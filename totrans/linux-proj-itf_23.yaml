- en: Chapter 23. Timers and Sleeping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A timer allows a process to schedule a notification for itself to occur at
    some time in the future. Sleeping allows a process (or thread) to suspend execution
    for a period of time. This chapter describes the interfaces used for setting timers
    and for sleeping. It covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: the classical UNIX APIs for setting interval timers (*setitimer()* and *alarm()*)
    to notify a process when a certain amount of time has passed;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the APIs that allow a process to sleep for a specified interval;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the POSIX.1b clocks and timers APIs; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the Linux-specific *timerfd* facility, which allows the creation of timers whose
    expirations can be read from a file descriptor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interval Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *setitimer()* system call establishes an *interval timer*, which is a timer
    that expires at a future point in time and (optionally) at regular intervals after
    that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'Using *setitimer()*, a process can establish three different types of timers,
    by specifying *which* as one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ITIMER_REAL`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a timer that counts down in real (i.e., wall clock) time. When the timer
    expires, a `SIGALRM` signal is generated for the process.
  prefs: []
  type: TYPE_NORMAL
- en: '`ITIMER_VIRTUAL`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a timer that counts down in process virtual time (i.e., user-mode CPU
    time). When the timer expires, a `SIGVTALRM` signal is generated for the process.
  prefs: []
  type: TYPE_NORMAL
- en: '`ITIMER_PROF`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a *profiling* timer. A profiling timer counts in process time (i.e.,
    the sum of both user-mode and kernel-mode CPU time). When the timer expires, a
    `SIGPROF` signal is generated for the process.
  prefs: []
  type: TYPE_NORMAL
- en: The default disposition of all of the timer signals is to terminate the process.
    Unless this is the desired result, we must establish a handler for the signal
    delivered by the timer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *new_value* and *old_value* arguments are pointers to *itimerval* structures,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the fields in the *itimerval* structure is in turn a structure of type
    *timeval*, containing seconds and microseconds fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The *it_value* substructure of the *new_value* argument specifies the delay
    until the timer is to expire. The *it_interval* substructure specifies whether
    this is to be a periodic timer. If both fields of *it_interval* are set to 0,
    then the timer expires just once, at the time given by *it_value*. If one or both
    of the *it_interval* fields are nonzero, then, after each expiration of the timer,
    the timer will be reset to expire again at the specified interval.
  prefs: []
  type: TYPE_NORMAL
- en: A process has only one of each of the three types of timers. If we call *setitimer()*
    a second time, it will change the characteristics of any existing timer corresponding
    to *which*. If we call *setitimer()* with both fields of *new_value.it_value*
    set to 0, then any existing timer is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: If *old_value* is not `NULL`, then it points to an *itimerval* structure that
    is used to return the previous value of the timer. If both fields of *old_value.it_value*
    are 0, then the timer was previously disabled. If both fields of *old_value.it_interval*
    are 0, then the previous timer was set to expire just once, at the time given
    by *old_value.it_value*. Retrieving the previous settings of the timer can be
    useful if we want to restore the settings after the new timer has expired. If
    we are not interested in the previous value of the timer, we can specify *old_value*
    as `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: As a timer progresses, it counts down from the initial value (*it_value*) toward
    0\. When the timer reaches 0, the corresponding signal is sent to the process,
    and then, if the interval (*it_interval*) is nonzero, the timer value (*it_value*)
    is reloaded, and counting down toward 0 recommences.
  prefs: []
  type: TYPE_NORMAL
- en: At any time, we can use *getitimer()* to retrieve the current state of the timer
    in order to see how much time is left before it next expires.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *getitimer()* system call returns the current state of the timer specified
    by *which*, in the buffer pointed to by *curr_value*. This is exactly the same
    information as is returned via the *old_value* argument of *setitimer()*, with
    the difference that we don’t need to change the timer settings in order to retrieve
    the information. The *curr_value.it_value* substructure returns the amount of
    time remaining until the timer next expires. This value changes as the timer counts
    down, and is reset on timer expiration if a nonzero *it_interval* value was specified
    when the timer was set. The *curr_value.it_interval* substructure returns the
    interval for this timer; this value remains unchanged until a subsequent call
    to *setitimer()*.
  prefs: []
  type: TYPE_NORMAL
- en: Timers established using *setitimer()* (and *alarm()*, which we discuss shortly)
    are preserved across *exec()*, but are not inherited by a child created by *fork()*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv4 marks *getitimer()* and *setitimer()* obsolete, noting that the POSIX
    timers API ([POSIX Interval Timers](ch23.html#posix_interval_timers "POSIX Interval
    Timers")) is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 23-1](ch23.html#using_a_real-time_timer "Example 23-1. Using a real-time
    timer") demonstrates the use of *setitimer()* and *getitimer()*. This program
    performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish a handler for the `SIGALRM` signal ![](figs/web/U003.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the value and interval fields for a real (`ITIMER_REAL`) timer using the
    values supplied in its command-line arguments ![](figs/web/U004.png). If these
    arguments are absent, the program sets a timer that expires just once, after 2
    seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute a continuous loop ![](figs/web/U005.png), consuming CPU time and periodically
    calling the function *displayTimes()* ![](figs/web/U001.png), which displays the
    elapsed real time since the program began, as well as the current state of the
    `ITIMER_REAL` timer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time the timer expires, the `SIGALRM` handler is invoked, and it sets a
    global flag, *gotAlarm* ![](figs/web/U002.png). Whenever this flag is set, the
    loop in the main program calls *displayTimes()* in order to show when the handler
    was called and the state of the timer ![](figs/web/U006.png). (We designed the
    signal handler in this manner to avoid calling non-async-signal-functions from
    within the handler, for the reasons described in [Reentrant and Async-Signal-Safe
    Functions](ch21.html#reentrant_and_async-signal-safe_function "Reentrant and Async-Signal-Safe
    Functions").) If the timer has a zero interval, then the program exits on delivery
    of the first signal; otherwise, it catches up to three signals before terminating
    ![](figs/web/U007.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the program in [Example 23-1](ch23.html#using_a_real-time_timer
    "Example 23-1. Using a real-time timer"), we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 23-1. Using a real-time timer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A simpler timer interface: *alarm()*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *alarm()* system call provides a simple interface for establishing a real-time
    timer that expires once, with no repeating interval. (Historically, *alarm()*
    was the original UNIX API for setting a timer.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always succeeds, returning number of seconds remaining on any previously set
    timer, or 0 if no timer previously was set
  prefs: []
  type: TYPE_NORMAL
- en: The *seconds* argument specifies the number of seconds in the future when the
    timer is to expire. At that time, a `SIGALRM` signal is delivered to the calling
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a timer with *alarm()* overrides any previously set timer. We can disable
    an existing timer using the call *alarm(0)*.
  prefs: []
  type: TYPE_NORMAL
- en: As its return value, *alarm()* gives us the number of seconds remaining until
    the expiration of any previously set timer, or 0 if no timer was set.
  prefs: []
  type: TYPE_NORMAL
- en: An example of the use of *alarm()* is shown in Section 23.3.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some later example programs in this book, we use *alarm()* to start a timer
    without establishing a corresponding `SIGALRM` handler, as a technique for ensuring
    that a process is killed if it is not otherwise terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions between *setitimer()* and *alarm()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Linux, *alarm()* and *setitimer()* share the same per-process real-time
    timer, which means that setting a timer with one of these functions changes any
    timer previously set by either of the functions. This may not be the case on other
    UNIX implementations (i.e., these functions could control independent timers).
    SUSv3 explicitly leaves unspecified the interactions between *setitimer()* and
    *alarm()*, as well as the interactions of these functions with the *sleep()* function
    described in [Low-Resolution Sleeping: *sleep()*](ch23.html#low-resolution_sleeping_colon_sleep_open
    "Low-Resolution Sleeping: sleep()"). For maximum portability, we should ensure
    that our applications use only one of *setitimer()* and *alarm()* for setting
    real-time timers.'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling and Accuracy of Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on system load and the scheduling of processes, a process may not
    be scheduled to run until some short time (i.e., usually some small fraction of
    a second) after actual expiration of the timer. Notwithstanding this, the expiration
    of a periodic timer established by *setitimer()*, or the other interfaces described
    later in this chapter, will remain regular. For example, if a real-time timer
    is set to expire every 2 seconds, then the delivery of individual timer events
    may be subject to the delays just described, but the scheduling of subsequent
    expirations will nevertheless be at exactly the next 2-second interval. In other
    words, interval timers are not subject to creeping errors.
  prefs: []
  type: TYPE_NORMAL
- en: Although the *timeval* structure used by *setitimer()* allows for microsecond
    precision, the accuracy of a timer has traditionally been limited by the frequency
    of the software clock ([The Software Clock (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff
    "The Software Clock (Jiffies)")). If a timer value does not exactly match a multiple
    of the granularity of the software clock, then the timer value is rounded up.
    This means that if, for example, we specified an interval timer to go off each
    19,100 microseconds (i.e., just over 19 milliseconds), then, assuming a jiffy
    value of 4 milliseconds, we would actually get a timer that expired every 20 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: High-resolution timers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On modern Linux kernels, the preceding statement that timer resolution is limited
    by the frequency of the software clock no longer holds true. Since kernel 2.6.21,
    Linux optionally supports high-resolution timers. If this support is enabled (via
    the `CONFIG_HIGH_RES_TIMERS` kernel configuration option), then the accuracy of
    the various timer and sleep interfaces that we describe in this chapter is no
    longer constrained by the size of the kernel jiffy. Instead, these calls can be
    as accurate as the underlying hardware allows. On modern hardware, accuracy down
    to a microsecond is typical.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The availability of high-resolution timers can be determined by examining the
    clock resolution returned by *clock_getres()*, described in [Retrieving the Value
    of a Clock: *clock_gettime()*](ch23.html#retrieving_the_value_of_a_clock_colon_cl
    "Retrieving the Value of a Clock: clock_gettime()").'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Timeouts on Blocking Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One use of real-time timers is to place an upper limit on the time for which
    a blocking system call can remain blocked. For example, we may wish to cancel
    a *read()* from a terminal if the user has not entered a line of input within
    a certain time. We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Call *sigaction()* to establish a handler for `SIGALRM`, omitting the `SA_RESTART`
    flag, so that system calls are not restarted (refer to [Interruption and Restarting
    of System Calls](ch21.html#interruption_and_restarting_of_system_ca "Interruption
    and Restarting of System Calls")).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call *alarm()* or *setitimer()* to establish a timer specifying the upper limit
    of time for which we wish the system call to block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the blocking system call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the system call returns, call *alarm()* or *setitimer()* once more to
    disable the timer (in case the system call completed before the timer expired).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check to see whether the blocking system call failed with *errno* set to `EINTR`
    (interrupted system call).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Example 23-2](ch23.html#performing_a_read_open_parenthesis_close "Example 23-2. Performing
    a read() with timeout") demonstrates this technique for *read()*, using *alarm()*
    to establish the timer.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-2. Performing a *read()* with timeout
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is a theoretical race condition in the program in [Example 23-2](ch23.html#performing_a_read_open_parenthesis_close
    "Example 23-2. Performing a read() with timeout"). If the timer expires after
    the call to *alarm()*, but before the *read()* call is started, then the *read()*
    call won’t be interrupted by the signal handler. Since the timeout value used
    in scenarios like this is normally relatively large (at least several seconds)
    this is highly unlikely to occur, so that, in practice, this is a viable technique.
    [Stevens & Rago, 2005] proposes an alternative technique using *longjmp()*. A
    further alternative when dealing with I/O system calls is to use the timeout feature
    of the *select()* or *poll()* system calls ([Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models")), which also have the advantage of allowing us to simultaneously
    wait for I/O on multiple descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Suspending Execution for a Fixed Interval (Sleeping)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we want to suspend execution of a process for a fixed amount of time.
    While it is possible to do this using a combination of *sigsuspend()* and the
    timer functions already described, it is easier to use one of the sleep functions
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Low-Resolution Sleeping: *sleep()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *sleep()* function suspends execution of the calling process for the number
    of seconds specified in the *seconds* argument or until a signal is caught (thus
    interrupting the call).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on normal completion, or number of unslept seconds if prematurely
    terminated
  prefs: []
  type: TYPE_NORMAL
- en: If the sleep completes, *sleep()* returns 0\. If the sleep is interrupted by
    a signal, *sleep()* returns the number of remaining (unslept) seconds. As with
    timers set by *alarm()* and *setitimer()*, system load may mean that the process
    is rescheduled only at some (normally short) time after the completion of the
    *sleep()* call.
  prefs: []
  type: TYPE_NORMAL
- en: 'SUSv3 leaves possible interactions of *sleep()* with *alarm()* and *setitimer()*
    unspecified. On Linux, *sleep()* is implemented as a call to *nanosleep()* ([High-Resolution
    Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")), with the consequence that there is no interaction between
    *sleep()* and the timer functions. However, on many implementations, especially
    older ones, *sleep()* is implemented using *alarm()* and a handler for the `SIGALRM`
    signal. For portability, we should avoid mixing the use of *sleep()* with *alarm()*
    and *setitimer()*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'High-Resolution Sleeping: *nanosleep()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *nanosleep()* function performs a similar task to *sleep()*, but provides
    a number of advantages, including finer resolution when specifying the sleep interval.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on successfully completed sleep, or -1 on error or interrupted sleep
  prefs: []
  type: TYPE_NORMAL
- en: 'The *request* argument specifies the duration of the sleep interval and is
    a pointer to a structure of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The *tv_nsec* field specifies a nanoseconds value. It must be a number in the
    range 0 to 999,999,999.
  prefs: []
  type: TYPE_NORMAL
- en: A further advantage of *nanosleep()* is that SUSv3 explicitly specifies that
    it should not be implemented using signals. This means that, unlike the situation
    with *sleep()*, we can portably mix calls to *nanosleep()* with calls to *alarm()*
    or *setitimer()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is not implemented using signals, *nanosleep()* may still be interrupted
    by a signal handler. In this case, *nanosleep()* returns -1, with *errno* set
    to the usual `EINTR` and, if the argument *remain* is not `NULL`, the buffer it
    points to returns the remaining unslept time. If desired, we can use the returned
    value to restart the system call and complete the sleep. This is demonstrated
    in [Example 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p "Example 23-3. Using
    nanosleep()"). As command-line arguments, this program expects seconds and nanosecond
    values for *nanosleep()*. The program loops repeatedly, executing *nanosleep()*
    until the total sleep interval is passed. If *nanosleep()* is interrupted by the
    handler for `SIGINT` (generated by typing *Control-C*), then the call is restarted
    using the value returned in *remain*. When we run this program, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although *nanosleep()* allows nanosecond precision when specifying the sleep
    interval, the accuracy of the sleep interval is limited to the granularity of
    the software clock ([The Software Clock (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff
    "The Software Clock (Jiffies)")). If we specify an interval that is not a multiple
    of the software clock, then the interval is rounded up.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted earlier, on systems that support high-resolution timers, the accuracy
    of the sleep interval can be much finer than the granularity of the software clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'This rounding behavior means that if signals are received at a high rate, then
    there is a problem with the approach employed in the program in [Example 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p
    "Example 23-3. Using nanosleep()"). The problem is that each restart of *nanosleep()*
    will be subject to rounding errors, since the returned *remain* time is unlikely
    to be an exact multiple of the granularity of the software clock. Consequently,
    each restarted *nanosleep()* will sleep longer than the value returned in *remain*
    by the previous call. In the case of an extremely high rate of signal delivery
    (i.e., as or more frequent than the software clock granularity), the process may
    never be able to complete its sleep. On Linux 2.6, this problem can be avoided
    by making use of *clock_nanosleep()* with the `TIMER_ABSTIME` option. We describe
    *clock_nanosleep()* in [Improved High-Resolution Sleeping: *clock_nanosleep()*](ch23.html#improved_high-resolution_sleeping_colon
    "Improved High-Resolution Sleeping: clock_nanosleep()").'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Linux 2.4 and earlier, there is an eccentricity in the implementation of
    *nanosleep()*. Suppose that a process performing a *nanosleep()* call is stopped
    by a signal. When the process is later resumed via delivery of `SIGCONT`, then
    the *nanosleep()* call fails with the error `EINTR`, as expected. However, if
    the program subsequently restarts the *nanosleep()* call, then the time that the
    process has spent in the stopped state is *not* counted against the sleep interval,
    so that the process will sleep longer than expected. This eccentricity is eliminated
    in Linux 2.6, where the *nanosleep()* call automatically resumes on delivery of
    the `SIGCONT` signal, and the time spent in the sleep state is counted against
    the sleep interval.
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-3. Using *nanosleep()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: POSIX Clocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'POSIX clocks (originally defined in POSIX.1b) provide an API for accessing
    clocks that measure time with nanosecond precision. Nanosecond time values are
    represented using the same *timespec* structure as is used by *nanosleep()* ([High-Resolution
    Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")).'
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, programs using this API must be compiled with the *-lrt* option, in
    order to link against the *librt* (realtime) library.
  prefs: []
  type: TYPE_NORMAL
- en: The main system calls in the POSIX clocks API are *clock_gettime()*, which retrieves
    the current value of a clock; *clock_getres()*, which returns the resolution of
    a clock; and *clock_settime()*, which updates a clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving the Value of a Clock: *clock_gettime()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *clock_gettime()* system call returns the time according to the clock specified
    in *clockid*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The time value is returned in the timespec structure pointed to by *tp*. Although
    the *timespec* structure affords nanosecond precision, the granularity of the
    time value returned by *clock_gettime()* may be coarser than this. The *clock_getres()*
    system call returns a pointer to a *timespec* structure containing the resolution
    of the clock specified in *clockid*.
  prefs: []
  type: TYPE_NORMAL
- en: The *clockid_t* data type is a type specified by SUSv3 for representing a clock
    identifier. The first column of [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b
    clock types") lists the values that can be specified for *clockid*
  prefs: []
  type: TYPE_NORMAL
- en: Table 23-1. POSIX.1b clock types
  prefs: []
  type: TYPE_NORMAL
- en: '| Clock ID | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CLOCK_REALTIME` | Settable system-wide real-time clock |'
  prefs: []
  type: TYPE_TB
- en: '| `CLOCK_MONOTONIC` | Nonsettable monotonic clock |'
  prefs: []
  type: TYPE_TB
- en: '| `CLOCK_PROCESS_CPUTIME_ID` | Per-process CPU-time clock (since Linux 2.6.12)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CLOCK_THREAD_CPUTIME_ID` | Per-thread CPU-time clock (since Linux 2.6.12)
    |'
  prefs: []
  type: TYPE_TB
- en: The `CLOCK_REALTIME` clock is a system-wide clock that measures wall-clock time.
    By contrast with the `CLOCK_MONOTONIC` clock, the setting of this clock can be
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 specifies that the `CLOCK_MONOTONIC` clock measures time since some “unspecified
    point in the past” that doesn’t change after system startup. This clock is useful
    for applications that must not be affected by discontinuous changes to the system
    clock (e.g., a manual change to the system time). On Linux, this clock measures
    the time since system startup.
  prefs: []
  type: TYPE_NORMAL
- en: '`The CLOCK_PROCESS_CPUTIME_ID` clock measures the user and system CPU time
    consumed by the calling process. The `CLOCK_THREAD_CPUTIME_ID` clock performs
    the analogous task for an individual thread within a process.'
  prefs: []
  type: TYPE_NORMAL
- en: All of the clocks in [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b
    clock types") are specified in SUSv3, but only `CLOCK_REALTIME` is mandatory and
    widely supported on UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux 2.6.28 adds a new clock type, `CLOCK_MONOTONIC_RAW`, to those listed in
    [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b clock types").
    This is a nonsettable clock that is similar to `CLOCK_MONOTONIC`, but it gives
    access to a pure hardware-based time that is unaffected by NTP adjustments. This
    nonstandard clock is intended for use in specialized clock-synchronization applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux 2.6.32 adds two more new clocks to those listed in [Table 23-1](ch23.html#posix.1b_clock_types
    "Table 23-1. POSIX.1b clock types"): `CLOCK_REALTIME_COARSE` and `CLOCK_MONOTIC_COARSE`.
    These clocks are similar to `CLOCK_REALTIME` and `CLOCK_MONOTONIC`, but intended
    for applications that want to obtain lower-resolution timestamps at minimal cost.
    These nonstandard clocks don’t cause any access to the hardware clock (which can
    be expensive for some hardware clock sources), and the resolution of the returned
    value is the jiffy ([The Software Clock (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff
    "The Software Clock (Jiffies)")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the Value of a Clock: *clock_settime()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *clock_settime()* system call sets the clock specified by *clockid* to the
    time supplied in the buffer pointed to by *tp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: If the time specified by *tp* is not a multiple of the clock resolution as returned
    by *clock_getres()*, the time is rounded downward.
  prefs: []
  type: TYPE_NORMAL
- en: A privileged (`CAP_SYS_TIME`) process may set the `CLOCK_REALTIME` clock. The
    initial value of this clock is typically the time since the Epoch. None of the
    other clocks in [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b
    clock types") are modifiable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to SUSv3, an implementation may allow the `CLOCK_PROCESS_CPUTIME_ID`
    and `CLOCK_THREAD_CPUTIME_ID` clocks to be settable. At the time of writing, these
    clocks are read-only on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the Clock ID of a Specific Process or Thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions described in this section allow us to obtain the ID of a clock
    that measures the CPU time consumed by a particular process or thread. We can
    use the returned clock ID in a call to *clock_gettime()* in order to find out
    the CPU time consumed by the process or thread.
  prefs: []
  type: TYPE_NORMAL
- en: The *clock_getcpuclockid()* function returns the identifier of the CPU-time
    clock of the process whose ID is *pid*, in the buffer pointed to by *clockid*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or a positive error number on error
  prefs: []
  type: TYPE_NORMAL
- en: If *pid* is 0, *clock_getcpuclockid()* returns the ID of the CPU-time clock
    of the calling process.
  prefs: []
  type: TYPE_NORMAL
- en: The *pthread_getcpuclockid()* function is the POSIX threads analog of the *clock_getcpuclockid()*
    function. It returns the identifier of the clock measuring the CPU time consumed
    by a specific thread of the calling process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or a positive error number on error
  prefs: []
  type: TYPE_NORMAL
- en: The *thread* argument is a POSIX thread ID that identifies the thread whose
    CPU-time clock ID we want to obtain. The clock ID is returned in the buffer pointed
    to by *clockid*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Improved High-Resolution Sleeping: *clock_nanosleep()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like *nanosleep()*, the Linux-specific *clock_nanosleep()* system call suspends
    the calling process until either a specified interval of time has passed or a
    signal arrives. In this section, we describe the features that distinguish *clock_nanosleep()*
    from *nanosleep()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on successfully completed sleep, or a positive error number on error
    or interrupted sleep
  prefs: []
  type: TYPE_NORMAL
- en: The *request* and *remain* arguments serve similar purposes to the analogous
    arguments for *nanosleep()*.
  prefs: []
  type: TYPE_NORMAL
- en: By default (i.e., if *flags* is 0), the sleep interval specified in *request*
    is relative (like *nanosleep()*). However, if we specify `TIMER_ABSTIME` in *flags*
    (see the example in [Example 23-4](ch23.html#using_clock_underscore_nanosleep_open_pa
    "Example 23-4. Using clock_nanosleep()")), then *request* specifies an absolute
    time as measured by the clock identified by *clockid*. This feature is essential
    in applications that need to sleep accurately until a specific time. If we instead
    try retrieving the current time, calculating the difference until the desired
    target time, and doing a relative sleep, then there is a possibility that the
    process may be preempted in the middle of these steps, and consequently sleep
    for longer than desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'As described in [High-Resolution Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "High-Resolution Sleeping: nanosleep()"), this “oversleeping” problem is particularly
    marked for a process that uses a loop to restart a sleep that is interrupted by
    a signal handler. If signals are delivered at a high rate, then a relative sleep
    (of the type performed by *nanosleep()*) can lead to large inaccuracies in the
    time a process spends sleeping. We can avoid the oversleeping problem by making
    an initial call to *clock_gettime()* to retrieve the time, adding the desired
    amount to that time, and then calling *clock_nanosleep()* with the `TIMER_ABSTIME`
    flag (and restarting the system call if it is interrupted by a signal handler).'
  prefs: []
  type: TYPE_NORMAL
- en: When the `TIMER_ABSTIME` flag is specified, the *remain* argument is unused
    (it is unnecessary). If the *clock_nanosleep()* call is interrupted by a signal
    handler, then the sleep can be restarted by repeating the call with the same *request*
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that distinguishes *clock_nanosleep()* from *nanosleep()* is
    that we can choose the clock that is used to measure the sleep interval. We specify
    the desired clock in *clockid*: `CLOCK_REALTIME`, `CLOCK_MONOTONIC`, or `CLOCK_PROCESS_CPUTIME_ID`.
    See [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b clock types")
    for a description of these clocks.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 23-4](ch23.html#using_clock_underscore_nanosleep_open_pa "Example 23-4. Using
    clock_nanosleep()") demonstrates the use of *clock_nanosleep()* to sleep for 20
    seconds against the `CLOCK_REALTIME` clock using an absolute time value.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-4. Using *clock_nanosleep()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: POSIX Interval Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classical UNIX interval timers set by *setitimer()* suffer a number of
    limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: We can set only one timer of each of the three types, `ITIMER_REAL`, `ITIMER_VIRTUAL`,
    and `ITIMER_PROF`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only way of being notified of timer expiration is via delivery of a signal.
    Furthermore, we can’t change the signal that is generated when the timer expires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an interval timer expires multiple times while the corresponding signal is
    blocked, then the signal handler is called only once. In other words, we have
    no way of knowing whether there was a *timeroverrun*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers are limited to microsecond resolution. However, some systems have hardware
    clocks that provide finer resolution than this, and, on such systems, it is desirable
    to have software access to this greater resolution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX.1b defined an API to address these limitations, and this API is implemented
    in Linux 2.6.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On older Linux systems, an incomplete version of this API was provided via a
    threads-based implementation in *glibc*. However, this user-space implementation
    doesn’t provide all of the features described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The POSIX timer API divides the life of a timer into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The *timer_create()* system call creates a new timer and defines the method
    by which it will notify the process when it expires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *timer_settime()* system call arms (starts) or disarms (stops) a timer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *timer_delete()* system call deletes a timer that is no longer required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX timers are not inherited by a child created by *fork()*. They are disarmed
    and deleted during an *exec()* or on process termination.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, programs using the POSIX timer API must be compiled with the *-lrt*
    option, in order to link against the *librt* (realtime) library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Timer: *timer_create()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *timer_create()* function creates a new timer that measures time using the
    clock specified by *clockid*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *clockid* can specify any of the values shown in [Table 23-1](ch23.html#posix.1b_clock_types
    "Table 23-1. POSIX.1b clock types"), or the *clockid* value returned by *clock_getcpuclockid()*
    or *pthread_getcpuclockid()*. The *timerid* argument points to a buffer that returns
    a handle used to refer to the timer in later system calls. This buffer is typed
    as *timer_t*, which is a data type specified by SUSv3 for representing a timer
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *evp* argument determines how the program is to be notified when the timer
    expires. It points to a structure of type *sigevent*, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The *sigev_notify* field of this structure is set to one of the values shown
    in [Table 23-2](ch23.html#values_for_the_sigev_underscore_notify_f "Table 23-2. Values
    for the sigev_notify field of the sigevent structure").
  prefs: []
  type: TYPE_NORMAL
- en: Table 23-2. Values for the *sigev_notify* field of the *sigevent* structure
  prefs: []
  type: TYPE_NORMAL
- en: '| *sigev_notify* value | Notification method | SUSv3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_NONE` | No notification; monitor timer using *timer_gettime()* | •
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_SIGNAL` | Send signal *sigev_signo* to process | • |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_THREAD` | Call *sigev_notify_function* as start function of new thread
    | • |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGEV_THREAD_ID` | Send signal *sigev_signo* to thread *sigev_notify_thread_id*
    |   |'
  prefs: []
  type: TYPE_TB
- en: 'Further details on the *sigev_notify* field constants, and the fields in the
    *sigval* structure that are associated with each constant value, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGEV_NONE`'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t provide notification of timer expiration. The process can still monitor
    the progress of the timer using *timer_gettime()*.
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGEV_SIGNAL`'
  prefs: []
  type: TYPE_NORMAL
- en: When the timer expires, generate the signal specified in the *sigev_signo* field
    for the process. The *sigev_value* field specifies data (an integer or a pointer)
    to accompany the signal ([Limits on the number of queued realtime signals](ch22.html#limits_on_the_number_of_queued_real-id1
    "Limits on the number of queued realtime signals")). This data can be retrieved
    via the *si_value* field of the *siginfo_t* structure that is passed to the handler
    for this signal or returned by a call to *sigwaitinfo()* or *sigtimedwait()*.
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGEV_THREAD`'
  prefs: []
  type: TYPE_NORMAL
- en: When the timer expires, call the function specified in the *sigev_notify_function*
    field. This function is invoked *as if* it were the start function in a new thread.
    The “as if ” wording is from SUSv3, and allows an implementation to generate the
    notifications for a periodic timer either by having each notification delivered
    to a new unique thread or by having the notifications delivered in series to a
    single new thread. The *sigev_notify_attributes* field can be specified as `NULL`
    or as a pointer to a *pthread_attr_t* structure that defines attributes for the
    thread ([Thread Attributes](ch29.html#thread_attributes "Thread Attributes")).
    The union *sigval* value specified in *sigev_value* is passed as the sole argument
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGEV_THREAD_ID`'
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to `SIGEV_SIGNAL`, but the signal is sent to the thread whose
    thread ID matches *sigev_notify_thread_id*. This thread must be in the same process
    as the calling thread. (With `SIGEV_SIGNAL` notification, a signal is queued to
    the process as a whole, and, if there are multiple threads in the process, the
    signal will be delivered to an arbitrarily selected thread in the process.) The
    *sigev_notify_thread_id* field can be set to the value returned by *clone()* or
    the value returned by *gettid()*. The `SIGEV_THREAD_ID` flag is intended for use
    by threading libraries. (It requires a threading implementation that employs the
    `CLONE_THREAD` option, described in [Example program](ch28.html#example_program-id39
    "Example program"). The modern NPTL threading implementation employs `CLONE_THREAD`,
    but the older LinuxThreads threading implementation does not.)
  prefs: []
  type: TYPE_NORMAL
- en: All of the above constants are specified in SUSv3, except for `SIGEV_THREAD_ID`,
    which is Linux-specific.
  prefs: []
  type: TYPE_NORMAL
- en: The *evp* argument may be specified as `NULL`, which is equivalent to specifying
    *sigev_notify* as `SIGEV_SIGNAL`, *sigev_signo* as `SIGALRM` (this may be different
    on other systems, since SUSv3 merely says “a default signal number”), and *sigev_value.sival_int*
    as the timer ID.
  prefs: []
  type: TYPE_NORMAL
- en: As currently implemented, the kernel preallocates one queued realtime signal
    structure for each POSIX timer that is created using *timer_create()*. The intent
    of this preallocation is to ensure that at least one such structure is available
    for queuing a signal when the timer expires. This means that the number of POSIX
    timers that may be created is subject to the limitations on the number of realtime
    signals that can be queued (refer to [Realtime Signals](ch22.html#realtime_signals
    "Realtime Signals")).
  prefs: []
  type: TYPE_NORMAL
- en: 'Arming and Disarming a Timer: *timer_settime()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have created a timer, we can arm (start) or disarm (stop) it using *timer_settime()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *timerid* argument of *timer_settime()* is a timer handle returned by a
    previous call to *timer_create()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *value* and *old_value* arguments are analogous to the *setitimer()* arguments
    of the same name: *value* specifies the new settings for the timer, and *old_value*
    is used to return the previous timer settings (see the description of *timer_gettime()*
    below). If we are not interested in the previous settings, we can specify *old_value*
    as `NULL`. The *value* and *old_value* arguments are pointers to *itimerspec*
    structures, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the fields of the *itimerspec* structure is in turn a structure of
    type *timespec*, which specifies time values as a number of seconds and nanoseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The *it_value* field specifies when the timer will first expire. If either subfield
    of *it_interval* is nonzero, then this is a periodic timer that, after the initial
    expiry specified by *it_value*, will expire with the frequency specified in these
    subfields. If both subfields of *it_interval* are 0, this timer expires just once.
  prefs: []
  type: TYPE_NORMAL
- en: If *flags* is specified as 0, then *value.it_value* is interpreted relative
    to the clock value at the time of the call to *timer_settime()* (i.e., like *setitimer()*).
    If *flags* is specified as `TIMER_ABSTIME`, then *value.it_value* is interpreted
    as an absolute time (i.e., measured from the clock’s zero point). If that time
    has already passed on the clock, the timer expires immediately.
  prefs: []
  type: TYPE_NORMAL
- en: To arm a timer, we make a call to *timer_settime()* in which either or both
    of the subfields of *value.it_value* are nonzero. If the timer was previously
    armed, *timer_settime()* replaces the previous settings.
  prefs: []
  type: TYPE_NORMAL
- en: If the timer value and interval are not multiples of the resolution of the corresponding
    clock (as returned by *clock_getres()*), these values are rounded up to the next
    multiple of the resolution.
  prefs: []
  type: TYPE_NORMAL
- en: On each expiration of the timer, the process is notified using the method defined
    in the *timer_create()* call that created this timer. If the *it_interval* structure
    contains nonzero values, these values are used to reload the *it_value* structure.
  prefs: []
  type: TYPE_NORMAL
- en: To disarm a timer, we make a call to *timer_settime()* specifying both fields
    of *value.it_value* as 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving the Current Value of a Timer: *timer_gettime()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *timer_gettime()* system call returns the interval and remaining time for
    the POSIX timer identified by *timerid*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The interval and the time until the next expiration of the timer are returned
    in the *itimerspec* structure pointed to by *curr_value*. The *curr_value.it_value*
    field returns the time until next timer expiration, even if this timer was established
    as an absolute timer using `TIMER_ABSTIME`.
  prefs: []
  type: TYPE_NORMAL
- en: If both fields of the returned *curr_value.it_value* structure are 0, then the
    timer is currently disarmed. If both fields of the returned *curr_value.it_interval*
    structure are 0, then the timer expires just once, at the time given in *curr_value.it_value*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting a Timer: *timer_delete()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each POSIX timer consumes a small amount of system resources. Therefore, when
    we have finished using a timer, we should free these resources by using *timer_delete()*
    to remove the timer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *timerid* argument is a handle returned by a previous call to *timer_create()*.
    If the timer was armed, then it is automatically disarmed before removal. If there
    is already a pending signal from an expiration of this timer, that signal remains
    pending. (SUSv3 leaves this point unspecified, so other UNIX implementations may
    behave differently.) Timers are deleted automatically when a process terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Notification via a Signal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we elect to receive timer notifications via a signal, then we can accept
    the signal via a signal handler, or by calling *sigwaitinfo()* or *sigtimedwait()*.
    Both mechanisms allow the receiving process to obtain a *siginfo_t* structure
    ([The `SA_SIGINFO` Flag](ch21.html#the_sa_underscore_siginfo_flag "The SA_SIGINFO
    Flag")) that provides further information about the signal. (To take advantage
    of this feature in a signal handler, we specify the `SA_SIGINFO` flag when establishing
    the handler.) The following fields are set in the *siginfo_t* structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '*si_signo*: This field contains the signal generated by this timer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*si_code*: This field is set to `SI_TIMER`, indicating that this signal was
    generated because of the expiration of a POSIX timer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*si_value*: This field is set to the value that was supplied in *evp.sigev_value*
    when the timer was created using *timer_create()*. Specifying different *evp.sigev_value*
    values provides a means of distinguishing expirations of multiple timers that
    deliver the same signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When calling *timer_create()*, *evp.sigev_value.sival_ptr* is typically assigned
    the address of the *timerid* argument given in the same call (see [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal")). This allows the signal
    handler (or the *sigwaitinfo()* call) to obtain the ID of the timer that generated
    the signal. (Alternatively, *evp.sigev_value.sival_ptr* may be assigned the address
    of a structure that contains the *timerid* given to *timer_create()*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux also supplies the following nonstandard field in the *siginfo_t* structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '*si_overrun*: This field contains the overrun count for this timer (described
    in [Timer Overruns](ch23.html#timer_overruns "Timer Overruns")).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Linux also supplies another nonstandard field: *si_timerid*. This field contains
    an identifier that is used internally by the system to identify the timer (it
    is not the same as the ID returned by *timer_create()*). It is not useful to applications.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Example 23-5](ch23.html#posix_timer_notification_using_a_signal "Example 23-5. POSIX
    timer notification using a signal") demonstrates the use of signals as the notification
    mechanism for a POSIX timer.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-5. POSIX timer notification using a signal
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the command-line arguments of the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") specifies the initial
    value and interval for a timer. The syntax of these arguments is described in
    the program’s “usage” message and demonstrated in the shell session below. This
    program performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish a handler for the signal that is used for timer notifications ![](figs/web/U002.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each command-line argument, create ![](figs/web/U004.png) and arm ![](figs/web/U005.png)
    a POSIX timer that uses the `SIGEV_SIGNAL` notification mechanism. The *itimerspecFromStr()*
    function that we use to convert ![](figs/web/U003.png)the command-line arguments
    to *itimerspec* structures is shown in [Example 23-6](ch23.html#converting_time-plus-interval_string_to
    "Example 23-6. Converting time-plus-interval string to an itimerspec value").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On each timer expiration, the signal specified in *sev.sigev_signo* will be
    delivered to the process. The handler for this signal displays the value that
    was supplied in *sev.sigev_value.sival_ptr* (i.e., the timer ID, *tidlist[j]*)
    and the overrun value for the timer ![](figs/web/U001.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having created and armed the timers, wait for timer expirations by executing
    a loop that repeatedly calls *pause()*![](figs/web/U006.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 23-6](ch23.html#converting_time-plus-interval_string_to "Example 23-6. Converting
    time-plus-interval string to an itimerspec value") shows the function that converts
    each of the command-line arguments for the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") into a corresponding
    *itimerspec* structure. The format of the string arguments interpreted by this
    function is shown in a comment at the top of the listing (and demonstrated in
    the shell session below).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-6. Converting time-plus-interval string to an *itimerspec* value
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We demonstrate the use of the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") in the following shell
    session, creating a single timer with an initial timer expiry of 2 seconds and
    an interval of 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After suspending the program, we pause for a few seconds, allowing several
    timer expirations to occur before we resume the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The last line of program output shows that five timer overruns occurred, meaning
    that six timer expirations occurred since the previous signal delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Timer Overruns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose that we have chosen to receive notification of timer expiration via
    delivery of a signal (i.e., *sigev_notify* is `SIGEV_SIGNAL`). Suppose further
    that the timer expires multiple times before the associated signal is caught or
    accepted. This could occur as the result of a delay before the process is next
    scheduled. Alternatively, it could occur because delivery of the associated signal
    was blocked, either explicitly via *sigprocmask()*, or implicitly during the execution
    of the handler for the signal. How do we know that such *timer overruns* have
    happened?
  prefs: []
  type: TYPE_NORMAL
- en: 'We might suppose that using a realtime signal would help solve this problem,
    since multiple instances of a realtime signal are queued. However, this approach
    turns out to be unworkable, because there are limits on the number of realtime
    signals that can be queued. Therefore, the POSIX.1b committee decided on a different
    approach: if we choose to receive timer notification via a signal, then multiple
    instances of the signal are never queued, even if we use a realtime signal. Instead,
    after receiving the signal (either via a signal handler or by using *sigwaitinfo()*),
    we can fetch the *timer overrun count*, which is the number of extra timer expirations
    that occurred between the time the signal was generated and the time it was received.
    For example, if the timer has expired three times since the last signal was received,
    then the overrun count is 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After receiving a timer signal, we can obtain the timer overrun count in two
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Call *timer_getoverrun()*, which we describe below. This is the SUSv3-specified
    way of obtaining the overrun count.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the value in the *si_overrun* field of the *siginfo_t* structure returned
    with the signal. This approach saves the overhead of the *timer_getoverrun()*
    system call, but is a nonportable Linux extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timer overrun count is reset each time we receive the timer signal. If the
    timer expired just once since the timer signal was handled or accepted, then the
    overrun count will be 0 (i.e., there were no overruns).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns timer overrun count on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *timer_getoverrun()* function returns the overrun count for the timer specified
    by its *timerid* argument.
  prefs: []
  type: TYPE_NORMAL
- en: The *timer_getoverrun()* function is one of those specified as being async-signal-safe
    in SUSv3 ([Table 21-1](ch21.html#functions_required_to_be_async-signal-sa "Table 21-1. Functions
    required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3"), in [Use
    of *errno* inside signal handlers](ch21.html#use_of_errno_inside_signal_handlers
    "Use of errno inside signal handlers")), so it is safe to call it from within
    a signal handler.
  prefs: []
  type: TYPE_NORMAL
- en: Notification via a Thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SIGEV_THREAD` flag allows a program to obtain notification of timer expiration
    via the invocation of a function in a separate thread. Understanding this flag
    requires knowledge of POSIX threads that we present later, in [Chapter 29](ch29.html
    "Chapter 29. Threads: Introduction") and [Chapter 30](ch30.html "Chapter 30. Threads:
    Thread Synchronization"). Readers unfamiliar with POSIX threads may want to read
    those chapters before examining the example program that we present in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 23-7](ch23.html#posix_timer_notification_using_a_thread "Example 23-7. POSIX
    timer notification using a thread function") demonstrates the use of `SIGEV_THREAD`.
    This program takes the same command-line arguments as the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal"). The program performs
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: For each command-line argument, the program creates ![](figs/web/U006.png) and
    arms ![](figs/web/U007.png) a POSIX timer that uses the `SIGEV_THREAD` notification
    mechanism ![](figs/web/U003.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time this timer expires, the function specified by *sev.sigev_notify_function*
    ![](figs/web/U004.png) will be invoked in a separate thread. When this function
    is invoked, it receives the value specified in *sev.sigev_value.sival_ptr* as
    an argument. We assign the address of the timer ID (*tidlist[j]*) to this field
    ![](figs/web/U005.png) so that the notification function can obtain the ID of
    the timer that caused its invocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having created and armed all of the timers, the main program enters a loop that
    waits for timer expirations ![](figs/web/U008.png). Each time through the loop,
    the program uses *pthread_cond_wait()* to wait for a condition variable (*cond*)
    to be signaled by the thread that is handling a timer notification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *threadFunc()* function is invoked on each timer expiration ![](figs/web/U001.png).
    After printing a message, it increments the value of the global variable *expireCnt*.
    To allow for the possibility of timer overruns, the value returned by *timer_getoverrun()*
    is also added to *expireCnt*. (We explained timer overruns in [Timer Overruns](ch23.html#timer_overruns
    "Timer Overruns") in relation to the `SIGEV_SIGNAL` notification mechanism. Timer
    overruns can also come into play with the `SIGEV_THREAD` mechanism, because a
    timer might expire multiple times before the notification function is invoked.)
    The notification function also signals the condition variable *cond* so that the
    main program knows to check that a timer has expired ![](figs/web/U002.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shell session log demonstrates the use of the program in [Example 23-7](ch23.html#posix_timer_notification_using_a_thread
    "Example 23-7. POSIX timer notification using a thread function"). In this example,
    the program creates two timers: one with an initial expiry of 5 seconds and an
    interval of 5 seconds, and the other with an initial expiration of 10 seconds
    and an interval of 10 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Example 23-7. POSIX timer notification using a thread function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Timers That Notify via File Descriptors: The *timerfd* API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.25, Linux provides another API for creating timers.
    The Linux-specific *timerfd* API creates a timer whose expiration notifications
    can be read from a file descriptor. This is useful because the file descriptor
    can be monitored along with other descriptors using *select()*, *poll()*, and
    *epoll* (described in [Chapter 63](ch63.html "Chapter 63. Alternative I/O Models")).
    (With the other timer APIs discussed in this chapter, it requires some effort
    to be able to simultaneously monitor one or more timers along with a set of file
    descriptors.)
  prefs: []
  type: TYPE_NORMAL
- en: The operation of the three new system calls in this API is analogous to the
    operation of the *timer_create()*, *timer_settime()*, and *timer_gettime()* system
    calls described in Section 23.6.
  prefs: []
  type: TYPE_NORMAL
- en: The first of the new system calls is *timerfd_create()*, which creates a new
    timer object and returns a file descriptor referring to that object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The value of *clockid* can be either `CLOCK_REALTIME` or `CLOCK_MONOTONIC` (see
    [Table 23-1](ch23.html#posix.1b_clock_types "Table 23-1. POSIX.1b clock types")).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initial implementation of *timerfd_create()*, the *flags* argument was
    reserved for future use and had to be specified as 0\. However, since Linux 2.6.27,
    two flags are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TFD_CLOEXEC`'
  prefs: []
  type: TYPE_NORMAL
- en: Set the close-on-exec flag (`FD_CLOEXEC`) for the new file descriptor. This
    flag is useful for the same reasons as the *open()* `O_CLOEXEC` flag described
    in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()").
  prefs: []
  type: TYPE_NORMAL
- en: '`TFD_NONBLOCK`'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `O_NONBLOCK` flag on the underlying open file description, so that future
    reads will be nonblocking. This saves additional calls to *fcntl()* to achieve
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: When we have finished using a timer created by *timerfd_create()*, we should
    *close()* the associated file descriptor, so that the kernel can free the resources
    associated with the timer.
  prefs: []
  type: TYPE_NORMAL
- en: The *timerfd_settime()* system call arms (starts) or disarms (stops) the timer
    referred to by the file descriptor *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *new_value* argument specifies the new settings for the timer. The *old_value*
    argument can be used to return the previous settings of the timer (see the description
    of *timerfd_gettime()* below for details). If we are not interested in the previous
    settings, we can specify *old_value* as `NULL`. Both of these arguments are *itimerspec*
    structures that are used in the same way as for *timer_settime()* (see [Arming
    and Disarming a Timer: *timer_settime()*](ch23.html#arming_and_disarming_a_timer_colon_timer
    "Arming and Disarming a Timer: timer_settime()")).'
  prefs: []
  type: TYPE_NORMAL
- en: The *flags* argument is similar to the corresponding argument for *timer_settime()*.
    It may either be 0, meaning that *new_value.it_value* is interpreted relative
    to the time of the call to *timerfd_settime()*, or it can be `TFD_TIMER_ABSTIME`,
    meaning that *new_value.it_value* is interpreted as an absolute time (i.e., measured
    from the clock’s zero point).
  prefs: []
  type: TYPE_NORMAL
- en: The *timerfd_gettime()* system call returns the interval and remaining time
    for the timer identified by the file descriptor *fd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: As with *timer_gettime()*, the interval and the time until the next expiration
    of the timer are returned in the *itimerspec* structure pointed to by *curr_value*.
    The *curr_value.it_value* field returns the time until the next timer expiration,
    even if this timer was established as an absolute timer using `TFD_TIMER_ABSTIME`.
    If both fields of the returned *curr_value.it_value* structure are 0, then the
    timer is currently disarmed. If both fields of the returned *curr_value.it_interval*
    structure are 0, then the timer expires just once, at the time given in *curr_value.it_value*.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions of *timerfd* with *fork()* and *exec()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During a *fork()*, a child process inherits copies of file descriptors created
    by *timerfd_create()*. These file descriptors refer to the same timer objects
    as the corresponding descriptors in the parent, and timer expirations can be read
    in either process.
  prefs: []
  type: TYPE_NORMAL
- en: File descriptors created by *timerfd_create()* are preserved across an *exec()*
    (unless the descriptors are marked close-on-exec, as described in [File Descriptors
    and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes "File Descriptors
    and exec()")), and armed timers will continue to generate timer expirations after
    the *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from the *timerfd* file descriptor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once we have armed a timer with *timerfd_settime()*, we can use *read()* to
    read information about timer expirations from the associated file descriptor.
    For this purpose, the buffer given to *read()* must be large enough to hold an
    unsigned 8-byte integer (*uint64_t*).
  prefs: []
  type: TYPE_NORMAL
- en: If one or more expirations have occurred since the timer settings were last
    modified using *timerfd_settime()* or the last *read()* was performed, then *read()*
    returns immediately, and the returned buffer contains the number of expirations
    that have occurred. If no timer expirations have occurred, then *read()* blocks
    until the next expiration occurs. It is also possible to use the *fcntl()* `F_SETFL`
    operation ([Open File Status Flags](ch05.html#open_file_status_flags "Open File
    Status Flags")) to set the `O_NONBLOCK` flag for the file descriptor, so that
    reads are nonblocking, and will fail with the error `EAGAIN` if no timer expirations
    have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, a *timerfd* file descriptor can be monitored using *select()*,
    *poll()*, and *epoll*. If the timer has expired, then the file descriptor indicates
    as being readable.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 23-8](ch23.html#using_the_timerfd_api "Example 23-8. Using the timerfd
    API") demonstrates the use of the *timerfd* API. This program takes two command-line
    arguments. The first argument is mandatory, and specifies the initial time and
    interval for a timer. (This argument is interpreted using the *itimerspecFromStr()*
    function shown in [Example 23-6](ch23.html#converting_time-plus-interval_string_to
    "Example 23-6. Converting time-plus-interval string to an itimerspec value").)
    The second argument, which is optional, specifies the maximum number of expirations
    of the timer that the program should wait for before terminating; the default
    for this argument is 1.'
  prefs: []
  type: TYPE_NORMAL
- en: The program creates a timer using *timerfd_create()*, and arms it using *timerfd_settime()*.
    It then loops, reading expiration notifications from the file descriptor until
    the specified number of expirations has been reached. After each *read()*, the
    program displays the time elapsed since the timer was started, the number of expirations
    read, and the total number of expirations so far.
  prefs: []
  type: TYPE_NORMAL
- en: In the following shell session log, the command-line arguments specify a timer
    with a 1-second initial value and 1-second interval, and a maximum of 100 expirations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: From the above output, we can see that multiple timer expirations occurred while
    the program was suspended in the background, and all of these expirations were
    returned on the first *read()* after the program resumed execution.
  prefs: []
  type: TYPE_NORMAL
- en: Example 23-8. Using the *timerfd* API
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A process can use *setitimer()* or *alarm()* to set a timer, so that it receives
    a signal after the passage of a specified amount of real or process time. One
    use of timers is to set an upper limit on the time for which a system call can
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that need to suspend execution for a specified interval of real
    time can use a variety of sleep functions for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux 2.6 implements the POSIX.1b extensions that define an API for high-precision
    clocks and timers. POSIX.1b timers provide a number of advantages over traditional
    (*setitimer()*) UNIX timers. We can: create multiple timers; choose the signal
    that is delivered on timer expiration; retrieve the timer overrun count in order
    to determine if a timer has expired multiple times since the last expiration notification;
    and choose to receive timer notifications via execution of a thread function instead
    of delivery of a signal.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux-specific *timerfd* API provides a set of interfaces for creating timers
    that is similar to the POSIX timers API, but allows timer notifications to be
    read via a file descriptor. This file descriptor can be monitored using *select()*,
    *poll()*, and *epoll*.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Under the rationale for individual functions, SUSv3 provides useful notes on
    the (standard) timer and sleep interface described in this chapter. [Gallmeister,
    1995] discusses POSIX.1b clocks and timers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although *alarm()* is implemented as a system call within the Linux kernel,
    this is redundant. Implement *alarm()* using *setitimer()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try running the program in [Example 23-3](ch23.html#using_nanosleep_open_parenthesis_close_p
    "Example 23-3. Using nanosleep()") (`t_nanosleep.c`) in the background with a
    60-second sleep interval, while using the following command to send as many `SIGINT`
    signals as possible to the background process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]; done`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should observe that the program sleeps rather longer than expected. Replace
    the use of *nanosleep()* with the use of *clock_gettime()* (use a `CLOCK_REALTIME`
    clock) and *clock_nanosleep()* with the `TIMER_ABSTIME` flag. (This exercise requires
    Linux 2.6.) Repeat the test with the modified program and explain the difference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write a program to show that if the *evp* argument to *timer_create()* is specified
    as `NULL`, then this is equivalent to specifying *evp* as a pointer to a *sigevent*
    structure with *sigev_notify* set to `SIGEV_SIGNAL`, *sigev_signo* set to `SIGALRM`,
    and *si_value.sival_int* set to the timer ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the program in [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") (`ptmr_sigev_signal.c`)
    to use *sigwaitinfo()* instead of a signal handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
