["```\nwhile true\n    println(\"Enter a number, or 0 to quit.\")\n    x = readline()\n    x = parse(Float64, x)\n    if x ≤ 0\n     ➊ break\n    end\n ➋ println(\"The square root is \", sqrt(x))\nend\n```", "```\nn = [12, 53, 19, 64, 16, 8]\n\nfor x in n\n    if round( √x ) == √x\n        println(\"Found a perfect square in the list: \", x)\n        break\n    end\nend\n```", "```\nFound a perfect square in the list: 64\n```", "```\nfor n in 1:100\n    possibly_prime = true\n    x = 2\n    while x ≤ √n\n     ➊ if n % x == 0\n            possibly_prime = false\n            break\n        end\n        x += 1\n    end\n    if !possibly_prime\n     ➋ continue\n    else\n        println(n)\n    end\nend\n```", "```\njulia> xs = [];\n\njulia> for x in 1:5\n           push!(xs, x^2)\n       end\n\njulia> xs\n5-element Vector{Any}:\n  1\n  4\n  9\n 16\n 25\n```", "```\njulia> xs = [x^2 for x in 1:5]\n5-element Vector{Int64}:\n  1\n  4\n  9\n 16\n 25\n```", "```\njulia> [2x for x in [1 2\n                     3 4]]\n2×2 Matrix{Int64}:\n 2  4\n 6  8\n```", "```\njulia> [x * y for x in 1:3 for y in 1:3]\n9-element Vector{Int64}:\n 1\n 2\n 3\n 2\n 4\n 6\n 3\n 6\n 9\n\njulia> [x * y for x in 1:3, y in 1:3]\n3×3 Matrix{Int64}:\n 1  2  3\n 2  4  6\n 3  6  9\n```", "```\njulia> [x * y for x in 1:9, y in 1:9\n       if x * y % 2 == 0 &&\n       x * y % 7 == 0] |> unique\n4-element Vector{Int64}:\n 14\n 28\n 42\n 56\n```", "```\njulia> multiplication_generator = (x * y for x in 1:9, y in 1:9)\n```", "```\njulia> [n for n in multiplication_generator\n       if n % 2 == 0 && n % 7 == 0]\n       |> unique\n4-element Vector{Int64}:\n 14\n 28\n 42\n 56\n```", "```\njulia> comma_space = \", \";\n\njulia> string(\"Hello\", comma_space, \"François\")\n\"Hello, François\"\n```", "```\njulia> repeat(\"ABC \", 5)\n\"ABC ABC ABC ABC ABC \"\n```", "```\njulia> print(raw\"a\\tb\")\na\\tb\njulia> print(\"a\\tb\")\na       b\n```", "```\njulia> print(\"I said, \\\"No\\\".\")\nI said, \"No\".\njulia> print(raw\"I said, \\\"No\\\".\")\nI said, \"No\".\n```", "```\njulia> v\"1.6.1\" < v\"1.6.2\"\ntrue\n\njulia> version = v\"1.7.2\"\nv\"1.7.2\"\n\njulia> version.major, version.minor, version.patch\n(0x00000001, 0x00000007, 0x00000002)\n```", "```\njulia> b\"a2∑\"\n4-element Base.CodeUnits{UInt8, String}:\n 0x61\n 0x32\n 0xce\n 0xa3\n```", "```\njulia> '∑'\n'∑': Unicode U+03A3 (category Lu: Letter, uppercase)\n```", "```\njulia> \"a2\\u03a3\"\n\"a2∑\"\n```", "```\njulia> s = \"abc\"\n\"abc\"\n\njulia> replace(s, \"b\" => \"XX\", \"c\" => \"Z\")\n\"aXXZ\"\n\njulia> replace(s, \"c\" => \"Z\", \"Z\" => \"WWW\")\n\"abZ\"\n```", "```\njulia> occursin(\"abc\", \"abcdef\")\ntrue\n\njulia> occursin(\"abc\", \"abCdef\")\nfalse\n```", "```\njulia> findfirst('a', \"abcabc\")\n1\n\njulia> findlast('a', \"abcabc\")\n4\n```", "```\njulia> findfirst(\"abc\", \"abcabc\")\n1:3\n\njulia> findlast(\"abc\", \"abcabc\")\n4:6\n```", "```\n   q = \"To be or not to be, that is the question\"\n   i = 0\n   locations = []\n\n➊ while i != nothing\n       i = findnext('e', q, i + 1)\n       push!(locations, i)\n   end\n\nprint(\"\"\"The letter \"e\" was found at locations \"\"\",\n             join(locations[1:end-1], \", \", \" and \"), \".\")\n```", "```\nThe letter \"e\" was found at locations 5, 18, 31 and 35.\n```", "```\njulia> s = \"abc<ABC>def\"\n\"abc<ABC>def\"\n\njulia> replace(s, r\"<.*>\" => \"\")\n\"abcdef\"\n```", "```\njulia> replace(s, r\"(.*)<(.*)>(.*)\" => s\"\\1\\3, \\2\")\n\"abcdef, ABC\"\n```", "```\njulia> function name_length()\n           println(\"Hi. What's your name?\")\n        ➊ name = readline()\n        ➋ println(\"Hello, $name. Your name has $(length(name)) letters.\")\n       end\nname_length (generic function with 1 method)\n\njulia> name_length()\nHi. What's your name?\nEmily\nHello, Emily. Your name has 5 letters.\n```", "```\nprintln(\"Hello, $name. Your name has $(length(replace(name, \" \" => \"\"))) letters.\")\n```", "```\njulia> bd = Dict(\"one\"=>1, \"two\"=>2)\nDict{String, Int64} with 2 entries:\n  \"two\" => 2\n  \"one\" => 1\n```", "```\njulia> bd[\"one\"]\n1\n\njulia> bd[2]\nERROR: KeyError: key 2 not found\n```", "```\njulia> bd[\"one\"] = 9;\n\njulia> bd\nDict{String, Int64} with 2 entries:\n  \"two\" => 2\n  \"one\" => 9\n```", "```\njulia> Dict([(\"one\", 1) (\"two\", 2)])\nDict{String, Int64} with 2 entries:\n  \"two\" => 2\n  \"one\" => 1\n```", "```\njulia> s1 = Set(1:5)\nSet{Int64} with 5 elements:\n  5\n  4\n  2\n  3\n  1\n\njulia> s2 = Set(4:8)\nSet{Int64} with 5 elements:\n  5\n  4\n  6\n  7\n  8\n```", "```\njulia> intersect(s1, s2)\nSet{Int64} with 2 elements:\n  5\n  4\n\njulia> union(s1, s2)\nSet{Int64} with 8 elements:\n  5\n  4\n  6\n  7\n  2\n  8\n  3\n  1\n```", "```\n   julia> issubset(4:7, s2)\n   true\n\n   julia> 4:7 ⊆ s2\n   true\n\n➊ julia> 4:7 ⊇ s2\n   false\n```", "```\njulia> s1\nSet{Int64} with 5 elements:\n  5\n  4\n  2\n  3\n  1\n\njulia> setdiff(s1, 3:5)\nSet{Int64} with 2 elements:\n  2\n  1\n```", "```\njulia> push!(s1, 999);\n\njulia> setdiff!(s1, 1:3)\nSet{Int64} with 3 elements:\n  5\n  4\n  999\n```", "```\njulia> struct Website\n           url\n           title\n       end\n\njulia> google = Website(\"https://google.com\", \"google\")\nWebsite(\"https://google.com\", \"google\")\n```", "```\njulia> google.title\n\"google\"\n\njulia> google.title = \"Google\"\nERROR: setfield!: immutable struct of type Website cannot be changed\n```", "```\njulia> mutable struct MutableWebsite\n           url\n           title\n       end\n\njulia> google = MutableWebsite(\"https://google.com\", \"google\")\nMutableWebsite(\"https://google.com\", \"google\")\n\njulia> google.title = \"Google\"\n\"Google\"\n```", "```\njulia> nt = (a=1, b=2, c=3);\n\njulia> nt.c\n3\n```", "```\njulia> nt.a = 17\nERROR: setfield!: immutable struct of type NamedTuple cannot be changed\n```", "```\njulia> repeat(['a' 'b' '|'], 4, 3)\n4×9 Matrix{Char}:\n 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'\n 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'\n 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'\n 'a'  'b'  '|'  'a'  'b'  '|'  'a'  'b'  '|'\n```", "```\njulia> XY = fill(['X' 'Y'], 3, 4)\n3×4 Matrix{Matrix{Char}}:\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n```", "```\njulia> XY[1, 4][1] = 'O';\n\njulia> XY\n3×4 Matrix{Matrix{Char}}:\n ['O' 'Y']  ['O' 'Y']  ['O' 'Y']  ['O' 'Y']\n ['O' 'Y']  ['O' 'Y']  ['O' 'Y']  ['O' 'Y']\n ['O' 'Y']  ['O' 'Y']  ['O' 'Y']  ['O' 'Y']\n```", "```\njulia> XY = fill(['X' 'Y'], 3, 4);\n\njulia> XY[1, 4] = ['O' 'Y'];\n\njulia> XY\n3×4 Matrix{Matrix{Char}}:\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['O' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n```", "```\njulia> XY = repeat([['X' 'Y']], 3, 4);\n```", "```\njulia> xy = [['X' 'Y'] for i in 1:3, j in 1:4]\n3×4 Matrix{Matrix{Char}}:\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n\njulia> xy[1, 4][1] = 'O';\n\njulia> xy\n3×4 Matrix{Matrix{Char}}:\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['O' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n ['X' 'Y']  ['X' 'Y']  ['X' 'Y']  ['X' 'Y']\n```", "```\njulia> zeros(4, 5)\n4×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n```", "```\njulia> a1 = collect(1:6);\n\njulia> a2  = reshape(a1, (3, 2))\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> reshape(a1, 2, 2)\nERROR: DimensionMismatch(\"new dimensions (2, 2) must\n       be consistent with array size 6\")\n```", "```\njulia> a1[5] = 0;\n\njulia> a2\n3×2 Matrix{Int64}:\n 1  4\n 2  0\n 3  6\n```", "```\njulia> m = [[1 2]; [3 4]]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```", "```\njulia> m = [[1 2];; [3 4]]\n1×4 Matrix{Int64}:\n 1  2  3  4\n\njulia> m = [[1 2] [3 4]]\n1×4 Matrix{Int64}:\n 1  2  3  4\n```", "```\njulia> m = [[1 2];;; [3 4]]\n1×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  2\n\n[:, :, 2] =\n 3  4\n```", "```\njulia> s3 = (1:9) .% 3 .== 0\n9-element BitVector:\n 0\n 0\n 1\n 0\n 0\n 1\n 0\n 0\n 1\n```", "```\njulia> (1:9)[s3]\n3-element Vector{Int64}:\n 3\n 6\n 9\n```", "```\njulia> ('a':'i')[s3]\n3-element Vector{Char}:\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'f': ASCII/Unicode U+0066 (category Ll: Letter, lowercase)\n 'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)\n```", "```\njulia> (1:100)[(1:100) .% 17 .== 0]\n5-element Vector{Int64}:\n 17\n 34\n 51\n 68\n 85\n```", "```\njulia> MR = [[1 2]; [3 4]]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> MR'\n2×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  3\n 2  4\n\njulia> MR' == adjoint(MR) == permutedims(MR)\ntrue\n```", "```\njulia> M = [[1+im 2+2im]; [3+3im 4+4im]]\n2×2 Matrix{Complex{Int64}}:\n 1+1im  2+2im\n 3+3im  4+4im\n\njulia> M'\n2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:\n 1-1im  3-3im\n 2-2im  4-4im\n```", "```\njulia> Mt = transpose(M)\n2×2 transpose(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:\n 1+1im  3+3im\n 2+2im  4+4im\n```", "```\njulia> conj(M)\n2×2 Matrix{Complex{Int64}}:\n 1-1im  2-2im\n 3-3im  4-4im\n```", "```\njulia> a = π/2\n1.5707963267948966\n\njulia> RM = [[cos(a) -sin(a)]; [sin(a) cos(a)]];\n\njulia> RM * [1, 0]\n2-element Vector{Float64}:\n 6.123233995736766e-17\n 1.0\n```", "```\njulia> MR^-1\n2×2 Matrix{Float64}:\n -2.0   1.0\n  1.5  -0.5\n\njulia> MR^-1 * MR\n2×2 Matrix{Float64}:\n 1.0          0.0\n 2.22045e-16  1.0\n```", "```\njulia> collect(enumerate([10 20; 30 40]))\n2×2 Matrix{Tuple{Int64, Int64}}:\n (1, 10)  (3, 20)\n (2, 30)  (4, 40)\n```", "```\njulia> for letter in enumerate(\"François\")\n           println(\"Letter number $(letter[1]) is $(letter[2]).\")\n       end\nLetter number 1 is F.\nLetter number 2 is r.\nLetter number 3 is a.\nLetter number 4 is n.\nLetter number 5 is ç.\nLetter number 6 is o.\nLetter number 7 is i.\nLetter number 8 is s.\n```", "```\njulia> \"François\"[5]\n'ç': Unicode U+00E7 (category Ll: Letter, lowercase)\n\njulia> \"François\"[6]\nERROR: StringIndexError: invalid index [6], valid nearby indices [5]=>'ç', [7]=>'o'\n```", "```\njulia> collect(pairs(\"François\"))\n8-element Vector{Pair{Int64, Char}}:\n 1 => 'F'\n 2 => 'r'\n 3 => 'a'\n 4 => 'n'\n 5 => 'ç'\n 7 => 'o'\n 8 => 'i'\n 9 => 's'\n```", "```\njulia> [p.first for p in pairs(\"François\")]\n8-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 7\n 8\n 9\n```", "```\njulia> p1 = \"one\" => 1\n\"one\" => 1\n\njulia> p2 = Pair(\"two\", 2)\n\"two\" => 2\n\njulia> Dict([p1, p2]) == Dict(\"one\"=>1, \"two\"=>2)\ntrue\n```", "```\njulia> Dict(pairs(\"François\"))\nDict{Int64, Char} with 8 entries:\n  5 => 'ç'\n  4 => 'n'\n  7 => 'o'\n  2 => 'r'\n  9 => 's'\n  8 => 'i'\n  3 => 'a'\n  1 => 'F'\n```", "```\njulia> zip([1 2; 3 4], ['a' 'b'; 'c' 'd']) |> collect\n2×2 Matrix{Tuple{Int64, Char}}:\n (1, 'a')  (2, 'b')\n (3, 'c')  (4, 'd')\n```", "```\njulia> zip([1, 2, 3, 4], ['a' 'b'; 'c' 'd']) |> collect\n4-element Vector{Tuple{Int64, Char}}:\n (1, 'a')\n (2, 'c')\n (3, 'b')\n (4, 'd')\n```", "```\njulia> zip(1:3, ['a' 'b'; 'c' 'd']) |> collect\n3-element Vector{Tuple{Int64, Char}}:\n (1, 'a')\n (2, 'c')\n (3, 'b')\n\njulia> zip(1:5, ['a' 'b'; 'c' 'd']) |> collect\n4-element Vector{Tuple{Int64, Char}}:\n (1, 'a')\n (2, 'c')\n (3, 'b')\n (4, 'd')\n```"]