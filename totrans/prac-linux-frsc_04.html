<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_83"/><span class="big"><strong>4</strong></span><br/><strong>DIRECTORY LAYOUT AND FORENSIC ANALYSIS OF LINUX FILES</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindent">The previous chapter described forensic analysis of storage and filesystems, the low-level building blocks that create the illusion of a hierarchical file tree. This chapter focuses on the layout of that file tree, takes a closer look at individual files, and identifies specific areas of interest to digital forensic examiners.</p>&#13;
<h3 class="h3" id="ch00lev1_17"><strong>Linux Directory Layout</strong></h3>&#13;
<p class="noindent">When performing a forensic examination of a Linux system, understanding the organization of files and directories on a drive helps the investigator to locate areas and artifacts of interest quickly and ignore areas that are less likely to contain evidence.</p>&#13;
<p class="indent">Linux adopted its tree-like structure from traditional Unix, which starts with the <em>root</em> directory, represented by a forward slash (/). Additional filesystems on local storage or remote network servers can be attached (mounted) to any subdirectory in the tree.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>Original Unix systems organized the filesystem hierarchy into directories to separate executable programs, shared libraries, configuration files, devices, documentation, user directories, and so on.<sup><a id="ch04foot01" href="footnotes.xhtml#ch04foot_01">1</a></sup> Linux systems today still use most of the names those directories were given.</p>&#13;
<h4 class="h4" id="ch00lev2_49"><strong><em>Filesystem Hierarchy</em></strong></h4>&#13;
<p class="noindent">The top of this hierarchical tree is called the root directory, or <em>/</em> (not to be confused with the root user’s home directory, <em>/root/</em>). All subdirectories, mounted storage media, mounted network shares, or other mounted virtual filesystems, are attached to this “upside down” tree below the root, as illustrated in <a href="ch04.xhtml#ch04fig01">Figure 4-1</a>. This process is called <em>mounting</em> a filesystem, and the directory (typically empty) where it is mounted is called the <em>mount point</em>. The PC DOS world differs in that attached filesystems (local or remote) are represented as individual drive letters (A:, B:,. . ., Z:).</p>&#13;
<div class="image"><img id="ch04fig01" src="Images/ch04fig01.jpg" alt="Image" width="694" height="488"/></div>&#13;
<p class="figcap"><em>Figure 4-1: Filesystem tree structure</em></p>&#13;
<p class="indent">The POSIX and Open Group UNIX standards didn’t define a detailed directory layout<sup><a id="ch04foot02" href="footnotes.xhtml#ch04foot_02">2</a></sup> for Unix vendors to follow. Unix systems and Linux distributions document their directory hierarchy in the hier(7) or hier(5) man pages. The Linux community developed the <em>Filesystem Hierarchy Standard (FHS)</em><sup><a id="ch04foot03" href="footnotes.xhtml#ch04foot_03">3</a></sup> to encourage a common layout across distributions. Modern Linux systems also have a file-hierarchy(7) man page with additional information <span epub:type="pagebreak" id="page_85"/>related to systemd. The rest of this section describes each of the top-level directories commonly used in Linux and their relevance to forensics.</p>&#13;
<h5 class="h5"><strong>/boot/ and efi/</strong></h5>&#13;
<p class="noindent">The <em>/boot/</em>and <em>efi/</em> directories<sup><a id="ch04foot04" href="footnotes.xhtml#ch04foot_04">4</a></sup> contain files for booting the system. Boot configuration (kernel parameters and so on) can be found here. Current and previous kernels can be found here together with the initial ramfs, which can be examined. On EFI systems, the EFI partition (a FAT filesystem) is often mounted inside the <em>/boot/</em> directory. Non-standard and non-default files that have been added to the <em>/boot/</em>and <em>efi/</em> directories should be examined. <a href="ch06.xhtml">Chapter 6</a> on forensic analysis of Linux system initialization describes these directories in more detail.</p>&#13;
<h5 class="h5"><strong>/etc/</strong></h5>&#13;
<p class="noindent">The <em>/etc/</em> directory is the traditional location for system-wide configuration files and other data. The majority of these files are easily examined plaintext files. Configuration files may have a corresponding directory with a <em>.d</em> extension for drop-in files that are included as part of the configuration.<sup><a id="ch04foot05" href="footnotes.xhtml#ch04foot_05">5</a></sup> The creation and modification timestamps of these files may be interesting in an investigation, as they indicate when a particular configuration file was added or changed. In addition, user-specific configuration files in a user’s <em>/home/</em> directory may override system-wide <em>/etc/</em> files. Deviations from the distro or software defaults are often found here and may be of forensic interest. Copies of the distro default files are sometimes found in <em>/usr/share/factory/etc/*</em> and can be compared with those in the <em>/etc/</em> directory. When some distros perform upgrades to config files in <em>/etc/</em>, they may create a backup copy of the old files or add the new file with an extension (Arch’s Pacman uses the extension *<em>.pacnew</em>). Various files in <em>/etc/</em> are explained in more detail throughout the book.</p>&#13;
<h5 class="h5"><strong>/srv/</strong></h5>&#13;
<p class="noindent">The <em>/srv/</em> directory is available for use by server application content, such as FTP or HTTP files. This is a good directory to examine in case it contains files that were published or otherwise accessible over a network. This directory is unused on many distributions and may be empty.</p>&#13;
<h5 class="h5"><strong>/tmp/</strong></h5>&#13;
<p class="noindent">The <em>/tmp/</em> directory is for storing temporary files. These files may be deleted periodically or during boot, depending on the distro or system’s configuration. In some Linux distros, the contents of <em>/tmp/</em> may reside in RAM using the tmpfs virtual memory filesystem. On a forensic image, systems using tmpfs to mount <em>/tmp/</em> will likely be empty. See the systemd-tmpfiles(8) man page for more information about how a system manages temporary files, <span epub:type="pagebreak" id="page_86"/>and see the tmpfs(5) man page for more details regarding virtual memory filesystems.</p>&#13;
<h5 class="h5"><strong>/run/</strong></h5>&#13;
<p class="noindent">The <em>/run/</em> directory is a tmpfs-mounted directory residing in RAM and will likely be empty on a forensic image. On a running system, this directory contains runtime information like PID and lock files, systemd runtime configuration, and more. There may be references to files and directories in <em>/run/</em> found in logs or configuration files.</p>&#13;
<h5 class="h5"><strong>/home/ and /root/</strong></h5>&#13;
<p class="noindent">The <em>/home/</em> directory is the default location for user home directories. A user’s home directory contains files the user created or downloaded, including configuration, cache, data, documents, media, desktop contents, and other files the user owns. The <em>/etc/skel/</em>directory (which might only contain hidden “.” files) contains the default contents of a newly created <em>/home/*</em> directory. The root user’s home directory is typically <em>/root/</em> of the root filesystem. This is intentional so that root can log in even when <em>/home/</em> is not mounted. These home directories are of significant interest to forensic investigators because they provide information about a system’s human users. If <em>/home/</em> is empty on a forensic image, it’s likely the user’s home directories are mounted from another filesystem or over a network. The creation (birth) timestamp of a user’s home directory may indicate when the user account was first added. <a href="ch10.xhtml">Chapter 10</a> covers the <em>/home/</em> directory contents in detail.</p>&#13;
<h5 class="h5"><strong>/bin/, /sbin/, /usr/bin/, and /usr/sbin/</strong></h5>&#13;
<p class="noindent">The standard locations for executable programs are <em>/bin/</em>, <em>/sbin/</em>, <em>/usr/bin/</em>, and <em>/usr/sbin/</em>. These directories originally were intended to separate groups of programs for users, administrators, the boot process, or for separately mounted filesystems. Today, <em>/bin/</em> and <em>/sbin/</em> are often symlinked to their corresponding directory in <em>/usr/</em>, and in some cases, <em>/bin/</em>, <em>/sbin/</em>, and <em>/usr/ sbin/</em> are symlinked to a single <em>/usr/bin/</em> directory containing all programs. Be careful examining symlinked directories on a suspect drive mounted on your own Linux analysis machine. The symlinks might be pointing to your own directories and not the suspect drive.</p>&#13;
<h5 class="h5"><strong>/lib/ and /usr/lib/</strong></h5>&#13;
<p class="noindent">The <em>/lib/</em> directory is generally symlinked to <em>/usr/lib/</em> on most Linux systems today. This includes shared library code (also for multiple platforms), kernel modules, support for programming environments (header files), and more. The <em>/lib/</em> directory also contains the default configuration files for many software packages.</p>&#13;
<h5 class="h5"><strong>/usr/</strong></h5>&#13;
<p class="noindent">The <em>/usr/</em> directory contains the bulk of the system’s static read-only data. This includes binaries, libraries, documentation, and more. Most Linux <span epub:type="pagebreak" id="page_87"/>systems will symlink <em>/bin/</em>, <em>/sbin/</em>, and <em>/lib/</em> to their equivalents in the <em>/usr/</em> subdirectory. Files located here that are not part of any installed package may be of forensic interest because they were added outside the normal software installation process. These might be manually installed files by a user with root access, or unauthorized files placed by a malicious actor.</p>&#13;
<h5 class="h5"><strong>/var/</strong></h5>&#13;
<p class="noindent">The <em>/var/</em> directory contains system data that is changing (variable) and usually persistent across reboots. The subdirectories below <em>/var/</em> are especially interesting from a forensics perspective because they contain logs, cache, historical data, persistent temporary files, the mail and printing subsystems, and much more. A significant portion of this book deals with files and directories in the <em>/var/</em> directory.</p>&#13;
<h5 class="h5"><strong>/dev/, /sys/, and /proc/</strong></h5>&#13;
<p class="noindent">Linux has several other tmpfs and pseudo-filesystems that appear to contain files when the system is running, which include <em>/dev/</em>, <em>/sys/</em>, and <em>/proc/</em>. These directories provide representations of devices or kernel data structures but the contents don’t actually exist on a normal filesystem. When examining a forensic image, these directories will likely be empty. See the procfs(5) and sysfs(5) man pages for more details.</p>&#13;
<h5 class="h5"><strong>/media/</strong></h5>&#13;
<p class="noindent">The <em>/media/</em> directory is intended to hold dynamically created mount points for mounting external removable storage, such as CDROMs or USB drives. When examining a forensic image, this directory will likely be empty. References to <em>/media/</em> in logs, filesystem metadata, or other persistent data may provide information about user attached (mounted) external storage devices.</p>&#13;
<h5 class="h5"><strong>/opt/</strong></h5>&#13;
<p class="noindent">The <em>/opt/</em> directory contains add-on packages, which typically are grouped by vendor name or package name. These packages may create a self-contained directory tree to organize their own files (for example, <em>bin/</em>, <em>etc/</em>, and other common subdirectories).</p>&#13;
<h5 class="h5"><strong>/lost+found/</strong></h5>&#13;
<p class="noindent">A <em>/lost+found/</em> directory may exist on the root of every filesystem. If a filesystem repair is run (using the <code>fsck</code> command) and a file is found without a parent directory, that file (sometimes called an <em>orphan</em>) is placed in the <em>/lost+found/</em> directory where it can be recovered. Such files don’t have their original names because the directory that contained the filename is unknown or missing.</p>&#13;
<h5 class="h5"><strong>./ and ../</strong></h5>&#13;
<p class="noindent">Two hidden subdirectories (./ and ../) are found in every directory. The single dot (.) represents the current directory, and the double dot (..) represents <span epub:type="pagebreak" id="page_88"/>the parent directory. At the top of the tree, these two files also exist, and both represent the root (/) directory (and have the same inode number). From a low-level filesystem perspective, these dot files are needed to link a directory to its parent, creating the illusion of a hierarchical tree.</p>&#13;
<h4 class="h4" id="ch00lev2_50"><strong><em>User Home Directory</em></strong></h4>&#13;
<p class="noindent">A forensic investigation typically involves analysis of human user activity (where the user could be either a victim or a suspect). All users on a Linux system have a home directory where they have permission to save files and documents, customize their environment, store persistent and cached data, and retain historical data (browser cookies, shell history, or email, for example). The user’s home directory contains significant amounts of potential evidence investigators can use to reconstruct past events and activity. The location of a user’s home directory is defined in the <em>/etc/passwd</em> file and typically defaults to a subdirectory in <em>/home/</em> with their username (for example, <em>/home/sam/</em>). A user’s home directory can also be abbreviated with a tilde (<em>~/</em>) for use on the command line or in documentation.</p>&#13;
<h5 class="h5"><strong>Hidden Dot Files and XDG Base Directories</strong></h5>&#13;
<p class="noindent">It is common practice to save user configuration data in hidden files and directories that begin with a dot and are named after the program being configured. Several examples of information found in a home directory’s hidden files include:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>.bash_history</em></strong> History of shell commands the user typed</p>&#13;
<p class="noindentin"><strong><em>.lesshst</em></strong> Search history of the <code>less</code> command</p>&#13;
<p class="noindentin"><strong><em>.viminfo</em></strong> Search and command history, and traces of vim-edited files</p>&#13;
<p class="noindentin"><strong><em>.wget-hsts</em></strong> List of <code>wget</code> hosts visited<sup><a id="ch04foot06" href="footnotes.xhtml#ch04foot_06">6</a></sup> with timestamps</p>&#13;
<p class="noindentin"><strong><em>.forward</em></strong> File containing email addresses for auto-forwarding</p>&#13;
<p class="noindentin"><strong><em>.apvlvinfo</em></strong> History of PDFs viewed using the apvlv PDF viewer</p>&#13;
</div>&#13;
<p class="indent">For more complex user configuration, cache, history, and persistent data, an application may create a dedicated hidden directory containing multiple files and subdirectories to organize data. Here are a few examples:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong><em>.ssh/</em></strong> Secure shell configuration, keys, and list of known hosts visited</p>&#13;
<p class="noindentin"><strong><em>.gnupg/</em></strong> GPG configuration, keys, and other people’s added public keys</p>&#13;
<p class="noindentin"><strong><em>.thunderbird/</em></strong> Email and calendar accounts, and synchronized email and calendar content for offline access</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_89"/><strong><em>.mozilla/</em></strong> Firefox configuration, cookies, bookmarks, browsing history, and plug-ins</p>&#13;
<p class="noindentin"><strong><em>.zoom/</em></strong> Zoom configuration, logs, call history, and shared data</p>&#13;
<p class="noindentin"><strong><em>.john/</em></strong> John the Ripper password-cracking history with discovered passwords</p>&#13;
<p class="noindentin"><strong><em>.ICAClient/</em></strong> Citrix client configuration, cache, logs, and other data</p>&#13;
</div>&#13;
<p class="noindent">The developers of any software package are free to choose what to save and where to save it. Storing information using hidden files and directories was never required, but it became common practice.</p>&#13;
<p class="indent">Over time, the number of dot files in a typical user’s home directory became unwieldy, driving the need for standardization. The former X Desktop Group (known today as <a href="http://freedesktop.org">freedesktop.org</a>) created the <em>XDG Base Directory Specification</em> (<em><a href="https://www.freedesktop.org/wiki/Specifications/basedir-spec/">https://www.freedesktop.org/wiki/Specifications/basedir-spec/</a></em>), which defined standard locations for storing user-specific data.<sup><a id="ch04foot07" href="footnotes.xhtml#ch04foot_07">7</a></sup> The specification defines environment variables and default locations that operating systems and applications may use instead of creating their own proprietary files and directories in the user’s home directory. These location environment variables and associated default locations are:</p>&#13;
<ul>&#13;
<li class="noindent">Data files: <code>$XDG_DATA_HOME</code> or default <em>~/.local/share/*</em></li>&#13;
<li class="noindent">Configuration files: <code>$XDG_CONFIG_HOME</code> or default <em>~/.config/*</em></li>&#13;
<li class="noindent">Non-essential cache data: <code>$XDG_CACHE_HOME</code> or default <em>~/.cache</em></li>&#13;
<li class="noindent">Runtime files: <code>$XDG_RUNTIME_DIR</code> or typically <em>/run/user/</em>UID (where <em>UID</em> is the numeric ID of the user)</li>&#13;
</ul>&#13;
<p class="indent">In addition, the specification defines two search variables, <code>$XDG_DATA_DIRS</code> and <code>$XDG_CONFIG_DIRS</code>, which contain paths for additional configuration (this is often to include system-wide, or Flatpak and snap, directories). The <em>/run/</em> directory is mounted on a temporary RAM-based filesystem (tmpfs), so user runtime files exist only when the system is running and the user is logged in. The <em>/run/</em> directory will be empty when examining a forensic image.</p>&#13;
<h5 class="h5"><strong>Location of User Application and System Information</strong></h5>&#13;
<p class="noindent">When performing a postmortem forensic analysis, the data, configuration, and cache directories contain significant amounts of information about applications and system components related to a user’s activity. Many of these locations are described in more detail in the rest of the book, but let’s look at some examples.</p>&#13;
<p class="indent">Programs placing data in the <em>~/.cache/</em> directory expect that it might be deleted. It is considered “non-essential” but remains persistent over time and across login sessions and reboots. Any program can create files or directories in <em>~/.cache/</em> to store data for performance and efficiency reasons.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_90"/>Here are examples of information and the programs that may save them:</p>&#13;
<ul>&#13;
<li class="noindent">Browsers cache HTML, images, JavaScript, and safe browsing information</li>&#13;
<li class="noindent">A separate directory for web favicons exists</li>&#13;
<li class="noindent">Software Center caches file lists, images, ratings, and information</li>&#13;
<li class="noindent">Some mail clients store cached email and calendars</li>&#13;
<li class="noindent">Package managers save downloaded software packages</li>&#13;
<li class="noindent">Programs store thumbnails, images, and album art</li>&#13;
<li class="noindent">Window managers and desktop environments save session information and logs</li>&#13;
<li class="noindent">Some programs use <em>.cache</em> as the location to auto-save open files</li>&#13;
<li class="noindent">Temporary screenshot data</li>&#13;
<li class="noindent">Any other cache data stored by programs for performance or efficiency reasons</li>&#13;
</ul>&#13;
<p class="indent">The <em>~/.cache/</em> directory stores anything that can be re-downloaded, locally generated, or otherwise recovered and re-created. These files contain information about the use of the system and different applications. The creation and modification timestamps may help reconstruct a timeline of past activity.</p>&#13;
<p class="indent">The user’s <em>~/.config/</em> directory is supposed to contain only configuration data, but many application developers use it for other things, like history and cached information. Files in <em>~/.config/</em> may end in <em>*rc</em> or have extensions of <em>.conf</em>, <em>.ini</em>, <em>.xml</em>, <em>.yaml</em>, or other configuration formats. Most files found here are regular text files and are easy to view with any text editor or viewer.</p>&#13;
<p class="indent">In some cases, configuration information is stored in databases and must be extracted. Because this is the free and open source world, tools and specifications usually exist to facilitate analysis of those databases. Some examples of data stored in the <em>~/.config/</em> directory include:</p>&#13;
<ul>&#13;
<li class="noindent">General configuration of applications (not including data)</li>&#13;
<li class="noindent">Desktop artifacts (trash, session configuration, autostart, and dconf)</li>&#13;
<li class="noindent">Application extensions and plug-ins</li>&#13;
<li class="noindent">Files containing unique identifiers and license data</li>&#13;
<li class="noindent">Cookies for some browsers</li>&#13;
<li class="noindent">Application state data (first time run, initial welcome banners)</li>&#13;
<li class="noindent">Configuration of user accounts and remote servers</li>&#13;
<li class="noindent">Communication application (Wire, Jitsi) logs, persistence, and cache</li>&#13;
<li class="noindent">Default applications specified in a <em>mimeapps.list</em> file</li>&#13;
<li class="noindent">Any other arbitrary configuration data stored by programs</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_91"/>Aside from the usual configuration data from applications, the <em>~/.config/</em> directory is interesting to search for usernames, email addresses, and hostnames that indicate remote connections and activity. In some cases, you also can find passwords or password hashes in user configuration files.</p>&#13;
<p class="indent">The <em>~/.local/share/</em> directory is intended to store persistent data accumulated or generated by applications. Examples of data saved here include:</p>&#13;
<ul>&#13;
<li class="noindent">Distro-specific configuration</li>&#13;
<li class="noindent">Graphical login session configuration</li>&#13;
<li class="noindent">Desktop-specific configuration</li>&#13;
<li class="noindent">Desktop-bundled apps (readers, notes, file managers, and so on)</li>&#13;
<li class="noindent">Commonly shared thumbnails</li>&#13;
<li class="noindent">Desktop trashcan</li>&#13;
<li class="noindent">Cookies for some browsers</li>&#13;
<li class="noindent">Calendar and contact databases for some applications</li>&#13;
<li class="noindent">Recently used files and places (<em>*.xbel</em> files)</li>&#13;
<li class="noindent">Snap and Flatpak application information</li>&#13;
<li class="noindent">Baloo file index and search for KDE</li>&#13;
<li class="noindent">Tracker file index and search for GNOME</li>&#13;
<li class="noindent">Secret keyrings and password wallets</li>&#13;
<li class="noindent">Clipboard manager data</li>&#13;
<li class="noindent">Xorg logs</li>&#13;
<li class="noindent">Any other persistent data stored by programs</li>&#13;
</ul>&#13;
<p class="indent">Most distributions and applications are starting to follow the XDG specifications, and thus provide common locations for artifacts of interest to forensic investigators. However, some applications do not follow the XDG Base Directory Specification correctly or at all. This may be historic, for backward compatibility, or for other reasons. The Arch Linux wiki maintains a list (<em><a href="https://wiki.archlinux.org/index.php/XDG_Base_Directory">https://wiki.archlinux.org/index.php/XDG_Base_Directory</a></em>) of application compatibility with the XDG Base Directory Specification. As you can see, every application is free to choose what to save, how to save it, and where to save it. Even across desktop environments and distributions, only the XDG base directories are consistent, but even that is not a requirement. When analyzing user home directories, be sure to examine each hidden file and directory in the <em>/home/</em> and the XDG base directories.</p>&#13;
<p class="indent">Independent of applications, the XDG standards suggest a list of common directories in a user’s <em>/home/</em> directory to store user files based on category. These directories are defined in <em>/etc/xdg/user-dirs.defaults</em> and may be created on login if they don’t already exist:</p>&#13;
<ul>&#13;
<li class="noindent"><em>Desktop/</em></li>&#13;
<li class="noindent"><em>Downloads/</em></li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_92"/><em>Templates/</em></li>&#13;
<li class="noindent"><em>Public/</em></li>&#13;
<li class="noindent"><em>Documents/</em></li>&#13;
<li class="noindent"><em>Music/</em></li>&#13;
<li class="noindent"><em>Pictures/</em></li>&#13;
<li class="noindent"><em>Videos/</em></li>&#13;
</ul>&#13;
<p class="indent">The <em>Desktop/</em> directory is for files that will appear on the user’s desktop, and the <em>Downloads/</em> directory is a default location for applications to save downloaded files. Applications (like office suites) reference the <em>Templates/</em> directory to suggest template files when a user is creating a new document. The <em>Public/</em> directory can be used as an open share for other users (typically on a local LAN) to access files. The remaining directories are self-explanatory, and relevant applications can use those directories as default locations to store documents and media files.</p>&#13;
<p class="indent">These directory names are created with local language translations depending on the locale’s settings. For example, on my German test system, the following folders corresponding to the English equivalents: <em>Schreibtisch/</em>, <em>Vorlagen/</em>, <em>Downloads/</em>, <em>Öffentlich/</em>, <em>Dokumente/</em>, <em>Musik/</em>, <em>Bilder/</em>, and <em>Videos/</em>.</p>&#13;
<p class="indent">The <em>~/Downloads/</em> directory can be interesting to analyze. When some browsers begin downloading a file, they create a temporary file and then move it to the correct filename when the download completes (Firefox uses <em>*.part</em> as the temporary file). This means the birth (<code>crtime</code>) timestamp represents when the download started, and the contents’ last modified (<code>mtime</code>) timestamp is when the download finished. Because we know the size of the file, we can even calculate the approximate speed of the download over the network connection at the time.</p>&#13;
<p class="indent">Here, a 7GB DVD download started at 8:51 and finished at 9:12:</p>&#13;
<pre>$ <span class="codestrong1">stat ~/Downloads/rhel-8.1-x86_64-dvd.iso</span>&#13;
...&#13;
  Size: 7851737088Blocks: 15335432  IO Block: 4096  regular file&#13;
...&#13;
Modify: 2020-03-26 09:12:47.604143584 +0100&#13;
...&#13;
Birth: 2020-03-26 08:51:10.849591860 +0100</pre>&#13;
<p class="noindent">Knowing the start and end time of a file download could be interesting in a forensic investigation, especially when reconstructing timelines of user activity.</p>&#13;
<p class="indent">This book does not focus on Linux application analysis, so these examples are brief and incomplete. Some of the files and directories (<em>.ssh</em> and <em>.gnupg</em>, for example) are covered in more detail elsewhere in the book. The other examples shown here illustrate the commonly used locations and contents of application data stored on Linux systems. Good sources of information for forensic analysis techniques for individual applications are Forensic <span epub:type="pagebreak" id="page_93"/>Science International’s <em>Digital Investigation</em> journal, the DFRWS conference, and <em><a href="https://www.ForensicFocus.com/">https://www.ForensicFocus.com/</a></em>.</p>&#13;
<h4 class="h4" id="ch00lev2_51"><strong><em>Hashsets and NSRL for Linux</em></strong></h4>&#13;
<p class="noindent">A common method of identifying files in digital forensics is to use cryptographic hashes (MD5, SHA-1, and so on) to create a unique fingerprint or signature. You can create lists of cryptographic hashes from software packages or other known collections of files. These lists of known file hashes are called <em>hashsets</em> or <em>hash databases</em>. In digital forensics, hashsets are typically used either to ignore uninteresting files or to identify especially interesting files.</p>&#13;
<p class="indent">When used to ignore uninteresting files, hashsets can reduce the number of files to be examined. For instance, if an investigator is interested only in files created, modified, or downloaded apart from the installation of an operating system, they can use hashsets to filter out the files known to belong to that operating system. Examples of known files typically ignored during forensic analysis include:</p>&#13;
<ul>&#13;
<li class="noindent">Operating systems and all supporting files</li>&#13;
<li class="noindent">Device drivers</li>&#13;
<li class="noindent">Application software</li>&#13;
<li class="noindent">Company-generated hashsets of standard server or client installations</li>&#13;
</ul>&#13;
<p class="indent">Hashsets identify only the contents of files, not the metadata of the installed files on the filesystem. Timestamps, permissions, ownership, and so on are part of the filesystem, and aren’t included in a hashset.</p>&#13;
<p class="indent">When identifying especially interesting files, investigators use hashsets to search for the existence of files in a forensic drive image. For example, if an investigator has a list of hashes for files involved in a particular cyberattack, they can search an affected machine specifically for the existence of those files. Examples of known files typically of interest during forensic analysis include:</p>&#13;
<ul>&#13;
<li class="noindent">Indicators of compromise (IOCs), which may include hashes of malware components</li>&#13;
<li class="noindent">Certain classifications of software (keyloggers or bitcoin miners, for example)</li>&#13;
<li class="noindent">Known illicit material (these hashsets are usually available only to law enforcement)</li>&#13;
<li class="noindent">Known leaked or sensitive documents in a corporate environment</li>&#13;
</ul>&#13;
<p class="indent">Hashsets also are used to find modified or trojaned versions of binary executables by comparing installed files with the expected vendor-supplied hash values.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>You can find hashsets of known files in several places. The security community often shares IOCs and security-related hashsets, and cybersecurity companies sell them as threat intelligence data feeds. Law enforcement agencies share hashsets of illicit material, which are made available only to other police forensic labs. Large companies may create hashsets of their internally developed software packages or standard server/client installations.</p>&#13;
<p class="indent">NIST maintains the National Software Reference Library (NSRL),<sup><a id="ch04foot08" href="footnotes.xhtml#ch04foot_08">8</a></sup> which is a collection of known software packages. NIST provides hashsets from the NSRL for free (<em><a href="http://www.nsrl.nist.gov/">http://www.nsrl.nist.gov/</a></em>). The NSRL hashsets are a compressed list of files with hashes, the filename, product, and other information; for example:</p>&#13;
<pre>"000C89BD70552E6C782A4754536778B027764E14","0D3DD34D8302ADE18EC8152A32A4D934",&#13;
"7A810F52","gnome-print-devel-0.25-9.i386.rpm",244527,2317,"Linux",""&#13;
...&#13;
"001A5E31B73C8FA39EFC67179C7D5FA5210F32D8","49A2465EDC058C975C0546E7DA07CEE",&#13;
"E93AF649","CNN01B9X.GPD",83533,8762,"Vista",""</pre>&#13;
<p class="indent">The format of NSRL data sets is defined at <em><a href="https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/">https://www.nist.gov/system/files/data-formats-of-the-nsrl-reference-data-set-16.pdf/</a></em>.</p>&#13;
<p class="indent">Hashsets are also available as commercial products. These typically include the NSRL hashsets, additional hashes that could be extracted from commercial products (not included in the NSRL), and other sources. A popular example is <em><a href="https://www.hashsets.com/">https://www.hashsets.com/</a></em>, which provides hashset subscriptions that augment the NSRL data.</p>&#13;
<p class="indent">Most digital forensic software (including free open source tools like Autopsy and The Sleuth Kit) support the inclusion and exclusion of hashsets for analysis.</p>&#13;
<p class="indent">Maintaining hashsets for Linux systems and free and open source software (FOSS) in general causes some difficulties. Here are a few examples:</p>&#13;
<ul>&#13;
<li class="noindent">Rolling distributions like Arch Linux update on a daily basis</li>&#13;
<li class="noindent">Some software packages are compiled from source and may produce files that are unique to the system where they are installed</li>&#13;
<li class="noindent">Some software runs installation scripts that may generate files unique to the system where they are installed</li>&#13;
<li class="noindent">Many different Linux distributions provide their own software re-positories that are constantly changing and updating (see <em><a href="https://distrowatch.com/">https://distrowatch.com/</a></em>)</li>&#13;
<li class="noindent">Linux users may download software directly from developers and then compile and install manually on their own systems</li>&#13;
</ul>&#13;
<p class="indent">This dynamic landscape of change and development makes maintaining hashsets more difficult. In contrast, commercial software vendors have release cycles with well-defined software product packages.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_95"/>Most open source software developers provide hashes or GPG signatures of the source code to verify integrity. But these hashes are for the code, not the compiled binaries. Most Linux distributions provide hashes or GPG signatures of the compiled binary software packages they provide, and some even include hashes of each individual file (see <a href="ch07.xhtml">Chapter 7</a> on software installation for more information).</p>&#13;
<h3 class="h3" id="ch00lev1_18"><strong>Linux File Types and Identification</strong></h3>&#13;
<p class="noindent">The phrase <em>file type</em> can have one of two meanings. In the context of lower-layer filesystems, it refers to Unix or POSIX file types. In the context of higher-layer applications, it refers to the file content type. Understanding this difference is important when conducting a forensic examination. In addition, “hidden” files (which are usually just normal files and not actually hidden) can provide important information for an investigation.</p>&#13;
<h4 class="h4" id="ch00lev2_52"><strong><em>POSIX File Types</em></strong></h4>&#13;
<p class="noindent">Linux was developed with the Unix philosophy of “everything is a file.” To implement this concept, special file types were needed to extend functionality beyond regular files and directories. Linux has adopted the seven fundamental file types as defined by the POSIX standard, allowing the representation of special objects as files. These file types are:</p>&#13;
<ul>&#13;
<li class="noindent">Regular file</li>&#13;
<li class="noindent">Directory</li>&#13;
<li class="noindent">Symbolic link</li>&#13;
<li class="noindent">Named pipe or FIFO</li>&#13;
<li class="noindent">Block special</li>&#13;
<li class="noindent">Character special</li>&#13;
<li class="noindent">Socket</li>&#13;
</ul>&#13;
<p class="indent">Every “file” on a Linux system is categorized into one of these types and can be determined with the <code>ls -l</code> or <code>file</code> commands (and others). Understanding the difference between these file types is important to forensic investigators because not all files are related to data storage (and potentially contain evidence). Some files provide access to hardware devices or facilitate the flow of data between programs. Understanding this system behavior helps to reconstruct past events and locate potential evidence stored in other locations. Let’s take a closer look at the seven file types:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>Regular files</strong> A regular file is exactly that: a file containing data such as text, pictures, videos, office documents, executable programs, databases, encrypted data, or any other content normally stored in a file. Data in a regular file is stored in filesystem blocks on the storage medium.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_96"/><strong>Directory files</strong> These are special files that contain a list of the directory’s contents, including filenames and their corresponding inodes. They allow files and directories to be organized hierarchically in a tree structure. However, this is only an abstraction because, at lower layers, the file blocks can be located anywhere on a drive. Directories are also known as folders and are created with commands like <code>mkdir</code>.</p>&#13;
<p class="noindentin"><strong>Symbolic links</strong> This type of file represents a pointer to another file (similar to LNK files in Windows, but without the additional metadata). A symbolic link is a small file containing the path and name of another file (depending on the filesystem, this information may be stored in the link’s inode). The size of a symbolic link file is the same as the length of the filename it points to. Symbolic links are allowed to point to files that don’t exist, and this may be interesting from a forensics perspective. This indicates that a file existed in the past or was on a filesystem mounted in the past. Symbolic links are also called symlinks and are created with the <code>ln -s</code> command.</p>&#13;
<p class="noindentin"><strong>Character and block special files</strong> These files provide access to hardware devices (and pseudo-devices) through device drivers or kernel modules. These files are usually located in the <em>/dev/</em> directory. Modern Linux systems create and remove them dynamically, but they can be created manually with the <code>mknod</code> command. Block devices are typically used to access storage media, and can be buffered, cached, or otherwise abstracted. Both character and block special files are associated with devices by a major and minor number specified when the device file is created. Use the <code>ls -l</code> or <code>stat</code> commands to identify the major and minor numbers. For a list of the assigned major and minor numbers on a running Linux system, look in the <em>/sys/dev/block/</em> and <em>/sys/dev/char/</em> directories. You can list block devices with the <code>lsblk</code> command. The file size of a character or block file is zero bytes.</p>&#13;
<p class="noindentin"><strong>Named pipe or FIFO</strong> These files provide unidirectional interprocess communication between two programs. One program writing to a pipe can transfer data to another program that is reading from the same pipe. The <code>mkfifo</code> or <code>mknod</code> commands are used to create pipes. A pipe’s file size is zero bytes.</p>&#13;
<p class="noindentin"><strong>Socket files</strong> Also providing interprocess communication, these files are bi-directional, and multiple programs may use them at the same time. They are often created by a daemon providing local services (instead of using TCP/IP sockets) and are removed on exit. Socket files can also be created by systemd socket activation.</p>&#13;
</div>&#13;
<p class="indent">Why are hard links not on this list of file types? Hard links are not considered to be a file type. A <em>hard link</em> is simply an additional filename linked to an existing inode (the inode represents the actual file, as described in <a href="ch03.xhtml">Chapter 3</a>).</p>&#13;
<p class="indent">A <em>sparse file</em> is also not a file type, but rather a feature of the filesystem that allows a regular file containing continuous sequences of zeros to be written to disk in a compact form.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>When examining different file types in a postmortem forensic analysis, be aware of the following:</p>&#13;
<ul>&#13;
<li class="noindent">Block and character special files are created (and removed) in the <em>/dev/</em> or <em>/sys/</em> directories dynamically while the system is running. These directories will likely be empty during a forensic examination.</li>&#13;
<li class="noindent">Named pipes (FIFOs) and sockets will not contain any data (anything written to them is received by another running process). A program or daemon can also remove the pipe or socket file from the filesystem when it exits.</li>&#13;
<li class="noindent">A symbolic link is not required to point to an existing file. The link file will contain a filename, but the file it’s pointing to may or may not be there.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you have a forensic image of a suspect Linux system directly mounted to your Linux analysis workstation, symbolic links from the drive under analysis may point to files and directories</em> on your own analysis machine<em>. Make sure that you are always analyzing the intended filesystem.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2_53"><strong><em>Magic Strings and File Extensions</em></strong></h4>&#13;
<p class="noindent">The POSIX definition of a <em>regular file</em> refers to a filesystem file type, but the contents of this regular file can be text, pictures, videos, office documents, executable programs, databases, encrypted files, or any other content. The file content is also referred to as a file type, but at the application layer. There are several ways to identify the application file type of regular files. The phrase <em>file type</em> used in this section refers to application file types, not POSIX file types.</p>&#13;
<p class="indent">The terms <em>magic string</em>, <em>magic type</em>, <em>magic signature</em>, or <em>magic bytes</em> all refer to a string of bytes at the beginning of a file. Linux shells and file managers use magic strings to identify the file type and choose which program to run for the file in question. These strings are typically part of the file format and are difficult to modify or remove maliciously without breaking functionality. You can use the Linux <code>file</code> command to determine the file type (<code>file -l</code> lists around 3,000 supported types). Forensic carving tools also use magic strings to help identify files that can be carved from unstructured data. See the file(1) and magic(5) man pages for more information about magic strings and Linux. More information about forensic carving is described in <a href="ch03.xhtml">Chapter 3</a>.</p>&#13;
<p class="indent">File extensions are commonly used to indicate the contents of a file. For example, filenames ending with <em>.pdf</em>, <em>.docx</em>, or <em>.odt</em> are most likely office documents, whereas those ending with <em>.jpg</em>, <em>.png</em>, or <em>.gif</em> are probably images, and so on. Applications use these file extensions to determine how to open a particular file. For example, email clients use them for opening attachments, web browsers for downloads, file managers for file open requests, and so on. The simplicity of file extensions is sometimes abused to hide file content merely by changing the file extension. For example, malware may attempt <span epub:type="pagebreak" id="page_98"/>to hide executable files, corporate data theft may involve attempts to hide office documents, and people in possession of illicit material may attempt to hide the existence of media files. Although this is trivial to detect with modern forensic software, it is still commonplace.</p>&#13;
<p class="indent">Unlike in the Windows world, having multiple extensions for a single file is common in Linux and usually indicates several operations to a file (or group of files). For example, <em>files.tar.gz</em> refers to an archive (extension <em>.tar</em>) that has been compressed (extension <em>.gz</em>). Another example, <em>files.tar.gz.md5</em>, refers to a file containing the MD5 hash of the compressed archive file. When examining a Linux environment, digital forensic software must understand how to process files with multiple extensions.</p>&#13;
<h4 class="h4" id="ch00lev2_54"><strong><em>Hidden Files</em></strong></h4>&#13;
<p class="noindent">Linux uses the Unix naming convention for hidden files. A hidden file is simply a normal file or directory name starting with a dot (.). Files starting with dots indicate to programs that they don’t need to show the file in a directory listing. The use of an initial dot for hiding files was somewhat accidental. An early version of the <code>ls</code> command was written to ignore the directory “.” and “..” files, but ended up ignoring any file starting with a dot. Since then, developers have used it to hide things like configuration files that the user normally doesn’t need to see.</p>&#13;
<p class="indent">Hidden files using a dot in their filename are not really hidden. The hiding mechanism is not a technical method like a kernel or filesystem flag. It is only a naming convention that programs and applications may use (if they want) to filter out files from view. Most programs, file managers in particular, provide an option to show hidden files. When performing analysis with forensic tools, hidden files appear as normal files (because they are normal files). You don’t need to take additional steps to “unhide” them. Attempts to hide files and directories using a dot in unconventional locations may indicate suspicious activity.</p>&#13;
<p class="indent">Another method of hiding a file is by opening it and then deleting it without closing. This removes the directory entry with the filename (that is, the file is unlinked), but the inode will stay allocated until the file is closed. This method of file hiding is not persistent across reboots or if the process holding it open dies. Filesystem forensic tools should find inodes without filenames (for example, The Sleuth Kit’s <code>ils -O</code> or <code>-p</code>).</p>&#13;
<p class="indent">Malicious code can potentially hide files. Trojaned versions of programs like <code>ls</code> can be patched to prevent showing certain filenames or directories. Malicious kernel modules or rootkits can also intercept file operations and prevent viewing or accessing specific files. Kernel module rootkits can also hide processes, sockets, and kernel modules themselves (search for Linux rootkits on GitHub or other public source code repositories).</p>&#13;
<p class="indent">Simple hiding of files can also be done using filesystem permissions. Files can be hidden from other users by placing them in a read-protected directory. Users without read access won’t be able to read the contents of the directory, effectively hiding the filenames from view.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>Hiding files using trojaned binaries, rootkits, or filesystem permissions is effective only on a running system. When performing an offline postmortem forensic analysis, these files should appear normal and not hidden. Also, knowing which users had access to files and directories may be relevant to an investigation.</p>&#13;
<p class="indent">A section on file hiding should at least mention <em>steganography</em>. Multiple tools are available for hiding files using steganography, many of which can be compiled and run under Linux. As these tools are not specific to Linux systems, they are considered beyond the scope of this book.</p>&#13;
<h3 class="h3" id="ch00lev1_19"><strong>Linux File Analysis</strong></h3>&#13;
<p class="noindent">Analyzing the contents of files found on Linux systems is generally easier than in more proprietary environments. File formats tend to be open and well documented. Many files, especially configuration files, are simple ASCII text files. Very few file formats are inherently proprietary to Linux.</p>&#13;
<h4 class="h4" id="ch00lev2_55"><strong><em>Application Metadata</em></strong></h4>&#13;
<p class="noindent">In digital forensics, file metadata may refer to either the metadata stored in the filesystem inode or to the metadata stored inside the file contents. In this section, we focus on the latter.</p>&#13;
<p class="indent">The metadata from applications found on Linux systems is generally easier to analyze than that found in proprietary environments. Common open file formats are well documented and well supported by forensic tools. Applications running on Linux systems (and FOSS in general) use files falling into several categories:</p>&#13;
<ul>&#13;
<li class="noindent">Open standards (JPEG images, for example)</li>&#13;
<li class="noindent">Proprietary but reverse-engineered by open source developers (many Microsoft file formats, for example)</li>&#13;
<li class="noindent">Defined by open source application developers but specific to that application (a good example is the GIMP XCF file format)</li>&#13;
<li class="noindent">Specific to a Linux distribution (Red Hat RPM software package files, for example)</li>&#13;
<li class="noindent">Specific to a common Linux system component (systemd’s journal format, for example)</li>&#13;
</ul>&#13;
<p class="noindent">Open source and Linux-specific formats are of particular interest in Linux forensics.</p>&#13;
<p class="indent">Extracting metadata from Linux-specific files may require the use of a Linux analysis machine for best results (even if a commercial forensic tool claims to support it). Often, Linux software packages will include tools for troubleshooting, repair, data extraction, conversion, and querying. You can use these tools (often simple command line utilities) to extract both metadata and content. To find ways of displaying file metadata using Linux tools, the best source of information is the tool’s own man page.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>In many cases, you can also use the application itself (on a read-only copy of the file) to examine metadata. For example, <a href="ch04.xhtml#ch04fig02">Figure 4-2</a> shows a GIMP dialog displaying the metadata of an XCF file.</p>&#13;
<div class="image"><img id="ch04fig02" src="Images/ch04fig02.jpg" alt="Image" width="419" height="505"/></div>&#13;
<p class="figcap"><em>Figure 4-2: GIMP dialog displaying the metadata of an XCF file</em></p>&#13;
<p class="indent">Source code repositories like GitHub or GitLab often have small tools for extracting metadata from open formats. These tools may be written by students, hobbyists, professional programmers, or even companies. They may or may not provide accurate results, and I recommend comparing the results with other similar tools.</p>&#13;
<p class="indent">If all else fails, looking at the application’s source code may help. The file formats may be documented in header files or documentation included with the source software package. For example, take a look at the contents of <em>/usr/include/*.h</em>, and you’ll find many file formats (among other things). Knowing a file format’s data structures allows you to write a tool or possibly use a hex editor to extract or decode metadata from a particular file.</p>&#13;
<h4 class="h4" id="ch00lev2_56"><strong><em>Content Analysis</em></strong></h4>&#13;
<p class="noindent">As mentioned in the previous section, files found in Linux environments tend to be open and well documented. Because of this, tools are easily written to examine the content of files. Often, you can examine file contents with tools developed for data recovery, data export, or conversion to other formats, or using simple file readers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>If a file format is unknown, use the <code>file</code> command to try to identify the content. If no tools are available specifically for that file, try the <code>strings</code> command to extract the human-readable character strings contained in the file. See the file(1) and strings(1) man pages for more information.</p>&#13;
<p class="indent">Another possibility for extracting content from files, in particular compound files with other embedded files, is to use standard forensic carving tools on them. Such tools may extract files or fragments of files that may be of interest.</p>&#13;
<p class="indent">Some files found on Linux systems are backup or archive files. Traditional (but still common) examples of this are <em>tar</em>, <em>cpio</em>, and <em>dump</em>. Examples of more recent Linux backup solutions for end users include <em>duplicity</em> and <em>timeshift</em>. Common Linux enterprise backup systems include Bacula and Amanda. The forensic analysis of backup solutions is beyond the scope of this book. However, backups can be an excellent evidence source, and even the backup index databases will contain lists of filenames and directories that were backed up in the past, often together with timestamps (tar incremental backups use <em>.snar</em> files, for example).</p>&#13;
<p class="indent">Extracting the content of encrypted files is always a challenge for digital forensic investigators. Even though the encryption format may be open and documented, the data will remain inaccessible unless the cryptographic keys are recovered. Some examples of encrypted file formats you might encounter on a Linux system include:</p>&#13;
<ul>&#13;
<li class="noindent">Encrypted email using GnuPG</li>&#13;
<li class="noindent">Encryption built in to applications (office documents: PDF, DOC, and so on)</li>&#13;
<li class="noindent">GnuPG encrypted files</li>&#13;
<li class="noindent">Encrypted ZIP files</li>&#13;
<li class="noindent">Encrypted file containers like Veracrypt</li>&#13;
</ul>&#13;
<p class="indent">In most cases, native files found on Linux systems will have an identifiable and documented format, tools available to view metadata, and tools for viewing or extracting their contents. Proprietary file formats may have FOSS tools, but those will be the result of best-effort reverse engineering by volunteers.</p>&#13;
<h4 class="h4" id="ch00lev2_57"><strong><em>Executable Files</em></strong></h4>&#13;
<p class="noindent">When high-level programming code (readable by humans) is compiled into machine code (readable by CPUs), it is stored in an <em>executable</em> file format (readable by operating systems). This format gives the operating system all the information it needs to load the code into memory, set up various things (like dynamic linking with other code libraries), and run the program. Linux uses the <em>Executable and Linkable Format (ELF)</em> files taken from Unix. ELF executable files can be identified by the magic string in the first four bytes:</p>&#13;
<pre>7F 45 4C 46  .ELF</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/>A number of tools can provide information about ELF files on a Linux system. The <code>file</code> command provides a basic summary of executable files:</p>&#13;
<pre>$ <span class="codestrong1">file /bin/mplayer</span>&#13;
/bin/mplayer: ELF 64-bit LSB pie executable, x86-64, version 1&#13;
(SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2,&#13;
BuildID[sha1]=d216175c8528f418051d5d8fb1196f322b461ef2,&#13;
for GNU/Linux 3.2.0, stripped</pre>&#13;
<p class="indent">In forensics, there are several areas of interest when analyzing executable files. In the case of malware, where no source code is available, executable files must be reverse-engineered to understand precisely what they are doing. This process involves disassembling and decompiling binaries into human-readable code, a method known as <em>static analysis</em>. Another method, called <em>dynamic analysis</em>, involves running code in a sandbox with debugging and tracing tools to understand live behavior. In the case of traditional computer forensic investigations (non-malware), the focus is on metadata from the executable. Reverse engineering of executables is beyond the scope of this book, but this section explores metadata useful for investigations.</p>&#13;
<p class="indent">Some executable formats (like MS-Windows PE/COFF) have a timestamp embedded in the file indicating when the binary was built. The ELF format doesn’t define a build timestamp, but Linux executables compiled with GCC contain a unique identifier called the <em>build ID</em> (optional, but default). The build ID is an SHA-1 hash of portions of code in the executable, and most ELF analysis tools can extract it. The <code>file</code> command (shown in the preceding example) displays the <code>build-id</code> (<code>BuildID[sha1]=</code>), and the <code>readelf</code> command can display it, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">readelf -n /bin/mplayer</span>&#13;
&#13;
Displaying notes found in: .note.gnu.build-id&#13;
  Owner                Data size Description&#13;
  GNU                  0x00000014NT_GNU_BUILD_ID (unique build ID bitstring)&#13;
    Build ID: d216175c8528f418051d5d8fb1196f322b461ef2&#13;
...</pre>&#13;
<p class="indent">This ID is unique to the version of compiled code and to the build environment, but when analyzing the build ID, note the following:</p>&#13;
<ul>&#13;
<li class="noindent">The build ID will be the same whether the binary is stripped or not (symbol information is removed).</li>&#13;
<li class="noindent">It’s not always unique across machines. Two identical installations of Linux compiling the same version of code may generate the same build ID.</li>&#13;
<li class="noindent">This string can be removed or maliciously modified and there are no validity checks.</li>&#13;
<li class="noindent">Executables compiled at a central location and then copied to multiple machines will all have the same build ID.</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_103"/>This build ID may be useful for linking executable files found on multiple machines in some cases, but in other cases, it may have little or no value.</p>&#13;
<p class="indent">Other tools (such as <code>dumpelf</code> from the <code>pax-utils</code> package, <code>objdump</code>, and <code>readelf</code>) provide information about the internal structure of ELF executables, including the different headers and sections of the file. The <code>objdump</code> <code>-d</code> command also provides a disassembled output of the machine code.</p>&#13;
<p class="indent">Knowing which additional files are dynamically linked into an executable at runtime is also interesting to investigators. You normally can check this with the <code>ldd</code> command, as follows:</p>&#13;
<pre>$ <span class="codestrong1">ldd /bin/mplayer</span>&#13;
    linux-vdso.so.1 (0x00007fffe56c9000)&#13;
    libncursesw.so.6 =&gt; /usr/lib/libncursesw.so.6 (0x00007f111253e000)&#13;
    libsmbclient.so.0 =&gt; /usr/lib/libsmbclient.so.0 (0x00007f1112514000)&#13;
    libpng16.so.16 =&gt; /usr/lib/libpng16.so.16 (0x00007f11124dc000)&#13;
    libz.so.1 =&gt; /usr/lib/libz.so.1 (0x00007f11124c2000)&#13;
    libmng.so.2 =&gt; /usr/lib/libmng.so.2 (0x00007f1112252000)&#13;
    libjpeg.so.8 =&gt; /usr/lib/libjpeg.so.8 (0x00007f11121bb000)&#13;
    libgif.so.7 =&gt; /usr/lib/libgif.so.7 (0x00007f11121ae000)&#13;
    libasound.so.2 =&gt; /usr/lib/libasound.so.2 (0x00007f11120d3000)&#13;
...</pre>&#13;
<p class="indent">However, if you are analyzing a suspicious file (potential malware), using <code>ldd</code> is not recommended. The man page explicitly states “you should never employ <code>ldd</code> on an untrusted executable, since this may result in the execution of arbitrary code.” A safe alternative to finding the shared objects required is the <code>objdump</code> tool, as follows:</p>&#13;
<pre>$ <span class="codestrong1">objdump -p /bin/mplayer |grep NEEDED</span>&#13;
  NEEDED           libncursesw.so.6&#13;
  NEEDED           libsmbclient.so.0&#13;
  NEEDED           libpng16.so.16&#13;
  NEEDED           libz.so.1&#13;
  NEEDED           libmng.so.2&#13;
  NEEDED           libjpeg.so.8&#13;
  NEEDED           libgif.so.7&#13;
  NEEDED           libasound.so.2&#13;
...</pre>&#13;
<p class="indent">The examples shown here are from popular 64-bit x86 (Intel/AMD) architectures, but the Linux kernel supports dozens of different CPU architectures. Other CPUs in use at the very high end of computing (mainframes and supercomputers) and the very low end (Raspberry Pi and IoT embedded systems) can be very different. Here’s an example <code>file</code> output from a Raspberry Pi:</p>&#13;
<pre>$ <span class="codestrong1">file /usr/bin/mplayer</span>&#13;
/usr/bin/mplayer: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV),&#13;
<span epub:type="pagebreak" id="page_104"/>dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0,&#13;
BuildID[sha1]=bef918434bc5966b5bd7002c028773d3fc7d3c67, stripped</pre>&#13;
<p class="noindent">A Linux architecture can be 32 or 64 bits, big or little endian, and support a variety of CPU instruction sets (x86, ARM, PPC, Sparc, and so on). Knowing the architecture is important when using forensic tools. Unless tools automatically detect these architectural characteristics, they may need to be made aware of them to produce sensible and accurate results.</p>&#13;
<h3 class="h3" id="ch00lev1_20"><strong>Crash and Core Dumps</strong></h3>&#13;
<p class="noindent">Computers crash. Software crashes. Normally these events are upsetting, especially when data is lost. But for the forensic examiner, these events can be a good thing, as volatile memory data might be preserved during a crash. Crashed kernels, crashed processes, and other application crash data saved to the local disk have potential forensic value.</p>&#13;
<p class="indent">When computers or programs crash, they may attempt to save crash data on the local disk for programmers to analyze for debugging purposes. In some cases, those files are even uploaded to the developer’s servers for analysis. Some information saved in these crash data files may contain forensic artifacts that are useful in an investigation.</p>&#13;
<p class="indent">A kernel crash, process crash, and higher-level application and distro-specific crashes use different handling mechanisms. In each of these cases, data relevant to a forensic investigation may be saved.</p>&#13;
<p class="indent">Forensic analysis of memory dumps may either refer to recovering traces of content information from memory dump files, or to understanding code execution and reasons for the dump. Understanding code execution is often used in the analysis of malware and technical exploitation (stack and buffer overflows, and so on). Analyzing such attacks involves static and dynamic code analysis, reverse engineering, decompilation, and disassembly. This analysis requires in-depth knowledge of C, assembly, and Linux memory management. All of these concepts are beyond the intended scope of this book (in fact, this topic could easily fill an entire book on its own). Here we’ll explore a superficial analysis of memory dumps and the extraction of basic string information.</p>&#13;
<h4 class="h4" id="ch00lev2_58"><strong><em>Process Core Dumps</em></strong></h4>&#13;
<p class="noindent">When a Linux program is executed, the process resides in memory and runs until it completes, terminates from a signal (kill), or crashes. When a process crashes, the system can be configured to save a memory image or core file to disk for debugging purposes. This is called a <em>core dump</em> or <em>dumping core</em>. Let’s look at where to find core files and how to examine them in a forensic context.</p>&#13;
<p class="indent">Traditionally, the saved core from a crashed process is written to a file called core or <em>core.</em>PID, where <em>PID</em> is the numeric process ID. Later kernels used a template to create the <em>core.*</em> filename. These core files are saved in the same directory (if writable) where they crashed, and are owned by the <span epub:type="pagebreak" id="page_105"/>user ID of the crashed process. You can find a system’s core files by searching the filesystem for all files named <em>core</em>, <em>core.</em>PID, or <em>core.*</em> if using a template. See the core(5) man page for more information about core files and templates.</p>&#13;
<p class="indent">If managed by systemd, which may require installation of a separate <code>systemd-coredump</code> package, core files are saved to a single directory <em>/var/lib/ systemd/coredump/</em>. Here the core dump is sent to the <code>systemd-coredump</code> program, which logs it in the journal and saves a core file (see the systemd-coredump(8) man page). You can use the <code>coredumpctl</code> command to list systemd core dumps found in a suspect machine’s journal. The coredumpctl(1) and coredump.conf(5) man pages have more information.</p>&#13;
<p class="indent">The following example shows one line of a core dump log from an offline journal file:</p>&#13;
<pre>$ <span class="codestrong1">coredumpctl --file user-1000.journal</span>&#13;
TIME                      PID  UID  GID SIG COREFILE EXE&#13;
...&#13;
Thu 2020-11-12 13:36:48 CET <span class="ent">➊</span> 157004   1000 1000 11 <span class="ent">➋</span> present  /usr/bin/mousepad&#13;
...</pre>&#13;
<p class="indent">Here we see a list of available (<code>present</code> <span class="ent">➋</span> ) core dumps, including the time and information about the crashed program (<code>mousepad</code>) used in this example.</p>&#13;
<p class="indent">By specifying the PID from a particular crash in this list (<code>157004</code> <span class="ent">➊</span> ), we can view more information and a backtrace:</p>&#13;
<pre>  $ <span class="codestrong1">coredumpctl info 157004 --file user-1000.journal</span>&#13;
           PID: 157004 (mousepad)&#13;
           UID: 1000 (sam)&#13;
           GID: 1000 (sam)&#13;
        Signal: 11 (SEGV)&#13;
     Timestamp: Thu 2020-11-12 13:36:48 CET (4 days ago)&#13;
  Command Line: mousepad&#13;
    Executable: /usr/bin/mousepad <span class="ent">➊</span> &#13;
 Control Group: /user.slice/user-1000.slice/session-3.scope&#13;
          Unit: session-3.scope&#13;
         Slice: user-1000.slice&#13;
       Session: 3&#13;
     Owner UID: 1000 (sam)&#13;
       Boot ID: 3813c142df4b494fb95aaed7f2f6fab3&#13;
    Machine ID: 9ea4c1fdd84f44b2b4cbf3dcf6aee195&#13;
      Hostname: pc1&#13;
       Storage: /var/lib/systemd/coredump/core.mousepad.1000.&#13;
3813c142df4b494fb95aaed7f2f6fab3.157004.1605184608000000.zst <span class="ent">➋</span> &#13;
       Message: Process 157004 (mousepad) of user 1000 dumped core.&#13;
&#13;
                Stack trace of thread 157004:&#13;
                #0 0x00007fca48c0746f __poll (libc.so.6 + 0xf546f)&#13;
                #1 0x00007fca48da375f n/a (libglib-2.0.so.0 + 0xa675f)&#13;
                <span epub:type="pagebreak" id="page_106"/>#2 0x00007fca48d4ee63 g_main_loop_run (libglib-2.0.so.0 + 0x51e63)&#13;
                #3 0x00007fca493944ff gtk_main (libgtk-3.so.0 + 0x1e14ff)&#13;
                #4 0x0000564f2caff1a2 n/a (mousepad + 0x111a2)&#13;
                #5 0x00007fca48b3a152 __libc_start_main (libc.so.6 + 0x28152)&#13;
                #6 0x0000564f2caff39e n/a (mousepad + 0x1139e)&#13;
...</pre>&#13;
<p class="noindent">In this example, the <code>mousepad</code> application <span class="ent">➊</span> (a graphical text editor) dumped core, and <code>systemd-coredump</code> logged the output and saved the core file <span class="ent">➋</span> .</p>&#13;
<p class="indent">The core file was saved to the <em>/var/lib/systemd/coredump/</em> directory and can be copied to a forensic analysis machine. The filename starts with <code>core.</code>, followed by the name of the program (<code>mousepad</code>), the numeric user ID (<code>1000</code>), the boot ID, the PID, a timestamp, and, lastly, an extension with the compression used:</p>&#13;
<pre>core.mousepad.1000.3813c142df4b494fb95aaed7f2f6fab3.157004.1605184608000000.zst</pre>&#13;
<p class="noindent">Depending on the distro or configuration, the compression may be <em>zst</em>, <em>lz4</em>, or some other systemd-supported algorithm.</p>&#13;
<p class="indent">You can uncompress the core file’s contents with tools like <code>zstdcat</code> or <code>lz4cat</code>. Here is an example of a shell pipeline where a core file is uncompressed and strings are extracted to a pager for manual analysis:</p>&#13;
<pre>$ <span class="codestrong1">zstdcat core.mousepad.1000.3813c142df4b494fb95aaed7f2f6fab3.157004.16051846</span>&#13;
<span class="codestrong1">08000000.zst|strings|less</span>&#13;
...&#13;
The file contains secret info!!!&#13;
...&#13;
SHELL=/bin/bash&#13;
SESSION_MANAGER=local/pc1:@/tmp/.ICE-unix/3055,unix/pc1:/tmp/.ICE-unix/3055&#13;
WINDOWID=123731982&#13;
COLORTERM=truecolor&#13;
...</pre>&#13;
<p class="indent">The output from this <code>zstdcat</code> and strings example contains all the human-readable strings from the core dump, including the environment variables and even the unsaved text that was typed into the editor at the moment it crashed. Core dumps from programs will contain whatever data they had in memory at the time of the crash.</p>&#13;
<p class="indent">Tools such as <code>bulk_extractor</code> can carve the core file for the usual search strings and also create a wordlist of possible passwords insecurely stored in memory. You can use this wordlist with password recovery programs to attempt decryption of any encrypted files found. You can also perform forensic carving for files or file fragments (images, HTML, and so on) on the uncompressed core dump.</p>&#13;
<p class="indent">You could also use a debugger like <code>gdb</code> to further analyze the executable code.</p>&#13;
<h4 class="h4" id="ch00lev2_59"><span epub:type="pagebreak" id="page_107"/><strong><em>Application and Distro-Specific Crash Data</em></strong></h4>&#13;
<p class="noindent">Crash information helps developers debug and fix problems in their software. Crash reporting systems (which can be opt-in or opt-out) can monitor for local crashes and then send the data to developer servers for analysis.</p>&#13;
<p class="indent">A Linux distribution can have its own system crash reporting. Desktop environments can have crash reporting specific to their library toolkits, and applications can implement their own crash reporting. Let’s look at some examples.</p>&#13;
<p class="indent">Fedora and Red Hat distros use <code>abrt</code> (automated bug reporting tool). The <code>abrtd</code> daemon watches for crash events and takes appropriate action, which may include informing the user or uploading to a server managed by the distro maintainers. The <code>abrt</code> system uses plug-ins that can monitor multiple types of crashes, such as process core dumps, Python, Java, Xorg, and others. During a forensic examination, you can check several directories for the existence of crash data handled by <code>abrt</code>, such as <em>/var/spool/abrt/</em>, <em>/var/spool/abrt-upload/</em>, and <em>/var/tmp/abrt/</em>.</p>&#13;
<p class="indent">The output differs depending on the crash information’s origin. The following is an example of core dump crash data stored in <em>/var/spool/abrt/</em>:</p>&#13;
<pre># <span class="codestrong1">ls /var/spool/abrt/ccpp-2020-11-12-13\:53\:24.586354-1425/</span>&#13;
abrt_version    dso_list         os_info          proc_pid_status&#13;
analyzer        environ          os_release       pwd&#13;
architecture    executable       package          reason&#13;
cgroup          hostname         pid              rootdir &#13;
cmdline         journald_cursor  pkg_arch         runlevel&#13;
component       kernel           pkg_epoch        time&#13;
core_backtrace  last_occurrence  pkg_fingerprint  type&#13;
coredump        limits           pkg_name         uid&#13;
count           maps             pkg_release      username&#13;
cpuinfo         mountinfo        pkg_vendor       uuid&#13;
crash_function  open_fds         pkg_version</pre>&#13;
<p class="noindent">Each of these files contain some information about the crashed process, including the reason for the crash, open files, environment variables, and other data. The <code>abrt</code> system is a competitor of <code>systemd-coredump</code> as a core-dump handler.</p>&#13;
<p class="indent">Activity from <code>abrt</code> is also logged in the systemd journal:</p>&#13;
<pre>Nov 12 13:53:25 pc1 abrt-notification[1393908]: Process 1425 (geoclue) crashed in __poll()</pre>&#13;
<p class="indent">You can find the abrt system’s configuration, actions, and plug-ins in the <em>/etc/abrt/*</em> directory. For more details, see the abrt(1) and abrtd(8) man pages. The abrt system has several man pages describing various parts of the system (from a Fedora/Red Hat Linux shell, enter <span class="codestrong">apropos abrt</span> for a list). The authoritative online documentation is available at <em><a href="https://abrt.readthedocs.io/en/latest/">https://abrt.readthedocs.io/en/latest/</a></em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_108"/>Ubuntu-based systems have a daemon called Whoopsie (which sends data to a server called Daisy) and a handling system called <code>apport</code>. The <code>apport</code> program can manage crash data from core dumps, Python, package managers, and more (for more information, see <em><a href="https://wiki.ubuntu.com/Apport/">https://wiki.ubuntu.com/Apport/</a></em>).</p>&#13;
<p class="indent">When a process crashes, the core is sent to the <code>apport</code> program, which generates a report and saves it in <em>/var/crash/</em>. The <code>whoopsie</code> daemon watches this directory for new crash data.</p>&#13;
<p class="indent">On Ubuntu, you can find crash evidence in the journal and in a dedicated log, <em>/var/log/apport.log</em>, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">cat</span> <span class="codestrong1">/var/log/apport.log</span>&#13;
ERROR: apport (pid 30944) Fri Nov 13 08:25:21 2020: called for pid 26501, signal 11,&#13;
 core limit 0, dump mode 1&#13;
ERROR: apport (pid 30944) Fri Nov 13 08:25:21 2020: executable: /usr/sbin/cups-browsed&#13;
 (command line "/usr/sbin/cups-browsed")</pre>&#13;
<p class="indent">The crash report is a normal text file located in the <em>/var/crash/</em> directory:</p>&#13;
<pre># <span class="codestrong1">cat /var/crash/_usr_sbin_cups-browsed.0.crash</span>&#13;
ProblemType: Crash&#13;
Architecture: amd64&#13;
Date: Fri Nov 13 08:25:21 2020&#13;
DistroRelease: Ubuntu 18.04&#13;
ExecutablePath: /usr/sbin/cups-browsed&#13;
ExecutableTimestamp: 1557413338&#13;
ProcCmdline: /usr/sbin/cups-browsed&#13;
ProcCwd: /&#13;
ProcEnviron:&#13;
 LANG=en_US.UTF-8&#13;
 LC_ADDRESS=de_CH.UTF-8&#13;
 LC_IDENTIFICATION=de_CH.UTF-8&#13;
 LC_MEASUREMENT=de_CH.UTF-8&#13;
 LC_MONETARY=de_CH.UTF-8&#13;
 LC_NAME=de_CH.UTF-8&#13;
 LC_NUMERIC=de_CH.UTF-8&#13;
 LC_PAPER=de_CH.UTF-8&#13;
 LC_TELEPHONE=de_CH.UTF-8&#13;
 LC_TIME=de_CH.UTF-8&#13;
...</pre>&#13;
<p class="indent">This report contains various information about the crash, including base64-encoded core dump data. A unique identifier is stored in the <em>/var/ lib/whoopsie/whoopsie-id</em> file. This is an SHA-512 hash of the BIOS DMI UUID (found with <code>dmidecode</code>). This string is sent to Ubuntu (Canonical) servers to distinguish between individual machines in their logs and statistics.</p>&#13;
<p class="indent">Desktop environments may handle crashed applications on their own. For example, you can invoke the KDE crash handler through libraries and</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_109"/>save crash information to files with the <em>.kcrash</em> extension. This can also generate a crash pop-up from <code>drkonqi</code> for the desktop user (Dr. Konqi is similar to Dr. Watson on Windows). See <em><a href="https://api.kde.org/frameworks/kcrash/html/namespaceKCrash.html">https://api.kde.org/frameworks/kcrash/html/namespaceKCrash.html</a></em> and <em><a href="https://github.com/KDE/drkonqi/">https://github.com/KDE/drkonqi/</a></em> for more information on KCrash and <code>drkonqi</code>. GNOME has similar functionality with <code>bug-buddy</code>. The <code>abrt</code> crash system can also support GNOME applications.</p>&#13;
<p class="indent">Distributions may implement their own crash and bug reporting mechanisms. For example, <code>mintreport</code> creates report files in <em>/tmp/mintreport</em> about detected problems. These files contain information about the system (<em>/tmp/mintreport/inxi</em>) and a set of report subdirectories (<em>/tmp/mintreport/ reports/*</em>). These directories each contain different reports in the form of Python scripts (<em>*/MintReportInfo.py</em>). See the inxi(1) man page for more information on the <code>inxi</code> information gathering tool.</p>&#13;
<p class="indent">Crash reports are not only managed by the system or desktop environments. Applications can generate them, as well. This information is typically saved in the user’s home directory by user-run application processes. For example, Firefox will save crash data in the <em>~/.mozilla/firefox/Crash Reports/</em> subdirectory. This directory contains information about the reporting configuration (<em>crashreporter.ini</em>), a file with the time of last crash (<em>LastCrash</em>), and pending reports. The reports contain information saved by the application (Firefox, in this example). Other applications may manage their own crash logs and save data in the XDG base directories (<em>.cache/</em>, <em>.local/share/</em>, and <em>.config/</em>) in the user’s home.</p>&#13;
<h4 class="h4" id="ch00lev2_60"><strong><em>Kernel Crashes</em></strong></h4>&#13;
<p class="noindent">As we saw in the previous section, when a process crashes, only that process is affected. But when the Linux kernel (including kernel modules) crashes, the entire system is affected. A kernel crash can manifest itself as a panic or an oops. A <em>panic</em> is a condition in which the kernel is unable to continue and will halt or reboot the system. An <em>oops</em> will log error information to the ring buffer (which is captured and possibly saved by the journal or syslog), and the system will continue running. The system’s stability after an oops depends on the error, and a reboot may still be a good idea.</p>&#13;
<p class="indent">A kernel may crash in the following situations:</p>&#13;
<ul>&#13;
<li class="noindent">Bugs in the kernel code (including drivers or modules)</li>&#13;
<li class="noindent">Severe resource exhaustion (out of memory)</li>&#13;
<li class="noindent">Physical hardware problems</li>&#13;
<li class="noindent">Malicious activity affecting or targeting the kernel</li>&#13;
</ul>&#13;
<p class="indent">You can find a kernel oops in the systemd journal together with an <code>Oops</code> number like this:</p>&#13;
<pre>[178123.292445] Oops: 0002 [#1] SMP NOPTI</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_110"/>The output of a kernel oops is similar to a kernel warning message. The following is an example of a kernel warning that was observed in the systemd journal:</p>&#13;
<pre>Sep 28 10:45:20 pc1 kernel: ------------[ cut here ]------------&#13;
Sep 28 10:45:20 pc1 kernel: WARNING: CPU: 0 PID: 384 at drivers/gpu/drm/amd/amdgpu/../display/&#13;
dc/calcs/dcn_calcs.c:1452 dcn_bw_update_from_pplib.cold+0x73/0x9c [amdgpu] <span class="ent">➊</span> &#13;
Sep 28 10:45:20 pc1 kernel: Modules linked in: amd64_edac_mod(-) nls_iso8859_1 nls_cp437 amdgpu&#13;
(+) vfat iwlmvm fat mac80211 edac_mce_amd kvm_amd snd_hda_codec_realtek ccp gpu_sched ttm ...&#13;
Sep 28 10:45:20 pc1 kernel: <span class="ent">➋</span> CPU: 0 PID: 384 Comm: systemd-udevd Not tainted 5.3.1&#13;
-arch1-1-ARCH #1 <span class="ent">➌</span> &#13;
Sep 28 10:45:20 pc1 kernel: Hardware name: To Be Filled By O.E.M. To Be Filled By O.E.M./X570&#13;
Phantom Gaming X, BIOS P2.00 08/21/2019 <span class="ent">➍</span> &#13;
...&#13;
Sep 28 10:45:20 pc1 kernel: Call Trace: <span class="ent">➎</span> &#13;
Sep 28 10:45:20 pc1 kernel: dcn10_create_resource_pool+0x9a5/0xa50 [amdgpu]&#13;
Sep 28 10:45:20 pc1 kernel: dc_create_resource_pool+0x1e9/0x200 [amdgpu]&#13;
Sep 28 10:45:20 pc1 kernel: dc_create+0x243/0x6b0 [amdgpu]&#13;
...&#13;
Sep 28 10:45:20 pc1 kernel: entry_SYSCALL_64_after_hwframe+0x44/0xa9&#13;
Sep 28 10:45:20 pc1 kernel: RIP: 0033:0x7fa80119fb3e&#13;
Sep 28 10:45:20 pc1 kernel: Code: 48 8b 0d 55 f3 0b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 2e 0f&#13;
1f 84 00 00 00 00 00 90 f3 0f 1e fa 49 89 ca b8 af 00 00 00 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3&#13;
48 8b 0d 22 f3 0b 00 f7 d8 64 89 01 48&#13;
Sep 28 10:45:20 pc1 kernel: RSP: 002b:00007ffe3b6751a8 EFLAGS: 00000246 ORIG_RAX:&#13;
 00000000000000af&#13;
Sep 28 10:45:20 pc1 kernel: RAX: ffffffffffffffda RBX: 000055a6ec0954b0 RCX: 00007fa80119fb3e&#13;
Sep 28 10:45:20 pc1 kernel: RDX: 00007fa800df284d RSI: 000000000084e3b9 RDI: 000055a6eca85cd0&#13;
Sep 28 10:45:20 pc1 kernel: RBP: 00007fa800df284d R08: 000000000000005f R09: 000055a6ec0bfc20&#13;
Sep 28 10:45:20 pc1 kernel: R10: 000055a6ec08f010 R11: 0000000000000246 R12: 000055a6eca85cd0&#13;
Sep 28 10:45:20 pc1 kernel: R13: 000055a6ec0c7e40 R14: 0000000000020000 R15: 000055a6ec0954b0&#13;
Sep 28 10:45:20 pc1 kernel: ---[ end trace f37f56c2921e5305 ]---</pre>&#13;
<p class="noindent">This shows a problem with the <code>amdgpu</code> kernel module <span class="ent">➊</span>, but not one severe enough to cause a panic. The kernel logged information about the warning to the journal, including the CPU <span class="ent">➋</span>, information about the kernel <span class="ent">➌</span> and hardware <span class="ent">➍</span>, and a backtrace <span class="ent">➎</span>. Aside from the log entry, this kernel warning didn’t write any crash dump data on the disk. A kernel setting <code>kernel</code> <code>.panic_on_oops</code> can tell the kernel to panic (and possibly reboot) whenever an oops occurs.</p>&#13;
<p class="indent">Here is an example of kernel panic output to the console:</p>&#13;
<pre># <span class="codestrong1">echo c &gt; /proc/sysrq-trigger</span>&#13;
[12421482.414400] sysrq: Trigger a crash&#13;
[12421482.415167] Kernel panic - not syncing: sysrq triggered crash&#13;
[12421482.416357] CPU: 1 PID: 16002 Comm: bash Not tainted 5.6.0-2-amd64 #1 Deb1&#13;
[12421482.417971] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-4&#13;
[12421482.420203] Call Trace:&#13;
<span epub:type="pagebreak" id="page_111"/>[12421482.420761] dump_stack+0x66/0x90&#13;
[12421482.421492] panic+0x101/0x2d7&#13;
[12421482.422167] ? printk+0x58/0x6f&#13;
[12421482.422846] sysrq_handle_crash+0x11/0x20&#13;
[12421482.423701] __handle_sysrq.cold+0x43/0x101&#13;
[12421482.424601] write_sysrq_trigger+0x24/0x40&#13;
[12421482.425475] proc_reg_write+0x3c/0x60&#13;
[12421482.426263] vfs_write+0xb6/0x1a0&#13;
[12421482.426990] ksys_write+0x5f/0xe0&#13;
[12421482.427711] do_syscall_64+0x52/0x180&#13;
[12421482.428497] entry_SYSCALL_64_after_hwframe+0x44/0xa9&#13;
[12421482.429542] RIP: 0033:0x7fe70e280504&#13;
[12421482.430306] Code: 00 f7 d8 64 89 02 48 c7 c0 ff ff ff ff eb b3 0f 1f 80 03&#13;
[12421482.433997] RSP: 002b:00007ffe237f32f8 EFLAGS: 00000246 ORIG_RAX: 00000001&#13;
[12421482.435525] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007fe70e284&#13;
[12421482.436999] RDX: 0000000000000002 RSI: 00005617e0219790 RDI: 0000000000001&#13;
[12421482.438441] RBP: 00005617e0219790 R08: 000000000000000a R09: 00007fe70e310&#13;
[12421482.439869] R10: 000000000000000a R11: 0000000000000246 R12: 00007fe70e350&#13;
[12421482.441310] R13: 0000000000000002 R14: 00007fe70e34d760 R15: 0000000000002&#13;
[12421482.443202] Kernel Offset: 0x1b000000 from 0xffffffff81000000 (relocation)&#13;
[12421482.445325] ---[ end Kernel panic - not syncing: sysrq triggered crash ]--</pre>&#13;
<p class="noindent">In this example, the panic was purposely generated (<code>echo c &gt; /proc/sysrq</code> <code>-trigger</code>) and caused the system to halt immediately. The logs have no evidence of the crash because the kernel crashed before it could write anything.</p>&#13;
<p class="indent">When performing a postmortem forensic examination of a Linux system, we are looking for evidence of a crash and any potential data saved from the crash. This data may give insight into the reason for crashing (stack trace, code that can be analyzed, and so on) and memory images can be forensically carved for file fragments and strings.</p>&#13;
<p class="indent">A running kernel resides in volatile memory. When the kernel panics and halts or reboots, that memory is lost. For debugging purposes, the kernel developers created methods to save the contents of memory in the event of a kernel panic. We can use these methods as a form of forensic readiness, and configure them to preserve kernel memory as digital evidence.</p>&#13;
<p class="indent">Saving data from a crashed kernel is a chicken-or-egg problem. You need a functioning kernel to save the data, but a crashed kernel is not necessarily functional. Two software methods, <code>kdump</code> and <code>pstore</code>, attempt to solve this problem and preserve information after a kernel crash. Some hardware devices also use DMA to dump memory via PCI or Thunderbolt, but these are not Linux specific and thus not covered here.</p>&#13;
<p class="indent">The <code>pstore</code> method (if enabled) saves trace and <code>dmesg</code> information from a crash for retrieval after a reboot. Several <code>pstore</code> “backends” can save information persistently after a crash. Storage on the mainboard firmware is possible using EFI variables or ACPI error serialization. Data can also be stored in a reserved area of RAM that remains untouched after a reboot, and local block devices (partition or disk) can be used. If storage size is limited, only things like the backtrace of a crash or the tail of <code>dmesg</code> are saved. <span epub:type="pagebreak" id="page_112"/>On a running system, you can find this information in <em>/sys/fs/pstore/</em> (for EFI, this is a decompressed representation of the corresponding variables in <em>/sys/firmware/efi/efivars/</em>). Recent systemd versions (as of version 243) include the <code>systemd-pstore</code> service that copies <code>pstore</code> data to disk and clears the firmware storage so that it can be used again. It is stored in <em>/var/lib/ systemd/pstore/</em> and should be checked during an examination. If the mainboard of the suspect machine is available, you can read the EFI variables and data separately.</p>&#13;
<p class="indent">The <code>kdump</code> method employs a second kernel, loaded at boot time, that attempts to recover the memory of the first kernel when a crash occurs. Execution is handed over to the functional second kernel using <code>kexec</code> (part of the <code>kexec-tools</code> software package), which boots with a separate initrd capable of saving a full memory image to a predefined location. <a href="ch04.xhtml#ch04fig03">Figure 4-3</a> is a visual description of this process.<sup><a id="ch04foot09" href="footnotes.xhtml#ch04foot_09">9</a></sup></p>&#13;
<div class="image"><img id="ch04fig03" src="Images/ch04fig03.jpg" alt="Image" width="624" height="479"/></div>&#13;
<p class="figcap"><em>Figure 4-3: Saving a kernel image with</em> <span class="codeitalic">kdump</span></p>&#13;
<p class="indent">A common place to save kernel memory images and other information from <code>kdump</code> is <em>/var/crash/</em>. For example, a <code>kdump</code> crash directory from an Ubuntu system creates a timestamp subdirectory and looks like this:</p>&#13;
<pre># <span class="codestrong1">ls -lh /var/crash/202011150957/</span>&#13;
total 612M&#13;
-rw------- 1 root whoopsie 69K Nov 15 09:59 dmesg.202011150957&#13;
-rw------- 1 root whoopsie 612M Nov 15 09:59 dump.202011150957</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_113"/>In this example, the <em>/var/crash/202011150957/</em> directory contains the file <code>dmesg</code> output (text file) and the compressed kernel dump file, all with a timestamp as part of the filename. Other distros may use <em>vmcore</em> as a filename.</p>&#13;
<p class="indent">Kernel dump images in <em>/var/crash/</em> will likely be compressed. If you want to run carving tools, strings, or a hex editor against an image, it must be uncompressed first. You can copy the dump file to an analysis system and use the <code>makedumpfile</code> command to uncompress it:</p>&#13;
<pre>$ <span class="codestrong1">makedumpfile -d 0 dump.202011150957 raw-dump.202011150957</span>&#13;
Copying data        : [100.0 %] \      eta: 0s&#13;
&#13;
The dumpfile is saved to raw-dump.202011150957.&#13;
&#13;
makedumpfile Completed.</pre>&#13;
<p class="noindent">Here, the resulting file is roughly the same size as the physical RAM of the system under examination (assuming that all memory pages were included at the time of dump).</p>&#13;
<p class="indent">The <code>kdump</code> method was intended for debugging and doesn’t necessarily save the entire memory image. Developers are primarily interested in the kernel code and stack trace information, and the <code>makedumpfile</code> command may be configured to exclude certain memory pages. However, forensic examiners are interested in completeness, which includes the data and contents of all processes, even unused memory. When setting up <code>kdump</code> for evidence purposes (that is, forensic readiness), <code>makedumpfile</code> can be configured to save an entire memory image (using the <code>makedumpfile</code> flag <code>-d 0</code>). See the makedumpfile(8) and makedumpfile.conf(5) man pages for instructions on changing how kernel dump files are made.</p>&#13;
<p class="indent">You can use forensic carving tools (for strings or file fragments), a debugger like <code>gdb</code>, or a memory forensics tool like <code>Volatility</code> to analyze the uncompressed dump file. <span epub:type="pagebreak" id="page_114"/>Here are some examples of information that you can retrieve from carving:</p>&#13;
<ul>&#13;
<li class="noindent">Files and file fragments</li>&#13;
<li class="noindent">EXIF data from media files</li>&#13;
<li class="noindent">Credit card numbers and track 2 information</li>&#13;
<li class="noindent">Domain names</li>&#13;
<li class="noindent">Email addresses</li>&#13;
<li class="noindent">IP addresses</li>&#13;
<li class="noindent">Ethernet MAC addresses</li>&#13;
<li class="noindent">URLs</li>&#13;
<li class="noindent">Telephone numbers</li>&#13;
<li class="noindent">Custom specified regex strings</li>&#13;
</ul>&#13;
<p class="indent">Here are some examples of information that debuggers and memory forensic tools can extract:</p>&#13;
<ul>&#13;
<li class="noindent">Process list</li>&#13;
<li class="noindent">ARP table (MAC addresses and associated IPs)</li>&#13;
<li class="noindent">Open files</li>&#13;
<li class="noindent">Network interfaces</li>&#13;
<li class="noindent">Network connections</li>&#13;
<li class="noindent">Loaded kernel modules</li>&#13;
<li class="noindent">Memory-based Bash history</li>&#13;
<li class="noindent">Suspicious processes</li>&#13;
<li class="noindent">Cached TrueCrypt passphrase</li>&#13;
</ul>&#13;
<p class="indent">A full memory analysis using <code>gdb</code> or <code>Volatility</code> is beyond the scope of this book. However, enough information has been provided here to help you identify full kernel memory dumps if they reside on the disk. A free book titled <em>Linux Kernel Crash Book</em> (<em><a href="https://www.dedoimedo.com/computers/www.dedoimedo.com-crash-book.pdf">https://www.dedoimedo.com/computers/www.dedoimedo.com-crash-book.pdf</a></em>) describes kernel crashing in more detail.</p>&#13;
<h3 class="h3" id="ch00lev1_21"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter covers the origin and current directory layout of a typical Linux system, highlighting the areas of interest to forensic investigators. It also describes the challenges of creating hashsets and the NSRL for free and open source software. After reading this chapter, you should be able to identify Linux file types and understand the difference between POSIX file types in the filesystem and application content file types. In addition, this chapter provides analysis of file metadata and content, including hidden files, executables, and files containing memory dumps. You now should have the foundation to explore userspace artifacts like logs, software installation, and other user-generated activity.</p>&#13;
</div></body></html>