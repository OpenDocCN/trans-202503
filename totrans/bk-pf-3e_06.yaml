- en: Chapter 6. Turning the Tables for Proactive Defense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Turning the Tables for Proactive Defense](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, you saw how you might need to spend considerable time
    and energy making sure that the services you want to offer will be available even
    when you have strict packet filtering in place. Now, with your working setup in
    place, you’ll soon notice that some services tend to attract a little more unwanted
    attention than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the scenario: You have a network with packet filtering to match your
    site’s needs, including some services that need to be accessible to users from
    elsewhere. Unfortunately, when services are available, there’s a risk that someone
    will want to exploit them for some sort of mischief.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll almost certainly have remote login via SSH (Secure Shell), as well as
    SMTP email running on your network—both are tempting targets. In this chapter,
    we’ll look at ways to make it harder to gain unauthorized access via SSH, and
    then we’ll turn to some of the more effective ways to deny spammers use of your
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Turning Away the Brutes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Secure Shell service, commonly referred to as SSH, is a fairly crucial service
    for Unix administrators. It’s frequently the main interface to the machine and
    a favorite target of script kiddie attacks.
  prefs: []
  type: TYPE_NORMAL
- en: SSH Brute-Force Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you run an SSH login service that’s accessible from the Internet, you’ve
    probably seen entries like this in your authentication logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is what a *brute-force attack* looks like. Someone or something is trying
    by brute force to find a username and password combination that lets them get
    into your system.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest response would be to write a *pf.conf* rule that blocks all access,
    but that leads to another class of problems, including how to let people with
    legitimate business on your system access it. Setting up your `sshd` to accept
    only key-based authentication would help but most likely would not stop the kiddies
    from trying. You might consider moving the service to another port, but then again,
    the ones flooding you on port 22 would probably be able to scan their way to port
    22222 for a repeat performance.^([[30](#ftn.ch06fn01)])
  prefs: []
  type: TYPE_NORMAL
- en: Since OpenBSD 3.7 (and equivalents), PF has offered a slightly more elegant
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up an Adaptive Firewall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To thwart brute-force attacks, you can write your `pass` rules so they maintain
    certain limits on what connecting hosts can do. For good measure, you can banish
    violators to a table of addresses to which you deny some or all access. You can
    even choose to drop all existing connections from machines that overreach your
    limits. To enable this feature, first set up the table by adding the following
    line to your configuration before any filtering rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, early in your rule set, `block` brute forcers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add your `pass` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule is very similar to what you’ve seen in earlier examples. The interesting
    part in this context is the contents of the parentheses, called *state-tracking
    options*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max-src-conn` is the number of simultaneous connections allowed from one host.
    In this example, it’s set to `100`. You may want a slightly higher or lower value,
    depending on your network’s traffic patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-src-conn-rate` is the rate of new connections allowed from any single
    host. Here, it’s set to `15` connections per 5 seconds, denoted as `15/5`. Choose
    a rate that suits your setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`overload <bruteforce>` means that the address of any host that exceeds the
    preceding limits is added to the table `bruteforce`. Our rule set blocks all traffic
    from addresses in the `bruteforce` table. Once a host exceeds any of these limits
    and is put in the overload table, the rule no longer matches traffic from that
    host. Make sure that overloaders are handled, if only by a default block rule
    or similar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flush global` says that when a host reaches the limit, all states for its
    connections are terminated (flushed). The `global` option means that for good
    measure, `flush` applies to all states created by traffic from that host, no matter
    which rule created a state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can imagine, the effect of this tiny addition to the rule set is dramatic.
    After a few tries, brute forcers end up in the `bruteforce` table. That means
    that all their existing connections are terminated (flushed) and any new attempts
    will be blocked, most likely with `Fatal: timeout before authentication` messages
    at their end. You have created an *adaptive firewall* that adjusts automatically
    to conditions in your network and acts on undesirable activity.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*These adaptive rules are effective only for protection against the traditional,
    rapid-fire type of brute-force attempts. The low-intensity, distributed password-guessing
    attempts that were first identified as such in 2008 and have been recurring ever
    since (known among other names as* The Hail Mary Cloud*^([[31](#ftn.ch06fn02)]))
    don’t produce traffic that will match these rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s likely that you will want some flexibility in your rule set and want to
    allow a larger number of connections for some services, but you also might like
    to be a little more tight-fisted when it comes to SSH. In that case, you could
    supplement the general-purpose `pass` rule with something like the following one
    early in your rule set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to find the set of parameters that’s just right for your
    situation by reading the relevant man pages and the *PF User Guide* (see [Appendix A](apa.html
    "Appendix A. Resources")).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Remember that these sample rules are intended as illustrations and your network’s
    needs may be better served by different rules. Setting the number of simultaneous
    connections or the rate of connections too low may block legitimate traffic. There’s
    a potential risk of self-inflicted denial of service when the configuration includes
    many hosts behind a common NATing gateway and the users on the NATed hosts have
    legitimate business on the other side of a gateway with strict `overload` rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The state-tracking options and the `overload` mechanism don’t need to apply
    exclusively to the SSH service, and blocking all traffic from offenders isn’t
    always desired. You could, for example, use a rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `max` specifies the maximum number of states that can be created for each
    rule with no `overload` to protect a mail or Web service from receiving more connections
    than it can handle (keep in mind that the number of rules loaded depends on what
    the `$mail_services` macro expands to). Once the `max` limit is reached, new connections
    will not match this rule until the old ones terminate. Alternatively, you could
    remove the `max` restriction, add an `overload` part to the rule, and assign offenders
    to a queue with a minimal bandwidth allocation (see the discussion of traffic
    shaping in [Chapter 7](ch07.html "Chapter 7. Traffic Shaping with Queues and Priorities")
    for details on setting up queues).
  prefs: []
  type: TYPE_NORMAL
- en: Some sites use `overload` to implement a multitiered system, where hosts that
    trip one `overload` rule are transferred to one or more intermediate “probation”
    tables for special treatment. It can be useful in Web contexts not to block traffic
    from hosts in the overload tables outright but rather to redirect all HTTP requests
    from these hosts to specific Web pages (as in the `authpf` example near the end
    of [Chapter 4](ch04.html "Chapter 4. Wireless Networks Made Easy")).
  prefs: []
  type: TYPE_NORMAL
- en: Tidying Your Tables with pfctl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `overload` rules from the previous section in place, you now have
    an adaptive firewall that automatically detects undesirable behavior and adds
    offenders’ IP addresses to tables. Watching the logs and the tables can be fun
    in the short run, but because those rules only add to the tables, we run into
    the next challenge: keeping the content of the tables up-to-date and relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve run a configuration with an adaptive rule set for a while, at some
    point, you’ll discover that an IP address one of your `overload` rules blocked
    last week due to a brute-force attack was actually a dynamically assigned address,
    which is now assigned to a different ISP customer with a legitimate reason to
    communicate with hosts in your network.^([[32](#ftn.ch06fn03)]) If your adaptive
    rules catch a lot of traffic on a busy network, you may also find that the overload
    tables will grow over time to take up an increasing amount of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to *expire* table entries—to remove entries after a certain
    amount of time. In OpenBSD 4.1, `pfctl` acquired the ability to expire table entries
    based on the time since their statistics were last reset.^([[33](#ftn.ch06fn04)])
    (In almost all instances, this reset time is equal to the time since the table
    entry was added.) The keyword is `expire`, and the table entry’s age is specified
    in seconds. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command will remove `bruteforce` table entries that had their statistics
    reset more than 86,400 seconds (24 hours) ago.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The choice of 24 hours as the expiry time is a fairly arbitrary one. You should
    choose a value that you feel is a reasonable amount of time for any problem at
    the other end to be noticed and fixed. If you have adaptive rules in place, it’s
    a good idea to set up `crontab` entries to run table expiry at regular intervals
    with a command much like the preceding one to make sure your tables are kept up-to-date.*'
  prefs: []
  type: TYPE_NORMAL
- en: Giving Spammers a Hard Time with spamd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Email is a fairly essential service that needs special attention due to the
    large volume of unwanted messages, or *spam*. The volume of unsolicited commercial
    messages was already a painful problem when malware makers discovered that email-borne
    worms would work and started using email to spread their payload. During the early
    2000s, the combined volume of spam and email-borne malware had increased to the
    point where running an SMTP mail service without some sort of spam countermeasures
    had become almost unthinkable.
  prefs: []
  type: TYPE_NORMAL
- en: Spam-fighting measures are almost as old as the spam problem itself. The early
    efforts focused on analysis of the messages’ contents (known as *content filtering*)
    and to some extent on interpretation of the messages’ rather trivially forgeable
    headers, such as the purported sender address (`From:`) or the store and forward
    paths of intermediate deliveries recorded in the `Received:` headers.
  prefs: []
  type: TYPE_NORMAL
- en: When the OpenBSD team designed its spam-fighting solution `spamd`, first introduced
    with OpenBSD 3.3 in 2003, the developers instead focused on the network level
    and the immediate communication partner in the SMTP conversations along with any
    available information about hosts that tried to deliver messages. The developers
    set out to create a small, simple, and secure program. The early implementation
    was based almost entirely on creative use of PF tables combined with data from
    trusted external sources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In addition to the OpenBSD spam-deferral daemon, the content-filtering-based
    antispam package SpamAssassin* ([http://spamassassin.apache.org/](http://spamassassin.apache.org/))
    *features a program called `spamd`. Both programs are designed to help fight spam,
    but they take very different approaches to the underlying problem and don’t interoperate
    directly. However, when both programs are correctly configured and running, they
    complement each other well.*'
  prefs: []
  type: TYPE_NORMAL
- en: Network-Level Behavior Analysis and Blacklisting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original `spamd` design is based on the observation that spammers send a
    lot of mail and the incredibly small likelihood of you being the first person
    to receive a particular message. In addition, spam is sent via a few spammer-friendly
    networks and numerous hijacked machines. Both the individual messages and the
    machines that send them will be reported to blacklist maintainers quickly, and
    the blacklist data consisting of known spam senders’ IP addresses forms the basis
    for `spamd`’s processing.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with blacklisted hosts, `spamd` employs a method called *tarpitting*.
    When the daemon receives an SMTP connection, it presents its banner and immediately
    switches to a mode where it answers SMTP traffic at the rate of 1 byte per second,
    using a tiny selection of SMTP commands designed to make sure that mail is never
    delivered but rather rejected back into the sender’s queue once the message headers
    have been transferred. The intention is to waste as much time as possible on the
    sending end while costing the receiver pretty much nothing. This specific tarpitting
    implementation with 1-byte SMTP replies is often referred to as *stuttering*.
    Blacklist-based tarpitting with stuttering was the default mode for `spamd` up
    to and including OpenBSD 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*On FreeBSD and NetBSD, spamd is not part of the base system but is available
    through ports and packages as* mail/spamd*. If you’re running PF on FreeBSD or
    NetBSD, you need to install the port or package before following the instructions
    over the next few pages.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up spamd in Blacklisting Mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set up `spamd` to run in traditional, blacklisting-only mode, you first put
    a special-purpose table and a matching redirection in *pf.conf* and then turn
    your attention to `spamd`’s own *spamd.conf*. `spamd` then hooks into the PF rule
    set via the table and the redirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the *pf.conf* lines for this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the pre–OpenBSD 4.7 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The table, `<spamd>`, is there to store the IP addresses you import from trusted
    blacklist sources. The redirection takes care of all SMTP attempts from hosts
    that are already in the blacklist. `spamd` listens on port 8025 and responds s-l-o-w-l-y
    (1 byte per second) to all SMTP connections it receives as a result of the redirection.
    Later on in the rule set, you would have a rule that makes sure legitimate SMTP
    traffic passes to the mail server. *spamd.conf* is where you specify the sources
    of your blacklist data and any exceptions or local overrides you want.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*On OpenBSD 4.0 and earlier (and by extension, ports based on versions prior
    to OpenBSD 4.1),* spamd.conf *was in* /etc*. Beginning with OpenBSD 4.1,* spamd.
    conf *is found in* /etc/mail *instead. The FreeBSD port installs a sample configuration
    in* /usr/local/etc/spamd/spamd.conf.sample*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Near the beginning of *spamd.conf*, you’ll notice a line without a `#` comment
    sign that looks like `all:\`. This line specifies the blacklists you’ll use. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Add all blacklists that you want to use below the `all:\` line, separating each
    with a colon (**`:`**). To use whitelists to subtract addresses from your blacklist,
    add the name of the whitelist immediately after the name of each blacklist, as
    in `:blacklist:whitelist:`
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the blacklist definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Following the name (`uatraps`), the first data field specifies the list type—in
    this case, `black`. The `msg` field contains the message to be displayed to blacklisted
    senders during the SMTP dialogue. The `method` field specifies how `spamd-setup`
    fetches the list data—in this case, via HTTP. Other possibilities include fetching
    via FTP (`ftp`), from a file in a mounted filesystem (`file`), or via execution
    of an external program (`exec`). Finally, the `file` field specifies the name
    of the file `spamd` expects to receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a whitelist follows much the same pattern but omits the message
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The suggested blacklists in the current default* spamd.conf *are actively
    maintained and have rarely, if ever, contained false positives. However, earlier
    versions of that file also suggested lists that excluded large blocks of the Internet,
    including several address ranges that claim to cover entire countries. If your
    site expects to exchange legitimate mail with any of the countries in question,
    those lists may not be optimal for your setup. Other popular lists have been known
    to list entire `/16` ranges as spam sources, and it’s well worth reviewing the
    details of the list’s maintenance policy before putting a blacklist into production.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the lines for `spamd` and the startup parameters you want in your */etc/
    rc.conf.local* on OpenBSD or in */etc/rc.conf* on FreeBSD or NetBSD. Here’s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we enable `spamd` and set it to run in blacklisting mode with the `-b`
    flag. In addition, the `-v` flag enables verbose logging, which is useful for
    keeping track of `spamd`’s activity for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On FreeBSD, the */etc/rc.conf* settings that control `spamd`’s behavior are
    `obspamd_enable`, which should be set to `"YES"` in order to enable `spamd`, and
    `obspamd_flags`, where you fill in any command-line options for `spamd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*To have spamd run in pure blacklist mode on OpenBSD 4.1 or newer, you can
    achieve the same effect by setting the spamd_black variable to “YES” and then
    restarting spamd.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished editing the setup, start `spamd` with the options you want
    and complete the configuration with `spamd-setup`. Finally, create a `cron` job
    that calls `spamd-setup` to update the blacklist at reasonable intervals. In pure
    blacklist mode, you can view and manipulate the table contents using `pfctl` table
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: spamd Logging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, `spamd` logs to your general system logs. To send the `spamd` log
    messages to a separate log file, add an entry like this to *syslog.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you’re satisfied that `spamd` is running and doing what it’s supposed to
    do, you’ll probably want to add the `spamd` log file to your log rotations, too.
    After you’ve run `spamd-setup` and the tables are filled, you can view the table
    contents using `pfctl`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In the sample* pf.conf *fragment at the beginning of this section, the redirection*
    (*rdr-to) rule is also a pass rule. If you opted for a match rule instead (or
    if you’re using an older PF version and chose to write a rdr rule that doesn’t
    include a pass part), be sure to set up a pass rule to let traffic through to
    your redirection. You may also need to set up rules to let legitimate email through.
    However, if you’re already running an email service on your network, you can probably
    go on using your old SMTP pass rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: Given a set of reliable and well-maintained blacklists, `spamd` in pure blacklisting
    mode does a good job of reducing spam. However, with pure blacklisting, you catch
    traffic only from hosts that have already tried to deliver spam elsewhere, and
    you put your trust in external data sources to determine which hosts deserve to
    be tarpitted. For a setup that provides a more immediate response to network-level
    behavior and offers some real gains in spam prevention, consider *greylisting*,
    which is a crucial part of how the modern `spamd` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Greylisting: My Admin Told Me Not to Talk to Strangers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Greylisting consists mainly of interpreting the current SMTP standards and adding
    a little white lie to make life easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spammers tend to use other people’s equipment to send their messages, and the
    software they install without the legal owner’s permission needs to be relatively
    lightweight in order to run undetected. Unlike legitimate mail senders, spammers
    typically don’t consider any individual message they send to be important. Taken
    together, this means that typical spam and malware sender software aren’t set
    up to interpret SMTP status codes correctly. This is a fact that we can use to
    our advantage, as Evan Harris proposed in his 2003 paper titled “The Next Step
    in the Spam Control War: Greylisting.” ^([[34](#ftn.ch06fn05)])'
  prefs: []
  type: TYPE_NORMAL
- en: As Harris noted, when a compromised machine is used to send spam, the sender
    application tends to try delivery only once, without checking for any results
    or return codes. Real SMTP implementations interpret SMTP return codes and act
    on them, and real mail servers retry if the initial attempt fails with any kind
    of temporary error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his paper, Harris outlined a practical approach:'
  prefs: []
  type: TYPE_NORMAL
- en: On first SMTP contact from a previously unknown communication partner, *do not*
    receive email on the first delivery attempt, but instead, respond with a status
    code that indicates a temporary local problem, and store the sender IP address
    for future reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the sender retries immediately, reply as before with the temporary failure
    status code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the sender retries after a set minimum amount of time (1 hour, for example)
    but not more than a maximum waiting period (4 hours, for example), accept the
    message for delivery and record the sender IP address in your whitelist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the essence of greylisting. And fortunately, you can set up and maintain
    a greylisting `spamd` on your PF-equipped gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up spamd in Greylisting Mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenBSD’s `spamd` acquired its ability to greylist in OpenBSD 3.5\. Beginning
    with OpenBSD 4.1, `spamd` runs in greylisting mode by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the default greylisting mode, the `spamd` table used for blacklisting, as
    described in the previous section, becomes superfluous. You can still use blacklists,
    but `spamd` will use a combination of private data structures for blacklist data
    and the `spamdb` database to store greylisting-related data. A typical set of
    rules for `spamd` in default mode looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This includes the necessary `pass` rules to let legitimate email flow to the
    intended destinations from your own network. The `<spamd-white>` table is the
    whitelist, maintained by `spamd`. The hosts in the `<spamd-white>` table have
    passed the greylisting hurdle, and mail from these machines is allowed to pass
    to the real mail servers or their content-filtering frontends. In addition, the
    `nospamd` table is there for you to load addresses of hosts that you don’t want
    to expose to `spamd` processing, and the matching `pass` rule makes sure SMTP
    traffic from those hosts passes.
  prefs: []
  type: TYPE_NORMAL
- en: In your network, you may want to tighten those rules to pass SMTP traffic only
    to and from hosts that are allowed to send and receive email via SMTP. We’ll get
    back to the `nospamd` table in [Handling Sites That Do Not Play Well with Greylisting](ch06.html#handling_sites_that_do_not_play_well_wit
    "Handling Sites That Do Not Play Well with Greylisting").
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the equivalent rules in pre–OpenBSD 4.7 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: On FreeBSD, in order to use `spamd` in greylisting mode, you need a file descriptor
    filesystem (see `man 5 fdescfs`) mounted at */dev/fd/*. To implement this, add
    the following line to */etc/fstab* and make sure the `fdescfs` code is in your
    kernel, either compiled in or by loading the module via the appropriate `kldload`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To begin configuring `spamd`, place the lines for `spamd` and the startup parameters
    you want in */etc/rc.conf.local*. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On FreeBSD, the equivalent line should go in */etc/rc.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can fine-tune several of the greylisting-related parameters via `spamd`
    command-line parameters trailing the `-G` option.
  prefs: []
  type: TYPE_NORMAL
- en: Why Greylisting Works
  prefs: []
  type: TYPE_NORMAL
- en: A significant amount of design and development effort has been put into making
    essential services, such as SMTP email transmission, fault-tolerant. In practical
    terms, this means that the best effort of a service such as SMTP is as close as
    you can get to having a perfect record for delivering messages. That’s why we
    can rely on greylisting to eventually let us receive email from proper mail servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current standard for Internet email transmission is defined in RFC 5321.^([[35](#ftn.ch06fn05a)])
    The following are several excerpts from Section 4.5.4.1, “Sending Strategy”:'
  prefs: []
  type: TYPE_NORMAL
- en: “In a typical system, the program that composes a message has some method for
    requesting immediate attention for a new piece of outgoing mail, while mail that
    cannot be transmitted immediately MUST be queued and periodically retried by the
    sender. . . .
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “The sender *MUST* delay retrying a particular destination after one attempt
    has failed. In general, the retry interval *SHOULD* be at least 30 minutes; however,
    more sophisticated and variable strategies will be beneficial when the SMTP client
    can determine the reason for non-delivery.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Retries continue until the message is transmitted or the sender gives up; the
    give-up time generally needs to be at least 4–5 days.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Delivering email is a collaborative, best-effort process, and the RFC clearly
    states that if the site you are trying to send mail to reports that it can’t receive
    at the moment, it is your duty (a must requirement) to try again later, giving
    the receiving server a chance to recover from its problem.
  prefs: []
  type: TYPE_NORMAL
- en: The clever wrinkle to greylisting is that it’s a convenient white lie. When
    we claim to have a temporary local problem, that problem is really the equivalent
    of “My admin told me not to talk to strangers.” Well-behaved senders with valid
    messages will call again, but spammers won’t wait around for the chance to retry,
    since doing so increases their cost of delivering messages. This is why greylisting
    still works, and since it’s based on strict adherence to accepted standards,^([[36](#ftn.ch06fn05b)])
    false positives are rare.
  prefs: []
  type: TYPE_NORMAL
- en: 'The colon-separated list `2:4:864` represents the values `passtime`, `greyexp`,
    and `whiteexp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`passtime` denotes the minimum number of minutes `spamd` considers a reasonable
    time before retry. The default is 25 minutes, but here we’ve reduced it to 2 minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`greyexp` is the number of hours an entry stays in the greylisted state before
    it’s removed from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whiteexp` determines the number of hours a whitelisted entry is kept. The
    default values for `greyexp` and `whiteexp` are 4 hours and 864 hours (just over
    1 month), respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greylisting in Practice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Users and administrators at sites that implement greylisting tend to agree that
    greylisting gets rid of most of their spam, with a significant drop in the load
    on any content filtering they have in place for their mail. We’ll start by looking
    at what `spamd`’s greylisting looks like according to log files and then return
    with some data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start `spamd` with the `-v` command-line option for verbose logging,
    your logs will include a few more items of information in addition to IP addresses.
    With verbose logging, a typical log excerpt looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first line is the beginning of a connection from a machine in the `spews1`
    blacklist. The next six lines show the complete records of two connection attempts
    from another machine, which each time connects as the second active connection.
    This second machine isn’t yet in any blacklist, so it’s grey-listed. Note the
    rather curious delivery address (*[wkitp98zpu.fsf@datadok.no](mailto:wkitp98zpu.fsf@datadok.no)*)
    in the message that the greylisted machine tries to deliver. There’s a useful
    trick that we’ll look at in [Greytrapping](ch06.html#greytrapping "Greytrapping").
    The `(GREY)` and `(BLACK)` before the addresses indicate greylisting or blacklisting
    status. Then there’s more activity from the blacklisted host, and a little later
    we see that after 404 seconds (or 6 minutes and 44 seconds), the blacklisted host
    gives up without completing the delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining lines show a few very short connections, including one from a
    machine already on a blacklist. This time, though, the machine disconnects too
    quickly to see any `(BLACK)` flag at the beginning of the SMTP dialogue, but we
    see a reference to the list name (`spews1`) at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly 400 seconds is about the amount of time that naive blacklisted spammers
    hang around (according to data from various sites) and about the time it takes
    (at the rate of 1 byte per second) to complete the `EHLO ...` dialogue until `spamd`
    rejects the message. However, while peeking at the logs, you’re likely to find
    some spammers that hang around significantly longer. For example, in the data
    from our office gateway, one log entry stood out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This particular machine was already on several blacklists when it made 13 attempts
    at delivery from December 9 through December 12\. The last attempt lasted 32 minutes
    and 44 seconds, without completing the delivery. Relatively intelligent spam senders
    drop the connection during the first few seconds, like the ones in the first log
    fragment. Others give up after around 400 seconds. A few hang on for hours. (The
    most extreme case we’ve recorded hung on for 42,673 seconds, which is almost 12
    hours.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Tracking Your Real Mail Connections: spamlogd'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Behind the scenes, rarely mentioned and barely documented, is one of `spamd`’s
    most important helper programs: the `spamlogd` whitelist updater. As the name
    suggests, `spamlogd` works quietly in the background, logging connections to and
    from your mail servers to keep your whitelist updated. The idea is to make sure
    that valid mail sent between hosts you communicate with regularly goes through
    with a minimum of fuss.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you’ve followed the discussion up to this point, `spamlogd` has probably
    been started automatically already. However, if your initial `spamd` configuration
    didn’t include greylisting, `spamlogd` may not have been started, and you may
    experience strange symptoms, like the greylist and whitelist not being updated
    properly. Restarting `spamd` after you’ve enabled greylisting should ensure that
    `spamlogd` is loaded and available, too.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform its job properly, `spamlogd` needs you to log SMTP connections
    to and from your mail servers, just as we did in the sample rule sets in [Chapter 5](ch05.html
    "Chapter 5. Bigger or Trickier Networks"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'On OpenBSD 4.1 and higher (and equivalents), you can create several `pflog`
    interfaces and specify where rules should be logged. Here’s how to separate the
    data `spamlogd` needs to read from the rest of your PF logs:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a separate `pflog1` interface using `ifconfig pflog1 create`, or create
    a *hostname.pflog1* file with just the line `up`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the rules to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add `-l pflog1` to `spamlogd`’s startup parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This separates the `spamd`-related logging from the rest. (See [Chapter 9](ch09.html
    "Chapter 9. Logging, Monitoring, and Statistics") for more about logging.)
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding rules in place, `spamlogd` will add the IP addresses that
    receive email you send to the whitelist. This isn’t an ironclad guarantee that
    the reply will pass immediately, but in most configurations, it helps speed things
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Greytrapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that spam senders rarely use a fully compliant SMTP implementation to
    send their messages, which is why greylisting works. We also know that spammers
    rarely check that the addresses they feed to their hijacked machines are actually
    deliverable. Combine these facts, and you see that if a greylisted machine tries
    to send a message to an invalid address in your domain, there’s a good chance
    that the message is spam or malware.
  prefs: []
  type: TYPE_NORMAL
- en: This realization led to the next evolutionary step in `spamd` development—a
    technique dubbed *greytrapping*. When a greylisted host tries to deliver mail
    to a known bad address in our domains, the host is added to a locally maintained
    blacklist called `spamd-greytrap`. Members of the `spamd-greytrap` list are treated
    to the same 1-byte-per-second tarpitting as members of other blacklists.
  prefs: []
  type: TYPE_NORMAL
- en: Greytrapping as implemented in `spamd` is simple and elegant. The main thing
    you need as a starting point is `spamd` running in greylisting mode. The other
    crucial component is a list of addresses in domains your servers handle email
    for, but only ones that you’re sure will never receive legitimate email. The number
    of addresses in your list is unimportant, but there must be at least one, and
    the upper limit is mainly defined by how many addresses you wish to add.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use `spamdb` to feed your list to the greytrapping feature and sit
    back to watch. First, a sender tries to send email to an address on your grey-trap
    list and is simply greylisted, as with any sender you haven’t exchanged email
    with before. If the same machine tries again, either to the same, invalid address
    or another address on your greytrapping list, the greytrap is triggered, and the
    offender is put into `spamd-greytrap` for 24 hours. For the next 24 hours, any
    SMTP traffic from the greytrapped host will be stuttered, with 1-byte-at-a-time
    replies.
  prefs: []
  type: TYPE_NORMAL
- en: That 24-hour period is short enough not to cause serious disruption of legitimate
    traffic because real SMTP implementations will keep trying to deliver for at least
    a few days. Experience from large-scale implementations of the technique shows
    that it rarely produces false positives. Machines that continue spamming after
    24 hours will make it back to the tarpit soon enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up your traplist, use `spamdb`’s `-T` option. In my case, the strange
    address^([[37](#ftn.ch06fn06)]) I mentioned earlier in [Greylisting in Practice](ch06.html#greylisting_in_practice
    "Greylisting in Practice") was a natural candidate for inclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The command I actually entered was `$ sudo spamdb -T -a "<wkitp98zpu.fsf@datadok.no>"`.
    In OpenBSD 4.1 and newer, `spamdb` doesn’t require the angle brackets or quotes,
    but it will accept them.
  prefs: []
  type: TYPE_NORMAL
- en: Add as many addresses as you like. I tend to find new additions for my local
    list of spamtrap addresses by looking in the greylist and mail server logs for
    failed attempts to deliver delivery failure reports to nonexistent addresses in
    my domains (yes, it really is as crazy as it sounds).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Make sure that the addresses you add to your spamtrap lists are invalid and
    will stay invalid. There’s nothing quite like the embarrassment of discovering
    that you made a valid address into a spamtrap, however temporarily.*'
  prefs: []
  type: TYPE_NORMAL
- en: The following log fragment shows how a spam-sending machine is grey-listed at
    first contact and then comes back and clumsily tries to deliver messages to the
    curious address I added to my traplist, only to end up in the `spamd-greytrap`
    blacklist after a few minutes. We know what it will be doing for the next 20-odd
    hours.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, it looks like even though the spammer moved to send from a different
    machine, both the `From:` and `To:` addresses stayed the same. The fact that he’s
    still trying to send to an address that’s never been deliverable is a strong indicator
    that this spammer doesn’t check his lists frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Lists with spamdb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There may be times when you need to view or change the contents of blacklists,
    whitelists, and greylists. These records are located in the */var/db/spamdb* database,
    and an administrator’s main interface to managing those lists is `spamdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Early versions of `spamdb` simply offered options to add whitelist entries to
    the database or update existing ones (`spamdb -a` *nn*`.`*mm*`.`*nn*`.`*mm*).
    You could delete whitelist entries (`spamdb -d` *nn*`.`*mm*`.`*nn*`.`*mm*) to
    compensate for shortcomings in either the blacklists used or the effects of the
    greylisting algorithms. Recent versions of `spamdb` offer some interesting features
    to support greytrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you run `spamdb` without any parameters, it lists the contents of your `spamdb`
    database, and it lets you add or delete both spamtrap addresses and traplist entries.
    You can also add whitelist entries on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add a host to your whitelist without adding it to your permanent
    *nospamd* file and reloading your rule set or the table, you could do it from
    the command line instead, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If a spam sender managed to get a message delivered despite your best efforts,
    you could correct the situation by adding the spam sender to the `spamd-greytrap`
    list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a new trap address is just as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you want to reverse either of these decisions, you would simply substitute
    `-d` for the `-a` option in both these commands.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping spamd Greylists in Sync
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Beginning with OpenBSD 4.1, `spamd` can keep greylisting databases in sync
    across any number of cooperating greylisting gateways. The implementation is via
    a set of `spamd` command-line options:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-Y` option specifies a *sync target*—that is, the IP address(es) of other
    `spamd`-running gateways you want to inform of updates to your greylisting information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the receiving end, the `-y` option specifies a *sync listener*, which is
    the address or interface where this `spamd` instance is prepared to receive greylisting
    updates from other hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, our main `spamd` gateway `mainoffice-gw.example.com` might have
    the following options added to its startup command line to establish a sync target
    and sync listener, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, `minorbranch-gw.example.com` at the branch office would have the
    hostnames reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `spamd` daemon also supports shared-secret authentication between the synchronization
    partners. Specifically, if you create the file */etc/mail/ spamd.key* and distribute
    copies of it to all synchronization partners, it’ll be used to calculate the necessary
    checksums for authentication. The *spamd.key* file itself can be any kind of data,
    such as random data harvested from */dev/arandom*, as suggested by the `spamd`
    man page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In situations where direct synchronization of `spamd`-related data isn’t practical
    or if you simply want to share your `spamd-greytrap` with others, exporting the
    contents of your list of locally trapped spam senders to a text file may be desirable.
    The list format `spamd-setup` expects is one address per line, optionally with
    comment lines starting with one or more # characters. Exporting your list of currently
    trapped addresses in a usable format can be as simple as putting together a one-liner
    with `spamdb, grep`, and a little imagination.*'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Out-of-Order MX Use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenBSD 4.1 gave `spamd` the ability to detect out-of-order MX use. Contacting
    a secondary mail exchanger first instead of trying the main one is a fairly well-known
    spammer trick and one that runs contrary to the behavior we expect from ordinary
    email transfer agents. In other words, if someone tries the email exchangers in
    the wrong order, we can be pretty sure that they’re trying to deliver spam.
  prefs: []
  type: TYPE_NORMAL
- en: For our *example.com* domain with main mail server 192.0.2.225 and backup 192.0.2.224,
    adding `-M 192.0.2.224` to `spamd`’s startup options would mean that any host
    that tries to contact 192.0.2.224 via SMTP before contacting the main mail server
    at 192.0.2.225 will be added to the local `spamdgreytrap` list for the next 24
    hours.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Sites That Do Not Play Well with Greylisting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, there are situations where you’ll need to compensate for the
    peculiarities of other sites’ email setups.
  prefs: []
  type: TYPE_NORMAL
- en: The first email message sent from any site that hasn’t contacted you for as
    long as the greylister keeps its data around will be delayed for some random amount
    of time, which depends mainly on the sender’s retry interval. There are times
    when even a minimal delay is undesirable. If, for example, you have some infrequent
    customers who demand your immediate and urgent attention to their business when
    they do contact you, an initial delivery delay of what could be up to several
    hours may not be optimal. In addition, you are bound to encounter misconfigured
    mail servers that either don’t retry at all or retry too quickly, perhaps stopping
    delivery retries after just one attempt.
  prefs: []
  type: TYPE_NORMAL
- en: Also, some sites are large enough to have several outgoing SMTP servers, and
    they don’t play well with greylisting because they’re not guaranteed to retry
    delivery of any given message from the same IP address used with the prior delivery
    attempt. Even though those sites comply with the retry requirements, it’s obvious
    that this is one of the few remaining downsides of greylisting.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to compensate for such situations is to define a table for a local
    whitelist to be fed from a file in case of reboots. To make sure SMTP traffic
    from the addresses in the table is not fed to `spamd`, add a `pass` rule to allow
    the traffic to pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In pre–OpenBSD 4.7 syntax, add a `no rdr` rule at the top of your redirection
    block and a matching `pass` rule to let SMTP traffic from the hosts in your `nospamd`
    table through, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve made these changes to your rule set, enter the addresses you need
    to protect from redirection into the */etc/mail/nospamd* file. Then reload your
    rule set using `pfctl -f /etc/pf.conf`. You can then use all the expected table
    tricks on the `<nospamd>` table, including replacing its content after editing
    the *nospamd* file. In fact, this approach is strongly hinted at in both man pages
    and sample configuration files distributed with recent versions of `spamd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At least some sites with many outgoing SMTP servers publish information about
    which hosts are allowed to send email for their domain via Sender Policy Framework
    (SPF) records as part of the domain’s DNS information.^([[38](#ftn.ch06fn07)])
    To retrieve the SPF records for our *example.com* domain, use the `host` command’s
    `-ttxt` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This command would produce an answer roughly like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the text in quotes is the *example.com* domain’s SPF record. If you want
    email from *example.com* to arrive quickly and you trust the people there not
    to send or relay spam, choose the address range from the SPF record, add it to
    your *nospamd* file, and reload the `<nospamd>` table contents from the updated
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Spam-Fighting Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When used selectively, blacklists combined with `spamd` are powerful, precise,
    and efficient spam-fighting tools. The load on the `spamd` machine is minimal.
    On the other hand, `spamd` will never perform better than its weakest data source,
    which means you’ll need to monitor your logs and use whitelisting when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also feasible to run `spamd` in a pure greylisting mode, with no blacklists.
    In fact, some users report that a purely greylisting `spamd` configuration is
    about as effective a spam-fighting tool as configurations with blacklists and
    sometimes significantly more effective than content filtering. One such report
    posted to *openbsd-misc* claimed that a pure greylisting configuration immediately
    rid the company of approximately 95 percent of its spam load. (This report is
    accessible via *[http://marc.info/](http://marc.info/)*, among other places; search
    for the subject “Followup – spamd greylisting results.”)
  prefs: []
  type: TYPE_NORMAL
- en: I recommend two very good blacklists. One is Bob Beck’s traplist based on “ghosts
    of usenet postings past.” Generated automatically by computers running `spamd`
    at the University of Alberta, Bob’s setup is a regular `spamd` system that removes
    trapped addresses automatically after 24 hours, which means that you get an extremely
    low number of false positives. The number of hosts varies widely and has been
    as high as 670,000\. While still officially in testing, the list was made public
    in January 2006\. The list is available from *[http://www.openbsd.org/spamd/traplist.gz](http://www.openbsd.org/spamd/traplist.gz)*.
    It’s part of recent sample *spamd.conf* files as the `uatraps` blacklist.
  prefs: []
  type: TYPE_NORMAL
- en: The other list I recommend is *heise.de*’s `nixspam`, which has a 12-hour automatic
    expiry and extremely good accuracy. It’s also in the sample *spamd.conf* file.
    Detailed information about this list is available from *[http://www.heise.de/ix/nixspam/dnsbl_en/](http://www.heise.de/ix/nixspam/dnsbl_en/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re happy with your setup, try introducing local greytrapping. This
    is likely to catch a few more undesirables, and it’s good, clean fun. Some limited
    experiments—carried out while writing this chapter (chronicled at *[http://bsdly.blogspot.com/](http://bsdly.blogspot.com/)*
    in entries starting with *[http://bsdly.blogspot.com/2007/07/hey-spammer-heres-list-for-you.html](http://bsdly.blogspot.com/2007/07/hey-spammer-heres-list-for-you.html)*)—even
    suggest that harvesting the invalid addresses spammers use from your mail server
    logs, from `spamd` logs, or directly from your greylist to put in your traplist
    is extremely efficient. Publishing the list on a moderately visible Web page appears
    to ensure that the addresses you put there will be recorded over and over again
    by address-harvesting robots and will provide you with even better greytrapping
    material, as they’re then more likely to be kept on the spammers’ list of known
    good addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[30](#ch06fn01)]) At the time this chapter was first written, this was purely
    theoretical; I hadn’t yet had any credible reports that this was happening. That
    changed during 2012 when reliable sources started reporting the appearance of
    brute-force sequences at odd ports. See *[http://bsdly.blogspot.com/2013/02/theres-no-protection-in-high-ports.html](http://bsdly.blogspot.com/2013/02/theres-no-protection-in-high-ports.html)*
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[31](#ch06fn02)]) For an overview of the Hail Mary Cloud sequence of brute-force
    attempts, see the article “The Hail Mary Cloud and the Lessons Learned” at *[http://bsdly.blogspot.com/2013/10/the-hail-mary-cloud-and-lessons-learned.html](http://bsdly.blogspot.com/2013/10/the-hail-mary-cloud-and-lessons-learned.html)*.
    More resources are referenced there and in [Appendix A](apa.html "Appendix A. Resources").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[32](#ch06fn03)]) From a longer-term perspective, it’s fairly normal for
    entire networks and larger ranges of IP addresses to be reassigned to new owners
    in response to events in the physical, business-oriented world.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[33](#ch06fn04)]) Before `pfctl` acquired the ability to expire table entries,
    table expiry was more likely than not handled by the special-purpose utility `expiretable`.
    If your `pfctl` doesn’t have the `expire` option, you should seriously consider
    upgrading to a newer system. If upgrading is for some reason not practical, look
    for `expiretable` in your package system.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[34](#ch06fn05)]) The original Harris paper and a number of other useful
    articles and resources can be found at *[http://www.greylisting.org/](http://www.greylisting.org/)*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[35](#ch06fn05a)]) The relevant parts of RFC 5321 are identical to the corresponding
    parts of RFC 2821, which is obsolete. Some of us were more than a little disappointed
    that the IETF didn’t clarify these chunks of the text, now moving forward on the
    standards track. My reaction (actually, it’s quite a rant) is at *[http://bsdly.blogspot.com/2008/10/ietf-failed-to-account-for-greylisting.html](http://bsdly.blogspot.com/2008/10/ietf-failed-to-account-for-greylisting.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[36](#ch06fn05b)]) The relevant RFCs are mainly RFC 1123 and RFC 5321, which
    made obsolete the earlier RFC 2821\. Remember that temporary rejection is an SMTP
    fault-tolerance feature.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[37](#ch06fn06)]) Of course, this address is totally bogus. It looks like
    the kind of message ID the GNUS email and news client generates, and it was probably
    lifted from a news spool or some unfortunate malware victim’s mailbox.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#ch06fn07)]) SPF records are stored in DNS zones as TXT records. See
    *[http://www.openspf.org/](http://www.openspf.org/)* for details.
  prefs: []
  type: TYPE_NORMAL
