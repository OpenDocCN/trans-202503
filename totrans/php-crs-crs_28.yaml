- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 23 ERROR HANDLING WITH EXCEPTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applications don’t always function the way you want. For example, a file may
    not upload because of a network error, or data from a user or web API may be malformed
    in some way. In this chapter, you’ll learn to use *exceptions* to anticipate these
    sorts of problems and recover from them, so your application doesn’t always crash
    when something goes wrong. You’ll work with PHP’s generic Exception class, along
    with other, more specialized exception classes built into the language. You’ll
    also see how to design your own custom exception classes, as well as how to design
    your applications to safely handle any and all exceptions that may arise.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Basics of Exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '*Exceptions* are classes that provide a sophisticated and customizable approach
    to handling and recovering from anticipated, problematic circumstances in OOP.
    They differ from *errors*, which arise from circumstances or events that can’t
    be recovered from, such as the computer system running out of memory or a class
    declaration attempting to use a constant that can’t be found. PHP has a built-in
    Exception class for handling generic problems, along with other more specialized
    exception classes that cater to particular types of errors. You can also develop
    your own custom exception classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exception-based software design allows you to write code in the most natural
    sequence, assuming it will all work fine, and then to separately write code to
    capture and address any typical problems that may occur. This involves writing
    tests into the methods of a class that generate exception objects and disrupt
    the flow of program control whenever an unusual or invalid situation occurs, such
    as providing invalid arguments for a constructor or setter method. Thanks to these
    tests, code appearing later in a method can be written with the safe assumption
    that if execution gets that far, the exception-throwing conditions haven’t occurred,
    and the code is working as it should.
  prefs: []
  type: TYPE_NORMAL
- en: Central to exception-based application programming are throw and catch statements.
    A method uses a throw statement to create an exception object when a problem occurs.
    This is called *throwing an exception*. The throw statement halts the execution
    of the method and disrupts the flow of the program. By itself, throwing an exception
    can lead to a fatal error, unless you *catch* the exception with a catch statement.
    The catch statement features code that’s intended to be executed when an exception
    is thrown; such code may allow the application to recover from the issue, or if
    non-recoverable, then the problem can be logged and execution ended gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore the basics of throwing and catching exceptions.
    We’ll also look at finally statements, pieces of code that are executed at the
    end of a process, regardless of whether an exception has been thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an Exception
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we’ll consider how to throw an uncaught exception to cause a fatal error,
    halting an application. We’ll examine the common use case of throwing an exception
    when an invalid argument is provided to the setter method of a class. We’ll create
    a variation of the Food and Dessert classes from [Chapter 19](chapter19.xhtml),
    adding exception-based validation behavior in the setCalories() method of the
    Dessert class. An exception will be thrown if a negative value is provided as
    the number of calories for a new Dessert object. The project we’ll create is illustrated
    in the UML class diagram in [Figure 23-1](#fig23-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure23-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23-1: A diagram showing an exception thrown by the Dessert class'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that Dessert is a subclass of Food, with its own __toString() method
    and a calories property. The diagram indicates that an invalid calories value
    will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll declare the Food class. Create a new project with *src/Food.php*
    containing the code in [Listing 23-1](#lis23-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-1: The Food superclass'
  prefs: []
  type: TYPE_NORMAL
- en: We assign the Food class to the Mattsmithdev namespace and give it a name property
    with protected visibility so that all subclasses can directly access it. The class
    has a straightforward constructor to initialize name when each new object is created,
    and a __toString() method to return a string in the form "(FOOD) name".
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now declare the Dessert subclass of Food. Create *src/Dessert.php* and
    enter the contents of [Listing 23-2](#lis23-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-2: The Dessert class, which throws an exception if the calories
    value is invalid'
  prefs: []
  type: TYPE_NORMAL
- en: The Dessert class has a calories property assigned in the constructor via the
    setCalories() method ❶. This way, we reserve any validation logic for the setter
    method itself, so every new calories value will be vetted, regardless of whether
    it’s provided at the time of object construction or via the setter at a later
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Within setCalories(), we perform the validation with an if statement ❷. If the
    provided integer argument $calories is less than 0, we throw a new Exception object,
    with the message 'attempting to set calories to a negative value'. If the $calories
    argument is 0 or more and no exception is thrown, the code continues by storing
    the provided value in the Dessert object’s calories property ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the syntax for throwing the exception. We begin with the throw keyword,
    which tells PHP to disrupt the flow of the program if the if statement is true.
    Then we use the new keyword to create a new object of the Exception class, passing
    the error message we want to display as an argument. We have to prefix the Exception
    class with a backslash (\) because it’s part of PHP’s root namespace, whereas
    Dessert is part of the Mattsmithdev namespace. Without the backslash, Exception
    would be assumed to be in the Mattsmithdev namespace as well.
  prefs: []
  type: TYPE_NORMAL
- en: We next need to write a *composer.json* file to autoload our classes. Create
    this file as shown in [Listing 23-3](#lis23-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-3: The composer.json file for autoloading'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have this file, generate the autoloader scripts by entering composer
    dump-autoload at the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s write an index script to attempt to create a Food and a Dessert object.
    Create *public/index.php* to match [Listing 23-4](#lis23-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-4: Attempting to create an invalid Dessert object in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We read and execute the autoloader and provide use statements for the two classes
    we need. Then we create and print a Food object and a Dessert object, passing
    an invalid argument of -1 for the latter’s calories property. Here’s the result
    of running this index script at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line of output shows that the Food object was successfully created
    and printed out, but then we get a fatal error due to the exception thrown by
    the negative calorie value. The exception is said to be *uncaught*, since we didn’t
    write any code telling PHP what to do if an exception is thrown. As a result,
    the application has simply stopped running and has printed the error message we
    provided, followed by a *stack trace*, a report that steps through the code to
    show the cause of the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack trace tells us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '#0 shows that the exception was thrown when setCalories() was passed -1 as
    an argument at line 12 of the *src/Dessert.php* file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '#1 shows that setCalories() was called when the Dessert class’s constructor
    method was invoked with the arguments (''strawberry chee...'', -1) (the food-name
    string has been shortened).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '#2 reports that the exception-throwing code is line 23 in *src/Dessert.php*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the output ends with the stack trace, meaning the index script wasn’t
    able to get to the point of printing out the Dessert object. The uncaught exception
    halted the flow of the program, so the final line of the index script didn’t execute.
  prefs: []
  type: TYPE_NORMAL
- en: Catching an Exception
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To avoid a fatal error and safely manage exceptions, we need to *catch* the
    exceptions by writing a try...catch statement in our index script. The try portion
    indicates what we want to do under normal circumstances, and the catch portion
    indicates what to do when an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: By catching exceptions, we prevent application users from seeing fatal errors
    and the resulting stack traces. Besides being embarrassing and not user-friendly,
    printing out a stack trace “leaks” information about the structure of the web
    application code (in the preceding example, for instance, we leaked the folder
    name *src* and the class filename *Dessert.php*). While stack traces aren’t serious
    security vulnerability issues, any information leaked like this might be helpful
    to an attacker and so should be prevented where possible. Catching exceptions
    lets us decide what to do with the exception data, as well as what the user will
    see when a problem arises.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In [Chapter 24](chapter24.xhtml), we’ll explore logging, which allows useful
    debugging data such as stack traces to be stored for developers and site administrators
    to access, while not publishing such information to any public website visitor
    or software client.*'
  prefs: []
  type: TYPE_NORMAL
- en: To catch the exception raised when a negative calorie value is given, update
    the *public/index.php* script to match [Listing 23-5](#lis23-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-5: Adding a try...catch statement to index.php'
  prefs: []
  type: TYPE_NORMAL
- en: The old code creating and printing Food and Dessert objects is now inside a
    try block ❶. If any exception occurs during this sequence, PHP checks the class
    of the exception against the class(es) specified in the catch block that follows
    ❷. If the class matches, the catch block is executed. In this case, the catch
    statement is for objects of the \Exception class, as specified in the parentheses
    after the catch keyword. The variable $e, also in the parentheses, becomes a reference
    to the Exception object that has been caught.
  prefs: []
  type: TYPE_NORMAL
- en: In the catch block, we print out the message '(caught!) - an exception occurred!'
    followed by a line break. Then we print the message inside the Exception object
    via its public getMessage() method ❸. This is the 'attempting to set calories
    to a negative value' message we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve added code catching the exception, try running the index script
    again at the command line. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, the Food object has been successfully created and printed. Next, we see
    the message printed from inside our catch statement, followed by the message from
    the Exception object itself. In this example, having caught the exception, we’re
    still printing out a message for the user, but we’ve controlled the information
    that’s displayed. No stack trace is leaking information now that we’re handling
    the exception with a catch statement.
  prefs: []
  type: TYPE_NORMAL
- en: Ending with a finally Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A finally statement is a block of code that gets executed regardless of whether
    an exception has been thrown. It’s written after the try and catch statements
    and typically includes *housekeeping code*, code that gracefully ends any processes
    that have been started. For example, you might use a finally statement to ensure
    that any file streams or database connections are closed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a finally statement to our index script to gracefully close the application
    every time it runs, even if an exception has been thrown. Modify *public/index.php*
    to match [Listing 23-6](#lis23-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-6: Adding a finally statement to index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a finally block that prints a simple message after either the try
    or catch block concludes. Here’s the result of running this updated index script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The message from the finally block prints at the end of the output, after displaying
    the message from the exception.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure the finally statement executes even when the catch statement doesn’t,
    let’s update our script so that the Dessert object is given a valid number of
    calories, meaning no exception will be thrown. Modify the instantiation of the
    Dessert object in *public/index.php* as shown in [Listing 23-7](#lis23-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-7: Creating a valid Dessert object in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the index script now, you should see the Food and Dessert object
    messages and then the finally message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output confirms that a Dessert object was successfully created without
    throwing an exception, and that the finally block was still executed regardless.  ###
    Using Multiple Exception Classes'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to PHP’s root Exception class, several other classes of exception
    are available as part of the Standard PHP Library (SPL), such as the InvalidArgumentException
    class. These other exception classes are all connected hierarchically to Exception
    as its subclasses, subclasses of its subclasses, and so on. You can also create
    your own custom exception classes that are subclasses of one of these built-in
    exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it may seem unnecessary to have subclasses of Exception, since
    we could create basic Exception objects with custom messages for each situation
    throwing an exception. However, by writing code that throws objects of different
    Exception subclasses, you can include several catch statements, one for each Exception
    subclass, allowing you to respond differently to each type of exception.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could write multiple validation checks into a setter method
    and throw a certain class of exception depending on which validation check fails.
    Then you could write a separate catch statement for each of the exception classes,
    so each type of exception generates a customized response. You would then typically
    end with a catch statement for generic Exception objects, allowing you to catch
    any exceptions you didn’t already account for. We’ll look at how this works in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Other Built-in Exception Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s use another built-in PHP exception class in conjunction with the root
    Exception class. We’ll update our Dessert class’s setCalories() method to throw
    one of two exception class objects as part of the validation of the received $calories
    argument. Our validation tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If $calories is less than 0, throw an \InvalidArgumentException object because
    desserts can’t have negative calories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If $calories is greater than 5000, throw a general \Exception object because
    that’s *way too many* calories for one dessert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the setCalories() method in *src/Dessert.php* to match [Listing 23-8](#lis23-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-8: Updating the setCalories() method to throw different classes
    of exception'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we change the class of exception thrown when the argument received is
    negative to \InvalidArgumentException. Once again, note the forward slash before
    the class name, indicating that this class is declared in the root PHP namespace.
    Then we add a second validation test: when the number of calories is greater than
    5000, an object of the general \Exception class will be thrown. If execution of
    the code gets past these two if statements without throwing any exceptions, we
    store the provided value in the object’s calories property as before.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update the index script. We’ll write multiple catch statements
    to handle each class of exception object appropriately. Then we’ll try different
    values for the Dessert object’s calories property to test the validation logic.
    Edit *public/index.php* to match [Listing 23-9](#lis23-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-9: Multiple catch statements in the public/index.php script'
  prefs: []
  type: TYPE_NORMAL
- en: We start with three assignment statements for different values of the $calories
    variable. To thoroughly test the script, comment out all but one of these assignment
    statements, choosing a different one each time. In the try block, we create a
    new Dessert object, providing the $calories variable as an argument. Then we create
    two catch statements, one for the InvalidArgumentException class ❶ and the other
    for the general Exception class ❷. Each prints a different message, along with
    the message attached to the exception object itself, retrieved with $e->getMessage().
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 23-1](#tab23-1) shows the outputs for the three values of $calories,
    demonstrating that our exception-based logic is working as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 23-1: Outputs for Calorie Values'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value of $calories | Program output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | (caught!) - an Invalid Argument Exception occurred! attempting to set
    calories to a negative value (finally) -- Application finished -- |'
  prefs: []
  type: TYPE_TB
- en: '| 6000 | (caught!) - a general Exception occurred! too many calories for one
    dessert! (finally) -- Application finished -- |'
  prefs: []
  type: TYPE_TB
- en: '| 500 | I am a Dessert containing 500 calories! (finally) -- Application finished
    -- |'
  prefs: []
  type: TYPE_TB
- en: Notice that the values of -1 and 6000 each trigger their own class of exception,
    while 500 allows the Dessert object to be successfully created and printed.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Exception Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PHP gives you the flexibility to write your own custom exception classes, provided
    they’re subclasses of Exception or one of the other built-in PHP exception classes.
    Also, many third-party libraries come with their own custom exception classes
    designed specifically for the methods in that library. Whether you’re writing
    your own or using someone else’s, custom exception classes give you even more
    freedom to structure your code to respond differently to a variety of anticipated
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a custom exception class to our Dessert project: Mattsmithdev\NegativeCaloriesException.
    We’ll update the project to throw an exception object of this class instead of
    the InvalidArgumentException class. [Figure 23-2](#fig23-2) shows the two classes
    of exception that our Dessert objects can throw. Notice that the NegativeCaloriesException
    class falls within the Mattsmithdev namespace, while the Exception class is outside,
    since it’s in the root PHP namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure23-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23-2: The two classes of exception that a Dessert object can throw'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new class in *src/NegativeCaloriesException.php* containing
    the code in [Listing 23-10](#lis23-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-10: The custom NegativeCaloriesException class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare NegativeCaloriesException as a subclass of the root \Exception class.
    It contains no methods. Since it doesn’t have its own constructor method, it will
    inherit the constructor from its Exception superclass, allowing it to take in
    a message for display.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now update our Dessert class’s setCalories() method to throw a NegativeCaloriesException
    object when the provided calorie value is negative. As in the previous example,
    we’ll throw a general Exception object when the provided value is greater than
    5000. Update the setCalories() method in *src/Dessert.php* to match [Listing 23-11](#lis23-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-11: Throwing a custom exception in the setCalories() method'
  prefs: []
  type: TYPE_NORMAL
- en: We change the class of exception thrown when the argument received is negative
    to an object of the NegativeCaloriesException class. Since this new class is in
    the same namespace as our Dessert class, we don’t write a backslash before the
    class identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update the catch statements in our index script to handle the
    new custom exception class. Modify *public/index.php* as shown in [Listing 23-12](#lis23-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-12: Catching custom exception objects in the index.php script'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a use statement so we can reference the NegativeCaloriesException class
    without the Mattsmithdev namespace prefix. Then we create a catch statement for
    exceptions of this class, printing an appropriate message. Here’s the output you
    should get if you try to create a new Dessert object with -1 calories, confirming
    that a NegativeCaloriesException is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing for a negative value is a simple example, but it serves to illustrate
    how straightforward it is to create custom subclasses of Exception, allowing you
    to write different logic to address different anticipated problems at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Call-Stack Bubbling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an exception occurs in a block of code and isn’t caught by that code block,
    it will *bubble up* the call stack to the code that invoked the code block. If
    not caught there, the exception will continue to bubble up through successively
    higher levels of code until either it’s caught and handled or the top of the call
    stack is reached. If the exception isn’t caught in the top-level block of code,
    a fatal error will result, as we saw in this chapter’s first example. For this
    reason, it’s a good idea to include some code at the top level of an application
    to catch any exceptions that may have bubbled all the way to the top of the call
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, the flow of control for a typical object-oriented PHP web application
    begins with the index script, which creates an object of the Application class
    and invokes its run() method. This in turn triggers the creation of other objects
    and the invocation of other methods. Some of this activity might throw exceptions.
    You can try to catch all those exceptions within the Application class, but any
    uncaught exceptions will ultimately bubble up to the index script and should be
    caught there to avoid a fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how this works, we’ll update our Dessert project, taking the
    code that used to be in the index script and encapsulating it in an Application
    class. This class will be responsible for catching any NegativeCaloriesException
    objects thrown during the creation of Dessert objects, but we’ll allow other miscellaneous
    exceptions to bubble up to the top of the call stack. Then we’ll catch those in
    the top-level index script.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s update our index script to create an Application object and invoke
    its run() method. We’ll wrap that code in a try...catch statement to handle any
    uncaught exceptions that bubble up, and we’ll include a finally statement to gracefully
    close the application. We’ll also clearly indicate that the messages being printed
    by the catch and finally blocks are coming from this index script by prefixing
    them with (index.php). Modify *public/index.php* to match [Listing 23-13](#lis23-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-13: The simplified index.php script creating an Application object'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the try block, we create an Application object, storing a reference to
    the new object in the $app variable, and invoke its run() method. If any uncaught
    Exception objects bubble up from the try block statements, we use a catch block
    to handle them and print a message. Since every exception object is an instance
    of the Exception class (either directly or as a subclass), this catch statement
    acts as a catchall for any possible exception object that was thrown during program
    execution but wasn’t caught elsewhere in the code. We also add a finally block
    that will print a final message regardless of whether any exceptions were thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s write the Application class. Create a new file named *src/Application.php*
    to match [Listing 23-14](#lis23-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 23-14: The Application class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the Application class with a run() method containing many of the
    statements from the older index script. As before, we include three assignment
    statements for the $calories variable that you can selectively comment out to
    test the project. Then we create and print a new Dessert object in a try block
    and use a catch block to handle NegativeCaloriesException objects. [Table 23-2](#tab23-2)
    shows the results of running the application with the different possible values
    of $calories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 23-2: Catching Exceptions with Call-Stack Bubbling'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value of $calories | Program output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 500 | I am a Dessert containing 500 calories! (index.php) finally -- Application
    finished -- |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | (Application->run) - Negative Calories Value Exception caught! (index.php)
    finally -- Application finished -- |'
  prefs: []
  type: TYPE_TB
- en: '| 6000 | (index.php) Exception caught! (index.php) finally -- Application finished
    -- |'
  prefs: []
  type: TYPE_TB
- en: When a valid value of 500 is used, the object properties are printed out. When
    the value is -1, the NegativeCaloriesException is caught inside the run() method
    of the Application class. When the too-high value of 6000 is used, the run() method
    of the Application class fails to catch the general Exception that’s thrown, since
    the method is watching only for NegativeCaloriesException objects. As a result,
    the exception bubbles up to the index script, where it hits the general catch
    block. In all cases, the output ends with the message from the finally block in
    the index script.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a general try...catch statement to an index script ensures that any bubbled-up
    uncaught exceptions will be addressed, meaning the application will avoid runtime
    errors relating to exceptions. Meanwhile, the code for handling more-specific
    exceptions, such as our custom NegativeCaloriesException, is located at a lower
    level of the application code, which keeps the index script simple and well organized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced how to work with exceptions. You learned how to create
    exceptions when anticipated problematic situations occur by writing throw statements,
    and how to manage exceptions with try...catch...finally structures. All exceptions
    are instances of PHP’s top-level \Exception class, but we discussed how to refine
    the program logic by using provided exception subclasses such as InvalidArgumentException
    or by declaring custom exception subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored a general application architecture that exploits the bubbling
    up of uncaught exceptions. Specific anticipated exceptions can be caught within
    class methods, while any remaining exceptions can be caught in the index script
    at the top level of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Create a new project and implement a simple Product class with private
    name and price properties, public accessor methods for each property, and a constructor
    that takes in new values for each property and sets them using the setter methods.
    Add validation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   If a negative value for price is received, an InvalidArgumentException
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: b.   If a price greater than 1000000 is received, a general Exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: c.   If an empty string is provided for the name property, an InvalidArgumentException
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Create a *composer.json* file and an index script to attempt to create a Product
    object with valid and invalid names and prices. Then wrap your index code with
    try...catch statements, so you can handle the various exceptions your code throws.
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Make a copy of your Exercise 1 solution and introduce an Application class
    similar to the one from [Listing 23-14](#lis23-14). Refactor your code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Create the Product object in the run() method of your Application class.
    Catch InvalidArgumentException objects and print an appropriate message as part
    of the run() method as well.
  prefs: []
  type: TYPE_NORMAL
- en: b.   In the index script, create an Application object and invoke its run()
    method. Catch any bubbled-up general Exception objects and print an appropriate
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Make a copy of your solution for Exercise 2 and introduce a custom exception
    named EmptyStringException that’s thrown by the setName() method. Add an appropriate
    catch block to catch and process this exception in the run() method of the Application
    class.
  prefs: []
  type: TYPE_NORMAL
