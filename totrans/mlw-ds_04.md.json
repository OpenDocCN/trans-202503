["```\n#!/usr/bin/python\nimport networkx\n\n# instantiate a network with no nodes and no edges.\nnetwork = networkx.Graph()\n```", "```\nnodes = [\"hello\",\"world\",1,2,3]\nfor node in nodes:\n    network.add_node(node)\n```", "```\n➊ network.add_edge(\"hello\",\"world\")\n   network.add_edge(1,2)\n   network.add_edge(1,3)\n```", "```\nnetwork.add_node(1,myattribute=\"foo\")\n```", "```\nnetwork.node[1][\"myattribute\"] = \"foo\"\n```", "```\nprint network.node[1][\"myattribute\"] # prints \"foo\"\n```", "```\nnetwork.add_edge(\"node1\",\"node2\",myattribute=\"attribute of an edge\")\n```", "```\nnetwork.edge[\"node1\"][\"node2\"][\"myattribute\"] = \"attribute of an edge\"\n```", "```\n➊ network.edge[\"node1\"][\"node2\"][\"myattribute\"] = 321\n➋ print network.edge[\"node2\"][\"node1\"][\"myattribute\"]  # prints 321\n```", "```\n#!/usr/bin/python\nimport networkx\nfrom networkx.drawing.nx_agraph import write_dot\n\n# instantiate a network, add some nodes, and connect them\nnodes = [\"hello\",\"world\",1,2,3]\nnetwork = networkx.Graph()\nfor node in nodes:\n    network.add_node(node)\nnetwork.add_edge(\"hello\",\"world\")\nwrite_dot(➊network,➋\"network.dot\")\n```", "```\n$ <toolname> <dotfile> -T png –o <outputfile.png>\n```", "```\n$ fdp apt1callback.dot –T png –o apt1callback.png\n```", "```\nG<parametername>=<parametervalue>\n```", "```\n$ <toolname> <dotfile> -Goverlap=false -T png -o <outputfile.png>\n```", "```\n$ <toolname> <dotfile> -Gsplines=true -T png -o <outputfile.png>\n```", "```\n$ <toolname> <dotfile> -Gsplines=true –Goverlap=false -T png -o <outputfile.png>\n```", "```\n$ fdp callback_servers_malware_projection.dot -T png -o fdp_servers.png –Goverlap=false\n```", "```\n$ sfdp callback_servers_malware_projection.dot -T png -o sfdp_servers.png –Goverlap=false\n```", "```\n$ neato callback_servers_malware_projection.dot -T png -o neato_servers.png –Goverlap=false\n```", "```\n   #!/usr/bin/python\n   import networkx\n   from networkx.drawing.nx_agraph import writedot\n\n➊ g = networkx.Graph()\n   g.add_node(1)\n   g.add_node(2)\n   g.add_edge(1,2,➋penwidth=10) # make the edge extra wide\n   write_dot(g,'network.dot')\n```", "```\n#!/usr/bin/python\n\nimport networkx\nfrom networkx.drawing.nx_agraph import write_dot\n\ng = networkx.Graph()\ng.add_node(1,➊color=\"blue\") # make the node outline blue\ng.add_node(2,➋color=\"pink\") # make the node outline pink\ng.add_edge(1,2,➌color=\"red\") # make the edge red\nwrite_dot(g,'network.dot')\n```", "```\n#!/usr/bin/python\n\nimport networkx\nfrom networkx.drawing.nx_agraph import write_dot\n\ng = networkx.Graph()\ng.add_node(1,➊shape='diamond')\ng.add_node(2,➋shape='egg')\ng.add_edge(1,2)\n\nwrite_dot(g,'network.dot')\n```", "```\n#!/usr/bin/python\n\nimport networkx\nfrom networkx.drawing.nx_agraph import write_dot\n\ng = networkx.Graph()\ng.add_node(1,➊label=\"first node\")\ng.add_node(2,➋label=\"second node\")\ng.add_edge(1,2,➌label=\"link between first and second node\")\n\nwrite_dot(g,'network.dot')\n```", "```\n#!/usr/bin/python\n\nimport pefile➊\nimport sys\nimport argparse\nimport os\nimport pprint\nimport networkx➋\nimport re\nfrom networkx.drawing.nx_agraph import write_dot\nimport collections\nfrom networkx.algorithms import bipartite\n```", "```\nargs = argparse.ArgumentParser(\"Visualize shared DLL import relationships\nbetween a directory of malware samples\")\nargs.add_argument(➊\"target_path\",help=\"directory with malware samples\")\nargs.add_argument(➋\"output_file\",help=\"file to write DOT file to\")\nargs.add_argument(➌\"malware_projection\",help=\"file to write DOT file to\")\nargs.add_argument(➍\"resource_projection\",help=\"file to write DOT file to\")\nargs = args.parse_args()\n```", "```\n   #!/usr/bin/python\n\n   import pefile\n➊ import sys\n   import argparse\n   import os\n   import pprint\n   import networkx\n   import re\n   from networkx.drawing.nx_agraph import write_dot\n   import collections\n   from networkx.algorithms import bipartite\n\n   args = argparse.ArgumentParser(\n   \"Visualize shared hostnames between a directory of malware samples\"\n   )\n   args.add_argument(\"target_path\",help=\"directory with malware samples\")\n   args.add_argument(\"output_file\",help=\"file to write DOT file to\")\n   args.add_argument(\"malware_projection\",help=\"file to write DOT file to\")\n   args.add_argument(\"hostname_projection\",help=\"file to write DOT file to\")\n   args = args.parse_args()\n   network = networkx.Graph()\n\n   valid_hostname_suffixes = map(\n   lambda string: string.strip(), open(\"domain_suffixes.txt\")\n   )\n   valid_hostname_suffixes = set(valid_hostname_suffixes)\n➋ def find_hostnames(string):\n      possible_hostnames = re.findall(\n      r'(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-]{,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}',\n      string)\n      valid_hostnames = filter(\n              lambda hostname: hostname.split(\".\")[-1].lower() \\\n              in valid_hostname_suffixes,\n              possible_hostnames\n      )\n      return valid_hostnames\n\n  # search the target directory for valid Windows PE executable files\n  for root,dirs,files in os.walk(args.target_path):\n      for path in files:\n          # try opening the file with pefile to see if it's really a PE file\n          try:\n              pe = pefile.PE(os.path.join(root,path))\n          except pefile.PEFormatError:\n              continue\n          fullpath = os.path.join(root,path)\n          # extract printable strings from the target sample\n        ➌ strings = os.popen(\"strings '{0}'\".format(fullpath)).read()\n\n          # use the search_doc function in the included reg module \n          # to find hostnames\n        ➍ hostnames = find_hostnames(strings)\n          if len(hostnames):\n              # add the nodes and edges for the bipartite network\n              network.add_node(path,label=path[:32],color='black',penwidth=5,\n              bipartite=0)\n          for hostname in hostnames:\n            ➎ network.add_node(hostname,label=hostname,color='blue',\n                 penwidth=10,bipartite=1)\n              network.add_edge(hostname,path,penwidth=2)\n          if hostnames:\n              print \"Extracted hostnames from:\",path\n              pprint.pprint(hostnames)\n```", "```\n  # write the dot file to disk\n➊ write_dot(network, args.output_file)\n➋ malware = set(n for n,d in network.nodes(data=True) if d['bipartite']==0)\n➌ hostname = set(network)-malware\n\n  # use NetworkX's bipartite network projection function to produce the malware\n  # and hostname projections\n➍ malware_network = bipartite.projected_graph(network, malware)\n  hostname_network = bipartite.projected_graph(network, hostname)\n\n  # write the projected networks to disk as specified by the user\n➎ write_dot(malware_network,args.malware_projection)\n  write_dot(hostname_network,args.hostname_projection)\n```", "```\n   #!/usr/bin/python\n\n   import pefile\n   import sys\n   import argparse\n   import os\n   import pprint\n   import logging\n   import networkx\n   import collections\n   import tempfile\n   from networkx.drawing.nx_agraph import write_dot\n   from networkx.algorithms import bipartite\n\n   # Use argparse to parse any command line arguments\n\n   args = argparse.ArgumentParser(\n   \"Visualize shared image relationships between a directory of malware samples\"\n   )\n   args.add_argument(\"target_path\",help=\"directory with malware samples\")\n   args.add_argument(\"output_file\",help=\"file to write DOT file to\")\n   args.add_argument(\"malware_projection\",help=\"file to write DOT file to\")\n   args.add_argument(\"resource_projection\",help=\"file to write DOT file to\")\n   args = args.parse_args()\n   network = networkx.Graph()\n\n➊ class ExtractImages():\n      def __init__(self,target_binary):\n          self.target_binary = target_binary\n          self.image_basedir = None\n          self.images = []\n\n      def work(self):\n          self.image_basedir = tempfile.mkdtemp()\n          icondir = os.path.join(self.image_basedir,\"icons\")\n          bitmapdir = os.path.join(self.image_basedir,\"bitmaps\")\n          raw_resources = os.path.join(self.image_basedir,\"raw\")\n          for directory in [icondir,bitmapdir,raw_resources]:\n              os.mkdir(directory)\n          rawcmd = \"wrestool -x {0} -o {1} 2> \\\n                   /dev/null\".format(\n                   self.target_binary,raw_resources\n                   )\n          bmpcmd = \"mv {0}/*.bmp {1} 2> /dev/null\".format(\n          raw_resources,bitmapdir\n          )\n          icocmd = \"icotool -x {0}/*.ico -o {1} \\\n                    2> /dev/null\".format(\n                    raw_resources,icondir\n                    )\n          for cmd in [rawcmd,bmpcmd,icocmd]:\n              try:\n                  os.system(cmd)\n              except Exception,msg:\n                  pass\n          for dirname in [icondir,bitmapdir]:\n              for path in os.listdir(dirname):\n                  logging.info(path)\n                  path = os.path.join(dirname,path)\n                  imagehash = hash(open(path).read())\n                  if path.endswith(\".png\"):\n                      self.images.append((path,imagehash))\n                  if path.endswith(\".bmp\"):\n                      self.images.append((path,imagehash))\n      def cleanup(self):\n          os.system(\"rm -rf {0}\".format(self.image_basedir))\n\n   # search the target directory for PE files to extract images from\n   image_objects = []\n   for root,dirs,files in os.walk(args.target_path):➋\n      for path in files:\n          # try to parse the path to see if it's a valid PE file\n          try:\n              pe = pefile.PE(os.path.join(root,path))\n          except pefile.PEFormatError:\n              continue\n```", "```\n           fullpath = os.path.join(root,path)\n        ➊ images = ExtractImages(fullpath)\n        ➋ images.work()\n           image_objects.append(images)\n\n           # create the network by linking malware samples to their images\n        ➌ for path, image_hash in images.images:\n               # set the image attribute on the image nodes to tell GraphViz to\n               # render images within these nodes\n               if not image_hash in network:\n                ➍ network.add_node(image_hash,image=path,label='',type='image')\n               node_name = path.split(\"/\")[-1]\n               network.add_node(node_name,type=\"malware\")\n            ➎ network.add_edge(node_name,image_hash)\n```", "```\n   # write the bipartite network, then do the two projections and write them\n➊ write_dot(network, args.output_file)\n   malware = set(n for n,d in network.nodes(data=True) if d['type']=='malware')\n   resource = set(network) - malware\n   malware_network = bipartite.projected_graph(network, malware)\n   resource_network = bipartite.projected_graph(network, resource)\n\n➋ write_dot(malware_network,args.malware_projection)\n   write_dot(resource_network,args.resource_projection)\n```"]