<html><head></head><body>
		<h2 class="h2a" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span></strong><br/><strong>THINKING LOW-LEVEL, WRITING HIGH-LEVEL</strong></h2>&#13;
		<div class="bq1">&#13;
			<p class="noindentc"><em>If you want to write the best high-level language code, learn assembly language.</em></p>&#13;
			<p class="noindentc"><em>—Common programming advice</em></p>&#13;
		</div>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">This book doesn’t teach anything revolutionary. Rather, it describes a time-tested, well-proven approach to writing great code—understanding how the code you write will actually execute on a real machine. The journey to that understanding begins with this chapter. In it, we’ll explore these topics:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Misconceptions programmers have about the code quality produced by typical compilers</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Why learning assembly language is still a good idea</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How to think in low-level terms while writing HLL code</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">So, without further ado, let’s begin!</p>&#13;
		<h3 class="h3" id="ch00lev1sec8"><span epub:type="pagebreak" id="page_2"/><strong>1.1 Misconceptions About Compiler Quality</strong></h3>&#13;
		<p class="noindent">In the early days of the personal computer revolution, high-performance software was written in assembly language. As time passed, optimizing compilers for high-level languages were improved, and their authors began claiming that the performance of compiler-generated code was within 10 to 50 percent of hand-optimized assembly code. Such proclamations ushered the ascent of HLLs for PC application development, sounding the death knell for assembly language. Many programmers began citing statistics like “my compiler achieves 90 percent of assembly’s speed, so it’s insane to use assembly language.” The problem is that they never bothered to write hand-optimized assembly versions of their applications to check their claims. Often, their assumptions about their compiler’s performance were wrong. Worse still, as compilers for languages such as C and C++ matured to the point that they were producing very good output code, programmers began favoring more high-level languages, such as Java, Python, and Swift, that were either interpreted (or semi-interpreted) or had very immature code generators producing terrible output code.</p>&#13;
		<p class="indent">The authors of optimizing compilers weren’t lying. Under the right conditions, an optimizing compiler <em>can</em> produce code that is almost as good as hand-optimized assembly language. However, the HLL code has to be written in an appropriate way to achieve these performance levels. Writing HLL code in this manner requires a firm understanding of how computers operate and execute software.</p>&#13;
		<h3 class="h3" id="ch00lev1sec9"><strong>1.2 Why Learning Assembly Language Is Still a Good Idea</strong></h3>&#13;
		<p class="noindent">When programmers first began giving up assembly language in favor of using HLLs, they generally understood the low-level ramifications of the HLL they were using and could choose their HLL statements appropriately. Unfortunately, the generation of computer programmers that followed them did not have the benefit of mastering assembly language. As a result, they were not equipped to wisely choose statements and data structures that HLLs could efficiently translate into machine code. Their applications, if measured against the performance of a comparable hand-optimized assembly language program, surely proved inferior.</p>&#13;
		<p class="indent">Veteran programmers who recognized this problem offered sage advice to the new programmers: “If you want to learn how to write good HLL code, you need to learn assembly language.” By learning assembly language, programmers can understand the low-level implications of their code and make informed decisions about the best way to write applications in an HLL.<sup><a id="ch1fn_1"/><a href="footnotes.xhtml#ch1fn1">1</a></sup> <a href="ch02.xhtml#ch02">Chapter 2</a> will discuss assembly language further.</p>&#13;
		<h3 class="h3" id="ch00lev1sec10"><span epub:type="pagebreak" id="page_3"/><strong>1.3 Why Learning Assembly Language Isn’t Absolutely Necessary</strong></h3>&#13;
		<p class="noindent">While it’s a good idea for any well-rounded programmer to learn to program in assembly language, it isn’t a necessary condition for writing great, efficient code. What’s most important is to understand how HLLs translate statements into machine code so that you can choose appropriate HLL statements. And while one way to do this is to become an expert assembly language programmer, that approach requires considerable time and effort.</p>&#13;
		<p class="indent">The question, then, is, “Can a programmer just study the low-level nature of the machine and improve the HLL code they write without becoming an expert assembly programmer in the process?” The answer, given the preceding point, is a qualified yes. That’s the purpose of this book: to teach you what you need to know to write great code without having to become an expert assembly language programmer.</p>&#13;
		<h3 class="h3" id="ch00lev1sec11"><strong>1.4 Thinking Low-Level</strong></h3>&#13;
		<p class="noindent">When Java was first becoming popular in the late 1990s, the language received complaints like the following:</p>&#13;
		<div class="bq">&#13;
			<p class="noindent">Java’s interpreted code is forcing me to take a lot more care when writing software; I can’t get away with using linear searches the way I could in C/C++. I have to use good (and more difficult to implement) algorithms like binary search.</p>&#13;
		</div>&#13;
		<p class="indent">Such statements demonstrate the major problem with using optimizing compilers: they allow programmers to get lazy. Although optimizing compilers have made tremendous strides over the past several decades, none of them can make up for poorly written HLL source code.</p>&#13;
		<p class="indent">Of course, many novice HLL programmers read about how marvelous the optimization algorithms are in modern compilers and assume that the compiler will produce efficient code regardless of what it’s fed. However, that’s not the case: although compilers can do a great job of translating well-written HLL code into efficient machine code, poorly written source code stymies the compiler’s optimization algorithms. In fact, it’s not uncommon to hear C/C++ programmers praising their compiler, never realizing how poor a job it’s actually doing because of how they’ve written their code. The problem is that they’ve never actually looked at the machine code the compiler produces from their HLL source code. They assume that the compiler is doing a great job because they’ve been told that compilers produce code that’s almost as good as what an expert assembly language programmer can produce.</p>&#13;
		<h4 class="h4" id="ch00lev2sec1"><span epub:type="pagebreak" id="page_4"/><strong>1.4.1 Compilers Are Only as Good as the Source Code You Feed Them</strong></h4>&#13;
		<p class="noindent">It goes without saying that a compiler won’t change your algorithms in order to improve your software’s performance. For example, if you use a linear search rather than a binary search, you can’t expect the compiler to use a better algorithm for you. Certainly, the optimizer may improve the speed of your linear search by a constant factor (for example, double or triple the speed of your code), but this improvement may be nothing compared to using a better algorithm. In fact, it’s very easy to show that, given a sufficiently large database, a binary search processed by an interpreter with no optimization will run faster than a linear search algorithm processed by the best compiler.</p>&#13;
		<h4 class="h4" id="ch00lev2sec2"><strong>1.4.2 How to Help the Compiler Produce Better Machine Code</strong></h4>&#13;
		<p class="noindent">Let’s assume that you’ve chosen the best possible algorithm(s) for your application and you’ve spent the extra money to get the best compiler available. Is there something you can do to write HLL code that is more efficient than you would otherwise produce? Generally, the answer is yes.</p>&#13;
		<p class="indent">One of the best-kept secrets in the compiler world is that most compiler benchmarks are rigged. Most real-world compiler benchmarks specify an algorithm to use, but they leave it up to the compiler vendors to actually implement the algorithm in their particular language. These compiler vendors generally know how their compilers behave when fed certain code sequences, so they will write the code sequence that produces the best possible executable.</p>&#13;
		<p class="indent">Some may feel that this is cheating, but it’s really not. If a compiler is capable of producing that same code sequence under normal circumstances (that is, the code generation trick wasn’t developed specifically for the benchmark), there’s nothing wrong with showing off its performance. And if the compiler vendor can pull little tricks like this, so can you. By carefully choosing the statements you use in your HLL source code, you can “manually optimize” the machine code the compiler produces.</p>&#13;
		<p class="indent">Several levels of manual optimization are possible. At the most abstract level, you can optimize a program by selecting a better algorithm for the software. This technique is independent of the compiler and the language.</p>&#13;
		<p class="indent">Dropping down a level of abstraction, the next step is to manually optimize your code based on the HLL that you’re using while keeping the optimizations independent of the particular implementation of that language. While such optimizations may not apply to other languages, they should apply across different compilers for the same language.</p>&#13;
		<p class="indent">Dropping down yet another level, you can start thinking about structuring the code so that the optimizations are applicable only to a certain vendor or perhaps only to a specific version of a compiler.</p>&#13;
		<p class="indent">Finally, at perhaps the lowest level, you can consider the machine code that the compiler emits and adjust how you write statements in an HLL to force the compiler to generate some sequence of machine instructions. The Linux kernel is an example of this approach. Legend has it that the kernel developers were constantly tweaking the C code they wrote in the Linux kernel in order to control the 80x86 machine code that the GNU C Compiler (GCC) was producing.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_5"/>Although this development process may be a bit overstated, one thing is for sure: programmers who employ it will produce the best possible machine code from a compiler. This is the type of code that’s comparable to what decent assembly language programmers produce, and the kind of compiler output that HLL programmers like to cite when arguing that compilers produce code that’s comparable to handwritten assembly. The fact that most people do not go to these extremes to write their HLL code never enters into the argument. Nevertheless, the fact remains that carefully written HLL code can be nearly as efficient as decent assembly code.</p>&#13;
		<p class="indent">Will compilers ever produce code that is as good as or better than what an expert assembly language programmer can write? The correct answer is no; after all, an expert assembly language programmer can always look at a compiler’s output and improve on that. However, careful programmers writing code in HLLs like C/C++ can come close if they write their program such that the compiler can easily translate it into efficient machine code. Thus, the real question is, “How do I write my HLL code so that the compiler can translate it most efficiently?” Well, answering that question is the subject of this book. But the short answer is, “Think in assembly; write in a high-level language.” Let’s take a quick look at how to do that.</p>&#13;
		<h4 class="h4" id="ch00lev2sec3"><strong>1.4.3 How to Think in Assembly While Writing HLL Code</strong></h4>&#13;
		<p class="noindent">HLL compilers translate statements in that language to a sequence of one or more machine language (or assembly language) instructions. The amount of space in memory that an application consumes, and the amount of time that an application spends in execution, are directly related to the number and type of machine instructions that the compiler emits.</p>&#13;
		<p class="indent">However, the fact that you can achieve the same result with two different code sequences in an HLL does not imply that the compiler generates the same sequence of machine instructions for each approach. The HLL <code>if</code> and <code>switch/case</code> statements are classic examples. Most introductory programming texts suggest that a chain of <code>if-elseif-else</code> statements is equivalent to a <code>switch/case</code> statement. Consider the following trivial C example:</p>&#13;
		<pre class="programs">&#13;
			switch( x )<br/>    {<br/>        case 1:<br/>            printf( "X=1\n" );<br/>            break;<br/><br/>        case 2:<br/>            printf( "X=2\n" );<br/>            break;<br/><br/>        case 3:<br/>            printf( "X=3\n" );<br/>            break;<br/><br/>        case 4:<br/>            printf( "X=4\n" );<br/>            break;<br/><br/>        default:<br/>            printf( "X does not equal 1, 2, 3, or 4\n" );<br/>    }<br/><br/>/* equivalent if statement */<br/><br/>    if( x == 1 )<br/>        printf( "X=1\n" );<br/>    else if( x== 2 )<br/>        printf( "X=2\n" );<br/>    else if( x==3 )<br/>        printf( "X=3\n" );<br/>    else if( x==4 )<br/>        printf( "X=4\n" );<br/>    else<br/>        printf( "X does not equal 1, 2, 3, or 4\n" );</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_6"/>Although these two code sequences might be semantically equivalent (that is, they compute the same result), there is no guarantee that the compiler will generate the same sequence of machine instructions for both.</p>&#13;
		<p class="indent">Which one will be better? Unless you understand how the compiler translates statements like these into machine code, and have a basic knowledge of the different efficiencies between various machines, you probably can’t answer that. Programmers who fully understand how a compiler will translate these two sequences can evaluate both and then judiciously choose one based on the quality of the expected output code.</p>&#13;
		<p class="indent">By thinking in low-level terms when writing HLL code, a programmer can help an optimizing compiler approach the level of code quality achieved by hand-optimized assembly language code. Sadly, the converse is usually true as well: if a programmer does not consider the low-level ramifications of their HLL code, the compiler will rarely generate the best possible machine code.</p>&#13;
		<h3 class="h3" id="ch00lev1sec12"><strong>1.5 Writing High-Level</strong></h3>&#13;
		<p class="noindent">One problem with thinking in low-level terms while writing high-level code is that it’s almost as much work to write HLL code this way as it is to write assembly code. This negates many of the familiar benefits of writing programs in HLLs, such as faster development time, better readability, and easier maintenance. If you’re sacrificing the benefits of writing applications in an HLL, why not simply write them in assembly language to begin with?</p>&#13;
		<p class="indent">As it turns out, thinking in low-level terms won’t lengthen your overall project schedule as much as you would expect. Although it does slow down the initial coding process, the resulting HLL code will still be readable and portable, and it will maintain the other attributes of well-written, great code. But more importantly, it will also gain some efficiency that it wouldn’t otherwise have. Once the code is written, you won’t have to constantly think about it in low-level terms during the maintenance and enhancement phases of the Software Development Life Cycle (SDLC). In short, thinking <span epub:type="pagebreak" id="page_7"/>in low-level terms during the initial software development stage retains the advantages of both low-level and high-level coding (efficiency plus ease of maintenance) without the corresponding disadvantages.</p>&#13;
		<h3 class="h3" id="ch00lev1sec13"><strong>1.6 Language-Neutral Approach</strong></h3>&#13;
		<p class="noindent">Although this book assumes you are conversant in at least one imperative language, it is not entirely language specific; its concepts transcend whatever programming language(s) you’re using. To help make the examples more accessible, the programming examples we’ll use will rotate among several languages, such as C/C++, Pascal, BASIC, Java, Swift, and assembly. When presenting examples, I’ll explain exactly how the code operates so that even if you’re unfamiliar with the specific programming language, you’ll be able to understand its operation by reading the accompanying description.</p>&#13;
		<p class="indent">This book uses the following languages and compilers in various examples:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent"><strong>C/C++:</strong> GCC and Microsoft’s Visual C++</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><strong>Pascal:</strong> Borland’s Delphi, and Free Pascal</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><strong>Assembly language:</strong> Microsoft’s MASM, HLA (High-Level Assembly), and Gas (the GNU Assembler)</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent"><strong>Basic:</strong> Microsoft’s Visual Basic</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">If you’re not comfortable working with assembly language, don’t worry: the primer on 80x86 assembly language and the online reference (<em><a href="http://www.writegreatcode.com/">http://www.writegreatcode.com/</a></em>) will allow you to read compiler output. If you’d like to extend your knowledge of assembly language, see the resources listed at the end of this chapter.</p>&#13;
		<h3 class="h3" id="ch00lev1sec14"><strong>1.7 Additional Tips</strong></h3>&#13;
		<p class="noindent">No single book can completely cover everything you need to know in order to write great code. This book, therefore, concentrates on the areas that are most pertinent for writing great software, providing the 90 percent solution for those who are interested in writing the best possible code. To get that last 10 percent you’ll need additional help. Here are some suggestions:</p>&#13;
		<p class="noindentin"><strong>Become an expert assembly language programmer.</strong> Fluency in at least one assembly language will fill in many missing details that you just won’t get from this book. As noted, the purpose of this book is to teach you how to write the best possible code <em>without</em> actually becoming an assembly language programmer. However, the extra effort will improve your ability to think in low-level terms.</p>&#13;
		<p class="noindentin"><strong>Study compiler construction theory.</strong> Although this is an advanced topic in computer science, there’s no better way to understand how compilers generate code than to study the theory behind compilers. While there’s a wide variety of textbooks on this subject, many of them require considerable prerequisite knowledge. Carefully review any <span epub:type="pagebreak" id="page_8"/>book before you purchase it in order to determine if it was written at an appropriate level for your skill set. You can also search online to find some excellent web tutorials.</p>&#13;
		<p class="noindentin"><strong>Study advanced computer architecture.</strong> Machine organization and assembly language programming are a subset of the study of computer architecture. While you may not need to know how to design your own CPUs, studying computer architecture may help you discover additional ways to improve the HLL code that you write.</p>&#13;
		<h3 class="h3" id="ch00lev1sec15"><strong>1.8 For More Information</strong></h3>&#13;
		<p class="bib">Duntemann, Jeff. <em>Assembly Language Step-by-Step</em>. 3rd ed. Indianapolis: Wiley, 2009.</p>&#13;
		<p class="bib">Hennessy, John L., and David A. Patterson. <em>Computer Architecture: A Quantitative Approach</em>. 5th ed. Waltham, MA: Morgan Kaufmann, 2012.</p>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
	</body></html>