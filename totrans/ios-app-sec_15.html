<html><head></head><body>
<h2 class="h2" id="ch12"><a id="page_199"/><strong><span class="big">12</span></strong><br/><strong>INJECTION ATTACKS</strong></h2>
<p class="noindent">In this chapter, I’ll discuss types of injection attacks, many of which apply both to iOS client applications and to their remote endpoints or APIs. While a thorough examination of all potential server-side flaws is outside the scope of this book, this chapter will give you an idea of how an iOS app and its complementary endpoint or web app can work together to prevent security flaws.</p>
<p class="indent">Injection attacks are standard for web applications, but client-side injection attacks are less common and go largely unnoticed by developers and security engineers. Client-side injection attacks happen when remotely supplied data is parsed by the program running on the device. The most notable examples of this are cross-site scripting, SQL injection, predicate injection, and XML injection.</p>
<h3 class="h3" id="ch12lev1sec01"><strong>Client-Side Cross-Site Scripting</strong></h3>
<p class="noindent"><em>Cross-site scripting (XSS)</em> is an issue most often found in web applications, but JavaScript can be injected into the content used by iOS applications, too. One prominent app reported to have an XSS vulnerability was the Skype <a id="page_200"/>mobile application. As security researcher Phil Purviance described on his Superevr blog, at the time, the app used a <code>UIWebView</code> to render content.<sup><a href="footnote.html#fn105" id="fn_105">1</a></sup> The full name of the remote user was not sanitized before display, which allowed an attacker to insert a malicious script into a remote user’s application by embedding the script in their username. In this case, the attack could steal sensitive data (the contents of the Address Book) from the device. Such attacks can also be used to, say, insert a fake login page that submits credentials to an attacker-controlled domain.</p>
<p class="indent">If your application uses a <code>UIWebView</code>, then to avoid XSS vulnerability, be particularly vigilant that you don’t take any unsanitized user-supplied data from the server or other external sources and integrate it into the user interface. You can do this most effectively with a two-part approach, using both <em>input sanitization</em> and <em>output encoding</em>.</p>
<h4 class="h4" id="ch12lev2sec01"><em><strong>Input Sanitization</strong></em></h4>
<p class="noindent">Input sanitization involves stripping potentially harmful characters from external inputs, using either a <em>blacklist</em> or <em>whitelist</em> approach.</p>
<h5 class="h5" id="ch12lev3sec01"><strong>Blacklisting Bad Input</strong></h5>
<p class="noindent">In a blacklist, you try to list every character that could cause a security problem if accepted as input and give that list to your application. Then, you write your application to either remove unacceptable characters or throw an error when they appear.</p>
<p class="indent">Blacklisting is a fragile approach, and it’s rarely effective. You need to know every conceivable way data could cause trouble, including every type of character encoding, every JavaScript event handler or SQL special character, and so on. For example, you might simply add <code>&lt;</code> and <code>&gt;</code> to a blacklist in hopes of preventing XSS via <code>&lt;script&gt;</code> tags, but you’re ignoring attacks that can be accomplished with only double quotes, parentheses, and an equal sign.</p>
<p class="indent">In general, if your app or an app you’re testing relies on blacklisting characters, investigate whether the blacklist might be masking an underlying flaw. Such filters can be easily bypassed, and an app that relies on this technique probably also lacks effective output encoding, which I’ll discuss in “<a href="ch12.html#ch12lev2sec02">Output Encoding</a>” on <a href="ch12.html#page_201">page 201</a>.</p>
<h5 class="h5" id="ch12lev3sec02"><strong>Whitelisting Allowable Input</strong></h5>
<p class="noindent">In a whitelist approach, you instead explicitly define the characters that are acceptable for a particular user input. Whitelisting is preferable to blacklisting because comprehensively specifying what characters should be allowed is easier than speculating about what might be bad. In a whitelist approach, you might define the characters that a phone number field should allow: 0 through 9 and possibly dashes and parentheses. Not only does this preclude most any malicious input, but it also keeps data clean in your database.</p>
<h5 class="h5" id="ch12lev3sec03"><a id="page_201"/><strong>Finding Balance</strong></h5>
<p class="noindent">It’s possible to be misguidedly zealous about input sanitization with either blacklisting or whitelisting. Some programs and websites actually disallow legitimate characters in some inputs (most notably, user passwords). You may have run across an app or site that refuses to accept a password containing special characters (such as <code>!</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, or <code>;</code>). This is often an indication that the programmers are handling data on the backend in a remarkably incompetent way.</p>
<p class="indent">For example, if an application strips apostrophes or semicolons, the developers may not be using parameterized SQL statements, instead relying on removing “bad” special characters to prevent SQL injection. But this blacklisting of suspected bad characters just reduces user password complexity, and it’s unlikely to solve the problem of SQL injection in any comprehensive fashion.</p>
<p class="indent">For input sanitization to work correctly, it also needs to happen as close as possible to the point before the data is processed or stored. For example, when an iOS application talks to a remote API, the application can certainly try to strip out harmful characters or restrict input to a certain character range. This is fine, but it <em>only</em> results in increased usability for the user. The user can see immediately that their input won’t be accepted, rather than waiting until they fill out all the form data and try to submit it.</p>
<p class="indent">Your typical users may appreciate that side effect, but there’s a problem here: the user controls the device and, ultimately, how your program behaves. If your UI won’t allow certain values as input, all an attacker needs to do is route the device’s traffic through a proxy, as I described in “<a href="ch04.html#ch04lev1sec04">Network and Proxy Setup</a>” on <a href="ch04.html#page_43">page 43</a>. The user can then modify data after it leaves the app but before it reaches the server and add the harmful characters back.</p>
<p class="indent">To counter this possibility, never trust a mobile app to supply good data. In a client-server app, always ensure that sanitization happens on the server.</p>
<p class="indent">With sane input sanitization in place, you should move on to encoding your output.</p>
<h4 class="h4" id="ch12lev2sec02"><em><strong>Output Encoding</strong></em></h4>
<p class="noindent">Output encoding, sometimes known as HTML entity encoding, is the process of taking user input and replacing characters with their HTML representations. This process is necessary for any potentially untrusted data that might end up rendered in a WebView. For example, the characters <code>&lt;</code> and <code>&gt;</code> would be translated to <code>&amp;lt;</code> and <code>&amp;gt;</code>, respectively. When data is displayed to the user, those characters should appear in the UI as <code>&lt;</code> and <code>&gt;</code>, but because they’ve been encoded, the HTML engine doesn’t process them as metacharacters, which might be used in a <code>&lt;script&gt;</code> tag.</p>
<p class="indent"><a id="page_202"/>Output encoding is the last and most potent line of defense before delivering HTML that contains third-party input to a client. Even if you totally neglected to strip potentially harmful metacharacters during input sanitization, as long as you encode your output, you don’t have to worry about whether the data you send will be executed by the browser rather than just displayed.</p>
<h5 class="h5" id="ch12lev3sec04"><strong>Displaying Untrusted Data</strong></h5>
<p class="noindent">Like input sanitization, output encoding is usually a process you should perform on the server side, not the client. But if you have to display data from domains outside your control that contain untrusted data, you’ll want to perform HTML entity encoding before displaying content to the user.</p>
<p class="indent">Google Toolbox for Mac includes two category methods of <code>NSString</code> that you could use to encode HTML entities on the client side: <code>gtm_string-ByEscapingForHTML</code> and <code>gtm_stringByEscapingForAsciiHTML</code>.<sup><a href="footnote.html#fn106" id="fn_106">2</a></sup> Including Google’s category for <code>NSString</code> in your project makes it so you can simply call a method on any <code>NSString</code> object to have it return an encoded representation:</p>
<pre><span class="violet1">NSString</span> *escaped;<br/>escaped = [<span class="red">@"Meet &amp; greet"</span> gtm_stringByEscapingForHTML];</pre>
<p class="indent">After this escaping, <code>escaped</code> should contain the <code>NSString Meet &amp;amp; greet</code>, which should be safe to render within HTML.</p>
<h5 class="h5" id="ch12lev3sec05"><strong>Don’t Over-Encode</strong></h5>
<p class="noindent">As with input sanitization, be careful not to get carried away with output encoding. Some applications entity-encode received characters before sending them to a server or storing them in a database and then end up reencoding the encoded data. You may have seen the results in mobile apps or web apps.</p>
<p class="indent">For example, I once saw an application display a banner inviting me to “Meet &amp;amp; greet.” In the underlying HTML source, this data would appear as follows:</p>
<pre>Meet &amp;amp;amp; greet</pre>
<p class="indent">The original input was already encoded (to <code>&amp;amp;</code>) and would have rendered fine as <code>&amp;</code> in the browser. Encoding it again causes it to show up as <code>&amp;amp;</code> to the user. This doesn’t create a security problem, but it can cause your data to become messy and hard to deal with. Just remember that there’s a reason the technique is called <em>output encoding</em>: it needs to be done just before output.</p>
<h3 class="h3" id="ch12lev1sec02"><a id="page_203"/><strong>SQL Injection</strong></h3>
<p class="noindent">Client-side SQL injection results from parsing externally supplied data that injects valid SQL into a badly formed SQL statement. Statements that are constructed dynamically on execution, using unsanitized, externally supplied input, are vulnerable to SQL injection. Malicious input will contain SQL metacharacters and statements that subvert the intent of the original query.</p>
<p class="indent">For example, imagine a simple status message is posted to a website by a user. It then gets downloaded and added to a local data store. If the user posting the original content has basic security knowledge and malicious intent, the user could embed SQL into the message, which will be executed when parsed by the SQL engine. This malicious SQL could destroy or modify existing data in the data store.</p>
<p class="indent">On iOS, the most commonly used SQL API is SQLite. <a href="ch12.html#ch12ex1">Listing 12-1</a> shows an example of an incorrectly formed, dynamically constructed SQL statement for SQLite.</p>
<pre><span class="violet1">NSString</span> *uid = [myHTTPConnection get<span class="violet1">UID];</span><br/><span class="violet1">NSString *</span>statement = [<span class="violet1">NSString</span> StringWithFormat:<span class="red">@"SELECT username FROM users where</span><br/>     <span class="red">uid = '%@'"</span>,uid];<br/><span class="rose">const char</span> *sql = [statement UTF8String];</pre>
<p class="listcap"><a id="ch12ex1"/><em>Listing 12-1: An unparameterized SQL statement vulnerable to SQL injection</em></p>
<p class="indent">The problem here is that the <code>uid</code> value is being taken from user-supplied input and inserted as is into a SQL statement using a format string. Any SQL in the user-supplied parameter will then become part of that statement when it ultimately gets executed.</p>
<p class="indent">To prevent SQL injection, simply use parameterized statements to avoid the dynamic construction of SQL statements in the first place. Instead of constructing the statement dynamically and passing it to the SQL parser, a parameterized statement causes the statement to be evaluated and compiled independently of the parameters. The parameters themselves are supplied to the compiled statement upon execution.</p>
<p class="indent">Using parameterized statements, the correct way to structure the query in <a href="ch12.html#ch12ex1">Listing 12-1</a> is to use <code>?</code> as a placeholder character for the supplied parameter, as in <a href="ch12.html#ch12ex2">Listing 12-2</a>.</p>
<pre>   <span class="rose">static</span> sqlite3_stmt *selectUid = nil;<br/><span class="ent">➊</span> <span class="rose">const char</span> *sql = <span class="red">"SELECT username FROM users where uid = ?"</span>;<br/><span class="ent">➋</span> <span class="green">sqlite3_prepare_v2</span>(db, sql, -1, &amp;selectUid, NULL);<br/><span class="ent">➌</span> <span class="green">sqlite3_bind_int</span>(selectUid, 1, uid);<br/>   <span class="rose">int</span> status = <span class="green">sqlite3_step</span>(selectUid);</pre>
<p class="listcap"><a id="ch12ex2"/><em>Listing 12-2: A properly parameterized SQL statement</em></p>
<p class="indent"><a id="page_204"/>The SQL statement is constructed with the <code>?</code> placeholder at <span class="ent">➊</span>. The code then compiles the SQL statement with <code>sqlite3_prepare_v2</code> at <span class="ent">➋</span> and lastly binds the user-supplied <code>uid</code> using <code>sqlite3_bind_int</code> at <span class="ent">➌</span>. Since the SQL statement has already been constructed, no additional SQL provided in the <code>uid</code> parameter will be added to the SQL itself; it’s simply passed in by value.</p>
<p class="indent">In addition to preventing SQL injection, using parameterized, prepared statements will improve application performance under most circumstances. You should use them for all SQL statements, even if a statement isn’t taking input from untrusted sources.</p>
<h3 class="h3" id="ch12lev1sec03"><strong>Predicate Injection</strong></h3>
<p class="noindent"><em>Predicates</em> let you perform logical comparisons between data using a basic query language not dissimilar to SQL. In a basic <code>NSPredicate</code>, values are compared or filtered using format strings.</p>
<pre><span class="ent">➊</span> <span class="violet1">NSMutableArray</span> *fruit = [<span class="violet1">NSMutableArray</span> arrayWithObjects:<span class="red">@"Grape"</span>, <span class="red">@"Peach"</span>,<br/>        <span class="red">@"orange"</span>, <span class="red">@"grapefruit"</span>, nil];<br/><span class="ent">➋</span> <span class="violet1">NSPredicate</span> *pred = [<span class="violet1">NSPredicate</span> predicateWithFormat:<span class="red">@"SELF CONTAINS[c] 'Grape'"</span>];<br/><span class="ent">➌</span> <span class="violet1">NSArray</span> *grapethings = [fruit filteredArrayUsingPredicate:pred];<br/>   <span class="violet1">NSLog(</span><span class="red">@"%@"</span><span class="violet1">,</span> grapethings);</pre>
<p class="indent">At <span class="ent">➊</span>, an array of various types of fruit is created; this array will be the data source to evaluate against an expression. When creating a predicate at <span class="ent">➋</span>, a query is created that checks whether the string <code>"Grape"</code> is contained in the item the predicate is being compared to. (The <code>[c]</code> makes this comparison case insensitive.) When a new array is instantiated at <span class="ent">➌</span> to contain the results of this comparison, the <code>filteredArrayUsingPredicate</code> method of the <code>fruit</code> array is used to pass in the predicate. The resulting <code>grapethings</code> array should now contain both <code>"Grape"</code> and <code>"grapefruit"</code>.</p>
<p class="indent">So far, so good! But a few things can go wrong when you build a predicate query using externally supplied data. First, consider the case where a predicate is built using SQL’s <code>LIKE</code> operator, as follows.</p>
<pre><span class="violet1">NSPredicate</span> *pred;<br/>pred = [<span class="violet1">NSPredicate</span> predicateWithFormat:<span class="red">@"pin LIKE %@"</span>, [<span class="rose">self</span>.pin text]];</pre>
<p class="indent">This example evaluates a PIN, perhaps a secondary form of authentication for my application. But the <code>LIKE</code> operator performs the evaluation, which means a simple entry of the wildcard character (<sub>*</sub>) from a user will cause the predicate to evaluate to true, effectively bypassing PIN protection.</p>
<p class="indent"><a id="page_205"/>This result may seem obvious to those familiar with SQL injection (since SQL also has a <code>LIKE</code> operator), but consider the more subtle case where you’re examining code that uses the predicate <code>MATCHES</code> operator, as shown here:</p>
<pre><span class="violet1">NSPredicate</span> *pred;<br/>pred = [<span class="violet1">NSPredicate</span> predicateWithFormat:<span class="red">@"pin MATCHES %@"</span>, [<span class="rose">self</span>.pin text]];</pre>
<p class="indent">This code has the same issue as the <code>LIKE</code> example, but rather than just accepting wildcards, <code>MATCHES</code> expects a regular expression. Therefore, using <code>.*</code> as your PIN will be enough to bypass validation.</p>
<p class="indent">To prevent predicate injection attacks, examine all uses of <code>NSPredicate</code> in your code and make sure that the operators being used make sense for the application. It’s also probably a good idea to limit the characters that are allowed in user-supplied data that gets passed to a predicate to ensure that characters like wildcards don’t get plugged in. Or, simply don’t use a predicate for security-sensitive operations.</p>
<h3 class="h3" id="ch12lev1sec04"><strong>XML Injection</strong></h3>
<p class="noindent">XML injection occurs when malicious XML is parsed by an XML parser instance. Typically, this type of attack is used to force an application to load external resources over the network or consume system resources. In the iOS world, the most commonly used XML parser is the Foundation <code>NSXMLParser</code> class.</p>
<h4 class="h4" id="ch12lev2sec03"><em><strong>Injection Through XML External Entities</strong></em></h4>
<p class="noindent">One basic function of an XML parser is to handle XML entities. You can basically think of these as shortcuts or euphemisms. For example, say you have a simple string like this one:</p>
<pre>&lt;!<span class="rose">ENTITY</span> myEntity <span class="red">"This is some text that I don't want to have to spell out</span><br/>     <span class="red">repeatedly"</span>&gt;</pre>
<p class="indent">You could then reference the entity in other parts of an XML document, and the parser would insert the contents of the entity at that placeholder. To reference your defined entity, simply use this syntax:</p>
<pre>&lt;explanation&gt;&amp;myEntity;&lt;/explanation&gt;</pre>
<p class="indent"><a id="page_206"/><code>NSXMLParser</code> instances have several configurable parameters that can be set after instantiation. If <code>shouldResolveExternalEntities</code> is set to <code>YES</code> on an <code>NSXMLParser</code> instance, the parser will honor <em>Document Type Definitions (DTDs)</em>, which can define entities fetched from external URLs. (That’s why these are called <em>external</em> entities.) When a defined entity is encountered later in the parsed XML, the URL will be requested, and the results of the query will be used to populate the XML, as in this example:</p>
<pre><span class="violet1">NSURL</span> *testURL = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"http://api.nostarch.com"</span>];<br/><span class="violet1">NSXMLParser</span> *testParser = [[<span class="violet1">NSXMLParser</span> <span class="violet">alloc</span>] initWithContentsOfURL:testURL];<br/>[testParser setShouldResolveExternalEntities:YES];</pre>
<p class="indent">Here, an XML parser is instantiated that reads data from an <code>NSURL</code> passed to the <code>initWithContentsOfURL</code> argument. But if the remote server decides to return huge amounts of data, or to simply hang, the client application may crash or hang in response.</p>
<p class="indent">Remember, however, that an external entity can also refer to a local file, meaning the file’s contents could be included in your parsed XML. If that XML is stored and then later delivered to the server or another third party, the contents of the file will be disclosed along with the rest of the XML. To avoid such scenarios, ensure that any URL or filename passed to the XML parser is thoroughly sanitized, ideally by a using whitelisting approach, as I discussed in relation to cross-site scripting in “<a href="ch12.html#ch12lev3sec02">Whitelisting Allowable Input</a>” on <a href="ch01.html#page_12">page 12</a>.</p>
<p class="indent">Note that in iOS 7.0 and 7.1 the default behavior of the XML parser is to resolve external entities (the opposite of the parser’s intended behavior), and using <code>setShouldResolveExternalEntities:NO</code> doesn’t actually work.<sup><a href="footnote.html#fn107" id="fn_107">3</a></sup> Unfortunately, there is no workaround to secure the XML parser for older versions of iOS, short of using an alternative XML parser. The issue was resolved in iOS 8.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Contrary to what some have claimed,</em> <code><em>NSXMLParser</em></code> <em>is</em> not <em>vulnerable to recursive entity attacks, a type of denial of service otherwise known as the</em> billion laughs <em>attack. Vulnerable parsers will resolve recursive entities (entities that reference other entities) and chew up tons of system resources. However, if recursive entity declarations are given to</em> <code><em>NSXMLParser</em></code><em>, an</em> <code><em>NSXMLParserEntityRefLoopError</em></code> <em>is thrown.</em></p>
</div>
<p class="indent">Misuse of official external entities isn’t the only element of XML injection to watch for in iOS code, however. Some apps incorporate third-party XML libraries, which bring their own set of problems.</p>
<h4 class="h4" id="ch12lev2sec04"><a id="page_207"/><em><strong>Issues with Alternative XML Libraries</strong></em></h4>
<p class="noindent">You may encounter alternative XML libraries in various iOS projects, generally chosen for their improved performance characteristics over <code>NSXMLParser</code> and their support for features such as XPath. (Ray Wenderlich offers a good tutorial on choosing an XML parser on his blog.<sup><a href="footnote.html#fn108" id="fn_108">4</a></sup>) When examining code that uses an alternate XML library, first ensure that external entity expansion is disabled using that library’s standard methods. Then, confirm that any XPath queries that integrate externally supplied input sanitize the input first, as you would when preventing cross-site scripting. XPath queries should also be parameterized in a manner similar to that of SQL queries (see “<a href="ch12.html#ch12lev1sec02">SQL Injection</a>” on <a href="ch12.html#page_203">page 203</a>), but the methods for doing this may vary depending on which third-party libraries are involved.</p>
<h3 class="h3" id="ch12lev1sec05"><strong>Closing Thoughts</strong></h3>
<p class="noindent">Ultimately, handling most of the attacks in this chapter comes down to treating all external input as hostile: remove potentially malicious content and encode or prepare it, if possible, to prevent code execution. It’s a good idea to be specific about the content that is allowed for each parameter fetched from the UI or from a remote user-manipulated source and enforce this in your program.</p>
<p class="indent">Now I’ll turn away from shielding against malicious data and toward protecting good data with appropriate cryptography.<a id="page_208"/></p>
</body></html>