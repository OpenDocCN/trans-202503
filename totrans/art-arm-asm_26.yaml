- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: F ANSWERS TO QUESTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: F.1 Chapter 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  *as*
  prefs: []
  type: TYPE_NORMAL
- en: 2.  address, data, and control
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The PSTATE register
  prefs: []
  type: TYPE_NORMAL
- en: 4.  (a) 4, (b) 8, (c) 16, (d) 8
  prefs: []
  type: TYPE_NORMAL
- en: 5.  64 bits
  prefs: []
  type: TYPE_NORMAL
- en: 6.  bl
  prefs: []
  type: TYPE_NORMAL
- en: 7.  ret
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Application binary interface
  prefs: []
  type: TYPE_NORMAL
- en: 9.  (a) LO byte of W0, (b) LO hword of W0, (c) W0, (d) X0, (e) X0
  prefs: []
  type: TYPE_NORMAL
- en: 10.  X0, X1, X2, and X3 registers (respectively)
  prefs: []
  type: TYPE_NORMAL
- en: F.2 Chapter 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  9 × 10³ + 3 × 10² + 8 × 10¹ + 4 × 10⁰ + 5 × 10 ^(–1) + 7 × 10^(–2) + 6 ×
    10^(–3)
  prefs: []
  type: TYPE_NORMAL
- en: 2.  (a) 10, (b) 12, (c) 7, (d) 9, (e) 3, (f) 15
  prefs: []
  type: TYPE_NORMAL
- en: 3.  (a) A, (b) E, (c) B, (d) D, (e) 2, (f) C, (g) CF, (h) 98D1
  prefs: []
  type: TYPE_NORMAL
- en: 4.  (a) 0001_0010_1010_1111
  prefs: []
  type: TYPE_NORMAL
- en: (b)  1001_1011_1110_0111
  prefs: []
  type: TYPE_NORMAL
- en: (c)  0100_1010
  prefs: []
  type: TYPE_NORMAL
- en: (d)  0001_0011_0111_1111
  prefs: []
  type: TYPE_NORMAL
- en: (e)  1111_0000_0000_1101
  prefs: []
  type: TYPE_NORMAL
- en: (f)  1011_1110_1010_1101
  prefs: []
  type: TYPE_NORMAL
- en: (g)  0100_1001_0011_1000
  prefs: []
  type: TYPE_NORMAL
- en: 5.  (a) 10, (b) 11, (c) 15, (d) 13, (e) 14, (f) 12
  prefs: []
  type: TYPE_NORMAL
- en: 6.  (a) 32, (b) 128, (c) 16, (d) 64, (e) 4, (f) 8, (g) 4
  prefs: []
  type: TYPE_NORMAL
- en: 7.  (a) 4, (b) 8, (c) 16, (d) 2
  prefs: []
  type: TYPE_NORMAL
- en: 8.  (a) 16, (b) 256, (c) 65,536, (d) 2
  prefs: []
  type: TYPE_NORMAL
- en: 9.  4
  prefs: []
  type: TYPE_NORMAL
- en: 10.  0 through 7
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Bit 0
  prefs: []
  type: TYPE_NORMAL
- en: 12.  Bit 63
  prefs: []
  type: TYPE_NORMAL
- en: 13.  (a) 0, (b) 0, (c) 0, (d) 1
  prefs: []
  type: TYPE_NORMAL
- en: 14.  (a) 0, (b) 1, (c) 1, (d) 1
  prefs: []
  type: TYPE_NORMAL
- en: 15.  (a) 0, (b) 1, (c) 1, (d), 0
  prefs: []
  type: TYPE_NORMAL
- en: 16.  XORing with 1 (bitwise, all 1 bits in a register)
  prefs: []
  type: TYPE_NORMAL
- en: 17.  AND
  prefs: []
  type: TYPE_NORMAL
- en: 18.  OR
  prefs: []
  type: TYPE_NORMAL
- en: 19.  NOT (XOR with all 1 bits too)
  prefs: []
  type: TYPE_NORMAL
- en: 20.  XOR
  prefs: []
  type: TYPE_NORMAL
- en: 21.  not (eor with all 1 bits too)
  prefs: []
  type: TYPE_NORMAL
- en: 22.  1111_1011
  prefs: []
  type: TYPE_NORMAL
- en: 23.  0000_0010
  prefs: []
  type: TYPE_NORMAL
- en: 24.  (a) 1111_1111b, (c) 1000_0000b, (e) 1000_0001b
  prefs: []
  type: TYPE_NORMAL
- en: 25.  The neg instruction
  prefs: []
  type: TYPE_NORMAL
- en: 26.  (a) 1111_1111_1111_1111
  prefs: []
  type: TYPE_NORMAL
- en: (c)  000_0000_0000_0001
  prefs: []
  type: TYPE_NORMAL
- en: (d)  1111_1111_1111_0000
  prefs: []
  type: TYPE_NORMAL
- en: 27.  b (b.al)
  prefs: []
  type: TYPE_NORMAL
- en: '28.  label:'
  prefs: []
  type: TYPE_NORMAL
- en: 29.  Negative/sign (N), zero (Z), carry (C), and overflow (V)
  prefs: []
  type: TYPE_NORMAL
- en: 30.  Z = 1
  prefs: []
  type: TYPE_NORMAL
- en: 31.  C = 0 and Z = 0
  prefs: []
  type: TYPE_NORMAL
- en: 32.  bhi, bhs, bls, blo, beq, and bne conditional jump instructions
  prefs: []
  type: TYPE_NORMAL
- en: 33.  bgt, bge, blt, ble, beq, and bne conditional jump instructions
  prefs: []
  type: TYPE_NORMAL
- en: 34.  The lsl instruction does not affect the zero flag.
  prefs: []
  type: TYPE_NORMAL
- en: 35.  A multiplication by 2
  prefs: []
  type: TYPE_NORMAL
- en: 36.  A division by 2
  prefs: []
  type: TYPE_NORMAL
- en: 37.  Multiplication and division
  prefs: []
  type: TYPE_NORMAL
- en: 38.  A normalized floating-point value has a 1 bit in the HO mantissa position.
  prefs: []
  type: TYPE_NORMAL
- en: 39.  7 bits
  prefs: []
  type: TYPE_NORMAL
- en: 40.  0x30 through 0x39
  prefs: []
  type: TYPE_NORMAL
- en: 41.  The apostrophe (or single quotation mark) character
  prefs: []
  type: TYPE_NORMAL
- en: F.3 Chapter 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  The PC 64-bit register
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Operation code, the numeric encoding for a machine instruction
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Static/scalar variables and memory-based constants
  prefs: []
  type: TYPE_NORMAL
- en: 4.  About ±1 MB, with the ldr and str instructions
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The address of the memory location to access
  prefs: []
  type: TYPE_NORMAL
- en: 6.  (b) X0 and (d) SP
  prefs: []
  type: TYPE_NORMAL
- en: 7.  The lea macro (or adr and adrp instructions)
  prefs: []
  type: TYPE_NORMAL
- en: 8.  The final address obtained after all addressing mode calculations are completed
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Use the .align 3 directive to align a variable in the .data section to an
    8-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Memory management unit
  prefs: []
  type: TYPE_NORMAL
- en: 11.  An arithmetic expression that computes the (static) runtime address of
    a memory object
  prefs: []
  type: TYPE_NORMAL
- en: 12.  A big-endian value stores high-order portions of the value in lower memory
    addresses, while a little-endian value stores the low-order portions of the value
    in lower memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 13.  The rev32 instruction
  prefs: []
  type: TYPE_NORMAL
- en: 14.  The rev16 instruction
  prefs: []
  type: TYPE_NORMAL
- en: 15.  The rev instruction
  prefs: []
  type: TYPE_NORMAL
- en: 16.  Subtract 16 from SP, then store the value in X0 at the memory address pointed
    at by SP.
  prefs: []
  type: TYPE_NORMAL
- en: 17.  Load X0 from the address pointed at by SP, then add 16 to the SP register.
  prefs: []
  type: TYPE_NORMAL
- en: 18.  Reverse
  prefs: []
  type: TYPE_NORMAL
- en: 19.  Last-in, first-out
  prefs: []
  type: TYPE_NORMAL
- en: '## F.4 Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  A symbolic name for a constant that the assembler (or preprocessor) will
    replace with the numeric equivalent of that constant during assembly
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Use the .equ, .set, and = directives. You can also use the C preprocessor
    (CPP) #define directive if your source file’s name ends with *.S*.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.  A constant expression is an arithmetic expression that Gas can compute during
    assembly. You determine the number of data elements in the operand field of a
    byte directive by counting the expressions separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The current offset into a section (such as .data or .text)
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The period operator (.)
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Subtract the label of the second declaration from the label of the first
    (for example, second - first).
  prefs: []
  type: TYPE_NORMAL
- en: 7.  A 64-bit memory variable containing the address of another memory object;
    you would use a .dword directive to allocate storage for a pointer (or other mechanism
    to reserve 64 bits).
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Load that pointer into a 64-bit register and use the register-indirect addressing
    mode to access memory.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Use the .dword directive.
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Using an uninitialized pointer; using a pointer that contains an illegal
    value; continuing to use allocated data after it has been freed (a *dangling pointer*);
    failing to free memory after you are done using it (a *memory leak*); accessing
    indirect data by using the wrong data type
  prefs: []
  type: TYPE_NORMAL
- en: 11.  A pointer to allocated memory that has already been freed
  prefs: []
  type: TYPE_NORMAL
- en: 12.  A memory leak occurs when a program allocates memory (using malloc()) but
    fails to free that storage when it is done using it.
  prefs: []
  type: TYPE_NORMAL
- en: 13.  An object composed of (made up from) a collection of other data types
  prefs: []
  type: TYPE_NORMAL
- en: 14.  A sequence of characters delimited by a zero value (typically a byte)
  prefs: []
  type: TYPE_NORMAL
- en: 15.  A sequence of characters beginning with a length value (typically a byte,
    but it could also be a half word, word, or other type)
  prefs: []
  type: TYPE_NORMAL
- en: 16.  A structure that describes a string object, typically containing length
    information and a pointer to the string
  prefs: []
  type: TYPE_NORMAL
- en: 17.  A sequence of objects (all the same type) appearing in consecutive memory
    locations
  prefs: []
  type: TYPE_NORMAL
- en: 18.  The address of the first element, typically at the lowest address of the
    array in memory
  prefs: []
  type: TYPE_NORMAL
- en: '19.  Here is a typical array declaration using Gas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '20.  You will typically use a directive such as .word with a list of the initial
    element values; here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You could also use the .space directive if you have an array of bytes and every
    byte is initialized with the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 21.  (a) Multiply the index by 8 and add the base address of A to this product;
    (b) To access W[i, j], use address = base(W) + (i * 8 + j) * 4; (c) To access
    R[i, j, k], use address = base(R) + ((i * 4) + j) * 6 + k) * 4.
  prefs: []
  type: TYPE_NORMAL
- en: 22.  A mechanism for storing arrays in memory, where elements from each row
    appear in consecutive memory locations and the rows appear in consecutive blocks
    of memory
  prefs: []
  type: TYPE_NORMAL
- en: 23.  A mechanism for storing arrays in memory, where elements from each column
    appear in consecutive memory locations and the columns appear in consecutive blocks
    of memory
  prefs: []
  type: TYPE_NORMAL
- en: '24.  A typical two-dimensional array declaration for word array W[4,8] would
    take this form: W: .space 4 * 8 * 4, 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 25.  A composite data type whose elements (fields) need not all be the same
    type
  prefs: []
  type: TYPE_NORMAL
- en: '26.  Use statements like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 27.  Add the offset of a particular field to the base address of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 28.  A type of structure in which all fields occupy the same memory locations
  prefs: []
  type: TYPE_NORMAL
- en: 29.  For structs, each field is allocated a unique block of memory (according
    to its size), whereas for a union, all fields are allocated the same memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: F.5 Chapter 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  The bl instruction copies the address of the next instruction into LR, then
    transfers control to the target address specified by the operand.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The ret instruction copies the value from the LR into the program counter.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The biggest problem with caller preservation is that it is hard to maintain.
    It also generates bigger object code files.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  It saves registers, taking valuable CPU cycles, even if the caller doesn’t
    require those registers to be saved.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Storage space in the stack, where a procedure maintains parameters, return
    addresses, saved register values, local variables, and possibly other data
  prefs: []
  type: TYPE_NORMAL
- en: 6.  The FP register (X29)
  prefs: []
  type: TYPE_NORMAL
- en: '7.  The standard entry sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '8.  The standard exit sequence is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 9.  A variable that a procedure automatically allocates and deallocates storage
    for in an activation record
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Upon entry into a procedure
  prefs: []
  type: TYPE_NORMAL
- en: 11.  The parameter’s value
  prefs: []
  type: TYPE_NORMAL
- en: 12.  The parameter’s address
  prefs: []
  type: TYPE_NORMAL
- en: 13.  X0, X1, X2, and X3
  prefs: []
  type: TYPE_NORMAL
- en: 14.  All parameters beyond the eighth parameter get passed on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 15.  Volatile registers can be used by an ARM procedure without preserving their
    values; nonvolatile registers’ values must be preserved across a procedure call.
  prefs: []
  type: TYPE_NORMAL
- en: 16.  Registers X0, X1, ..., X15
  prefs: []
  type: TYPE_NORMAL
- en: 17.  Registers X16 through X31 (SP)
  prefs: []
  type: TYPE_NORMAL
- en: 18.  A procedure accesses parameters passed in the code stream via the address
    passed in the LR register.
  prefs: []
  type: TYPE_NORMAL
- en: 19.  Large parameters (such as arrays and records) should be passed by reference,
    since the procedure is faster and shorter when using reference arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 20.  The X0 register (X8 can contain a pointer to a large function return result)
  prefs: []
  type: TYPE_NORMAL
- en: 21.  The address of a procedure to call, passed as an argument to a procedure
    or function
  prefs: []
  type: TYPE_NORMAL
- en: 22.  Call procedural parameters (as well as any procedure via a pointer) by
    using the br instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '23.  Set aside local storage for the registers and preserve those values in
    the local storage.  ## F.6 Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The cmp instruction sets the zero flag if the two operands are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The cmp instruction sets the carry flag if one unsigned operand (left) is
    greater than or equal to the other unsigned operand (right).
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The cmp instruction sets negative and overflow flags to opposite values
    if the left signed operand is less than the signed right operand; they are set
    to the same value if the left signed operand is greater than or equal to the right
    signed operand.
  prefs: []
  type: TYPE_NORMAL
- en: '4.  x = x + y:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y - z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y * z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y + z * t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'x = (y + z) * t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'x = -((x * y) / z):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'x = (y == z) && (t != 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '5.  x = x * 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y * 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y * 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '6.  x = x / 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y / 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'x = z / 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '7.  x = x + y:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y - z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y * z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'x = y + z * t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'x = (y + z) * t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'x = -((x * y) / z):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '8.  bb = x < y:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'bb = x >= y && x < z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: F.7 Chapter 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  Use the lea macro to obtain the address of a symbol in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  br reg64
  prefs: []
  type: TYPE_NORMAL
- en: 3.  A piece of code that keeps track of its execution history by entering and
    leaving certain states
  prefs: []
  type: TYPE_NORMAL
- en: 4.  A mechanism for extending the range of a branch instruction
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Short-circuit Boolean evaluation might not execute code for all the conditions
    in an expression if it determines the result to be true or false without executing
    any additional code. Complete Boolean evaluation evaluates the entire expression,
    even if the result is known after a partial evaluation of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '6.'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '7.'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '8.  The following switch statements (assume all variables are unsigned 32-bit
    integers) become the assembly language code:'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '9.  The following while loops get converted to the corresponding assembly code
    (assuming all variables are signed 32-bit integers):'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: F.8 Chapter 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '1.'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '2.'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '3.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '4.  The conversions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: d.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '5.  The conversions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '6.  The conversions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: d.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: e.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: f.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '7.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '8.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '## F.9 Chapter 9'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Four output digits
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Call qToStr twice, the first time passing in the HO dword, the second time
    passing in the LO dword.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Take the input value and see if it is negative. If so, emit a dash (-) character
    and negate the value. Whether the number is negative or nonnegative, call the
    unsigned conversion function to do the rest of the work.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The u64toSizeStr function expects a pointer to the destination buffer in
    X0, the value to convert to a string in X1, and the minimum field width in X3.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The function will output however many characters are necessary to correctly
    represent the value.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  The r64ToStr function expects the floating-point value to convert in D0,
    a pointer to the buffer in X0, the field width in X1, the number of digits after
    the decimal point in X2, the padding character in the LO byte of X3, and the maximum
    string length in X4.
  prefs: []
  type: TYPE_NORMAL
- en: '7.  A string fWidth characters long, containing the # character if it cannot
    properly format the output'
  prefs: []
  type: TYPE_NORMAL
- en: 8.  D0 contains the value to convert; X0 contains the address of the output
    buffer; X1 contains the field width; X2 is the padding character; X3 contains
    the number of exponent digits; X4 is the maximum string width.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  A character used to begin, end, and separate input values
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Overflow and illegal input characters
  prefs: []
  type: TYPE_NORMAL
- en: F.10 Chapter 10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  The set of legal input values
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The set of possible output values
  prefs: []
  type: TYPE_NORMAL
- en: '3.'
  prefs: []
  type: TYPE_NORMAL
- en: a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: c.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: d.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 4.  The process of adjusting the input value to a function so that the minimum
    and maximum values are limited, in order to allow the use of smaller tables
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Because memory access is so slow relative to computational performance
  prefs: []
  type: TYPE_NORMAL
- en: F.11 Chapter 11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  A lane is an element of a byte, half-word, word, or dword array held within
    a vector register. When operating on a pair of vector registers, lanes are corresponding
    elements within the two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  A scalar instruction operates on a single piece of data, while a vector
    instruction operates on multiple lanes (pieces of data) within a vector register.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The fmov Sd, Ws instruction
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The fmov Dd, Xs instruction
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The tbl or tbx instruction
  prefs: []
  type: TYPE_NORMAL
- en: 6.  The mov Vd.t[index], Rs instruction (Rn = Xn or Wn)
  prefs: []
  type: TYPE_NORMAL
- en: '7.  The shl Vd.2D, Vs.2D, #n instruction'
  prefs: []
  type: TYPE_NORMAL
- en: 8.  A vertical addition adds the corresponding lanes from two vector registers
    together, while a horizontal addition adds adjacent lanes in a single vector register
    together.
  prefs: []
  type: TYPE_NORMAL
- en: '9.  Use the movi v0.16B, #0 instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '10.  Use the movi v0.16B, #0xff instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: F.12 Chapter 12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  The and and bic instructions
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The bic instruction
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The orr instruction
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The eor instruction
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The tst instruction
  prefs: []
  type: TYPE_NORMAL
- en: 6.  The bfxil (or bfm) instruction
  prefs: []
  type: TYPE_NORMAL
- en: 7.  The bfi (or bfm) instruction
  prefs: []
  type: TYPE_NORMAL
- en: 8.  The clz instruction
  prefs: []
  type: TYPE_NORMAL
- en: 9.  You could reverse the bits in the register, invert all the bits, and then
    use the clz instruction to find the first nonzero bit.
  prefs: []
  type: TYPE_NORMAL
- en: 10.  The cnt instruction
  prefs: []
  type: TYPE_NORMAL
- en: F.13 Chapter 13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  Compile-time language
  prefs: []
  type: TYPE_NORMAL
- en: 2.  During assembly (compilation)
  prefs: []
  type: TYPE_NORMAL
- en: 3.  #warning
  prefs: []
  type: TYPE_NORMAL
- en: 4..warning
  prefs: []
  type: TYPE_NORMAL
- en: 5.  #error
  prefs: []
  type: TYPE_NORMAL
- en: 6..error
  prefs: []
  type: TYPE_NORMAL
- en: 7.  #define
  prefs: []
  type: TYPE_NORMAL
- en: 8..equ, .set, and =
  prefs: []
  type: TYPE_NORMAL
- en: '9.  #ifdef, #ifndef, #if, #elif, #else, and #endif'
  prefs: []
  type: TYPE_NORMAL
- en: 10.  The main Gas conditional assembly directives are .if, .elseif, .else, and
    .endif. The secondary assembly directives are .ifdef, .ifb, .ifc, .ifeq, .ifeqs,
    .ifge, .ifgt, .ifile, .iflt, .ifnb, .ifnc, .ifndef/.ifnotdef, .ifne, .ifnc, and
    .ifnes.
  prefs: []
  type: TYPE_NORMAL
- en: 11.  The CPP map macro
  prefs: []
  type: TYPE_NORMAL
- en: 12..rept, .irp, .irpc, and .endr
  prefs: []
  type: TYPE_NORMAL
- en: 13..irpc
  prefs: []
  type: TYPE_NORMAL
- en: 14.  #define
  prefs: []
  type: TYPE_NORMAL
- en: 15..macro and .endm
  prefs: []
  type: TYPE_NORMAL
- en: 16.  Specify the macro name at the place in the file where an instruction mnemonic
    is expected.
  prefs: []
  type: TYPE_NORMAL
- en: '17.  Use functional notation. For example: mymacro(p1, p2).'
  prefs: []
  type: TYPE_NORMAL
- en: '18.  Specify Gas macro parameters as operands in the instruction operand field.
    For example: lea x0, label (x0 and label are the parameters to the lea macro).'
  prefs: []
  type: TYPE_NORMAL
- en: 19.  Put :req after the parameter in the macro declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 20.  Specify the parameter name in the macro declaration without a suffix (:req,
    :varargs, or =expression). By default, Gas macro parameters are optional.
  prefs: []
  type: TYPE_NORMAL
- en: '21.  Use ... as the last (or only) argument in a #define macro definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 22.  Put :varargs after the last (or only) argument in a Gas macro definition.
  prefs: []
  type: TYPE_NORMAL
- en: 23.  Use the .ifb (if blank) conditional assembly directive.
  prefs: []
  type: TYPE_NORMAL
- en: 24..exitm
  prefs: []
  type: TYPE_NORMAL
- en: '## F.14 Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  A sequence of zero or more characters in memory ending with a byte containing
    0
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Because the program must often scan the entire string to determine its length
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Because this string assembly language type (a) encodes the string’s length
    as part of the data type, (b) aligns the string data on a 16-byte boundary, and
    (c) guarantees that the storage for the string is a multiple of 16 bytes long.
    This allows algorithms to fetch additional data beyond the end of the string,
    as long as all the data fits within a block of 16 bytes aligned on a 16-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Because the starting index argument can be any value
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Because they must deal with variable-length characters
  prefs: []
  type: TYPE_NORMAL
- en: F.15 Chapter 15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  #ifndef or .ifndef
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The assembly of a source file plus any files it directly or indirectly includes
  prefs: []
  type: TYPE_NORMAL
- en: 3..global
  prefs: []
  type: TYPE_NORMAL
- en: 4..extern. Technically, using this directive is optional, as Gas assumes all
    undefined symbols are external.
  prefs: []
  type: TYPE_NORMAL
- en: '5.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 6.  A makefile-dependent file is a file that must be built or updated in order
    to properly build the current file (that is, the current file depends on the makefile-dependent
    file in order to be built).
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Delete all executable and object-code files produced by a make operation.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  A collection of object modules that the linker can use to extract (only)
    those object modules it needs
  prefs: []
  type: TYPE_NORMAL
- en: F.16 Chapter 16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.  The operating system typically uses svc to call an OS API function.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  #0
  prefs: []
  type: TYPE_NORMAL
- en: 3.  #0x80
  prefs: []
  type: TYPE_NORMAL
