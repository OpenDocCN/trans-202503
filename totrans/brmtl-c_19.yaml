- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modular Programming
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: So far we’ve been working with small, simple one-file programs, which is fine
    if all you’re going to do is write sample programs for a book. In the real world,
    however, you’re probably going to encounter programs with more than 50 lines in
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel has 33,000 files and 28 million lines of code (and those numbers
    are increasing as you are reading this). You can’t deal with that amount of information
    without organizing it by dividing up the code into *modules*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A module ideally is a single file containing a collection of data and functions
    that does one thing well with minimum interaction with other modules. We’ve already
    used the STM HAL collection of modules earlier in this book, including the module
    containing the `HAL_Init` function. It does a lot of work internally, but we never
    see it. We see only a simple module that does one thing well: it initializes all
    the stuff needed to get the hardware to work.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a program that uses two files. The main program will be called
    *main.c* (see [Listing 17-1](#listing17-1)) and will call a function in the *func.c*
    file (see [Listing 17-2](#listing17-2)). We’ll use a makefile (see [Listing 17-3](#listing17-3))
    to compile the two files into one program.
  prefs: []
  type: TYPE_NORMAL
- en: '**main.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-1: The main program'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is the declaration of `funct` 1 in *main.c*. The`extern`keyword
    tells C that the function is defined in another file, named *func.c*.[Listing
    17-2](#listing17-2) contains that file.
  prefs: []
  type: TYPE_NORMAL
- en: '**func.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-2: The file that defines the function'
  prefs: []
  type: TYPE_NORMAL
- en: The `funct` function is defined 1 in the *func.c* file, and the makefile in
    [Listing 17-3](#listing17-3) handles the compilation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-3: simple/Makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the makefile tells `make` that the target `main` must be rebuilt
    if *main.c* or *func.c* changes. The second line tells `make` that when one of
    those files changes it should compile both files and use them to make the program.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ve taken a function and a main program and put them in two
    different files. Then we told `make` to tell the compiler to combine them into
    one program. This is an oversimplified version of modular programming, but these
    basic principles are used with more complex programs with larger and more numerous
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with the Simple Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous example has a few problems. The first one is that the same information
    is repeated twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *main.c*, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And in *func.c*, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: which means that if we change one file, we must change the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Worse, *C does not check types across files*, which means it’s possible to
    have the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: in two different files. Suppose file *a.c* decides to set `flag` to zero. The
    program is going to deposit 32 bits worth of zero into `flag`, which is defined
    in file *b.c* as being only 16 bits long. What will actually happen is that 16
    bits will go into `flag`, and 16 bits will go into something else. The result
    is that unexpected, surprising, and difficult-to-debug things will happen to your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to declare a variable `extern` in a file and later declare it
    without the `extern`. C will check to make sure that the type in the `extern`
    definition matches the type in the actual declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Concerning the second problem, suppose we want to use our external function
    `funct` in several different files. Do we want to add an `extern` statement to
    each of them? That would mean the definition of `funct` would be duplicated in
    many different places (and not checked by the compiler).
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to create a header file to hold the `extern` definition. [Listing
    17-4](#listing17-4) contains this file.
  prefs: []
  type: TYPE_NORMAL
- en: '**func.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-4: The file that defines the function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the function definition 1, this file also contains *double inclusion
    protection*. The `#findef`/`#endif` pair prevents problems that might occur if
    your program does something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the definitions in *func.h* to be defined twice, which is not
    a problem for `extern` declarations, but it will upset the compiler if multiple
    instances of `#define` are involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example looks a bit silly, because in real programs, the problem is not
    so obvious. You may have a case where the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: but the *database.h* file includes the *direct_io.h* file, which includes *func.h*,
    and the *service.h* file includes the *network.h* file, which includes *func.h*.
    You then get *func.h* included twice, even though you took the long way to do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the `#include` statement has changed slightly in these examples
    as well. Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'it’s this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The quotation marks indicate that the file to be included is a user-generated
    file. The compiler will search for it in the current directory instead of searching
    through the system files.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-5](#listing17-5) contains an improved *main.c* that uses the include
    file to bring in the `extern` declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**good/main.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-5: Improved *main.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-6](#listing17-6) contains the improved *func.c* that includes *func.h*.
    The `extern` functions defined in *func.h* are not really needed to compile *func.c*,
    but by bringing them in, we make sure that the `extern` matches the actual function
    declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**good/func.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-6: Improved *func.c*'
  prefs: []
  type: TYPE_NORMAL
- en: By including the *func.h* file twice, we’ve solved the problem that can occur
    when the `extern` does not match the actual declaration. Including it in *func.c*
    lets the compiler check the definition of the function, while in *main.c*, the
    inclusion provides us with the definition of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The makefile for this program has changed as well (see [Listing 17-7](#listing17-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-7: Improved *Makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line defines a macro called `CFLAGS`, which is a specific name used
    to compile C programs. The next line defines another macro called `OBJS` (there
    is nothing significant about that name), which contains a list of the objects
    we use to make our program. In this example, we’re going to compile *main.c* into
    the *main.o* object file and compile *func.c* into the *func.o* object file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re using a macro here simply to avoid having to write the list twice in
    the next rule 1, which tells `make` to create *main.o* from *main.c* and *func.h*.
    However, this rule isn’t followed by a rule telling `make` *how* to do this. When
    `make` doesn’t have a rule for something, it falls back to its list of built-in
    rules. When we create a *.o* (or .*obj*) file from a *.c* file, that built-in
    rule is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: where `CC` is the macro containing the name of the C compiler (in this case,
    `cc`, which is an alias for `gcc`).
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates a simple modular program, but the design pattern works
    when programs have additional modules.
  prefs: []
  type: TYPE_NORMAL
- en: What Makes Good Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following list outlines some rules for making good modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Each module should have a header file with the same name as the module. That
    file should contain the definitions of the public types, variables, and functions
    in that module (and nothing else).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every module should include its own header file so that C can check to make
    sure the header file and the implementation match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules should contain code used for a common purpose, and they should expose
    the minimum amount of information to the outside world. The information they do
    expose through `extern` declarations is global (seen by the entire program), and
    as described in the next section, sometimes that can be a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One problem with C is that it does not have namespaces. In C++, for example,
    you can tell the compiler that all the symbols in a given module belong to the
    `db` namespace, so you can create a module with entries like `insert`, `delete`,
    and `query` that are visible to other people as `db::insert`, `db::delete`, and
    `db::query`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In C, if you define a public function called `Init`, no one else can define
    a function called `Init` in any module. If this does happen, the linker will complain
    about a duplicate symbol. Since there may be more than one item that needs initialization,
    that can be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Most programmers solve this issue by adding a module prefix to the name of each
    public function, type, or variable. You can see this in action with the HAL library
    that gets added automatically to your Nucleo projects. For example, as shown in
    [Listing 17-8](#listing17-8), all the functions that manipulate the UART begin
    with the `UART_` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-8: An excerpt from *stm32f0xx_hal_uart.h*'
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that a public symbol in the HAL library starts with `HAL_`,
    which makes it easy to determine whether a function belongs to the library. It
    also ensures that you don’t accidentally use a name already in use by the HAL
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Listing every file that goes into a program is not too bad when there are fewer
    than 20 files. After that, it gets a little tedious, but it’s manageable until
    the number gets really big. The mainframe programs we’ve been writing use the
    standard C library functions. The C library has more than 1,600 files. Fortunately,
    we don’t need to list them all when we compile a program.
  prefs: []
  type: TYPE_NORMAL
- en: The standard C library is a file named *libc.a*, and it’s automatically loaded
    when your program is linked. The library is a collection of object files in a
    simple archive format (hence the *.a* extension).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create our own library containing several modules to square various types
    of numbers. [Listing 17-9](#listing17-9) shows a function to square a floating-point
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '**square_float.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-9: A function to square a floating-point number'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-10](#listing17-10) is the header for that module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**square_float.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-10: The header file for the *square_float.c* module'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-11](#listing17-11) defines a function to square an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**square_int.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-11: A function to square an integer'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-12](#listing17-12) defines its header file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**square_int.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-12: The header file for *square_int.c*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, [Listing 17-13](#listing17-13) is a similar function to square an unsigned
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: '**square_unsigned.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-13: A function to square an unsigned integer'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-14](#listing17-14) defines the header file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**square_unsigned.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-14: The header file for *square_unsigned.c*'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to put our three functions in a library. If users want to use this
    library, they will have to include all those header files. That’s a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, we’ll create a header file called *square.h* for the
    library. This file consolidates the individual headers for each of the preceding
    library components (modules). As a result, people who use this library just need
    to include *square.h* (see [Listing 17-15](#listing17-15)) instead of a bunch
    of individual headers.
  prefs: []
  type: TYPE_NORMAL
- en: '**square.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-15: The header file for the library'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now followed our style rule of one header per program file, as well as
    the style rule that says the interface to a library should be as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create a small test program for our library (see [Listing 17-16](#listing17-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '**square.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-16: A test program for the library'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don’t test all the members of the library (this will matter later).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the source files for our library, we need to turn them into
    an actual library. As mentioned previously, a library is a set of object files
    in an archive format, sort of like a *.zip* file, only without the compression.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we’ll create the *libsquare.a* file (the library itself) from
    the *square_float.o*, *square_int.o*, and *square_unsigned.o* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `make` program is quite intelligent and has the ability to update an archive’s
    components. For example, one of the components of *libsquare.a* is *square_int.o*.
    The following rule makes this a component of the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first line tells `make` that we are creating or updating the *square_int.o*
    component in the *libsquare.a* library. This component depends on the *square_int.o*
    object file.
  prefs: []
  type: TYPE_NORMAL
- en: The second line is the actual command to add the library. The `c` option tells
    `ar` to create the archive if it does not exist. The `r` causes `ar` to create
    or replace the *square_int.o* component in the archive. The `U` flag tells `ar`
    to run in nondeterministic mode, which stores the creation time of the file in
    the archive (we’ll discuss deterministic versus nondeterministic mode later in
    this chapter). Following that command is the name of the library (*libsquare.a*)
    and the name of the component to add or replace (*square_int.o*). The linker sets
    the naming convention. It must begin with *lib* and end with *.a* (more on this
    naming convention later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, with the following directives, we tell `make` what components should
    make up the *libsquare.a* library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines tell `make` what components to make *libsquare.a* out of.
    The third line, `ranlib libsquare.a`, tells `make` to run a program called `ranlib`
    on the archive after installing all the components to create a table of contents
    for the archive.
  prefs: []
  type: TYPE_NORMAL
- en: ranlib and Library Linking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The reason we use `ranlib` is due to some of the early linkers. Suppose that
    we had an archive with the components *a.o* (defines `a_funct`), *b.o* (defines
    `b_funct`), and *c.o* (defines `c_funct`) and that the program needed a function
    in *b.o*. The linker would open the archive and go through it serially, looking
    at each member to see whether it was needed. The decision process goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the list of undefined symbols (the program uses `b_funct`, so it’s undefined).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at *a.o*. Does it define a needed symbol? No. Do not load it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at *b.o*. Does it define a needed symbol? Yes. Load it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at *c.o*. Does it define a needed symbol? No. Do not load it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now suppose that *b.o* needed the `a_funct` function. The linker would not go
    back and reexamine the archive. It would continue on and look only at *c.o*. Since
    *c.o* does not define the symbol, it would not be loaded. The linker would reach
    the end of the archive and abort because it did not find an object file to satisfy
    the need for `a_funct`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way the linker worked, sometimes you needed to specify the same
    library two or three times. To solve that problem, a table of contents was added
    to the archive so the components could be loaded in random order (thus the name
    `ranlib`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the algorithm to load components is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the list of undefined symbols (the program uses `b_funct`, so it’s undefined).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we have an undefined symbol that’s in the table of contents?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, load it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until we have no more symbols that can be satisfied by this library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process solves the ordering problem because the table of contents makes
    everything accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command actually links the library with our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `-L.` flag tells the linker to search the current directory (`.`) for library
    files. Otherwise, only the system library directories are searched. The library
    itself is specified with the `-lsquare` directive. The linker looks for a library
    called *libsquare.a*, first in the current directory (because of the `-L.`) and
    then in the system directories.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-17](#listing17-17) shows the full makefile for this project.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-17: The full makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: Because our test program does not call `square_unsigned`, the *square_unsigned.o*
    module will not be linked into our program. (The test for `square_unsigned` was
    omitted to demonstrate how the linker will not link in unneeded object files.)
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic vs. Nondeterministic Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, if you run a `make` command, the resulting binary should be the same,
    no matter when the command was executed. For this reason, originally the library
    files did not store information on who created the components or when they were
    created.
  prefs: []
  type: TYPE_NORMAL
- en: However, that causes some difficulties for the `make` program. How can it determine
    whether the version of *square_int.o* in the archive is newer or older than the
    version you just compiled if the archive doesn’t store the modification date?
  prefs: []
  type: TYPE_NORMAL
- en: The `ar` command was modified to store this information. Because this feature
    broke legacy functionality, the `ar` maintainers decided to make storing this
    information optional. If you specify the `D` option, the modification times are
    not stored and you get a *deterministic archive* (the same binary every time).
    If you specify `U` for *nondeterministic*, you get a different binary each time,
    but one that the `make` program likes better. The default is `D`, the legacy format.
  prefs: []
  type: TYPE_NORMAL
- en: Weak Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve defined modules with functions and variables that are always loaded.
    In other words, if a module defines a `doIt` function, that’s the only definition
    of the function that’s loaded. An extension to the C language provided by GCC
    and most other compilers allows for *weak symbols*. A weak symbol tells the linker,
    “If no one else defines this symbol, use me.”
  prefs: []
  type: TYPE_NORMAL
- en: One example of where weak symbols are used is in the STM interrupt table. You
    *must* define functions to be called for every possible interrupt; the hardware
    requires it. So you have to write an interrupt route for interrupts that never
    occur. Since the function is never going to be called, that should make things
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: However, the STM firmware is designed around the idea that although interrupt
    routes for disabled interrupts *should* never be called, that doesn’t mean that
    they will *never* be called. The STM firmware defines interrupt handlers for all
    interrupts that brick the system. If they ever do get called, your system stops
    and you get a chance to go in with the debugger and try and figure out why.
  prefs: []
  type: TYPE_NORMAL
- en: The only way a default interrupt handler will be called is if you turn on interrupts
    and don’t provide your own interrupt handler. In that case the default interrupt
    knows something went wrong and just sits there waiting for you to figure out what.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STM interrupt handler from the USART2 interrupts is the function `USART2_IRQHandler`,
    which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, if we define our own, the one in the firmware library disappears, in
    spite of the fact that the other 40 or so interrupt functions in the same module
    will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this in action with our own code. In Listings 17-18 and 17-19 we have
    `sub1` and `sub2`, and `sub2` is defined twice (once in *main.c* and once in *sub.c*).
    When the linker looks at those two files, it says, “There are two `sub2` functions
    here. Should I raise an error? No. One of them is weak, and I can throw it away.”
    The `sub2` in *main.c* will get linked in and the one in *sub.c* will not.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first define a main program whose job is to call our two subroutines (see
    [Listing 17-18](#listing17-18)).
  prefs: []
  type: TYPE_NORMAL
- en: '**main.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-18: The main program to call the two subroutines'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 17-19](#listing17-19), we tell the compiler that `sub2` in *sub.c*
    is weak through the GCC extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**sub.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-19: Tells the compiler `sub2` is weak'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a header file, so let’s produce one (see [Listing 17-20](#listing17-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '**sub.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-20: The header file'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define our own `sub2` function in [Listing 17-21](#listing17-21).
  prefs: []
  type: TYPE_NORMAL
- en: '**sub2.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-21: Defining the `sub2` function'
  prefs: []
  type: TYPE_NORMAL
- en: If we link *main.c* and *sub.c*, the weak `sub2` will be linked in. If we link
    *main.c*, *sub.c*, and *sub2.c*, the non-weak version defined in *sub2.c* will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for cases like interrupt routines where you have to define one
    whether you use it or not. It allows you to supply a fallback or default version.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules enable you to split up large programs into manageable units. Good design
    means a large program does not need to have large parts. Multiple modules can
    be organized into a library. The advantage of a library is that it can include
    a large number of specialized modules, and the linker will only link in the needed
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Good programming is all about organizing information, and modules and libraries
    let you organize a huge programming mess into manageable-sized units.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a library to compute the area of geometric shapes (`rectangle_area`, `triangle_area`,
    and so on). Each function should be in its own object file, and all the area functions
    should be combined into a single library. Write a main program to perform a unit
    test on the functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite one of the serial output programs created in previous chapters so that
    all of the UART-related code is in a module of its own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test to see what happens when:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You define two weak symbols and one strong one.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You define two weak symbols and no strong one.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You define two strong symbols.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
