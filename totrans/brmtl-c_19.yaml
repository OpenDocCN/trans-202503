- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Modular Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: So far we’ve been working with small, simple one-file programs, which is fine
    if all you’re going to do is write sample programs for a book. In the real world,
    however, you’re probably going to encounter programs with more than 50 lines in
    them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理简单的小型单文件程序，如果你只是为了写书中的示例程序，这样是可以的。然而，在现实世界中，你可能会遇到包含超过50行代码的程序。
- en: The Linux kernel has 33,000 files and 28 million lines of code (and those numbers
    are increasing as you are reading this). You can’t deal with that amount of information
    without organizing it by dividing up the code into *modules*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核有33,000个文件和2800万行代码（而且这些数字还在不断增加，随着你阅读本文，它们会继续增加）。你不可能在没有将代码组织成*模块*的情况下处理这么大量的信息。
- en: 'A module ideally is a single file containing a collection of data and functions
    that does one thing well with minimum interaction with other modules. We’ve already
    used the STM HAL collection of modules earlier in this book, including the module
    containing the `HAL_Init` function. It does a lot of work internally, but we never
    see it. We see only a simple module that does one thing well: it initializes all
    the stuff needed to get the hardware to work.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的模块是一个包含数据和函数集合的单一文件，它能够做好一件事，并且与其他模块的交互最小化。我们之前在本书中使用过STM HAL模块集合，包括包含`HAL_Init`函数的模块。它在内部做了大量的工作，但我们从未看到它。我们只看到了一个做一件事的简单模块：它初始化所有需要的硬件，使其能够工作。
- en: Simple Modules
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单模块
- en: Let’s create a program that uses two files. The main program will be called
    *main.c* (see [Listing 17-1](#listing17-1)) and will call a function in the *func.c*
    file (see [Listing 17-2](#listing17-2)). We’ll use a makefile (see [Listing 17-3](#listing17-3))
    to compile the two files into one program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用两个文件的程序。主程序将被命名为*main.c*（见[清单 17-1](#listing17-1)），并将调用*func.c*文件中的一个函数（见[清单
    17-2](#listing17-2)）。我们将使用一个makefile（见[清单 17-3](#listing17-3)）将这两个文件编译成一个程序。
- en: '**main.c**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.c**'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 17-1: The main program'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-1：主程序
- en: The first thing to notice is the declaration of `funct` 1 in *main.c*. The`extern`keyword
    tells C that the function is defined in another file, named *func.c*.[Listing
    17-2](#listing17-2) contains that file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要注意的点是`funct`函数在*main.c*中的声明。`extern`关键字告诉C语言这个函数在另一个名为*func.c*的文件中定义。[清单
    17-2](#listing17-2)包含了该文件。
- en: '**func.c**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**func.c**'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 17-2: The file that defines the function'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-2：定义该函数的文件
- en: The `funct` function is defined 1 in the *func.c* file, and the makefile in
    [Listing 17-3](#listing17-3) handles the compilation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`funct`函数在*func.c*文件中定义，并且[清单 17-3](#listing17-3)中的makefile处理编译。'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 17-3: simple/Makefile*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-3：simple/Makefile*'
- en: The first line of the makefile tells `make` that the target `main` must be rebuilt
    if *main.c* or *func.c* changes. The second line tells `make` that when one of
    those files changes it should compile both files and use them to make the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: makefile的第一行告诉`make`，如果*main.c*或*func.c*发生变化，目标`main`必须重新构建。第二行告诉`make`，当其中一个文件发生变化时，它应该编译两个文件并用它们来生成程序。
- en: In this example, we’ve taken a function and a main program and put them in two
    different files. Then we told `make` to tell the compiler to combine them into
    one program. This is an oversimplified version of modular programming, but these
    basic principles are used with more complex programs with larger and more numerous
    modules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将一个函数和一个主程序放在了两个不同的文件中。然后我们告诉`make`让编译器将它们组合成一个程序。这是模块化编程的一个过于简化的版本，但这些基本原则在更复杂的程序中也有应用，尤其是那些包含更多和更复杂模块的程序。
- en: Problems with the Simple Module
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单模块的问题
- en: The previous example has a few problems. The first one is that the same information
    is repeated twice.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子有一些问题。第一个问题是相同的信息被重复了两次。
- en: 'In *main.c*, we have the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在*main.c*中，我们有以下内容：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And in *func.c*, we have this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在*func.c*中，我们有以下内容：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: which means that if we change one file, we must change the other.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们更改一个文件，我们必须更改另一个文件。
- en: 'Worse, *C does not check types across files*, which means it’s possible to
    have the lines:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，*C不检查跨文件的类型*，这意味着可能会有如下代码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'and:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 并且：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: in two different files. Suppose file *a.c* decides to set `flag` to zero. The
    program is going to deposit 32 bits worth of zero into `flag`, which is defined
    in file *b.c* as being only 16 bits long. What will actually happen is that 16
    bits will go into `flag`, and 16 bits will go into something else. The result
    is that unexpected, surprising, and difficult-to-debug things will happen to your
    program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的文件中。假设文件 *a.c* 决定将 `flag` 设置为零。程序将会把 32 位的零存储到 `flag` 中，而 `flag` 在文件 *b.c*
    中定义为只有 16 位长。实际发生的情况是，16 位将被存储到 `flag` 中，另 16 位将存储到其他地方。结果是，程序将发生意外的、令人惊讶的并且难以调试的问题。
- en: 'It is possible to declare a variable `extern` in a file and later declare it
    without the `extern`. C will check to make sure that the type in the `extern`
    definition matches the type in the actual declaration:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个文件中可以声明一个变量为 `extern`，并在之后的地方不再使用 `extern` 声明。C 会检查确保 `extern` 定义中的类型与实际声明中的类型匹配：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compiling this will result in an error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码将导致错误：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Concerning the second problem, suppose we want to use our external function
    `funct` in several different files. Do we want to add an `extern` statement to
    each of them? That would mean the definition of `funct` would be duplicated in
    many different places (and not checked by the compiler).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个问题，假设我们想要在多个文件中使用我们的外部函数 `funct`。我们是否希望在每个文件中都添加一个 `extern` 声明？那样的话，`funct`
    的定义将在多个地方重复出现（而且不会被编译器检查）。
- en: The solution is to create a header file to hold the `extern` definition. [Listing
    17-4](#listing17-4) contains this file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是创建一个头文件来保存 `extern` 定义。[清单 17-4](#listing17-4) 包含了这个文件。
- en: '**func.h**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**func.h**'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 17-4: The file that defines the function'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-4：定义函数的文件
- en: 'Along with the function definition 1, this file also contains *double inclusion
    protection*. The `#findef`/`#endif` pair prevents problems that might occur if
    your program does something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数定义 1，这个文件还包含了 *双重包含保护*。`#findef`/`#endif` 对可以防止程序出现类似以下的情况：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will cause the definitions in *func.h* to be defined twice, which is not
    a problem for `extern` declarations, but it will upset the compiler if multiple
    instances of `#define` are involved.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 *func.h* 中的定义被定义两次，这对于 `extern` 声明并不是问题，但如果涉及到多个 `#define` 实例，编译器会感到困扰。
- en: 'This example looks a bit silly, because in real programs, the problem is not
    so obvious. You may have a case where the code looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来有些傻，因为在实际程序中，问题并不是那么显而易见。你可能会遇到类似以下的情况：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: but the *database.h* file includes the *direct_io.h* file, which includes *func.h*,
    and the *service.h* file includes the *network.h* file, which includes *func.h*.
    You then get *func.h* included twice, even though you took the long way to do
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 *database.h* 文件包含了 *direct_io.h* 文件，后者又包含了 *func.h*，而 *service.h* 文件包含了 *network.h*
    文件，后者也包含了 *func.h*。你会发现 *func.h* 被包含了两次，尽管你是通过绕远路去做的。
- en: 'The format of the `#include` statement has changed slightly in these examples
    as well. Instead of:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中 `#include` 语句的格式略有变化，不再是：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'it’s this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样的：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The quotation marks indicate that the file to be included is a user-generated
    file. The compiler will search for it in the current directory instead of searching
    through the system files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 引号表示要包含的文件是用户生成的文件。编译器将会在当前目录中查找它，而不是通过系统文件进行查找。
- en: '[Listing 17-5](#listing17-5) contains an improved *main.c* that uses the include
    file to bring in the `extern` declarations.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-5](#listing17-5) 包含了改进版的 *main.c*，它使用包含文件来引入 `extern` 声明。'
- en: '**good/main.c**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**good/main.c**'
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 17-5: Improved *main.c*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-5：改进版 *main.c*
- en: '[Listing 17-6](#listing17-6) contains the improved *func.c* that includes *func.h*.
    The `extern` functions defined in *func.h* are not really needed to compile *func.c*,
    but by bringing them in, we make sure that the `extern` matches the actual function
    declaration.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-6](#listing17-6) 包含改进版的 *func.c*，该文件包括 *func.h*。`extern` 在 *func.h*
    中定义的函数实际上并不需要用来编译 *func.c*，但是通过引入它们，我们可以确保 `extern` 与实际的函数声明相匹配。'
- en: '**good/func.c**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**good/func.c**'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 17-6: Improved *func.c*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-6：改进版 *func.c*
- en: By including the *func.h* file twice, we’ve solved the problem that can occur
    when the `extern` does not match the actual declaration. Including it in *func.c*
    lets the compiler check the definition of the function, while in *main.c*, the
    inclusion provides us with the definition of the function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 *func.h* 文件包含两次，我们解决了 `extern` 与实际声明不匹配时可能发生的问题。在 *func.c* 中包含它可以让编译器检查函数定义，而在
    *main.c* 中包含它则为我们提供了函数的定义。
- en: Making the Module
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建模块
- en: The makefile for this program has changed as well (see [Listing 17-7](#listing17-7)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的makefile也发生了变化（见[Listing 17-7](#listing17-7)）。
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 17-7: Improved *Makefile*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 17-7: 改进版*Makefile*'
- en: The first line defines a macro called `CFLAGS`, which is a specific name used
    to compile C programs. The next line defines another macro called `OBJS` (there
    is nothing significant about that name), which contains a list of the objects
    we use to make our program. In this example, we’re going to compile *main.c* into
    the *main.o* object file and compile *func.c* into the *func.o* object file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个名为`CFLAGS`的宏，这是编译C程序时使用的特定名称。下一行定义了另一个名为`OBJS`的宏（这个名称没有特殊含义），它包含了我们用来生成程序的对象列表。在这个例子中，我们将编译*main.c*为*main.o*目标文件，并将*func.c*编译为*func.o*目标文件。
- en: 'We’re using a macro here simply to avoid having to write the list twice in
    the next rule 1, which tells `make` to create *main.o* from *main.c* and *func.h*.
    However, this rule isn’t followed by a rule telling `make` *how* to do this. When
    `make` doesn’t have a rule for something, it falls back to its list of built-in
    rules. When we create a *.o* (or .*obj*) file from a *.c* file, that built-in
    rule is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用宏是为了避免在下一个规则1中重复写出列表，这个规则告诉`make`从*main.c*和*func.h*创建*main.o*。然而，这个规则后面并没有跟着一个规则来告诉`make`*如何*做。当`make`没有规则时，它会回退到内置规则的列表中。当我们从*.c*文件创建*.o*（或.*obj*）文件时，那个内置规则是：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: where `CC` is the macro containing the name of the C compiler (in this case,
    `cc`, which is an alias for `gcc`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`CC`是包含C编译器名称的宏（在这里是`cc`，它是`gcc`的别名）。
- en: This example demonstrates a simple modular program, but the design pattern works
    when programs have additional modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个简单的模块化程序，但当程序有更多模块时，设计模式同样适用。
- en: What Makes Good Modules
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么构成好的模块
- en: 'The following list outlines some rules for making good modules:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表列出了制作好模块的一些规则：
- en: Each module should have a header file with the same name as the module. That
    file should contain the definitions of the public types, variables, and functions
    in that module (and nothing else).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块应该有一个与模块同名的头文件。该文件应包含该模块中公共类型、变量和函数的定义（并且没有其他内容）。
- en: Every module should include its own header file so that C can check to make
    sure the header file and the implementation match.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块应包含自己的头文件，以便C可以检查头文件和实现是否匹配。
- en: Modules should contain code used for a common purpose, and they should expose
    the minimum amount of information to the outside world. The information they do
    expose through `extern` declarations is global (seen by the entire program), and
    as described in the next section, sometimes that can be a problem.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块应包含用于共同目的的代码，并且它们应该向外界暴露最少的信息。它们通过`extern`声明暴露的信息是全局的（程序中的所有部分都可以看到），正如下一节所述，这有时会成为一个问题。
- en: Namespaces
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: One problem with C is that it does not have namespaces. In C++, for example,
    you can tell the compiler that all the symbols in a given module belong to the
    `db` namespace, so you can create a module with entries like `insert`, `delete`,
    and `query` that are visible to other people as `db::insert`, `db::delete`, and
    `db::query`, respectively.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的一个问题是它没有命名空间。例如，在C++中，你可以告诉编译器某个模块中的所有符号都属于`db`命名空间，这样你就可以创建一个模块，其中的条目如`insert`、`delete`和`query`，在其他人看来分别就是`db::insert`、`db::delete`和`db::query`。
- en: In C, if you define a public function called `Init`, no one else can define
    a function called `Init` in any module. If this does happen, the linker will complain
    about a duplicate symbol. Since there may be more than one item that needs initialization,
    that can be a problem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，如果你定义了一个名为`Init`的公共函数，其他人不能在任何模块中再定义一个名为`Init`的函数。如果发生这种情况，链接器会抱怨重复的符号。由于可能有多个项目需要初始化，这可能会成为一个问题。
- en: Most programmers solve this issue by adding a module prefix to the name of each
    public function, type, or variable. You can see this in action with the HAL library
    that gets added automatically to your Nucleo projects. For example, as shown in
    [Listing 17-8](#listing17-8), all the functions that manipulate the UART begin
    with the `UART_` prefix.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员通过为每个公共函数、类型或变量添加模块前缀来解决这个问题。你可以在Nucleo项目中自动添加的HAL库中看到这一点。例如，如[Listing
    17-8](#listing17-8)所示，所有操作UART的函数都以`UART_`前缀开头。
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 17-8: An excerpt from *stm32f0xx_hal_uart.h*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 17-8: *stm32f0xx_hal_uart.h*的摘录'
- en: The key point here is that a public symbol in the HAL library starts with `HAL_`,
    which makes it easy to determine whether a function belongs to the library. It
    also ensures that you don’t accidentally use a name already in use by the HAL
    library.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是 HAL 库中的公共符号以 `HAL_` 开头，这使得我们可以轻松判断一个函数是否属于该库。它还确保你不会不小心使用已经被 HAL 库占用的名称。
- en: Libraries
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库
- en: Listing every file that goes into a program is not too bad when there are fewer
    than 20 files. After that, it gets a little tedious, but it’s manageable until
    the number gets really big. The mainframe programs we’ve been writing use the
    standard C library functions. The C library has more than 1,600 files. Fortunately,
    we don’t need to list them all when we compile a program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中包含的文件少于 20 个时，列出每个文件还不算太麻烦。但一旦文件数量超过 20 个，就会显得有些繁琐，不过还是能管理的，直到数量变得非常庞大。我们一直在编写的主机程序使用的是标准
    C 库函数。C 库有超过 1,600 个文件。幸运的是，我们在编译程序时不需要列出所有这些文件。
- en: The standard C library is a file named *libc.a*, and it’s automatically loaded
    when your program is linked. The library is a collection of object files in a
    simple archive format (hence the *.a* extension).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 C 库是一个名为 *libc.a* 的文件，在程序链接时会自动加载。这个库是由多个目标文件组成的，采用简单的归档格式（因此有 *.a* 后缀）。
- en: Let’s create our own library containing several modules to square various types
    of numbers. [Listing 17-9](#listing17-9) shows a function to square a floating-point
    number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含多个模块的库，用来计算不同类型数字的平方。[列表 17-9](#listing17-9) 展示了一个计算浮点数平方的函数。
- en: '**square_float.c**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_float.c**'
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 17-9: A function to square a floating-point number'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-9：一个用于计算浮点数平方的函数
- en: '[Listing 17-10](#listing17-10) is the header for that module.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-10](#listing17-10) 是该模块的头文件。'
- en: '**square_float.h**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_float.h**'
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 17-10: The header file for the *square_float.c* module'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-10：*square_float.c* 模块的头文件
- en: '[Listing 17-11](#listing17-11) defines a function to square an integer.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-11](#listing17-11) 定义了一个用于计算整数平方的函数。'
- en: '**square_int.c**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_int.c**'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 17-11: A function to square an integer'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-11：一个用于计算整数平方的函数
- en: '[Listing 17-12](#listing17-12) defines its header file.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-12](#listing17-12) 定义了它的头文件。'
- en: '**square_int.h**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_int.h**'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 17-12: The header file for *square_int.c*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-12：*square_int.c* 的头文件
- en: Next, [Listing 17-13](#listing17-13) is a similar function to square an unsigned
    integer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[列表 17-13](#listing17-13) 是一个类似的函数，用于计算无符号整数的平方。
- en: '**square_unsigned.c**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_unsigned.c**'
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 17-13: A function to square an unsigned integer'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-13：一个用于计算无符号整数平方的函数
- en: '[Listing 17-14](#listing17-14) defines the header file.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-14](#listing17-14) 定义了该头文件。'
- en: '**square_unsigned.h**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_unsigned.h**'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 17-14: The header file for *square_unsigned.c*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-14：*square_unsigned.c* 的头文件
- en: We are going to put our three functions in a library. If users want to use this
    library, they will have to include all those header files. That’s a lot of work.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这三个函数放入一个库中。如果用户想使用这个库，他们需要包含所有这些头文件。这将是一项繁重的工作。
- en: To make things easier, we’ll create a header file called *square.h* for the
    library. This file consolidates the individual headers for each of the preceding
    library components (modules). As a result, people who use this library just need
    to include *square.h* (see [Listing 17-15](#listing17-15)) instead of a bunch
    of individual headers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将为这个库创建一个名为 *square.h* 的头文件。这个文件整合了前面各个库组件（模块）的独立头文件。因此，使用这个库的人只需要包含
    *square.h*（请参见 [列表 17-15](#listing17-15)），而不需要包含一堆单独的头文件。
- en: '**square.h**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**square.h**'
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 17-15: The header file for the library'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-15：库的头文件
- en: We’ve now followed our style rule of one header per program file, as well as
    the style rule that says the interface to a library should be as simple as possible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在遵循了每个程序文件一个头文件的风格规则，以及库接口应尽可能简单的风格规则。
- en: Next, let’s create a small test program for our library (see [Listing 17-16](#listing17-16)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为库创建一个小的测试程序（请参见 [列表 17-16](#listing17-16)）。
- en: '**square.c**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**square.c**'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 17-16: A test program for the library'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-16：库的测试程序
- en: Notice that we don’t test all the members of the library (this will matter later).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们并没有测试库中的所有成员（这一点稍后会很重要）。
- en: Now that we have the source files for our library, we need to turn them into
    an actual library. As mentioned previously, a library is a set of object files
    in an archive format, sort of like a *.zip* file, only without the compression.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了库的源文件，接下来需要将它们转化为实际的库。如前所述，库是一个归档格式的目标文件集合，类似于一个 *.zip* 文件，只不过没有压缩。
- en: In this case, we’ll create the *libsquare.a* file (the library itself) from
    the *square_float.o*, *square_int.o*, and *square_unsigned.o* files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将通过 *square_float.o*、*square_int.o* 和 *square_unsigned.o* 文件创建 *libsquare.a*
    文件（即库文件本身）。
- en: 'The `make` program is quite intelligent and has the ability to update an archive’s
    components. For example, one of the components of *libsquare.a* is *square_int.o*.
    The following rule makes this a component of the library:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 程序非常智能，能够更新归档文件的组件。例如，*libsquare.a* 的一个组件是 *square_int.o*。以下规则将其作为库的一个组件：'
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first line tells `make` that we are creating or updating the *square_int.o*
    component in the *libsquare.a* library. This component depends on the *square_int.o*
    object file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉 `make` 我们正在创建或更新 *libsquare.a* 库中的 *square_int.o* 组件。此组件依赖于 *square_int.o*
    目标文件。
- en: The second line is the actual command to add the library. The `c` option tells
    `ar` to create the archive if it does not exist. The `r` causes `ar` to create
    or replace the *square_int.o* component in the archive. The `U` flag tells `ar`
    to run in nondeterministic mode, which stores the creation time of the file in
    the archive (we’ll discuss deterministic versus nondeterministic mode later in
    this chapter). Following that command is the name of the library (*libsquare.a*)
    and the name of the component to add or replace (*square_int.o*). The linker sets
    the naming convention. It must begin with *lib* and end with *.a* (more on this
    naming convention later).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是实际添加库的命令。`c` 选项告诉 `ar` 在归档文件不存在时创建它。`r` 使得 `ar` 在归档文件中创建或替换 *square_int.o*
    组件。`U` 标志告诉 `ar` 以非确定性模式运行，这样会将文件的创建时间存储在归档文件中（我们将在本章后面讨论确定性模式和非确定性模式）。该命令之后是库的名称
    (*libsquare.a*) 和要添加或替换的组件名称 (*square_int.o*)。链接器设置了命名规范，库文件名必须以 *lib* 开头，以 *.a*
    结尾（更多关于命名规范的内容将在后面讨论）。
- en: 'Next, with the following directives, we tell `make` what components should
    make up the *libsquare.a* library:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下指令，我们告诉 `make` 应该用哪些组件来构成 *libsquare.a* 库：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first two lines tell `make` what components to make *libsquare.a* out of.
    The third line, `ranlib libsquare.a`, tells `make` to run a program called `ranlib`
    on the archive after installing all the components to create a table of contents
    for the archive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行告诉 `make` 用哪些组件来创建 *libsquare.a*。第三行，`ranlib libsquare.a`，告诉 `make` 在安装完所有组件后运行名为
    `ranlib` 的程序，生成归档文件的目录表。
- en: ranlib and Library Linking
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ranlib 和库链接
- en: 'The reason we use `ranlib` is due to some of the early linkers. Suppose that
    we had an archive with the components *a.o* (defines `a_funct`), *b.o* (defines
    `b_funct`), and *c.o* (defines `c_funct`) and that the program needed a function
    in *b.o*. The linker would open the archive and go through it serially, looking
    at each member to see whether it was needed. The decision process goes like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ranlib` 的原因是早期的链接器。假设我们有一个包含 *a.o*（定义了 `a_funct`）、*b.o*（定义了 `b_funct`）和
    *c.o*（定义了 `c_funct`）的归档文件，而程序需要 *b.o* 中的某个函数。链接器将打开归档文件，并按顺序检查每个成员是否需要，决策过程如下：
- en: Look at the list of undefined symbols (the program uses `b_funct`, so it’s undefined).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看未定义符号的列表（程序使用了 `b_funct`，所以它未定义）。
- en: Open the archive.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开归档文件。
- en: Look at *a.o*. Does it define a needed symbol? No. Do not load it.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看 *a.o*。它定义了需要的符号吗？没有。不要加载它。
- en: Look at *b.o*. Does it define a needed symbol? Yes. Load it.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看 *b.o*。它定义了需要的符号吗？是的。加载它。
- en: Look at *c.o*. Does it define a needed symbol? No. Do not load it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看 *c.o*。它定义了需要的符号吗？没有。不要加载它。
- en: Now suppose that *b.o* needed the `a_funct` function. The linker would not go
    back and reexamine the archive. It would continue on and look only at *c.o*. Since
    *c.o* does not define the symbol, it would not be loaded. The linker would reach
    the end of the archive and abort because it did not find an object file to satisfy
    the need for `a_funct`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 *b.o* 需要 `a_funct` 函数。链接器不会回过头重新检查归档文件，而是继续查看 *c.o*。由于 *c.o* 没有定义该符号，因此不会被加载。链接器会到达归档文件的末尾并中止，因为它没有找到满足
    `a_funct` 需求的目标文件。
- en: Because of the way the linker worked, sometimes you needed to specify the same
    library two or three times. To solve that problem, a table of contents was added
    to the archive so the components could be loaded in random order (thus the name
    `ranlib`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于链接器的工作方式，有时你需要指定同一个库两次或三次。为了解决这个问题，归档文件中增加了目录表，以便组件可以随机顺序加载（因此有了 `ranlib`
    的名字）。
- en: 'Now the algorithm to load components is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载组件的算法如下：
- en: Look at the list of undefined symbols (the program uses `b_funct`, so it’s undefined).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看未定义符号的列表（程序使用了`b_funct`，所以它是未定义的）。
- en: Open the archive.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开档案。
- en: Do we have an undefined symbol that’s in the table of contents?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否有一个未定义的符号在目录中？
- en: If so, load it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有，加载它。
- en: Repeat until we have no more symbols that can be satisfied by this library.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到我们没有更多可以由此库满足的符号。
- en: This process solves the ordering problem because the table of contents makes
    everything accessible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程解决了排序问题，因为目录使得一切都能被访问。
- en: 'The following command actually links the library with our program:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令实际上将库与我们的程序链接在一起：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `-L.` flag tells the linker to search the current directory (`.`) for library
    files. Otherwise, only the system library directories are searched. The library
    itself is specified with the `-lsquare` directive. The linker looks for a library
    called *libsquare.a*, first in the current directory (because of the `-L.`) and
    then in the system directories.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L.`选项告诉链接器在当前目录（` .`）中查找库文件。否则，它只会搜索系统库目录。库本身通过`-lsquare`指令来指定。链接器首先在当前目录（因为有`-L.`）查找名为*libsquare.a*的库，然后在系统目录中查找。'
- en: '[Listing 17-17](#listing17-17) shows the full makefile for this project.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单17-17](#listing17-17)显示了这个项目的完整makefile。'
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 17-17: The full makefile*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单17-17：完整的makefile*'
- en: Because our test program does not call `square_unsigned`, the *square_unsigned.o*
    module will not be linked into our program. (The test for `square_unsigned` was
    omitted to demonstrate how the linker will not link in unneeded object files.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的测试程序没有调用`square_unsigned`，所以*square_unsigned.o*模块将不会被链接到我们的程序中。（为了演示链接器如何不链接不需要的目标文件，省略了对`square_unsigned`的测试。）
- en: Deterministic vs. Nondeterministic Libraries
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定性库与非确定性库
- en: Ideally, if you run a `make` command, the resulting binary should be the same,
    no matter when the command was executed. For this reason, originally the library
    files did not store information on who created the components or when they were
    created.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，如果你运行`make`命令，生成的二进制文件应该是相同的，无论命令在什么时候执行。出于这个原因，最初库文件并没有存储有关谁创建了组件或何时创建的信息。
- en: However, that causes some difficulties for the `make` program. How can it determine
    whether the version of *square_int.o* in the archive is newer or older than the
    version you just compiled if the archive doesn’t store the modification date?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这给`make`程序带来了一些困难。如果档案不存储修改日期，`make`程序如何确定档案中的*square_int.o*版本是比你刚编译的版本更新还是更旧呢？
- en: The `ar` command was modified to store this information. Because this feature
    broke legacy functionality, the `ar` maintainers decided to make storing this
    information optional. If you specify the `D` option, the modification times are
    not stored and you get a *deterministic archive* (the same binary every time).
    If you specify `U` for *nondeterministic*, you get a different binary each time,
    but one that the `make` program likes better. The default is `D`, the legacy format.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ar`命令被修改以存储这些信息。因为这个功能破坏了传统功能，`ar`的维护者决定让存储这些信息成为可选项。如果你指定`D`选项，修改时间不会被存储，并且你将得到一个*确定性档案*（每次都是相同的二进制文件）。如果你指定`U`选项表示*非确定性*，你每次都会得到一个不同的二进制文件，但这是`make`程序更喜欢的。默认值是`D`，即传统格式。'
- en: Weak Symbols
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱符号
- en: So far, we’ve defined modules with functions and variables that are always loaded.
    In other words, if a module defines a `doIt` function, that’s the only definition
    of the function that’s loaded. An extension to the C language provided by GCC
    and most other compilers allows for *weak symbols*. A weak symbol tells the linker,
    “If no one else defines this symbol, use me.”
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了总是被加载的具有函数和变量的模块。换句话说，如果一个模块定义了一个`doIt`函数，那就是唯一被加载的函数定义。GCC和大多数其他编译器提供的C语言扩展允许使用*弱符号*。弱符号告诉链接器，“如果没有其他人定义这个符号，就使用我。”
- en: One example of where weak symbols are used is in the STM interrupt table. You
    *must* define functions to be called for every possible interrupt; the hardware
    requires it. So you have to write an interrupt route for interrupts that never
    occur. Since the function is never going to be called, that should make things
    simple.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用弱符号的例子是STM中断表。你*必须*为每个可能的中断定义要调用的函数；硬件要求这样做。因此，你必须为那些从不发生的中断编写中断处理程序。由于该函数永远不会被调用，这应该让事情变得简单。
- en: However, the STM firmware is designed around the idea that although interrupt
    routes for disabled interrupts *should* never be called, that doesn’t mean that
    they will *never* be called. The STM firmware defines interrupt handlers for all
    interrupts that brick the system. If they ever do get called, your system stops
    and you get a chance to go in with the debugger and try and figure out why.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，STM固件的设计理念是，尽管禁用中断的中断路由*应该*永远不会被调用，但这并不意味着它们*永远*不会被调用。STM固件为所有会让系统崩溃的中断定义了中断处理程序。如果它们真的被调用，您的系统会停止，您有机会使用调试器进行分析并尝试找出原因。
- en: The only way a default interrupt handler will be called is if you turn on interrupts
    and don’t provide your own interrupt handler. In that case the default interrupt
    knows something went wrong and just sits there waiting for you to figure out what.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的方式使默认的中断处理程序被调用是如果您开启了中断并且没有提供自己的中断处理程序。在这种情况下，默认的中断处理程序会知道出了问题，并且静静地等待您来找出问题所在。
- en: 'The STM interrupt handler from the USART2 interrupts is the function `USART2_IRQHandler`,
    which is defined as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: STM的USART2中断处理程序是`USART2_IRQHandler`，它的定义如下：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, if we define our own, the one in the firmware library disappears, in
    spite of the fact that the other 40 or so interrupt functions in the same module
    will be loaded.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们自己定义了该函数，固件库中的`sub2`函数将消失，尽管同一模块中的其他约40个中断函数仍然会被加载。
- en: Let’s see this in action with our own code. In Listings 17-18 and 17-19 we have
    `sub1` and `sub2`, and `sub2` is defined twice (once in *main.c* and once in *sub.c*).
    When the linker looks at those two files, it says, “There are two `sub2` functions
    here. Should I raise an error? No. One of them is weak, and I can throw it away.”
    The `sub2` in *main.c* will get linked in and the one in *sub.c* will not.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过自己的代码来看这个过程。在清单 17-18 和 17-19 中，我们有`sub1`和`sub2`，而`sub2`被定义了两次（一次在*main.c*中，另一次在*sub.c*中）。当链接器查看这两个文件时，它会说：“这里有两个`sub2`函数。我应该抛出错误吗？不，一个是弱符号，我可以把它丢弃。”在*main.c*中的`sub2`将被链接，而在*sub.c*中的`sub2`则不会。
- en: Let’s first define a main program whose job is to call our two subroutines (see
    [Listing 17-18](#listing17-18)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义一个主程序，它的任务是调用我们的两个子例程（参见[清单 17-18](#listing17-18)）。
- en: '**main.c**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.c**'
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 17-18: The main program to call the two subroutines'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-18：调用两个子例程的主程序
- en: In [Listing 17-19](#listing17-19), we tell the compiler that `sub2` in *sub.c*
    is weak through the GCC extension.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 17-19](#listing17-19)中，我们通过GCC扩展告诉编译器`sub2`在*sub.c*中是弱符号。
- en: '**sub.c**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**sub.c**'
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 17-19: Tells the compiler `sub2` is weak'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-19：告诉编译器`sub2`是弱符号
- en: Next, we need a header file, so let’s produce one (see [Listing 17-20](#listing17-20)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个头文件，因此让我们创建一个（参见[清单 17-20](#listing17-20)）。
- en: '**sub.h**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**sub.h**'
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 17-20: The header file'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-20：头文件
- en: Finally, we define our own `sub2` function in [Listing 17-21](#listing17-21).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在[清单 17-21](#listing17-21)中定义了我们自己的`sub2`函数。
- en: '**sub2.c**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**sub2.c**'
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 17-21: Defining the `sub2` function'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-21：定义`sub2`函数
- en: If we link *main.c* and *sub.c*, the weak `sub2` will be linked in. If we link
    *main.c*, *sub.c*, and *sub2.c*, the non-weak version defined in *sub2.c* will
    be used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们链接*main.c*和*sub.c*，弱符号`sub2`将被链接进来。如果我们链接*main.c*、*sub.c*和*sub2.c*，则会使用在*sub2.c*中定义的非弱版本。
- en: This is useful for cases like interrupt routines where you have to define one
    whether you use it or not. It allows you to supply a fallback or default version.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于像中断例程这样的情况非常有用，您必须定义一个，无论是否使用它。这让您能够提供一个回退或默认版本。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Modules enable you to split up large programs into manageable units. Good design
    means a large program does not need to have large parts. Multiple modules can
    be organized into a library. The advantage of a library is that it can include
    a large number of specialized modules, and the linker will only link in the needed
    ones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模块使您能够将大型程序拆分成可管理的单元。良好的设计意味着大型程序不需要包含庞大的部分。多个模块可以组织成一个库。库的优势在于它可以包含大量的专用模块，链接器只会链接需要的模块。
- en: Good programming is all about organizing information, and modules and libraries
    let you organize a huge programming mess into manageable-sized units.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的编程就是组织信息，而模块和库使您能够将庞大的程序乱象整理成可管理的小单元。
- en: Programming Problems
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程问题
- en: Write a library to compute the area of geometric shapes (`rectangle_area`, `triangle_area`,
    and so on). Each function should be in its own object file, and all the area functions
    should be combined into a single library. Write a main program to perform a unit
    test on the functions.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个库来计算几何形状的面积（`rectangle_area`、`triangle_area` 等）。每个函数应在自己的目标文件中，所有面积计算函数应合并成一个单独的库。编写一个主程序对这些函数进行单元测试。
- en: Rewrite one of the serial output programs created in previous chapters so that
    all of the UART-related code is in a module of its own.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写前面章节中创建的一个串行输出程序，使所有与UART相关的代码都在一个独立的模块中。
- en: 'Test to see what happens when:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下发生了什么，当：
- en: You define two weak symbols and one strong one.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了两个弱符号和一个强符号。
- en: You define two weak symbols and no strong one.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了两个弱符号，没有强符号。
- en: You define two strong symbols.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了两个强符号。
