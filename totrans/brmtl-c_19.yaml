- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modular Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: So far we’ve been working with small, simple one-file programs, which is fine
    if all you’re going to do is write sample programs for a book. In the real world,
    however, you’re probably going to encounter programs with more than 50 lines in
    them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel has 33,000 files and 28 million lines of code (and those numbers
    are increasing as you are reading this). You can’t deal with that amount of information
    without organizing it by dividing up the code into *modules*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'A module ideally is a single file containing a collection of data and functions
    that does one thing well with minimum interaction with other modules. We’ve already
    used the STM HAL collection of modules earlier in this book, including the module
    containing the `HAL_Init` function. It does a lot of work internally, but we never
    see it. We see only a simple module that does one thing well: it initializes all
    the stuff needed to get the hardware to work.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Simple Modules
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a program that uses two files. The main program will be called
    *main.c* (see [Listing 17-1](#listing17-1)) and will call a function in the *func.c*
    file (see [Listing 17-2](#listing17-2)). We’ll use a makefile (see [Listing 17-3](#listing17-3))
    to compile the two files into one program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**main.c**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 17-1: The main program'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is the declaration of `funct` 1 in *main.c*. The`extern`keyword
    tells C that the function is defined in another file, named *func.c*.[Listing
    17-2](#listing17-2) contains that file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**func.c**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 17-2: The file that defines the function'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The `funct` function is defined 1 in the *func.c* file, and the makefile in
    [Listing 17-3](#listing17-3) handles the compilation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 17-3: simple/Makefile*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the makefile tells `make` that the target `main` must be rebuilt
    if *main.c* or *func.c* changes. The second line tells `make` that when one of
    those files changes it should compile both files and use them to make the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ve taken a function and a main program and put them in two
    different files. Then we told `make` to tell the compiler to combine them into
    one program. This is an oversimplified version of modular programming, but these
    basic principles are used with more complex programs with larger and more numerous
    modules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Problems with the Simple Module
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous example has a few problems. The first one is that the same information
    is repeated twice.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In *main.c*, we have the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And in *func.c*, we have this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: which means that if we change one file, we must change the other.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Worse, *C does not check types across files*, which means it’s possible to
    have the lines:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'and:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: in two different files. Suppose file *a.c* decides to set `flag` to zero. The
    program is going to deposit 32 bits worth of zero into `flag`, which is defined
    in file *b.c* as being only 16 bits long. What will actually happen is that 16
    bits will go into `flag`, and 16 bits will go into something else. The result
    is that unexpected, surprising, and difficult-to-debug things will happen to your
    program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的文件中。假设文件 *a.c* 决定将 `flag` 设置为零。程序将会把 32 位的零存储到 `flag` 中，而 `flag` 在文件 *b.c*
    中定义为只有 16 位长。实际发生的情况是，16 位将被存储到 `flag` 中，另 16 位将存储到其他地方。结果是，程序将发生意外的、令人惊讶的并且难以调试的问题。
- en: 'It is possible to declare a variable `extern` in a file and later declare it
    without the `extern`. C will check to make sure that the type in the `extern`
    definition matches the type in the actual declaration:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个文件中可以声明一个变量为 `extern`，并在之后的地方不再使用 `extern` 声明。C 会检查确保 `extern` 定义中的类型与实际声明中的类型匹配：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compiling this will result in an error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码将导致错误：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Concerning the second problem, suppose we want to use our external function
    `funct` in several different files. Do we want to add an `extern` statement to
    each of them? That would mean the definition of `funct` would be duplicated in
    many different places (and not checked by the compiler).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个问题，假设我们想要在多个文件中使用我们的外部函数 `funct`。我们是否希望在每个文件中都添加一个 `extern` 声明？那样的话，`funct`
    的定义将在多个地方重复出现（而且不会被编译器检查）。
- en: The solution is to create a header file to hold the `extern` definition. [Listing
    17-4](#listing17-4) contains this file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是创建一个头文件来保存 `extern` 定义。[清单 17-4](#listing17-4) 包含了这个文件。
- en: '**func.h**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**func.h**'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 17-4: The file that defines the function'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-4：定义函数的文件
- en: 'Along with the function definition 1, this file also contains *double inclusion
    protection*. The `#findef`/`#endif` pair prevents problems that might occur if
    your program does something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数定义 1，这个文件还包含了 *双重包含保护*。`#findef`/`#endif` 对可以防止程序出现类似以下的情况：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will cause the definitions in *func.h* to be defined twice, which is not
    a problem for `extern` declarations, but it will upset the compiler if multiple
    instances of `#define` are involved.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 *func.h* 中的定义被定义两次，这对于 `extern` 声明并不是问题，但如果涉及到多个 `#define` 实例，编译器会感到困扰。
- en: 'This example looks a bit silly, because in real programs, the problem is not
    so obvious. You may have a case where the code looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来有些傻，因为在实际程序中，问题并不是那么显而易见。你可能会遇到类似以下的情况：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: but the *database.h* file includes the *direct_io.h* file, which includes *func.h*,
    and the *service.h* file includes the *network.h* file, which includes *func.h*.
    You then get *func.h* included twice, even though you took the long way to do
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 *database.h* 文件包含了 *direct_io.h* 文件，后者又包含了 *func.h*，而 *service.h* 文件包含了 *network.h*
    文件，后者也包含了 *func.h*。你会发现 *func.h* 被包含了两次，尽管你是通过绕远路去做的。
- en: 'The format of the `#include` statement has changed slightly in these examples
    as well. Instead of:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中 `#include` 语句的格式略有变化，不再是：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'it’s this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样的：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The quotation marks indicate that the file to be included is a user-generated
    file. The compiler will search for it in the current directory instead of searching
    through the system files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 引号表示要包含的文件是用户生成的文件。编译器将会在当前目录中查找它，而不是通过系统文件进行查找。
- en: '[Listing 17-5](#listing17-5) contains an improved *main.c* that uses the include
    file to bring in the `extern` declarations.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-5](#listing17-5) 包含了改进版的 *main.c*，它使用包含文件来引入 `extern` 声明。'
- en: '**good/main.c**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**good/main.c**'
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 17-5: Improved *main.c*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-5：改进版 *main.c*
- en: '[Listing 17-6](#listing17-6) contains the improved *func.c* that includes *func.h*.
    The `extern` functions defined in *func.h* are not really needed to compile *func.c*,
    but by bringing them in, we make sure that the `extern` matches the actual function
    declaration.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-6](#listing17-6) 包含改进版的 *func.c*，该文件包括 *func.h*。`extern` 在 *func.h*
    中定义的函数实际上并不需要用来编译 *func.c*，但是通过引入它们，我们可以确保 `extern` 与实际的函数声明相匹配。'
- en: '**good/func.c**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**good/func.c**'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 17-6: Improved *func.c*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 17-6：改进版 *func.c*
- en: By including the *func.h* file twice, we’ve solved the problem that can occur
    when the `extern` does not match the actual declaration. Including it in *func.c*
    lets the compiler check the definition of the function, while in *main.c*, the
    inclusion provides us with the definition of the function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 *func.h* 文件包含两次，我们解决了 `extern` 与实际声明不匹配时可能发生的问题。在 *func.c* 中包含它可以让编译器检查函数定义，而在
    *main.c* 中包含它则为我们提供了函数的定义。
- en: Making the Module
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The makefile for this program has changed as well (see [Listing 17-7](#listing17-7)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 17-7: Improved *Makefile*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The first line defines a macro called `CFLAGS`, which is a specific name used
    to compile C programs. The next line defines another macro called `OBJS` (there
    is nothing significant about that name), which contains a list of the objects
    we use to make our program. In this example, we’re going to compile *main.c* into
    the *main.o* object file and compile *func.c* into the *func.o* object file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re using a macro here simply to avoid having to write the list twice in
    the next rule 1, which tells `make` to create *main.o* from *main.c* and *func.h*.
    However, this rule isn’t followed by a rule telling `make` *how* to do this. When
    `make` doesn’t have a rule for something, it falls back to its list of built-in
    rules. When we create a *.o* (or .*obj*) file from a *.c* file, that built-in
    rule is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: where `CC` is the macro containing the name of the C compiler (in this case,
    `cc`, which is an alias for `gcc`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates a simple modular program, but the design pattern works
    when programs have additional modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: What Makes Good Modules
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following list outlines some rules for making good modules:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Each module should have a header file with the same name as the module. That
    file should contain the definitions of the public types, variables, and functions
    in that module (and nothing else).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every module should include its own header file so that C can check to make
    sure the header file and the implementation match.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules should contain code used for a common purpose, and they should expose
    the minimum amount of information to the outside world. The information they do
    expose through `extern` declarations is global (seen by the entire program), and
    as described in the next section, sometimes that can be a problem.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One problem with C is that it does not have namespaces. In C++, for example,
    you can tell the compiler that all the symbols in a given module belong to the
    `db` namespace, so you can create a module with entries like `insert`, `delete`,
    and `query` that are visible to other people as `db::insert`, `db::delete`, and
    `db::query`, respectively.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In C, if you define a public function called `Init`, no one else can define
    a function called `Init` in any module. If this does happen, the linker will complain
    about a duplicate symbol. Since there may be more than one item that needs initialization,
    that can be a problem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Most programmers solve this issue by adding a module prefix to the name of each
    public function, type, or variable. You can see this in action with the HAL library
    that gets added automatically to your Nucleo projects. For example, as shown in
    [Listing 17-8](#listing17-8), all the functions that manipulate the UART begin
    with the `UART_` prefix.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 17-8: An excerpt from *stm32f0xx_hal_uart.h*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that a public symbol in the HAL library starts with `HAL_`,
    which makes it easy to determine whether a function belongs to the library. It
    also ensures that you don’t accidentally use a name already in use by the HAL
    library.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是 HAL 库中的公共符号以 `HAL_` 开头，这使得我们可以轻松判断一个函数是否属于该库。它还确保你不会不小心使用已经被 HAL 库占用的名称。
- en: Libraries
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库
- en: Listing every file that goes into a program is not too bad when there are fewer
    than 20 files. After that, it gets a little tedious, but it’s manageable until
    the number gets really big. The mainframe programs we’ve been writing use the
    standard C library functions. The C library has more than 1,600 files. Fortunately,
    we don’t need to list them all when we compile a program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中包含的文件少于 20 个时，列出每个文件还不算太麻烦。但一旦文件数量超过 20 个，就会显得有些繁琐，不过还是能管理的，直到数量变得非常庞大。我们一直在编写的主机程序使用的是标准
    C 库函数。C 库有超过 1,600 个文件。幸运的是，我们在编译程序时不需要列出所有这些文件。
- en: The standard C library is a file named *libc.a*, and it’s automatically loaded
    when your program is linked. The library is a collection of object files in a
    simple archive format (hence the *.a* extension).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 C 库是一个名为 *libc.a* 的文件，在程序链接时会自动加载。这个库是由多个目标文件组成的，采用简单的归档格式（因此有 *.a* 后缀）。
- en: Let’s create our own library containing several modules to square various types
    of numbers. [Listing 17-9](#listing17-9) shows a function to square a floating-point
    number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含多个模块的库，用来计算不同类型数字的平方。[列表 17-9](#listing17-9) 展示了一个计算浮点数平方的函数。
- en: '**square_float.c**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_float.c**'
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 17-9: A function to square a floating-point number'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-9：一个用于计算浮点数平方的函数
- en: '[Listing 17-10](#listing17-10) is the header for that module.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-10](#listing17-10) 是该模块的头文件。'
- en: '**square_float.h**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_float.h**'
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 17-10: The header file for the *square_float.c* module'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-10：*square_float.c* 模块的头文件
- en: '[Listing 17-11](#listing17-11) defines a function to square an integer.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-11](#listing17-11) 定义了一个用于计算整数平方的函数。'
- en: '**square_int.c**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_int.c**'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 17-11: A function to square an integer'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-11：一个用于计算整数平方的函数
- en: '[Listing 17-12](#listing17-12) defines its header file.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-12](#listing17-12) 定义了它的头文件。'
- en: '**square_int.h**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_int.h**'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 17-12: The header file for *square_int.c*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-12：*square_int.c* 的头文件
- en: Next, [Listing 17-13](#listing17-13) is a similar function to square an unsigned
    integer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[列表 17-13](#listing17-13) 是一个类似的函数，用于计算无符号整数的平方。
- en: '**square_unsigned.c**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_unsigned.c**'
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 17-13: A function to square an unsigned integer'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-13：一个用于计算无符号整数平方的函数
- en: '[Listing 17-14](#listing17-14) defines the header file.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-14](#listing17-14) 定义了该头文件。'
- en: '**square_unsigned.h**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**square_unsigned.h**'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 17-14: The header file for *square_unsigned.c*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-14：*square_unsigned.c* 的头文件
- en: We are going to put our three functions in a library. If users want to use this
    library, they will have to include all those header files. That’s a lot of work.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这三个函数放入一个库中。如果用户想使用这个库，他们需要包含所有这些头文件。这将是一项繁重的工作。
- en: To make things easier, we’ll create a header file called *square.h* for the
    library. This file consolidates the individual headers for each of the preceding
    library components (modules). As a result, people who use this library just need
    to include *square.h* (see [Listing 17-15](#listing17-15)) instead of a bunch
    of individual headers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将为这个库创建一个名为 *square.h* 的头文件。这个文件整合了前面各个库组件（模块）的独立头文件。因此，使用这个库的人只需要包含
    *square.h*（请参见 [列表 17-15](#listing17-15)），而不需要包含一堆单独的头文件。
- en: '**square.h**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**square.h**'
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 17-15: The header file for the library'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-15：库的头文件
- en: We’ve now followed our style rule of one header per program file, as well as
    the style rule that says the interface to a library should be as simple as possible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在遵循了每个程序文件一个头文件的风格规则，以及库接口应尽可能简单的风格规则。
- en: Next, let’s create a small test program for our library (see [Listing 17-16](#listing17-16)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为库创建一个小的测试程序（请参见 [列表 17-16](#listing17-16)）。
- en: '**square.c**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**square.c**'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 17-16: A test program for the library'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17-16：库的测试程序
- en: Notice that we don’t test all the members of the library (this will matter later).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们并没有测试库中的所有成员（这一点稍后会很重要）。
- en: Now that we have the source files for our library, we need to turn them into
    an actual library. As mentioned previously, a library is a set of object files
    in an archive format, sort of like a *.zip* file, only without the compression.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了库的源文件，接下来需要将它们转化为实际的库。如前所述，库是一个归档格式的目标文件集合，类似于一个 *.zip* 文件，只不过没有压缩。
- en: In this case, we’ll create the *libsquare.a* file (the library itself) from
    the *square_float.o*, *square_int.o*, and *square_unsigned.o* files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The `make` program is quite intelligent and has the ability to update an archive’s
    components. For example, one of the components of *libsquare.a* is *square_int.o*.
    The following rule makes this a component of the library:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first line tells `make` that we are creating or updating the *square_int.o*
    component in the *libsquare.a* library. This component depends on the *square_int.o*
    object file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The second line is the actual command to add the library. The `c` option tells
    `ar` to create the archive if it does not exist. The `r` causes `ar` to create
    or replace the *square_int.o* component in the archive. The `U` flag tells `ar`
    to run in nondeterministic mode, which stores the creation time of the file in
    the archive (we’ll discuss deterministic versus nondeterministic mode later in
    this chapter). Following that command is the name of the library (*libsquare.a*)
    and the name of the component to add or replace (*square_int.o*). The linker sets
    the naming convention. It must begin with *lib* and end with *.a* (more on this
    naming convention later).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, with the following directives, we tell `make` what components should
    make up the *libsquare.a* library:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first two lines tell `make` what components to make *libsquare.a* out of.
    The third line, `ranlib libsquare.a`, tells `make` to run a program called `ranlib`
    on the archive after installing all the components to create a table of contents
    for the archive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: ranlib and Library Linking
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The reason we use `ranlib` is due to some of the early linkers. Suppose that
    we had an archive with the components *a.o* (defines `a_funct`), *b.o* (defines
    `b_funct`), and *c.o* (defines `c_funct`) and that the program needed a function
    in *b.o*. The linker would open the archive and go through it serially, looking
    at each member to see whether it was needed. The decision process goes like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Look at the list of undefined symbols (the program uses `b_funct`, so it’s undefined).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the archive.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at *a.o*. Does it define a needed symbol? No. Do not load it.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at *b.o*. Does it define a needed symbol? Yes. Load it.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at *c.o*. Does it define a needed symbol? No. Do not load it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now suppose that *b.o* needed the `a_funct` function. The linker would not go
    back and reexamine the archive. It would continue on and look only at *c.o*. Since
    *c.o* does not define the symbol, it would not be loaded. The linker would reach
    the end of the archive and abort because it did not find an object file to satisfy
    the need for `a_funct`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way the linker worked, sometimes you needed to specify the same
    library two or three times. To solve that problem, a table of contents was added
    to the archive so the components could be loaded in random order (thus the name
    `ranlib`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the algorithm to load components is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Look at the list of undefined symbols (the program uses `b_funct`, so it’s undefined).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the archive.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we have an undefined symbol that’s in the table of contents?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, load it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until we have no more symbols that can be satisfied by this library.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process solves the ordering problem because the table of contents makes
    everything accessible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command actually links the library with our program:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `-L.` flag tells the linker to search the current directory (`.`) for library
    files. Otherwise, only the system library directories are searched. The library
    itself is specified with the `-lsquare` directive. The linker looks for a library
    called *libsquare.a*, first in the current directory (because of the `-L.`) and
    then in the system directories.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-17](#listing17-17) shows the full makefile for this project.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 17-17: The full makefile*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Because our test program does not call `square_unsigned`, the *square_unsigned.o*
    module will not be linked into our program. (The test for `square_unsigned` was
    omitted to demonstrate how the linker will not link in unneeded object files.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic vs. Nondeterministic Libraries
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, if you run a `make` command, the resulting binary should be the same,
    no matter when the command was executed. For this reason, originally the library
    files did not store information on who created the components or when they were
    created.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: However, that causes some difficulties for the `make` program. How can it determine
    whether the version of *square_int.o* in the archive is newer or older than the
    version you just compiled if the archive doesn’t store the modification date?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The `ar` command was modified to store this information. Because this feature
    broke legacy functionality, the `ar` maintainers decided to make storing this
    information optional. If you specify the `D` option, the modification times are
    not stored and you get a *deterministic archive* (the same binary every time).
    If you specify `U` for *nondeterministic*, you get a different binary each time,
    but one that the `make` program likes better. The default is `D`, the legacy format.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Weak Symbols
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve defined modules with functions and variables that are always loaded.
    In other words, if a module defines a `doIt` function, that’s the only definition
    of the function that’s loaded. An extension to the C language provided by GCC
    and most other compilers allows for *weak symbols*. A weak symbol tells the linker,
    “If no one else defines this symbol, use me.”
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: One example of where weak symbols are used is in the STM interrupt table. You
    *must* define functions to be called for every possible interrupt; the hardware
    requires it. So you have to write an interrupt route for interrupts that never
    occur. Since the function is never going to be called, that should make things
    simple.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: However, the STM firmware is designed around the idea that although interrupt
    routes for disabled interrupts *should* never be called, that doesn’t mean that
    they will *never* be called. The STM firmware defines interrupt handlers for all
    interrupts that brick the system. If they ever do get called, your system stops
    and you get a chance to go in with the debugger and try and figure out why.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The only way a default interrupt handler will be called is if you turn on interrupts
    and don’t provide your own interrupt handler. In that case the default interrupt
    knows something went wrong and just sits there waiting for you to figure out what.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The STM interrupt handler from the USART2 interrupts is the function `USART2_IRQHandler`,
    which is defined as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, if we define our own, the one in the firmware library disappears, in
    spite of the fact that the other 40 or so interrupt functions in the same module
    will be loaded.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this in action with our own code. In Listings 17-18 and 17-19 we have
    `sub1` and `sub2`, and `sub2` is defined twice (once in *main.c* and once in *sub.c*).
    When the linker looks at those two files, it says, “There are two `sub2` functions
    here. Should I raise an error? No. One of them is weak, and I can throw it away.”
    The `sub2` in *main.c* will get linked in and the one in *sub.c* will not.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first define a main program whose job is to call our two subroutines (see
    [Listing 17-18](#listing17-18)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**main.c**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 17-18: The main program to call the two subroutines'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 17-19](#listing17-19), we tell the compiler that `sub2` in *sub.c*
    is weak through the GCC extension.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**sub.c**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 17-19: Tells the compiler `sub2` is weak'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a header file, so let’s produce one (see [Listing 17-20](#listing17-20)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**sub.h**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 17-20: The header file'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define our own `sub2` function in [Listing 17-21](#listing17-21).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**sub2.c**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 17-21: Defining the `sub2` function'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: If we link *main.c* and *sub.c*, the weak `sub2` will be linked in. If we link
    *main.c*, *sub.c*, and *sub2.c*, the non-weak version defined in *sub2.c* will
    be used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for cases like interrupt routines where you have to define one
    whether you use it or not. It allows you to supply a fallback or default version.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules enable you to split up large programs into manageable units. Good design
    means a large program does not need to have large parts. Multiple modules can
    be organized into a library. The advantage of a library is that it can include
    a large number of specialized modules, and the linker will only link in the needed
    ones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Good programming is all about organizing information, and modules and libraries
    let you organize a huge programming mess into manageable-sized units.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a library to compute the area of geometric shapes (`rectangle_area`, `triangle_area`,
    and so on). Each function should be in its own object file, and all the area functions
    should be combined into a single library. Write a main program to perform a unit
    test on the functions.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个库来计算几何形状的面积（`rectangle_area`、`triangle_area` 等）。每个函数应在自己的目标文件中，所有面积计算函数应合并成一个单独的库。编写一个主程序对这些函数进行单元测试。
- en: Rewrite one of the serial output programs created in previous chapters so that
    all of the UART-related code is in a module of its own.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写前面章节中创建的一个串行输出程序，使所有与UART相关的代码都在一个独立的模块中。
- en: 'Test to see what happens when:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一下发生了什么，当：
- en: You define two weak symbols and one strong one.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了两个弱符号和一个强符号。
- en: You define two weak symbols and no strong one.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了两个弱符号，没有强符号。
- en: You define two strong symbols.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你定义了两个强符号。
