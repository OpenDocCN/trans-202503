["```\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n```", "```\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\", \"ProviderC\");\n```", "```\nsecurity.provider.n=ProviderClassName\n```", "```\nstatic {\n    Security.insertProviderAt(new MyProvider(), 1);\n}\n```", "```\nstatic EngineClassName getInstance(String algorithm)➊\n    throws NoSuchAlgorithmException\nstatic EngineClassName getInstance(String algorithm, String provider)➋\n    throws NoSuchAlgorithmException, NoSuchProviderException\nstatic EngineClassName getInstance(String algorithm, Provider provider)➌\n    throws NoSuchAlgorithmException\n```", "```\nProvider[] providers = Security.getProviders();\nfor (Provider p : providers) {\n     System.out.printf(\"%s/%s/%f\\n\", p.getName(), p.getInfo(), p.getVersion());\n     Set<Service> services = p.getServices();\n     for (Service s : services) {\n         System.out.printf(\"\\t%s/%s/%s\\n\", s.getType(),\n              s.getAlgorithm(), s.getClassName());\n    }\n}\n```", "```\nSecureRandom sr = new SecureRandom();➊\nbyte[] output = new byte[16];\nsr.nextBytes(output);➋\n```", "```\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");➊\nbyte[] data = getMessage();\nbyte[] digest = md.digest(data);➋\n```", "```\nPrivateKey privKey = getPrivateKey();\nPublicKey pubKey = getPublicKey();\nbyte[] data = \"sign me\".getBytes(\"ASCII\");\n\nSignature sig = Signature.getInstance(\"SHA256withRSA\");\nsig.initSign(privKey);➊\nsig.update(data);➋\nbyte[] signature = sig.sign();➌\n\nsig.initVerify(pubKey);➍\nsig.update(data);\nboolean valid = sig.verify(signature);➎\n```", "```\nCipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n```", "```\nSecureRandom sr = new SecureRandom();\nSecretKey key = getSecretKey();\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");➊\n\nbyte[] iv = new byte[cipher.getBlockSize()];\nsr.nextBytes(iv);\nIvParameterSpec ivParams = new IvParameterSpec(iv);➋\ncipher.init(Cipher.ENCRYPT_MODE, key, ivParams);➌\nbyte[] plaintext = \"encrypt me\".getBytes(\"UTF-8\");\nByteArrayOutputStream baos = new ByteArrayOutputStream();\nbyte[] output = cipher.update(plaintext);➍\nif (output != null) {\n    baos.write(output);\n}\noutput = cipher.doFinal();➎\nbaos.write(output);\nbyte[] ciphertext = baos.toByteArray();\n\ncipher.init(Cipher.DECRYPT_MODE, key, ivParams);➏\nbaos = new ByteArrayOutputStream();\noutput = cipher.update(ciphertext);➐\nif (output != null) {\n    baos.write(output);\n}\noutput = cipher.doFinal();➑\nbaos.write(output);\nbyte[] decryptedPlaintext = baos.toByteArray();➒\n```", "```\nKeyGenerator keygen = KeyGenerator.getInstance(\"HmacSha256\");\nSecretKey key = keygen.generateKey();\nMac mac = Mac.getInstance(\"HmacSha256\");➊\nmac.init(key);➋\nbyte[] message = \"MAC me\".getBytes(\"UTF-8\");\nbyte[] tag = mac.doFinal(message);➌\n```", "```\nKeyFactory kf = KeyFactory.getInstance(\"RSA\");➊\nbyte[] encodedKey = readRsaPublicKey();\nX509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);➋\nRSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(keySpec);➌\n```", "```\nbyte[] salt = generateSalt();\nint iterationCount = 1000; int keyLength = 256;\nKeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,\n                                 iterationCount, keyLength);➊\nSecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");➋\nSecretKey key = skf.generateSecret(keySpec);➌\n```", "```\nKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDH\");➊\nECGenParameterSpec ecParamSpec = new ECGenParameterSpec(\"secp256r1\");➋\nkpg.initialize(ecParamSpec);➌\nKeyPair keyPair = kpg.generateKeyPair();➍\n```", "```\nKeyGenerator keygen = KeyGenerator.getInstance(\"AES\");➊\nkg.init(256);➋\nSecretKey key = keygen.generateKey();➌\n```", "```\nPrivateKey myPrivKey = getPrivateKey();\nPublicKey remotePubKey = getRemotePubKey();\nKeyAgreement keyAgreement = KeyAgreement.getInstance(\"ECDH\");➊\nkeyAgreement.init(myPrivKey);➋\nkeyAgreement.doPhase(remotePubKey, true);➌\nbyte[] secret = keyAgreement.generateSecret();➍\n```", "```\nKeyStore keyStore = KeyStore.getInstance(\"PKCS12\");➊\nInputStream in = new FileInputStream(\"mykey.pfx\");\nkeyStore.load(in, \"password\".toCharArray());➋\nKeyStore.PrivateKeyEntry keyEntry =\n      (KeyStore.PrivateKeyEntry)keyStore.getEntry(\"mykey\", null);➌\nX509Certificate cert = (X509Certificate) keyEntry.getCertificate();➍\nRSAPrivateKey privKey = (RSAPrivateKey) keyEntry.getPrivateKey();➎\n```", "```\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");➊\nInputStream in = new FileInputStream(\"certificate.cer\");\nX509Certificate cert = (X509Certificate) cf.generateCertificate(in);➋\n```", "```\nCertPathValidator certPathValidator = CertPathValidator.getInstance(\"PKIX\");➊\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\nX509Certificate[] chain = getCertChain();\nCertPath certPath = cf.generateCertPath(Arrays.asList(chain));➋\nSet<TrustAnchor> trustAnchors = getTrustAnchors();\nPKIXParameters result = new PKIXParameters(trustAnchors);➌\nPKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult)\n             certPathValidator.validate(certPath, pkixParams);➍\n```", "```\nstatic {\n    Security.insertProviderAt(\n        new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n}\nSignature sig = Signature.getInstance(\"SHA1withRSA/PSS\", \"SC\");\n```"]