- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 13 TREES AND FORESTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: In previous chapters we explored binary trees that have the restriction of only
    two children per node. In this chapter, we’ll consider some new structures that
    go beyond that restriction, such as forests and orchards (when working with a
    single tree isn’t enough). After that, we’ll move on to study B-trees and red-black
    trees for faster searching.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Defining Trees and Forests
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Binary trees* can be empty or consist of a node (the root) and two children,
    which are both binary trees themselves. In particular, *binary search trees* are
    also *ordered* trees, because we define a certain order between children and distinguish
    the left child from the right child.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Let’s expand on those concepts. First, you’ll allow a node to have many children,
    not just two—in other words, nodes can have degrees greater than 2\. You may have
    trees with a specific number of (possibly empty) children per node, as binary
    or ternary trees, but in general, no restrictions are placed on the degree of
    a node. Sometimes trees with an unspecified maximum degree are called *multiary*
    or *multiway*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond single trees, a *forest* is defined as a set of disjointed trees.
    For instance, you could consider the directory for a given hard drive in your
    computer to be a tree, but all the different pieces of storage (like hard drives
    or USB sticks) in your computer would make up a forest.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even go further and define an *orchard* as a forest with an ordered
    relationship between its trees. In a forest, trees are strewn around in a disordered
    manner, but an orchard has a well-defined layout. Continuing with the computer
    example, if you assign letters to your drives (C:, D:, and so on, Microsoft Windows
    style), your storage actually is an orchard. The forestry-related terms do not
    end here: you can also have *groves*, which are like trees, with the exception
    that their nodes can have links to other nodes, which would turn the data structure
    into a directed (and possibly cyclic) graph.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To simplify the terminology in this chapter, we’ll use the terms forests (when
    no particular order is implied among the trees) and ordered forests (rather than
    orchards), which is the terminology most textbooks use. Also, in this chapter
    we won’t work with groves at all.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Representing Trees with Arrays
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do you know how to represent a general tree? How about a forest? Let’s start
    with trees, because by doing so we’ll discover a tip for dealing with forests.
    The first solution you’ll probably think of is having an array to point at each
    child, and in JavaScript with varying-length dynamic arrays, that’s the simplest
    solution. [Figure 13-1](chapter13.xhtml#fig13-1) shows a generic tree where the
    nodes have different degrees.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A generic tree'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement such a tree, add an array of subtrees to each node, resulting
    in something like the following (in terms of JavaScript, this code varies a bit
    from the style of the book and represents trees with a class, which lets you use
    a standard interface like the Document Object Model [DOM] node interface):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这样的树，在每个节点上添加一个子树数组，形成如下所示的结构（从 JavaScript 的角度来看，这段代码与书中的风格略有不同，表示使用类的树结构，这使得你可以使用像文档对象模型
    [DOM] 节点接口这样的标准接口）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A key field ❶, which also doubles as a flag, decides whether a tree is empty
    ❸, and an array of children ❷ is empty by default. The _throwIfEmpty() method
    ❹ detects incorrect accesses to empty trees (this is used in several methods).
    You also add a getter ❺ and a setter ❻ for the tree’s key. Then add some getters
    to check whether a node is a leaf with no children ❼ and, if not, to get its children
    ❽, in particular, accessing its first ❾ and last ❿ child, mimicking well-known
    DOM node-related methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键字段 ❶，也作为标志，决定树是否为空 ❸，默认情况下，子节点数组 ❷ 为空。`_throwIfEmpty()` 方法 ❹ 检测到对空树的不正确访问（这在多个方法中使用）。你还添加了一个
    getter ❺ 和一个 setter ❻ 来获取和设置树的键。然后添加一些 getter 来检查节点是否是没有子节点的叶子节点 ❼，如果不是，则获取其子节点
    ❽，特别是访问它的第一个 ❾ 和最后一个 ❿ 子节点，模仿常见的 DOM 节点相关方法。
- en: NOTE
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For more details on the DOM node interface, visit* [https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node](https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node)*.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*欲了解更多关于 DOM 节点接口的详情，请访问* [https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node](https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node)*.*'
- en: You could consider adding more methods to the tree, but you would need some
    extra fields to reproduce certain methods, such as parentNode or previousSibling.
    We’ll see some ways to achieve those things later in the chapter. Now you can
    represent general trees and access their nodes, so next take a look at how to
    add or remove data to update trees.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑为树添加更多的方法，但你需要一些额外的字段来重现某些方法，如 `parentNode` 或 `previousSibling`。我们将在本章稍后看到实现这些功能的一些方法。现在你可以表示一般的树并访问它们的节点，接下来看看如何添加或移除数据来更新树。
- en: Adding Nodes to a Tree
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向树中添加节点
- en: 'First, add a new child in a specific place among its siblings:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在同级节点中的特定位置添加一个新子节点：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To add a new key, all you need to specify is its position among its siblings;
    by default, you’ll add it at the end ❶. If the tree is empty (no root), you throw
    an error ❷, and you also do that if the index lies beyond the limits of the current
    array of children ❸. If everything’s okay, just create a new tree ❹, place the
    new key as its root, and place the tree in the correct position among its siblings
    ❺, ending by allowing chaining, as in other previous cases ❻.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新的键，只需指定它在同级节点中的位置；默认情况下，你将把它添加到末尾 ❶。如果树为空（没有根节点），则抛出错误 ❷，如果索引超出当前子节点数组的范围，也会抛出错误
    ❸。如果一切正常，创建一个新的树 ❹，将新键作为其根节点，并将树放置在正确的位置 ❺，最后启用链式操作，如其他情况 ❻。
- en: 'Appending a node is easy:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 附加节点很简单：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You just depend on the default parameters for addChild(), which also test whether
    the tree has a root. No special code needed here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需依赖 `addChild()` 的默认参数，这也会测试树是否有根。这里不需要特殊的代码。
- en: Removing Nodes from a Tree
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从树中移除节点
- en: 'To remove a given child, you need only a test and some array manipulation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除给定的子节点，只需要测试并进行一些数组操作：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After verifying that the tree has a root and isn’t empty ❶, check whether the
    index of the child to remove is valid or not ❷. If it is valid, do some array
    manipulation to remove the child from among its siblings ❸. End by enabling chaining
    as when adding a node ❹.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证树有根且不为空 ❶ 后，检查要删除的子节点的索引是否有效 ❷。如果有效，对数组进行操作，将该子节点从同级节点中移除 ❸。最后，如同添加节点时一样，启用链式操作
    ❹。
- en: Representing Trees with Binary Trees
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用二叉树表示树
- en: 'Representing trees with arrays works well, but another way of dealing with
    trees uses a simpler kind of tree, a binary tree. The trick is to use the left
    and right pointers in a different way from before: the left one will point to
    the first child, and the right one will point to the next sibling.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组表示树是有效的，但处理树的另一种方法是使用更简单的树形结构——二叉树。诀窍在于不同于以前的使用方式，左指针指向第一个子节点，右指针指向下一个兄弟节点。
- en: NOTE
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you are wondering whether this technique is purely academic or if you’ll
    ever use it in reality, we’ll be doing so in [Chapter 15](chapter15.xhtml) when
    studying binomial heaps and their variants.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在想这种技术是否纯粹是学术性的，或者是否能在实际中使用，我们将在[第15章](chapter15.xhtml)学习二项堆及其变种时使用它。*'
- en: Revisit the tree shown in [Figure 13-1](chapter13.xhtml#fig13-1). An alternative
    representation would have each node’s left link pointing to the node’s first child,
    and the right links would create a list of the node’s siblings. (As with all the
    other diagrams in this book, left and right null pointers are omitted for clarity.)
    If you rearrange and rotate the image 45 degrees, so the left pointers actually
    point down, the scheme becomes clearer, as shown in [Figure 13-2](chapter13.xhtml#fig13-2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[图13-1](chapter13.xhtml#fig13-1)中展示的树。另一种表示方法是每个节点的左链接指向该节点的第一个子节点，右链接则创建一个节点的兄弟列表。（与本书中的其他所有图示一样，为了清晰起见，左和右的空指针被省略。）如果你重新排列并旋转图像45度，使得左指针实际指向下方，这个方案就会更清晰，如[图13-2](chapter13.xhtml#fig13-2)所示。
- en: '![](../images/Figure13-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-2.jpg)'
- en: 'Figure 13-2: A tree represented with the “left-child, right-sibling” style'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：使用“左孩子，右兄弟”样式表示的树
- en: Many structures use this *left-child, right-sibling* convention, but it’s better
    to rename the left pointer to *down* for clarity; *right* will still point to
    siblings. As for algorithms (adding or removing values and so on), you won’t need
    to do anything different from what you learned about binary trees in [Chapter
    12](chapter12.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多结构使用这种*左孩子，右兄弟*约定，但为了更清晰，最好将左指针重命名为*下*，*右*指针仍然指向兄弟节点。至于算法（添加或删除值等），你不需要做任何不同于在[第12章](chapter12.xhtml)中学到的二叉树内容的事情。
- en: '#### Representing Forests'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 表示森林'
- en: You can extend these methods for representing trees to represent forests. If
    you use arrays for pointers, you can simply have an array of roots, each pointing
    to a specific tree (we’ll see this concept again in [Chapters 14](chapter14.xhtml)
    and [15](chapter15.xhtml) when discussing binomial and Fibonacci heaps, so consider
    [Figure 13-3](chapter13.xhtml#fig13-3) to be a minor spoiler).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些表示树的方法扩展到表示森林。如果使用数组作为指针，你可以简单地有一个根节点数组，每个元素指向一个特定的树（我们将在讨论二项堆和斐波那契堆时再次看到这个概念，见[第14章](chapter14.xhtml)和[第15章](chapter15.xhtml)，所以可以把[图13-3](chapter13.xhtml#fig13-3)看作是一个小剧透）。
- en: '![](../images/Figure13-3.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-3.jpg)'
- en: 'Figure 13-3: A forest, represented with an array of roots'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3：一个森林，表示为根节点数组
- en: 'At the top of the forest is an array with a pointer to the root of each individual
    tree. If you prefer the binary tree representation, you can do two different things:
    consider that all roots are siblings or add a fictitious “super-root” that has
    all the forest trees as subtrees. The first is the usual representation, which
    would give something like the forest in [Figure 13-4](chapter13.xhtml#fig13-4)
    (this is the same forest as shown in [Figure 13-3](chapter13.xhtml#fig13-3)).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在森林的顶部是一个数组，其中包含指向每棵单独树根节点的指针。如果你更喜欢二叉树的表示方式，你可以做两件事：要么考虑所有根节点都是兄弟节点，要么添加一个虚拟的“超级根”，它包含所有森林中的树作为子树。第一种是常见的表示方式，类似于[图13-4](chapter13.xhtml#fig13-4)所示的森林（这与[图13-3](chapter13.xhtml#fig13-3)中展示的森林相同）。
- en: '![](../images/Figure13-4.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-4.jpg)'
- en: 'Figure 13-4: An alternative representation of the same forest; the roots are
    linked to the right.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4：同一森林的另一种表示方法；根节点通过右指针连接。
- en: To access this forest, you need a pointer to the leftmost root; from there,
    you can access all the trees. You can go even further by making the list of siblings
    circular and doubly linked; we’ll explore this later and see why those enhancements
    (and complications) are actually needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这个森林，你需要一个指向最左根节点的指针；从那里，你可以访问所有的树。你甚至可以通过使兄弟列表变成循环和双向链表来进一步扩展；我们稍后会探讨这个，并且看看为什么这些增强（以及复杂性）实际上是必要的。
- en: Traversing Trees
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历树
- en: 'When studying binary search trees in [Chapter 12](chapter12.xhtml), we looked
    at three different ways of traversing trees by “visiting” all the nodes according
    to various schemes. With general trees, you don’t have all those methods, but
    we’ll add new ones. But first review the traversals we’ve done before and adapt
    two of them to the general tree:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](chapter12.xhtml)学习二叉查找树时，我们讨论了三种不同的遍历树的方式，通过“访问”所有节点，按照不同的方案进行遍历。对于一般树，你没有那么多的方法，但我们会新增一些。但首先，复习一下我们之前做过的遍历，并将其中的两种方法适配到一般树上：
- en: '**Preorder **For binary trees, *preorder* means first visiting the root, then
    traversing its left subtree, and finally traversing its right subtree. You can
    adapt this for general trees by first visiting the root and then traversing each
    of its subtrees in order.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**前序** 对于二叉树，*前序*意味着首先访问根节点，然后遍历其左子树，最后遍历其右子树。你可以将这个方法适配到一般树上，首先访问根节点，然后按顺序遍历每一个子树。'
- en: '**Postorder **The *postorder* method for binary trees is similar to preorder,
    but it first visits the root’s left subtree, then the right, and finally the root
    itself. The adaptation requires first traversing all the root’s children in order
    and finally visiting the root itself.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**后序** *后序*方法对于二叉树来说类似于前序方法，但它首先访问根节点的左子树，然后是右子树，最后访问根节点本身。其变体要求先遍历所有根节点的子节点，并按顺序访问，最后访问根节点。'
- en: '**Inorder **The *inorder* method doesn’t really have an equivalent. For binary
    trees, it means first traversing the left subtree, then visiting the root, and
    finally traversing the right subtree. However, for general trees, you don’t have
    any reasonable alternative, so you can forgo this traversal (although for B-trees,
    discussed later in this chapter, you do have a possible inorder version).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**中序** *中序*方法实际上没有完全对应的版本。对于二叉树，它意味着首先遍历左子树，然后访问根节点，最后遍历右子树。然而，对于一般树，你没有合适的替代方法，因此可以跳过这种遍历（尽管对于本章后面讨论的B树，你确实有可能实现一个中序版本）。'
- en: 'Coding preorder and postorder traversals is fairly straightforward, and the
    versions used for binary trees require only minor changes (we’ll consider their
    implementations in the questions at the end of this chapter). Two new methods,
    however, are worth studying and also appear in other types of algorithms, such
    as game playing or function optimization: *depth-first* and *breadth-first* traversals.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编写前序和后序遍历的代码是相当直接的，二叉树的版本只需要做一些小的修改（我们将在本章末的习题中讨论它们的实现）。然而，有两个新方法值得学习，并且也出现在其他类型的算法中，例如游戏或函数优化：*深度优先*和*广度优先*遍历。
- en: Depth-First Traversal
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 深度优先遍历
- en: The possibly most logical traversal to implement requires visiting the root
    first and then traversing all its children using the same algorithm. In effect,
    it’s equivalent to going as deeply as possible into a branch before moving on
    to another branch—thus, the name *depth first*. [Figure 13-5](chapter13.xhtml#fig13-5)
    shows an example of such a traversal; the numbers in the nodes reflect the order
    in which the visits occur.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可能最合逻辑的遍历方法需要首先访问根节点，然后使用相同的算法遍历所有子节点。实际上，这相当于在移动到另一分支之前尽可能深入地进入一个分支——因此，称为*深度优先*。
    [图13-5](chapter13.xhtml#fig13-5)展示了这种遍历的一个示例；节点中的数字反映了访问发生的顺序。
- en: '![](../images/Figure13-5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-5.jpg)'
- en: 'Figure 13-5: A depth-first traversal of a tree'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-5：树的深度优先遍历
- en: 'This kind of algorithm is a classic one, generally used for searches or games.
    For instance, if you’re trying to get out of a maze, you’d follow some path until
    you either exit (and finish) or become blocked, in which case you go back to try
    another option. (See “Finding a Path in a Maze” on [page 69](chapter5.xhtml#pg_69).)
    Similarly, in games, you consider some sequence of movements as far as you can
    (because of time limitations), and if you haven’t found a winning line, you go
    back to try another one. The logic looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种算法是一种经典算法，通常用于搜索或游戏。例如，如果你试图走出迷宫，你会沿着某条路径前进，直到你要么退出（并完成任务），要么遇到障碍，在这种情况下你会回头尝试另一条路径。（请参阅[第69页](chapter5.xhtml#pg_69)的“迷宫路径查找”。）同样，在游戏中，你会尽可能地考虑某一系列的移动（因为时间有限），如果你还没有找到获胜的路线，就会回头尝试另一条。其逻辑如下：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The algorithm is similar to some that you wrote for binary trees in [Chapter
    12](chapter12.xhtml). First, define a default visit() function ❶ that just lists
    the node’s key, and if the tree isn’t empty ❷, visit its root ❸. Then proceed
    to visit all of its children recursively, depth first ❹.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法与在[第12章](chapter12.xhtml)中为二叉树编写的某些算法类似。首先，定义一个默认的visit()函数❶，它仅列出节点的键，然后如果树不为空❷，访问其根节点❸。接下来，递归地按照深度优先的方式访问所有子节点❹。
- en: Breadth-First Traversal
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: The alternative way to traverse trees is breadth first, which is a traversal
    style that you haven’t yet met. (This type of traversal is also called *level
    order* for reasons that will become apparent.) The idea is that you start at the
    root; then, you visit all of its children in the next level. Then (and only then),
    you visit the children’s children at the second level of the tree, and so on.
    You never visit a node until you’ve already visited all the nodes closer to the
    root, going down level by level, one by one. [Figure 13-6](chapter13.xhtml#fig13-6)
    shows such a traversal for a generic tree. Again, the numbers reflect the order
    in which the nodes are visited, and you can verify that each level is fully visited
    before starting the next level.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-6.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: A breadth-first traversal of a tree'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this strategy requires using a queue, as discussed in [Chapter
    10](chapter10.xhtml). As you start visiting nodes “horizontally,” you need to
    remember to visit their children later, so a queue with a first in, first out
    (FIFO) strategy works. You can code this as an independent function just for variety:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As with other traversals, a default visit() function ❶ logs the node’s key.
    If the tree to be traversed isn’t empty ❷ (in which case you wouldn’t have to
    do anything), initialize a queue ❸ by pushing the tree’s root ❹. The rest of the
    algorithm is straightforward: while the queue hasn’t been emptied ❺, you pop its
    top ❻, visit that node ❼, and push all of its children into the queue for future
    visits ❽.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm isn’t recursive at all, which isn’t common for trees and other
    recursively defined structures. There’s an interesting sort of symmetry here:
    visiting a tree breadth first without recursion requires using a queue, and visiting
    it depth first without recursion needs a stack; see question 13.3.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: B-trees
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: B-trees have a self-adjusting tree structure with assured logarithmic performance
    for additions, removals, and searches, so in that sense, you could consider them
    an extension of height-balanced binary search trees—and a better-performing one
    at that. A key characteristic of these trees is that nodes can have more than
    two children, which allows for wider, shorter trees with faster searches.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Nobody really knows what the B in B-tree stands for. This structure was defined
    in 1972 by Rudolf Bayer and Edward McCreight, but no explanation was given for
    the term, so you can choose your own interpretation: some proposals have been
    “balanced,” “broad,” “bushy,” and, obviously, “Bayer.”*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition (and implementation) for a B-tree varies among different sources
    and authors, so let’s make clear what is used here. A B-tree of order *m* satisfies
    the following properties:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Every node has *p* < *m* keys, in ascending order, and *p* + 1 children.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every node but the root must have at least *m*/2 (rounded up) children, or in
    other words, all nodes (except the root) should be at least half full.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root should have at least one key.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点应至少包含一个键。
- en: All leaves must be at the same level.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有叶子节点必须位于同一层级。
- en: 'The B-tree is structured in a fashion similar to a binary search tree: given
    any key in a node, all the children to its left will be smaller than the key,
    and all the children to its right will be greater than it. For instance, you could
    have a node such as the one shown in [Figure 13-7](chapter13.xhtml#fig13-7).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: B树的结构类似于二叉搜索树：给定一个节点中的键，该节点左侧的所有子节点的值都小于该键，右侧的所有子节点的值都大于该键。例如，你可以有一个如下所示的节点，参见[图13-7](chapter13.xhtml#fig13-7)。
- en: '![](../images/Figure13-7.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-7.jpg)'
- en: 'Figure 13-7: A B-tree node, showing where keys are to be found'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-7：一个B树节点，展示了键的位置
- en: In this case, the node has four keys, so five children. The first child, to
    the left of the 34 key, has keys less than 34; the child between 34 and 40 has
    keys between those two values, and so on, until the last child, the one to the
    right of the 60 key, has keys greater than that value. (These facts are what we’ll
    use to search in a B-tree; you’ll see the algorithm soon.) This structure is similar
    to binary search trees, except that now instead of a maximum of two children per
    node, we allow a greater number—and for actual implementations (such as an index
    for actual files in disk), much larger values are preferred in order to have a
    shorter height and thus faster access.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，节点有四个键，因此有五个子节点。第一个子节点位于34键的左侧，包含比34小的键；位于34和40之间的子节点包含介于这两个值之间的键，以此类推，直到最后一个子节点，它位于60键的右侧，包含比该值大的键。（这些事实就是我们用来在B树中进行搜索的依据；你很快会看到算法。）这种结构类似于二叉搜索树，不同之处在于每个节点现在允许更多的子节点，而不是最多两个子节点——对于实际的实现（如磁盘中文件的索引），通常更大的值更受欢迎，以便缩短树的高度，从而加快访问速度。
- en: Defining B-trees
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义B树
- en: 'Let’s start in similar fashion as with binary search trees by defining the
    basic functions we’ll need:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像在二叉搜索树中一样，首先定义我们需要的基本函数：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can define B-trees of any order, and we’ll use a variable ORDER ❶ to store
    the one you want. The first time you create a B-tree ❷, you’ll store the desired
    order (or 3, by default), so all future B-trees will have that order. (This decision
    begs the question: What if you want to have B-trees of *different* orders? See
    question 13.9.) The newNode() function ❸ creates a new node with a single null
    key by default, flanked by two null pointers; of course, this node will be “too
    empty,” unless ORDER is small. Note, however, that if you provide an array of
    keys ❹, some JavaScript trickery is used to generate (if needed) a corresponding
    array of null pointers, with one key more; can you see how this works?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义任意阶的B树，我们将使用一个变量ORDER ❶来存储你想要的阶数。当你第一次创建B树 ❷时，你将存储所需的阶数（默认情况下是3），这样所有未来的B树都会具有这个阶数。（这个决定引出了一个问题：如果你想要不同阶数的B树怎么办？参见问题13.9。）newNode()函数
    ❸默认情况下会创建一个包含单一空键的新节点，并且两侧有空指针；当然，这个节点会显得“过于空”，除非ORDER值很小。然而，值得注意的是，如果你提供一个键的数组
    ❹，一些JavaScript的技巧将被用来生成（如果需要）一个对应的空指针数组，数组长度比键数组多一个；你能理解这怎么工作吗？
- en: Finally, a couple of auxiliary functions will come in handy. At times, you’ll
    need to test whether a node is oversized (or would be, if d keys were added to
    it), with more keys than allowed ❺, and _tooBig() will check that. Similarly,
    _tooSmall() determines whether the node is undersized (or would be, if d keys
    were removed from it) and doesn’t have enough keys ❻. (Be careful not to apply
    _tooSmall() to the root—the only node that is allowed to be smaller.) You’ll use
    those two methods when adding or removing keys.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些辅助函数会派上用场。有时，你需要测试一个节点是否超载（或者如果添加d个键后会超载），即它的键数超过了允许的数量 ❺，_tooBig()函数将检查这一点。类似地，_tooSmall()函数判断节点是否过小（或者如果移除d个键后会过小），即它没有足够的键
    ❻。（注意不要对根节点使用_tooSmall()——根节点是唯一允许小于规定键数的节点。）你将在添加或删除键时使用这两个方法。
- en: Finding a Key in a B-tree
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在B树中查找键
- en: 'Let’s start with the most basic algorithm: searching for a key. In a sense,
    the algorithm is similar to searching a binary search tree; you look for the key,
    and if you don’t find it in a node, you determine where to continue searching.
    Consider some examples. Assume you have the following B-tree of order 3; null
    links are represented with blank boxes, as shown in [Figure 13-8](chapter13.xhtml#fig13-8).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的算法开始：查找一个键。从某种意义上讲，算法类似于查找二叉搜索树中的键；你查找该键，如果在某个节点中没有找到，你会判断接下来应该在哪里继续查找。考虑一些例子。假设你有一个阶数为3的B树；空链接用空白框表示，如[图13-8](chapter13.xhtml#fig13-8)所示。
- en: '![](../images/Figure13-8.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-8.jpg)'
- en: 'Figure 13-8: A B-tree of order 3'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-8：阶数为 3 的 B 树
- en: 'If you were looking for 22, that would be easy: it’s in the root, so there’s
    nothing to do. You can make it more complex and look for 56, as shown in [Figure
    13-9](chapter13.xhtml#fig13-9).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找 22，那就简单多了：它就在根节点中，因此无需做任何操作。你可以让它变得更复杂，像寻找 56 一样，参考[图 13-9](chapter13.xhtml#fig13-9)。
- en: '![](../images/Figure13-9.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-9.jpg)'
- en: 'Figure 13-9: The search process for key 56'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-9：键 56 的搜索过程
- en: Start at the root, and since 56 > 22, follow the root’s last pointer to a new
    node. There, you find that 56 should be between 34 and 60, so follow the middle
    pointer to yet another node. In that one, you finally find 56, so the search is
    successful.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从根节点开始，由于 56 > 22，沿着根节点的最后一个指针到达一个新节点。在那里，你发现 56 应该位于 34 和 60 之间，因此沿着中间指针到达另一个节点。在这个节点中，你最终找到了
    56，因此搜索成功。
- en: What about searching for a key that isn’t in the tree? If you had been looking
    for 38, everything would be the same as for 56, but upon not finding 38 in the
    node with 40 and 56, you would have continued down the first pointer of the node
    (since 38 < 40), but finding it null, the search would have been unsuccessful.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查找的键不在树中呢？如果你在寻找 38，整个过程和寻找 56 是一样的，但是在没有找到包含 40 和 56 的节点中的 38 后，你会继续沿着节点的第一个指针（因为
    38 < 40），但发现它为空，搜索就会失败。
- en: 'Now on to the algorithms. Every time you get to a node, you need to see whether
    the key you want is there; if not, the algorithm tells you what pointer to follow
    to the next level; there is an auxiliary function for this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入算法部分。每次到达一个节点时，你需要检查所需的键是否存在；如果不存在，算法会告诉你该跟随哪个指针到达下一层；为此有一个辅助函数：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This looks for the first element in the keys array that is greater than or
    equal to the key you are searching ❶. If no key fits, findIndex() returns -1,
    so in that case, you return the index of the last element of ptrs (you’ll see
    the reason for this tricky code soon enough):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这会寻找键数组中第一个大于或等于你所搜索的键的元素 ❶。如果没有匹配的键，findIndex() 会返回 -1，因此在这种情况下，你返回 ptrs 中最后一个元素的索引（你很快就会明白为什么这段代码如此巧妙）：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you are searching for a key and arrive at an empty node ❶, the key obviously
    isn’t there. Otherwise, the _findIndex() method finds the first key that isn’t
    less than the searched-for key ❷. If the key is actually equal to the value you
    want to find ❸, you are done; otherwise, continue the search at the corresponding
    pointer. This is why you had _findIndex() return the last position in the array—because
    that’s the link you need to follow when the key you want to find is greater than
    all the keys in the node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在搜索一个键，并且到达一个空节点 ❶，显然该键不在其中。否则，_findIndex() 方法会找到第一个不小于所搜索键的键 ❷。如果该键正好等于你要查找的值
    ❸，则搜索完成；否则，继续沿着相应的指针进行搜索。这就是为什么你让 _findIndex() 返回数组中的最后一个位置——因为当你要查找的键大于节点中的所有键时，这是你需要跟随的链接。
- en: It may seem like a backward step to do a linear search when you have already
    seen better ways of searching; see question 13.7 for some ideas on better ways
    of searching.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进行线性搜索可能看起来是倒退的一步，尤其是在你已经看过更好的搜索方法时；有关更好的搜索方法的想法，请参见问题 13.7。
- en: Traversing a B-tree
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遍历 B 树
- en: We can define the equivalent to the inorder traversal for binary trees, which
    means visiting all keys in ascending order. Since each node has several keys,
    you need to work carefully. [Figure 13-10](chapter13.xhtml#fig13-10) shows how
    to do this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义二叉树的中序遍历等效方式，这意味着按升序访问所有键。由于每个节点有多个键，因此需要仔细操作。[图 13-10](chapter13.xhtml#fig13-10)展示了如何实现这一点。
- en: '![](../images/Figure13-10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-10.jpg)'
- en: 'Figure 13-10: A traversal for B-trees, similar to inorder for binary trees'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-10：B 树的遍历，类似于二叉树的中序遍历
- en: This version of inorder should visit keys in ascending order, so with the node
    in [Figure 15-9](chapter15.xhtml#fig15-9), start with the first (leftmost) child,
    then visit the node’s first key, followed by the second child, then the second
    key, then the third child, then the third key, and so on, ending after having
    traversed the rightmost child.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本的中序遍历应该按升序访问键，因此，对于[图 15-9](chapter15.xhtml#fig15-9)中的节点，首先访问最左边的子节点，然后访问该节点的第一个键，再访问第二个子节点，然后是第二个键，然后是第三个子节点，依此类推，直到遍历完最右边的子节点。
- en: 'Here’s a version of it at work:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个它工作的示例：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the current node is empty ❶, do nothing; otherwise, do a loop ❷, alternating
    between traversing a child ❸ and visiting a key ❹. For the latter, remember that
    there’s one fewer key than children. This code uses the condition && expression
    syntax as a shortcut to an if or ternary operator: expression is evaluated if
    and only if condition is true; in this case, visit a key if and only if the corresponding
    index is within the array of keys.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前节点为空 ❶，什么都不做；否则，执行一个循环 ❷，在遍历子节点 ❸ 和访问键 ❹ 之间交替进行。对于后者，请记住，键的数量比子节点少一个。此代码使用&&表达式语法作为if或三元运算符的快捷方式：当且仅当条件为真时，表达式才会被求值；在此情况下，只有当对应索引在键数组范围内时，才访问键。
- en: Adding a Key to a B-tree
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向B树添加键
- en: Now consider how to add a key. If you want to add a key to a node that has enough
    empty space, it’s straightforward. The problem is trying to add a key to a node
    that’s already too full to allow another key. Consider both cases using the B-tree
    of order 3 from earlier as an example (see [Figure 13-11](chapter13.xhtml#fig13-11)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如何添加一个键。如果你想向一个有足够空余空间的节点添加键，这很简单。问题在于试图将一个键添加到一个已经满了的节点。考虑使用之前提到的3阶B树作为例子（见[图13-11](chapter13.xhtml#fig13-11)）。
- en: '![](../images/Figure13-11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-11.jpg)'
- en: 'Figure 13-11: A B-tree into which you’ll add some new keys'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-11：你将添加一些新键的B树
- en: First, try to add a 66 key. After searching, you decide it should go with the
    63 key, and since that node has enough space, there’s no extra work (see [Figure
    13-12](chapter13.xhtml#fig13-12)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试添加一个66的键。经过查找后，你决定它应该与63的键一起，并且因为该节点有足够的空间，所以不需要额外操作（见[图13-12](chapter13.xhtml#fig13-12)）。
- en: '![](../images/Figure13-12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-12.jpg)'
- en: 'Figure 13-12: Adding a key at a node with space causes no problems.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-12：在有空间的节点添加键不会遇到问题。
- en: Now make things more complicated, and add a 10 key. That’s a problem, because
    the bottom-left node has no more space. First, you can let it grow beyond its
    maximum size (see [Figure 13-13](chapter13.xhtml#fig13-13)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让事情变得更复杂，添加一个10的键。这个问题在于，左下角的节点已经没有空间了。首先，你可以让它超出最大大小（见[图13-13](chapter13.xhtml#fig13-13)）。
- en: '![](../images/Figure13-13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-13.jpg)'
- en: 'Figure 13-13: Adding a key at a node at limit requires splitting the node and
    rotating a key up.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-13：在节点达到限制时添加键需要分裂节点并旋转一个键到上层。
- en: Now you need to split the oversized node in two and make its middle key go up
    to the parent node. Fortunately, that node has space, so you are done (see [Figure
    13-14](chapter13.xhtml#fig13-14)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将过大的节点分裂成两个，并将它的中间键上移到父节点。幸运的是，父节点有空间，所以操作完成了（见[图13-14](chapter13.xhtml#fig13-14)）。
- en: '![](../images/Figure13-14.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-14.jpg)'
- en: 'Figure 13-14: After the split, the B-tree structure is okay again.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-14：分裂后，B树结构恢复正常。
- en: 'If you try to add a 78 key, this node would split twice: first, the 66 key
    would go up to the 34-60 node, and then that node would split, sending its middle
    key (60) to its parent. This is the only way a B-tree can grow: if its root needs
    splitting, it adds a new level.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试添加一个78的键，这个节点会分裂两次：首先，66的键会移动到34-60节点，然后该节点会分裂，将它的中间键（60）传递到父节点。这是B树唯一的生长方式：如果根节点需要分裂，它会增加一个新层级。
- en: 'Take a look at the code and see what happens at the root level:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下代码，看看根节点层级发生了什么：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The easiest case is if the tree is empty ❶, because then all you need to do
    is create a new node with the new key and a couple of null pointers. Otherwise,
    add the key somewhere in the tree ❷ (using an auxiliary recursive _add() method,
    which will see it immediately), and check whether the root became too big ❸. If
    so, create two new nodes ❹ ❺, each with half the keys and pointers, leaving the
    middle key at the root ❻, which will have the two new nodes as children ❼.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是如果树为空 ❶，因为这时你只需要创建一个新节点，并加入新的键和几个空指针。否则，将键添加到树中的某个位置 ❷（使用一个辅助的递归_add()方法，它会立即处理），并检查根节点是否变得太大
    ❸。如果是，创建两个新节点 ❹ ❺，每个节点包含一半的键和指针，并将中间键保留在根节点 ❻，根节点将有这两个新节点作为子节点 ❼。
- en: 'But how is the new key actually added, and what’s the _add() method missing
    earlier? Here’s the code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，新的键是如何添加的呢？之前的_add()方法又有什么问题呢？下面是代码：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First find in which subtree of the current node to add the new key ❶. If the
    subtree doesn’t exist (the corresponding pointer is null), you are at the bottom
    level and can simply add the key there ❷; no need to do anything else. (Of course,
    the bottom node may have grown too large, but that will be checked by its parent,
    which will fix the situation if needed.) If there is a subtree ❸, recursively
    add the new key into it ❹ and then check whether the child grew too large ❺. If
    so, you need to add a new node that will get the second half of the keys and pointers
    of the outsized node ❻; the middle key and pointer to the new node will go up
    to the parent ❼, and you’ll leave the first half of the keys and pointers in the
    original child ❽. The code isn’t particularly hard to understand, but handling
    indices and arrays properly requires care.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a B-tree
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adding a key introduces the complexity that sometimes a node grows too big,
    and dealing with that requires either rotating or moving a key up. Removing a
    key also causes difficulties, because nodes may become too empty and need to get
    keys from other nodes or eventually require a key from the parent, which may make
    the whole B-tree shorter; in the same way that additions may cause it to grow
    taller, removals may lower its height.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several possible cases to study, but here are two: removing a key
    that isn’t in a leaf and removing a key that is in a leaf.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Nonleaf Node
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Removing a key in an internal node is easy; it’s the same as for binary search
    trees. Replace the key with the one that follows it in ascending order and then
    remove *that* key (which will be at a leaf) from the tree. For instance, assume
    you want to remove the 22 key from the tree in [Figure 13-15](chapter13.xhtml#fig13-15).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-15.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-15: A B-tree from which you’ll remove a key not from a leaf—in this
    case, the 22'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: You first need to locate the key following 22, so follow the link after 22 and
    then continue following the leftmost link until you get to a leaf to find the
    24 key (see [Figure 13-16](chapter13.xhtml#fig13-16)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-16.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-16: To remove 22, first locate the following (greater) key, which
    is 24 in this case.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Now, replace the key to be removed (22) with the following key (24) and proceed
    with the logic to remove a key from a leaf node (marked in gray in [Figure 13-17](chapter13.xhtml#fig13-17)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-17.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-17: After moving 24 to the place of the 22, you now need to remove
    the 24 from the leaf node.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: With this method, you always have to remove keys from a leaf node. Here’s how
    to do it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Leaf Node
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After finding the key to remove and checking that it’s in a leaf node, you
    have two possible cases: either the node is “full enough,” so removing the key
    won’t make it too empty, or the node is at its minimum size, which means removing
    the key will leave it undersized.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'The first case is easy to handle: continuing the example from the previous
    section, to remove the 24 key, just remove it from the node, which has enough
    keys (see [Figure 13-18](chapter13.xhtml#fig13-18)).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个情况很容易处理：继续上一节的例子，要移除24键，只需将其从节点中移除，因为该节点有足够的键（见[图13-18](chapter13.xhtml#fig13-18)）。
- en: '![](../images/Figure13-18.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-18.jpg)'
- en: 'Figure 13-18: If after removal the leaf node still has enough keys, you’re
    done.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-18：如果移除后叶子节点仍有足够的键，你就完成了。
- en: 'But consider a more complicated case: What happens if you want to remove the
    12 key? You have a problem, because the corresponding node would end up with not
    enough keys, as shown in [Figure 13-19](chapter13.xhtml#fig13-19). (In this case,
    the node gets emptied, because you are dealing with a B-tree of order 3; in a
    B-tree of a higher order, the node would still have some keys, but just not enough.)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但考虑一个更复杂的情况：如果你要移除12键，会发生什么？你会遇到问题，因为对应的节点最终会键数不足，如[图13-19](chapter13.xhtml#fig13-19)所示。（在这种情况下，节点会变为空，因为你正在处理一个3阶的B树；在更高阶的B树中，节点仍然会有一些键，但不足够。）
- en: '![](../images/Figure13-19.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-19.jpg)'
- en: 'Figure 13-19: An attempt to rotate keys from a sibling to reorganize the B-tree'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-19：尝试从兄弟节点旋转键以重新组织B树
- en: The solution here depends on the node’s siblings. You can try to borrow keys
    from one of them and check whether it’s possible to borrow from the left or right
    sibling; both siblings are symmetrical. In this case, the left sibling has enough
    keys (4 and 9), so you borrow one from it. The 9 key goes into the parent node,
    and the 11 key is rotated down into the leaf (see [Figure 13-20](chapter13.xhtml#fig13-20)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案取决于节点的兄弟。你可以尝试从其中一个兄弟借键，检查是否可以从左边或右边的兄弟借键；两个兄弟是对称的。在这种情况下，左兄弟有足够的键（4和9），所以从它那里借一个。9键进入父节点，11键被旋转到叶子节点（见[图13-20](chapter13.xhtml#fig13-20)）。
- en: '![](../images/Figure13-20.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-20.jpg)'
- en: 'Figure 13-20: A rotation fixed the problem, so you’re done.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-20：旋转解决了问题，所以你完成了。
- en: 'You have only one pending case to deal with: What happens if no sibling has
    keys to share? In that scenario, merge the node with a sibling, borrowing one
    key from the parent. This step may cause it to become undersized as well and need
    to be fixed. In this example, say you want to remove the 11 key. Merge it with
    its sibling and borrow the 9 key, reaching the situation shown in [Figure 13-21](chapter13.xhtml#fig13-21).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你只剩下一个待处理的情况：如果没有兄弟节点有键可共享，会发生什么？在这种情况下，将节点与其兄弟合并，并从父节点借用一个键。这个步骤可能会导致节点变得不足，并需要修复。在这个例子中，假设你要移除11键。将它与其兄弟合并，并借用9键，达到了[图13-21](chapter13.xhtml#fig13-21)所示的情况。
- en: '![](../images/Figure13-21.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-21.jpg)'
- en: 'Figure 13-21: The leaf node was fixed, but a problem appears above it.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-21：叶子节点已经修复，但它上面出现了问题。
- en: To solve the new undersized node situation, you again turn to the borrowing
    concept, rotate keys around, and the final tree would look like [Figure 13-22](chapter13.xhtml#fig13-22).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决新的不足节点情况，你再次使用借键的概念，旋转键，最终的树形如[图13-22](chapter13.xhtml#fig13-22)所示。
- en: '![](../images/Figure13-22.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-22.jpg)'
- en: 'Figure 13-22: A new rotation fixes the problem.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-22：新的旋转解决了问题。
- en: When doing this sharing and joining, it’s possible that eventually the tree
    will grow shorter in height. If you removed the 4 and 9 keys in succession, you’d
    arrive at the tree in [Figure 13-23](chapter13.xhtml#fig13-23).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行共享和合并时，最终树可能会变得更短。如果你连续移除了4和9键，你会得到[图13-23](chapter13.xhtml#fig13-23)中的树形。
- en: '![](../images/Figure13-23.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure13-23.jpg)'
- en: 'Figure 13-23: Removing several keys can make a B-tree eventually grow shorter.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-23：移除几个键可以使B树最终变得更短。
- en: Can you do the intermediate steps?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做出中间步骤吗？
- en: Implementing the remove() Method
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现remove()方法
- en: 'Now that you’ve seen all the strategies to apply, here’s how to code them.
    Dealing with a removal at the root level is short:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到所有的应用策略，接下来是如何编写代码。处理根节点的删除是简短的：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First use a _remove() function to remove the key from the tree recursively ❶.
    If the tree is empty, or if the root node has been left with no keys (because
    it had a single key and had to pass it down when its two children got joined),
    but the node still has one non-null child (the root might already be at the bottom
    level, without children) ❷, return that child. This means the B-tree has become
    shorter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用 _remove() 函数递归地从树中移除关键字 ❶。如果树为空，或者根节点已经没有关键字（因为它只有一个关键字，并且在两个子节点合并时必须将其传递下去），但节点仍然有一个非空的子节点（根节点可能已经位于最底层，没有子节点）
    ❷，则返回该子节点。这意味着 B 树已经变得更短。
- en: 'Now start the actual key removal process:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始实际的关键字移除过程：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Start as when doing a search: if the tree is empty, you’re done ❶. Otherwise,
    see whether the current node includes the key you want to remove ❷. If you find
    the key and are at the bottom level ❸, just remove that key and its corresponding
    pointer ❹; otherwise, if you are at a higher level, find the next key in ascending
    order ❺ using _findMin() and put it in place of the original key you wanted to
    remove ❻. Finish by removing the next key from the tree ❼ and fixing its size
    ❽ if needed (because the child became too small, with not enough keys in it).
    If the key wasn’t in the node, go down to the next level to remove it ❾ and fix
    the size if necessary ❿.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从进行搜索时开始：如果树为空，操作结束 ❶。否则，检查当前节点是否包含你要移除的关键字 ❷。如果找到关键字并且已经到达底层 ❸，直接移除该关键字及其对应的指针
    ❹；否则，如果你在更高的层次，使用 _findMin() 查找按升序排列的下一个关键字 ❺，并将其放入你想移除的原始关键字的位置 ❻。最后，移除树中的下一个关键字
    ❼，并在需要时修正其大小 ❽（因为子节点变得太小，里面没有足够的关键字）。如果关键字不在节点中，向下移至下一层进行移除 ❾，并在必要时修复大小 ❿。
- en: 'How do you find the next key? You have seen similar methods before, and for
    B-trees, the code is also quite short:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到下一个关键字？你之前可能见过类似的方法，对于 B 树，代码也相当简短：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If there’s no leftmost subtree, return the first key in the node; otherwise,
    go down to the subtree and look for the minimum there.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有最左边的子树，返回节点中的第一个关键字；否则，向下进入子树并寻找那里的最小值。
- en: 'The last method is _fixChildIfSmall(), which deals with all the cases mentioned
    before and properly rebalances nodes. The following includes four distinct cases,
    but the logic for each of them is short:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法是 _fixChildIfSmall()，它处理之前提到的所有情况并正确地重新平衡节点。以下包括四种不同的情况，但每种情况的逻辑都很简短：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, just verify whether the child is still big enough ❶, and if so, nothing
    needs to be done. Then, check whether the child has a left sibling that won’t
    become too empty if you take one key from it ❷; if this is the case, do a rotation
    of keys as described earlier ❸. Alternatively, check whether the child has a right
    sibling with enough keys ❹, and if so, do the rotation with that sibling ❺. If
    no rotation was possible and if there is a left sibling ❻, join it to the child
    ❼; otherwise, there must be a right sibling ❽, so join the child with it instead
    ❾. Again, the cases are not complex, but take care when manipulating indices;
    it’s easy to get things wrong.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，验证子节点是否仍然足够大 ❶，如果是，则无需做任何操作。然后，检查子节点是否有一个左兄弟，如果从中取一个关键字不会导致它变得太空 ❷；如果是这种情况，则进行如前所述的关键字旋转
    ❸。或者，检查子节点是否有一个右兄弟，且其包含足够的关键字 ❹，如果是，执行与该兄弟的旋转 ❺。如果无法进行旋转并且有左兄弟 ❻，则将其与子节点合并 ❼；否则，必定有一个右兄弟
    ❽，因此与它合并 ❾。再次强调，情况不复杂，但操作索引时需要小心；很容易出错。
- en: Considering Performance for B-trees
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑 B 树的性能
- en: A B-tree ensures that every node (apart from the root) will have a minimum number
    of children, so it grows exponentially as levels are added, meaning that the height
    is logarithmic; all paths from the root to another key will be *O*(log *n*), so
    all algorithms turn out to be logarithmic, as shown in [Table 13-1](chapter13.xhtml#tab13-1).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: B 树确保每个节点（根节点除外）至少有一定数量的子节点，因此随着层次的增加，它呈指数增长，意味着高度是对数的；从根节点到另一个关键字的所有路径都将是 *O*(log
    *n*)，因此所有算法的时间复杂度都呈对数增长，如 [表 13-1](chapter13.xhtml#tab13-1) 所示。
- en: 'Table 13-1: Performance of Operations for B-trees'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1：B 树操作的性能
- en: '| Operation | Performance |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Add | O(log n) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(log n) |'
- en: '| Remove | O(log n) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 移除 | O(log n) |'
- en: '| Find | O(log n) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(log n) |'
- en: '| Traverse | O(n) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 遍历 | O(n) |'
- en: B-trees ensure good performance, so they’re widely used, most notably to create
    indices for databases; in fact, the B-tree is the default structure for MySQL
    and PostgreSQL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: B 树确保良好的性能，因此被广泛应用，特别是在为数据库创建索引时；事实上，B 树是 MySQL 和 PostgreSQL 的默认结构。
- en: '### Red-Black Trees'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '### 红黑树'
- en: B-trees are powerful, but can be a bit complex to implement. However, you can
    work with them using a binary representation that produces the same results in
    a different way. In particular, we’ll use B-trees of order 3 but we’ll represent
    them in a binary tree style. The resulting *red-black trees* have very good performance
    and are used, among other places, in the Linux kernel to track directory entries,
    virtual memory, scheduling, and more. In this section we’ll look at left-leaning
    red-black trees, which are a variant created by Robert Sedgewick and are easier
    to implement than the original red-black tree.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*B-trees of order 3 are also known as 2-3 trees, alluding to the fact that
    their nodes have either two or three children. In the same way, B-trees of order
    4 are called 2-3-4 trees or 2-4 trees.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Consider the nodes in a red-black tree as 2-nodes (with two children) or 3-nodes
    (with three children). You can represent 2-nodes as common nodes in any binary
    tree, but here you’ll add an extra node to represent a 3-node (see [Figure 13-24](chapter13.xhtml#fig13-24)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-24.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-24: A red-black node is actually equivalent to a B-tree of order
    3.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The standard nodes are black, and the extra nodes added for 3-nodes are red,
    which allow you to distinguish 2-nodes from 3-nodes. You could also say that links
    between nodes are black if they point to a black node or red if they point to
    a red node.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Since this book is black and white, the “red” nodes will be gray with black
    text and the “black” nodes will be black with white text.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way representation was defined, red nodes are always to the left;
    in addition, a red node can never be connected to another red node (or, alternatively,
    you can’t have two red links in a row). Also, the root is black, and empty trees
    (leaves at the bottom) are also black.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s transform the B-tree we worked with earlier into a red-black tree
    (see [Figure 13-25](chapter13.xhtml#fig13-25)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-25.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-25: A B-tree that will be converted into a red-black tree'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: All 2-children nodes become black nodes and 3-children nodes add a new red node,
    as shown in [Figure 13-26](chapter13.xhtml#fig13-26).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-26.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-26: The equivalent red-black tree'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: You now have a binary search tree, which means you can use the earlier key-searching
    logic without any changes, but you do need to make adjustments when adding or
    removing keys.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Because of their B-tree origin, red-black trees have another important property.
    All paths from the root to a leaf have the same number of black nodes and up to
    that same number of red nodes. This property is called black balance, and we’ll
    often allude to it in this book.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how to implement these red-black trees, but keep in mind
    their equivalence to B-trees of order 3, because algorithms will make much more
    sense that way, essentially doing the same type of work from earlier in this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Representing Red-Black Trees
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Red-black trees are just binary search trees, so you can start with some functions
    you already have, such as the find() method and others that need no changes. For
    these new trees, you need a couple of constants and a method to flip a node’s
    color (you’ll use these frequently):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now start defining the new tree:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To represent a node’s color, add a color attribute ❶, which is red for new nodes,
    although that color may be changed to black later. You also add a couple of auxiliary
    methods to test a node’s color ❷ ❸. Notice you are defining that an empty tree
    is black.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a Red-Black Tree
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You are essentially just adding a key to a B-tree, which was described earlier.
    Always add nodes as red, which won’t affect the black balance of the tree, but
    you can possibly fix their color later or make other changes. Also take care that
    the root is always black and that all the properties of red-black trees are satisfied.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the algorithm, you’ll allow (for a while) problems like having
    right red links or two consecutive red links, but you’ll use rotations and color
    changes to fix those situations before you are done. Just add the key and worry
    about fixing problems later:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Add the key with an auxiliary _add() method ❶, which is the same algorithm as
    for common binary search trees with only one innovation, a call to a _fixUp()
    function ❷ that takes care of restoring the structure if there are any problems
    in it. The addition itself is done ❸; then first use _add() to add the new key
    to the tree ❹ and then make sure the root is black ❺.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Restoring a Red-Black Tree Structure
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the red-black structure has been damaged somehow, the trick to restoring
    it lies in the _fixUp() method. Remember a new node is always colored red. The
    possible cases when adding a new key depend on whether the new key ends up forming
    part of a 2-node or a 3-node.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The first situation is simple: if the new child is the left child of a black
    node, you just turned a 2-node into a 3-node, and since the red child is on the
    left of the root, everything’s okay. Call this case (a). Otherwise, if the new
    child is to the right of the black root, you can fix it with a rotation. Call
    this case (b). [Figure 13-27](chapter13.xhtml#fig13-27) shows both cases; N is
    the newly added key, and R is the original root for the 2-node.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-27.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-27: A rotation is needed if adding a node to the right.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: For case (a), nothing needs to be done, and a rotation to the left solves case
    (b). In both situations, the black balance of the whole hasn’t been affected.
    You didn’t add any black links, so everything’s still fine. Also, notice that
    the N node, originally red, has turned black.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The more complex case happens when you add the new key to an existing 2-node
    (thus creating a 3-node), because in this case, all situations are wrong. The
    (relatively) easiest case to fix is when the new key becomes the rightmost key
    in the 3-node, as shown in [Figure 13-28](chapter13.xhtml#fig13-28). Call this
    case (c).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-28.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-28: You can fix adding a new key to a 2-node tree by flipping colors,
    but new problems may appear above it.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a quick solution is available: just flip the three nodes’ colors. But
    notice that doing so will send a red link up the tree, which may require further
    recursive fixing. Also, verify that the black balance of the tree was maintained,
    so the fix is good.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The next case in terms of complexity is adding the newest key to the left of
    the leftmost one in a 3-node. Call this case (d); you need two steps to solve
    it, as shown in [Figure 13-29](chapter13.xhtml#fig13-29).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-29.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-29: Adding a child to the left of a left child can also be solved
    with rotations.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: If the new key is the lowest key in a 3-node, you have two left red children
    in a row. Start by doing a right rotation at the root, and that will leave you
    with the previous case (black root, two red children), so a final color flip will
    again solve the problem, although you may still need more recursive fixes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The final case (e) is the most complex. Add a new key that ends as the middle
    key, placed between the two existing keys in a 3-node, as shown in [Figure 13-30](chapter13.xhtml#fig13-30).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-30.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-30: You also can fix adding a child to the right of a left child
    with rotations plus color-flipping.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you end with a red node to the right of another red node, which
    is a no-no. You can solve the issue by starting a rotation to the left, which
    leaves you with a situation you’ve already dealt with, and finish with another
    rotation, this time to the right, to get a scenario you’ve seen twice before (black
    root with two red children), so a final color flip solves everything.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the rotations code, which is exactly the same as when we studied
    AVL trees in [Chapter 12](chapter12.xhtml), except we don’t need to maintain a
    height attribute:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The only additions are the two lines in bold that exchange colors.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll delve into the far more interesting code that applies all the fixes
    described (note that we’ll also use this code for removals; the same logic applies
    there):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the node you’re looking at has a red right child, do a rotation to the left
    ❶, which solves case (b) and is the first step for cases (c) and (e), which will
    be completed later, when you move up recursively. If you have a left red child
    and a left red grandchild ❷, this is case (d); you could also have arrived here
    after doing a rotation in case (e). Finally, after the previous changes, either
    you have fixed everything—if you were originally in cases (a) or (b)—or you still
    need to flip the color ❸, and you’re done.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another takeaway from this algorithm: color flipping and rotations
    to the left or to the right all retain the black balance in a tree, so if you
    start with a red-black tree and apply only those transformations, you’ll necessarily
    end with a red-black tree. This concept is important for additions, but you’ll
    also apply it for removals.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Red-Black Tree
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing a key from a red-black tree is probably the most complex algorithm
    discussed in this book. (Many textbooks and other resources tend to omit it or,
    at most, only hint at it.) While adding a key is not too complex, being basically
    the same algorithm as for common binary search trees (plus some logic to ascertain
    that certain constraints are being kept), deletion requires a more difficult process
    with changes both up and down the tree.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: You need to ensure that the key to be deleted is at the bottom of the tree as
    part of a 3-node (either the black or red node), because in that case, removing
    it causes no problem. If the key to be deleted is the red one, just take it off.
    If you want to delete the black one, put the red key in its place, but change
    the color to black to maintain balance. [Figure 13-31](chapter13.xhtml#fig13-31)
    shows both cases; X marks the key to be removed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-31.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-31: Removing a red leaf is direct, and removing the black root is
    also easy to achieve.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the process. Either do rotations or flip colors as you go down, so at
    all times, the node at the root either is red or has a red left child, and you’ll
    tolerate (for now) having red right children or black nodes with two red children.
    When you find the key you want, replace it with the following key (as with binary
    search trees) and then proceed to remove that key from the tree. When you find
    it, one of the two cases illustrated in [Figure 13-31](chapter13.xhtml#fig13-31)
    will apply, and you’ll effectively remove the key. Finally, apply the “fix-up”
    algorithm to go back to the root and take care of whatever problems might be left.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the invariant to uphold: either the root or its left child must be
    black. Assume that at some moment in the algorithm, you have to go down to the
    left. Obviously, if the root is black, you just go down to the left (which is
    red). The invariant will persist, and now the root will be red. However, if the
    left child is black, there are two cases, depending on the color of the root’s
    right child’s left child. If that child is black, you can just flip colors, as
    [Figure 13-32](chapter13.xhtml#fig13-32) shows (it doesn’t include other links
    or subtrees for clarity, so you can focus on the important nodes). The small triangle
    points to the new red node, which you’ll move left for the updated invariant.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-32.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-32: Color flipping adjusts this case.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the equivalent red-black tree, this is like joining nodes to create
    a 4-node, which you’ll need to split later.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'If the root’s right child’s left child had been red, you would have needed
    more steps: flipping, rotating right, rotating left, and flipping again. But after
    all those transformations (all of which maintain black balance), you’ll be able
    to go down the left: the root’s left child’s left child will be red, and again
    the invariant is maintained. [Figure 13-33](chapter13.xhtml#fig13-33) shows all
    the steps.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-33.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-33: The most complex case requires several rotations and color flips.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The initial tree is (a); (b) is the tree after flipping; (c) is after rotating
    the root’s right’s left child to the right; (d) is after rotating the root to
    the left; and finally, (e) is after flipping colors.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Considering the equivalent 2-3 tree, this deletion was like borrowing the 4-key
    from a 3-node to send the 3-key down to create a 3-node together with the 2-key.
    As before, you are maintaining black balance and there will be nothing to fix
    later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the other case, which is when you want to move right. This case
    is similar to the ones you just explored, but it’s a tad simpler. If the root
    is black and its right child is red, just move to it with no fuss. If the root
    is red, its left child is black, and the root’s left child’s left child is also
    black, you can just flip colors. Take a look at the situation shown in [Figure
    13-34](chapter13.xhtml#fig13-34).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-34.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-34: Color-flipping also fixes the potential 4-node tree.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: As before, this solution is equivalent to joining nodes and creating a 4-node
    tree, which will need to be fixed later.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The last case occurs when you need to move right and the root’s left child’s
    left child is red. You need to flip colors, do a rotation, and flip colors again
    to re-establish the invariant, as shown in [Figure 13-35](chapter13.xhtml#fig13-35).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-35.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-35: This complex case also requires both color flipping and rotations.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, (a) is the initial situation, (b) shows the flipped colors,
    (c) is after rotating the root to the right, and (d) is after flipping colors
    again.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Again, in terms of the original 2-3 tree, this example is like moving the 2-key
    up from the 3-node where it was to the place of the 3-key, which joins the 4-key
    into a 3-node. However, note that the final situation is not valid (there’s a
    red child to the right), so this will need to be fixed later.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete algorithm is based directly on Sedgewick’s own code, but blame
    any errors on me. The simple part is this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First apply the algorithm described to actually remove the key from the tree
    ❶ and then make sure the root is black ❷ unless, obviously, there’s no key and
    the tree became empty.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The complex part is the _remove() code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After verifying that the tree isn’t empty, check whether you need to go left
    ❶, and if so ❷, you may need to apply the transformations you saw earlier before
    actually moving left ❸. If the key you want to delete is greater than or equal
    to the root, start by doing a rotation ❹ so that the red node will be to the right,
    which you’ll need later. If you find the key ❺ and it has no right child, it must
    be at the bottom, so you can now delete it. You’ll want to move right, so set
    things up according to the procedures described earlier ❻ but don’t move just
    yet. If you find the key but aren’t able to delete it, replace it with the following
    key in the tree and move right to delete that value ❼; otherwise, just move right
    to keep looking for the key to be removed ❽. At the end, a final fix-up pass ❾
    solves any wrong configurations in the tree.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Red-black trees have the shortest code for searching and not very complex code
    for adding a new key (basically, just adding a fix-up call at the end), but the
    deletions are rather more involved. Getting the code right is difficult (see question
    13.10 for a small detail).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Red-Black Trees
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We don’t need to analyze the performance of red-black trees, because they’re
    just another case of B-trees, so you already know that all algorithms (adding,
    removing, and searching) are *O*(log *n*), as [Table 13-2](chapter13.xhtml#tab13-2)
    shows.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-2: Performance of Operations for Red-Black Trees'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n) |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n) |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| Find | O(log n) |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| Traverse | O(n) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: Of course, because of the possible embedded red links, red-black trees are taller
    on average than B-trees of higher orders (and not all paths from the root to a
    leaf have the same length), but that doesn’t change the result. Performance will
    still be logarithmic, even if searches are slower by a (bound) constant factor.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we moved beyond binary trees and explored two new structures
    for the dictionary ADT: B-trees and red-black trees (which are derived from B-trees).
    These structures provide good performance, and they’re used often because their
    implementation is not too complex and their speed is significant.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll study heaps, which are a variant of binary trees,
    and then in the following chapter, we’ll look at extended heaps, which combine
    heaps and forests to achieve high performance.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**13.1  Missing Test?**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: In the appendChild() method for trees, shouldn’t it include a call to this._throwIfEmpty()?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**13.2  Traversing General Trees**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Implement the missing preorder and postorder traversals. You might want to do
    this for both trees represented with arrays of children and for trees with a “left
    child, right sibling” representation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3  Nonrecursive Visiting**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Implement a depth-first traversal of a tree without recursion by using a stack
    as an auxiliary structure.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4  Tree Equality**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Implement an equals(tree1, tree2) algorithm that will decide whether two trees
    are equal—that is, having the same shape and the same keys in the same positions.
    You may want to “think outside the box” for this. Maybe you won’t even need recursion!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5  Measuring Trees**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Redo the calcSize() and calcHeight() functions from [Chapter 12](chapter12.xhtml)
    (see questions 12.5 and 12.6) to work with multiway trees.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**13.6  Sharing More**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: In a B-tree, instead of siblings sharing just one key, you can achieve a better
    balance if they share more keys. For example, when adding a key, if a node becomes
    too full and a sibling has enough space, instead of just passing a single key
    to it, pass as many as possible until both siblings are about equally full. A
    similar process would work when removing a key. Implement this optimization.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '**13.7  Faster Node Searching**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: This chapter used linear searching in nodes, but since keys are ordered, a better
    way would be using binary searching. Make this change. Would that make a difference
    in the order of the B-trees’ methods? Why or why not?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**13.8  Lowest Order**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Would B-trees of order 2 make sense?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**13.9  Many Orders of Trees**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'What would you do if you needed to work with B-trees of different orders? Hint:
    the problem here is that imported modules are singletons. Look for a way to avoid
    this behavior.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '**13.10  Safe to Delete?**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: In the remove() algorithm for red-black trees, when you actually delete a node,
    are you sure it’s possible to remove it without any negative effects?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
