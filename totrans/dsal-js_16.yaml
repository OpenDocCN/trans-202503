- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 13 TREES AND FORESTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters we explored binary trees that have the restriction of only
    two children per node. In this chapter, we’ll consider some new structures that
    go beyond that restriction, such as forests and orchards (when working with a
    single tree isn’t enough). After that, we’ll move on to study B-trees and red-black
    trees for faster searching.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Trees and Forests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Binary trees* can be empty or consist of a node (the root) and two children,
    which are both binary trees themselves. In particular, *binary search trees* are
    also *ordered* trees, because we define a certain order between children and distinguish
    the left child from the right child.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s expand on those concepts. First, you’ll allow a node to have many children,
    not just two—in other words, nodes can have degrees greater than 2\. You may have
    trees with a specific number of (possibly empty) children per node, as binary
    or ternary trees, but in general, no restrictions are placed on the degree of
    a node. Sometimes trees with an unspecified maximum degree are called *multiary*
    or *multiway*.
  prefs: []
  type: TYPE_NORMAL
- en: Moving beyond single trees, a *forest* is defined as a set of disjointed trees.
    For instance, you could consider the directory for a given hard drive in your
    computer to be a tree, but all the different pieces of storage (like hard drives
    or USB sticks) in your computer would make up a forest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even go further and define an *orchard* as a forest with an ordered
    relationship between its trees. In a forest, trees are strewn around in a disordered
    manner, but an orchard has a well-defined layout. Continuing with the computer
    example, if you assign letters to your drives (C:, D:, and so on, Microsoft Windows
    style), your storage actually is an orchard. The forestry-related terms do not
    end here: you can also have *groves*, which are like trees, with the exception
    that their nodes can have links to other nodes, which would turn the data structure
    into a directed (and possibly cyclic) graph.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To simplify the terminology in this chapter, we’ll use the terms forests (when
    no particular order is implied among the trees) and ordered forests (rather than
    orchards), which is the terminology most textbooks use. Also, in this chapter
    we won’t work with groves at all.*'
  prefs: []
  type: TYPE_NORMAL
- en: Representing Trees with Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do you know how to represent a general tree? How about a forest? Let’s start
    with trees, because by doing so we’ll discover a tip for dealing with forests.
    The first solution you’ll probably think of is having an array to point at each
    child, and in JavaScript with varying-length dynamic arrays, that’s the simplest
    solution. [Figure 13-1](chapter13.xhtml#fig13-1) shows a generic tree where the
    nodes have different degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A generic tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement such a tree, add an array of subtrees to each node, resulting
    in something like the following (in terms of JavaScript, this code varies a bit
    from the style of the book and represents trees with a class, which lets you use
    a standard interface like the Document Object Model [DOM] node interface):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A key field ❶, which also doubles as a flag, decides whether a tree is empty
    ❸, and an array of children ❷ is empty by default. The _throwIfEmpty() method
    ❹ detects incorrect accesses to empty trees (this is used in several methods).
    You also add a getter ❺ and a setter ❻ for the tree’s key. Then add some getters
    to check whether a node is a leaf with no children ❼ and, if not, to get its children
    ❽, in particular, accessing its first ❾ and last ❿ child, mimicking well-known
    DOM node-related methods.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more details on the DOM node interface, visit* [https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node](https://developer.cdn.mozilla.net/en-US/docs/Web/API/Node)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: You could consider adding more methods to the tree, but you would need some
    extra fields to reproduce certain methods, such as parentNode or previousSibling.
    We’ll see some ways to achieve those things later in the chapter. Now you can
    represent general trees and access their nodes, so next take a look at how to
    add or remove data to update trees.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Nodes to a Tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, add a new child in a specific place among its siblings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To add a new key, all you need to specify is its position among its siblings;
    by default, you’ll add it at the end ❶. If the tree is empty (no root), you throw
    an error ❷, and you also do that if the index lies beyond the limits of the current
    array of children ❸. If everything’s okay, just create a new tree ❹, place the
    new key as its root, and place the tree in the correct position among its siblings
    ❺, ending by allowing chaining, as in other previous cases ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appending a node is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You just depend on the default parameters for addChild(), which also test whether
    the tree has a root. No special code needed here.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Nodes from a Tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To remove a given child, you need only a test and some array manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After verifying that the tree has a root and isn’t empty ❶, check whether the
    index of the child to remove is valid or not ❷. If it is valid, do some array
    manipulation to remove the child from among its siblings ❸. End by enabling chaining
    as when adding a node ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Trees with Binary Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Representing trees with arrays works well, but another way of dealing with
    trees uses a simpler kind of tree, a binary tree. The trick is to use the left
    and right pointers in a different way from before: the left one will point to
    the first child, and the right one will point to the next sibling.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you are wondering whether this technique is purely academic or if you’ll
    ever use it in reality, we’ll be doing so in [Chapter 15](chapter15.xhtml) when
    studying binomial heaps and their variants.*'
  prefs: []
  type: TYPE_NORMAL
- en: Revisit the tree shown in [Figure 13-1](chapter13.xhtml#fig13-1). An alternative
    representation would have each node’s left link pointing to the node’s first child,
    and the right links would create a list of the node’s siblings. (As with all the
    other diagrams in this book, left and right null pointers are omitted for clarity.)
    If you rearrange and rotate the image 45 degrees, so the left pointers actually
    point down, the scheme becomes clearer, as shown in [Figure 13-2](chapter13.xhtml#fig13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: A tree represented with the “left-child, right-sibling” style'
  prefs: []
  type: TYPE_NORMAL
- en: Many structures use this *left-child, right-sibling* convention, but it’s better
    to rename the left pointer to *down* for clarity; *right* will still point to
    siblings. As for algorithms (adding or removing values and so on), you won’t need
    to do anything different from what you learned about binary trees in [Chapter
    12](chapter12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Representing Forests'
  prefs: []
  type: TYPE_NORMAL
- en: You can extend these methods for representing trees to represent forests. If
    you use arrays for pointers, you can simply have an array of roots, each pointing
    to a specific tree (we’ll see this concept again in [Chapters 14](chapter14.xhtml)
    and [15](chapter15.xhtml) when discussing binomial and Fibonacci heaps, so consider
    [Figure 13-3](chapter13.xhtml#fig13-3) to be a minor spoiler).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: A forest, represented with an array of roots'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the forest is an array with a pointer to the root of each individual
    tree. If you prefer the binary tree representation, you can do two different things:
    consider that all roots are siblings or add a fictitious “super-root” that has
    all the forest trees as subtrees. The first is the usual representation, which
    would give something like the forest in [Figure 13-4](chapter13.xhtml#fig13-4)
    (this is the same forest as shown in [Figure 13-3](chapter13.xhtml#fig13-3)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: An alternative representation of the same forest; the roots are
    linked to the right.'
  prefs: []
  type: TYPE_NORMAL
- en: To access this forest, you need a pointer to the leftmost root; from there,
    you can access all the trees. You can go even further by making the list of siblings
    circular and doubly linked; we’ll explore this later and see why those enhancements
    (and complications) are actually needed.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When studying binary search trees in [Chapter 12](chapter12.xhtml), we looked
    at three different ways of traversing trees by “visiting” all the nodes according
    to various schemes. With general trees, you don’t have all those methods, but
    we’ll add new ones. But first review the traversals we’ve done before and adapt
    two of them to the general tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preorder **For binary trees, *preorder* means first visiting the root, then
    traversing its left subtree, and finally traversing its right subtree. You can
    adapt this for general trees by first visiting the root and then traversing each
    of its subtrees in order.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Postorder **The *postorder* method for binary trees is similar to preorder,
    but it first visits the root’s left subtree, then the right, and finally the root
    itself. The adaptation requires first traversing all the root’s children in order
    and finally visiting the root itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inorder **The *inorder* method doesn’t really have an equivalent. For binary
    trees, it means first traversing the left subtree, then visiting the root, and
    finally traversing the right subtree. However, for general trees, you don’t have
    any reasonable alternative, so you can forgo this traversal (although for B-trees,
    discussed later in this chapter, you do have a possible inorder version).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coding preorder and postorder traversals is fairly straightforward, and the
    versions used for binary trees require only minor changes (we’ll consider their
    implementations in the questions at the end of this chapter). Two new methods,
    however, are worth studying and also appear in other types of algorithms, such
    as game playing or function optimization: *depth-first* and *breadth-first* traversals.'
  prefs: []
  type: TYPE_NORMAL
- en: Depth-First Traversal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The possibly most logical traversal to implement requires visiting the root
    first and then traversing all its children using the same algorithm. In effect,
    it’s equivalent to going as deeply as possible into a branch before moving on
    to another branch—thus, the name *depth first*. [Figure 13-5](chapter13.xhtml#fig13-5)
    shows an example of such a traversal; the numbers in the nodes reflect the order
    in which the visits occur.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: A depth-first traversal of a tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of algorithm is a classic one, generally used for searches or games.
    For instance, if you’re trying to get out of a maze, you’d follow some path until
    you either exit (and finish) or become blocked, in which case you go back to try
    another option. (See “Finding a Path in a Maze” on [page 69](chapter5.xhtml#pg_69).)
    Similarly, in games, you consider some sequence of movements as far as you can
    (because of time limitations), and if you haven’t found a winning line, you go
    back to try another one. The logic looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm is similar to some that you wrote for binary trees in [Chapter
    12](chapter12.xhtml). First, define a default visit() function ❶ that just lists
    the node’s key, and if the tree isn’t empty ❷, visit its root ❸. Then proceed
    to visit all of its children recursively, depth first ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-First Traversal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The alternative way to traverse trees is breadth first, which is a traversal
    style that you haven’t yet met. (This type of traversal is also called *level
    order* for reasons that will become apparent.) The idea is that you start at the
    root; then, you visit all of its children in the next level. Then (and only then),
    you visit the children’s children at the second level of the tree, and so on.
    You never visit a node until you’ve already visited all the nodes closer to the
    root, going down level by level, one by one. [Figure 13-6](chapter13.xhtml#fig13-6)
    shows such a traversal for a generic tree. Again, the numbers reflect the order
    in which the nodes are visited, and you can verify that each level is fully visited
    before starting the next level.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: A breadth-first traversal of a tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this strategy requires using a queue, as discussed in [Chapter
    10](chapter10.xhtml). As you start visiting nodes “horizontally,” you need to
    remember to visit their children later, so a queue with a first in, first out
    (FIFO) strategy works. You can code this as an independent function just for variety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As with other traversals, a default visit() function ❶ logs the node’s key.
    If the tree to be traversed isn’t empty ❷ (in which case you wouldn’t have to
    do anything), initialize a queue ❸ by pushing the tree’s root ❹. The rest of the
    algorithm is straightforward: while the queue hasn’t been emptied ❺, you pop its
    top ❻, visit that node ❼, and push all of its children into the queue for future
    visits ❽.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm isn’t recursive at all, which isn’t common for trees and other
    recursively defined structures. There’s an interesting sort of symmetry here:
    visiting a tree breadth first without recursion requires using a queue, and visiting
    it depth first without recursion needs a stack; see question 13.3.'
  prefs: []
  type: TYPE_NORMAL
- en: B-trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: B-trees have a self-adjusting tree structure with assured logarithmic performance
    for additions, removals, and searches, so in that sense, you could consider them
    an extension of height-balanced binary search trees—and a better-performing one
    at that. A key characteristic of these trees is that nodes can have more than
    two children, which allows for wider, shorter trees with faster searches.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Nobody really knows what the B in B-tree stands for. This structure was defined
    in 1972 by Rudolf Bayer and Edward McCreight, but no explanation was given for
    the term, so you can choose your own interpretation: some proposals have been
    “balanced,” “broad,” “bushy,” and, obviously, “Bayer.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition (and implementation) for a B-tree varies among different sources
    and authors, so let’s make clear what is used here. A B-tree of order *m* satisfies
    the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Every node has *p* < *m* keys, in ascending order, and *p* + 1 children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every node but the root must have at least *m*/2 (rounded up) children, or in
    other words, all nodes (except the root) should be at least half full.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root should have at least one key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All leaves must be at the same level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The B-tree is structured in a fashion similar to a binary search tree: given
    any key in a node, all the children to its left will be smaller than the key,
    and all the children to its right will be greater than it. For instance, you could
    have a node such as the one shown in [Figure 13-7](chapter13.xhtml#fig13-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: A B-tree node, showing where keys are to be found'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the node has four keys, so five children. The first child, to
    the left of the 34 key, has keys less than 34; the child between 34 and 40 has
    keys between those two values, and so on, until the last child, the one to the
    right of the 60 key, has keys greater than that value. (These facts are what we’ll
    use to search in a B-tree; you’ll see the algorithm soon.) This structure is similar
    to binary search trees, except that now instead of a maximum of two children per
    node, we allow a greater number—and for actual implementations (such as an index
    for actual files in disk), much larger values are preferred in order to have a
    shorter height and thus faster access.
  prefs: []
  type: TYPE_NORMAL
- en: Defining B-trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start in similar fashion as with binary search trees by defining the
    basic functions we’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define B-trees of any order, and we’ll use a variable ORDER ❶ to store
    the one you want. The first time you create a B-tree ❷, you’ll store the desired
    order (or 3, by default), so all future B-trees will have that order. (This decision
    begs the question: What if you want to have B-trees of *different* orders? See
    question 13.9.) The newNode() function ❸ creates a new node with a single null
    key by default, flanked by two null pointers; of course, this node will be “too
    empty,” unless ORDER is small. Note, however, that if you provide an array of
    keys ❹, some JavaScript trickery is used to generate (if needed) a corresponding
    array of null pointers, with one key more; can you see how this works?'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a couple of auxiliary functions will come in handy. At times, you’ll
    need to test whether a node is oversized (or would be, if d keys were added to
    it), with more keys than allowed ❺, and _tooBig() will check that. Similarly,
    _tooSmall() determines whether the node is undersized (or would be, if d keys
    were removed from it) and doesn’t have enough keys ❻. (Be careful not to apply
    _tooSmall() to the root—the only node that is allowed to be smaller.) You’ll use
    those two methods when adding or removing keys.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a Key in a B-tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the most basic algorithm: searching for a key. In a sense,
    the algorithm is similar to searching a binary search tree; you look for the key,
    and if you don’t find it in a node, you determine where to continue searching.
    Consider some examples. Assume you have the following B-tree of order 3; null
    links are represented with blank boxes, as shown in [Figure 13-8](chapter13.xhtml#fig13-8).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: A B-tree of order 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were looking for 22, that would be easy: it’s in the root, so there’s
    nothing to do. You can make it more complex and look for 56, as shown in [Figure
    13-9](chapter13.xhtml#fig13-9).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: The search process for key 56'
  prefs: []
  type: TYPE_NORMAL
- en: Start at the root, and since 56 > 22, follow the root’s last pointer to a new
    node. There, you find that 56 should be between 34 and 60, so follow the middle
    pointer to yet another node. In that one, you finally find 56, so the search is
    successful.
  prefs: []
  type: TYPE_NORMAL
- en: What about searching for a key that isn’t in the tree? If you had been looking
    for 38, everything would be the same as for 56, but upon not finding 38 in the
    node with 40 and 56, you would have continued down the first pointer of the node
    (since 38 < 40), but finding it null, the search would have been unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now on to the algorithms. Every time you get to a node, you need to see whether
    the key you want is there; if not, the algorithm tells you what pointer to follow
    to the next level; there is an auxiliary function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks for the first element in the keys array that is greater than or
    equal to the key you are searching ❶. If no key fits, findIndex() returns -1,
    so in that case, you return the index of the last element of ptrs (you’ll see
    the reason for this tricky code soon enough):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you are searching for a key and arrive at an empty node ❶, the key obviously
    isn’t there. Otherwise, the _findIndex() method finds the first key that isn’t
    less than the searched-for key ❷. If the key is actually equal to the value you
    want to find ❸, you are done; otherwise, continue the search at the corresponding
    pointer. This is why you had _findIndex() return the last position in the array—because
    that’s the link you need to follow when the key you want to find is greater than
    all the keys in the node.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem like a backward step to do a linear search when you have already
    seen better ways of searching; see question 13.7 for some ideas on better ways
    of searching.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a B-tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can define the equivalent to the inorder traversal for binary trees, which
    means visiting all keys in ascending order. Since each node has several keys,
    you need to work carefully. [Figure 13-10](chapter13.xhtml#fig13-10) shows how
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-10: A traversal for B-trees, similar to inorder for binary trees'
  prefs: []
  type: TYPE_NORMAL
- en: This version of inorder should visit keys in ascending order, so with the node
    in [Figure 15-9](chapter15.xhtml#fig15-9), start with the first (leftmost) child,
    then visit the node’s first key, followed by the second child, then the second
    key, then the third child, then the third key, and so on, ending after having
    traversed the rightmost child.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a version of it at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the current node is empty ❶, do nothing; otherwise, do a loop ❷, alternating
    between traversing a child ❸ and visiting a key ❹. For the latter, remember that
    there’s one fewer key than children. This code uses the condition && expression
    syntax as a shortcut to an if or ternary operator: expression is evaluated if
    and only if condition is true; in this case, visit a key if and only if the corresponding
    index is within the array of keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a B-tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now consider how to add a key. If you want to add a key to a node that has enough
    empty space, it’s straightforward. The problem is trying to add a key to a node
    that’s already too full to allow another key. Consider both cases using the B-tree
    of order 3 from earlier as an example (see [Figure 13-11](chapter13.xhtml#fig13-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: A B-tree into which you’ll add some new keys'
  prefs: []
  type: TYPE_NORMAL
- en: First, try to add a 66 key. After searching, you decide it should go with the
    63 key, and since that node has enough space, there’s no extra work (see [Figure
    13-12](chapter13.xhtml#fig13-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-12: Adding a key at a node with space causes no problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Now make things more complicated, and add a 10 key. That’s a problem, because
    the bottom-left node has no more space. First, you can let it grow beyond its
    maximum size (see [Figure 13-13](chapter13.xhtml#fig13-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-13: Adding a key at a node at limit requires splitting the node and
    rotating a key up.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to split the oversized node in two and make its middle key go up
    to the parent node. Fortunately, that node has space, so you are done (see [Figure
    13-14](chapter13.xhtml#fig13-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-14: After the split, the B-tree structure is okay again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to add a 78 key, this node would split twice: first, the 66 key
    would go up to the 34-60 node, and then that node would split, sending its middle
    key (60) to its parent. This is the only way a B-tree can grow: if its root needs
    splitting, it adds a new level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the code and see what happens at the root level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The easiest case is if the tree is empty ❶, because then all you need to do
    is create a new node with the new key and a couple of null pointers. Otherwise,
    add the key somewhere in the tree ❷ (using an auxiliary recursive _add() method,
    which will see it immediately), and check whether the root became too big ❸. If
    so, create two new nodes ❹ ❺, each with half the keys and pointers, leaving the
    middle key at the root ❻, which will have the two new nodes as children ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how is the new key actually added, and what’s the _add() method missing
    earlier? Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First find in which subtree of the current node to add the new key ❶. If the
    subtree doesn’t exist (the corresponding pointer is null), you are at the bottom
    level and can simply add the key there ❷; no need to do anything else. (Of course,
    the bottom node may have grown too large, but that will be checked by its parent,
    which will fix the situation if needed.) If there is a subtree ❸, recursively
    add the new key into it ❹ and then check whether the child grew too large ❺. If
    so, you need to add a new node that will get the second half of the keys and pointers
    of the outsized node ❻; the middle key and pointer to the new node will go up
    to the parent ❼, and you’ll leave the first half of the keys and pointers in the
    original child ❽. The code isn’t particularly hard to understand, but handling
    indices and arrays properly requires care.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a B-tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adding a key introduces the complexity that sometimes a node grows too big,
    and dealing with that requires either rotating or moving a key up. Removing a
    key also causes difficulties, because nodes may become too empty and need to get
    keys from other nodes or eventually require a key from the parent, which may make
    the whole B-tree shorter; in the same way that additions may cause it to grow
    taller, removals may lower its height.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several possible cases to study, but here are two: removing a key
    that isn’t in a leaf and removing a key that is in a leaf.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Nonleaf Node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Removing a key in an internal node is easy; it’s the same as for binary search
    trees. Replace the key with the one that follows it in ascending order and then
    remove *that* key (which will be at a leaf) from the tree. For instance, assume
    you want to remove the 22 key from the tree in [Figure 13-15](chapter13.xhtml#fig13-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-15: A B-tree from which you’ll remove a key not from a leaf—in this
    case, the 22'
  prefs: []
  type: TYPE_NORMAL
- en: You first need to locate the key following 22, so follow the link after 22 and
    then continue following the leftmost link until you get to a leaf to find the
    24 key (see [Figure 13-16](chapter13.xhtml#fig13-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-16: To remove 22, first locate the following (greater) key, which
    is 24 in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, replace the key to be removed (22) with the following key (24) and proceed
    with the logic to remove a key from a leaf node (marked in gray in [Figure 13-17](chapter13.xhtml#fig13-17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-17: After moving 24 to the place of the 22, you now need to remove
    the 24 from the leaf node.'
  prefs: []
  type: TYPE_NORMAL
- en: With this method, you always have to remove keys from a leaf node. Here’s how
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Leaf Node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After finding the key to remove and checking that it’s in a leaf node, you
    have two possible cases: either the node is “full enough,” so removing the key
    won’t make it too empty, or the node is at its minimum size, which means removing
    the key will leave it undersized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first case is easy to handle: continuing the example from the previous
    section, to remove the 24 key, just remove it from the node, which has enough
    keys (see [Figure 13-18](chapter13.xhtml#fig13-18)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-18: If after removal the leaf node still has enough keys, you’re
    done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But consider a more complicated case: What happens if you want to remove the
    12 key? You have a problem, because the corresponding node would end up with not
    enough keys, as shown in [Figure 13-19](chapter13.xhtml#fig13-19). (In this case,
    the node gets emptied, because you are dealing with a B-tree of order 3; in a
    B-tree of a higher order, the node would still have some keys, but just not enough.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-19: An attempt to rotate keys from a sibling to reorganize the B-tree'
  prefs: []
  type: TYPE_NORMAL
- en: The solution here depends on the node’s siblings. You can try to borrow keys
    from one of them and check whether it’s possible to borrow from the left or right
    sibling; both siblings are symmetrical. In this case, the left sibling has enough
    keys (4 and 9), so you borrow one from it. The 9 key goes into the parent node,
    and the 11 key is rotated down into the leaf (see [Figure 13-20](chapter13.xhtml#fig13-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-20: A rotation fixed the problem, so you’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have only one pending case to deal with: What happens if no sibling has
    keys to share? In that scenario, merge the node with a sibling, borrowing one
    key from the parent. This step may cause it to become undersized as well and need
    to be fixed. In this example, say you want to remove the 11 key. Merge it with
    its sibling and borrow the 9 key, reaching the situation shown in [Figure 13-21](chapter13.xhtml#fig13-21).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-21: The leaf node was fixed, but a problem appears above it.'
  prefs: []
  type: TYPE_NORMAL
- en: To solve the new undersized node situation, you again turn to the borrowing
    concept, rotate keys around, and the final tree would look like [Figure 13-22](chapter13.xhtml#fig13-22).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-22: A new rotation fixes the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: When doing this sharing and joining, it’s possible that eventually the tree
    will grow shorter in height. If you removed the 4 and 9 keys in succession, you’d
    arrive at the tree in [Figure 13-23](chapter13.xhtml#fig13-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-23: Removing several keys can make a B-tree eventually grow shorter.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you do the intermediate steps?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the remove() Method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now that you’ve seen all the strategies to apply, here’s how to code them.
    Dealing with a removal at the root level is short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First use a _remove() function to remove the key from the tree recursively ❶.
    If the tree is empty, or if the root node has been left with no keys (because
    it had a single key and had to pass it down when its two children got joined),
    but the node still has one non-null child (the root might already be at the bottom
    level, without children) ❷, return that child. This means the B-tree has become
    shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now start the actual key removal process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Start as when doing a search: if the tree is empty, you’re done ❶. Otherwise,
    see whether the current node includes the key you want to remove ❷. If you find
    the key and are at the bottom level ❸, just remove that key and its corresponding
    pointer ❹; otherwise, if you are at a higher level, find the next key in ascending
    order ❺ using _findMin() and put it in place of the original key you wanted to
    remove ❻. Finish by removing the next key from the tree ❼ and fixing its size
    ❽ if needed (because the child became too small, with not enough keys in it).
    If the key wasn’t in the node, go down to the next level to remove it ❾ and fix
    the size if necessary ❿.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you find the next key? You have seen similar methods before, and for
    B-trees, the code is also quite short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If there’s no leftmost subtree, return the first key in the node; otherwise,
    go down to the subtree and look for the minimum there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method is _fixChildIfSmall(), which deals with all the cases mentioned
    before and properly rebalances nodes. The following includes four distinct cases,
    but the logic for each of them is short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, just verify whether the child is still big enough ❶, and if so, nothing
    needs to be done. Then, check whether the child has a left sibling that won’t
    become too empty if you take one key from it ❷; if this is the case, do a rotation
    of keys as described earlier ❸. Alternatively, check whether the child has a right
    sibling with enough keys ❹, and if so, do the rotation with that sibling ❺. If
    no rotation was possible and if there is a left sibling ❻, join it to the child
    ❼; otherwise, there must be a right sibling ❽, so join the child with it instead
    ❾. Again, the cases are not complex, but take care when manipulating indices;
    it’s easy to get things wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for B-trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A B-tree ensures that every node (apart from the root) will have a minimum number
    of children, so it grows exponentially as levels are added, meaning that the height
    is logarithmic; all paths from the root to another key will be *O*(log *n*), so
    all algorithms turn out to be logarithmic, as shown in [Table 13-1](chapter13.xhtml#tab13-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-1: Performance of Operations for B-trees'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Find | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Traverse | O(n) |'
  prefs: []
  type: TYPE_TB
- en: B-trees ensure good performance, so they’re widely used, most notably to create
    indices for databases; in fact, the B-tree is the default structure for MySQL
    and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: '### Red-Black Trees'
  prefs: []
  type: TYPE_NORMAL
- en: B-trees are powerful, but can be a bit complex to implement. However, you can
    work with them using a binary representation that produces the same results in
    a different way. In particular, we’ll use B-trees of order 3 but we’ll represent
    them in a binary tree style. The resulting *red-black trees* have very good performance
    and are used, among other places, in the Linux kernel to track directory entries,
    virtual memory, scheduling, and more. In this section we’ll look at left-leaning
    red-black trees, which are a variant created by Robert Sedgewick and are easier
    to implement than the original red-black tree.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*B-trees of order 3 are also known as 2-3 trees, alluding to the fact that
    their nodes have either two or three children. In the same way, B-trees of order
    4 are called 2-3-4 trees or 2-4 trees.*'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the nodes in a red-black tree as 2-nodes (with two children) or 3-nodes
    (with three children). You can represent 2-nodes as common nodes in any binary
    tree, but here you’ll add an extra node to represent a 3-node (see [Figure 13-24](chapter13.xhtml#fig13-24)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-24: A red-black node is actually equivalent to a B-tree of order
    3.'
  prefs: []
  type: TYPE_NORMAL
- en: The standard nodes are black, and the extra nodes added for 3-nodes are red,
    which allow you to distinguish 2-nodes from 3-nodes. You could also say that links
    between nodes are black if they point to a black node or red if they point to
    a red node.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Since this book is black and white, the “red” nodes will be gray with black
    text and the “black” nodes will be black with white text.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way representation was defined, red nodes are always to the left;
    in addition, a red node can never be connected to another red node (or, alternatively,
    you can’t have two red links in a row). Also, the root is black, and empty trees
    (leaves at the bottom) are also black.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s transform the B-tree we worked with earlier into a red-black tree
    (see [Figure 13-25](chapter13.xhtml#fig13-25)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-25: A B-tree that will be converted into a red-black tree'
  prefs: []
  type: TYPE_NORMAL
- en: All 2-children nodes become black nodes and 3-children nodes add a new red node,
    as shown in [Figure 13-26](chapter13.xhtml#fig13-26).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-26: The equivalent red-black tree'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a binary search tree, which means you can use the earlier key-searching
    logic without any changes, but you do need to make adjustments when adding or
    removing keys.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Because of their B-tree origin, red-black trees have another important property.
    All paths from the root to a leaf have the same number of black nodes and up to
    that same number of red nodes. This property is called black balance, and we’ll
    often allude to it in this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how to implement these red-black trees, but keep in mind
    their equivalence to B-trees of order 3, because algorithms will make much more
    sense that way, essentially doing the same type of work from earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Red-Black Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Red-black trees are just binary search trees, so you can start with some functions
    you already have, such as the find() method and others that need no changes. For
    these new trees, you need a couple of constants and a method to flip a node’s
    color (you’ll use these frequently):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start defining the new tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To represent a node’s color, add a color attribute ❶, which is red for new nodes,
    although that color may be changed to black later. You also add a couple of auxiliary
    methods to test a node’s color ❷ ❸. Notice you are defining that an empty tree
    is black.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a Red-Black Tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You are essentially just adding a key to a B-tree, which was described earlier.
    Always add nodes as red, which won’t affect the black balance of the tree, but
    you can possibly fix their color later or make other changes. Also take care that
    the root is always black and that all the properties of red-black trees are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the algorithm, you’ll allow (for a while) problems like having
    right red links or two consecutive red links, but you’ll use rotations and color
    changes to fix those situations before you are done. Just add the key and worry
    about fixing problems later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Add the key with an auxiliary _add() method ❶, which is the same algorithm as
    for common binary search trees with only one innovation, a call to a _fixUp()
    function ❷ that takes care of restoring the structure if there are any problems
    in it. The addition itself is done ❸; then first use _add() to add the new key
    to the tree ❹ and then make sure the root is black ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring a Red-Black Tree Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the red-black structure has been damaged somehow, the trick to restoring
    it lies in the _fixUp() method. Remember a new node is always colored red. The
    possible cases when adding a new key depend on whether the new key ends up forming
    part of a 2-node or a 3-node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first situation is simple: if the new child is the left child of a black
    node, you just turned a 2-node into a 3-node, and since the red child is on the
    left of the root, everything’s okay. Call this case (a). Otherwise, if the new
    child is to the right of the black root, you can fix it with a rotation. Call
    this case (b). [Figure 13-27](chapter13.xhtml#fig13-27) shows both cases; N is
    the newly added key, and R is the original root for the 2-node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-27: A rotation is needed if adding a node to the right.'
  prefs: []
  type: TYPE_NORMAL
- en: For case (a), nothing needs to be done, and a rotation to the left solves case
    (b). In both situations, the black balance of the whole hasn’t been affected.
    You didn’t add any black links, so everything’s still fine. Also, notice that
    the N node, originally red, has turned black.
  prefs: []
  type: TYPE_NORMAL
- en: The more complex case happens when you add the new key to an existing 2-node
    (thus creating a 3-node), because in this case, all situations are wrong. The
    (relatively) easiest case to fix is when the new key becomes the rightmost key
    in the 3-node, as shown in [Figure 13-28](chapter13.xhtml#fig13-28). Call this
    case (c).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-28: You can fix adding a new key to a 2-node tree by flipping colors,
    but new problems may appear above it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a quick solution is available: just flip the three nodes’ colors. But
    notice that doing so will send a red link up the tree, which may require further
    recursive fixing. Also, verify that the black balance of the tree was maintained,
    so the fix is good.'
  prefs: []
  type: TYPE_NORMAL
- en: The next case in terms of complexity is adding the newest key to the left of
    the leftmost one in a 3-node. Call this case (d); you need two steps to solve
    it, as shown in [Figure 13-29](chapter13.xhtml#fig13-29).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-29: Adding a child to the left of a left child can also be solved
    with rotations.'
  prefs: []
  type: TYPE_NORMAL
- en: If the new key is the lowest key in a 3-node, you have two left red children
    in a row. Start by doing a right rotation at the root, and that will leave you
    with the previous case (black root, two red children), so a final color flip will
    again solve the problem, although you may still need more recursive fixes.
  prefs: []
  type: TYPE_NORMAL
- en: The final case (e) is the most complex. Add a new key that ends as the middle
    key, placed between the two existing keys in a 3-node, as shown in [Figure 13-30](chapter13.xhtml#fig13-30).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-30: You also can fix adding a child to the right of a left child
    with rotations plus color-flipping.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you end with a red node to the right of another red node, which
    is a no-no. You can solve the issue by starting a rotation to the left, which
    leaves you with a situation you’ve already dealt with, and finish with another
    rotation, this time to the right, to get a scenario you’ve seen twice before (black
    root with two red children), so a final color flip solves everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the rotations code, which is exactly the same as when we studied
    AVL trees in [Chapter 12](chapter12.xhtml), except we don’t need to maintain a
    height attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only additions are the two lines in bold that exchange colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll delve into the far more interesting code that applies all the fixes
    described (note that we’ll also use this code for removals; the same logic applies
    there):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If the node you’re looking at has a red right child, do a rotation to the left
    ❶, which solves case (b) and is the first step for cases (c) and (e), which will
    be completed later, when you move up recursively. If you have a left red child
    and a left red grandchild ❷, this is case (d); you could also have arrived here
    after doing a rotation in case (e). Finally, after the previous changes, either
    you have fixed everything—if you were originally in cases (a) or (b)—or you still
    need to flip the color ❸, and you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another takeaway from this algorithm: color flipping and rotations
    to the left or to the right all retain the black balance in a tree, so if you
    start with a red-black tree and apply only those transformations, you’ll necessarily
    end with a red-black tree. This concept is important for additions, but you’ll
    also apply it for removals.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Red-Black Tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing a key from a red-black tree is probably the most complex algorithm
    discussed in this book. (Many textbooks and other resources tend to omit it or,
    at most, only hint at it.) While adding a key is not too complex, being basically
    the same algorithm as for common binary search trees (plus some logic to ascertain
    that certain constraints are being kept), deletion requires a more difficult process
    with changes both up and down the tree.
  prefs: []
  type: TYPE_NORMAL
- en: You need to ensure that the key to be deleted is at the bottom of the tree as
    part of a 3-node (either the black or red node), because in that case, removing
    it causes no problem. If the key to be deleted is the red one, just take it off.
    If you want to delete the black one, put the red key in its place, but change
    the color to black to maintain balance. [Figure 13-31](chapter13.xhtml#fig13-31)
    shows both cases; X marks the key to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-31: Removing a red leaf is direct, and removing the black root is
    also easy to achieve.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the process. Either do rotations or flip colors as you go down, so at
    all times, the node at the root either is red or has a red left child, and you’ll
    tolerate (for now) having red right children or black nodes with two red children.
    When you find the key you want, replace it with the following key (as with binary
    search trees) and then proceed to remove that key from the tree. When you find
    it, one of the two cases illustrated in [Figure 13-31](chapter13.xhtml#fig13-31)
    will apply, and you’ll effectively remove the key. Finally, apply the “fix-up”
    algorithm to go back to the root and take care of whatever problems might be left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the invariant to uphold: either the root or its left child must be
    black. Assume that at some moment in the algorithm, you have to go down to the
    left. Obviously, if the root is black, you just go down to the left (which is
    red). The invariant will persist, and now the root will be red. However, if the
    left child is black, there are two cases, depending on the color of the root’s
    right child’s left child. If that child is black, you can just flip colors, as
    [Figure 13-32](chapter13.xhtml#fig13-32) shows (it doesn’t include other links
    or subtrees for clarity, so you can focus on the important nodes). The small triangle
    points to the new red node, which you’ll move left for the updated invariant.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-32: Color flipping adjusts this case.'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the equivalent red-black tree, this is like joining nodes to create
    a 4-node, which you’ll need to split later.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the root’s right child’s left child had been red, you would have needed
    more steps: flipping, rotating right, rotating left, and flipping again. But after
    all those transformations (all of which maintain black balance), you’ll be able
    to go down the left: the root’s left child’s left child will be red, and again
    the invariant is maintained. [Figure 13-33](chapter13.xhtml#fig13-33) shows all
    the steps.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-33: The most complex case requires several rotations and color flips.'
  prefs: []
  type: TYPE_NORMAL
- en: The initial tree is (a); (b) is the tree after flipping; (c) is after rotating
    the root’s right’s left child to the right; (d) is after rotating the root to
    the left; and finally, (e) is after flipping colors.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the equivalent 2-3 tree, this deletion was like borrowing the 4-key
    from a 3-node to send the 3-key down to create a 3-node together with the 2-key.
    As before, you are maintaining black balance and there will be nothing to fix
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the other case, which is when you want to move right. This case
    is similar to the ones you just explored, but it’s a tad simpler. If the root
    is black and its right child is red, just move to it with no fuss. If the root
    is red, its left child is black, and the root’s left child’s left child is also
    black, you can just flip colors. Take a look at the situation shown in [Figure
    13-34](chapter13.xhtml#fig13-34).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-34: Color-flipping also fixes the potential 4-node tree.'
  prefs: []
  type: TYPE_NORMAL
- en: As before, this solution is equivalent to joining nodes and creating a 4-node
    tree, which will need to be fixed later.
  prefs: []
  type: TYPE_NORMAL
- en: The last case occurs when you need to move right and the root’s left child’s
    left child is red. You need to flip colors, do a rotation, and flip colors again
    to re-establish the invariant, as shown in [Figure 13-35](chapter13.xhtml#fig13-35).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure13-35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-35: This complex case also requires both color flipping and rotations.'
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, (a) is the initial situation, (b) shows the flipped colors,
    (c) is after rotating the root to the right, and (d) is after flipping colors
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Again, in terms of the original 2-3 tree, this example is like moving the 2-key
    up from the 3-node where it was to the place of the 3-key, which joins the 4-key
    into a 3-node. However, note that the final situation is not valid (there’s a
    red child to the right), so this will need to be fixed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete algorithm is based directly on Sedgewick’s own code, but blame
    any errors on me. The simple part is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First apply the algorithm described to actually remove the key from the tree
    ❶ and then make sure the root is black ❷ unless, obviously, there’s no key and
    the tree became empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complex part is the _remove() code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After verifying that the tree isn’t empty, check whether you need to go left
    ❶, and if so ❷, you may need to apply the transformations you saw earlier before
    actually moving left ❸. If the key you want to delete is greater than or equal
    to the root, start by doing a rotation ❹ so that the red node will be to the right,
    which you’ll need later. If you find the key ❺ and it has no right child, it must
    be at the bottom, so you can now delete it. You’ll want to move right, so set
    things up according to the procedures described earlier ❻ but don’t move just
    yet. If you find the key but aren’t able to delete it, replace it with the following
    key in the tree and move right to delete that value ❼; otherwise, just move right
    to keep looking for the key to be removed ❽. At the end, a final fix-up pass ❾
    solves any wrong configurations in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Red-black trees have the shortest code for searching and not very complex code
    for adding a new key (basically, just adding a fix-up call at the end), but the
    deletions are rather more involved. Getting the code right is difficult (see question
    13.10 for a small detail).
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Red-Black Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We don’t need to analyze the performance of red-black trees, because they’re
    just another case of B-trees, so you already know that all algorithms (adding,
    removing, and searching) are *O*(log *n*), as [Table 13-2](chapter13.xhtml#tab13-2)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-2: Performance of Operations for Red-Black Trees'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Find | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Traverse | O(n) |'
  prefs: []
  type: TYPE_TB
- en: Of course, because of the possible embedded red links, red-black trees are taller
    on average than B-trees of higher orders (and not all paths from the root to a
    leaf have the same length), but that doesn’t change the result. Performance will
    still be logarithmic, even if searches are slower by a (bound) constant factor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we moved beyond binary trees and explored two new structures
    for the dictionary ADT: B-trees and red-black trees (which are derived from B-trees).
    These structures provide good performance, and they’re used often because their
    implementation is not too complex and their speed is significant.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll study heaps, which are a variant of binary trees,
    and then in the following chapter, we’ll look at extended heaps, which combine
    heaps and forests to achieve high performance.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**13.1  Missing Test?**'
  prefs: []
  type: TYPE_NORMAL
- en: In the appendChild() method for trees, shouldn’t it include a call to this._throwIfEmpty()?
  prefs: []
  type: TYPE_NORMAL
- en: '**13.2  Traversing General Trees**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the missing preorder and postorder traversals. You might want to do
    this for both trees represented with arrays of children and for trees with a “left
    child, right sibling” representation.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3  Nonrecursive Visiting**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a depth-first traversal of a tree without recursion by using a stack
    as an auxiliary structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4  Tree Equality**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement an equals(tree1, tree2) algorithm that will decide whether two trees
    are equal—that is, having the same shape and the same keys in the same positions.
    You may want to “think outside the box” for this. Maybe you won’t even need recursion!
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5  Measuring Trees**'
  prefs: []
  type: TYPE_NORMAL
- en: Redo the calcSize() and calcHeight() functions from [Chapter 12](chapter12.xhtml)
    (see questions 12.5 and 12.6) to work with multiway trees.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.6  Sharing More**'
  prefs: []
  type: TYPE_NORMAL
- en: In a B-tree, instead of siblings sharing just one key, you can achieve a better
    balance if they share more keys. For example, when adding a key, if a node becomes
    too full and a sibling has enough space, instead of just passing a single key
    to it, pass as many as possible until both siblings are about equally full. A
    similar process would work when removing a key. Implement this optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.7  Faster Node Searching**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter used linear searching in nodes, but since keys are ordered, a better
    way would be using binary searching. Make this change. Would that make a difference
    in the order of the B-trees’ methods? Why or why not?
  prefs: []
  type: TYPE_NORMAL
- en: '**13.8  Lowest Order**'
  prefs: []
  type: TYPE_NORMAL
- en: Would B-trees of order 2 make sense?
  prefs: []
  type: TYPE_NORMAL
- en: '**13.9  Many Orders of Trees**'
  prefs: []
  type: TYPE_NORMAL
- en: 'What would you do if you needed to work with B-trees of different orders? Hint:
    the problem here is that imported modules are singletons. Look for a way to avoid
    this behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '**13.10  Safe to Delete?**'
  prefs: []
  type: TYPE_NORMAL
- en: In the remove() algorithm for red-black trees, when you actually delete a node,
    are you sure it’s possible to remove it without any negative effects?
  prefs: []
  type: TYPE_NORMAL
