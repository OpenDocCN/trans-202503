- en: '## **17'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **17'
- en: GHIDRA LOADERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GHIDRA 加载器**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: Except for a brief example demonstrating the Raw Binary loader in [Chapter 4](ch04.xhtml#ch04),
    Ghidra has identified the file type and happily loaded and analyzed all of the
    files we have thrown at it. This will not always be the case. At some point, you
    are likely to be confronted with a dialog like the one shown in [Figure 17-1](ch17.xhtml#fig17_1).
    (This particular file is shellcode, which Ghidra is unable to recognize, as there
    is no defined structure, meaningful file extension, or magic number.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[第4章](ch04.xhtml#ch04)中简要展示的原始二进制加载器示例外，Ghidra 已经识别了文件类型，并顺利加载并分析了我们投给它的所有文件。但这并非总是如此。在某些时候，你可能会遇到如[图
    17-1](ch17.xhtml#fig17_1)所示的对话框。（这个特定的文件是 shellcode，Ghidra 无法识别它，因为没有定义的结构、意义明确的文件扩展名或魔术数字。）
- en: '![image](Images/fig17-1.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-1.jpg)'
- en: '*Figure 17-1: Raw Binary loader example*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-1：原始二进制加载器示例*'
- en: 'So what happened when we tried to import this file? Let’s start with a high-level
    view of Ghidra’s process for loading a file:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们尝试导入这个文件时发生了什么呢？让我们从一个高层次的角度来看一下 Ghidra 加载文件的过程：
- en: In the Ghidra Project window, the user specifies a file to load into a project.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ghidra 项目窗口中，用户指定一个文件加载到项目中。
- en: The Ghidra Importer polls all of the Ghidra loaders, and each loader tries to
    identify the file. Each then responds with a list of load specifications to populate
    the Import dialog if it can load the file. (An empty list means “I can’t load
    this file.”)
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ghidra 导入器会轮询所有的 Ghidra 加载器，每个加载器尝试识别文件。如果可以加载文件，它们会响应并提供一份加载规范列表以填充导入对话框。（一个空列表意味着“我不能加载这个文件。”）
- en: The Importer collects responses from all of the loaders, builds a list of loaders
    that recognize the file, and presents a populated Import dialog to the user.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入器收集所有加载器的响应，构建一个识别该文件的加载器列表，并向用户展示一个已填充的导入对话框。
- en: The user chooses a loader and associated information for loading the file.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择加载器及其相关信息来加载文件。
- en: The Importer invokes the user-selected loader that then loads the file.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入器调用用户选择的加载器，然后加载该文件。
- en: For the file in [Figure 17-1](ch17.xhtml#fig17_1), none of the format-specific
    loaders responded with a “yes.” As a result, the task was passed to the only loader
    willing to take any file at any time—the Raw Binary loader. This loader performs
    almost no work, shifting the analysis burden to the reverse engineer. If you ever
    find yourself analyzing similar files that all appear to have the “raw” format,
    it may be time to build a specialized loader to help you with some or all of the
    loading process. Several tasks need to be undertaken to create a new loader that
    Ghidra can use to load a file in a new format.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[图 17-1](ch17.xhtml#fig17_1)中的文件，没有任何格式特定的加载器给出“是”的回应。因此，任务被交给了唯一一个愿意随时接受任何文件的加载器——原始二进制加载器。这个加载器几乎不做任何工作，把分析的负担转移给了逆向工程师。如果你在分析类似的文件时，发现它们都表现出“原始”格式，可能是时候构建一个专门的加载器来帮助你完成部分或全部的加载过程。创建一个新的加载器以便
    Ghidra 能够加载一种新格式的文件需要完成几个任务。
- en: In this chapter, we first walk you through analysis of a file whose format is
    not recognized by Ghidra. This will help you understand the process of analyzing
    an unknown file and also make a strong case for building a loader, which is how
    we will spend the second half of the chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将引导你分析一个 Ghidra 无法识别格式的文件。这将帮助你了解分析未知文件的过程，同时也为构建加载器提供有力的论据，我们将在本章的后半部分进行详细探讨。
- en: '### **Unknown File Analysis**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### **未知文件分析**'
- en: Ghidra includes loader modules to recognize many of the more common executable
    and archive file formats, but there is no way that Ghidra can accommodate the
    ever-increasing number of file formats for storing executable code. Binary images
    may contain executable files formatted for use with specific operating systems,
    ROM images extracted from embedded systems, firmware images extracted from flash
    updates, or simply raw blocks of machine language, perhaps extracted from network
    packet captures. The format of these images may be dictated by the operating system
    (executable files), the target processor and system architecture (ROM images),
    or nothing at all (exploit shellcode embedded in application layer data).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 包含多个加载模块，用于识别许多常见的可执行文件和归档文件格式，但 Ghidra 无法适应日益增加的用于存储可执行代码的文件格式数量。二进制映像可能包含针对特定操作系统格式化的可执行文件、从嵌入式系统中提取的
    ROM 镜像、从固件更新中提取的固件镜像，或者只是原始的机器语言块，可能是通过网络数据包捕获提取的。这些镜像的格式可能由操作系统（可执行文件）、目标处理器和系统架构（ROM
    镜像）或者根本没有任何格式（嵌入在应用层数据中的利用 shellcode）来决定。
- en: Assuming that a processor module is available to disassemble the code contained
    in the unknown binary, it will be your job to properly arrange the file image
    within Ghidra before informing Ghidra which portions of the binary represent code
    and which portions of the binary represent data. For most processor types, the
    result of loading a file using the raw format is simply a list of the contents
    of the file piled into a single segment, beginning at address zero, as shown in
    [Listing 17-1](ch17.xhtml#exa17_1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个处理器模块可以反汇编未知二进制文件中的代码，那么你的任务就是在 Ghidra 中正确安排文件镜像，并在告知 Ghidra 哪些二进制部分表示代码，哪些二进制部分表示数据之前完成此操作。对于大多数处理器类型，使用原始格式加载文件的结果通常只是一个包含文件内容的列表，这些内容堆积成一个单一段，从地址零开始，如
    [Listing 17-1](ch17.xhtml#exa17_1) 所示。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 17-1: Initial lines of an unanalyzed PE file loaded using the Raw
    Binary loader*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-1: 使用原始二进制加载器加载的未分析 PE 文件的初始行*'
- en: In some cases, depending on the sophistication of the selected processor module,
    some disassembly takes place. For example, a selected processor for an embedded
    microcontroller can make specific assumptions about the memory layout of ROM images,
    or an analyzer with knowledge of common code sequences associated with a specific
    processor can optimistically format any matches as code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，取决于所选处理器模块的复杂度，可能会进行一些反汇编。例如，为嵌入式微控制器选择的处理器可以对 ROM 镜像的内存布局做出特定假设，或者一个了解与特定处理器相关的常见代码序列的分析工具，可以乐观地将任何匹配的部分格式化为代码。
- en: When you are faced with an unrecognized file, arm yourself with as much information
    about the file as you can get your hands on. Useful resources might include notes
    on how and where the file was obtained, processor references, operating system
    references, system design documentation, and any memory layout information obtained
    through debugging or hardware-assisted analysis (such as via logic analyzers).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你面对一个无法识别的文件时，尽可能多地收集有关该文件的信息。有用的资源可能包括文件的获取方式和位置的说明、处理器参考、操作系统参考、系统设计文档以及通过调试或硬件辅助分析（例如通过逻辑分析仪）获得的任何内存布局信息。
- en: In the following section, for the sake of example, we assume that Ghidra does
    not recognize the Windows PE file format. PE is a well-known file format that
    many readers may be familiar with. More importantly, documents detailing the structure
    of PE files are widely available, which makes dissecting an arbitrary PE file
    a relatively simple task.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，为了举例说明，我们假设 Ghidra 无法识别 Windows PE 文件格式。PE 是一个广为人知的文件格式，许多读者可能对此有所了解。更重要的是，关于
    PE 文件结构的文档随处可得，这使得分析任意 PE 文件成为一项相对简单的任务。
- en: '### **Manually Loading a Windows PE File**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '### **手动加载 Windows PE 文件**'
- en: 'When you can find documentation on the format of a particular file, your life
    will be significantly easier as you attempt to use Ghidra to help you make sense
    of the binary. [Listing 17-1](ch17.xhtml#exa17_1) shows the first few lines of
    an unanalyzed PE file loaded into Ghidra using the Raw Binary loader and `x86:LE:32:default:windows`
    as its language/compiler specification.^([1](footnotes.xhtml#ch17fn1)) The PE
    specification states that a valid PE file begins with an MS-DOS header structure,
    beginning with the 2-byte signature, `4Dh 5Ah` (`MZ`), which we see in the first
    two lines of [Listing 17-1](ch17.xhtml#exa17_1).^([2](footnotes.xhtml#ch17fn2))
    The 4-byte value located at offset `0x3C` in the file contains the offset to the
    next header we need to find: the PE header.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你能找到某个文件格式的文档时，使用 Ghidra 帮助你理清二进制文件时将变得更加轻松。[列表 17-1](ch17.xhtml#exa17_1) 显示了使用
    Raw Binary 加载器加载并使用 `x86:LE:32:default:windows` 作为语言/编译器规范的未分析 PE 文件的前几行。^([1](footnotes.xhtml#ch17fn1))
    PE 规范规定，一个有效的 PE 文件应以 MS-DOS 头部结构开始，头部以 2 字节签名 `4Dh 5Ah`（`MZ`）开始，我们可以在 [列表 17-1](ch17.xhtml#exa17_1)
    的前两行看到这一点。^([2](footnotes.xhtml#ch17fn2)) 位于文件偏移量 `0x3C` 处的 4 字节值包含下一个头部的偏移量：PE
    头部。
- en: Two strategies for breaking down the fields of the MS-DOS header are (1) to
    define appropriately sized data values for each field in the MS-DOS header and
    (2) to use Ghidra’s Data Type Manager functionality to define and apply an `IMAGE_DOS_HEADER`
    structure in accordance with the PE file specification. We will look at the challenges
    associated with option 1 in an example later in the chapter. In this case, option
    2 requires significantly less effort.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 MS-DOS 头部字段的两种策略是：(1) 为每个字段定义适当大小的数据值；(2) 使用 Ghidra 的数据类型管理器功能，按照 PE 文件规范定义并应用
    `IMAGE_DOS_HEADER` 结构。我们将在本章后面的例子中探讨选项 1 相关的挑战。在这种情况下，选项 2 需要的工作量显著较少。
- en: 'When using the Raw Binary loader, Ghidra does not load the Data Type Manager
    with the Windows data types, so we can load the archive containing MS-DOS types,
    *windows_vs12_32.gdt*, ourselves. Locate the `IMAGE_DOS_HEADER` either by navigating
    to it within the archive or choosing CTRL-F to find it in the Data Type Manager
    window; then drag and drop the header onto the start of the file. You can also
    place the cursor on the first address in the listing and choose Data ▸ Choose
    Data Type (or hotkey T) from the right-click context menu and enter, or navigate
    to, the data type in the resulting Data Type Chooser dialog. Any of these options
    yields the following listing, with descriptive end-of-line comments describing
    each field:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Raw Binary 加载器时，Ghidra 并不会加载 Windows 数据类型的 Data Type Manager，因此我们可以自行加载包含
    MS-DOS 类型的归档文件 *windows_vs12_32.gdt*。通过在归档中导航或按 CTRL-F 在数据类型管理器窗口中查找，定位 `IMAGE_DOS_HEADER`；然后将头部拖动到文件的起始位置。你也可以将光标放置在列表中的第一个地址上，然后从右键菜单中选择
    Data ▸ Choose Data Type（或快捷键 T）并输入或导航到数据类型选择对话框中的数据类型。这些选项都会得到以下列表，并附有描述每个字段的行尾注释：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `e_lfanew` field in the final line of the previous listing has a value
    of `D8h`, indicating that a PE header should be found at offset `D8h` (216 bytes)
    into the binary. Examining the bytes at offset `D8h` should reveal the magic number
    for a PE header, `50h 45h` (`PE`), which indicates that we should apply an `IMAGE_NT_HEADERS`
    structure at offset `D8h` into the binary. Here is a portion of the resulting
    expanded Ghidra listing:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个列表中的最后一行 `e_lfanew` 字段的值为 `D8h`，这表示 PE 头部应该位于二进制文件的偏移量 `D8h`（216 字节）处。检查偏移量
    `D8h` 处的字节应该能揭示出 PE 头部的魔术数字 `50h 45h`（`PE`），这表示我们应该在二进制文件的偏移量 `D8h` 处应用 `IMAGE_NT_HEADERS`
    结构。以下是 Ghidra 扩展列表的一部分：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, we have revealed a number of interesting pieces of information
    that will help us to further refine the layout of the binary. First, the `Machine`
    field ➊ in a PE header indicates the target processor type for which the file
    was built. The value `14Ch` indicates that the file is for use with x86 processor
    types. Had the machine type been something else, such as `1C0h` (ARM), we would
    need to close the CodeBrowser, right-click our file in the Project window to select
    the Set Language option, and choose the correct language setting.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经揭示了许多有趣的信息，有助于进一步完善二进制文件的布局。首先，PE 头部中的 `Machine` 字段 ➊ 表示文件构建时的目标处理器类型。值
    `14Ch` 表示该文件适用于 x86 处理器类型。如果机器类型是其他类型，例如 `1C0h`（ARM），我们需要关闭 CodeBrowser，右击项目窗口中的文件，选择
    Set Language 选项，然后选择正确的语言设置。
- en: The `ImageBase` field ➍ indicates the base virtual address for the loaded file
    image. Using this information, we can incorporate some virtual address information
    into the CodeBrowser. Using the Window ▸ Memory Map menu option, we are shown
    the list of memory blocks ([Figure 17-2](ch17.xhtml#fig17_2)) that make up the
    current program. In this case, a single memory block contains all of the program’s
    content. The Raw Binary loader has no means of determining appropriate memory
    addresses for any of our program’s content, so it places all of the content in
    a single memory block starting at address zero.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageBase` 字段 ➍ 指示加载文件镜像的基虚拟地址。利用这些信息，我们可以将一些虚拟地址信息整合到 CodeBrowser 中。通过“窗口
    ▸ 内存映射”菜单选项，我们可以看到当前程序的内存块列表（见 [图 17-2](ch17.xhtml#fig17_2)）。在这种情况下，单个内存块包含了程序的所有内容。原始二进制加载器无法为程序的任何内容确定合适的内存地址，因此它将所有内容放在从地址零开始的一个内存块中。'
- en: '![image](Images/fig17-2.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-2.jpg)'
- en: '*Figure 17-2: The Memory Map window*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-2：内存映射窗口*'
- en: The Memory Map window’s tool buttons, shown in [Figure 17-3](ch17.xhtml#fig17_3),
    are used to manipulate memory blocks. In order to properly map our image into
    memory, the first thing we need to do is set the base address specified in the
    PE header.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射窗口的工具按钮，如 [图 17-3](ch17.xhtml#fig17_3) 所示，用于操作内存块。为了正确地将我们的镜像映射到内存中，首先需要做的是设置
    PE 头中指定的基地址。
- en: '![image](Images/fig17-3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-3.jpg)'
- en: '*Figure 17-3: Memory Map window tools*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-3：内存映射窗口工具*'
- en: The `ImageBase` field ➍ tells us that the correct base address for this binary
    is `00400000`. We can use the Set Image Base option to adjust the image base from
    the default to this value. Once we click OK, all Ghidra windows will be updated
    to reflect the new memory layout of the program, as shown in [Figure 17-4](ch17.xhtml#fig17_4).
    (Be careful using this option after you already have multiple memory blocks defined;
    it will shift every memory block the same distance as the base memory block.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageBase` 字段 ➍ 告诉我们该二进制文件的正确基址是 `00400000`。我们可以使用“设置镜像基址”选项将镜像基址从默认值调整为该值。点击确认后，所有
    Ghidra 窗口将更新，以反映程序的新内存布局，如 [图 17-4](ch17.xhtml#fig17_4) 所示。（在已经定义了多个内存块的情况下使用此选项时需要小心，它会将每个内存块都移动与基内存块相同的距离。）'
- en: '![image](Images/fig17-4.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-4.jpg)'
- en: '*Figure 17-4: Memory Map after setting image base*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-4：设置镜像基址后的内存映射*'
- en: The `AddressOfEntryPoint` field ➌ specifies the relative virtual address (RVA)
    of the program entry point. In the PE file specification, an RVA is a relative
    offset from the program’s base virtual address, while the program entry point
    is the address of the first instruction within the program file that will be executed.
    In this case, an entry point RVA of `14E0h` indicates that the program will begin
    execution at virtual address `4014E0h` (`400000h + 14E0h`). This is our first
    indication of where we should begin looking for code within the program. Before
    we can do that, however, we need to properly map the remainder of the program
    to appropriate virtual addresses.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddressOfEntryPoint` 字段 ➌ 指定了程序入口点的相对虚拟地址（RVA）。在 PE 文件规范中，RVA 是从程序基虚拟地址的相对偏移量，而程序入口点是程序文件中将执行的第一条指令的地址。在本例中，`14E0h`
    的入口点 RVA 表明程序将在虚拟地址 `4014E0h`（`400000h + 14E0h`）处开始执行。这是我们开始在程序中查找代码的第一个指示。然而，在此之前，我们需要将程序的其余部分正确映射到适当的虚拟地址。'
- en: The PE format uses sections to describe the mapping of file content to memory
    ranges. By parsing the section headers for each section in the file, we can complete
    the basic virtual memory layout of the program. The `NumberOfSections` field ➋
    indicates the number of sections contained in a PE file (in this case, five).
    According to the PE specification, an array of section header structures immediately
    follows the `IMAGE_NT_HEADERS` structure. Individual elements in the array are
    `IMAGE_SECTION_HEADER` structures, which we define in the Ghidra structures editor
    and apply (five times, in this case) to the bytes following the `IMAGE_NT_HEADERS`
    structure. Alternatively, you can select the first byte of the first section header
    and set its type to `IMAGE``_SECTION_HEADER[`n`]`, where n is 5 in this example,
    to collapse the entire array into a single Ghidra display line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PE 格式使用节（sections）来描述文件内容与内存范围的映射。通过解析文件中每个节的节头，我们可以完成程序的基本虚拟内存布局。`NumberOfSections`
    字段 ➋ 表示 PE 文件中包含的节的数量（在本例中为五个）。根据 PE 规范，一组节头结构紧随 `IMAGE_NT_HEADERS` 结构之后。该数组中的每个元素都是
    `IMAGE_SECTION_HEADER` 结构，我们在 Ghidra 结构编辑器中定义，并将其应用（本例中为五次）到 `IMAGE_NT_HEADERS`
    结构之后的字节上。或者，您可以选择第一个节头的第一个字节，并将其类型设置为 `IMAGE_SECTION_HEADER[n]`，其中 n 在本例中为 5，从而将整个数组压缩为
    Ghidra 显示行中的一行。
- en: The `FileAlignment` field ➏ and the `SectionAlignment` field ➎ indicate how
    the data for each section is aligned within the file and how that same data will
    be aligned when mapped into memory. In our example, both fields are set to align
    on `1000h` byte offsets.^([3](footnotes.xhtml#ch17fn3)) In the PE format, there
    is no requirement that these two numbers be the same. The fact that they are the
    same does make our lives easier, however, as it means that offsets to content
    within the disk file are identical to offsets to the corresponding bytes in the
    loaded memory image of the file. Understanding how sections are aligned is important
    in helping us avoid errors when we manually create sections for our program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileAlignment` 字段 ➏ 和 `SectionAlignment` 字段 ➎ 表示每个节的数据在文件中的对齐方式，以及当数据映射到内存时如何对齐。在我们的例子中，两个字段都设置为
    `1000h` 字节偏移量对齐。^([3](footnotes.xhtml#ch17fn3)) 在 PE 格式中，这两个数字不需要相同。然而，二者相同确实让我们的工作更轻松，因为这意味着磁盘文件内内容的偏移量与加载的内存映像中的相应字节的偏移量相同。理解节的对齐方式对于帮助我们在手动创建程序节时避免错误非常重要。'
- en: 'After structuring each of the section headers, we have enough information to
    create additional segments within the program. Applying an `IMAGE_SECTION_HEADER`
    template to the bytes immediately following the `IMAGE_NT_HEADERS` structure yields
    the first section header in our Ghidra listing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造了每个节头后，我们就有足够的信息来创建程序中的其他段。将 `IMAGE_SECTION_HEADER` 模板应用于紧跟在 `IMAGE_NT_HEADERS`
    结构之后的字节，得到我们在 Ghidra 列表中的第一个节头：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Name` field ➊ informs us that this header describes the `.text` section.
    All of the remaining fields are potentially useful in formatting the listing,
    but we will focus on the three that describe the layout of the section. The `PointerToRawData`
    field ➍ (`1000h`) indicates the file offset at which the content of the section
    can be found. Note that this value is a multiple of the file alignment value,
    `1000h`. Sections within a PE file are arranged in increasing file offset (and
    virtual address) order. Since this section begins at file offset `1000h`, the
    first `1000h` bytes of the file contain file header data and padding (if there
    are fewer than `1000h` bytes of header data, the section must be padded to a `1000h`
    byte boundary). Therefore, even though the header bytes do not, strictly speaking,
    constitute a section, we can highlight the fact that they are logically related
    by grouping them into a memory block in the Ghidra listing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name` 字段 ➊ 告诉我们这个节头描述的是 `.text` 节。其余的字段在格式化列表时可能有用，但我们将重点关注三个描述节布局的字段。`PointerToRawData`
    字段 ➍（`1000h`）表示可以找到节内容的文件偏移量。注意，这个值是文件对齐值 `1000h` 的倍数。PE 文件中的节按文件偏移量（和虚拟地址）升序排列。由于该节从文件偏移量
    `1000h` 开始，因此文件的前 `1000h` 字节包含文件头数据和填充（如果文件头数据少于 `1000h` 字节，节必须填充到 `1000h` 字节边界）。因此，尽管文件头字节严格来说并不构成一个节，我们可以通过将它们分组为
    Ghidra 列表中的内存块来突出它们在逻辑上是相关的。'
- en: Ghidra offers two ways to create new memory blocks, both accessed through the
    Memory Map window from [Figure 17-2](ch17.xhtml#fig17_2). The Add Block tool (refer
    to [Figure 17-3](ch17.xhtml#fig17_3)) opens the dialog shown in [Figure 17-5](ch17.xhtml#fig17_5),
    which is used to add new memory blocks that do not overlap with any existing memory
    block. The dialog asks for the name of the new memory block, its start address,
    and its length. The block may be initialized with a constant value (zero-filled,
    for example), initialized with content from the current file (you indicate the
    file offset from which the content is taken), or left uninitialized.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 提供了两种创建新内存块的方法，这两种方法都可以通过内存映射窗口访问，见[图 17-2](ch17.xhtml#fig17_2)。添加块工具（参考[图
    17-3](ch17.xhtml#fig17_3)）打开[图 17-5](ch17.xhtml#fig17_5)中显示的对话框，用于添加与现有内存块不重叠的新内存块。该对话框要求提供新内存块的名称、起始地址和长度。该块可以通过常量值进行初始化（例如，填充零），也可以通过当前文件中的内容进行初始化（您需要指示内容来源的文件偏移量），或者保持未初始化状态。
- en: 'The second way to create a new block is to split an existing block. To split
    a block in Ghidra, you must first select the block to split in the Memory Map
    window and then use the Split Block tool (refer to [Figure 17-3](ch17.xhtml#fig17_3))
    to open the dialog shown in [Figure 17-6](ch17.xhtml#fig17_6). We are just starting
    out, so we have only one block to split. We start by splitting the file at the
    beginning of the `.text` section to carve the program headers off of the beginning
    of the existing block. When we enter the length (`1000h`) of our block to split
    (the header section), Ghidra automatically computes the remaining address and
    length fields. All that is left is to provide a name for the new block being created
    at the split point. Here, we use the name contained in the first section header:
    `.text`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新块的第二种方法是拆分一个现有的块。在 Ghidra 中拆分块时，必须首先在内存映射窗口中选择要拆分的块，然后使用拆分块工具（参考[图 17-3](ch17.xhtml#fig17_3)）打开[图
    17-6](ch17.xhtml#fig17_6)中显示的对话框。我们刚开始，所以只有一个块可以拆分。我们首先在 `.text` 部分的开始处拆分文件，将程序头从现有块的开头切割下来。当我们输入要拆分的块的长度（`1000h`）（即头部部分）时，Ghidra
    会自动计算剩余的地址和长度字段。剩下的就是为新创建的块提供一个名称，名称来自于第一个部分头部：`.text`。
- en: '![image](Images/fig17-5.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-5.jpg)'
- en: '*Figure 17-5: The Add Memory Block dialog*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-5：添加内存块对话框*'
- en: '![image](Images/fig17-6.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-6.jpg)'
- en: '*Figure 17-6: The Split Block dialog*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-6：拆分块对话框*'
- en: We now have two blocks in our memory map. The first block contains the correctly
    sized program headers. The second block contains the correctly named, but not
    correctly sized, `.text` section. This situation is reflected in [Figure 17-7](ch17.xhtml#fig17_7),
    where we can see that the size of the `.text` section is `0x29000` bytes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的内存映射中有两个块。第一个块包含正确大小的程序头。第二个块包含正确命名但大小不正确的 `.text` 部分。这个情况在[图 17-7](ch17.xhtml#fig17_7)中得到了体现，我们可以看到
    `.text` 部分的大小是 `0x29000` 字节。
- en: '![image](Images/fig17-7.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-7.jpg)'
- en: '*Figure 17-7: Memory Map window after splitting a block*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-7：拆分块后的内存映射窗口*'
- en: Returning to the header for the `.text` section, we see that the `VirtualAddress`
    field ➋ (`1000h`) is an RVA that specifies the memory offset (from `ImageBase`)
    at which the section content begins and that the `SizeOfRawData` field ➌ (`21000h`)
    indicates how many bytes of data are present in the file. In other words, this
    particular section header tells us that the `.text` section is created by mapping
    the `21000h` bytes from file offsets `1000h-21FFFh` to virtual addresses `401000h-421FFFh`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `.text` 部分的头部，我们看到 `VirtualAddress` 字段 ➋（`1000h`）是一个 RVA，指定了部分内容开始的内存偏移（从
    `ImageBase` 开始），而 `SizeOfRawData` 字段 ➌（`21000h`）指示文件中存在多少字节的数据。换句话说，这个特定的部分头部告诉我们，`.text`
    部分是通过将 `21000h` 字节的文件数据从 `1000h-21FFFh` 的偏移映射到虚拟地址 `401000h-421FFFh` 来创建的。
- en: 'Because we split the original memory block at the beginning of the `.text`
    section, the newly created `.text` section temporarily contains all remaining
    sections, since its current size of `0x29000` is greater than the correct size
    of `0x21000`. By consulting the remaining section headers and repeatedly splitting
    the last memory block, we make progress toward a correct final memory map for
    the program. However, a problem arises when we reach the following pair of section
    headers:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`.text`段的开始处分割了原始内存块，新的`.text`段暂时包含了所有剩余的段，因为其当前大小`0x29000`大于正确的大小`0x21000`。通过查阅剩余的段头，并反复分割最后一个内存块，我们逐步接近程序的正确最终内存映射。然而，当我们遇到以下一对段头时，问题出现了：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `.data` section’s virtual size ➊ is larger than its file size ➌. What does
    this mean and how does it impact our memory map? The compiler has concluded that
    the program requires `5624h` bytes of runtime static data, but supplies only `4000h`
    bytes to initialize that data. The remaining `1624h` bytes of runtime data will
    not be initialized with content from the executable file, as they are allocated
    for uninitialized global variables. (It is not uncommon to see such variables
    allocated within a dedicated program section named `.bss`.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`.data`段的虚拟大小 ➊ 大于其文件大小 ➌。这意味着什么，如何影响我们的内存映射？编译器已经得出结论，程序需要`5624h`字节的运行时静态数据，但只提供了`4000h`字节来初始化这些数据。剩余的`1624h`字节运行时数据将不会通过可执行文件的内容初始化，因为它们是为未初始化的全局变量分配的。（在程序中，常常会看到这样的变量分配到一个名为`.bss`的专用段中。）'
- en: 'To finalize our memory map, we must choose an appropriate size for the `.data`
    section and ensure that subsequent sections are correctly mapped as well. The
    `.data` section maps `4000h` bytes of file data from file offset `24000h` to memory
    address `424000h` ➋ (`ImageBase` + `VirtualAddress`). The next section (`.idata`)
    maps `1000h` bytes from file offset `28000h` ➎ to memory address `42A000h` ➍.
    If you’re paying close attention, you may have noticed that the `.data` section
    appears to occupy `6000h` bytes in memory (`42A000h–424000h`), and in fact it
    does. The reasoning behind this size is that the `.data` section requires `5624h`
    bytes, but this is not an even multiple of `1000h`, so the section will be padded
    up to `6000h` bytes so that the `.idata` section properly adheres to the section
    alignment requirement specified in the PE header. In order to finish our memory
    map, we must carry out the following actions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的内存映射，我们必须为`.data`段选择一个合适的大小，并确保随后的段也正确映射。`.data`段将从文件偏移`24000h`映射`4000h`字节的数据到内存地址`424000h`
    ➋（`ImageBase` + `VirtualAddress`）。接下来的段（`.idata`）将从文件偏移`28000h` ➎映射`1000h`字节到内存地址`42A000h`
    ➍。如果你留心观察，可能已经注意到，`.data`段似乎在内存中占用了`6000h`字节（`42A000h–424000h`），实际上它确实占用了。这个大小的原因是，`.data`段需要`5624h`字节，但这不是`1000h`的整数倍，因此该段会填充到`6000h`字节，以确保`.idata`段符合PE头中指定的段对齐要求。为了完成我们的内存映射，我们必须执行以下操作：
- en: Split the `.data` section using a length of `4000h`. The resulting `.idata`
    section will, for the moment, start at `428000h`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`4000h`的长度分割`.data`段。生成的`.idata`段暂时将从`428000h`开始。
- en: Move the `.idata` section to address `42A000h` by clicking the Move Block icon
    ([Figure 17-3](ch17.xhtml#fig17_3)) and setting the start address to 42A000h.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“移动块”图标（[图 17-3](ch17.xhtml#fig17_3)），将`.idata`段移动到地址`42A000h`，并将起始地址设置为42A000h。
- en: Split off, and, if necessary, move any remaining sections to achieve the final
    program layout.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离并根据需要移动任何剩余的段，以实现最终的程序布局。
- en: Optionally, expand any sections whose virtual size aligns to a higher boundary
    than their file size. In our example, the `.data` section’s virtual size, `5624h`,
    aligns to `6000h`, while its file size, `4000h`, aligns to `4000h`. Once we have
    created room by moving the `.idata` section to its proper location, we will expand
    the `.data` section from `4000h` to `6000h` bytes.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，扩展任何虚拟大小对齐到比文件大小更高边界的段。在我们的示例中，`.data`段的虚拟大小`5624h`对齐到`6000h`，而其文件大小`4000h`对齐到`4000h`。一旦我们通过将`.idata`段移动到正确的位置来腾出空间，就可以将`.data`段从`4000h`扩展到`6000h`字节。
- en: To expand the `.data` section, highlight the `.data` section in the Memory Map
    window and then select the **Expand Down** tool (refer to [Figure 17-3](ch17.xhtml#fig17_3))
    to modify the end address (or length) of the section. The Expand Block Down dialog
    is shown in [Figure 17-8](ch17.xhtml#fig17_8). (This operation will add the *.exp*
    extension to the section name.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展 `.data` 部分，在内存映射窗口中突出显示 `.data` 部分，然后选择 **Expand Down** 工具（参见[图 17-3](ch17.xhtml#fig17_3)），修改该部分的结束地址（或长度）。展开块向下对话框显示在[图
    17-8](ch17.xhtml#fig17_8)中。（此操作将为该部分名称添加 *.exp* 扩展名。）
- en: '![image](Images/fig17-8.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-8.jpg)'
- en: '*Figure 17-8: The Expand Block Down dialog*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-8：展开块向下对话框*'
- en: Our final memory map, obtained after the series of block moves, splits, and
    expansions, appears in [Figure 17-9](ch17.xhtml#fig17_9). In addition to the section
    name, start and end addresses, and length columns, read (R), write (W), and execute
    (X) permissions are shown for each section in the form of checkboxes. For PE files,
    these values are specified via bits in the `Characteristics` field of each section
    header. Consult the PE specification for information on parsing the `Characteristics`
    field to properly set permissions for each section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终内存映射，在经过一系列块移动、拆分和扩展后，如[图 17-9](ch17.xhtml#fig17_9)所示。除了部分名称、起始和结束地址以及长度列外，还显示了每个部分的读取（R）、写入（W）和执行（X）权限，权限以复选框的形式显示。对于
    PE 文件，这些值是通过每个部分头中的 `Characteristics` 字段的位来指定的。请查阅 PE 规范，以了解如何解析 `Characteristics`
    字段，正确设置每个部分的权限。
- en: '![image](Images/fig17-9.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-9.jpg)'
- en: '*Figure 17-9: Final Memory Map window after creating all sections*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-9：创建所有部分后的最终内存映射窗口*'
- en: 'With all program sections properly mapped, we need to locate some bytes that
    have a high likelihood of being code. The `AddressOfEntryPoint` (RVA `14E0h`,
    or virtual address `4014E0h`) leads us to the program’s entry point, which is
    known to be code. Navigating to this location, we see the following raw byte listing:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有程序部分正确映射后，我们需要定位一些很可能是代码的字节。`AddressOfEntryPoint`（RVA `14E0h`，或虚拟地址 `4014E0h`）引导我们到程序的入口点，这是已知的代码位置。导航到该位置后，我们看到以下原始字节列表：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the context menu to disassemble (hotkey D) from `address` `004014e0`
    starts the recursive descent process (whose progress may be tracked in the lower-right
    corner of the Code Browser) and causes the bytes above to be reformatted as the
    code seen here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文菜单从 `address` `004014e0` 进行反汇编（快捷键 D），启动递归下降过程（其进度可以在代码浏览器的右下角跟踪），并使上面的字节重新格式化为以下所示的代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, we would hope that we had enough code to perform a comprehensive
    analysis of the binary. If we had fewer clues regarding the memory layout of the
    binary, or the separation between code and data within the file, we would need
    to rely on other sources of information to guide our analysis. Some potential
    approaches to determining correct memory layout and locating code include the
    following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们希望已收集到足够的代码来进行全面的二进制分析。如果我们对二进制文件的内存布局或文件中代码与数据的分离了解较少，我们将需要依赖其他信息来源来指导我们的分析。确定正确内存布局和定位代码的一些潜在方法包括以下几种：
- en: Use processor reference manuals to understand where reset vectors may be found.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用处理器参考手册来了解复位向量的位置。
- en: Search for strings in the binary that might suggest the architecture, operating
    system, or compiler used to build the binary.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在二进制文件中查找可能暗示架构、操作系统或编译器的字符串。
- en: Search for common code sequences such as function prologues associated with
    the processor for which the binary was built.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找常见的代码序列，如与构建该二进制文件的处理器相关的函数前言。
- en: Perform statistical analysis over portions of the binary to find regions that
    look statistically similar to known binaries.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对二进制文件的部分进行统计分析，找出看起来在统计上类似于已知二进制文件的区域。
- en: Look for repetitive data sequences that might be tables of addresses (for example,
    many nontrivial 32-bit integers that all share the same upper 12 bits).^([4](footnotes.xhtml#ch17fn4))
    These may be pointers and may provide clues regarding the memory layout of the
    binary.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找可能是地址表格的重复数据序列（例如，许多非平凡的 32 位整数，它们共享相同的上 12 位）。^([4](footnotes.xhtml#ch17fn4))
    这些可能是指针，并且可能提供有关二进制文件内存布局的线索。
- en: In rounding out our discussion of loading raw binaries, consider that you would
    need to repeat each step covered in this section every time you open a binary
    with the same format that remains unknown to Ghidra. Along the way, you might
    automate some of your actions by writing scripts that perform some of the header
    parsing and segment creation for you. This is exactly the purpose of a Ghidra
    loader module! In the next section, we’ll write a simple loader module to introduce
    Ghidra’s loader module architecture, before moving on to more sophisticated loader
    modules that perform some common tasks associated with loading files that adhere
    to a structured format.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论加载原始二进制文件时，请考虑到每次打开一个格式相同但Ghidra无法识别的二进制文件时，您都需要重复本节中讲解的每个步骤。在这个过程中，您可能通过编写脚本自动化一些操作，执行一些头部解析和段创建。这正是Ghidra加载器模块的目的！在下一节中，我们将编写一个简单的加载器模块，以介绍Ghidra的加载器模块架构，然后再深入到执行一些常见任务的更复杂加载器模块，这些任务涉及加载符合结构化格式的文件。
- en: '**Example 1: SimpleShellcode Loader Module**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**示例1：SimpleShellcode加载器模块**'
- en: 'At the beginning of this chapter, we tried to load a shellcode file into Ghidra
    and were referred to the Raw Binary loader. In [Chapter 15](ch15.xhtml#ch15),
    we used Eclipse and GhidraDev to create an analyzer module and then added it as
    an extension to Ghidra. Recall that one of the module options provided by Ghidra
    was to create a loader module. In this chapter, we will build a simple loader
    module as an extension to Ghidra to load shellcode. As in our [Chapter 15](ch15.xhtml#ch15)
    example, we will use a simplified software development process, as this is just
    a simple demonstration project. Our process will include the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们尝试将一个shellcode文件加载到Ghidra中，并且被引导到使用Raw Binary加载器。在[第15章](ch15.xhtml#ch15)中，我们使用了Eclipse和GhidraDev创建了一个分析模块，并将其作为扩展添加到Ghidra中。回想一下，Ghidra提供的模块选项之一是创建一个加载器模块。在本章中，我们将构建一个简单的加载器模块，作为Ghidra的扩展来加载shellcode。和我们在[第15章](ch15.xhtml#ch15)中的示例一样，我们将使用简化的软件开发流程，因为这只是一个简单的演示项目。我们的过程将包括以下步骤：
- en: Define the problem.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义问题。
- en: Create the Eclipse module.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Eclipse模块。
- en: Build the loader.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建加载器。
- en: Add the loader to our Ghidra installation.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加载器添加到我们的Ghidra安装中。
- en: Test the loader from our Ghidra installation.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的Ghidra安装中测试加载器。
- en: '**WHAT IS SHELLCODE AND WHY DO WE CARE?**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是SHELLCODE，为什么我们关心它？**'
- en: 'To be pedantic, *shellcode* is raw machine code whose sole purpose is to spawn
    a user space shell process (for example, */bin/sh*), most often by communicating
    directly with the operating system kernel using system calls. The use of system
    calls eliminates any dependencies on user space libraries such as *libc*. The
    term *raw* in this case should not be confused with a Ghidra Raw Binary loader.
    Raw machine code is code that has no packaging in the form of file headers and
    is quite compact when compared to a compiled executable that carries out the same
    actions. Compact shellcode for x86-64 on Linux may be as small as 30 bytes, but
    a compiled version of the following C program, which also spawns a shell, is still
    over 6000 bytes, even after it has been stripped:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，*shellcode* 是原始机器代码，其唯一目的是生成一个用户空间的shell进程（例如，*/bin/sh*），通常通过使用系统调用直接与操作系统内核进行通信。使用系统调用消除了对用户空间库（如*libc*）的依赖。在这种情况下，*raw*（原始）一词不应与Ghidra的Raw
    Binary加载器混淆。原始机器代码是没有文件头包装的代码，相比于执行相同行为的编译可执行文件，它非常紧凑。对于Linux上的x86-64架构，紧凑的shellcode可能小至30字节，但以下C程序的编译版本（它同样生成一个shell）即使在去除调试信息后，仍然超过6000字节：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The drawback to shellcode is that it can’t be run directly from the command
    line. Instead, it is typically injected into an existing process, and action is
    taken to transfer control to the shellcode. Attackers may attempt to place shellcode
    into a process’s memory space, in conjunction with other input consumed by the
    process, and then trigger a control flow hijack vulnerability that allows the
    attacker to redirect the process’s execution to their injected shellcode. Because
    shellcode is often embedded within other input intended for a process, shellcode
    may be observed in network traffic intended for a vulnerable server process, or
    within a file meant to be opened by a vulnerable viewing application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 的缺点在于它不能直接从命令行运行。相反，它通常会被注入到一个现有的进程中，然后采取措施将控制权转交给 shellcode。攻击者可能会试图将
    shellcode 放入进程的内存空间中，并与该进程消耗的其他输入一起，触发控制流劫持漏洞，从而允许攻击者将进程的执行重定向到他们注入的 shellcode。由于
    shellcode 通常嵌入在其他供进程使用的输入中，因此 shellcode 可能会出现在针对易受攻击的服务器进程的网络流量中，或者出现在需要被易受攻击的查看应用程序打开的文件中。
- en: Over time, the term *shellcode* has come to be used generically to describe
    any raw machine code incorporated into an exploit, regardless of whether the execution
    of that machine code spawns a user space shell on the target system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，术语 *shellcode* 被泛指为任何嵌入到漏洞利用中的原始机器代码，无论这些机器代码的执行是否会在目标系统上启动一个用户空间的 shell。
- en: '***Step 0: Take a Step Back***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 0：退后一步***'
- en: Before we can even start to define the problem, we need to understand (a) what
    Ghidra currently does with a shellcode file and (b) what we would like Ghidra
    to do with a shellcode file. Basically, we have to load and analyze a shellcode
    file as a raw binary and then use the information we discover to inform the development
    of our shellcode loader (and potentially an analyzer). Fortunately for us, most
    shellcode is not nearly as complicated as a PE file. Let’s take a deep breath
    and dive into the world of shellcode.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始定义问题之前，我们需要了解 (a) Ghidra 当前如何处理 shellcode 文件，以及 (b) 我们希望 Ghidra 如何处理 shellcode
    文件。基本上，我们必须将 shellcode 文件作为原始二进制文件加载并分析，然后利用我们发现的信息来指导我们 shellcode 加载器（并可能是分析器）的开发。幸运的是，大多数
    shellcode 远没有 PE 文件那么复杂。让我们深呼吸一下，进入 shellcode 的世界。
- en: Let’s start by analyzing the shellcode file we tried to load at the beginning
    of the chapter. We loaded the file and were referred to the Raw Binary loader
    as our only option, as shown earlier in [Figure 17-1](ch17.xhtml#fig17_1). There
    was no recommendation for a language as the Raw Binary loader just “inherited”
    our file because none of the other loaders wanted it. Let’s select a relatively
    common language/compiler specification, `x86:LE:32:default:gcc`, as shown in [Figure
    17-10](ch17.xhtml#fig17_10).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析我们在章节开始时尝试加载的 shellcode 文件开始。我们加载了文件，并且如前所示，被指向了原始二进制加载器作为唯一选项，[图 17-1](ch17.xhtml#fig17_1)
    中展示了这一点。由于其他加载器都不需要该文件，因此没有为其推荐语言。让我们选择一个相对常见的语言/编译器规格，`x86:LE:32:default:gcc`，如
    [图 17-10](ch17.xhtml#fig17_10) 所示。
- en: '![image](Images/fig17-10.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-10.jpg)'
- en: '*Figure 17-10: Import dialog with language/compiler specification*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-10：带有语言/编译器规格的导入对话框*'
- en: We click **OK** and get an Import Results Summary window that includes the content
    shown in [Figure 17-11](ch17.xhtml#fig17_11).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击 **确定**，并得到一个包含 [图 17-11](ch17.xhtml#fig17_11) 所示内容的导入结果摘要窗口。
- en: '![image](Images/fig17-11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-11.jpg)'
- en: '*Figure 17-11: Import Results Summary for shellcode file*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-11：shellcode 文件的导入结果摘要*'
- en: Based on the contents of the enlarged block in the summary, we know that there
    are only 78 bytes in the file in one memory/data block, and that is about all
    the help we get from the Raw Binary loader. If we open the file in the CodeBrowser,
    Ghidra will offer to auto analyze the file. Regardless of whether or not Ghidra
    auto analyzes the file, the Listing window in the CodeBrowser displays the content
    shown in [Figure 17-12](ch17.xhtml#fig17_12). Note that there is only one section
    in Program Trees, the Symbol Tree is empty, and the Data Type Manager has no entries
    in the folder specific to the file. In addition, the Decompiler window remains
    empty, as no functions have been identified in the file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据总结中放大区块的内容，我们知道文件在一个内存/数据块中只有78字节，这就是我们从原始二进制加载器得到的所有帮助。如果我们在CodeBrowser中打开文件，Ghidra会提供自动分析文件的选项。无论Ghidra是否自动分析该文件，CodeBrowser中的Listing窗口都会显示[图17-12](ch17.xhtml#fig17_12)中所示的内容。请注意，程序树中只有一个部分，符号树为空，数据类型管理器在文件特定的文件夹中没有条目。此外，反编译器窗口保持空白，因为文件中没有识别出的函数。
- en: '![image](Images/fig17-12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-12.jpg)'
- en: '*Figure 17-12: CodeBrowser window after loading (or analyzing) the shellcode
    file*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-12：加载（或分析）shellcode文件后的CodeBrowser窗口*'
- en: Right-click the first address in the file and choose **Disassemble** (hotkey
    D) from the context menu. In the Listing window, we now see something we can work
    with—a list of instructions! [Listing 17-2](ch17.xhtml#exa17_2) shows the instructions
    after disassembly and after we have done some analysis on the file. The end-of-line
    comments document some of the analysis of this short file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击文件中的第一个地址，并从上下文菜单中选择**Disassemble**（快捷键D）。在Listing窗口中，我们现在看到一些可以操作的内容——一系列指令！[列表17-2](ch17.xhtml#exa17_2)显示了反汇编后的指令，以及我们在文件分析后得到的结果。行末注释记录了一些关于这个简短文件的分析内容。
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 17-2: Disassembled 32-bit Linux shellcode*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-2：反汇编后的32位Linux shellcode*'
- en: Based on our analysis, the shellcode invokes the Linux *execve* system call
    (at `0000004c`) to launch */bin/sh* (which was pushed onto the stack at `0000003a`
    and `000003f`). The fact that these instructions have meaning to us indicates
    that we likely chose an appropriate language and disassembly starting point.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的分析，shellcode调用了Linux的*execve*系统调用（在`0000004c`处），以启动*/bin/sh*（该路径在`0000003a`和`000003f`处被压入堆栈）。这些指令对我们有意义，表明我们可能选择了合适的语言和反汇编起点。
- en: We now know enough about the loading process to define our loader. (We also
    have enough information to build a simple shellcode analyzer, but that is a task
    for another day.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对加载过程了解得足够多，可以定义我们的加载器了。（我们也有足够的信息来构建一个简单的shellcode分析器，但那是另一天的任务。）
- en: '***Step 1: Define the Problem***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤1：定义问题***'
- en: 'Our task is to design and develop a simple loader that will load shellcode
    into our Listing window and set the entry point, which will facilitate auto analysis.
    The loader needs to be added to Ghidra and be available as a Ghidra Loader option.
    It also needs to be able to respond to the Ghidra Importer poll in an appropriate
    manner: the same way as the Raw Binary loader does. This will make our new loader
    a second catchall loader option. As a side note, all of the examples will utilize
    the FlatProgramAPI. While the FlatProgramAPI is not generally used for building
    extensions, its use will reinforce the scripting concepts presented in [Chapter
    14](ch14.xhtml#ch14) that you are likely to use when developing Ghidra scripts
    in Java.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是设计并开发一个简单的加载器，它将把shellcode加载到Listing窗口中并设置入口点，以便进行自动分析。该加载器需要添加到Ghidra中，并作为Ghidra加载器选项可用。它还需要能够以适当的方式响应Ghidra
    Importer的轮询：与原始二进制加载器的工作方式相同。这将使我们的新加载器成为第二个通用加载器选项。顺便提一下，所有示例都将使用FlatProgramAPI。虽然FlatProgramAPI通常不用于构建扩展，但其使用将巩固在[第14章](ch14.xhtml#ch14)中介绍的脚本概念，这些概念在你使用Java开发Ghidra脚本时可能会用到。
- en: '***Step 2: Create the Eclipse Module***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤2：创建Eclipse模块***'
- en: As discussed in [Chapter 15](ch15.xhtml#ch15), use **GhidraDev** ▸ **New** ▸
    **Ghidra Module Project** to create a module called SimpleShellcode that uses
    the Loader Module template. This will create a file called *SimpleShellcodeLoader.java*
    in the *src/main/java* folder within the SimpleShellcode module. This folder hierarchy
    is shown in context in [Figure 17-13](ch17.xhtml#fig17_13).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第15章](ch15.xhtml#ch15)中所述，使用**GhidraDev** ▸ **New** ▸ **Ghidra Module Project**来创建一个名为SimpleShellcode的模块，该模块使用加载器模块模板。这将会在SimpleShellcode模块的*src/main/java*文件夹中创建一个名为*SimpleShellcodeLoader.java*的文件。该文件夹层级结构在[图17-13](ch17.xhtml#fig17_13)中有展示。
- en: '![image](Images/fig17-13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-13.jpg)'
- en: '*Figure 17-13:* SimpleShellcode *hierarchy*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-13：* SimpleShellcode *层次结构*'
- en: '***Step 3: Build the Loader***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***第3步：构建加载器***'
- en: A partial image of the loader template *SimpleShellcodeLoader.java* is shown
    in [Figure 17-14](ch17.xhtml#fig17_14). The functions have been collapsed so that
    you can see all of the loader methods provided in the loader template. Recall
    that Eclipse will recommend imports if you need them as you develop your code,
    so you can jump right into coding and accept the recommended `import` statements
    when Eclipse detects that you need them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器模板*SimpleShellcodeLoader.java*的部分图像如[图17-14](ch17.xhtml#fig17_14)所示。功能已被折叠，以便你可以看到加载器模板中提供的所有加载器方法。回想一下，当你在开发代码时，如果需要导入，Eclipse会推荐导入项，因此你可以直接开始编码，当Eclipse检测到你需要它们时，接受推荐的`import`语句。
- en: '![image](Images/fig17-14.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-14.jpg)'
- en: '*Figure 17-14:* SimpleShellcodeLoader *template*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-14：* SimpleShellcodeLoader *模板*'
- en: Within the loader template in [Figure 17-14](ch17.xhtml#fig17_14) are six *task
    tags* to the left of the line numbers that indicate where you should start your
    development. We will expand each section as we address specific tasks and include
    the before and after content associated with each task so you will understand
    how you need to modify the template. (Some content will be wrapped or reformatted
    for readability and comments minimized to conserve space.) Unlike the analyzer
    module you wrote in [Chapter 15](ch15.xhtml#ch15), this module does not require
    any obvious class member variables, so you can jump right into the tasks at hand.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图17-14](ch17.xhtml#fig17_14)中的加载器模板内，左侧的行号旁有六个*任务标签*，指示你应该从哪里开始开发。我们将在处理具体任务时扩展每个部分，并包括与每个任务相关的前后内容，以便你理解如何修改模板。（为了可读性，某些内容将被折叠或重新格式化，注释将被简化以节省空间。）与[第15章](ch15.xhtml#ch15)中你编写的分析器模块不同，这个模块不需要任何明显的类成员变量，因此你可以直接开始当前任务。
- en: '**Step 3-1: Document the Class**'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**第3步-1：记录类**'
- en: 'When you expand the first task tag, you see the following task description:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你展开第一个任务标签时，你会看到以下任务描述：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This task involves replacing the existing `TODO` comments with comments that
    describe what the loader does:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务涉及将现有的`TODO`注释替换为描述加载器功能的注释：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Step 3-2: Name and Describe the Loader**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**第3步-2：命名并描述加载器**'
- en: 'Expanding the next task tag reveals a `TODO` comment and the string you need
    to edit. This makes it easy to identify where you should start working. The second
    task contains the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 展开下一个任务标签会显示一个`TODO`注释和你需要编辑的字符串。这使你可以轻松识别你应该从哪里开始工作。第二个任务包含以下内容：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Change the string ➊ to something meaningful. You don’t need to worry about
    matching the name in the *.opinion* files, as they are not applicable to loaders
    that will accept any files. You will see *.opinion* files when you get to the
    third example. Ignoring the *.opinion* file comment in the template results in
    the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串 ➊ 更改为有意义的内容。你不需要担心与*.opinion*文件中的名称匹配，因为这些文件不适用于将接受任何文件的加载器。当你进入第三个示例时，你会看到*.opinion*文件。忽略模板中的*.opinion*文件注释会导致以下代码：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Step 3-3: Determine If the Loader Can Load This File**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**第3步-3：确定加载器是否能加载该文件**'
- en: 'The second step in the loading process we described at the beginning of the
    chapter involved the Importer loader poll. This task requires you to determine
    if your loader can load the file and provide a response to the Importer through
    your method’s return value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节开头描述的加载过程的第二个步骤涉及到导入器加载器轮询。此任务要求你确定你的加载器是否可以加载文件，并通过你的方法的返回值向导入器提供响应：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Most loaders do this by examining the content of the file to find a magic number
    or header structure. The `ByteProvider` input parameter is a Ghidra-provided read-only
    wrapper around an input file stream. We are going to simplify our task and adopt
    the `LoadSpec` list that the Raw Binary loader uses, which ignores file content
    and simply lists all possible `LoadSpec`s. We will then give our loader a lower
    priority than the Raw Binary loader so that if a more specific loader exists,
    it will automatically have a higher priority in the Ghidra Import dialog.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数加载器通过检查文件的内容来查找魔数或头部结构来实现这一点。`ByteProvider`输入参数是Ghidra提供的一个只读包装器，封装了输入文件流。我们将简化任务，采用Raw
    Binary加载器使用的`LoadSpec`列表，该列表忽略文件内容，只列出所有可能的`LoadSpec`。然后，我们将给加载器设置一个比Raw Binary加载器更低的优先级，这样如果存在更具体的加载器，它将在Ghidra导入对话框中自动拥有更高的优先级。
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Every loader has an associated tier and tier priority. Ghidra defines four tiers
    of loaders, ranging from highly specialized (tier 0) to format agnostic (tier
    3). When multiple loaders are willing to accept a file, Ghidra sorts the loader
    list displayed to the user in increasing tier order. Loaders within the same tier
    are further sorted in increasing tier priority order (that is, tier priority 10
    is listed before tier priority 20).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载器都有一个关联的层级和层级优先级。Ghidra定义了四个加载器层级，层级0为高度专业化的加载器，层级3为与格式无关的加载器。当多个加载器都愿意接受某个文件时，Ghidra会按照层级的递增顺序对加载器列表进行排序。同一层级中的加载器则会根据层级优先级的递增顺序进一步排序（即，层级优先级为10的加载器会排在层级优先级为20的加载器之前）。
- en: 'For example, the PE loader and the Raw Binary loader are both willing to load
    PE files, but the PE loader is a better choice to load this format (its tier is
    1), so it will appear before the Raw Binary loader (tier 3, tier priority 100)
    in the list. We set the Simple Shellcode Loader’s tier to 3 (`LoaderTier.UNTARGETED_LOADER`)
    and priority to 101, so it will be given the lowest priority by the Importer when
    populating the Import window with candidate loaders. To accomplish this, add the
    following two methods to your loader:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，PE加载器和原始二进制加载器都愿意加载PE文件，但PE加载器是加载这种格式的更好选择（其层级为1），因此它将出现在原始二进制加载器（层级3，层级优先级100）之前。我们将简单Shellcode加载器的层级设置为3（`LoaderTier.UNTARGETED_LOADER`），优先级设置为101，因此在Importer填充导入窗口中的候选加载器时，它会被赋予最低的优先级。为此，请将以下两个方法添加到您的加载器中：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '##### **Step 3-4: Load the Bytes**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **步骤3-4：加载字节**'
- en: 'The following method shown before and after we edit the content does the heavy
    lifting of loading content from the file being imported into our Ghidra project
    (in this case, it loads the shellcode):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法展示了在我们编辑内容前后的操作，它完成了将文件内容加载到我们的Ghidra项目中的主要任务（在这个例子中，它加载的是shellcode）：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that, unlike the scripts in [Chapters 14](ch14.xhtml#ch14) and [15](ch15.xhtml#ch15),
    which inherit from `GhidraScript` (and ultimately `FlatProgramAPI`), our loader
    class has no direct access to the Flat API. Therefore, to simplify our access
    to some commonly used API classes, we instantiate our own `FlatProgramAPI` object
    ➊. Next, we create a `MemoryBlock` named `SHELLCODE` at address zero ➋ and populate
    it with the entire contents of the input file. We take the time to set some reasonable
    permissions ➌ on the new memory region before adding an entry point ➍ that informs
    Ghidra where it should begin its disassembly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与[第14章](ch14.xhtml#ch14)和[第15章](ch15.xhtml#ch15)中的脚本不同，这些脚本继承自`GhidraScript`（最终继承自`FlatProgramAPI`），我们的加载器类无法直接访问Flat
    API。因此，为了简化我们对一些常用API类的访问，我们实例化了我们自己的`FlatProgramAPI`对象➊。接下来，我们在地址零处创建一个名为`SHELLCODE`的`MemoryBlock`➋，并用输入文件的全部内容填充它。在添加一个入口点之前，我们花时间为新的内存区域设置一些合理的权限➌，该入口点通知Ghidra它应从哪里开始反汇编。
- en: Adding an entry point is a very important step for a loader. The presence of
    entry points is the primary means by which Ghidra locates addresses known to contain
    code (as opposed to data). As it parses the input file, the loader is ideally
    suited to discover any entry points and identify them to Ghidra.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 添加入口点是加载器的一个非常重要的步骤。入口点的存在是Ghidra定位已知包含代码（而非数据）的地址的主要手段。在解析输入文件时，加载器理想情况下能够发现任何入口点并将其标识给Ghidra。
- en: '##### **Step 3-5: Register Custom Loader Options**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **步骤3-5：注册自定义加载器选项**'
- en: 'Some loaders offer users the option to modify various parameters associated
    with the loading process. You may override the `getDefaultOptions` function to
    provide Ghidra with a list of custom options available for your loader:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一些加载器为用户提供修改与加载过程相关的各种参数的选项。您可以重写`getDefaultOptions`函数，以便向Ghidra提供可用于您加载器的自定义选项列表：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since this loader is just for demonstration purposes, we will not add any options.
    Options for a loader might include setting an offset into the file at which to
    start reading, and setting the base address at which to load the binary. To view
    the options associated with any loader, click the **Options . . .** button on
    the bottom right of the Import dialog (refer to [Figure 17-1](ch17.xhtml#fig17_1)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个加载器只是用于演示，我们不会添加任何选项。加载器的选项可能包括设置开始读取文件的偏移量，以及设置加载二进制文件的基地址。要查看与任何加载器相关的选项，请点击导入对话框右下角的**选项
    . . .**按钮（请参阅[图17-1](ch17.xhtml#fig17_1)）。
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Step 3-6: Validate Options**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤3-6：验证选项**'
- en: 'The next task is to validate the options:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是验证选项：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we do not have any options, we just return `null`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有任何选项，我们直接返回`null`：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**TESTING MODULES FROM ECLIPSE**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**从ECLIPSE测试模块**'
- en: If you are one of those programmers who doesn’t always get the code exactly
    right on the first try, you can avoid the multiple “export, start Ghidra, import
    extension, add extension to import list, choose extension, restart Ghidra, test
    extension” cycles by running the new code from Eclipse. If you choose Run ▸ Run
    As from the Eclipse menu, you will be given the option to run as Ghidra (or as
    Ghidra Headless). This will launch Ghidra, and you can import a file to the current
    project. Your loader will be included in the import options, and all console feedback
    will be provided in the Eclipse console. You can interact with the file in Ghidra,
    just like any other file. You can then exit out of your Ghidra project without
    saving and either (1) adjust the code, or (2) “export, start Ghidra, import extension,
    add extension to import list, choose extension, restart Ghidra, and test extension”
    just one time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是那种在第一次尝试时不总是能精确写出代码的程序员，可以通过从 Eclipse 运行新代码来避免多次进行“导出，启动 Ghidra，导入扩展，添加扩展到导入列表，选择扩展，重启
    Ghidra，测试扩展”这些循环。如果你从 Eclipse 菜单选择“运行 ▸ 作为运行”，你将获得作为 Ghidra（或 Ghidra Headless）运行的选项。这将启动
    Ghidra，你可以将文件导入到当前项目中。你的加载器将作为导入选项包含在内，所有控制台反馈都会在 Eclipse 控制台中显示。你可以像处理其他文件一样在
    Ghidra 中与该文件进行交互。然后，你可以在不保存的情况下退出 Ghidra 项目，并选择（1）调整代码，或（2）只进行一次“导出，启动 Ghidra，导入扩展，添加扩展到导入列表，选择扩展，重启
    Ghidra，测试扩展”。
- en: '***Step 4: Add the Loader to Our Ghidra Installation***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：将加载器添加到我们的 Ghidra 安装中***'
- en: After confirming that this module functions correctly, export the Ghidra module
    extension from Eclipse and then install the extension in Ghidra, just as we did
    with the SimpleROPAnalyzer module in [Chapter 15](ch15.xhtml#ch15). Select **GhidraDev**
    ▸ **Export** ▸ **Ghidra Module Extension**, choosing the **SimpleShellcode** module,
    and follow the same click-through process that you did in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认该模块正常工作后，从 Eclipse 导出 Ghidra 模块扩展，然后将扩展安装到 Ghidra，就像我们在[第 15 章](ch15.xhtml#ch15)中对
    SimpleROPAnalyzer 模块所做的那样。选择 **GhidraDev** ▸ **导出** ▸ **Ghidra 模块扩展**，选择 **SimpleShellcode**
    模块，然后按照你在[第 15 章](ch15.xhtml#ch15)中所做的相同步骤进行操作。
- en: To import the extension into Ghidra, choose **File** ▸ **Install Extensions**
    from the Ghidra Project window. Add the new loader to the list and select it.
    Once you restart Ghidra, the new loader should be available as an option, but
    you should test to be sure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要将扩展导入到 Ghidra 中，请从 Ghidra 项目窗口选择 **文件** ▸ **安装扩展**。将新加载器添加到列表中并选择它。重新启动 Ghidra
    后，新加载器应作为选项可用，但你应该进行测试以确保。
- en: '***Step 5: Test the Loader Within Ghidra***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 5：在 Ghidra 中测试加载器***'
- en: 'Our simplified test plan is just to demonstrate functionality. SimpleShellcode
    passed an acceptance test consisting of the following criteria:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简化的测试计划仅用于演示功能。SimpleShellcode 已通过以下标准的验收测试：
- en: (Pass) SimpleShellcode appears as a loader option with lower priority than Raw
    Binary.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （通过）SimpleShellcode 作为加载器选项出现，优先级低于原始二进制文件。
- en: (Pass) SimpleShellcode loads a file and sets the entry point.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （通过）SimpleShellcode 加载文件并设置入口点。
- en: Test case 1 passed, as shown in [Figure 17-15](ch17.xhtml#fig17_15). A second
    confirmation is shown in [Figure 17-16](ch17.xhtml#fig17_16), where the PE file
    analyzed earlier in the chapter is being loaded. In both cases, we see that the
    Simple Shellcode Loader option has the lowest priority in the Format list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例 1 已通过，如[图 17-15](ch17.xhtml#fig17_15)所示。第二个确认在[图 17-16](ch17.xhtml#fig17_16)中显示，其中前面章节分析的
    PE 文件正在被加载。在这两种情况下，我们可以看到“简单 shellcode 加载器”选项在格式列表中的优先级最低。
- en: '![image](Images/fig17-15.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-15.jpg)'
- en: '*Figure 17-15: Import window with our new loader listed as an option*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-15：导入窗口，显示我们的新加载器作为选项*'
- en: '![image](Images/fig17-16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-16.jpg)'
- en: '*Figure 17-16: Import window with our new loader listed as an option for a
    PE file*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-16：导入窗口，显示我们的新加载器作为 PE 文件的选项*'
- en: Choose the language specification based on the information available about the
    binary and how it was obtained. Let’s assume that the shellcode was captured from
    packets headed for an x86 box. In that case, selecting `x86:LE:32:default:gcc`
    for our language/compiler specification is probably a good starting point.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据有关二进制文件的信息和获取方式，选择语言规范。假设 shellcode 是从指向 x86 机器的数据包中捕获的。在这种情况下，选择 `x86:LE:32:default:gcc`
    作为我们的语言/编译器规范可能是一个好的起点。
- en: 'After we select a language and click OK for the file shown in [Figure 17-15](ch17.xhtml#fig17_15),
    the binary will be imported into our Ghidra project. We can then open the program
    in the CodeBrowser, and Ghidra will provide us an option to analyze the file.
    If we accept the analysis, we will see the following listing:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们选择语言并点击 [图 17-15](ch17.xhtml#fig17_15) 中所示的文件后，二进制文件将被导入到我们的 Ghidra 项目中。然后我们可以在
    CodeBrowser 中打开程序，Ghidra 会提供一个选项来分析文件。如果我们接受分析，我们将看到以下清单：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An entry point ➊ is identified, so Ghidra is able to provide us with a disassembly
    to begin our analysis.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点 ➊ 被识别，因此 Ghidra 能够为我们提供反汇编结果，以便开始分析。
- en: SimpleShellcodeLoader was a trivial example, as shellcode is generally found
    embedded within some other data. For demonstration purposes, we will use our loader
    module as a base to create a loader module that extracts shellcode from C source
    files and loads the shellcode for analysis. This may, for example, allow us to
    build shellcode signatures that Ghidra can recognize in other binaries. We will
    not go into great depth for each step, as we are just augmenting the capabilities
    of our existing shellcode loader.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleShellcodeLoader 是一个简单的示例，因为 shellcode 通常嵌入在其他数据中。为了演示目的，我们将以我们的加载器模块为基础，创建一个从
    C 源文件中提取 shellcode 并加载 shellcode 进行分析的加载器模块。这可能会允许我们构建 Ghidra 能在其他二进制文件中识别的 shellcode
    特征。我们不会深入探讨每个步骤，因为我们只是扩展了现有 shellcode 加载器的功能。
- en: '**Example 2: Simple Shellcode Source Loader**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**示例 2：简单的 Shellcode 源代码加载器**'
- en: Since modules provide a way to organize code, and the SimpleShellcode module
    you created has everything required to create a loader, you don’t need to create
    a new module. Simply choose **File** ▸ **New** ▸ **File** from the Eclipse menu
    and add a new file (*SimpleShellcodeSourceLoader.java*) to your SimpleShellcode
    *src/main/java* folder. By doing this, all of your new loaders will be included
    in your new Ghidra extension.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块提供了一种组织代码的方法，并且您创建的 SimpleShellcode 模块具备创建加载器所需的一切，您不需要创建一个新模块。只需从 Eclipse
    菜单中选择 **文件** ▸ **新建** ▸ **文件**，然后将一个新文件 (*SimpleShellcodeSourceLoader.java*) 添加到您的
    SimpleShellcode *src/main/java* 文件夹中。通过这样做，您所有的新加载器将包含在您的新 Ghidra 扩展中。
- en: To make life simple, paste the contents of your existing *SimpleShellcodeLoader.java*
    into this new file and update the comments about what the loader does. The following
    steps highlight the parts of the existing loader that you need to change to make
    the new loader work as expected. For the most part, you will be adding onto the
    existing code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，将现有的 *SimpleShellcodeLoader.java* 文件内容粘贴到这个新文件中，并更新关于加载器功能的注释。以下步骤突出显示了现有加载器中需要更改的部分，以使新加载器按预期工作。在大多数情况下，您将扩展现有代码。
- en: '#### ***Update 1: Modify the Response to the Importer Poll***'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***更新 1：修改对导入器轮询的响应***'
- en: 'The simple source loader is going to make its decision based strictly on the
    file extension. If the file does not end in *.c*, the loader will return an empty
    `loadSpecs` list. If the file does end with *.c*, it will return the same `loadSpecs`
    list that it did for the previous loader. To make this work, you need to add the
    following test to the `findSupportLoadSpecs` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的源代码加载器将严格根据文件扩展名做出决定。如果文件的扩展名不是*.c*，加载器将返回一个空的`loadSpecs`列表。如果文件扩展名是*.c*，它将返回与之前的加载器相同的`loadSpecs`列表。为了使这一点生效，您需要在`findSupportLoadSpecs`方法中添加以下测试：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’ve also decided that our loader deserves a higher priority than the Raw
    Binary loader because ours identifies a particular type of file to accept and
    is better suited for that type of file. This is done by returning a higher priority
    (lower value) from our `getTierPriority` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还决定，由于我们的加载器识别特定类型的文件并且更适合该类型的文件，所以它的优先级高于原始二进制加载器。这是通过在`getTierPriority`方法中返回一个较高的优先级（较低的值）来实现的：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***Update 2: Find the Shellcode in the Source Code***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新 2：在源代码中找到 Shellcode***'
- en: 'Recall that shellcode is just raw machine code that does something useful for
    us. The individual bytes in the shellcode will lie in the range `0..255`, and
    many of these values fall outside the range of ASCII printable characters. Therefore,
    when shellcode is embedded into a source file, much of it must be represented
    using hex escape sequences such as `\xFF`. Strings of this sort are rather unique,
    and we can build a regular expression to help our loader identify them. The following
    instance variable declaration describes the regular expression that all of the
    functions in our loader may use to find shellcode bytes with the selected C file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，shellcode 只是执行某些有用任务的原始机器码。shellcode 中的每个字节都在 `0..255` 范围内，其中许多值超出了 ASCII
    可打印字符的范围。因此，当 shellcode 被嵌入到源文件中时，其中的大部分必须通过十六进制转义序列来表示，例如 `\xFF`。这种类型的字符串相当独特，我们可以构建一个正则表达式，帮助我们的加载器识别它们。以下实例变量声明描述了所有加载器函数可能使用的正则表达式，用于在选定的
    C 文件中查找 shellcode 字节：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Within the `load` method, the loader parses the file looking for patterns that
    match the regular expression to help calculate the amount of memory needed when
    loading the file into Ghidra. As shellcode is frequently not contiguous, the loader
    should parse the entire file looking for shellcode regions to load from the file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `load` 方法中，加载器解析文件，寻找与正则表达式匹配的模式，以帮助计算加载文件到 Ghidra 时所需的内存量。由于 shellcode 通常不是连续的，因此加载器应解析整个文件，寻找需要加载的
    shellcode 区域。
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After loading the entire contents of the input file ➊, we count all of the matches
    ➌ against our regular expression ➋.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 加载输入文件的全部内容 ➊ 后，我们统计所有与正则表达式匹配的项 ➌。
- en: '***Update 3: Convert Shellcode to Byte Values***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新 3：将 Shellcode 转换为字节值***'
- en: 'The `load()` method next needs to convert the hex escape sequences into byte
    values and put them in a byte array:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()` 方法接下来需要将十六进制转义序列转换为字节值，并将它们放入字节数组中：'
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The hex digits are extracted from each matching string ➊ and converted into
    byte values ➌ that get appended to our shellcode array ➋.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数字从每个匹配的字符串 ➊ 中提取，并转换为字节值 ➌，然后附加到我们的 shellcode 数组 ➋。
- en: '***Update 4: Load Converted Byte Array***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新 4：加载转换后的字节数组***'
- en: 'Finally, because the shellcode is in a byte array, the `load()` method needs
    to copy it from the byte array into the program’s memory. This is the actual loading
    step and the last required step for your loader to accomplish the goal:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 shellcode 已经是字节数组，`load()` 方法需要将其从字节数组复制到程序的内存中。这是实际的加载步骤，也是加载器完成目标的最后一步：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***Results***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: 'To test our new loader, we create a C source file that contains the following
    escaped representation of x86 shellcode:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的新加载器，我们创建了一个 C 源文件，其中包含以下表示 x86 shellcode 的转义形式：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because our source file’s name ends in *.c*, our loader appears in the list
    as the top selection, with higher priority than the Raw Binary and Simple Shellcode
    loaders, as shown in [Figure 17-17](ch17.xhtml#fig17_17).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的源文件名以 *.c* 结尾，因此我们的加载器出现在列表中的首位，优先级高于原始二进制和简单 shellcode 加载器，如 [图 17-17](ch17.xhtml#fig17_17)
    所示。
- en: '![image](Images/fig17-17.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-17.jpg)'
- en: '*Figure 17-17: Import dialog for shellcode source file*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-17：Shellcode 源文件导入对话框*'
- en: 'Selecting this loader, using the same default compiler/language specification
    as the previous example (`x86:LE:32:default:gcc`), and letting Ghidra auto analyze
    the file yields the following function in the disassembly listing:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此加载器，使用与之前示例相同的默认编译器/语言规范（`x86:LE:32:default:gcc`），并让 Ghidra 自动分析文件，结果如下所示的反汇编列表中的函数：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Scrolling down through the listing leads us to the familiar content (see [Listing
    17-2](ch17.xhtml#exa17_2)) shown here (with comments added for clarity):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动查看列表，带我们到熟悉的内容（见 [列表 17-2](ch17.xhtml#exa17_2)），此处显示的是（已添加注释以便理解）：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Most reverse engineering efforts focus on binaries. In this case, we have stepped
    outside that box and used Ghidra to load shellcode for analysis as well as to
    extract shellcode from C source files. Our goal was to demonstrate the flexibility
    and simplicity of creating loaders for Ghidra. Now, let’s step back into that
    box and create a loader for a structured file format.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数逆向工程工作集中在二进制文件上。在这种情况下，我们跳出了这个范畴，使用 Ghidra 加载 shellcode 进行分析，并从 C 源文件中提取
    shellcode。我们的目标是展示为 Ghidra 创建加载器的灵活性和简便性。现在，让我们重新回到这个范畴，创建一个结构化文件格式的加载器。
- en: Assume that our target shellcode is contained within an ELF binary and that,
    for the sake of this example, Ghidra does not recognize ELF binaries. Further,
    none of us have ever heard of an ELF binary. Let the adventure begin.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的目标 shellcode 包含在一个 ELF 二进制文件中，并且为了这个示例，Ghidra 无法识别 ELF 二进制文件。此外，我们中的任何人都从未听说过
    ELF 二进制文件。冒险开始吧。
- en: '**Example 3: Simple ELF Shellcode Loader**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**示例 3：Simple ELF Shellcode Loader**'
- en: 'Congratulations! You are now the resident RE expert on shellcode, and colleagues
    are reporting what they suspect is shellcode contained in binaries and are being
    referred by Ghidra to the Raw Binary loader. Since this does not appear to be
    a one-off problem, and you think there is a good chance you will see more binaries
    with similar characteristics, you decide to build a loader that will handle this
    new type of file. As discussed in [Chapter 13](ch13.xhtml#ch13), you can use tools
    internal or external to Ghidra to capture information about the file. If you once
    again turn to the command line, `file` provides helpful information to start building
    your loader:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在是 shellcode 的常驻逆向工程专家，同事们报告他们怀疑某些二进制文件中包含 shellcode，并且 Ghidra 将它们转介给原始二进制文件加载器。由于这似乎不是一次性的问题，而且你认为很有可能会看到更多具有类似特征的二进制文件，因此你决定构建一个能够处理这种新文件类型的加载器。如
    [第13章](ch13.xhtml#ch13) 中所讨论的，你可以使用 Ghidra 内部或外部的工具来捕获文件信息。如果你再次转向命令行，`file` 命令提供了有用的信息，帮助你开始构建加载器：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `file` command provides information about a format you have never heard
    of before, ELF. Your first step is to do some research to see if you can locate
    any information about this type of binary. Your friend Google will happily point
    you to several references about the ELF format, which you can use to locate the
    information you need to build your loader. Anything that provides enough accurate
    information to solve the problem works.^([5](footnotes.xhtml#ch17fn5))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 命令提供了你之前从未听说过的 ELF 格式的信息。你的第一步是进行一些研究，看看是否能找到有关这种二进制文件的任何信息。你的朋友 Google
    会很高兴地为你指引几篇关于 ELF 格式的参考资料，你可以利用这些资料来找到构建加载器所需的信息。任何提供足够准确信息以解决问题的资源都可以使用。^([5](footnotes.xhtml#ch17fn5))'
- en: As this is a bigger challenge than the previous two loader examples, we will
    break this into sections associated with the individual files within your Eclipse
    SimpleShellcode module that you will need to create/modify/delete to complete
    your new *SimpleELFShellcodeLoader*. We will start off with some simple housekeeping.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个比之前两个加载器示例更大的挑战，我们将其分解为与 Eclipse SimpleShellcode 模块中各个文件相关的部分，你需要创建、修改或删除这些文件以完成你的新
    *SimpleELFShellcodeLoader*。我们将从一些简单的基本准备工作开始。
- en: '#### ***Housekeeping***'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***基本准备工作***'
- en: 'The first step is to create a *SimpleELFShellcodeLoader.java* file within the
    SimpleShellcode module in Eclipse. As you don’t want to start from nothing, you
    should use Save As with *SimpleShellcodeLoader.java* to create this new file.
    Once you have done this, there are a few minor modifications to make to the new
    file before you can start focusing on the new challenge:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在 Eclipse 中的 SimpleShellcode 模块内创建一个 *SimpleELFShellcodeLoader.java* 文件。由于你不想从零开始，你应该使用另存为功能创建这个新文件，文件名为
    *SimpleShellcodeLoader.java*。完成这个步骤后，你需要对新文件进行一些小的修改，才能开始集中精力解决新的挑战：
- en: Change the name of the class to SimpleELFShellcodeLoader.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类名更改为 SimpleELFShellcodeLoader。
- en: Modify the `getTier` method return value from `UNTARGETED_LOADER` to GENERIC_TARGET_LOADER.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `getTier` 方法的返回值，从 `UNTARGETED_LOADER` 改为 GENERIC_TARGET_LOADER。
- en: Delete the `getTierPriority` method.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `getTierPriority` 方法。
- en: Modify the `getName` method to return "Simple ELF Shellcode Loader".
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `getName` 方法以返回 "Simple ELF Shellcode Loader"。
- en: Once you have completed the housekeeping tasks, let’s apply the information
    you learned from your research about the new header format.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了基本的准备工作，让我们应用你从研究中学到的关于新头部格式的信息。
- en: '***ELF Header Format***'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ELF头部格式***'
- en: 'While researching this new format, you discover that the ELF format contains
    three types of headers: the file header (or ELF header), the program header(s),
    and the section header(s). You can start by focusing on the ELF header. Associated
    with each field in the ELF header is an offset as well as other information about
    the field. Since you need to access only a few of these fields and you won’t be
    modifying the offsets, declare the following constants as instance variables within
    your loader class to help your loader correctly parse this new header format:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究这种新格式时，你发现ELF格式包含三种类型的头文件：文件头（或ELF头文件）、程序头和节头。你可以从专注于ELF头文件开始。每个ELF头文件中的字段都与一个偏移量以及其他关于该字段的信息相关联。由于你只需要访问其中的少数字段，并且不会修改偏移量，因此可以将以下常量作为实例变量声明在加载器类中，以帮助加载器正确解析这种新的头文件格式：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With a description of the ELF header in hand, the next step is to determine
    how to respond to the Importer poll to ensure that the new ELF loader is capable
    of loading only files that adhere to the ELF format. In the previous two examples,
    the shellcode loaders did not look at file contents to determine if they could
    load a file. This simplified coding these examples significantly. Now things are
    a bit more complicated. Fortunately, the ELF documentation provides important
    clues to help determine the appropriate loader specifications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取了ELF头文件的描述后，下一步是确定如何响应导入器的轮询，以确保新的ELF加载器只加载符合ELF格式的文件。在前两个示例中，shellcode加载器并没有查看文件内容来判断是否能够加载一个文件。这大大简化了这些示例的编写。现在情况有点复杂。幸运的是，ELF文档提供了重要的线索，帮助确定适当的加载器规范。
- en: '***Find Supported Load Specifications***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找支持的加载规范***'
- en: 'The loader can’t load anything that isn’t in the right format and can reject
    any file by returning an empty `loadSpecs` list. Within the `findSupportedLoadSpecs()`
    method, immediately eliminate all binaries that don’t have the expected magic
    number by using the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器无法加载任何不符合正确格式的文件，并且可以通过返回一个空的`loadSpecs`列表来拒绝任何文件。在`findSupportedLoadSpecs()`方法中，立即通过以下代码消除所有没有预期魔数的二进制文件：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once the undesirables have been eliminated, the loader can check the bit width
    and endianness to see if the architecture is reasonable for an ELF binary. For
    this demonstration, let’s further limit the types of binaries the loader will
    accept to 32-bit little-endian:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦排除了不需要的内容，加载器可以检查位宽和字节顺序，以查看架构是否适合ELF二进制文件。为了演示，我们进一步限制加载器接受的二进制文件类型为32位小端模式：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To round out the verification process, the following code checks if this is
    an ELF executable file (as opposed to a shared library) for the x86 architecture:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善验证过程，以下代码检查是否为x86架构的ELF可执行文件（与共享库不同）：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that you have limited your file types, you can query the opinion service
    for matching language and compiler specifications. Conceptually, you query the
    opinion services with values extracted from the file you are loading (for example,
    the ELF header `e_machine` field), and in response you receive a list of language/compiler
    specifications that your loader is willing to accept. (The “behind the scenes”
    actions that take place when you query the opinion service are described in more
    detail in the following sections.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经限制了文件类型，你可以查询意见服务以匹配语言和编译器规范。从概念上讲，你是用从加载的文件中提取的值（例如，ELF头文件中的`e_machine`字段）查询意见服务，作为响应，你将收到一个语言/编译器规范的列表，加载器愿意接受这些规范。（查询意见服务时后台进行的操作将在以下章节中详细描述。）
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s assume that the opinion service is likely to yield more results than
    you want to handle with this loader. You can pare the list further by excluding
    results based on the attributes specified in the associated language/compiler
    specifications. The following code filters out a compiler and a processor variant:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设意见服务可能会返回比你希望此加载器处理的结果更多的内容。你可以通过基于相关语言/编译器规范中指定的属性进一步缩小列表。以下代码过滤掉了一个编译器和一个处理器变种：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The above examples (which you are free to include in your loader) specifically
    exclude the *Delphi compiler* ➊ and *x86 system management mode* ➋. You can exclude
    others if you wish. All of the results you have not excluded need to be added
    to your `loadSpecs` list ➌.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例（你可以自由地将其包括在加载器中）特别排除了*Delphi编译器* ➊和*x86系统管理模式* ➋。你也可以排除其他的。如果你没有排除的所有结果，都需要添加到`loadSpecs`列表中
    ➌。
- en: '***Load File Content into Ghidra***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将文件内容加载到Ghidra中***'
- en: 'The `load()` method of your simplified loader assumes the file consists of
    a minimal ELF header and a short program header, followed by the shellcode in
    a text section. You need to determine the total length of the header to allocate
    the correct amount of space for it. The following code determines the required
    size by using the `EH_EEHSIZE_OFFSET`, `EH_PHENTSIZE_OFFSET`, and `EH_PHNUM_OFFSET`
    fields from the ELF header:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你简化版加载器的`load()`方法假设文件包含一个最小的 ELF 头和一个简短的程序头，后面是 shellcode 的文本部分。你需要确定头部的总长度，以便为其分配正确的空间。以下代码通过使用
    ELF 头中的 `EH_EEHSIZE_OFFSET`、`EH_PHENTSIZE_OFFSET` 和 `EH_PHNUM_OFFSET` 字段来确定所需的大小：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that you know the size, create and populate the memory blocks for the ELF
    header section and the text section as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了大小，按照以下方式创建并填充 ELF 头部区域和文本区域的内存块：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***Format Data Bytes and Add an Entry Point***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***格式数据字节并添加入口点***'
- en: 'A few more steps, and you will be done. Loaders often apply data types and
    create cross-references for information derived from file headers. It is also
    the loader’s job to identify any entry points in the binary. Creating a list of
    entry points at load time provides the disassembler with a list of locations it
    should consider code. Our loader follows these practices:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 再做几步，你就完成了。加载器通常会应用数据类型并为从文件头中派生的信息创建交叉引用。加载器的工作还包括识别二进制文件中的任何入口点。在加载时创建入口点列表，能为反汇编器提供它应该视为代码的位置列表。我们的加载器遵循以下做法：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, the Ghidra ELF header data type is applied at the start of the ELF headers
    ➊.^([6](footnotes.xhtml#ch17fn6)) Second, a label ➋ and an entry point ➌ are created
    for the shellcode. Finally, we create a cross-reference between the entry point
    field in the ELF header and the start of the shellcode ➍.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 ELF 头部的开始应用 Ghidra ELF 头数据类型 ➊。^([6](footnotes.xhtml#ch17fn6)) 其次，为 shellcode
    创建一个标签 ➋ 和入口点 ➌。最后，我们在 ELF 头的入口点字段和 shellcode 开始之间创建一个交叉引用 ➍。
- en: Congratulations! You are done writing the Java code for your loader, but we
    need to address a couple of issues to ensure that you understand all of the dependencies
    between your new loader and some important related files in order for your loader
    to operate as expected.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了加载器的 Java 代码编写，但我们需要解决几个问题，以确保你理解新加载器与一些重要相关文件之间的所有依赖关系，以便加载器能够按预期正常运行。
- en: This example leverages an existing processor architecture (x86), and some work
    was done behind the scenes that helped this loader work correctly. Recall that
    the Importer polled the loaders and magically produced acceptable language/compiler
    specifications. The following two files provided information critical to the loader.
    The first of these files is the x86 language definition file *x86.ldefs*, is a
    component of the x86 processor module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例利用了现有的处理器架构（x86），并且在幕后做了一些工作，帮助加载器正确运行。回想一下，导入器轮询了加载器并神奇地生成了可接受的语言/编译器规范。以下两个文件提供了对加载器至关重要的信息。第一个文件是
    x86 语言定义文件 *x86.ldefs*，是 x86 处理器模块的一部分。
- en: '***Language Definition Files***'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***语言定义文件***'
- en: 'Every processer has an associated language definition file. This is an XML-formatted
    file that includes all of the information required to generate language/compiler
    specifications for the processor. Language definitions from the *x86.ldefs* file
    that meet the requirements for a 32-bit ELF binary are shown in the following
    listing:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器都有一个关联的语言定义文件。这个 XML 格式的文件包含生成处理器语言/编译器规范所需的所有信息。满足 32 位 ELF 二进制文件要求的来自
    *x86.ldefs* 文件的语言定义如下所示：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This file is used to populate the recommended language/compiler specs presented
    as import options. In this case, there are five recommended specifications (each
    starting with the `compiler` tag), which will be returned based on information
    associated with the ELF binary, but our loader eliminates two from consideration
    based on the compiler ➊ and the variant ➋.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件用于填充作为导入选项呈现的推荐语言/编译器规范。在这种情况下，有五个推荐规范（每个以 `compiler` 标签开头），这些规范将根据与 ELF
    二进制文件相关的信息返回，但我们的加载器会根据编译器 ➊ 和变种 ➋ 排除其中两个。
- en: '***Opinion Files***'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***意见文件***'
- en: 'Another type of support file is the *.opinion* file. This is an XML-formatted
    file that contains constraints associated with your loader. To be recognized by
    the opinion query service, each loader must have an entry in an opinion file.
    The following listing shows a suitable opinion file entry for the loader you just
    built:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的支持文件是*.opinion*文件。这是一个XML格式的文件，包含与你的加载器相关的约束。为了让意见查询服务识别，每个加载器必须在意见文件中有一个条目。以下列出了你刚刚构建的加载器的合适意见文件条目：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Everything in the entry should be familiar, except possibly the `primary` field
    ➋. This field is the primary key for a search that identifies the machine as defined
    in the ELF header. Within the ELF header, the value `0x03` in the `e_machine`
    field means x86, and `0x3E` in the `e_machine` field means amd64\. A `<constraint>`
    tag ➊ defines an association between a primary key (`"3"`/x86) and the remaining
    attributes of the `<constraint>` tag. This information is used by the query service
    to locate the appropriate entries in the language definition files.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 入口中的所有内容应该是熟悉的，除了可能的`primary`字段 ➋。该字段是用于搜索的主键，用于标识在ELF头中定义的机器类型。在ELF头中，`e_machine`字段中的值`0x03`表示x86，而`0x3E`表示amd64。`<constraint>`标签
    ➊定义了主键（`"3"`/x86）和`<constraint>`标签其余属性之间的关联。这些信息由查询服务用于定位语言定义文件中的相关条目。
- en: Our only remaining task is to place our opinion data in an appropriate place
    where Ghidra will find it. The only opinion files that ship with Ghidra reside
    in the *data/languages* subdirectory of a Ghidra processor module. Although you
    could insert your opinion data into an existing opinion file, it’s a good idea
    to avoid modifying any processor opinion files, as your modifications will need
    to be reapplied anytime you upgrade your Ghidra installation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一剩下的任务是将我们的意见数据放置在一个合适的位置，确保Ghidra能够找到它。唯一随Ghidra一起发布的意见文件位于Ghidra处理器模块的*data/languages*子目录下。尽管你可以将意见数据插入到现有的意见文件中，但最好避免修改任何处理器的意见文件，因为每次升级Ghidra安装时，你的修改都需要重新应用。
- en: Instead, create a new opinion file containing our opinion data. You can name
    the file anything you wish, but *SimpleShellcode.opinion* seems reasonable. Our
    Eclipse Loader Module template contains its own *data* subdirectory. Save your
    opinion file in this location so it will be associated with your loader module.
    Ghidra will locate it when looking for opinion files, and any upgrades to the
    Ghidra installation should not affect your module.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，创建一个新的意见文件，包含我们的意见数据。你可以将文件命名为任何你喜欢的名字，但*SimpleShellcode.opinion*似乎是合理的。我们的Eclipse加载器模块模板包含它自己的*data*子目录。将你的意见文件保存在这个位置，这样它将与加载器模块关联。Ghidra在查找意见文件时会定位到它，而且Ghidra的任何升级都不应该影响你的模块。
- en: Now that you understand what is going on behind the scenes, it is time to test
    your loader and see if it behaves as anticipated.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了幕后发生的事情，是时候测试你的加载器，看看它是否按预期运行了。
- en: '***Results***'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: To demonstrate the success of the new simplified ELF loader (one program header
    and no sections), let’s walk through the loading process and observe how the loader
    performs at each step of the process.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示新的简化ELF加载器（一个程序头，没有节区）的成功，让我们逐步了解加载过程，并观察加载器在每个步骤中的表现。
- en: 'From the Ghidra Project window, import a file. The importer will poll all of
    Ghidra’s loaders, including yours, to see which are willing to load this file.
    Recall that your loader is expecting a file that fits the following profile:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ghidra项目窗口导入一个文件。导入器将扫描所有Ghidra的加载器，包括你自己的，看看哪些加载器愿意加载该文件。回顾一下，你的加载器期待的是符合以下配置文件的文件：
- en: ELF magic number at the start of the file
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件开始时的ELF魔数
- en: 32-bit little endian
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位小端
- en: ELF executable for the x86 architecture
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86架构的ELF可执行文件
- en: Cannot have been compiled by Delphi
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能由Delphi编译
- en: Cannot have the variant “System Management Mode”
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能有“系统管理模式”变体
- en: If you load a file that fits that profile, you should see an Import dialog similar
    to the one in [Figure 17-18](ch17.xhtml#fig17_18) that displays a prioritized
    list of the loaders willing to process this file.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你加载了一个符合该配置文件的文件，你应该会看到类似于[图17-18](ch17.xhtml#fig17_18)的导入对话框，显示出愿意处理该文件的加载器的优先列表。
- en: '![image](Images/fig17-18.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-18.jpg)'
- en: '*Figure 17-18: Import options for* elf_shellcode_min'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-18：elf_shellcode_min的导入选项*'
- en: The loader with the highest priority is Ghidra’s ELF loader. Let’s compare the
    language/compiler specifications that it will accept (top of [Figure 17-19](ch17.xhtml#fig17_19))
    with the ones that your new loader will accept at the bottom of the figure.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级最高的加载器是 Ghidra 的 ELF 加载器。让我们将它接受的语言/编译器规范与新加载器在图底部接受的规范进行比较（见 [图 17-19](ch17.xhtml#fig17_19)）。
- en: '![image](Images/fig17-19.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-19.jpg)'
- en: '*Figure 17-19: Acceptable language/compiler specifications for two different
    loaders*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-19：两种不同加载器的可接受语言/编译器规范*'
- en: The Delphi compiler and the System Management Mode variant are accepted by the
    stock ELF loader but not by your loader, as they have been filtered out. When
    you select your loader for the file *elf_shellcode_min*, you should see a summary
    similar to [Figure 17-20](ch17.xhtml#fig17_20).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Delphi 编译器和系统管理模式变种被标准 ELF 加载器接受，但不被你的加载器接受，因为它们已被过滤掉。当你选择加载器加载文件 *elf_shellcode_min*
    时，你应该会看到类似于 [图 17-20](ch17.xhtml#fig17_20) 的汇总信息。
- en: '![image](Images/fig17-20.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig17-20.jpg)'
- en: '*Figure 17-20: Import Results Summary window for the new ELF Shellcode Loader*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-20：新 ELF Shellcode 加载器的导入结果汇总窗口*'
- en: 'If you open the file in the CodeBrowser and allow Ghidra to auto analyze the
    file, you should see the following ELF header definition at the top of the file:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 CodeBrowser 中打开文件，并允许 Ghidra 自动分析该文件，你应该会在文件顶部看到以下 ELF 头部定义：
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Within the listing, the `shellcode` label ➊ is clearly associated with the
    entry point. Double-clicking the `shellcode` label takes you to a function, named
    `shellcode`, that contains the same shellcode contents we’ve seen in our previous
    two examples, including the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，`shellcode` 标签 ➊ 显然与入口点相关。双击 `shellcode` 标签会带你进入一个名为 `shellcode` 的函数，里面包含了我们在之前两个示例中看到的相同的
    shellcode 内容，包括以下内容：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that you have confirmed that your new loader works, you can add it as an
    extension to your Ghidra installation and share it with your colleagues who have
    been anxiously awaiting this functionality.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经确认新加载器正常工作，可以将其作为扩展添加到 Ghidra 安装中，并与那些一直在期待此功能的同事分享。
- en: '**Summary**'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we focused on the challenges associated with dealing with unrecognized
    binary files. We walked through examples of the loading and analysis processes
    that we can use within Ghidra to help us with these challenging reverse engineering
    scenarios. Finally, we extended our module creation capabilities to the world
    of Ghidra loaders.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们集中讨论了处理未识别的二进制文件所面临的挑战。我们通过加载和分析过程的示例，展示了可以在 Ghidra 中使用的方法，以帮助我们解决这些具有挑战性的逆向工程场景。最后，我们将模块创建能力扩展到
    Ghidra 加载器的领域。
- en: While the examples that we built were trivial, they provided the foundation
    and introduced all of the components required to write more complex loader modules
    in Ghidra. In the next chapter, we round out our discussion of Ghidra modules
    with an introduction to processor modules—the components most responsible for
    the overall formatting of a disassembled binary.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们构建的示例非常简单，但它们为编写更复杂的加载器模块提供了基础，并介绍了在 Ghidra 中编写这些模块所需的所有组件。在下一章中，我们将通过介绍处理器模块来完成对
    Ghidra 模块的讨论——这些模块在反汇编二进制文件的整体格式化中起着最重要的作用。
