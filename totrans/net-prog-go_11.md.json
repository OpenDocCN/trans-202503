["```\n`scheme`://`user`:`password`@`host`:`port`/`path`?`key1`=`value1`&`key2`=`value2`#`table_of_contents`\n```", "```\n1https://2images.google.com3/\n```", "```\nhttps://www.google.com/1search2?3q=gophers&tbm=isch . . .\n```", "```\nautomobile://the.grocery.store/purchase?butter=irish&eggs=12&coffee=dark_roast\n```", "```\n$ **nc www.google.com 80**\n1**GET /robots.txt HTTP/1.1**\n\n2 HTTP/1.1 200 OK\n3 Accept-Ranges: none\nVary: Accept-Encoding\nContent-Type: text/plain\nDate: Mon, 02 Jan 2006 15:04:05 MST\nExpires: Mon, 02 Jan 2006 15:04:05 MST\nCache-Control: private, max-age=0\nLast-Modified: Mon, 02 Jan 2006 15:04:05 MST\nX-Content-Type-Options: nosniff\nServer: sffe\nX-XSS-Protection: 0\nTransfer-Encoding: chunked\n\n4User-agent: *\nDisallow: /search\nAllow: /search/about\nAllow: /search/static\nAllow: /search/howsearchworks\n`--snip--` \n```", "```\npackage main\n\nimport (\n    \"net/http\"\n    \"testing\"\n    \"time\"\n)\n\nfunc TestHeadTime(t *testing.T) {\n    resp, err := 1http.Head(\"https://www.time.gov/\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    _ = 2resp.Body.Close() // Always close this without exception.\n\n    now := time.Now().Round(time.Second)\n    date := 3resp.Header.Get(\"Date\")\n    if date == \"\" {\n        t.Fatal(\"no Date header received from time.gov\")\n    }\n\n    dt, err := time.Parse(time.RFC1123, date)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    t.Logf(\"time.gov: %s (skew %s)\", dt, now.Sub(dt))\n}\n```", "```\n1HTTP/1.1 200 OK\nAccept-Ranges: none\nVary: Accept-Encoding\nContent-Type: text/plain\nDate: Mon, 02 Jan 2006 15:04:05 MST\nExpires: Mon, 02 Jan 2006 15:04:05 MST\nCache-Control: private, max-age=0\nLast-Modified: Mon, 02 Jan 2006 15:04:05 MST\nX-Content-Type-Options: nosniff\nServer: sffe\nX-XSS-Protection: 0\nTransfer-Encoding: chunked\n\n2User-agent: *\nDisallow: /search\nAllow: /search/about\nAllow: /search/static\nAllow: /search/howsearchworks\n`--snip--` \n```", "```\n_, _ = io.Copy(ioutil.Discard, response.Body) \n_ = response.Close()\n```", "```\npackage main\n\nimport (\n    \"context\"\n    \"errors\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n    \"time\"\n)\n\nfunc blockIndefinitely(w http.ResponseWriter, r *http.Request) {\n    select {}\n}\n\nfunc TestBlockIndefinitely(t *testing.T) {\n    ts := 1httptest.NewServer(2http.HandlerFunc(3blockIndefinitely))\n    _, _ = http.Get(4ts.URL)\n    t.Fatal(\"client did not indefinitely block\")\n}\n```", "```\n`--snip--`\n\nfunc TestBlockIndefinitelyWithTimeout(t *testing.T) {\n    ts := httptest.NewServer(http.HandlerFunc(blockIndefinitely))\n\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n\n    req, err := 1http.NewRequestWithContext(ctx, http.MethodGet, ts.URL, nil)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        if !errors.Is(err, context.DeadlineExceeded) {\n            t.Fatal(err)\n        }\n        return\n    }\n    _ = resp.Body.Close()\n}\n```", "```\n ctx, cancel := context.WithCancel(context.Background())\n    timer := time.AfterFunc(5*time.Second, 1cancel)\n    // Make the HTTP request, read the response headers, etc.\n    // ...\n    // Add 5 more seconds before reading the response body.\n    timer.Reset(5*time.Second)\n```", "```\n`--snip--`\n    req, err := http.NewRequestWithContext(ctx, http.MethodGet, ts.URL, nil)\n    if err != nil {\n        t.Fatal(err)\n    }\n  1req.Close = true \n`--snip--`\n```", "```\npackage main\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"mime/multipart\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"os\"\n    \"path/filepath\"\n    \"testing\"\n    \"time\"\n)\n\ntype User struct {\n    First string\n    Last  string\n}\n\n1 func handlePostUser(t *testing.T) func(http.ResponseWriter, *http.Request) {\n    return func(w http.ResponseWriter, r *http.Request) {\n        defer func(r io.ReadCloser) {\n            _, _ = 2io.Copy(ioutil.Discard, r)\n            _ = r.Close()\n        }(r.Body)\n\n        if r.Method != 3http.MethodPost {\n          4http.Error(w, \"\", http.StatusMethodNotAllowed)\n            return\n        }\n\n        var u User\n        err := json.NewDecoder(r.Body).Decode(&u)\n if err != nil {\n            t.Error(err)\n            http.Error(w, \"Decode Failed\", http.StatusBadRequest)\n            return\n        }\n\n      5w.WriteHeader(http.StatusAccepted) \n    }\n}\n```", "```\n`--snip--`\n\nfunc TestPostUser(t *testing.T) {\n    ts := httptest.NewServer(http.HandlerFunc(handlePostUser(t)))\n    defer ts.Close()\n\n    resp, err := http.Get(ts.URL)\n    if err != nil {\n        t.Fatal(err)\n    }\n    if 1resp.StatusCode != http.StatusMethodNotAllowed {\n        t.Fatalf(\"expected status %d; actual status %d\",\n            http.StatusMethodNotAllowed, resp.StatusCode)\n    }\n\n    buf := new(bytes.Buffer)\n    u := User{First: \"Adam\", Last: \"Woodbeck\"}\n 2 err = json.NewEncoder(buf).Encode(&u)\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    resp, err = 3http.Post(ts.URL, \"application/json\", buf)\n    if err != nil {\n        t.Fatal(err)\n    }\n    if resp.StatusCode != 4http.StatusAccepted {\n        t.Fatalf(\"expected status %d; actual status %d\",\n            http.StatusAccepted, resp.StatusCode)\n }\n    _ = resp.Body.Close()\n}\n```", "```\n`--snip--`\n\nfunc TestMultipartPost(t *testing.T) {\n    reqBody := 1new(bytes.Buffer)\n    w := 2multipart.NewWriter(reqBody)\n\n    for k, v := range map[string]string{\n        \"date\":        time.Now().Format(time.RFC3339),\n        \"description\": \"Form values with attached files\",\n    } {\n        err := 3w.WriteField(k, v)\n        if err != nil {\n            t.Fatal(err)\n        }\n    }\n```", "```\n`--snip--`\n\n    for i, file := range []string{\n        \"./files/hello.txt\",\n        \"./files/goodbye.txt\",\n    } {\n        filePart, err := 1w.CreateFormFile(fmt.Sprintf(\"file%d\", i+1),\n            filepath.Base(file))\n        if err != nil {\n            t.Fatal(err)\n        }\n\n        f, err := os.Open(file)\n        if err != nil {\n            t.Fatal(err)\n        }\n\n        _, err = 2io.Copy(filePart, f)\n        _ = f.Close()\n        if err != nil {\n            t.Fatal(err)\n        }\n    }\n\n    err := 3w.Close()\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```\n`--snip--`\n\n    ctx, cancel := context.WithTimeout(context.Background(),\n        60*time.Second)\n    defer cancel()\n\n    req, err := http.NewRequestWithContext(ctx, http.MethodPost,\n      1\"https://httpbin.org/post\", 2reqBody)\n    if err != nil {\n        t.Fatal(err)\n    }\n    req.Header.Set(\"Content-Type\", 3w.FormDataContentType())\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer func() { _ = resp.Body.Close() }()\n\n    b, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        t.Fatal(err)\n    }\n    if resp.StatusCode != http.StatusOK {\n        t.Fatalf(\"expected status %d; actual status %d\",\n            http.StatusOK, resp.StatusCode)\n    }\n\n    t.Logf(\"\\n%s\", b)\n}\n```", "```\n{\n  \"args\": {},\n  \"data\": \"\",\n1\"files\": {\n    \"file1\": \"Hello, world!\\n\",\n    \"file2\": \"Goodbye, world!\\n\"\n  },\n2\"form\": {\n    \"date\": \"2006-01-02T15:04:05-07:00\",\n    \"description\": \"Form fields with attached files\"\n  },\n  \"headers\": {\n    \"Accept-Encoding\": \"gzip\",\n    \"Content-Length\": \"739\",\n 3 \"Content-Type\": \"multipart/form-data; boundary=e9ad4b62e0dfc8d7dc57ccfa8ba62244342f1884608e6d88018f9de8abcb\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"Go-http-client/1.1\"\n  },\n  \"json\": null,\n  \"origin\": \"192.168.0.1\",\n  \"url\": \"https://httpbin.org/post\"\n}\n```"]