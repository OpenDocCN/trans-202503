<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch7" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch7">
<span class="cn"><span aria-label=" Page 69. " epub:type="pagebreak" id="pg_69" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">7</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">WORKING WITH FILES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">If you were to ask a coder only tangentially acquainted with Batch for its primary use, their response would likely mention moving files around. Batch can do much more, but without a doubt one of its primary uses is file movements. In this chapter, we’ll explore the different commands and techniques available. You’ll also learn about creating empty files, along with methods for merging, moving, renaming, and deleting files. I’ll introduce file masks and wildcards, allowing you to execute the commands you’re about to learn on many similarly named files instead of just one.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-50"/><span aria-label=" Page 70. " epub:type="pagebreak" id="pg_70" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Commands for Copying Files</span></h3>
<p class="tni">Batch has three commands for copying files: <span class="sans_thesansmonocd_w5regular_">copy</span>, <span class="sans_thesansmonocd_w5regular_">xcopy</span>, and <span class="sans_thesansmonocd_w5regular_">robocopy</span>. In this section, I’ll compare them and give recommendations on when to use each one, because they have their respective niches. Are you copying many small files or a few large files? Is the network stable? Is speed a consideration? Do you want a straightforward return code or one that’s more nuanced? How important is the logging to you? You’ll need to answer many questions before deciding on the optimal command and options for any particular copy.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="h1" id="sec2"><span id="h2-22"/><span class="sans_futura_std_heavy_oblique_bi_">copy</span></h4>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">copy</span> command offers a quick and easy way to create empty files:</p>
<pre class="pre"><code class="calibre11">copy nul C:\Target\EmptyFile.dat</code></pre>
<p class="tx">In Batch, the word <span class="sans_thesansmonocd_w5regular_">nul</span> represents a perpetually null or empty file (apparently, someone felt the need to abbreviate <i class="calibre6">null</i>). Here we’re making a copy of the <span class="sans_thesansmonocd_w5regular_">nul</span> file to produce an empty file with a path and name of our choosing (in <span class="xref"><a href="chapter12.xhtml" class="calibre3">Chapter 12</a></span>, I’ll demonstrate how to dispose of unwanted output by sending it to this file where it disappears). A fun fact: Windows won’t let you create a file named <span class="sans_thesansmonocd_w5regular_">nul</span> in any folder, regardless of the extension or the lack of an extension, even manually. Go ahead and try.</p>
<p class="tx">The only other use I’ve ever had for the <span class="sans_thesansmonocd_w5regular_">copy</span> command is to merge two or more relatively small files. The <span class="sans_thesansmonocd_w5regular_">/B</span> option performs a <i class="calibre6">binary</i> file copy, which means that every byte, even special characters such as the carriage return and line feed, are copied without alteration, resulting in a true concatenation of the files. The source files are separated by the plus sign, followed by the merged file:</p>
<pre class="pre"><code class="calibre11">copy /B C:\Source\Header.txt + C:\Source\Details.txt C:\Target\MergedFile.txt</code></pre>
<p class="tni">We’re concatenating two files here, but we can merge more with more plus sign delimiters.</p>
<p class="tx">You may have noticed that I’ve mentioned only two uses for the <span class="sans_thesansmonocd_w5regular_">copy</span> command, neither of which involve the copying of actual files. You can use the command to copy files, but I never use it for this purpose because it’s primitive and has a paucity of options. These shortcomings were apparent shortly after the first release of Batch, and it was soon largely replaced by the far more useful and configurable <span class="sans_thesansmonocd_w5regular_">xcopy</span> command.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1" id="sec3"><span id="h2-23"/><span class="sans_futura_std_heavy_oblique_bi_">xcopy</span></h4>
<p class="tni">The basic syntax for the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command has two arguments—the source file and the destination path:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Source\File2Copy.txt C:\Target\</code></pre>
<p class="tx"><span aria-label=" Page 71. " epub:type="pagebreak" id="pg_71" role="doc-pagebreak"/>One huge advantage of the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command is that it’ll create the target directory if it doesn’t yet exist. In contrast, the <span class="sans_thesansmonocd_w5regular_">copy</span> command wouldn’t find the path and would fail.</p>
<p class="tx">In the previous example only a target path is given, which means the copied file will have the same name as the source file. But we can rename the destination file as part of the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command by simply giving it a filename:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Source\File2Copy.txt C:\Target\RenamedFile.dat</code></pre>
<p class="tni">This command sometimes fails because the interpreter isn’t sure whether the destination is a directory or a file (in <span class="xref"><a href="chapter12.xhtml" class="calibre3">Chapter 12</a></span>, I’ll discuss how to make that work all of the time).</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">xcopy</span> command has two options that I use nearly every time I invoke the command. The <span class="sans_thesansmonocd_w5regular_">/Y</span> option suppresses the prompt to confirm overwriting a destination file. Although it might make sense to ask for confirmation when running via a command prompt or even interactively, in most other situations it does nothing more than halt processing and create a hang, so it’s best to turn it off.</p>
<p class="tx">The other option I can’t do without is <span class="sans_thesansmonocd_w5regular_">/F</span>. It displays the full source and destination paths and filenames of every file copied, which leaves a useful audit trail when the wildcard is used to copy multiple files. Without the <span class="sans_thesansmonocd_w5regular_">/F</span> option, only the source file or files are shown along with a total file count. At the other extreme, if you’re not interested in all of this information, you can use the <span class="sans_thesansmonocd_w5regular_">/Q</span> option (for <i class="calibre6">quiet</i> mode) to turn off the display altogether.</p>
<p class="tx">Using these two indispensable options, the following command suppresses the prompts and supplies detailed logging:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Source\File2Copy.txt C:\Target\ /Y /F</code></pre>
<p class="tx">This command has too many available options to reasonably go over here; use the <span class="sans_thesansmonocd_w5regular_">help</span> command for a full list. As a small sampling, however, the <span class="sans_thesansmonocd_w5regular_">/U</span> option copies only files that already exist at the destination; the <span class="sans_thesansmonocd_w5regular_">/S</span> option copies folders and subfolders; and the <span class="sans_thesansmonocd_w5regular_">/J</span> option uses unbuffered I/O, which is optimal for very large files.</p>
<p class="tx">Although <span class="sans_thesansmonocd_w5regular_">copy</span> has been deprecated in favor of <span class="sans_thesansmonocd_w5regular_">xcopy</span>, Microsoft technically considers <span class="sans_thesansmonocd_w5regular_">xcopy</span> itself deprecated in favor of the even newer <span class="sans_thesansmonocd_w5regular_">robocopy</span> command. Even so, the wide use of the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command means it’ll still be available in foreseeable operating systems, and as I’ll detail shortly, it’s still the better choice in many instances. I even used this command in what may have been your very first bat file in <span class="xref"><a href="chapter1.xhtml" class="calibre3">Chapter 1</a></span>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1" id="sec4"><span id="h2-24"/><span class="sans_futura_std_heavy_oblique_bi_">robocopy</span></h4>
<p class="tni">Removing the last character from the name of the command reveals the title of an old science-fiction film, but <span class="sans_thesansmonocd_w5regular_">robocopy</span> really stands for <i class="calibre6">robust copy</i>, which isn’t hyperbole. Although <span class="sans_thesansmonocd_w5regular_">xcopy</span> has many useful options, <span class="sans_thesansmonocd_w5regular_">robocopy</span> provides some impressive logging and a mind-boggling array of options.</p>
<p class="tx"><span aria-label=" Page 72. " epub:type="pagebreak" id="pg_72" role="doc-pagebreak"/>Even though the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command is far more powerful than <span class="sans_thesansmonocd_w5regular_">xcopy</span>, it’s also quite easy to use. The arguments are a bit different: first provide the source directory sans the filename, then the destination directory, and finally the file, files, or file mask to be copied:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ File2Copy.txt</code></pre>
<p class="tni">This example is functionally equivalent to the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command from the previous section and reproduced here:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Source\File2Copy.txt C:\Target\</code></pre>
<p class="tx">Because the first two arguments of the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command are known to be paths, you can leave off the trailing slash, which is a great advantage over <span class="sans_thesansmonocd_w5regular_">xcopy</span> where a missed slash can turn a destination directory into a filename.</p>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="h2" id="sec5"><span class="sans_futura_std_bold_b_">robocopy Logging</span></h5>
<p class="tni">To get an idea of how robust <span class="sans_thesansmonocd_w5regular_">robocopy</span> really is, look no further than its logging capability. If you are an <span class="sans_thesansmonocd_w5regular_">xcopy</span> aficionado, be seated before glancing ahead. Verbose is the only word that comes to mind, and even that isn’t adequate. Besides the list of files copied, logs include a fancy header, the start and end times, file sizes, copy speed statistics, source and destination paths, total counts of the files and directories copied and skipped, along with any failed copies, a list of the command line options used, and much more. It’s even formatted nicely with plenty of whitespace for readability.</p>
<p class="tx">The simple <span class="sans_thesansmonocd_w5regular_">robocopy</span> command shown previously to copy a single file generates the following log:</p>
<pre class="pre"><code class="calibre11">-----------------------------------------------------------------------------
   ROBOCOPY      ::      Robust File Copy for Windows
-----------------------------------------------------------------------------

  Started : Tuesday, January 30, 2007 12:18:44 PM
   Source : C:\Source\
     Dest : C:\Target\

    Files : File2Copy.txt
   
  Options : /DCOPY:DA /COPY:DAT /R:1000000 /W:30 

-----------------------------------------------------------------------------

     New Dir          1 C:\Source\
       New File         83146 File2Copy.txt
100% 

-----------------------------------------------------------------------------
<span aria-label=" Page 73. " epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/>
               Total    Copied   Skipped  Mismatch    FAILED    Extras
    Dirs :         1         1         0         0         0         0
   Files :         1         1         0         0         0         0
   Bytes :    81.1 k    81.1 k         0         0         0         0
   Times :   0:00:00   0:00:00                       0:00:00   0:00:00

   Speed :            20786500 Bytes/sec.
   Speed :            1189.413 MegaBytes/min.
   Ended : Tuesday, January 30, 2007 12:18:44 PM
</code></pre>
<p class="tx">Some of the results are self-explanatory such as <span class="sans_thesansmonocd_w5regular_">Total</span>, <span class="sans_thesansmonocd_w5regular_">Copied</span>, and <span class="sans_thesansmonocd_w5regular_">FAILED</span>, but others are not. If a file to be copied is already in the destination path and is identical, <span class="sans_thesansmonocd_w5regular_">robocopy</span> is smart enough to not waste time overlaying it and instead considers it justifiably <span class="sans_thesansmonocd_w5regular_">Skipped</span>. A <span class="sans_thesansmonocd_w5regular_">Mismatch</span> occurs when a copy is thwarted because a source file and a destination folder (or a source folder and a destination file) have the same name. <span class="sans_thesansmonocd_w5regular_">Extras</span> are files and directories not at the source but already at the destination. Obviously, the files weren’t copied, but the interpreter feels obligated to note their existence. For this task of copying one small file, the logging may be overkill. A more interesting task might go on for pages, but for that more interesting task, the logging may be invaluable.</p>
<p class="tx">By default, all this information is written to the console (in <span class="xref"><a href="chapter12.xhtml" class="calibre3">Chapter 12</a></span>, I’ll discuss how to instead redirect logging from any command or even an entire bat file to a logfile). But the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command is unique in that you can easily create a logfile with an option. The path and name of the logfile simply follows the appropriately named <span class="sans_thesansmonocd_w5regular_">/LOG</span> option, delimited by a colon.</p>
<p class="tx">This may be the first instance you’ve seen where an option has more than one character after the slash, and this command has plenty more. Adding the plus sign to the option, <span class="sans_thesansmonocd_w5regular_">/LOG+</span>, results in the information being appended to the logfile if it already exists. To demonstrate, consider the following:</p>
<pre class="pre"><code class="calibre11">set roboLog=C:\Batch\Robocopy.log
robocopy C:\Source\ C:\Target\ File2Copy.txt /LOG:%roboLog% /NP
robocopy C:\Source\ C:\Target\ AnotherFile2Copy.txt /LOG+:%roboLog% /NP
</code></pre>
<p class="tx">After defining <span class="sans_thesansmonocd_w5regular_">roboLog</span> as the path and name of the logfile, it’s used in two <span class="sans_thesansmonocd_w5regular_">robocopy</span> commands. The first creates the logfile with information from its copy, overwriting an existing file if present, and the second <span class="sans_thesansmonocd_w5regular_">robocopy</span> command appends to that logfile with the results of its copy.</p>
<p class="tx">Both of the last two commands use the <span class="sans_thesansmonocd_w5regular_">/NP</span> option, which stands for <i class="calibre6">no progress</i>, because I consider it a necessity when creating a logfile. If the information is being written to the console, the progress of each copy is shown in real time as a percentage, updated multiple times a second. Relatively large files might display several dozens of values before <span class="sans_thesansmonocd_w5regular_">100%</span> is finally shown. That status is great when viewed on the console, but in a logfile, each update becomes a new record. It doesn’t take many large files to turn the log into a complete mess. Even small files can result in a few extra unneeded records in the logfile. The <span class="sans_thesansmonocd_w5regular_">/NP</span> option cleans that up very nicely, updating the log only after each copy completes.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="h2" id="sec6"><span aria-label=" Page 74. " epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Useful robocopy Options</span></h5>
<p class="tni">There are many <span class="sans_thesansmonocd_w5regular_">robocopy</span> options, so I’ll quickly go over the most useful ones. But first, here’s a command to serve as the canvas for the options:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\</code></pre>
<p class="tni">This simple command (lacking the third argument of a file) copies all files in the source directory to the target directory.</p>
<p class="tx">The command automatically performs retries of failed copies, which is fabulous, but the default is a staggering one million attempts, each separated by a 30-second wait. This can result in a hang of several months for a fatally flawed attempted copy. The <span class="sans_thesansmonocd_w5regular_">/R</span> and <span class="sans_thesansmonocd_w5regular_">/W</span> options override the default number of <i class="calibre6">retries</i> and the <i class="calibre6">wait</i> time in seconds, respectively:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ /R:20 /W:5</code></pre>
<p class="tni">With these options, the interpreter will retry the failed copy up to <span class="sans_thesansmonocd_w5regular_">20</span> times, with <span class="sans_thesansmonocd_w5regular_">5</span> seconds between each attempt, before initiating an abort. Choose values that make sense to you and your hardware, but the defaults must not stand.</p>
<p class="tx">If you add the <span class="sans_thesansmonocd_w5regular_">/S</span> option, it also will copy all the <i class="calibre6">subdirectories</i>, except for empty subdirectories:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ /S</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/E</span> option copies all of the subdirectories, <i class="calibre6">empty</i> and nonempty alike:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ /E</code></pre>
<p class="tx">You can refine this option to copy only the files in the source directory (<i class="calibre6">C:\Source\</i>) and its immediate subdirectories, but not lower levels of subdirectories. The <span class="sans_thesansmonocd_w5regular_">/LEV</span> option defines the number of <i class="calibre6">levels</i>, including the root, as <span class="sans_thesansmonocd_w5regular_">2</span>, to handle that:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ /E /LEV:2</code></pre>
<p class="tx">Unbuffered I/O is more efficient for very large files and is invoked oddly enough with the <span class="sans_thesansmonocd_w5regular_">/J</span> option. (This option is borrowed from the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, where the <span class="sans_thesansmonocd_w5regular_">/U</span> option was already spoken for.) The <span class="sans_thesansmonocd_w5regular_">/MIN</span> and <span class="sans_thesansmonocd_w5regular_">/MAX</span> options set <i class="calibre6">minimum</i> and <i class="calibre6">maximum</i> byte limits for the files to be copied. The following two commands copy all files in a folder, using unbuffered I/O for only the files of at least 1GB:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ /MIN:1000000000 /J
robocopy C:\Source\ C:\Target\ /MAX:999999999 /MT
</code></pre>
<p class="tni"><span aria-label=" Page 75. " epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/>I snuck the <span class="sans_thesansmonocd_w5regular_">/MT</span> option, which stands for <i class="calibre6">multithreading</i>, into the command for the smaller files. By default, the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command copies files serially, but this option copies eight files in parallel. You can even define the number of threads; <span class="sans_thesansmonocd_w5regular_">/MT:128</span> is the maximum, but in my experience, this isn’t appreciably faster than the option default of eight. We can debate the threshold, but unbuffered I/O for large files and multithreading for smaller files will optimize any copy.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/MINAGE</span> and <span class="sans_thesansmonocd_w5regular_">/MAXAGE</span> options (<i class="calibre6">minimum</i> and <i class="calibre6">maximum ages</i>) define what’s to be copied based on the last modified date. You can use them individually or together to create a date range. The following command copies only files touched since Microsoft’s disastrous release of Windows Me on September 14, 2000, excluding anything that was changed in the last seven days:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target /MAXAGE:20000914 /MINAGE:7</code></pre>
<p class="tx">You can define the value of both options as either a date (formatted as CCYYMMDD) or a number of days. The interpreter is smart enough to know that the eight-byte number represents a date and not a timespan of more than 50,000 years. Batch may not be a new language, but it was used by neither the Denisovans nor our hunter-gatherer forebearers. Any number less than 1,900 is considered by the interpreter to be a number of days.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/PURGE</span> option deletes extra files and directories at the destination, which you obviously should use with caution, but it’s a very handy tool for creating backups. If you back up a folder one day, change the name of a file in the source directory the next, and then back up the folder again, you’ll end up with an extraneous file in the backup unless you use the <span class="sans_thesansmonocd_w5regular_">/PURGE</span> option. Even better is the <span class="sans_thesansmonocd_w5regular_">/MIR</span> option that <i class="calibre6">mirrors</i> a directory tree. The <span class="sans_thesansmonocd_w5regular_">/MIR</span> option essentially does what the <span class="sans_thesansmonocd_w5regular_">/PURGE</span> option does, but it includes subdirectories.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/XF</span> option <i class="calibre6">excludes</i> one or more <i class="calibre6">files</i> from the copy, while <span class="sans_thesansmonocd_w5regular_">/XD</span> similarly <i class="calibre6">excludes</i> one or more <i class="calibre6">directories</i>. The <span class="sans_thesansmonocd_w5regular_">/L</span> option doesn’t copy anything; it produces a <i class="calibre6">list</i> of everything that would’ve been copied if the option hadn’t been used.</p>
<p class="tx">You can also use the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command to move files (see <span class="xref">“Moving Files”</span> on page <span class="xref">80</span>). As always, use the <span class="sans_thesansmonocd_w5regular_">help</span> command for a complete list of available options.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="h2" id="sec7"><span class="sans_futura_std_bold_b_">The robocopy Return Code</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">xcopy</span> command is like most Batch commands in that a successful execution returns an <span class="sans_thesansmonocd_w5regular_">errorlevel</span> of <span class="sans_thesansmonocd_w5regular_">0</span>, while a failure returns a number other than <span class="sans_thesansmonocd_w5regular_">0</span>. In contrast, <span class="sans_thesansmonocd_w5regular_">robocopy</span> is unique—a uniqueness that if not understood can breed much bewilderment. A return code of <span class="sans_thesansmonocd_w5regular_">0</span> means that nothing was copied, but if at least one file was copied successfully, the interpreter returns an odd number between <span class="sans_thesansmonocd_w5regular_">1</span> and <span class="sans_thesansmonocd_w5regular_">15</span>, inclusive, but even some of those <span aria-label=" Page 76. " epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/>codes aren’t exactly <i class="calibre6">good</i> return codes. Here are the six basic return codes the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command generates:</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_b_">0</span>    No error, but no file(s) was copied; in other words, all files were skipped.</p>
<p class="runinpara1"><span class="sans_thesansmonocd_w7bold_b_">1</span>    One or more files copied successfully.</p>
<p class="runinpara1"><span class="sans_thesansmonocd_w7bold_b_">2</span>    One or more extra files or directories were found; none were copied.</p>
<p class="runinpara1"><span class="sans_thesansmonocd_w7bold_b_">4</span>    One or more mismatches were found; none were copied.</p>
<p class="runinpara1"><span class="sans_thesansmonocd_w7bold_b_">8</span>    Some files or directories could not be copied.</p>
<p class="runinpara2"><span class="sans_thesansmonocd_w7bold_b_">16</span>    Nothing was copied; there was a serious error.</p>
<p class="tx">Oh, the elegance of the <i class="calibre6">powers of two</i>; a mathematician must’ve come up with these return codes. Wouldn’t it have been easier to use codes <span class="sans_thesansmonocd_w5regular_">0</span> through <span class="sans_thesansmonocd_w5regular_">5</span>? No, the four codes in the middle aren’t mutually exclusive; that is, it’s possible for more than one of them (even all four) to be true at the same time. The interpreter adds up all of the codes that are true and returns the sum as the <span class="sans_thesansmonocd_w5regular_">errorlevel</span>.</p>
<p class="tx">As an example, envision a <span class="sans_thesansmonocd_w5regular_">robocopy</span> command of all files in a source folder to a destination folder where some files are copied successfully, but the destination also has extra copies. Return codes <span class="sans_thesansmonocd_w5regular_">1</span> and <span class="sans_thesansmonocd_w5regular_">2</span> are both true; hence, <span class="sans_thesansmonocd_w5regular_">3</span>, their sum, is returned as the <span class="sans_thesansmonocd_w5regular_">errorlevel</span>. It’s also possible that when files were copied, extras were found along with a mismatch, and another file failed to copy because it was held open by someone or some process. Do the math (1 + 2 + 4 + 8), and the interpreter returns <span class="sans_thesansmonocd_w5regular_">15</span>.</p>
<p class="tx">These return codes give the savvy coder the opportunity to fine-tune the error handling. Return codes of <span class="sans_thesansmonocd_w5regular_">1</span> and <span class="sans_thesansmonocd_w5regular_">3</span> are clearly good, and I often consider <span class="sans_thesansmonocd_w5regular_">3</span> or less to also be good. Anything from <span class="sans_thesansmonocd_w5regular_">4</span> to <span class="sans_thesansmonocd_w5regular_">7</span> involves a mismatch, and anything above that has at least one explicit failure. Depending on the circumstances, mismatches might be completely acceptable so that only a return code of <span class="sans_thesansmonocd_w5regular_">8</span> or greater would be considered bad.</p>
<p class="tx">To explicitly verify that at least one file was copied, we need to look only for an odd-numbered return code, which we can do with the modulo function from <span class="xref"><a href="chapter6.xhtml" class="calibre3">Chapter 6</a></span>.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="h2" id="sec8"><span class="sans_futura_std_bold_b_">xcopy vs. robocopy</span></h5>
<p class="tni">Despite the subjective nature of the word, most Batch coders agree that <span class="sans_thesansmonocd_w5regular_">robocopy</span> is <i class="calibre6">better</i> than <span class="sans_thesansmonocd_w5regular_">xcopy</span> because of its myriad of options, multithreading, automated retries, impressive logging, and everything behind the scenes that makes it more efficient. But there’s one major batveat. When trying to copy a single file, the <span class="sans_thesansmonocd_w5regular_">xcopy</span> error handling is <i class="calibre6">better</i> by far. Both of these commands are attempting to copy a named file that doesn’t exist:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Source\NonExistentFile.txt C:\Target\
robocopy C:\Source\ C:\Target\ NonExistentFile.txt
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">xcopy</span> command reports that no files were copied and returns an <span class="sans_thesansmonocd_w5regular_">errorlevel</span> of <span class="sans_thesansmonocd_w5regular_">4</span>, but the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command simply returns <span class="sans_thesansmonocd_w5regular_">0</span>, stating that <span aria-label=" Page 77. " epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/>there were no errors and no files copied. I contend that this should be an error. When attempting to copy multiple files, both commands return <span class="sans_thesansmonocd_w5regular_">0</span> when there are no source files—that makes sense, but both of these commands are calling for an explicit file to be copied, and the <span class="sans_thesansmonocd_w5regular_">robocopy</span> return code doesn’t distinguish between the file not being found and being skipped because it already exists at the target directory. The skipping of nonupdated files is a great feature of <span class="sans_thesansmonocd_w5regular_">robocopy</span>, but it’s something quite different from a file not being found. The robust logging makes this clear, but the return code does not.</p>
<p class="tx">This failure of the return code to report why a file wasn’t copied (not found or skipped) is a deficiency, but we can overcome it. When copying one specific file with the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command, you can perform an <span class="sans_thesansmonocd_w5regular_">if exist</span> on the target file when <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is <span class="sans_thesansmonocd_w5regular_">0</span>. If it exists, the file was properly skipped; if not, there was an error. Or, do as I do and just use <span class="sans_thesansmonocd_w5regular_">xcopy</span> in this situation.</p>
<p class="tx">There are other instances when the complex return code of the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command is more than what’s needed. You might not care whether there are extra or mismatched files and instead just want a simple result of good or bad, zero or nonzero. There’s nothing wrong with that, and if I’m being honest, I sometimes still use it in new code out of habit and ease of use.</p>
<p class="tx">That said, the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command is, as its name suggests, much more robust. It’s far more configurable, faster, and less prone to fail. If copying very large files, a large number of files, or files that might fail due to a connectivity issue, <span class="sans_thesansmonocd_w5regular_">robocopy</span> is the obvious choice, and that complex return code is a major boon at times. Also, the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command has a 254-byte limitation on the length of a path and filename. I’ve never come close to exceeding this limitation, but if you ever do, <span class="sans_thesansmonocd_w5regular_">robocopy</span> can handle it.</p>
<p class="tx">The most definitive statement I’ll make on this topic is that you should never use the <span class="sans_thesansmonocd_w5regular_">copy</span> command to copy a file, but keep it in your toolbox for creating an empty file or merging files.</p>
</section>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="h" id="sec9"><span id="h1-51"/><span class="sans_futura_std_bold_b_">File Masks and Wildcards</span></h3>
<p class="tni">All of the previous <span class="sans_thesansmonocd_w5regular_">xcopy</span> examples copied a single file, and the <span class="sans_thesansmonocd_w5regular_">robocopy</span> examples copied either a single file or all of the files in a directory. But with file masks and wildcards, you can create far more targeted commands that copy only some of the files in a directory; in fact, they might copy a different number of files every time they execute. A <i class="calibre6">file mask</i> replaces the filename in both of these commands and consists of one or more <i class="calibre6">wildcard</i> characters, possibly with some hardcoded text or resolved variables. Then when it executes, the command copies all of the files that satisfy or fit the file mask.</p>
<p class="tx">File masks are not unique to commands that copy files. Upcoming commands in this chapter for moving, deleting, and even renaming files also accept file masks in lieu of filenames, allowing you to move, delete, and rename multiple files at once. The <span class="sans_thesansmonocd_w5regular_">for</span> command makes great use of file masks, and I’ll demonstrate how in <span class="xref"><a href="part2.xhtml" class="calibre3">Part II</a></span>. Any command that performs some action on a file probably works with wildcards; experiment if in doubt.</p>
<p class="tx"><span aria-label=" Page 78. " epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/>Batch recognizes two characters as wildcards, the asterisk (<span class="sans_thesansmonocd_w5regular_">*</span>) and the question mark (<span class="sans_thesansmonocd_w5regular_">?</span>). They behave quite differently, and I’ll detail both with the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, but first let’s take a look at a set of files to copy. A meticulously organized person might maintain spreadsheets with budget information, one file for each month of a year. For this demonstration, the <i class="calibre6">C:\Budget\</i> folder contains spreadsheets with a naming convention noting the year and month. Here are just three:</p>
<pre class="pre"><code class="calibre11">Budget.January2008.xlsx
Budget.February2008.xlsx
Budget.March2008.xlsx
</code></pre>
<p class="tni">These files are from the year of the financial crisis and the start of the Great Recession, and the folder contains similarly named files from the year before and after, along with other types of files.</p>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1" id="sec10"><span id="h2-25"/><span class="sans_futura_std_heavy_oblique_bi_">The Asterisk Wildcard Character</span></h4>
<p class="tni">The asterisk is the most common Batch wildcard character and is a stand-in for zero to many characters. To demonstrate, the following <span class="sans_thesansmonocd_w5regular_">xcopy</span> command copies all of the files, and only the files, from 2008, or more specifically, the files residing in <i class="calibre6">C:\Budget\</i> that satisfy the <span class="sans_thesansmonocd_w5regular_">Budget.*2008.xlsx</span> mask:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Budget\Budget.*2008.xlsx C:\Target /F /Y</code></pre>
<p class="tx">The asterisk is the wildcard, meaning that this command copies every file with a name that starts with <span class="sans_thesansmonocd_w5regular_">Budget.</span> and ends with <span class="sans_thesansmonocd_w5regular_">2008.xlsx</span>, with something, or even nothing, in between. If a file named <i class="calibre6">Budget.2008.xlsx</i> happens to be in the folder, it also satisfies the mask and is one of the copied files.</p>
<p class="tx">By the end of the year, a dozen such files should satisfy this mask, one for each month, resulting in the command copying all 12. But the command won’t copy files from 2007 or 2009, nor will it copy a Word document with the same name but a different extension, such as <i class="calibre6">Budget.June2008 .docx</i>. If you were to remove the first dot from the name of one of the files, <i class="calibre6">BudgetAugust2008.xlsx</i>, the interpreter won’t copy it either because it doesn’t satisfy the mask.</p>
<p class="tx">The following very subtle change of inserting the letter <span class="sans_thesansmonocd_w5regular_">J</span> before the wildcard results in the command copying only three files, the ones for January, June, and July:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Budget\Budget.J*2008.xlsx C:\Target /F /Y</code></pre>
<p class="tni">Add one more character before the wildcard, and the <span class="sans_thesansmonocd_w5regular_">Budget.Ju*2008.xlsx</span> mask excludes the January file.</p>
<p class="tx">You aren’t limited to a single wildcard in a mask. Here’s an example that uses two asterisks, where the last one is a stand-in for the extension:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Budget\Budget.*2008.* C:\Target /F /Y</code></pre>
<p class="tni"><span aria-label=" Page 79. " epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>The aforementioned Word document, <i class="calibre6">Budget.June2008.docx</i>, now gets caught up in the dragnet.</p>
<p class="tx">You now know that the asterisk wildcard can represent any text of any length, including no text at all, but there are times that you may want to be more restrictive. Batch has a lesser known and much lesser understood wildcard character for this purpose.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1" id="sec11"><span id="h2-26"/><span class="sans_futura_std_heavy_oblique_bi_">The Question Mark Wildcard Character</span></h4>
<p class="tni">While the asterisk is a wildcard for zero to many characters, the question mark is a wildcard for exactly one character, <i class="calibre6">usually</i>. (Yes, the italics mean that a batveat is on the way.) To copy files only with four-character months, I’ll use four question marks where there once was an asterisk:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Budget\Budget.????2008.xlsx C:\Target /F /Y</code></pre>
<p class="tni">This command copies the files for June and July, but not the files for March, April, May, and all the other months, which happen to be more verbose.</p>
<p class="tx">That seems straightforward, but I promised you a batveat. If a set of one or more question mark wildcards comes at the end of a file mask or if those question marks immediately precede a dot, Batch also considers a null to be a valid replacement value for each of the question marks.</p>
<p class="tx">To illustrate, I’ll make a tweak to the file naming convention by inserting a period between the month and year, resulting in filenames such as these:</p>
<pre class="pre"><code class="calibre11">Budget.April.2008.xlsx
Budget.May.2008.xlsx
Budget.June.2008.xlsx
Budget.July.2008.xlsx
</code></pre>
<p class="tx">Next, I’ll insert the period into the file mask between the four question marks and the year like so:</p>
<pre class="pre"><code class="calibre11">xcopy C:\Budget\Budget.????.2008.xlsx C:\Target /F /Y</code></pre>
<p class="tx">Even some experienced Batch coders might expect the files for June and July only to satisfy this mask. They would be correct in that files for March, April, and all the other months denoted with more than four letters won’t be copied, but the file for May will also satisfy the mask. The first three wildcards match on each of the three letters in <span class="sans_thesansmonocd_w5regular_">May</span>, but the fourth question mark matches on a null or nonexistent character. Even the oddly named <i class="calibre6">Budget..2008.xlsx</i> satisfies this mask.</p>
<p class="tx">The upshot is that when <i class="calibre6">n</i> question mark wildcards come at the end of a file mask or are followed by a dot, the mask is satisfied with zero to <i class="calibre6">n</i> characters. Otherwise, <i class="calibre6">n</i> question mark wildcards are satisfied with exactly <i class="calibre6">n</i> characters. It’s a very subtle oddity, and understanding it might save you hours of grief.</p>
<p class="tx"><span aria-label=" Page 80. " epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/>To put a fine point on the difference between the two Batch wildcard characters, <span class="sans_thesansmonocd_w5regular_">shot</span>, <span class="sans_thesansmonocd_w5regular_">shoot</span>, <span class="sans_thesansmonocd_w5regular_">shut</span>, <span class="sans_thesansmonocd_w5regular_">shunt</span>, <span class="sans_thesansmonocd_w5regular_">shallot</span>, and even <span class="sans_thesansmonocd_w5regular_">sht</span> all satisfy the <span class="sans_thesansmonocd_w5regular_">sh*t</span> file mask. Of these words (and one nonword), only <span class="sans_thesansmonocd_w5regular_">shot</span> and <span class="sans_thesansmonocd_w5regular_">shut</span> satisfy the <span class="sans_thesansmonocd_w5regular_">sh?t</span> file mask.</p>
<aside aria-label="box-1" class="box">
<p class="boxtitle" id="box-1"><span class="sans_futura_std_bold_b_">SHORT FILENAMES AND FILE MASKS</span></p>
<p class="boxbodyfirst"><span class="sans_futura_std_book_">As an even more subtle batveat, sometimes filenames that don’t appear to satisfy a file mask end up satisfying the mask. What we think of as the filename is really the long filename. By default, Windows also assigns a short filename for every file on your computer. It’s a little-used legacy of older operating systems, but it still exists, and when the interpreter compares a file to a mask, it looks for matches against</span> <span class="futura_std_book_oblique_i_">either</span> <span class="sans_futura_std_book_">the long or short filename.</span></p>
<p class="boxbodylast"><span class="sans_futura_std_book_">The short filename is at most eight bytes long with no more than a three-byte extension. The aptly named</span> <span class="futura_std_book_oblique_i_">NineBytes.Long</span> <span class="sans_futura_std_book_">might have a short filename of</span> <span class="futura_std_book_oblique_i_">NINEBY~1.LON</span><span class="sans_futura_std_book_">. If you try to copy all files with an extension of no more than three bytes with the</span> <span class="sans_thesansmonocd_w5regular_">*.???</span> <span class="sans_futura_std_book_">file mask, the interpreter copies the file with the four-byte extension because its short filename satisfies the mask. This issue doesn’t come up often, but if you’re getting an unexpected hit on a file, check out its short filename. (You’ll learn how in <a href="chapter17.xhtml" class="calibre3">Chapter 17</a>.)</span></p>
</aside>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="h" id="sec12"><span id="h1-52"/><span class="sans_futura_std_bold_b_">Moving Files</span></h3>
<p class="tni">Moving a file is similar to copying a file; the only difference is that after a file is copied, it exists in two places, while after a file is moved, the original file is no more. The <span class="sans_thesansmonocd_w5regular_">move</span> command performs this task easily. It simply takes the source and the target as arguments, and you’ll usually see it with the <span class="sans_thesansmonocd_w5regular_">/Y</span> option to suppress the confirmation prompt for overwriting the target:</p>
<pre class="pre"><code class="calibre11">move C:\Source\File2Move.txt C:\Target\ /Y</code></pre>
<p class="tx">Plenty of old code still contains the <span class="sans_thesansmonocd_w5regular_">move</span> command, but it has been largely deprecated in favor of the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command. The following command with the <span class="sans_thesansmonocd_w5regular_">/MOV</span> option is functionally equivalent to the previous <span class="sans_thesansmonocd_w5regular_">move</span> command:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ File2Move.txt /MOV</code></pre>
<p class="tni">Removing the filename from this <span class="sans_thesansmonocd_w5regular_">robocopy</span> command moves all the files in the source folder, but nothing from the subfolders.</p>
<p class="tx">Adding the <span class="sans_thesansmonocd_w5regular_">/S</span> option results in moving all of the contents in all the subfolders, even if the target subfolders need to be created:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ /MOV /S</code></pre>
<p class="tni"><span aria-label=" Page 81. " epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>This command moves all of the files. They are no longer at the source, but the source folder structure remains. Now this is where it gets a bit weird, worthy of a batveat. We’ve been discussing the <span class="sans_thesansmonocd_w5regular_">/MOV</span> option, which is obviously short for <i class="calibre6">move</i>, but a similarly named option called <span class="sans_thesansmonocd_w5regular_">/MOVE</span> stands for ... I guess <i class="calibre6">move with an E</i>. These two options are subtly different. The <span class="sans_thesansmonocd_w5regular_">robocopy</span> command with the <span class="sans_thesansmonocd_w5regular_">/MOVE</span> option truly moves files and directories.</p>
<p class="tx">The addition of the <span class="sans_thesansmonocd_w5regular_">E</span> to the option deletes the source directory structure after copying all of the files to the destination:</p>
<pre class="pre"><code class="calibre11">robocopy C:\Source\ C:\Target\ /MOVE /S</code></pre>
<p class="tx">What we have is a <span class="sans_thesansmonocd_w5regular_">/MOV</span> option that moves files while copying subdirectories and a <span class="sans_thesansmonocd_w5regular_">/MOVE</span> option that moves both files and subdirectories. It isn’t particularly intuitive.</p>
<p class="tx">When considering which command to use for a particular move, the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command is the most efficient choice for all the same reasons mentioned in “<span class="sans_thesansmonocd_w5regular_">xcopy</span> <span class="xref">vs.</span> <span class="sans_thesansmonocd_w5regular_">robocopy</span>” on page <span class="xref">76</span>. But like the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, the <span class="sans_thesansmonocd_w5regular_">move</span> command has the more straightforward return code and still has a place in the Batch ecosystem.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="h" id="sec13"><span id="h1-53"/><span class="sans_futura_std_bold_b_">Deleting Files</span></h3>
<p class="tni">When files are no longer needed, it just makes sense to clean them up. The <span class="sans_thesansmonocd_w5regular_">del</span> command easily deletes one or more files. The <span class="sans_thesansmonocd_w5regular_">/Q</span> option, which again stands for <i class="calibre6">quiet</i> mode, prevents the interpreter from asking permission to delete the file. The command accepts multiple arguments of files to be deleted where you can use both explicit filenames and file masks. The following command deletes one specific file named <i class="calibre6">Junk.txt</i> and all files in the folder with the <i class="calibre6">.OLD</i> extension:</p>
<pre class="pre"><code class="calibre11">del /Q C:\Source\Junk.txt C:\Source\*.OLD</code></pre>
<p class="tx">Use the <span class="sans_thesansmonocd_w5regular_">/A</span> option to select files for deletion based on their attributes. For example, delete only hidden files using the <span class="sans_thesansmonocd_w5regular_">/AH</span> option. Negating the logic, the <span class="sans_thesansmonocd_w5regular_">/A-H</span> option deletes only files that are <i class="calibre6">not</i> hidden. As always, use the <span class="sans_thesansmonocd_w5regular_">help</span> command for a complete list of options.</p>
<p class="tx">Delete all the files in a folder by simply using the directory as the argument to the <span class="sans_thesansmonocd_w5regular_">del</span> command, but the directory itself will still exist. You’ll need a different command for that, and I’ll share it in <span class="xref"><a href="chapter13.xhtml" class="calibre3">Chapter 13</a></span>.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="h" id="sec14"><span id="h1-54"/><span class="sans_futura_std_bold_b_">Renaming Files</span></h3>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">ren</span> and <span class="sans_thesansmonocd_w5regular_">rename</span> commands are Batch synonyms; that is, they are the same command. The first argument is the file to be renamed, and the second argument is the new filename:</p>
<pre class="pre"><code class="calibre11">ren C:\Batch\File2Rename.txt NewFileName.txt</code></pre>
<p class="tx"><span aria-label=" Page 82. " epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>If the destination file already exists, the interpreter returns an <span class="sans_thesansmonocd_w5regular_">errorlevel</span> of <span class="sans_thesansmonocd_w5regular_">1</span>. If there’s the possibility that a file with the same name is already there, I’ll quietly delete it prior to the rename:</p>
<pre class="pre"><code class="calibre11">del C:\Batch\NewFileName.txt /Q
ren C:\Batch\File2Rename.txt NewFileName.txt
</code></pre>
<p class="tx">Wildcards are supported even for this command, but I’ve used the <span class="sans_thesansmonocd_w5regular_">ren</span> command only for explicit filenames, primarily because the command doesn’t write a list of renamed files to the console. (If I have more than one file to rename, I’ll use a <span class="sans_thesansmonocd_w5regular_">dir</span> command as input into a <span class="sans_thesansmonocd_w5regular_">for</span> command and do the renames one by one. We’ll explore these commands further in <span class="xref"><a href="chapter13.xhtml" class="calibre3">Chapters 13</a></span> and <span class="xref"><a href="chapter17.xhtml" class="calibre3">17</a></span>, respectively.)</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">ren</span> command isn’t complicated, but I’ve seen one common batveat far too often. It’s easy to use the path on both arguments, but when you reflect on this for a moment, the interpreter already knows the path from the first argument. The file isn’t being moved or copied anywhere; by the nature of this command, it’s being renamed in place. If the first argument doesn’t have a path, the current directory is assumed (more on that in the next chapter), but the second argument is the new filename only and should never have a path associated with it.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="h" id="sec15"><span id="h1-55"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">This chapter likely will become one that you reference most in this book. Batch would be nothing without the ability to create, copy, move, merge, and delete files, and I introduced a bevy of commands for those tasks here. Some of the commands I discussed are straightforward, but I covered more than one batveat along with solutions for mitigating them. You also learned how to execute these commands on multiple files at a time with the use of file masks and wildcards.</p>
<p class="tx">Copying a file might sound like a simple task, but I detailed the many techniques available and considerations at play. I hope that I showed you how powerful and useful the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command really is, while also instilling in you an appreciation for the simplicity and usefulness of the <span class="sans_thesansmonocd_w5regular_">xcopy</span> command.</p>
<p class="tx">In the next chapter I’ll describe how to execute a program compiled in another language, which will involve a deeper discussion about how the interpreter finds the program to execute when you don’t provide a path.</p>
</section>
</section>
</div></body></html>