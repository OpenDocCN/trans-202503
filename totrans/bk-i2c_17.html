<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_261" title="261"/>13</span><br/>&#13;
<span class="ChapterTitle">The MCP23017 and MCP23008 GPIO Expanders</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Most SBCs and MCUs provide anywhere from three to a couple dozen digital I/O pins. Sometimes, you’ll need more digital I/O than the standard complement. Even on those MCUs that provide a couple dozen pins or more, most of them are multifunction. If you use them for their alternate purposes, you may find that you don’t have enough remaining pins for digital I/O. This is where a GPIO expander comes in handy. </p>&#13;
<p>While there are many different ICs you can purchase to provide GPIO expansion on the I<sup>2</sup>C bus, the MCP23008 and MCP23017 (collectively MCP230<em>xx</em>) are popular; they’re available in DIP (through-hole) packages, and there’s considerable library code available for them. The MCP23008 supports 8 GPIO pins while the MCP23017 supports 16, but these 2 ICs are otherwise identical.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" id="Page_262" title="262"/><h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Unlike many of the other devices this book describes, you generally won’t find many breakout boards available for the MCP230<em>xx</em> parts. That’s because they are available in breadboard-friendly DIP packages (though Adafruit recently added a STEMMA/Qwiic breakout board; see <a class="LinkURL" href="https://www.adafruit.com/product/5346">https://www.adafruit.com/product/5346</a>).</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>This chapter describes the MCP23017 and MCP23008 devices, their electrical connections, and how to program them. It describes the internal device registers (and how to use them). It also provides some sample programs to demonstrate the ICs’ operation.</p>&#13;
<h2 id="h1-502468c13-0001">	13.1	The MCP23017 and MCP23008 Pinouts</h2>&#13;
<p class="BodyFirst">The MCP23017 has the pinout depicted in <a href="#figure13-1" id="figureanchor13-1">Figure 13-1</a>. </p>&#13;
<figure>&#13;
<img alt="" class="" height="359" src="image_fi/502468c13/f13001.png" width="412"/>&#13;
<figcaption><p><a id="figure13-1">Figure 13-1</a>: MCP23017 pinout</p></figcaption>&#13;
</figure>&#13;
<p>The MCP23008 has the pinout shown in <a href="#figure13-2" id="figureanchor13-2">Figure 13-2</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="233" src="image_fi/502468c13/f13002.png" width="413"/>&#13;
<figcaption><p><a id="figure13-2">Figure 13-2</a>: MCP23008 pinout</p></figcaption>&#13;
</figure>&#13;
<p><a href="#table13-1" id="tableanchor13-1">Table 13-1</a> shows what the pins on each device mean.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table13-1">Table 13-1</a>: MCP230<em>xx</em> Pin Functions<span epub:type="pagebreak" id="Page_263" title="263"/></p></figcaption>&#13;
<table border="1" id="table-502468c13-0001">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Pin</b></td>&#13;
<td><b>MCP23008</b></td>&#13;
<td><b>MCP23017</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>SCL (I<sup>2</sup>C clock)</td>&#13;
<td>GPIO 0, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>2</td>&#13;
<td>SDA (I<sup>2</sup>C data)</td>&#13;
<td>GPIO 1, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>3</td>&#13;
<td>A2 (address selection)</td>&#13;
<td>GPIO 2, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4</td>&#13;
<td>A1 (address selection)</td>&#13;
<td>GPIO 3, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>5</td>&#13;
<td>A0 (address selection)</td>&#13;
<td>GPIO 4, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td>Reset (active low)</td>&#13;
<td>GPIO 5, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>7</td>&#13;
<td>NC (no connection)</td>&#13;
<td>GPIO 6, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td>INT (interrupt on input)</td>&#13;
<td>GPIO 7, port B</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td>Vss (ground)</td>&#13;
<td>Vdd (1.8 V, 3.3 V, or 5 V)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10</td>&#13;
<td>GPIO 0</td>&#13;
<td>Vss (ground)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>11</td>&#13;
<td>GPIO 1</td>&#13;
<td>NC (no connection)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>12</td>&#13;
<td>GPIO 2</td>&#13;
<td>SCL (I<sup>2</sup>C clock)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>13</td>&#13;
<td>GPIO 3</td>&#13;
<td>SDA (I<sup>2</sup>C data)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>14</td>&#13;
<td>GPIO 4</td>&#13;
<td>NC (no connection)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>15</td>&#13;
<td>GPIO 5</td>&#13;
<td>A0 (address selection)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>16</td>&#13;
<td>GPIO 6</td>&#13;
<td>A1 (address selection)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>17</td>&#13;
<td>GPIO 7</td>&#13;
<td>A2 (address selection)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>18</td>&#13;
<td>Vdd (1.8 V, 3.3 V, or 5 V)</td>&#13;
<td>Reset (active low)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>19</td>&#13;
<td>n/a</td>&#13;
<td>INTB (interrupt on port B)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>20</td>&#13;
<td>n/a</td>&#13;
<td>INTA (interrupt on port A)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>21</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 0, port A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>22</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 1, port A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>23</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 2, port A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>24</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 3, port A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>25</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 4, port A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>26</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 5, port A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>27</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 6, port A</td>&#13;
</tr>&#13;
<tr>&#13;
<td>28</td>&#13;
<td>n/a</td>&#13;
<td>GPIO 7, port A</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>The Vdd pin is the power supply (positive voltage) to the IC. The MCP230<em>xx</em> can operate at several different logic levels ranging from 1.8 V to 5.5 V (typically 1.8 V, 3.3 V, or 5.0 V). The Vss pin is the ground connection.</p>&#13;
<p>The SCL and SDA are the I<sup>2</sup>C bus pins. As usual, these are open-drain pins. The bus voltages (held via I<sup>2</sup>C pullup resistors) should be close to Vdd. Note that the MCP230<em>xx</em> are capable of operating at 100 kHz, 400 kHz, or as high as 1.7 MHz.</p>&#13;
<p>The GPIO<em>x</em> pins provide the general-purpose I/O expansion. The MCP23008 has 8 expansion I/O pins, while the MCP23017 has 16 (named <em><span epub:type="pagebreak" id="Page_264" title="264"/>port A</em> and <em>port B</em> with 8 pins each). When operating as an input, these pins accept voltages up to Vdd. When operating as output pins, they produce Vdd on their outputs.</p>&#13;
<p>The A0, A1, and A2 pins specify the LO 3 bits of the device address. These should be wired to Vdd or Vss to set the device address. The MCP230<em>xx</em> ICs support up to eight different devices (selected by A0, A1, and A2 as the LO address bits) on the I<sup>2</sup>C bus. Note that the HO 4 address bits are always 0b0100, so the full device address falls in the range 0x20 to 0x27 (0x40 to 0x4E when shifted into the output byte).</p>&#13;
<p>The Reset signal is an active low signal that resets the device. This pin, when low, will configure all the pins as inputs and configure the device in <em>safe mode</em> (least likely to cause hardware problems). Note that the MCP230<em>xx</em> devices automatically reset themselves when power is applied, so unless a circuit absolutely needs to be able to reset the MCP230<em>xx</em> during operation, you’ll normally find this pin connected to Vdd.</p>&#13;
<p>The MCP23008 INT and the MCP23017 INTA and INTB pins signal an interrupt. An <em>interrupt</em> is an asynchronous signal that alerts the CPU to take some action (generally pausing the current execution stream and running a special interrupt service routine to handle the event). You can program the INT, INTA, and INTB pins to pulse or to be set to some level whenever a change occurs on the MCP230<em>xx</em>, which is useful for detecting input changes when the system can’t poll the input pins on a frequent basis.</p>&#13;
<h2 id="h1-502468c13-0002">	13.2	MCP230<em>xx</em> Registers</h2>&#13;
<p class="BodyFirst">The MCP230<em>xx</em> ICs are feature-rich devices. Unfortunately, this feature set comes at a cost: programming complexity. To program these ICs, you read and write various registers. The MCP23008 has 11 internal registers (see <a href="#table13-2" id="tableanchor13-2">Table 13-2</a>). </p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table13-2">Table 13-2</a>: MCP23008 Registers</p></figcaption>&#13;
<table border="1" id="table-502468c13-0002">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Register number</b></td>&#13;
<td><b>Name</b></td>&#13;
<td><b>Function</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>IODIR</td>&#13;
<td>I/O data direction register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>IPOL</td>&#13;
<td>Input polarity</td>&#13;
</tr>&#13;
<tr>&#13;
<td>2</td>&#13;
<td>GPINTEN</td>&#13;
<td>GPIO interrupt enable register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>3</td>&#13;
<td>DEFVAL</td>&#13;
<td>Default comparison value (for interrupts)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4</td>&#13;
<td>INTCON</td>&#13;
<td>Interrupt control register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>5</td>&#13;
<td>IOCON</td>&#13;
<td>I/O configuration register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td>GPPU</td>&#13;
<td>GPIO pullup register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>7</td>&#13;
<td>INTF</td>&#13;
<td>Interrupt flag register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td>INTCAP</td>&#13;
<td>Interrupt capture register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td>GPIO</td>&#13;
<td>GPIO I/O port register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10 (0xA)</td>&#13;
<td>OLAT</td>&#13;
<td>Output latch register</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_265" title="265"/>The MCP23017 has 22 internal registers (see <a href="#table13-3" id="tableanchor13-3">Table 13-3</a>).</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table13-3">Table 13-3</a>: MCP23017 Registers</p></figcaption>&#13;
<table border="1" id="table-502468c13-0003">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Register number,</b><br/>&#13;
<b>BANK = 0</b></td>&#13;
<td><b>Alternate register number,</b><br/>&#13;
<b>BANK = 1</b></td>&#13;
<td><b>Name</b></td>&#13;
<td><b>Function</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>IODIRA</td>&#13;
<td>Port A I/O data direction register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>16 (0x10)</td>&#13;
<td>IODIRB</td>&#13;
<td>Port B I/O data direction register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>2</td>&#13;
<td>1</td>&#13;
<td>IPOLA</td>&#13;
<td>Port A input polarity</td>&#13;
</tr>&#13;
<tr>&#13;
<td>3</td>&#13;
<td>17 (0x11)</td>&#13;
<td>IPOLB</td>&#13;
<td>Port B input polarity</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4</td>&#13;
<td>2</td>&#13;
<td>GPINTENA</td>&#13;
<td>Port A GPIO interrupt enable register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>5</td>&#13;
<td>18 (0x12)</td>&#13;
<td>GPINTENB</td>&#13;
<td>Port B GPIO interrupt enable register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td>3</td>&#13;
<td>DEFVALA</td>&#13;
<td>Port A default comparison value (for interrupts)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>7</td>&#13;
<td>19 (0x13)</td>&#13;
<td>DEFVALB</td>&#13;
<td>Port B default comparison value (for interrupts)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td>4</td>&#13;
<td>INTCONA</td>&#13;
<td>Port A interrupt control register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td>20 (0x14)</td>&#13;
<td>INTCONB</td>&#13;
<td>Port B interrupt control register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10 (0xA)</td>&#13;
<td>5</td>&#13;
<td>IOCON</td>&#13;
<td>I/O configuration register (only single IOCON)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>11 (0xB)</td>&#13;
<td>21 (0x15)</td>&#13;
<td>IOCON</td>&#13;
<td>I/O configuration register (same as register 10/5)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>12 (0xC)</td>&#13;
<td>6</td>&#13;
<td>GPPUA</td>&#13;
<td>Port A GPIO pullup register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>13 (0xD)</td>&#13;
<td>22 (0x16)</td>&#13;
<td>GPPUB</td>&#13;
<td>Port B GPIO pullup register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>14 (0xE)</td>&#13;
<td>7</td>&#13;
<td>INTFA</td>&#13;
<td>Port A interrupt flag register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>15 (0xF)</td>&#13;
<td>23 (0x17)</td>&#13;
<td>INTFB</td>&#13;
<td>Port B interrupt flag register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>16 (0x10)</td>&#13;
<td>8</td>&#13;
<td>INTCAPA</td>&#13;
<td>Port A interrupt capture register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>17 (0x11)</td>&#13;
<td>24 (0x18)</td>&#13;
<td>INTCAPB</td>&#13;
<td>Port B interrupt capture register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>18 (0x12)</td>&#13;
<td>9</td>&#13;
<td>GPIOA</td>&#13;
<td>Port A GPIO</td>&#13;
</tr>&#13;
<tr>&#13;
<td>19 (0x13)</td>&#13;
<td>25 (0x19)</td>&#13;
<td>GPIOB</td>&#13;
<td>Port B GPIO</td>&#13;
</tr>&#13;
<tr>&#13;
<td>20 (0x14)</td>&#13;
<td>10 (0xA)</td>&#13;
<td>OLATA</td>&#13;
<td>Port A output latch register</td>&#13;
</tr>&#13;
<tr>&#13;
<td>21 (0x15)</td>&#13;
<td>26 (0x1A)</td>&#13;
<td>OLATB</td>&#13;
<td>Port B output latch register</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_266" title="266"/>The MCP23017 supports two sets of register numbers, standard and alternate (or “special”). The register number is selected by bit 7 in the IOCON (control) register. If this bit is 0 (the power-up/reset state), then the MCP23017 uses the standard register numbering. If bit 7 is 1, then the MCP23017 uses the alternate register numbering, which separates the two ports into separate register banks (0 to 0xA for port A and 0x10 to 0x1A for port B).</p>&#13;
<h3 id="h2-502468c13-0001">13.2.1	Accessing MCP230<em>xx</em> Registers</h3>&#13;
<p class="BodyFirst">Because the MCP230<em>xx</em> devices have multiple registers, writing and reading data to and from these devices are a little more complex than with simpler devices like the MCP4725. The (typical) protocol for writing a single byte to a register is as follows:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Put a start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="2">Transmit the I<sup>2</sup>C address byte (a value in the range 0x40 to 0x46). This is always a write operation, so the LO bit of the address byte will always be 0.</li>&#13;
<li value="3">Write the register address to the I<sup>2</sup>C bus.</li>&#13;
<li value="4">Place the register data (to write to the MCP230<em>xx</em> register) on the I<sup>2</sup>C bus.</li>&#13;
<li value="5">Put a stop condition on the bus to terminate the transfer.</li>&#13;
</ol>&#13;
<p>The (typical) protocol for reading a single byte from a register is as follows:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Put a start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="2">Transmit the I<sup>2</sup>C address byte (a value in the range 0x40 to 0x46). This is always a write operation, so the LO bit of the address byte will always be 0.</li>&#13;
<li value="3">Write the register address to the I<sup>2</sup>C bus.</li>&#13;
<li value="4">Put a (re)start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="5">Transmit the I<sup>2</sup>C address byte (a value in the range 0x41 to 0x47). This is a read operation, so the LO bit of the address byte will be 1.</li>&#13;
<li value="6">Read the register data from the I<sup>2</sup>C bus.</li>&#13;
<li value="7">Put a stop condition on the bus to terminate the transfer.</li>&#13;
</ol>&#13;
<p>This chapter discusses additional forms of this protocol for block reads and writes; see section 13.2.6, “Sequential Register Operations,” later in this chapter.</p>&#13;
<h3 id="h2-502468c13-0002">13.2.2	MCP230<em>xx</em> Initialization</h3>&#13;
<p class="BodyFirst">At power-up, the MCP230<em>xx</em> devices enter the following state:</p>&#13;
<ul>&#13;
<li>IOCON bit 7 is set to 0 to select standard register numbers on the MCP23017.</li>&#13;
<li>All GPIO pins are programmed as inputs (see section 13.2.3, “Programming the Data Direction”).</li>&#13;
<li>All pullup resistors are turned off (see section 13.2.4, “Programming Input Pullup Resistors”).</li>&#13;
<li><span epub:type="pagebreak" id="Page_267" title="267"/>All interrupts are disabled (see section 13.5.5, “Enabling Interrupts on the MCP230<em>xx</em>”).</li>&#13;
<li>On the MCP23017, port A and B interrupts will be handled independently (should they be enabled).</li>&#13;
<li>The MCP230<em>xx</em> is programmed for sequential register operations (see section 13.2.6, “Sequential Register Operations”).</li>&#13;
<li>SDA slew rate control is enabled (see section 13.2.7, “Slew Rate Control”).</li>&#13;
<li>The INTx pin(s) are active outputs (not open drain; see section 13.2.8, “Reading General-Purpose Input/Output Pins on the MCP230<em>xx</em>”).</li>&#13;
<li>Interrupt output pins are active-low (low signal when an interrupt occurs; see section 13.5.5, “Enabling Interrupts on the MCP230<em>xx</em>”).</li>&#13;
</ul>&#13;
<p>The IOCON register (I/O configuration) handles most of this initialization. <a href="#table13-4" id="tableanchor13-4">Table 13-4</a> lists the bits in IOCON and their functions.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table13-4">Table 13-4</a>: IOCON Register Functions</p></figcaption>&#13;
<table border="1" id="table-502468c13-0004">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bit</b></td>&#13;
<td><b>Default on power-up or reset</b></td>&#13;
<td><b>Name</b></td>&#13;
<td><b>Function</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>7</td>&#13;
<td>0</td>&#13;
<td>BANK</td>&#13;
<td>MCP23017 only. Selects standard register numbering (BANK = 0) or alternate register numbering (BANK = 1).</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td>0</td>&#13;
<td>MIRROR</td>&#13;
<td>MCP23017 only. INTA/B mirror function. If MIRROR = 0, then the INTA and INTB pins operate independently. If MIRROR = 1, then the two pins are internally wired together. See “INT<em>x</em> Pin Polarity” under section 13.5.2 for more information.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>5</td>&#13;
<td>0</td>&#13;
<td>SEQOP</td>&#13;
<td>If SEQOP = 1, then successive data read/write operations read and write the same register number. If SEQOP = 0, then the register number is incremented after each operation (mainly for MCP23017).</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4</td>&#13;
<td>0</td>&#13;
<td>DISSLW</td>&#13;
<td>Slew rate control for SDA pin. If DISSLW = 0, then slew rate control is enabled. If DISSLW = 1, then slew rate control is disabled.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>3</td>&#13;
<td>0</td>&#13;
<td>N/A</td>&#13;
<td>Used only by SPI version of the MCP23S<em>xx</em> GPIO expander.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>2</td>&#13;
<td>0</td>&#13;
<td>ODR</td>&#13;
<td>Open drain control. If ODR = 1, then the INT<em>x</em> pins are open-drain outputs. If ODR = 0, then the INT<em>x</em> pins are active logic outputs. See section 13.5.5, “Enabling Interrupts on the MCP230<em>xx</em>” for more information.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>INTPOL</td>&#13;
<td>Sets the polarity of the INT pins. If INTPOL = 0, then the INT<em>x</em> pins are active low. If INTPOL = 1, then the INT<em>x</em> pins are active high. This bit sets the polarity only if ODR = 0. See section 13.5.4, “Open-Drain INT<em>x</em> Output,” for more information.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>N/A</td>&#13;
<td>Not used.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_268" title="268"/>If you decide you want to initialize the MCP230<em>xx</em> with something other than the default value, you will need to write an appropriate value to the IOCON register. Do so immediately after your program begins execution. While it is possible to change the configuration during execution, this is rare; most of the time you’ll configure the MCP230<em>xx</em> once and then not touch the register thereafter.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	An exception to rarely changing the IOCON register is the SEQOP bit, which you might want to change under program control. See section 13.2.6, “Sequential Register Operations,” for more details.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>To program the IOCON register, you will need to write 3 bytes to the I<sup>2</sup>C bus (see <a href="#figure13-3" id="figureanchor13-3">Figure 13-3</a>):</p>&#13;
<ol class="decimal">&#13;
<li value="1">Put a start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="2">Write the device address (0x40 to 0x46) with the LO bit set to 0 (write operation).</li>&#13;
<li value="3">Write the IOCON register number 0x0A (or 0x05, if using alternate register numbers) to the bus.</li>&#13;
<li value="4">Write the new IOCON register value to the I<sup>2</sup>C bus.</li>&#13;
<li value="5">Put a stop condition on the I<sup>2</sup>C bus.</li>&#13;
</ol>&#13;
<figure>&#13;
<img alt="" class="" height="119" src="image_fi/502468c13/f13003.png" width="693"/>&#13;
<figcaption><p><a id="figure13-3">Figure 13-3</a>: Example IOCON initialization sequence</p></figcaption>&#13;
</figure>&#13;
<p>On power-up or after a reset operation, the register addresses default to the standard register numbers. If you intend to use the alternate register numbers, you must write an IOCON value with bit 7 equal to 1 to address 0x0A, the power-on/reset IOCON address. After that, any writes to IOCON must happen at register number 0x05.</p>&#13;
<p>Note that if external hardware can reset the MCP230<em>xx</em>, then the IOCON register will switch back to address 0x0A. This can be a problem if the software isn’t aware that the reset operation took place. This is a good argument for leaving the MCP230<em>xx</em> in standard register number mode.</p>&#13;
<h3 id="h2-502468c13-0003">13.2.3	Programming the Data Direction</h3>&#13;
<p class="BodyFirst">The GPIO pins on the MCP230<em>xx</em> are individually programmable as inputs or outputs. The <em>data direction registers (DDRs)</em> control the input or output state of each pin. The MCP23008 has a single (8-bit) IODIR (register 0), and the MCP23017 has two (IODIRA is register 0, and IODIRB is register 1 or 16).</p>&#13;
<p><span epub:type="pagebreak" id="Page_269" title="269"/>Each bit position in an IODIR<em>x</em> register controls the I/O state of the corresponding GPIO pin. That is, bit 0 in IODIRA (IODIR on the MCP23008) controls GPA0, bit 1 in IODIRA controls GPA1, and so on. Likewise, bit 0 in IODIRB controls GPB0, bit 1 controls GPB1, and so on. A 1 in a given bit position programs the corresponding GPIO pin as an input; a 0 in the bit position programs the corresponding GPIO pin as an output.</p>&#13;
<p>When the MCP230<em>xx</em> powers up or when the reset line is brought low, the IC programs all GPIO pins as inputs (that is, it initializes the IODIR<em>x</em> registers with all 1 bits). This is the safest initial configuration, as it prevents programming a GPIO pin as an output, which might produce an electrical conflict if that pin is connected to a line with an active signal.</p>&#13;
<p>Because of the MCP230<em>xx</em>’s IODIR flexibility, you can program arbitrary bits as inputs or outputs. In practice, it’s most convenient (at least on the MCP23017) to program each bank of 8 bits as either all inputs or all outputs. Doing so makes it more convenient to program the MCP230<em>xx</em> ICs. Of course, if your hardware design requires that you mix and match I/O directions on a single port, that’s perfectly acceptable; the cost is slightly more complex programming requirements.</p>&#13;
<p>To send the data direction value to the MCP230<em>xx</em> ICs, transmit the sequence shown in <a href="#figure13-4" id="figureanchor13-4">Figure 13-4</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="247" src="image_fi/502468c13/f13004.png" width="693"/>&#13;
<figcaption><p><a id="figure13-4">Figure 13-4</a>: IODIR<em>x</em> initialization sequence</p></figcaption>&#13;
</figure>&#13;
<p>The third byte of the sequence appearing in <a href="#figure13-4">Figure 13-4</a> is the data direction initialization value.</p>&#13;
<h3 id="h2-502468c13-0004">13.2.4	Programming Input Pullup Resistors</h3>&#13;
<p class="BodyFirst">Input pins on the MCP230<em>xx</em> are often connected to <em>dry contact inputs</em>: switches, relay contacts, or other devices that connect two different signal lines. A typical dry contact might be a push button, DIP switch, or other SPST switch or relay.</p>&#13;
<p>Usually, a dry contact will connect an input pin on an MCP230<em>xx</em> to ground. Closing the contact shunts the input to ground so that a 0 input value appears on the corresponding bit in the GPIO<em>x</em> register. When the contact is open, the input signal <em>floats</em>, which is never good; the electronics <span epub:type="pagebreak" id="Page_270" title="270"/>might interpret a floating input as either a logic 0 or 1. To avoid floating inputs, designers typically put a pullup resistor on the input pin. This raises the voltage pin to the voltage connected to the pullup resistor (typically Vdd) when the dry contact is in the open position. When the dry contact is in the closed position, this shunts the input to ground, providing a logic 0 input.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Non-dry contact inputs generally consist of logic-level voltage signals.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The only problem with pullup resistors is that you’ll need to find space for them on a printed circuit or prototype board, as well as time and energy to install them. For convenience, the MCP230<em>xx</em> parts provide <em>programmable pullup resistors</em> that allow you to programmatically enable or disable pullup resistors on input pins. The GPPU<em>x</em> registers provide this capability. Programming a GPPU<em>x</em> bit with a 1 (and programming that same bit position in IODIR<em>x</em> with a 1) will connect a 100-kΩ pullup resistor to that pin. Conversely, programming a 0 bit disconnects the pullup resistor.</p>&#13;
<p>You should program only pullup resistors on GPIO pins connected to dry contact inputs. If a logic-level signal connects to a GPIO pin, programming a pullup resistor on that same pin might damage the MCP230<em>xx</em> or the logic device at the other end of the connection. Even if it doesn’t damage the electronics, it could interfere with the input signal.</p>&#13;
<p>To set the pullup value on the MCP230<em>xx</em> ICs, transmit the sequence shown in <a href="#figure13-5" id="figureanchor13-5">Figure 13-5</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="247" src="image_fi/502468c13/f13005.png" width="693"/>&#13;
<figcaption><p><a id="figure13-5">Figure 13-5</a>: GPPU<em>x</em> pullup initialization</p></figcaption>&#13;
</figure>&#13;
<p>The last byte in the sequence in <a href="#figure13-5">Figure 13-5</a> is the bitmap value for the pullup initialization.</p>&#13;
<h3 id="h2-502468c13-0005">13.2.5	Programming the Input Polarity</h3>&#13;
<p class="BodyFirst">If you’ve been reading closely, you may have noticed that reading a dry contact switch with a pullup resistor in the previous section produced a 0 input when the switch was closed (pressed) and a 1 input when the switch was open (unpressed). This logic, <em>active low logic</em>, is opposite of what you might expect in software. Intuition suggests you should get a logic 1 when you <span epub:type="pagebreak" id="Page_271" title="271"/>press (close) the switch and a logic 0 when you release (open) it—that is, you expect <em>active </em><em>high logic</em>. Although it is easy enough to invert the signal once you’ve read it from the GPIO pin, the MCP230<em>xx</em> devices provide a special <em>polarity register</em> that lets you select active high or active low logic signals.</p>&#13;
<p>The MCP23008 IPOL and the MCP23017 IPOLA and IPOLB registers let you control the polarity of an input pin. If a bit in IPOL<em>x</em> is 0, then the corresponding bit in the GPIO<em>x</em> register will reflect the current state of the input pin. If a bit in IPOL<em>x</em> is 1, then the corresponding bit in GPIO<em>x</em> will reflect the inverted state of the input pin.</p>&#13;
<p>If an actual input is active low but you want to read it as though it were active high, simply program the corresponding bit in IPOL<em>x</em> with a 1 to invert the signal when you read it. Inverting dry contacts, for example, makes them active high inputs so that their logic matches logic-level input signals.</p>&#13;
<p>To set the input pin polarities on the MCP230<em>xx</em> ICs, transmit the sequence shown in <a href="#figure13-6" id="figureanchor13-6">Figure 13-6</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="247" src="image_fi/502468c13/f13006.png" width="693"/>&#13;
<figcaption><p><a id="figure13-6">Figure 13-6</a>: IPOL<em>x</em> input pin polarity sequence</p></figcaption>&#13;
</figure>&#13;
<p>The third byte in the sequence appearing in <a href="#figure13-6">Figure 13-6</a> is the polarity initialization value.</p>&#13;
<h3 id="h2-502468c13-0006">13.2.6	Sequential Register Operations</h3>&#13;
<p class="BodyFirst">Reading or writing a register value on the MCP230<em>xx</em> requires a minimum of three 1-byte transmissions on the I<sup>2</sup>C bus: an I<sup>2</sup>C address byte, a register number, and a data transmission to or from the register. Because I<sup>2</sup>C transmissions are relatively slow (especially when operating at 100 kHz), the MCP230<em>xx</em> provides a special <em>sequential register access mode</em> to reduce the number of I<sup>2</sup>C bus transactions. The SEQOP bit in IOCON (bit 5) controls this mode. If SEQOP contains 0, then the MCP230<em>xx</em> automatically increments the register number after each data transmission and reception on the I<sup>2</sup>C bus. If SEQOP contains 1, then the MCP230<em>xx</em> disables the autoincrement mode.</p>&#13;
<p><span epub:type="pagebreak" id="Page_272" title="272"/>When the autoincrement mode is active, the controller device can read or write multiple data bytes after transmitting a single pair of I<sup>2</sup>C address and register bytes. As long as the controller device does not put a stop condition on the bus, successive clock pulses on SCL will continue to read or write successive registers on the MCP230<em>xx</em>. </p>&#13;
<p>This autoincrement feature is especially useful on the MCP23017 when the registers are in standard (non-banked) mode. In standard mode, the port A and port B registers appear in successive locations. This allows you to successively read and write registers from both ports as a 16-bit operation. For example, if you want to initialize IODIRA and IODIRB at the same time, you would use the following sequence (assuming SEQOP is 0, which is the power-on/reset condition):</p>&#13;
<ol class="decimal">&#13;
<li value="1">Place the start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="2">Write the address to the I<sup>2</sup>C bus (0x40 to 0x46) with the LO bit 0 (for write).</li>&#13;
<li value="3">Write 0 to the I<sup>2</sup>C bus (IODIRA register address).</li>&#13;
<li value="4">Write the data direction bits for IODIRA to the I<sup>2</sup>C bus.</li>&#13;
<li value="5">Write the data direction bits for IODIRB to the I<sup>2</sup>C bus.</li>&#13;
<li value="6">Place the stop condition on the I<sup>2</sup>C bus.</li>&#13;
</ol>&#13;
<p>Between steps 4 and 5 in this sequence, the MCP23017 automatically incremented the register number so that step 5 writes the data direction bits to register one (IODIRB), as shown in <a href="#figure13-7" id="figureanchor13-7">Figure 13-7</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="187" src="image_fi/502468c13/f13007.png" width="844"/>&#13;
<figcaption><p><a id="figure13-7">Figure 13-7</a>: Autoincrementing register numbers</p></figcaption>&#13;
</figure>&#13;
<p>This sequence requires writing only 4 bytes to the I<sup>2</sup>C bus. This is two less than the 6 bytes that would have been required to individually write to the IODIRA and IODIRB registers using independent transactions.</p>&#13;
<p>You’re not limited to writing just two values using the autoincrement mode. You could, for example, write the direction and polarity initialization values all at once:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Place the start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="2">Write the address to the I<sup>2</sup>C bus (0x40 to 0x46) with the LO bit 0 (for write).</li>&#13;
<li value="3"><span epub:type="pagebreak" id="Page_273" title="273"/>Write 0 to the I<sup>2</sup>C bus (IODIRA register address).</li>&#13;
<li value="4">Write the data direction bits for IODIRA to the I<sup>2</sup>C bus.</li>&#13;
<li value="5">Write the data direction bits for IODIRB to the I<sup>2</sup>C bus.</li>&#13;
<li value="6">Write the polarity bits for IPOLA to the I<sup>2</sup>C bus.</li>&#13;
<li value="7">Write the polarity bits for IPOLB to the I<sup>2</sup>C bus.</li>&#13;
<li value="8">Place the stop condition on the I<sup>2</sup>C bus.</li>&#13;
</ol>&#13;
<p>In theory, you could also write interrupt initialization values in this sequence, though it’s uncommon to use all the interrupt initialization features, so sequential writing isn’t always possible. Sadly, the pullup registers don’t appear sequentially in a common initialization list, so you wind up having to write their address and register values independently.</p>&#13;
<p>Of course, you’re unlikely to write the initialization bits more often than once in a typical application, so the savings for a single initialization won’t be that great. However, it is common to read all 16 input bits from the MCP23017 or to write all 16 output bits. The autoincrement mode is useful for those operations, which occur frequently in common applications.</p>&#13;
<p>Register autoincrement mode is not always useful, though. Perhaps you want to quickly write the GPIO, GPIOA, or GPIOB register to put some waveform onto the output pins, and you:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Put a start condition on the bus.</li>&#13;
<li value="2">Write the I<sup>2</sup>C address to the bus with the LO (read) bit equal to 1.</li>&#13;
<li value="3">Write the register number to the bus (for example, 12/0xC for GPIOA).</li>&#13;
<li value="4">Write a byte to the bus.</li>&#13;
<li value="5">Repeat step 4 for each different value to be written to the output pins.</li>&#13;
<li value="6">Place a stop condition on the bus.</li>&#13;
</ol>&#13;
<p>This code would require SEQOP to be set to 1 to disable autoincrementing the register number after step 4.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Keep in mind that certain library functions might limit the number of successive bytes that can be written in one I<sup>2</sup>C bus transaction.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>You’ll have to decide whether it’s better to operate with the autoincrement feature turned on or off (by default) in your code. If you’re constantly switching between the two modes, it may be more efficient just to operate in non-autoincrement mode.</p>&#13;
<h3 id="h2-502468c13-0007">13.2.7	Slew Rate Control</h3>&#13;
<p class="BodyFirst">Bit 4 of the IOCON register (DISSLW) controls the I<sup>2</sup>C SDA slew rate. When enabled (0), the slew rate control reduces the speed at which the SDA line rises from low to high or falls from high to low (see <a href="#figure13-8" id="figureanchor13-8">Figure 13-8</a>). By default, this bit is 0, which reduces the signal’s rise and fall time.</p>&#13;
<span epub:type="pagebreak" id="Page_274" title="274"/><figure>&#13;
<img alt="" class="" height="220" src="image_fi/502468c13/f13008.png" width="543"/>&#13;
<figcaption><p><a id="figure13-8">Figure 13-8</a>: Slew rate</p></figcaption>&#13;
</figure>&#13;
<p>Reducing the slew rate can reduce noise (due to <em>ringing</em>, noise caused by the signal temporarily bouncing up and down after a change) on the SDA line. However, at higher speeds, reducing the slew rate can introduce errors on its own. You would typically enable slew rate control at 100 kHz and disable it at 1 MHz. At 400 kHz, you would enable it or disable it as necessary, depending on the signal noise, which you would have to verify with an oscilloscope. As the MCP230<em>xx</em> devices enable slew rate control by default, you should turn it off only if there are noise problems in your system.</p>&#13;
<h3 id="h2-502468c13-0008"><em>13.2.8</em>	Reading General-Purpose Input/Output Pins on the MCP230<em>xx</em></h3>&#13;
<p class="BodyFirst">Reading the GPIO<em>x</em> register(s) on the MCP230<em>xx</em> is probably the most common software activity. Reading these registers returns the current state of the GPA<em>x</em> and GPB<em>x</em> pins. If the pins were programmed as output, then reading the GPIO<em>x</em> registers returns the last value written (or default reset state) to the output pins, which is the current state of those pins.</p>&#13;
<p>Reading data from the GPIO<em>x</em> registers requires two I<sup>2</sup>C bus transactions. First, write the GPIO<em>x</em> register address, and second, read the register value(s):</p>&#13;
<ol class="decimal">&#13;
<li value="1">Place a start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="2">Write the device address with the LO bit 0 (write operation).</li>&#13;
<li value="3">Write the GPIO, GPIOA, or GPIOB register address (GPIO = 9 on MCP23008, GPIOA = 9 or 0x12, and GPIOB = 0x19 or 0x13 on MCP23017).</li>&#13;
<li value="4">Place a (repeated) start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="5">Write the device address with the LO bit 1 (read operation) to the I<sup>2</sup>C bus.</li>&#13;
<li value="6">Read the GPIO bits from the I<sup>2</sup>C bus.</li>&#13;
<li value="7">(optional on MCP23017) Read the second set of GPIO bits (GPIOB) from the I<sup>2</sup>C bus (see <a href="#figure13-9" id="figureanchor13-9">Figure 13-9</a>).</li>&#13;
<li value="8">Place a stop condition on the bus.</li>&#13;
</ol>&#13;
<p>Step 7 assumes SEQOP bit in IOCON is 0 and the register address written in step 3 was GPIOA (address 0x12 in standard mode). </p>&#13;
<span epub:type="pagebreak" id="Page_275" title="275"/><figure>&#13;
<img alt="" class="" height="405" src="image_fi/502468c13/f13009.png" width="693"/>&#13;
<figcaption><p><a id="figure13-9">Figure 13-9</a>: GPIO sequential read operation</p></figcaption>&#13;
</figure>&#13;
<p>Note that if SEQOP in IOCON has been programmed as a 1 (no autoincrementing register address), then you can reread the GPIO<em>x</em> bits over and over again.</p>&#13;
<h2 id="h1-502468c13-0003"> <em>13.3	</em>Writing General-Purpose Input/Output Pins on the MCP230<em>xx</em></h2>&#13;
<p class="BodyFirst">There are two ways to write data to output pins on the MCP230<em>xx</em>: write the data to the GPIO<em>x</em> register(s) or write the data to the OLAT<em>x</em> register(s). Writing to either set of registers will place the output data on the output pins.</p>&#13;
<p>For output purposes, there is no real difference between writing to the GPIO<em>x</em> and OLAT<em>x</em> registers. Internally, the MCP230<em>xx</em> converts a write to GPIO<em>x</em> into a write to OLAT<em>x</em>. The two register sets differ when you read from them. Reading from GPIO<em>x</em>, of course, reads the current state of the GPA<em>n</em> and GPB<em>n</em> input pins. Reading from OLAT<em>x</em> returns the last value written to the OLAT<em>x</em> (or GPIO<em>x</em>) registers. This will produce differing results if any pins were programmed as inputs.</p>&#13;
<p>Writing to the OLAT<em>x</em> (or GPIO<em>x</em>) registers is slightly less complex than reading from the GPIO<em>x</em> registers. Here are the steps:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Place a start condition on the I<sup>2</sup>C bus.</li>&#13;
<li value="2">Write the device address with the LO bit 0 (write operation).</li>&#13;
<li value="3">Write the OLAT, OLATA, or OLATB register address (OLAT = 0xA on MCP23008, OLATA = 0xA or 0x14, and OLATB = 0x1A or 0x15 on MCP23017).</li>&#13;
<li value="4"><span epub:type="pagebreak" id="Page_276" title="276"/>Write the OLAT bits to the I<sup>2</sup>C bus.</li>&#13;
<li value="5">Write the second set of OLAT bits (OLATB) to the I<sup>2</sup>C bus (see <a href="#figure13-10" id="figureanchor13-10">Figure 13-10</a>). This is optional on MCP23017 (SEQOP = 0, only).</li>&#13;
<li value="6">Place a stop condition on the bus.</li>&#13;
</ol>&#13;
<p>This sequence is less complex than reading because you don’t have to do a repeated start condition and write a second device address to the bus.</p>&#13;
<figure>&#13;
<img alt="" class="" height="227" src="image_fi/502468c13/f13010.png" width="844"/>&#13;
<figcaption><p><a id="figure13-10">Figure 13-10</a>: GPIO (OLAT) 16-bit sequential write operation</p></figcaption>&#13;
</figure>&#13;
<p>Note that the output pins on the MCP230<em>xx</em> ICs are not capable of driving much current. Each pin is capable of sourcing or sinking 25 mA—barely enough to light an LED. The entire package is further limited to 150 mA, meaning you cannot connect 16 LEDs and run them all at 25 mA. To handle more current, you will need to connect a transistor or other current amplifier to the output pin. The ULN2308 Darlington array—8 Darlington amplifiers in an 18-pin package, each capable of sinking 500 mA—is a perfect device for this purpose.</p>&#13;
<h2 id="h1-502468c13-0004">	13.4	Demonstrating Input/Output on an MCP23017</h2>&#13;
<p class="BodyFirst">By now you’ve learned enough to actually program the MCP230<em>xx</em> devices in polled (non-interrupt) mode. The sample Arduino program in this section writes some output data to port B on an MCP23017 and reads this data from port A on the same device. This program is relatively trivial in terms of functionality, but it demonstrates most of what you need to program the device.</p>&#13;
<p>The program uses the circuit shown in <a href="#figure13-11" id="figureanchor13-11">Figure 13-11</a>. The SDA and SCL lines on the MCP23017 are wired to the corresponding pins on an Arduino Uno Rev3 (or other Arduino-compatible device). Pins A0, A1, and A2 are wired to Gnd, so the 7-bit device address will be 0x20. The reset pin is wired to +5 V or +3.3 V, depending on whether you’re running a 3.3-V or 5.0-V system. The port A pins are wired to the reversed port B pins. Finally, if your SBC does not provide appropriate pullup resistors on the SDA and SCL lines, you will need to put a pair of 4.7-kΩ resistors between these two lines and Vdd (+5 V or +3.3 V).</p>&#13;
<span epub:type="pagebreak" id="Page_277" title="277"/><figure>&#13;
<img alt="" class="keyline" height="697" src="image_fi/502468c13/f13011.png" width="518"/>&#13;
<figcaption><p><a id="figure13-11">Figure 13-11</a>: Simple wiring example for the program in <a href="#listing13-1" id="listinganchor13-1">Listing 13-1</a></p></figcaption>&#13;
</figure>&#13;
<p>Note in <a href="#figure13-11">Figure 13-11</a> that GPB0 is connected to GPA7, GPB1 is connected to GPA6, . . . , and GPB7 is connected to GPA0. So the output bits will be reversed when read as inputs. This was done to simplify wiring; the bit reversal can be fixed in software.</p>&#13;
<p>The program in  does not use interrupts, so you can leave the INTA and INTB pins floating. Also, don’t forget to wire the Vdd (pin 9) and Vss (pin 10) pins to +5 V (or +3.3 V) and Gnd, respectively.</p>&#13;
<pre><code>// <a href="#listinganchor13-1" id="listing13-1">Listing13-1</a>.ino&#13;
//&#13;
// A simple program that demonstrates&#13;
// MCP23017 programming.&#13;
//&#13;
// This program writes a value to port B, reads&#13;
// a value from port A, and verifies that the&#13;
// value sent to port B was properly read on port A.&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
#define mcp23017    (0x20)&#13;
<span epub:type="pagebreak" id="Page_278" title="278"/>&#13;
// MCP23017 registers:&#13;
&#13;
#define IODIRA (0)&#13;
#define IOCON  (0x0A)&#13;
#define GPPUA  (0x0C)&#13;
#define GPIOA  (0x12)&#13;
#define OLATB  (0x15)&#13;
&#13;
void setup( void )&#13;
{&#13;
&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "Test reading and writing MCP23017" );&#13;
&#13;
    Wire.begin(); // Initialize I2C library&#13;
&#13;
    // Initialize the MCP23017:&#13;
    //&#13;
    // - Sequential port A/B registers (BANK = 0)&#13;
    // - Don't mirror INT pins (MIRROR = 0)&#13;
    // - Autoincrement register numbers (SEQOP = 0)&#13;
    // - Slew rate control on (DISSLW = 0)&#13;
    // - ODR in open-drain mode (ODR = 1)&#13;
    // - Interrupt polarity is active low (INTP = 0)&#13;
&#13;
    #define initIOCON (4)   // ODR = 1&#13;
&#13;
    Wire.beginTransmission( mcp23017 );&#13;
    Wire.write( IOCON );&#13;
    Wire.write( initIOCON );&#13;
    Wire.endTransmission(); // Sends stop condition&#13;
&#13;
    // Set port A to input, port B to output,&#13;
    // and polarity noninverting.&#13;
&#13;
    Wire.beginTransmission( mcp23017 );&#13;
    Wire.write( IODIRA );&#13;
    Wire.write( 0xff );     // Port A = inputs&#13;
    Wire.write( 0 );        // Port B = outputs&#13;
    Wire.write( 0 );        // Port A noninverting&#13;
    Wire.endTransmission(); // Sends stop condition&#13;
&#13;
    // Disable pullup resistors on port A.&#13;
&#13;
    Wire.beginTransmission( mcp23017 );&#13;
    Wire.write( GPPUA );&#13;
    Wire.write( 0 );        // Port A = no pullups&#13;
    Wire.endTransmission(); // Sends stop condition&#13;
&#13;
}&#13;
&#13;
void loop( void )&#13;
<span epub:type="pagebreak" id="Page_279" title="279"/>{&#13;
    static byte outputValue   = 0;&#13;
    static byte expectedValue = 0;&#13;
&#13;
    ++outputValue;&#13;
&#13;
    // You simplified the wiring and connected&#13;
    // GPB0 to GPA7, GPB1 to GPA6, ..., GPB7 to GPA0.&#13;
    // So you need to reverse the bits in the&#13;
    // expected value.&#13;
&#13;
    expectedValue =   ((outputValue &amp; 0x01) &lt;&lt; 7)&#13;
                    | ((outputValue &amp; 0x02) &lt;&lt; 5)&#13;
                    | ((outputValue &amp; 0x04) &lt;&lt; 3)&#13;
                    | ((outputValue &amp; 0x08) &lt;&lt; 1)&#13;
                    | ((outputValue &amp; 0x10) &gt;&gt; 1)&#13;
                    | ((outputValue &amp; 0x20) &gt;&gt; 3)&#13;
                    | ((outputValue &amp; 0x40) &gt;&gt; 5)&#13;
                    | ((outputValue &amp; 0x80) &gt;&gt; 7);&#13;
&#13;
    // Write the byte to the output (port B).&#13;
&#13;
    Wire.beginTransmission( mcp23017 );&#13;
    Wire.write( OLATB );&#13;
    Wire.write( outputValue );&#13;
    Wire.endTransmission(); // Sends stop condition&#13;
&#13;
    // Read a byte from the input (port A).&#13;
&#13;
    Wire.beginTransmission( mcp23017 );&#13;
    Wire.write( GPIOA );                // Send register address&#13;
    Wire.endTransmission( false );      // No stop condition&#13;
&#13;
    Wire.requestFrom( mcp23017, 1 );    // Read from portA&#13;
    while( !Wire.available() ){}        // Wait for byte&#13;
&#13;
    byte b = Wire.read();               // Get input byte&#13;
&#13;
    if( b != expectedValue)&#13;
    {&#13;
        Serial.print&#13;
        ( &#13;
            "Error writing and reading MCP23017, value=0x" &#13;
        );&#13;
        Serial.print( b, 16 );&#13;
        Serial.print( ", output 0x" );&#13;
        Serial.print( outputValue, 16 );&#13;
        Serial.print( ", expected 0x" );&#13;
        Serial.println( expectedValue, 16 );&#13;
    }&#13;
    else&#13;
{&#13;
        static uint32_t count = 0;&#13;
&#13;
        if( ++count &amp; 0x3f )&#13;
<span epub:type="pagebreak" id="Page_280" title="280"/>            Serial.print( "." );&#13;
        else&#13;
            Serial.println( "." );&#13;
    }&#13;
}</code></pre>&#13;
<p>The <code>setup()</code> function initializes the MCP23017 device as appropriate for this sample program. Most importantly, it initializes port A pins as inputs and port B pins as outputs. It also disables the pullup resistors on the port A input pins, because port B is connected directly to port A, and port B’s pins provide TTL (5-V) signals.</p>&#13;
<p>The <code>loop()</code> function simply writes a sequence of byte values to port B, reads a byte value from port A, and verifies that the value read is equal (with bit reversal due to wiring) to the value that was written (to port B). This function prints an error message to the serial port if the two values do not match.</p>&#13;
<h2 id="h1-502468c13-0005">	13.5	Interrupts on the MCP230<em>xx</em></h2>&#13;
<p class="BodyFirst">Most programmers using the MCP230<em>xx </em>on an Arduino system don’t bother using the interrupt facilities on those devices. It’s often less work to simply poll the device to determine if any input bits have changed rather than to create an ISR and program the interrupts on the MCP230<em>xx</em>. If you’re programming a system that can poll the MCP230<em>xx</em> at a sufficiently high frequency without impacting the performance of other activities on your system, polling is a reasonable approach. However, if real-time concerns mean polling is not an option, the interrupt facilities on the MCP230<em>xx</em> can be a lifesaver.</p>&#13;
<h3 id="h2-502468c13-0009">13.5.1	Interrupt Actions on the MCP230<em>xx</em></h3>&#13;
<p class="BodyFirst">The program in <a href="#listing13-1">Listing 13-1</a> continuously wrote and read data. Because this program was responsible for both writing the data (to port B) and reading the data (at port A), the application always knows when data will be available on port A (specifically, data will be available immediately after the <code>loop()</code> function writes the data to port B). In the majority of real-world systems, the incoming data usually comes from some external hardware, and the<code> loop()</code> function wouldn’t intrinsically know when new data has arrived on port A. One solution might be to have the <code>loop()</code> function continuously read port A and compare the value read against the previous reading. When the two values are different, the function can assume that external hardware has transmitted a new value and deal with it appropriately. This scheme is known as <em>polling</em>.</p>&#13;
<p>One problem with polling is that it consumes CPU time (to read and compare the port B value) even when the external hardware is not transmitting new values. During polling, the CPU cannot be used for other operations. A better solution would be to have the external hardware notify the CPU that new data is available; this notification would interrupt the <span epub:type="pagebreak" id="Page_281" title="281"/>current CPU’s activities so it can briefly deal with the changed data and then resume the interrupted operation after handling the new data. The question is, how can the external hardware interrupt the CPU whenever it applies new data to port B?</p>&#13;
<p>You can program the MCP230<em>xx</em> devices to produce a signal on the MCP23008 INT or the MCP23017 INTA or INTB pins whenever a change in state occurs. A change in state, known as an <em>interrupt-on-change (IOC)</em>, is noted in one of two programmable situations:</p>&#13;
<ul>&#13;
<li>A pin changes state (from low to high or from high to low).</li>&#13;
<li>A pin changes state when compared against the corresponding bit in the DEFVAL register.</li>&#13;
</ul>&#13;
<p>The INT<em>x</em> pins reflect the current interrupt state. You would normally connect the INT<em>x</em> pins to an interrupt input on your SBC. Different SBCs support interrupts on different pins. Of course, if you are using a different SBC or a different RTOS, you will have to check the documentation for the SBC or RTOS to determine which pins are suitable for use as interrupt inputs. This section will assume you are using the Arduino libraries; see your SBC or RTOS documentation when using a different system.</p>&#13;
<h3 id="h2-502468c13-0010">13.5.2	Interrupt Service Routines</h3>&#13;
<p class="BodyFirst">When an interrupt causes the CPU to halt the current program execution, it transfers control to a special function: the ISR. The ISR quickly does whatever is necessary to handle the hardware event and then returns control to the system, which resumes the original, interrupted code. To support ISRs in an application, you’ll need to address a few questions. Answers vary by system; the following sections give answers for the Arduino.</p>&#13;
<p class="ListHead"><b>How and where is the electronic signal input to the system?</b></p>&#13;
<ol class="none">&#13;
<li>In most systems, Arduino included, interrupts are digital logic signals input on specific CPU or system pins. On the Arduino, selected digital I/O pins can serve as interrupt inputs. (See “For More Information” for information on Arduino-brand pin selections for interrupts.) For example, the Arduino Uno Rev3 supports interrupts on digital I/O pins 2 and 3, and the Teensy 3.1 supports interrupts on any digital I/O pin. Not all Arduino devices support pin 2 as an interrupt pin; check your documentation when using a different device.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>What type of input signals the interrupt?</b></p>&#13;
<ol class="none">&#13;
<li>Because digital I/O signals can be low (0) or high (1), you might think that interrupts can occur only on these two conditions. In fact, most Arduino systems will invoke an interrupt on one of the following conditions:&#13;
<ul>&#13;
<li>A low-to-high transition on the interrupt pin</li>&#13;
<li>A high-to-low transition on the interrupt pin</li>&#13;
<li><span epub:type="pagebreak" id="Page_282" title="282"/>Any change (low-to-high or high-to-low) on the interrupt pin</li>&#13;
<li>A low signal on the interrupt pin&#13;
<p class="ListBody">Some, but not all, Arduino devices can also invoke an interrupt when the interrupt pin is high.</p></li>&#13;
</ul>&#13;
</li>&#13;
</ol>&#13;
<p class="ListHead"><b>How do you specify the ISR function?</b></p>&#13;
<ol class="none">&#13;
<li>Arduino systems use the <code>attachInterrupt()</code> function to associate a particular digital I/O pin with an interrupt. The call takes the following form:&#13;
<pre><code>attachInterrupt( digitalPinToInterrupt( <var>pin</var> ), <var>ISR</var>, <var>mode</var> );</code></pre>&#13;
<p class="ListBody">In this call, <var>pin</var> is a digital I/O pin number, <var>ISR</var> is the name of a void function with no parameters that serves as the interrupt service routine, and <var>mode</var> is one of the following identifiers:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>LOW</code></span> </span>  Triggers the interrupt whenever the pin is low</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>CHANGE</code></span> </span>  Triggers the interrupt whenever the pin changes value</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>RISING</code></span> </span>  Triggers when the pin goes from low to high</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>FALLING</code></span> </span>  Triggers when the pin goes from high to low</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>HIGH</code></span> </span>  Triggers the interrupt whenever the pin is high </li>&#13;
</ol>&#13;
<p class="ListBody">Only some Arduino-compatible boards allow <code>HIGH</code>, so check your board’s documentation to see if it supports active high interrupt signaling (for example, the Uno Rev3 does not support <code>HIGH</code>).</p>&#13;
<p class="ListBody">To use interrupts on other systems, see the documentation for your library, OS, or SBC.</p>&#13;
</li>&#13;
</ol>&#13;
<p class="ListHead"><b>What are the constraints on the ISR function?</b></p>&#13;
<ol class="none">&#13;
<li>Most operating systems place constraints on ISRs. Generally, you should assume the following:&#13;
<ul>&#13;
<li>Any global variables an ISR modifies should be declared as <code>volatile</code>.</li>&#13;
<li>ISR functions should be short, and execution time should be as minimal as possible.</li>&#13;
<li>Many systems do not allow interrupts to be nested (that is, they don’t allow one interrupt signal to interrupt an executing ISR).</li>&#13;
<li>Many systems limit the type of library function calls that you can make in an ISR.</li>&#13;
</ul>&#13;
<p class="ListBody">Please consult your particular OS’s reference manuals for additional information about interrupt service routines.</p>&#13;
<p class="ListBody">The Arduino library, for example, places a couple of additional constraints on ISRs. In particular, you cannot use the <code>delay()</code> or <code>millis()</code> functions within an ISR. See “For More Information” for links to Arduino interrupt documentation.</p>&#13;
</li>&#13;
</ol>&#13;
<p class="ListHead"><b><span epub:type="pagebreak" id="Page_283" title="283"/>INT<em>x</em> pin polarity</b></p>&#13;
<ol class="none">&#13;
<li>When the MCP230<em>xx</em> detects a pin change that would cause an interrupt, it will set the INT<em>x</em> pin high or low. The INTPOL bit (bit 1) in the IOCON register determines the interrupt polarity. If INTPOL is 1, then the interrupt signal is active high—that is, the INT<em>x</em> pin will go high when an interrupt occurs. If INTPOL is 0, then the interrupt signal is active low and goes low on an interrupt.&#13;
<p class="ListBody">You can select the appropriate interrupt polarity either by using the Arduino <code>attachInterrupt()</code> <code>mode</code> parameter or by setting the interrupt polarity on the MCP230<em>xx</em>. However, it is important to ensure that the polarity you specify by <code>mode</code> matches the polarity you specify with the INTPOL bit. The common convention is to use active low interrupts and specify either <code>LOW</code> or <code>FALLING</code> as the <code>mode</code> parameter value.</p>&#13;
</li>&#13;
</ol>&#13;
<h3 id="h2-502468c13-0011">13.5.3	Mirroring INT<em>x</em> Pins (MCP23017 Only)</h3>&#13;
<p class="BodyFirst">The MCP23017 provides two independent interrupt pins for port A (INTA pin) and port B (INTB pin). This allows you to quickly determine the source of an interrupt if both ports A and B can generate interrupts, though at the cost of requiring two separate interrupt pins on the CPU. If you want to use only a single pin as an interrupt line on your CPU and are willing to use some software to differentiate port A and port B interrupts, you can program the MCP23017 to wire the INTA and INTB pins together so that an interrupt on either port will send a signal to the INTA and INTB pins.</p>&#13;
<p>Programming the MIRROR bit (bit 6) with a 1 in the IOCON register achieves this. Conversely, programming the MIRROR bit with a 0 (the default condition) routes all port A interrupts to INTA and all port B interrupts to INTB.</p>&#13;
<h3 id="h2-502468c13-0012">13.5.4	Open-Drain INT<em>x</em> Output</h3>&#13;
<p class="BodyFirst">Bit 2 of the IOCON register (ODR) controls the INT<em>x</em> line open-drain interface. If this bit is programmed as a 1, open-drain output is enabled; if it is programmed as a 0 (the default), the active logic output in the INT<em>x</em> lines is enabled.</p>&#13;
<p>The open-drain form allows you to connect the INT lines from multiple MCP230<em>xx</em> devices together. This mode requires a pullup resistor on the output line. In open-drain mode, an interrupt signal will pull the INT<em>x</em> pin low, which, presumably, signals an interrupt on the controller. The controller will have to poll the various MCP230<em>xx </em>devices to determine the source of the interrupt.</p>&#13;
<p>The active logic output mode puts a logic signal directly on the INT<em>x</em> output pin. In this mode, the INT<em>x</em> pin must exclusively connect to an interrupt on the controller device; you cannot tie the interrupt pins together since that would create an electrical fault. This mode is best when you have a single MCP230<em>xx</em> device or if you need separate interrupts for each MCP230<em>xx</em> (so you don’t have to poll the devices to determine the source of the interrupt). </p>&#13;
<p><span epub:type="pagebreak" id="Page_284" title="284"/>Active logic mode is the default interrupt mode, a design error in MCP230<em>xx</em> devices. Tying multiple devices’ INT<em>x</em> lines together and forgetting to program the ODR bit in open-drain mode could create an electrical conflict that could damage the MCP230<em>xx</em> parts. Moral of the story: always program the ODR bit in IOCON correctly! Many designers stick a transistor (such as a 2N7000 MOSFET) on the INT<em>x</em> pins to force open-drain (open-collector) mode and program ODR in active logic mode to drive the transistor. This avoids the possibility of a programming error that would damage the MCP230<em>xx</em>.</p>&#13;
<h3 id="h2-502468c13-0013">13.5.5	Enabling Interrupts on the MCP230<em>xx</em></h3>&#13;
<p class="BodyFirst">By default, the MCP230<em>xx</em> parts do not generate any interrupts; you must explicitly enable interrupts for the INT<em>x</em> pins to become active. You can do so with the MCP23008 GPINTEN and MCP23017 GPINTENA and GPINTENB registers.</p>&#13;
<p>The MCP230<em>xx</em> devices allow you to enable or disable interrupts on a pin-by-pin basis. Each bit in a GPINTEN<em>x</em> register matches one of the GPIO pins: GPINTENA matches GPIOA pins, and GPINTENB matches GPIOB pins on the MCP23017. If a bit in GPINTEN<em>x</em> contains 0, then interrupts are disabled for that particular I/O pin. If the bit contains 1, then interrupts are enabled for that bit, and interrupts are generated based on the bit settings in the INTCON and DEFVAL registers.</p>&#13;
<p>If interrupts are enabled for a particular I/O pin, then the INTCON and DEFVAL registers allow you to program the MCP230<em>xx</em> to generate an interrupt on a pin change or on a particular level. If a specific INTCON bit is 0, then the MCP230<em>xx</em> will generate an interrupt any time the input bit changes (that is, it will generate an interrupt on a low-to-high or on a high-to-low transition). In this case, the MCP230<em>xx</em> ignores the corresponding bit in DEFVAL. If a specific INTCON bit is 1, then the MCP230<em>xx</em> will generate an interrupt any time the input bit differs from the value of the corresponding bit in DEFVAL. This allows you to create level-sensing interrupts. If the corresponding bit in DEFVAL is 0, then the MCP230<em>xx</em> generates interrupts when the input pin is high; if the bit in DEFVAL is 1, then the MCP230<em>xx</em> generates interrupts when the input pin is low. Note that if the corresponding bit in INTCON is 0, or if that bit in GPINTEN<em>x</em> is 0, the system ignores the bit in DEFVAL.</p>&#13;
<p>Although it is possible to modify the GPINTEN<em>x</em>, INTCON<em>x</em>, and DEFVAL<em>x</em> registers throughout program execution in complex systems, most commonly you initialize these registers just once when your program first begins execution. To prevent race conditions, you should initialize interrupts in the following order:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Initialize the DEFVAL<em>x </em>register(s), if necessary.</li>&#13;
<li value="2">Initialize the INTCON<em>x</em> register(s), if necessary.</li>&#13;
<li value="3">Read the GPIO pins to clear any existing interrupts.</li>&#13;
<li value="4">Initialize the GPINTEN<em>x</em> register(s), if necessary.</li>&#13;
<li value="5">Attach an ISR to the particular pin using <code>attachInterrupt()</code>.</li>&#13;
</ol>&#13;
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_285" title="285"/>A sequence like this helps prevent any inadvertent interrupts resulting from pre-existing conditions on the input pins or conditions that change during initialization. This particular sequence is for an Arduino system, but all other systems have a comparable one.</p>&#13;
<h3 id="h2-502468c13-0014">13.5.6	Testing and Clearing Interrupts</h3>&#13;
<p class="BodyFirst">The INT<em>x</em> pin(s) on the MCP230<em>xx</em> indicate only that an interrupt has occurred on one (or both) banks. When the system invokes the ISR, you don’t know which pin—or pins, if multiple pins change simultaneously—is responsible for the interrupt. To determine the exact source(s) of the interrupt, you will need to read the MCP23008 INTF or MCP23017 INTFA or INTFB register(s).</p>&#13;
<p>The bits in the INTF<em>x</em> register indicate which bits are responsible for an interrupt. When the ISR begins execution, it should read the INTF<em>x</em> register(s), where a 1 bit in a bit position indicates that the interrupt resulted from a change in the specified input bit. The ISR can then read the appropriate GPIO pin to determine the state of that pin when the interrupt occurred. For example, if interrupts are enabled for any change, reading the GPIO pin will tell you whether a rising or falling edge on the pin called the interrupt.</p>&#13;
<p>In theory, the CPU will invoke the ISR almost immediately after the interrupt pin changes state. In practice, it is possible for the ISR invocation to be slightly delayed after the interrupt condition occurs; for example, some other high-priority code (ISR) could be executing with the interrupts disabled. In that case, the ISR will be called only when the current high-priority code re-enables interrupts. During this time, it is possible for the state of the I/O pin to change. Therefore, by the time the ISR reads the signal on the input pin, the input data could have changed, and whatever the ISR reads might be wrong (a common race condition). To prevent this from happening, the MCP230<em>xx</em> <em>captures</em> the state of the pins when the interrupt occurs. The MCP230<em>xx</em> puts this snapshot of the pins in the MCP23008 INTCAP or MCP23017 INTCAPA and INTCAPB registers. Therefore, the ISR should actually read the contents of the appropriate INTCAP<em>x</em> register to determine the pin state that produced the interrupt.</p>&#13;
<p>By reading GPIO data (GPIO<em>x</em> or INTCAP<em>x</em> port), the ISR unfreezes the INTCAP<em>x</em>. This prepares it to capture the next interrupt pin set. You should always read the INTCAP<em>x</em> register(s) first in an ISR, since it’s possible to lose captured information if another interrupt is pending and you read the GPIO<em>x</em> port first instead. Typically, there is no real need to read the GPIO<em>x</em> register(s) in an ISR—the INTCAP<em>x</em> register(s) usually provide all the information you need.</p>&#13;
<p>Pins configured for interrupt-on-change (in the INTCON<em>x</em> registers) will change the state that causes the next interrupt after you read the corresponding INTCAP<em>x</em> register. For example, if an interrupt occurred because a pin changed from high to low, the new interrupt condition (low to high) will not be active until you clear the interrupt by reading GPIO<em>x</em> or INTCAP<em>x</em>. If the pin actually toggles from high to low, then low to high and <span epub:type="pagebreak" id="Page_286" title="286"/>high to low again, the MCP230<em>xx</em> will signal a single interrupt only if the system has not cleared the interrupts between these level changes on the input pin.</p>&#13;
<p>Pins configured for interrupt-on-level—that is, pins configured to cause an interrupt based on the value appearing in a DEFVAL<em>x</em> register—continuously generate an interrupt signal as long as that level condition exists on the input pin. Reading or writing the GPIO<em>x</em> or INTCAP<em>x</em> register(s) does not reset that particular interrupt state until the interrupt condition ceases to exist.</p>&#13;
<h2 id="h1-502468c13-0006">	13.6	A Sample Interrupt-Driven MCP230<em>xx</em> </h2>&#13;
<p class="BodyFirst">Reading rotary shaft encoders is a common way to demonstrate interrupt programming on MCP230<em>xx</em> devices. As it turns out, twisting a rotary encoded at a high speed can easily result in data loss if the CPU is often busy doing other work, like displaying the values read from the rotary encoders. Using an ISR to quickly capture the encoder data and make it available for some main thread to process can eliminate data loss. This section provides some simple library code that demonstrates how to read and display the data from a SparkFun rotary encoder with red and green LEDs (<a class="LinkURL" href="https://www.sparkfun.com/products/15140">https://www.sparkfun.com/products/15140</a>). </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	You could also use SparkFun’s RGB rotary encoder (<a class="LinkURL" href="https://www.sparkfun.com/products/15141">https://www.sparkfun.com/products/15141</a>) or shaft encoder (<a class="LinkURL" href="https://www.sparkfun.com/products/9117">https://www.sparkfun.com/products/9117</a>) for the example in this section, with a few modifications. </p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p class="BodyContinued">The SparkFun rotary encoder breakout (<a class="LinkURL" href="https://www.sparkfun.com/products/11722">https://www.sparkfun.com/products/11722</a>) makes it easy to breadboard one of these devices into a circuit, as shown in <a href="#figure13-12" id="figureanchor13-12">Figure 13-12</a>.</p>&#13;
<figure>&#13;
<img alt="" class="" height="332" src="image_fi/502468c13/f13012.png" width="182"/>&#13;
<figcaption><p><a id="figure13-12">Figure 13-12</a>: SparkFun rotary encoder breakout board</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_287" title="287"/>SparkFun rotary encoders have two digital I/O pins labeled A and B, which specify rotational changes (see <a href="#figure13-13" id="figureanchor13-13">Figure 13-13</a>). You wire these pins through a 10-kΩ resistor to +5 V and wire the pin labeled C to Gnd. (If you connect the rotary encoder to an MCP230<em>xx</em> device, you can use the built-in programmable pullup resistor in place of the 10-kΩ resistor.) As you rotate the shaft on the encoder, it selectively connects pins A and B to pin C, that is, to Gnd. The pins labeled 1, 2, 3, and 4 in <a href="#figure13-13">Figure 13-13</a> connect to the red and green LEDs, a pushbutton switch, and a common for these pins.</p>&#13;
<p>Connecting pins A and B to inputs on your SBC allows you to read the state of the two pins (high or low). By observing the state of these two pins over time, you can tell which direction the shaft is rotating, and at what speed, if you are timing the changes.</p>&#13;
<figure>&#13;
<img alt="" class="" height="283" src="image_fi/502468c13/f13013.png" width="223"/>&#13;
<figcaption><p><a id="figure13-13">Figure 13-13</a>: SparkFun Red/Green rotary encoder</p></figcaption>&#13;
</figure>&#13;
<p>If you turn the shaft clockwise (CW) at a fixed speed, you will get the waveform shown in <a href="#figure13-14" id="figureanchor13-14">Figure 13-14</a> on pins A and B.</p>&#13;
<figure>&#13;
<img alt="" class="" height="242" src="image_fi/502468c13/f13014.png" width="694"/>&#13;
<figcaption><p><a id="figure13-14">Figure 13-14</a>: Rotary encoder output when rotating shaft clockwise</p></figcaption>&#13;
</figure>&#13;
<p>The output in <a href="#figure13-14">Figure 13-14</a> is known as a <em>quadrature output</em>, where two out-of-phase signals determine the rotation direction, producing binary outputs similar to those shown in <a href="#table13-5" id="tableanchor13-5">Table 13-5</a> over time.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table13-5">Table 13-5</a>: Clockwise Rotary Encoder Output<span epub:type="pagebreak" id="Page_288" title="288"/></p></figcaption>&#13;
<table border="1" id="table-502468c13-0005"><tbody>&#13;
<tr>&#13;
<td>Output A</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>And so on</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Output B</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>And so on</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>If you treat the input pairs as a 2-bit binary value, turning the encoder clockwise produces the repeating binary sequence 01 00 10 11 01 00 10 11 . . . over time. This is an example of a 2-bit<em> gray code</em>, a binary counting sequence where no more than a single bit changes between any two successive values (see “For More Information”). Gray codes are useful when working with multibit mechanical inputs because they are more immune to noise than regular binary codes are.</p>&#13;
<p>If you turn the shaft counterclockwise (CCW) at a fixed speed, you will get the waveform in <a href="#figure13-15" id="figureanchor13-15">Figure 13-15</a> on pins A and B.</p>&#13;
<figure>&#13;
<img alt="" class="" height="235" src="image_fi/502468c13/f13015.png" width="694"/>&#13;
<figcaption><p><a id="figure13-15">Figure 13-15</a>: Rotary encoder output when rotating shaft counterclockwise</p></figcaption>&#13;
</figure>&#13;
<p>This also produces outputs similar to those shown in <a href="#table13-6" id="tableanchor13-6">Table 13-6</a> over time.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table13-6">Table 13-6</a>: Counterclockwise Rotary Encoder Output</p></figcaption>&#13;
<table border="1" id="table-502468c13-0006"><tbody>&#13;
<tr>&#13;
<td>Output A</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>And so on</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Output B</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>And so on</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>The gray code output is the binary sequence: 00 01 11 10 00 01 . . .</p>&#13;
<p>Another way to interpret the A and B inputs is to use a change in A to indicate a rotation of the encoder shaft and then read the B input to determine the direction of the rotation:</p>&#13;
<ul>&#13;
<li>A high-to-low transition on A with B low during the transition indicates a CCW rotation.</li>&#13;
<li>A low-to-high transition on A with B high also indicates a CCW rotation.</li>&#13;
<li>A high-to-low transition on A with B high during the transition indicates a CW rotation.</li>&#13;
<li>A low-to-high transition on A with B low also indicates a CW rotation.</li>&#13;
</ul>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_289" title="289"/>A Note About Contact Bouncing</h2>&#13;
<p class="BoxBodyFirst">The contacts on a rotary switch are mechanical and subject to a phenomenon known as keybounce (or just bouncing). Bouncing occurs when the contacts switch from on to off or off to on. During this transition is a brief amount of time (typically a few milliseconds) when the contact rapidly switches between the two states. In a mechanical switch (for example, a pushbutton), the metallic contacts are literally bouncing on and off one another. If software is rapidly scanning this switch contact on an input port (usually at microsecond-level scanning times), the software will see several switch closures and opens until the contacts finally settle in an open or closed position. This can create problems if the software is looking for a single closure or open of the switch.</p>&#13;
<p>Keybounce can be fixed in hardware or software. The hardware solution is to use resistor-capacitor (RC) timing circuit to reduce the rise or fall time of the switch closure. A 10-kΩ resistor and 0.1-µF capacitor, for example, produce a 1 msec time constant (you would also feed this into a Schmidt trigger device, such as a 74HC14 inverter, to add hysteresis to the circuit). You can also solve this problem in software by reducing the scanning rate of the input (say, to less than once every 10 msec). </p>&#13;
<p>Using gray codes on a rotary encoder can reduce noise problems due to keybounce. Physically, the keybounce is still present, but the bouncing switches the inputs between two consecutive numbers in the gray code (as only 1 bit changes at a time on the rotary encoder, and if only 1 bit changes, the resulting numbers are consecutive). This introduces a small amount of jitter in the reading from the rotary encoder, which may be acceptable when using rotary encoders. Of course, if the jitter is unacceptable, you can use hardware (or software) debouncing to resolve the problem.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>An MCP23008 GPIO expander would allow you to connect up to four of the SparkFun Illuminated Red/Green rotary encoders to a system. The encoder used in this section, however, connects a single rotary encoder to pins GP0 and GP1 on an MCP23008. Specifically, the encoder’s A pin connects to GP1, and the B pin connects to GP0 through optional debouncing circuitry. If you also want to control the red and green LEDs on the encoder from the MCP23008, you can add some resistors between pins on MCP23008 to be programmed as outputs, along with the pins 2 and 3 on the rotary encoder. You will also need to connect the pin labeled 1 to Gnd. The resistors should probably be between 470 Ω and 1 kΩ. You can turn the red and green LEDs on or off by programming those output pins with logic 1s or 0s; programming both pins produces a yellow output. The example in this section will ignore the LED outputs, but you can easily add code to control them if you want. </p>&#13;
<p><span epub:type="pagebreak" id="Page_290" title="290"/>The rotary encoder A and B pins are dry contacts. To read logic signals from these pins, you would normally add pullup resistors to the circuit (to +5 V or +3.3 V, whichever is appropriate). Rather than explicitly adding these resistors, the software will enable the GP0 and GP1 pins to use the MCP23008 programmable pin pullup resistors.</p>&#13;
<p class="BodyFirst">The program in <a href="#listing13-2" id="listinganchor13-2">Listing 13-2</a> uses a change on the A pin to cause an interrupt. The ISR will read the A and B pin values on GP1 (A) and GP0 (B) and increment or decrement a global counter based on the previous and current readings of these pins. The main program (that is, the code outside the ISR) uses the value of this global variable to determine how many “clicks” the encoder has been turned in the clockwise or counterclockwise direction since the application began execution.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	For familiarity, the program in <a href="#listing13-2">Listing 13-2</a> is encoded in the Arduino IDE and written specifically for a Teensy 3.2 (or later) module. This code reads the INTCAP register within the ISR. As noted already in this chapter, ISR code must be fast, and certain system (library) calls may not be allowable. This code does not run on an Arduino Uno Rev3 but does seem to work okay on a Teensy 3.2. Whether this is due to the speed difference between the two CPUs or because the Teensy Wire library code is better written is a good question. Generally, I would recommend using a better operating system (FreeRTOS, Mbed, or NetBurner OS) rather than using this scheme in Arduino code. Treat the program in <a href="#listing13-2">Listing 13-2</a> as a “demonstration only” product. The online chapters contain example code for the ESP32 using FreeRTOS if you’d like to see a better implementation.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>For the program in <a href="#listing13-2">Listing 13-2</a>, the MCP23008 SCL and SDA lines (pins 1 and 2) connect to the Teensy 3.2 SDA0 and SCL0 pins (pins D18 and D19). The INT line (pin 8) connects to the Teensy D2 pin. The RESET (pin 6) and Vdd (pin 18) pins connect to +3.3 V. The address lines and Vss (pins 3, 4, 5, and 9) connect to Gnd. Finally, GP1 connects to the rotary encoder A pin, and GP0 connects to the rotary encoder B pin (the rotary encoder C pin connects to ground).</p>&#13;
<p><a href="#listing13-2">Listing 13-2</a> programs the MCP23008 to generate an interrupt (active low) whenever there is a change on the GPA1 pin. When the ISR reads the INTCAP register, GP1 will reflect the value of the A pin <em>after</em> the rising or falling transition. Therefore, if the ISR reads 0 in the LO 2 bits of INTCAP, there has been a falling edge (GP1 is 0) and B is 0. This indicates a counterclockwise rotation. Likewise, if the LO 2 bits of INTCAP are 3 (0b11), then there has been a rising edge and B is 1, which also indicates a CCW rotation.</p>&#13;
<p>On a CW rotation, if the ISR reads a 1 in the LO 2 bits of INTCAP, this indicates a falling edge on A while B is 1. If the ISR reads a 2 (0b10) in the LO 2 bits of INTCAP, this indicates a rising edge on A while B is low (also a CW rotation).</p>&#13;
<p>The ISR simply increments or decrements a global variable (<code>rotaryPosn</code>) on a CW or CCW rotation, respectively. The main program checks this global variable and displays its value whenever it changes.</p>&#13;
<pre><code><span epub:type="pagebreak" id="Page_291" title="291"/>// <a href="#listinganchor13-2" id="listing13-2">Listing13-2</a>.ino&#13;
//&#13;
// Demonstrate reading a rotary encoder&#13;
// using an MCP23008 with interrupts.&#13;
//&#13;
// Assumptions:&#13;
//&#13;
// - MCP23008 INT line connected to&#13;
//   digital I/O line 2.&#13;
//&#13;
// - SparkFun illuminated R/G rotary&#13;
//   encoder output A connected to&#13;
//   GP1 on MCP23008.&#13;
//&#13;
// - SparkFun illuminated R/G rotary&#13;
//   encoder output B connected to&#13;
//   GP0 on MCP23008.&#13;
//&#13;
// - MCP23008 wired to use address&#13;
//   0x20 (A0, A1, A2 = 0, 0 0).&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
&#13;
#define led         (13)&#13;
#define mcp23008    (0x20)&#13;
&#13;
#define IODIR       (0)&#13;
#define IOPOL       (1)&#13;
#define GPINTEN     (2)&#13;
#define DEFVAL      (3)&#13;
#define INTCON      (4)&#13;
#define IOCON       (5)&#13;
#define GPPU        (6)&#13;
#define INTF        (7)&#13;
#define INTCAP      (8)&#13;
#define GPIO        (9)&#13;
#define OLAT        (10)&#13;
&#13;
// The following variable tracks&#13;
// rotations on the rotary encoder.&#13;
// This variable is negative if there&#13;
// have been more clockwise rotations&#13;
// than counterclockwise (likewise,&#13;
// it's positive if there have been&#13;
// more counterclockwise rotations).&#13;
&#13;
volatile int rotaryPosn = 0;&#13;
&#13;
// Write a value to an MCP23008 register:&#13;
&#13;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void writeReg( int reg, int val )&#13;
<span epub:type="pagebreak" id="Page_292" title="292"/>{&#13;
    Wire.beginTransmission( mcp23008 );&#13;
    Wire.write( reg );&#13;
    Wire.write( val );&#13;
    Wire.endTransmission();&#13;
}&#13;
&#13;
// Read a value from an MCP23008 register:&#13;
&#13;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> int readReg( int reg )&#13;
{&#13;
    Wire.beginTransmission( mcp23008 );&#13;
    Wire.write( reg );&#13;
    Wire.endTransmission( false );&#13;
    Wire.requestFrom( mcp23008, 1 );&#13;
    return Wire.read();&#13;
}&#13;
&#13;
// Reset the MCP23008 to a known state:&#13;
&#13;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> void mcpReset( void )&#13;
{&#13;
    // I2C General Call is not mentioned in&#13;
    // the manual so do this the hard way.&#13;
    &#13;
    // INTF   is read only.&#13;
    // INTCAP is read only.&#13;
&#13;
    // Disable interrupts&#13;
    // and clear any pending.&#13;
&#13;
    writeReg( GPINTEN, 0 );&#13;
    readReg( INTCAP );&#13;
&#13;
    // Set remaining registers&#13;
    // to POR/RST values.&#13;
&#13;
    writeReg( IODIR,   0xFF );&#13;
    writeReg( IOPOL,   0 );&#13;
    writeReg( GPINTEN, 0 );&#13;
    writeReg( DEFVAL,  0 );&#13;
    writeReg( INTCON,  0 );&#13;
    writeReg( IOCON,   0 );&#13;
    writeReg( GPPU,    0 );&#13;
    writeReg( GPIO,    0 );&#13;
    writeReg( OLAT,    0 );&#13;
}&#13;
&#13;
// Interrupt service routine that gets&#13;
// called whenever the INT pin on the&#13;
// MCP23008 goes from high to low.&#13;
// This function needs to be *fast*.&#13;
// That means minimizing the number&#13;
<span epub:type="pagebreak" id="Page_293" title="293"/>// of I2C transactions.&#13;
&#13;
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> void ISRFunc( void )&#13;
&#13;
{&#13;
    // Read the INTCAP register.&#13;
    // This reads the GPIO pins at&#13;
    // the time of the interrupt and&#13;
    // also clears the interrupt flags.&#13;
    //&#13;
    // Note: A rotary encoder input in GPA1,&#13;
    // B rotary encoder input in GPA0.&#13;
&#13;
    int cur = readReg( INTCAP ) &amp; 0x3;&#13;
&#13;
    // You have CCW rotation if:&#13;
    //&#13;
    //      A:0-&gt;1 &amp;&amp; B==1  (cur=3)&#13;
    // or   A:1-&gt;0 &amp;&amp; B==0  (cur=0)&#13;
&#13;
    if( cur == 0 || cur == 3 )&#13;
    {&#13;
        ++rotaryPosn;&#13;
    }&#13;
    else if( cur == 1 || cur == 2 )&#13;
    {&#13;
        --rotaryPosn;   // CW rotation&#13;
    }&#13;
    // else illegal reading . . .&#13;
}&#13;
&#13;
// Usual Arduino initialization code:&#13;
&#13;
<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> void setup( void )&#13;
{&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "Rotary Encoder test" );&#13;
&#13;
    pinMode( 0, INPUT_PULLUP );&#13;
    pinMode( 1, INPUT_PULLUP );&#13;
    pinMode( 2, INPUT );&#13;
    pinMode( led, OUTPUT );&#13;
    digitalWrite( led, 0 );&#13;
&#13;
    Wire.begin();&#13;
&#13;
    // Reset the MCP23008 to a known state.&#13;
&#13;
    mcpReset();&#13;
    &#13;
    // Initialize the MCP23008 (this is the default&#13;
<span epub:type="pagebreak" id="Page_294" title="294"/>    // state, so just defensive coding). Note that&#13;
    // SEQOP = 0 is autoincrementing registers and&#13;
    // INTPOL = 0 yields active low interrupts.&#13;
&#13;
    writeReg( IOCON, 0 );&#13;
&#13;
    // Set data direction to input and&#13;
    // turn pullups on for GPA0/GPA1.&#13;
    // Set polarity to inverting for GPA0/GPA1.&#13;
&#13;
    writeReg( IODIR, 0xff );&#13;
    writeReg( IOPOL, 3 );&#13;
    writeReg( GPPU, 3 );&#13;
&#13;
    // Initialize MCP23008 interrupts.&#13;
&#13;
    writeReg( INTCON, 0 );      // GPA1 int on change&#13;
    writeReg( GPINTEN, 0x2 );   // Enable GPA1 interrupt&#13;
&#13;
    attachInterrupt( digitalPinToInterrupt(2), ISRFunc, FALLING );&#13;
    interrupts();               // Ensure CPU interrupts enabled&#13;
}&#13;
&#13;
// Main Arduino loop:&#13;
&#13;
<span aria-label="annotation6" class="CodeAnnotationCode">❻</span> void loop( void )&#13;
{&#13;
    static int lastRP = 0;&#13;
&#13;
    if( rotaryPosn != lastRP )&#13;
    {&#13;
        Serial.print( "Posn=" ); Serial.println( rotaryPosn );&#13;
        lastRP = rotaryPosn;&#13;
    }&#13;
}</code></pre>&#13;
<p><a href="#listing13-2">Listing 13-2</a> contains two functions, <code>writeReg()</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span> and <code>readReg()</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, that write data to and read data from an MCP23008 register. These functions transmit the appropriate I<sup>2</sup>C bytes to accomplish this. The <code>mcpReset()</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span> function initializes the MCP23008 to the power-on reset state, which is useful if the code is rerun without powering down the MCP23008. The code also includes an interrupt service routine, <code>ISRFunc()</code> <span aria-label="annotation4" class="CodeAnnotation">❹</span>, along with the usual Arduino <code>setup()</code> <span aria-label="annotation5" class="CodeAnnotation"><span class="CodeAnnotation">5</span></span><code> </code>and <code>loop()</code> <span aria-label="annotation6" class="CodeAnnotation"><span class="CodeAnnotation">6</span></span><code> </code>functions.</p>&#13;
<p>When a change occurs on the GP1 pin (because the shaft has rotated), this triggers an interrupt, causing the system to call the <code>ISRFunc()</code> function. This function determines if the shaft has rotated clockwise or counterclockwise and adjusts the value of the <code>rotaryPosn</code> variable accordingly.</p>&#13;
<p>The following is some sample output from the program in <a href="#listing13-2">Listing 13-2</a> obtained by twisting the encoder knob back and forth.</p>&#13;
<pre><code><span epub:type="pagebreak" id="Page_295" title="295"/>Posn=0&#13;
Posn=-1&#13;
Posn=-2&#13;
Posn=-3&#13;
Posn=-4&#13;
Posn=-5&#13;
Posn=-6&#13;
Posn=-7&#13;
Posn=-8&#13;
Posn=-7&#13;
Posn=-6&#13;
Posn=-5&#13;
Posn=-4&#13;
Posn=-3&#13;
Posn=-2&#13;
Posn=-1&#13;
Posn=0&#13;
Posn=1&#13;
Posn=2&#13;
Posn=3&#13;
Posn=4</code></pre>&#13;
<p>As you can determine from the output, the shaft was rotated counterclockwise for a short period, decrementing the output value, and then it was turned clockwise for a bit, incrementing the output value.</p>&#13;
<h2 id="h1-502468c13-0007">	13.7	MCP230<em/><em>xx</em> Library Code</h2>&#13;
<p class="BodyFirst">Because of the complexity, many programmers prefer to use calls to existing library code rather than writing directly to the hardware themselves. Arduino provides an MCP230<em>xx</em> library package to help you out with this. See “For More Information” for the links to these libraries.</p>&#13;
<p>If you’d prefer to program the MCP230<em>xx</em> on a Raspberry Pi, Adafruit has also ported its library to the Pi; see “For More Information” for details. Likewise, those links describe where to find an MCP23008 library for Mbed. A quick web search will turn up several example Mbed libraries for the MCP23017 (mostly adaptations of the Adafruit library). You can also easily search for the dozens of examples of MCP230<em>xx</em> code scattered across the internet for a wide variety of CPUs, operating systems, and programming languages. </p>&#13;
<h2 id="h1-502468c13-0008">	13.8	I<sup>2</sup>C Performance</h2>&#13;
<p class="BodyFirst">Although digital I/O functions, like reading a pushbutton, don’t require blazing performance, many such activities do require fast processing to properly read or write high-frequency digital signals. Unfortunately, <span epub:type="pagebreak" id="Page_296" title="296"/>high-performance operation and I<sup>2</sup>C bus connections are often mutually exclusive. Because it can sometimes take three or four bus transactions to read or write digital data via an MCP230<em>xx</em> device, it might require 400 μsec to 500 μsec for a single I/O operation at 100 kHz, yielding a 2-kHz sample rate. This can be too slow for certain operations.</p>&#13;
<p>Fortunately, the MCP230<em>xx</em> devices can run at 400 kHz and up to 1.7 MHz as well as 100 kHz. At 400 kHz, you can achieve (at least) an 8-kHz sample rate, and 10 kHz to 20 kHz is not unreasonable with carefully written code. If you’re willing to operate the bus at 1 MHz or more, you could even get the sample rate up to around 100 kHz, which is suitable for most applications. If you need higher performance, you’ll probably want to use something other than the I<sup>2</sup>C bus, like SPI versions of the MCP230<em>xx</em>.</p>&#13;
<h2 id="h1-502468c13-0009">	13.9	MCP23S<em>xx</em> Parts</h2>&#13;
<p class="BodyFirst">When searching for information about the MCP23008 and MCP23017 parts, you may come across references to the MCP23S08 and MCP23S17 devices. These GPIO expanders are nearly identical to the MCP230<em>xx</em> parts, except that they were designed for use on the SPI bus rather than the I<sup>2</sup>C bus. Most code written for the MCP23S<em>xx</em> parts will work fine on the MCP230<em>xx</em> devices with minimal modifications: essentially, you’d change the code to call I<sup>2</sup>C library functions rather than SPI library functions to write and read data to and from the devices. </p>&#13;
<p>Because the SPI bus operates at a higher frequency than the I<sup>2</sup>C bus, SPI variants can read input data at a higher sampling frequency. For more information, see the MCP23<em>xxx</em> documentation (which covers both the SPI and I<sup>2</sup>C parts). Links appear in “For More Information.”</p>&#13;
<h2 id="h1-502468c13-0010">	13.10	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter covered the MCP23017 and MCP23008 GPIO expansion ICs. It described the on-chip registers, including the data, data direction, pullup, and polarity registers. It described how to read and write digital data via the pins on the MCP230<em>xx</em>. This chapter also discussed interrupt-driven I/O using the MCP230<em>xx</em> devices; it presented a short sample program to read a SparkFun rotary encoder using an ISR to help avoid missing any pulses from the encoder. Finally, this chapter ended by discussing the use of open-software libraries available for the MCP230<em>xx</em>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_297" title="297"/>For More Information</h2>&#13;
<ol class="none">&#13;
<li>Some interesting online tutorials for the MCP230<em>xx</em>: <a class="LinkURL" href="https://www.best-microcontroller-projects.com/mcp23017.xhtml">https://www.best-microcontroller-projects.com/mcp23017.xhtml</a></li>&#13;
<li>MCP23017 datasheet: <a class="LinkURL" href="https://ww1.microchip.com/downloads/en/devicedoc/20001952c.pdf">https://ww1.microchip.com/downloads/en/devicedoc/20001952c.pdf</a></li>&#13;
<li>MCP23008 datasheet: <a class="LinkURL" href="https://ww1.microchip.com/downloads/en/devicedoc/21919e.pdf">https://ww1.microchip.com/downloads/en/devicedoc/21919e.pdf</a></li>&#13;
<li>Arduino libraries for MCP230<em>xx</em> devices: <a class="LinkURL" href="https://www.arduino.cc/reference/en/libraries/mcp23017">https://www.arduino.cc/reference/en/libraries/mcp23017</a></li>&#13;
<li>Adafruit libraries for MCP230<em>xx</em> devices: <a class="LinkURL" href="https://github.com/adafruit/Adafruit-MCP23017-Arduino-Library">https://github.com/adafruit/Adafruit-MCP23017-Arduino-Library</a></li>&#13;
<li>Sming libraries for MCP230<em>xx</em> devices: <a class="LinkURL" href="https://sming.readthedocs.io/en/latest/_inc/Sming/Libraries/MCP23017/index.xhtml">https://sming.readthedocs.io/en/latest/_inc/Sming/Libraries/MCP23017/index.xhtml</a></li>&#13;
<li>An Mbed MCP23008 library: <a class="LinkURL" href="https://os.mbed.com/users/dewyatt/code/MCP23008/docs/tip/classMCP23008.xhtml">https://os.mbed.com/users/dewyatt/code/MCP23008/docs/tip/classMCP23008.xhtml</a></li>&#13;
<li>Arduino documentation: <a class="LinkURL" href="https://www.arduino.cc/reference/en/language/functions/external-interrupts/attachinterrupt">https://www.arduino.cc/reference/en/language/functions/external-interrupts/attachinterrupt</a></li>&#13;
<li>Information on Arduino interrupts: <a class="LinkURL" href="https://gammon.com.au/interrupts">https://gammon.com.au/interrupts</a></li>&#13;
<li>Information on gray codes: <a class="LinkURL" href="https://en.wikipedia.org/wiki/Gray_code"> https://en.wikipedia.org/wiki/Gray_code</a></li>&#13;
<li>Programming MCP230<em>xx</em> devices on the Raspberry Pi: <a class="LinkURL" href="https://learn.adafruit.com/mcp230xx-gpio-expander-on-the-raspberry-pi">https://learn.adafruit.com/mcp230xx-gpio-expander-on-the-raspberry-pi</a></li>&#13;
<li>Wiring MCP23008 library on the Raspberry Pi: <a class="LinkURL" href="http://wiringpi.com/extensions/i2c-mcp23008-mcp23017">http://wiringpi.com/extensions/i2c-mcp23008-mcp23017</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>