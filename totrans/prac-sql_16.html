<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="305" id="Page_305"/>16</span><br/>&#13;
<span class="ChapterTitle">Working with JSON Data</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro"><em>JavaScript Object Notation (JSON)</em> is a widely used text format for storing data in a platform-independent way so it can be shared between computer systems. In this chapter, you’ll learn the structure of JSON as well as how to store and query JSON data types in PostgreSQL. After we explore PostgreSQL’s JSON query operators, we’ll analyze a month’s worth of data about earthquakes.</p>&#13;
<p>The American National Standards Institute (ANSI) SQL standard added syntax definitions for JSON and specified functions for creating and accessing JSON objects in 2016. Major database systems have added JSON support in recent years as well, although implementations vary. PostgreSQL, for example, supports some of the ANSI standard while implementing a number of nonstandard operators. I’ll note which aspects of PostgreSQL’s JSON support are part of standard SQL as we work through exercises.</p>&#13;
<h2 id="h1-501065c16-0001"><span epub:type="pagebreak" title="306" id="Page_306"/>Understanding JSON Structure</h2>&#13;
<p class="BodyFirst">JSON data primarily comprises two structures: an <em>object</em>,  which is an unordered set of name/value pairs, and an <em>array</em>, which is an ordered collection of values. If you’ve used programming languages such as JavaScript, Python, or C#, these aspects of JSON should look familiar.</p>&#13;
<p>Inside an object, we use name/value pairs as a structure for storing and referencing individual data items. The object in its entirety is enclosed within curly brackets, and each name, more often referred to as a <em>key</em>, is enclosed in double quotes, followed by a colon and its corresponding value. The object can encapsulate multiple key/value pairs, separated by commas. Here’s an example using movie information:</p>&#13;
<pre><code>{"title": "The Incredibles", "year": 2004}</code></pre>&#13;
<p>The keys are <code>title</code> and <code>year</code>, and their values are <code>"The Incredibles" </code>and <code>2004</code>. If the value is a string, it goes in double quotes. If it’s a number, a Boolean value, or a <code>null</code>, we omit the quotes. If you’re familiar with the Python language, you’ll recognize this structure as a <em>dictionary</em>.</p>&#13;
<p>An array is an ordered list of values enclosed in square brackets. We separate each value in the array with a comma. For example, we might list movie genres like so:</p>&#13;
<pre><code>["animation", "action"]</code></pre>&#13;
<p>Arrays are common in programming languages, and we’ve used them already in SQL queries. In Python, this structure is called a <em>list</em>.</p>&#13;
<p>We can create many permutations of these structures, including nesting objects and arrays inside each other.  For example, we can create an array of objects or use an array as the value of a key. We can add or omit key/value pairs or create additional arrays of objects without violating a preset schema. This flexibility—in contrast to the strict definition of a SQL table—is both part of the appeal of using JSON as a data store as well as one of the biggest difficulties in working with JSON data.</p>&#13;
<p>As an example, <a href="#listing16-1" id="listinganchor16-1">Listing 16-1</a> shows information about two of my favorite films stored as JSON. The outermost structure is an array with two elements—one object for each film. We know the outermost structure is an array because the entire JSON begins and ends with square brackets.</p>&#13;
<pre><code>[{<span class="CodeAnnotation" aria-label="annotation1">1</span>&#13;
    "title": "The Incredibles",&#13;
    "year": 2004,&#13;
  <span class="CodeAnnotation" aria-label="annotation2">2</span>"rating": {&#13;
        "MPAA": "PG"&#13;
    },&#13;
  <span class="CodeAnnotation" aria-label="annotation3">3</span>"characters": [{&#13;
        "name": "Mr. Incredible",&#13;
        "actor": "Craig T. Nelson"&#13;
<span epub:type="pagebreak" title="307" id="Page_307"/>    }, {&#13;
        "name": "Elastigirl",&#13;
        "actor": "Holly Hunter"&#13;
    }, {&#13;
        "name": "Frozone",&#13;
        "actor": "Samuel L. Jackson"&#13;
    }],&#13;
  <span class="CodeAnnotation" aria-label="annotation4">4</span>"genre": ["animation", "action", "sci-fi"]&#13;
}, {&#13;
    "title": "Cinema Paradiso",&#13;
    "year": 1988,&#13;
    "characters": [{&#13;
        "name": "Salvatore",&#13;
        "actor": "Salvatore Cascio"&#13;
    }, {&#13;
        "name": "Alfredo",&#13;
        "actor": "Philippe Noiret"&#13;
    }],&#13;
    "genre": ["romance", "drama"]&#13;
}]</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-1">Listing 16-1</a>: JSON with information about two films</p>&#13;
<p>Inside the outermost array, each film object is surrounded by curly brackets. The open brace at <span class="CodeAnnotation" aria-label="annotation1">1</span> starts the object for the first film <em>The Incredibles</em>. For both films, we store the <code>title</code> and <code>year</code> as key/value pairs, and they have string and integer values, respectively. The third key, <code>rating</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, has a JSON object for its value. That object contains a single key/value pair showing the film’s rating from the Motion Picture Association of America.</p>&#13;
<p>Here we can see the flexibility JSON affords us as a storage medium. First, if we later wanted to add another country’s rating for the film, we could easily add a second key/value pair to the <code>rating</code> value object. Second, we’re not required to include <code>rating</code>—or any key/value pair—in every film object. In fact, I omitted a <code>rating</code> for <em>Cinema Paradiso</em>. If a particular piece of data isn’t available, in this case a rating, some systems that generate JSON might simply exclude that pair. Other systems might include <code>rating</code> but with a <code>null</code> value. Both are valid, and that flexibility is one of JSON’s advantages: its data definition, or <em>schema</em>, can flex as needed.</p>&#13;
<p>The final two key/value pairs show other ways to structure JSON. For <code>characters</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, the value is an array of objects, with each object surrounded by curly brackets and separated by a comma. The value for <code>genre</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> is an array of strings.</p>&#13;
<h2 id="h1-501065c16-0002">Considering When to Use JSON with SQL</h2>&#13;
<p class="BodyFirst">There are advantages to using <em>NoSQL</em> or <em>document</em> databases that store data in JSON or other text-based data formats, as opposed to the relational tables SQL uses. Document databases are flexible in terms of data definitions. You can redefine a data structure on the fly if needed. Document <span epub:type="pagebreak" title="308" id="Page_308"/>databases are often also used for high-volume applications because they can be scaled by adding servers. On the flip side, you may give up SQL advantages such as easily added constraints that enforce data integrity and support for transactions.</p>&#13;
<p>The arrival of JSON support in SQL has made it possible to enjoy the best of both worlds by adding JSON data as columns in relational tables. The decision to use a SQL or NoSQL database should be multifaceted. PostgreSQL performs favorably relative to NoSQL in terms of speed, but we must also consider the kinds and volume of data being stored, the applications being served, and more.</p>&#13;
<p>That said, some cases where you might want to take advantage of JSON in SQL include the following:</p>&#13;
<ul>&#13;
<li>When users or applications need to arbitrarily create key/value pairs. For example, if tagging a collection of medical research papers, one user might want to add a key to track chemical names, and another user might want a key to track food names.</li>&#13;
<li>When storing related data in a JSON column instead of a separate table. An employees table could have the usual columns for name and contact information plus a JSON column with a flexible collection of key/value pairs that might hold additional attributes that don’t apply to every employee, such as company awards or performance metrics.</li>&#13;
<li>When saving time by analyzing JSON data fetched from other systems without first parsing it into a set of tables.</li>&#13;
</ul>&#13;
<p>Keep in mind that using JSON in PostgreSQL or other SQL databases can also present challenges. Constraints that are trivial to set up on regular SQL tables can be more difficult to set and enforce on JSON data. JSON data can consume more space as key names get repeated in text along with the quotes, commas, and braces that define its structure. Finally, the flexibility of JSON can create issues for the code that interacts with it—whether SQL or another language—if keys unexpectedly disappear or the data type of a value changes.</p>&#13;
<p>Keeping all this in mind, let’s review PostgreSQL’s two JSON data types and load some JSON into a table.</p>&#13;
<h2 id="h1-501065c16-0003">Using json and jsonb Data Types</h2>&#13;
<p class="BodyFirst">PostgreSQL provides two data types for storing JSON. Both allow insertion of valid JSON only—text that includes required elements of the JSON specification, such as open and closing curly brackets around an object, commas separating objects, and proper quoting of keys. If you try to insert invalid JSON, the database will generate an error.</p>&#13;
<p>The main difference between the two is that one stores JSON as text and the other as binary data. The binary implementation is newer to PostgreSQL and generally preferred because it’s faster at querying and has indexing capabilities.</p>&#13;
<p><span epub:type="pagebreak" title="309" id="Page_309"/>The two types are as follows:</p>&#13;
<p class="ListHead"><b><b>json</b></b></p>&#13;
<ol class="none">&#13;
<li>Stores JSON as text, keeping white space and maintaining the order of keys. If a single JSON object contains a particular key more than once (which is valid), the <code>json</code> type will preserve each of the repeated key/value pairs. Finally, each time a database function processes <code>json</code>-stored text, it must parse the object to interpret its structure. This can make reads from the database slower than with the <code>jsonb</code> type. Indexing is not supported. Typically, the <code>json</code> type is useful when an application has duplicate keys or needs to preserve the order of keys.</li>&#13;
</ol>&#13;
<p class="ListHead"><b><b>jsonb</b></b></p>&#13;
<ol class="none">&#13;
<li>Stores JSON in a binary format, removing white space and not maintaining the order of keys. If a single JSON object contains a particular key more than once, the <code>jsonb</code> type will preserve only the last of the key/value pairs. The binary format adds some overhead to writing data to the table, but processing is faster. Indexing is supported.</li>&#13;
</ol>&#13;
<p>Neither <code>json</code> nor <code>jsonb</code> is part of the ANSI SQL standard, which doesn’t specify a JSON data type and leaves it to database makers to decide how to implement support. The PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/datatype-json.html" class="LinkURL">https://www.postgresql.org/docs/current/datatype-json.html</a> recommends using <code>jsonb</code> unless there’s a need to preserve the order of key/value pairs.</p>&#13;
<p>We’ll use <code>jsonb</code> exclusively in the remainder of the chapter, both because of speed considerations but also because many of PostgreSQL’s JSON functions work the same way with both <code>json</code> and <code>jsonb</code>—and there are more functions available for <code>jsonb</code>. We’ll continue by adding the films JSON from <a href="#listing16-1">Listing 16-1</a> to a table and exploring JSON query syntax.</p>&#13;
<h2 id="h1-501065c16-0004">Importing and Indexing JSON Data</h2>&#13;
<p class="BodyFirst">The file <em>films.json</em> in the <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span> folder of the book’s resources at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a> contains a modified form of the JSON in <a href="#listing16-1">Listing 16-1</a>. View the file with a text editor, and you’ll see each film’s JSON object is placed on a single line, with no line breaks between elements. I’ve also removed the outermost square brackets and the comma separating the two film objects. Each remains a valid JSON object:</p>&#13;
<pre><code>{"title": "The Incredibles", "year": 2004, <var>--snip--</var> }&#13;
{"title": "Cinema Paradiso", "year": 1988, <var>--snip--</var> }</code></pre>&#13;
<p>I set up the file this way so that PostgreSQL’s <code>COPY</code> command will interpret each film’s JSON object as a separate row on import, the same way it does when importing a CSV file. The code in <a href="#listing16-2" id="listinganchor16-2">Listing 16-2</a> makes a simple <code>films</code> table with a surrogate primary key and a <code>jsonb</code> column called <code>film</code>.</p>&#13;
<pre><code><span epub:type="pagebreak" title="310" id="Page_310"/>CREATE TABLE films (&#13;
    id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,&#13;
    film jsonb NOT NULL&#13;
);&#13;
&#13;
COPY films (film)&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> FROM <var>C:\YourDirectory</var>\films.json';&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> CREATE INDEX idx_film ON films USING GIN (film);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-2">Listing 16-2</a>: Creating a table to hold JSON data and adding an index</p>&#13;
<p>Note that the <code>COPY</code> statement ends with the <code>FROM</code> clause <span class="CodeAnnotation" aria-label="annotation1">1</span> instead of continuing to include a <code>WITH</code> statement as in previous examples. The reason we no longer need the <code>WITH</code> statement, which we’ve used to specify options for file headers and CSV formatting, is that this file has no header and isn’t delimited. We just want the database to read each line and process it.</p>&#13;
<p>After import, we add an index <span class="CodeAnnotation" aria-label="annotation2">2</span> to the <code>jsonb</code> column using the GIN index type.  We discussed the generalized inverted index (GIN) with full-text search in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>. GIN’s implementation of indexing the location of words or key values within text is particularly suited to JSON data. Note that because index entries point to rows in a table, <code>jsonb</code> column indexing works best when each row contains a relatively small chunk of JSON—as opposed to a table with one row that has a single, enormous JSON value and repeated keys.</p>&#13;
<p>Execute the commands to create and fill the table and add the index. Run <code>SELECT * FROM films;</code> and you should see two rows containing the autogenerated <code>id</code> and the JSON object text. Now you’re ready to explore querying the data using with PostgreSQL’s JSON operators.</p>&#13;
<h2 id="h1-501065c16-0005">Using json and jsonb Extraction Operators</h2>&#13;
<p class="BodyFirst">To retrieve values from our stored JSON, we can use PostgreSQL-specific <em>extraction operators</em>, which return either a JSON object, an element of an array, or an element that exists at a path in the JSON structure we specify. <a href="#table16-1" id="tableanchor16-1">Table 16-1</a> shows the operators and their functions, which can vary based on the data type of the input. Each works with <code>json</code> and <code>jsonb</code> data types.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table16-1">Table 16-1</a>: <code>json</code> and <code>jsonb</code> Extraction Operators</p></figcaption>&#13;
<table id="table-501065c16-0001" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Operator, syntax</b></td>&#13;
<td><b>Function</b></td>&#13;
<td><b>Returns</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><var>json</var><code> -&gt; </code><var>text</var><br/>&#13;
<var>jsonb</var><code> -&gt; </code><var>text</var></td>&#13;
<td>Extracts a key value, specified as text</td>&#13;
<td><code>json</code> or <code>jsonb</code> (matching the input)</td>&#13;
</tr>&#13;
<tr>&#13;
<td><var>json</var><code> -&gt;&gt; </code><var>text</var><br/>&#13;
<var>jsonb</var><code> -&gt;&gt; </code><var>text</var></td>&#13;
<td>Extracts a key value, specified as text</td>&#13;
<td><code>text</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><var>json</var><code> -&gt; </code><var>integer</var><br/>&#13;
<var>jsonb</var><code> -&gt; </code><var>integer</var></td>&#13;
<td>Extracts an array element, specified as an integer denoting its array position</td>&#13;
<td><code>json</code> or <code>jsonb</code> (matching the input)</td>&#13;
</tr>&#13;
<tr>&#13;
<td><var><span epub:type="pagebreak" title="311" id="Page_311"/>json</var><code> -&gt;&gt; </code><var>integer</var><br/>&#13;
<var>jsonb</var><code> -&gt;&gt; </code><var>integer</var></td>&#13;
<td>Extracts an array element, specified as an integer denoting its array position</td>&#13;
<td><code>text</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><var>json</var><code> #&gt; </code><var>text array</var><br/>&#13;
<var>jsonb</var><code> #&gt; </code><var>text array</var></td>&#13;
<td>Extracts a JSON object at a specified path</td>&#13;
<td><code>json</code> or <code>jsonb</code> (matching the input)</td>&#13;
</tr>&#13;
<tr>&#13;
<td><var>json</var><code> #&gt;&gt; </code><var>text array</var><br/>&#13;
<var>jsonb</var><code> #&gt;&gt; </code><var>text array</var></td>&#13;
<td>Extracts a JSON object at a specified path</td>&#13;
<td><code>text</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>Let’s try the operators with our films JSON to learn more about how they vary in function.</p>&#13;
<h3 id="h2-501065c16-0001">Key Value Extraction</h3>&#13;
<p class="BodyFirst">In <a href="#listing16-3" id="listinganchor16-3">Listing 16-3</a> we use the <code>-&gt;</code> and <code>-&gt;&gt;</code> operators followed by text naming the key value to retrieve. In that context, with text input, these are called <em>field extraction operators</em> because they extract a field, or key value, from the JSON. The difference between the two is that <code>-&gt;</code> returns the key value as JSON in the same type as stored, and <code>-&gt;&gt;</code> returns the key value as text.</p>&#13;
<pre><code>SELECT id, film -&gt;<span class="CodeAnnotation" aria-label="annotation1">1</span> 'title' AS title&#13;
FROM films&#13;
ORDER BY id;&#13;
&#13;
SELECT id, film -&gt;&gt;<span class="CodeAnnotation" aria-label="annotation2">2</span> 'title' AS title&#13;
FROM films&#13;
ORDER BY id;&#13;
&#13;
SELECT id, film -&gt;<span class="CodeAnnotation" aria-label="annotation3">3</span> 'genre' AS genre&#13;
FROM films&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-3">Listing 16-3</a>: Retrieving a JSON key value with field extraction operators</p>&#13;
<p>In the <code>SELECT</code> list, we specify our JSON column name followed by the operator and the key name in single quotes. In the first example, the syntax <code>-&gt;</code> <code>'title'</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> returns the value of the <code>title</code> key as JSON in the same data type as stored, <code>jsonb</code>. Run the first query, and you should see the output like this:</p>&#13;
<pre><code>id       title&#13;
-- -----------------&#13;
 1 "The Incredibles"&#13;
 2 "Cinema Paradiso"</code></pre>&#13;
<p>In pgAdmin, the data type listed in the <code>title</code> column header should indicate <code>jsonb</code>, and the film titles remain quoted, as they are in the JSON object.</p>&#13;
<p><span epub:type="pagebreak" title="312" id="Page_312"/>Changing the field extraction operator to <code>-&gt;&gt;</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> returns the film titles as text instead:</p>&#13;
<pre><code>id       title&#13;
-- ---------------&#13;
 1 The Incredibles&#13;
 2 Cinema Paradiso</code></pre>&#13;
<p>Finally, we’ll return an array. In our films JSON, the value of the key <code>genre</code> is an array of values. Using the field extraction operator <code>-&gt;</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> returns the array as <code>jsonb</code>:</p>&#13;
<pre><code>id          genre&#13;
-- ---------------------------------&#13;
 1 ["animation", "action", "sci-fi"]&#13;
 2 ["romance", "drama"]</code></pre>&#13;
<p>If we used <code>-&gt;&gt;</code> here, we’d return the arrays as text. Let’s look at how to extract elements from an array.</p>&#13;
<h3 id="h2-501065c16-0002">Array Element Extraction</h3>&#13;
<p class="BodyFirst">To retrieve a specific value from an array, we follow the <code>-&gt;</code> and <code>-&gt;&gt;</code> operators with an integer specifying the value’s position, or <em>index</em>, in the array. We call these <em>element extraction operators</em> because they retrieve an element from a JSON array. As with field extraction, <code>-&gt;</code> returns the value as JSON in the same type as stored, and <code>-&gt;&gt;</code> returns it as text.</p>&#13;
<p><a href="#listing16-4" id="listinganchor16-4">Listing 16-4</a> shows four examples using the array values of <code>"genre"</code>.</p>&#13;
<pre><code>SELECT id, film -&gt; 'genre' -&gt; 0<span class="CodeAnnotation" aria-label="annotation1">1</span>  AS genres&#13;
FROM films&#13;
ORDER BY id;&#13;
&#13;
SELECT id, film -&gt; 'genre' -&gt; -1<span class="CodeAnnotation" aria-label="annotation2">2</span> AS genres&#13;
FROM films&#13;
ORDER BY id;&#13;
&#13;
SELECT id, film -&gt; 'genre' -&gt; 2<span class="CodeAnnotation" aria-label="annotation3">3</span> AS genres&#13;
FROM films&#13;
ORDER BY id;&#13;
&#13;
SELECT id, film -&gt; 'genre' -&gt;&gt; 0<span class="CodeAnnotation" aria-label="annotation4">4</span> AS genres&#13;
FROM films&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-4">Listing 16-4</a>: Retrieving a JSON array value with element extraction operators</p>&#13;
<p>We must first retrieve the array value from the key as JSON and then retrieve the desired element from the array. In the first example, we specify the JSON column <code>film</code>, followed by the field extraction operator <code>-&gt;</code> and the <code>genre</code> key name in single quotes. This returns the <code>genre</code> value as <code>jsonb</code>. We follow the key name with <code>-&gt;</code> and the integer <code>0</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to get the first element.</p>&#13;
<p><span epub:type="pagebreak" title="313" id="Page_313"/>Why not use <code>1</code> for the first value in the array? In many languages, including Python and JavaScript, index values start at zero, and that’s also true when accessing JSON arrays with SQL.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	SQL arrays have a different ordering scheme than JSON arrays in PostgreSQL. The first element in a SQL array is at position <code>1</code>; in a JSON array, the first element is at position <code>0</code>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Run the first query, and your results should look like this, showing the first element in each film’s <code>genre</code> array, returned as <code>jsonb</code>:</p>&#13;
<pre><code>id   genres&#13;
-- -----------&#13;
 1 "animation"&#13;
 2 "romance"</code></pre>&#13;
<p>We can also access the last element of the array, even if we aren’t sure of its index, because the number of genres per film can vary. We count backward from the end of the list using a negative index number. Supplying <code>-1</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> tells <code>-&gt;</code> to get the first element from the end of the list:</p>&#13;
<pre><code>id  genres&#13;
-- --------&#13;
 1 "sci-fi"&#13;
 2 "drama"</code></pre>&#13;
<p>We can count back further if we want—an index of <code>-2</code> will get the next-to-last element.</p>&#13;
<p>Note that PostgreSQL won’t return an error if there’s no element at the supplied index position; it will simply return a <code>NULL</code> for that row. For example, if we supply <code>2</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> for the index, we see results for one of our films and a <code>NULL</code> for the other:</p>&#13;
<pre><code>id  genres&#13;
-- --------&#13;
 1 "sci-fi"&#13;
 2</code></pre>&#13;
<p>We get a <code>NULL</code> back for <em>Cinema Paradiso</em> because it has only two elements in its <code>genre</code> value array, and index <code>2</code> (since we count up starting with zero) represents the third element. Later in the chapter, we’ll learn how to count array lengths.</p>&#13;
<p>Finally, changing the element extraction operator to <code>-&gt;&gt;</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> returns the desired element as a <code>text</code> data type rather than JSON:</p>&#13;
<pre><code>id  genres&#13;
-- ---------&#13;
 1 animation&#13;
 2 romance</code></pre>&#13;
<p><span epub:type="pagebreak" title="314" id="Page_314"/>This is the same pattern as we saw when extracting key values: <code>-&gt;</code> returns a JSON data type, and <code>-&gt;&gt;</code> returns text.</p>&#13;
<h3 id="h2-501065c16-0003">Path Extraction</h3>&#13;
<p class="BodyFirst">Both <code>#&gt;</code> and <code>#&gt;&gt;</code> are <em>path extraction operators</em> that return an object located at a JSON path. A path is a series of keys or array indices that lead to the location of a value. In our example JSON, it might be just the <code>title</code> key if we want the name of the film. Or it could be more complex, such as the <code>characters</code> key followed by an index value of <code>1</code>, then the <code>actor</code> key; this would provide the path to the name of the actor at index <code>1</code>. The <code>#&gt;</code> path extraction operator returns a JSON data type matching the stored data, and <code>#&gt;&gt;</code> returns text.</p>&#13;
<p>Consider the MPAA rating for the film <em>The Incredibles</em>, which appears in our JSON like this:</p>&#13;
<pre><code>"rating": {&#13;
    "MPAA": "PG"&#13;
}</code></pre>&#13;
<p>The structure is a key named <code>rating</code> with an object for its value; inside that object is a key/value pair with <code>MPAA</code> as the key name. Thus, the path to the film’s MPAA rating begins with the <code>rating</code> key and ends with the <code>MPAA</code> key. To denote the path’s elements, we use the PostgreSQL string syntax for arrays, creating a comma-separated list inside curly brackets and single quotes. We then feed that string to the path extraction operators. <a href="#listing16-5" id="listinganchor16-5">Listing 16-5</a> shows three examples of setting paths.</p>&#13;
<pre><code>SELECT id, film #&gt; '{rating, MPAA}'<span class="CodeAnnotationCode" aria-label="annotation1">1</span> AS mpaa_rating&#13;
FROM films&#13;
ORDER BY id;&#13;
&#13;
SELECT id, film #&gt; '{characters, 0, name}'<span class="CodeAnnotation" aria-label="annotation2">2</span> AS name&#13;
FROM films&#13;
ORDER BY id;&#13;
&#13;
SELECT id, film #&gt;&gt; '{characters, 0, name}'<span class="CodeAnnotation" aria-label="annotation3">3</span> AS name&#13;
FROM films&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-5">Listing 16-5</a>: Retrieving a JSON key value with path extraction operators</p>&#13;
<p>To get each film’s MPAA rating, we specify the path in an array: <code>{rating, MPAA}</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> with each item separated by commas. Run the query, and you should see these results:</p>&#13;
<pre><code>id mpaa_rating&#13;
-- -----------&#13;
 1 "PG"&#13;
 2</code></pre>&#13;
<p><span epub:type="pagebreak" title="315" id="Page_315"/>The query returns the PG rating for <em>The Incredibles</em> and a <code>NULL</code> for <em>Cinema Paradiso</em> because, in our data, the latter film has no MPAA rating present.</p>&#13;
<p>The second example works with the array of <code>characters</code>, which in our JSON looks like this:</p>&#13;
<pre><code>"characters": [{&#13;
    "name": "Salvatore",&#13;
    "actor": "Salvatore Cascio"&#13;
}, {&#13;
    "name": "Alfredo",&#13;
    "actor": "Philippe Noiret"&#13;
}]</code></pre>&#13;
<p>The <code>characters</code> array shown is for the second movie, but both films have a similar structure. Array objects each represent a character and the name and the actor who played them. To locate the name of the first character in the array, we specify a path <span class="CodeAnnotation" aria-label="annotation2">2</span> that starts at the <code>characters</code> key, continues to the first element of the array using the index <code>0</code>, and ends at the <code>name</code> key. The query results should look like this:</p>&#13;
<pre><code>id       name&#13;
-- ----------------&#13;
 1 "Mr. Incredible"&#13;
 2 "Salvatore"</code></pre>&#13;
<p>The <code>#&gt;</code> operator returns results as a JSON data type, in our case <code>jsonb</code>. If we want the results as text, we use <code>#&gt;&gt;</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> with the same path.</p>&#13;
<h3 id="h2-501065c16-0004">Containment and Existence</h3>&#13;
<p class="BodyFirst">The final collection of operators we’ll explore performs two kinds of evaluations. The first concerns <em>containment</em> and checks whether a specified JSON value contains a second specified JSON value. The second tests for <em>existence</em>: whether a string of text within a JSON object exists as a top-level key (or as an element of an array nested inside a deeper object). Both kinds of operators return a Boolean value, which means we can use them in a <code>WHERE</code> clause to filter query results.</p>&#13;
<p>This set of operators works only with the <code>jsonb</code> data type—another good reason to favor <code>jsonb</code> over <code>json</code>—and can make use of our GIN index for efficient searching. <a href="#table16-2" id="tableanchor16-2">Table 16-2</a> lists the operators with their syntax and function.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table16-2">Table 16-2</a>: <code>jsonb</code> Containment and Existence Operators</p></figcaption>&#13;
<table id="table-501065c16-0002" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Operator, syntax</b></td>&#13;
<td><b>Function</b></td>&#13;
<td><b>Returns</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><var>jsonb</var><code> @&gt; </code><var>jsonb</var></td>&#13;
<td>Tests whether the first JSON value contains the second JSON value</td>&#13;
<td><code>boolean</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><var>jsonb</var><code> &lt;@ </code><var>jsonb</var></td>&#13;
<td>Tests whether the second JSON value contains the first JSON value</td>&#13;
<td><code>boolean</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><var><span epub:type="pagebreak" title="316" id="Page_316"/>jsonb</var><code> ? </code><var>text</var></td>&#13;
<td>Tests whether the text exists as a top-level (not nested) key or an array value</td>&#13;
<td><code>boolean</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><var>jsonb</var><code> ?| </code><var>text array</var></td>&#13;
<td>Tests whether any of the text elements in the array exist as a top-level (not nested) key or as an array value</td>&#13;
<td><code>boolean</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><var>jsonb</var><code> ?&amp; </code><var>text array</var></td>&#13;
<td>Tests whether all of the text elements in the array exist as a top-level (not nested) key or as an array value</td>&#13;
<td><code>boolean</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<h4 id="h3-501065c16-0001">Using Containment Operators</h4>&#13;
<p class="BodyFirst">In <a href="#listing16-6" id="listinganchor16-6">Listing 16-6</a>, we use <code>@&gt;</code> to evaluate whether one JSON value contains a second JSON value.</p>&#13;
<pre><code>SELECT id, film -&gt;&gt; 'title' AS title,&#13;
       film @&gt;<span class="CodeAnnotation" aria-label="annotation1">1</span> '{"title": "The Incredibles"}'::jsonb AS is_incredible&#13;
FROM films&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-6">Listing 16-6</a>: Demonstrating the <code>@&gt;</code> containment operator</p>&#13;
<p>In our <code>SELECT</code> list, we check whether the JSON stored in the <code>film</code> column in each row contains the key/value pair for <em>The Incredibles</em>. We use the <code>@&gt;</code> containment operator <span class="CodeAnnotation" aria-label="annotation1">1</span> in an expression that generates a column with the Boolean result <code>true</code> if <code>film</code> contains <code>"title": "The Incredibles"</code>. We give the name of our JSON column, <code>film</code>, then the <code>@&gt;</code> operator, and then a string (cast to <code>jsonb</code>) specifying the key/value pair. In our <code>SELECT</code> list, we also return the text of the film title as a column. Running the query should produce these results:</p>&#13;
<pre><code>id      title      is_incredible&#13;
-- --------------- -------------&#13;
 1 The Incredibles  true&#13;
 2 Cinema Paradiso  false</code></pre>&#13;
<p>As expected, the expression evaluates to <code>true</code> for <em>The Incredibles</em> and <code>false</code> for <em>Cinema Paradiso</em>.</p>&#13;
<p>Because the expression evaluates to a Boolean result, we can use it in a query’s <code>WHERE</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> clause, as shown in <a href="#listing16-7" id="listinganchor16-7">Listing 16-7</a>.</p>&#13;
<pre><code>SELECT film -&gt;&gt; 'title' AS title,&#13;
       film -&gt;&gt; 'year' AS year&#13;
FROM films&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> WHERE film @&gt; '{"title": "The Incredibles"}'::jsonb;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-7">Listing 16-7</a>: Using a containment operator in a <code>WHERE</code> clause</p>&#13;
<p><span epub:type="pagebreak" title="317" id="Page_317"/>Here we again check that the JSON in the <code>film</code> column contains the key/value pair for the title of <em>The Incredibles</em>. By placing the evaluation in a <code>WHERE</code> clause, the query should return just the row where the expression returns <code>true</code>:</p>&#13;
<pre><code>     title      year&#13;
--------------- ----&#13;
The Incredibles 2004</code></pre>&#13;
<p>Finally, in <a href="#listing16-8" id="listinganchor16-8">Listing 16-8</a>, we flip the order of evaluation to check whether the key/value pair specified is contained within the <code>film</code> column.</p>&#13;
<pre><code>SELECT film -&gt;&gt; 'title' AS title,&#13;
       film -&gt;&gt; 'year' AS year&#13;
FROM films&#13;
WHERE '{"title": "The Incredibles"}'::jsonb &lt;@<span class="CodeAnnotation" aria-label="annotation3">3</span> film;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-8">Listing 16-8</a>: Demonstrating the <code>&lt;@</code> containment operator</p>&#13;
<p>Here we use the <code>&lt;@</code> operator <span class="CodeAnnotation" aria-label="annotation3">3</span> instead of <code>@&gt;</code> to flip the order of evaluation. This expression also evaluates to <code>true</code>, returning the same result as the previous query.</p>&#13;
<h4 id="h3-501065c16-0002">Using Existence Operators</h4>&#13;
<p class="BodyFirst">Next, in <a href="#listing16-9" id="listinganchor16-9">Listing 16-9</a>, we explore three existence operators. These check whether the text we supply exists as a top-level key or as an element of an array. All return a Boolean value.</p>&#13;
<pre><code>SELECT film -&gt;&gt; 'title' AS title&#13;
FROM films&#13;
WHERE film ?<span class="CodeAnnotation" aria-label="annotation1">1</span> 'rating';&#13;
&#13;
SELECT film -&gt;&gt; 'title' AS title,&#13;
       film -&gt;&gt; 'rating' AS rating,&#13;
       film -&gt;&gt; 'genre' AS genre&#13;
FROM films&#13;
WHERE film ?|<span class="CodeAnnotation" aria-label="annotation2">2</span> '{rating, genre}';&#13;
&#13;
SELECT film -&gt;&gt; 'title' AS title,&#13;
       film -&gt;&gt; 'rating' AS rating,&#13;
       film -&gt;&gt; 'genre' AS genre&#13;
FROM films&#13;
WHERE film ?&amp;<span class="CodeAnnotation" aria-label="annotation3">3</span> '{rating, genre}';</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-9">Listing 16-9</a>: Demonstrating existence operators</p>&#13;
<p>The <code>?</code> operator checks for the existence of a single key or array element. In the first query’s <code>WHERE</code> clause, we give the <code>film</code> column, the <code>?</code> operator <span class="CodeAnnotation" aria-label="annotation1">1</span>, and then the string <code>rating</code>. This syntax says, “In each row, does <code>rating</code> exist as a key in the JSON in the <code>film</code> column?” When we run the query, the results show the one film that has a <code>rating</code> key, <em>The Incredibles</em>.</p>&#13;
<p><span epub:type="pagebreak" title="318" id="Page_318"/>The <code>?|</code> and <code>?&amp;</code> operators act as <code>or</code> and <code>and</code>. For example, using <code>?|</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> tests whether either <code>rating</code> or <code>genre</code> exist as top-level keys. Running that second query returns both films, because both have at least one of those keys. Using <code>?&amp;</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, however, tests whether both <code>rating</code> and <code>genre</code> exist as keys, and that’s true for only <em>The Incredibles</em>.</p>&#13;
<p>All these operators provide options for fine-tuning your exploration of your JSON data. Now, let’s use some of them on a larger dataset.</p>&#13;
<h2 id="h1-501065c16-0006">Analyzing Earthquake Data</h2>&#13;
<p class="BodyFirst">In this section, we’ll analyze a collection of JSON data about earthquakes compiled by the US Geological Survey, an agency of the US Department of the Interior that monitors natural phenomenon including volcanoes, landslides, and water quality. The USGS uses a network of seismographs that record the earth’s vibrations, compiling data on each seismic event’s location and intensity. Minor earthquakes occur around the world many times a day; the big ones are less frequent but potentially devastating.</p>&#13;
<p>For our exercise, I fetched a month’s worth of JSON-formatted earthquake data from a USGS <em>application programming interface</em>, better known as an API. An <em>API</em> is a resource for transmitting data and commands between computers, and JSON is often used for APIs. You’ll find the data in the file <em>earthquakes.json</em> in the folder for this chapter included in the book’s resources.</p>&#13;
<h3 id="h2-501065c16-0005">Exploring and Loading the Earthquake Data</h3>&#13;
<p class="BodyFirst"><a href="#listing16-10" id="listinganchor16-10">Listing 16-10</a> shows the data structure for each earthquake record in the file, along with a selection of its key/value pairs (your <em>Chapter_16.sql</em> file has the nonsnipped version).</p>&#13;
<pre><code>{&#13;
    "type": "Feature", <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
    "properties":<span class="CodeAnnotationCode" aria-label="annotation2">2</span> {&#13;
        "mag": 1.44,&#13;
        "place": "134 km W of Adak, Alaska",&#13;
        "time": 1612051063470,&#13;
        "updated": 1612139465880,&#13;
        "tz": null,&#13;
        <var>--snip--</var>&#13;
        "felt": null,&#13;
        "cdi": null,&#13;
        "mmi": null,&#13;
        "alert": null,&#13;
        "status": "reviewed",&#13;
        "tsunami": 0,&#13;
        "sig": 32,&#13;
        "net": "av",&#13;
        "code": "91018173",&#13;
        "ids": ",av91018173,",&#13;
        "sources": ",av,",&#13;
        "types": ",origin,phase-data,",&#13;
<span epub:type="pagebreak" title="319" id="Page_319"/>        "nst": 10,&#13;
        "dmin": null,&#13;
        "rms": 0.15,&#13;
        "gap": 174,&#13;
        "magType": "ml",&#13;
        "type": "earthquake",&#13;
        "title": "M 1.4 - 134 km W of Adak, Alaska"&#13;
    },&#13;
    "geometry":<span class="CodeAnnotationCode" aria-label="annotation3">3</span> {&#13;
        "type": "Point",&#13;
        "coordinates": [-178.581, 51.8418333333333, 22.48]&#13;
    },&#13;
    "id": "av91018173"&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-10">Listing 16-10</a>: JSON with data on one earthquake</p>&#13;
<p>This data is in <em>GeoJSON</em> format, a JSON-based specification for spatial data. GeoJSON will include one or more <code>Feature</code> objects, denoted by inclusion of the key/value pair <code>"type": "Feature"</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. Each <code>Feature</code> describes a single spatial object and contains both descriptive attributes (such as event time or related codes) under <code>properties</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> plus a <code>geometry</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> key that includes the coordinates of the spatial object. In our data, each <code>geometry</code> is a Point, a simple feature with the coordinates of one earthquake’s longitude, latitude, and depth in kilometers. We discussed Points and simple features in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span> when working with PostGIS; GeoJSON incorporates it and other spatial simple features. You can read more about the GeoJSON specification at <a href="https://geojson.org/" class="LinkURL">https://geojson.org/</a> and see definitions of the keys in the USGS documentation at <a href="https://earthquake.usgs.gov/data/comcat/data-eventterms.php/" class="LinkURL">https://earthquake.usgs.gov/data/comcat/data-eventterms.php/</a>.</p>&#13;
<p>Let’s load our data into a table called <code>earthquakes</code> using the code in <a href="#listing16-11" id="listinganchor16-11">Listing 16-11</a>.</p>&#13;
<pre><code>CREATE TABLE earthquakes (&#13;
    id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,&#13;
    earthquake jsonb<span class="CodeAnnotation" aria-label="annotation1">1</span> NOT NULL&#13;
);&#13;
&#13;
COPY earthquakes (earthquake)&#13;
FROM <var>C:\YourDirectory</var>\earthquakes.json';&#13;
&#13;
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> CREATE INDEX idx_earthquakes ON earthquakes USING GIN (earthquake);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-11">Listing 16-11</a>: Creating and loading an earthquakes table</p>&#13;
<p>As with our <code>films</code> table, we use <code>COPY</code> to copy the data into a single <code>jsonb</code> column <span class="CodeAnnotation" aria-label="annotation1">1</span> and add a GIN index <span class="CodeAnnotation" aria-label="annotation2">2</span>.  Running <code>SELECT * FROM earthquakes;</code> should return 12,899 rows. Now let’s see what we can learn from the data.</p>&#13;
<h3 id="h2-501065c16-0006">Working with Earthquake Times</h3>&#13;
<p class="BodyFirst">The <code>time</code> key/value pair represents the moment the earthquake occurred. In <a href="#listing16-12" id="listinganchor16-12">Listing 16-12</a>, we retrieve the value of <code>time</code> using a path extraction operator.</p>&#13;
<pre><code><span epub:type="pagebreak" title="320" id="Page_320"/>SELECT id, earthquake #&gt;&gt; '{properties, time}'<span class="CodeAnnotationCode" aria-label="annotation1">1</span> AS time&#13;
FROM earthquakes&#13;
ORDER BY id LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-12">Listing 16-12</a>: Retrieving the earthquake time</p>&#13;
<p>In the <code>SELECT</code> list, we give the <code>earthquake</code> column followed by a <code>#&gt;&gt;</code> path extraction operator and the path <span class="CodeAnnotation" aria-label="annotation1">1</span> to the time value denoted as an array. The <code>#&gt;&gt;</code> operator will return our value as text. Running the query should return five rows:</p>&#13;
<pre><code>id     time&#13;
-- -------------&#13;
 1 1612137592990&#13;
 2 1612137479762&#13;
 3 1612136740672&#13;
 4 1612136207600&#13;
 5 1612135893550</code></pre>&#13;
<p>If those values don’t look like times to you, that’s not surprising. By default, the USGS represents time as milliseconds since the Unix epoch at 00:00 UTC on January 1, 1970. That’s a variant of the standard epoch time we covered in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>, which measures seconds since the epoch. We can convert this USGS <code>time</code> value to something understandable using <code>to_timestamp()</code> and a little math, as shown in <a href="#listing16-13" id="listinganchor16-13">Listing 16-13</a>.</p>&#13;
<pre><code>SELECT id, earthquake #&gt;&gt; '{properties, time}' as time,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> to_timestamp(&#13;
           (earthquake #&gt;&gt; '{properties, time}')::bigint / 1000<span class="CodeAnnotation" aria-label="annotation2">2</span>&#13;
                   ) AS time_formatted&#13;
FROM earthquakes&#13;
ORDER BY id LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-13">Listing 16-13</a>: Converting the <code>time</code> value to a timestamp</p>&#13;
<p>Inside the parentheses of the <code>to_timestamp()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function, we repeat the code to extract the <code>time</code> value. The <code>to_timestamp()</code> function requires a number representing seconds, but the extracted value is text and in milliseconds, so we also cast the extracted text to <code>bigint</code> and divide by 1,000 <span class="CodeAnnotation" aria-label="annotation2">2</span> to convert it to seconds.</p>&#13;
<p>On my machine, the query generates the following results showing the extracted <code>time</code> value and its converted timestamp (your values will vary depending on your PostgreSQL server’s time zone, so <code>time_formatted</code> will show when the earthquake occurred in your server’s time zone time):</p>&#13;
<pre><code>id     time          time_formatted&#13;
-- ------------- ----------------------&#13;
 1 1612137592990 2021-01-31 18:59:52-05&#13;
 2 1612137479762 2021-01-31 18:57:59-05&#13;
 3 1612136740672 2021-01-31 18:45:40-05&#13;
 4 1612136207600 2021-01-31 18:36:47-05&#13;
 5 1612135893550 2021-01-31 18:31:33-05</code></pre>&#13;
<p><span epub:type="pagebreak" title="321" id="Page_321"/>Now that we have an understandable timestamp, let’s find the oldest and newest earthquake times using the <code>min()</code> and <code>max()</code> aggregate functions in <a href="#listing16-14" id="listinganchor16-14">Listing 16-14</a>.</p>&#13;
<pre><code>SELECT min<span class="CodeAnnotation" aria-label="annotation1">1</span>(to_timestamp(&#13;
              (earthquake #&gt;&gt; '{properties, time}')::bigint / 1000&#13;
                          )) AT TIME ZONE 'UTC'<span class="CodeAnnotation" aria-label="annotation2">2</span> AS min_timestamp,&#13;
       max<span class="CodeAnnotation" aria-label="annotation3">3</span>(to_timestamp(&#13;
              (earthquake #&gt;&gt; '{properties, time}')::bigint / 1000&#13;
                          )) AT TIME ZONE 'UTC' AS max_timestamp&#13;
FROM earthquakes;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-14">Listing 16-14</a>: Finding the minimum and maximum earthquake times</p>&#13;
<p>We place <code>to_timestamp()</code> and our milliseconds-to-seconds conversion inside both the <code>min()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>max()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> functions in our <code>SELECT</code> list. This time, we add the keywords <code>AT TIME ZONE 'UTC'</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> after both functions; regardless of our server time zone settings, the results will display the timestamps in UTC, as USGS records them. Your results should look like this:</p>&#13;
<pre><code>   min_timestamp       max_timestamp&#13;
------------------- -------------------&#13;
2021-01-01 00:01:39 2021-01-31 23:59:52</code></pre>&#13;
<p>This collection of earthquakes spans a month—from early morning January 1, 2021, through the end of day on January 31. That’s helpful context as we continue to dig for usable information.</p>&#13;
<h3 id="h2-501065c16-0007">Finding the Largest and Most-Reported Earthquakes</h3>&#13;
<p class="BodyFirst">Next, we’ll look at two data points that measure an earthquake’s size and the degree to which citizens reported feeling it and apply JSON extraction techniques to simple sorting of results.</p>&#13;
<h4 id="h3-501065c16-0003">Extracting by Magnitude</h4>&#13;
<p class="BodyFirst">The USGS reports each earthquake’s magnitude in the <code>mag</code> key, beneath <code>properties</code>. Magnitude, according to the USGS, is a number representing the size of an earthquake at its source. Its scale is logarithmic: a magnitude 4 earthquake has seismic waves whose amplitude is about 10 times bigger than a quake with a magnitude of 3. With that context, let’s find the five largest earthquakes in our data using the code in <a href="#listing16-15" id="listinganchor16-15">Listing 16-15</a>.</p>&#13;
<pre><code>SELECT earthquake #&gt;&gt; '{properties, place}'<span class="CodeAnnotationCode" aria-label="annotation1">1</span> AS place,&#13;
       to_timestamp((earthquake #&gt;&gt; '{properties, time}')::bigint / 1000)&#13;
           AT TIME ZONE 'UTC' AS time,&#13;
       (earthquake #&gt;&gt; '{properties, mag}')::numeric AS magnitude&#13;
FROM earthquakes&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> ORDER BY (earthquake #&gt;&gt; '{properties, mag}')::numeric<span class="CodeAnnotation" aria-label="annotation3">3</span> DESC NULLS LAST&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-15">Listing 16-15</a>: Finding the five earthquakes with the largest magnitude</p>&#13;
<p><span epub:type="pagebreak" title="322" id="Page_322"/>We again use path extraction operators to retrieve our desired elements, including values for <code>place</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>mag</code>. To show the largest five in our results, we add an <code>ORDER BY</code> clause <span class="CodeAnnotation" aria-label="annotation2">2</span> with <code>mag</code>. We cast the value to numeric <span class="CodeAnnotation" aria-label="annotation3">3</span> here and in the <code>SELECT</code> because we want to display and sort the value as a number rather than as text. We also add the <code>DESC NULLS LAST</code> keywords, which sorts the results in descending order and places <code>NULL</code> values (of which there are two) last. Your results should look like this:</p>&#13;
<pre><code>                place                        time         magnitude&#13;
------------------------------------- ------------------- ---------&#13;
211 km SE of Pondaguitan, Philippines 2021-01-21 12:23:04         7&#13;
South Shetland Islands                2021-01-23 23:36:50       6.9&#13;
30 km SSW of Turt, Mongolia           2021-01-11 21:32:59       6.7&#13;
28 km SW of Pocito, Argentina         2021-01-19 02:46:21       6.4&#13;
Kermadec Islands, New Zealand         2021-01-08 00:28:50       6.3</code></pre>&#13;
<p>The largest, of magnitude 7, was located beneath the ocean southeast of the small city of Pondaguitan in the Philippines. The second was in the Antarctic near the South Shetland Islands.</p>&#13;
<h4 id="h3-501065c16-0004">Extracting by Citizen Reports</h4>&#13;
<p class="BodyFirst">The USGS operates a Did You Feel It? website at <a href="https://earthquake.usgs.gov/data/dyfi/" class="LinkURL">https://earthquake.usgs.gov/data/dyfi/</a> where people can report their earthquake experiences. Our JSON includes the number of reports for each earthquake under the key <code>felt</code>, beneath <code>properties</code>. Let’s see which earthquakes in our data generated the most reports using the code in <a href="#listing16-16" id="listinganchor16-16">Listing 16-16</a>.</p>&#13;
<pre><code>SELECT earthquake #&gt;&gt; '{properties, place}' AS place,&#13;
       to_timestamp((earthquake #&gt;&gt; '{properties, time}')::bigint / 1000)&#13;
           AT TIME ZONE 'UTC' AS time,&#13;
       (earthquake #&gt;&gt; '{properties, mag}')::numeric AS magnitude,&#13;
       (earthquake #&gt;&gt; '{properties, felt}')::integer<span class="CodeAnnotation" aria-label="annotation1">1</span> AS felt&#13;
FROM earthquakes&#13;
ORDER BY (earthquake #&gt;&gt; '{properties, felt}')::integer<span class="CodeAnnotation" aria-label="annotation2">2</span> DESC NULLS LAST&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-16">Listing 16-16</a>: Finding earthquakes with the most Did You Feel It? reports</p>&#13;
<p>Structurally, this query is similar to <a href="#listing16-15">Listing 16-15</a> that found the largest quakes. We add a path extraction operator for the <code>felt</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> key, casting the returned text value to an <code>integer</code> type. We cast to <code>integer</code> so the extracted text is treated as a number for sorting and display. Finally, we place the extraction code in <code>ORDER BY</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, using <code>NULLS LAST</code> because there are many earthquakes with no reports and we want those to appear last in the list. You should see these results:</p>&#13;
<pre><code>          place                  time         magnitude felt&#13;
------------------------- ------------------- --------- -----&#13;
4km SE of Aromas, CA      2021-01-17 04:01:27       4.2 19907&#13;
2km W of Concord, CA      2021-01-14 19:18:10      3.63  5101&#13;
<span epub:type="pagebreak" title="323" id="Page_323"/>10km NW of Pinnacles, CA  2021-01-02 14:42:23      4.32  3076&#13;
2km W of Willowbrook, CA  2021-01-20 16:31:58      3.52  2086&#13;
3km NNW of Santa Rosa, CA 2021-01-19 04:22:20      2.68  1765</code></pre>&#13;
<p>The top five are in California, which makes sense. Did You Feel It? is a US government-run system, so we’d expect more US reports—particularly in earthquake-prone California. Also, some of the largest quakes in our data occurred beneath oceans or in remote regions. The quake with more than 19,900 reports was moderate, but its nearness to cities meant more chance for people to notice it.</p>&#13;
<h3 id="h2-501065c16-0008">Converting Earthquake JSON to Spatial Data</h3>&#13;
<p class="BodyFirst">Our JSON data has longitude and latitude values for each earthquake, meaning we can perform spatial analysis using the GIS techniques discussed in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>. For example, we’ll  use a PostGIS distance function to locate earthquakes that occurred within 50 miles from a city. First, though, we must convert the coordinates stored in JSON to a PostGIS data type.</p>&#13;
<p>The longitude and latitude values are found in the array of the <code>coordinates</code> key, under <code>geometry</code>. Here’s an example:</p>&#13;
<pre><code>    "geometry": {&#13;
        "type": "Point",&#13;
        "coordinates": [-178.581, 51.8418333333333, 22.48]&#13;
    }</code></pre>&#13;
<p>The first coordinate, at position <code>0</code> in the array, represents longitude; the second, at position <code>1</code>, is latitude. The third value denotes depth in kilometers, which we won’t use. To extract these elements as text, we make use of a <code>#&gt;&gt;</code> path operator, as in <a href="#listing16-17" id="listinganchor16-17">Listing 16-17</a>.</p>&#13;
<pre><code>SELECT id,&#13;
       earthquake #&gt;&gt; '{geometry, coordinates}' AS coordinates,&#13;
       earthquake #&gt;&gt; '{geometry, coordinates, 0}' AS longitude,&#13;
       earthquake #&gt;&gt; '{geometry, coordinates, 1}' AS latitude&#13;
FROM earthquakes&#13;
ORDER BY id&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-17">Listing 16-17</a>: Extracting the earthquake’s location data</p>&#13;
<p>The query should return five rows:</p>&#13;
<pre><code>id           coordinates             longitude    latitude&#13;
-- -------------------------------- ------------ ----------&#13;
 1 [-122.852, 38.8228333, 2.48]     -122.852     38.8228333&#13;
 2 [-148.3859, 64.2762, 16.2]       -148.3859    64.2762&#13;
 3 [-152.489, 59.0143, 73]          -152.489     59.0143&#13;
 4 [-115.82, 32.7493333, 9.85]      -115.82      32.7493333&#13;
 5 [-115.6446667, 33.1711667, 5.89] -115.6446667 33.1711667</code></pre>&#13;
<p><span epub:type="pagebreak" title="324" id="Page_324"/>A quick visual compare of our result to the JSON <code>longitude</code> and <code>latitude</code> values tells us we’ve extracted the values properly. Next, we’ll use a PostGIS function to convert those values to a Point in the <code>geography</code> data type.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Your <code>analysis</code> database must have PostGIS enabled for this part of the chapter. If you skipped <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>, you can enable PostGIS by running <code>CREATE EXTENSION postgis;</code> in pgAdmin.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p><a href="#listing16-18" id="listinganchor16-18">Listing 16-18</a> generates a Point of type <code>geography</code> for each earthquake, which we can use as input for PostGIS spatial functions.</p>&#13;
<pre><code>SELECT ST_SetSRID(&#13;
         ST_MakePoint<span class="CodeAnnotation" aria-label="annotation1">1</span>(&#13;
            (earthquake #&gt;&gt; '{geometry, coordinates, 0}')::numeric,&#13;
            (earthquake #&gt;&gt; '{geometry, coordinates, 1}')::numeric&#13;
         ),&#13;
             4326<span class="CodeAnnotation" aria-label="annotation2">2</span>)::geography AS earthquake_point&#13;
FROM earthquakes&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-18">Listing 16-18</a>: Converting JSON location data to PostGIS geography</p>&#13;
<p>Inside <code>ST_MakePoint()</code><span class="CodeAnnotation" aria-label="annotation1">1</span>, we place our code to extract longitude and latitude, casting both values to type <code>numeric</code> as required by the function. We nest that function inside <code>ST_SetSRID()</code> to set a spatial reference system identifier (SRID) for the resulting Point. In <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>, you learned that the SRID specifies a coordinate grid for plotting spatial objects. The SRID value <code>4326</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> denotes the commonly used WGS 84 coordinate system. Finally, we cast the entire output to the <code>geography</code> type. The first several rows should look like this:</p>&#13;
<pre><code>                 earthquake_point&#13;
--------------------------------------------------&#13;
0101000020E61000004A0C022B87B65EC0A6C7009A52694340&#13;
0101000020E6100000D8F0F44A598C62C0EFC9C342AD115040&#13;
0101000020E6100000CFF753E3A50F63C0992A1895D4814D40&#13;
<var>--snip--</var></code></pre>&#13;
<p>We can’t interpret those strings of digits and letters directly, but we can use pgAdmin’s Geometry Viewer to see the Points plotted on a map. With your query results visible in the pgAdmin Data Output pane, click the eye icon in the <code>earthquake_point</code> result header. You should see the earthquakes plotted on a map that uses OpenStreetMap as the base layer, as in <a href="#figure16-1" id="figureanchor16-1">Figure 16-1</a>.</p>&#13;
<p>Even with only a month of data, it’s easy to see the abundance of earthquakes concentrated around the edges of the Pacific Ocean, in the so-called Ring of Fire where tectonic plates meet and volcanos are more active.</p>&#13;
<span epub:type="pagebreak" title="325" id="Page_325"/><figure>&#13;
<img src="Images/f16001.png" alt="f16001" class="keyline" width="694" height="430"/>&#13;
<figcaption><p><a id="figure16-1">Figure 16-1</a>: Viewing earthquake locations in pgAdmin</p></figcaption>&#13;
</figure>&#13;
<h4 id="h3-501065c16-0005">Finding Earthquakes Within a Distance</h4>&#13;
<p class="BodyFirst">Next, let’s narrow our study to earthquakes that occurred near Tulsa, Oklahoma—a part of the country that has seen increased seismic activity since 2009 as a result of oil and gas processing, according to the USGS.</p>&#13;
<p>To perform more complex GIS tasks like this, it’s easier if we permanently convert the JSON coordinates to a column of PostGIS type <code>geography</code> in the <code>earthquakes</code> table. That allows us to avoid the clutter of adding conversion code in each query.</p>&#13;
<p><a href="#listing16-19" id="listinganchor16-19">Listing 16-19</a> adds a column called <code>earthquake_point</code> to the <code>earthquakes</code> table and fills the new column with the JSON coordinates converted to type <code>geography</code>.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> ALTER TABLE earthquakes ADD COLUMN earthquake_point geography(POINT, 4326);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> UPDATE earthquakes&#13;
SET earthquake_point =&#13;
        ST_SetSRID(&#13;
            ST_MakePoint(&#13;
                (earthquake #&gt;&gt; '{geometry, coordinates, 0}')::numeric,&#13;
                (earthquake #&gt;&gt; '{geometry, coordinates, 1}')::numeric&#13;
             ),&#13;
                 4326)::geography;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> CREATE INDEX quake_pt_idx ON earthquakes USING GIST (earthquake_point);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-19">Listing 16-19</a>: Converting JSON coordinates to a PostGIS geometry column</p>&#13;
<p><span epub:type="pagebreak" title="326" id="Page_326"/>We use <code>ALTER TABLE</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to add a column <code>earthquake_point</code> of type <code>geography</code>, specifying that the column will hold Points with an SRID of <code>4326</code>. Next, we <code>UPDATE</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> the table, setting the <code>earthquake_point</code> column using the same syntax as in <a href="#listing16-18">Listing 16-18</a>, and add a spatial index using GIST <span class="CodeAnnotation" aria-label="annotation3">3</span> to the new column.</p>&#13;
<p>That done, we can use <a href="#listing16-20" id="listinganchor16-20">Listing 16-20</a> to find earthquakes within 50 miles of Tulsa.</p>&#13;
<pre><code>SELECT earthquake #&gt;&gt; '{properties, place}' AS place,&#13;
       to_timestamp((earthquake -&gt; 'properties' -&gt;&gt; 'time')::bigint / 1000)&#13;
           AT TIME ZONE 'UTC' AS time,&#13;
       (earthquake #&gt;&gt; '{properties, mag}')::numeric AS magnitude,&#13;
       earthquake_point&#13;
FROM earthquakes&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> WHERE ST_DWithin(earthquake_point,&#13;
               <span class="CodeAnnotationCode" aria-label="annotation2">2</span> ST_GeogFromText('POINT(-95.989505 36.155007)'),&#13;
                 80468)&#13;
ORDER BY time;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-20">Listing 16-20</a>: Finding earthquakes within 50 miles of downtown Tulsa, Oklahoma</p>&#13;
<p>In the <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation1">1</span>, we employ the <code>ST_DWithin()</code> function, which returns a Boolean value of <code>true</code> if one spatial object is within a specified distance of another object. Here, we want to evaluate each earthquake Point to check whether it’s within 50 miles of downtown Tulsa. We designate the city’s coordinates in <code>ST_GeogFromText()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and supply the value of 50 miles using its meters equivalent, <code>80468</code>, as meters is the required input. The query should return 19 rows (I’ve omitted the <code>earthquake_point</code> column and truncated the results for brevity):</p>&#13;
<pre><code>                place                 time         magnitude&#13;
------------------------------ ------------------- ---------&#13;
4 km SE of Owasso, Oklahoma    2021-01-04 19:46:58      1.53&#13;
6 km SSE of Cushing, Oklahoma  2021-01-05 08:04:42      0.91&#13;
2 km SW of Hulbert, Oklahoma   2021-01-05 21:08:28      1.95&#13;
<var>--snip--</var></code></pre>&#13;
<p>View the earthquake locations by clicking the eye icon atop the <code>earthquake_point</code> column in the results in pgAdmin. You should see 19 dots around the city, as in <a href="#figure16-2" id="figureanchor16-2">Figure 16-2</a> (and you can adjust the underlying map style by clicking the layer icon at top right).</p>&#13;
<p>Achieving these results required some coding gymnastics that would have been unnecessary if the data had arrived in a shapefile or in a typical SQL table. Nevertheless, it’s possible to extract meaningful insights from JSON data using PostgreSQL’s support for the format. In the last part of the chapter, we’ll cover useful PostgreSQL functions for generating and manipulating JSON.</p>&#13;
<span epub:type="pagebreak" title="327" id="Page_327"/><figure>&#13;
<img src="Images/f16002.png" alt="f16002" class="keyline" width="694" height="323"/>&#13;
<figcaption><p><a id="figure16-2">Figure 16-2</a>: Viewing earthquakes near Tulsa, Oklahoma, in pgAdmin</p></figcaption>&#13;
</figure>&#13;
<h2 id="h1-501065c16-0007">Generating and Manipulating JSON</h2>&#13;
<p class="BodyFirst">We can use PostgreSQL functions to create JSON from existing rows in a SQL table or to modify JSON stored in a table to add, subtract, or change keys and values. The PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/functions-json.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-json.html</a> lists several dozen JSON-related functions—we’ll work through a few you might find handy.</p>&#13;
<h3 id="h2-501065c16-0009">Turning Query Results into JSON</h3>&#13;
<p class="BodyFirst">Because JSON is primarily a format for sharing data, it’s useful to be able to quickly convert the results of a SQL query into JSON for delivery to another computer system. <a href="#listing16-21" id="listinganchor16-21">Listing 16-21</a> uses the PostgreSQL-specific <code>to_json()</code> function to turn rows from the <code>employees</code> table you made in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> into JSON.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> SELECT to_json(employees) AS json_rows&#13;
FROM employees;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-21">Listing 16-21</a>: Turning query results into JSON with <code>to_json()</code></p>&#13;
<p>The <code>to_json()</code> function does what it says: transforms a supplied SQL value to JSON. To convert all values in each row of the <code>employees</code> table, we use <code>to_json()</code> in a <code>SELECT</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and supply the table name as the function’s argument; that returns each row as a JSON object with column names as keys:</p>&#13;
<pre><code>                                    json_rows&#13;
--------------------------------------------------------------------------------------&#13;
{"emp_id":1,"first_name":"Julia","last_name":"Reyes","salary":115300.00,"dept_id":1}&#13;
{"emp_id":2,"first_name":"Janet","last_name":"King","salary":98000.00,"dept_id":1}&#13;
{"emp_id":3,"first_name":"Arthur","last_name":"Pappas","salary":72700.00,"dept_id":2}&#13;
{"emp_id":4,"first_name":"Michael","last_name":"Taylor","salary":89500.00,"dept_id":2}</code></pre>&#13;
<p><span epub:type="pagebreak" title="328" id="Page_328"/>We can modify our query a few ways to limit which columns to include in the results. In <a href="#listing16-22" id="listinganchor16-22">Listing 16-22</a>, we use a <code>row()</code> constructor as the argument for <code>to_json()</code>.</p>&#13;
<pre><code>SELECT to_json(row(emp_id, last_name))<span class="CodeAnnotationCode" aria-label="annotation1">1</span> AS json_rows&#13;
FROM employees;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-22">Listing 16-22</a>: Specifying columns to convert to JSON</p>&#13;
<p>A <code>row()</code> constructor (which is ANSI SQL compliant) builds a row value from the arguments passed to it. In this case, we supply the column names <code>emp_id</code> and <code>last_name</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and place <code>row()</code> inside <code>to_json()</code>. This syntax returns just those columns in the JSON result:</p>&#13;
<pre><code>      json_rows&#13;
----------------------&#13;
{"f1":1,"f2":"Reyes"}&#13;
{"f1":2,"f2":"King"}&#13;
{"f1":3,"f2":"Pappas"}&#13;
{"f1":4,"f2":"Taylor"}</code></pre>&#13;
<p>Notice, however, that the keys are named <code>f1</code> and <code>f2</code> instead of their source column names. That’s a side effect of <code>row()</code>, which doesn’t preserve column names when it builds the row record. We can set the names of the keys, which is often done to keep the names short and reduce JSON file size, improving transfer speeds. <a href="#listing16-23" id="listinganchor16-23">Listing 16-23</a> shows how via a subquery.</p>&#13;
<pre><code>SELECT to_json(employees) AS json_rows&#13;
FROM (&#13;
    <span class="CodeAnnotationCode" aria-label="annotation1">1</span> SELECT emp_id, last_name AS ln<span class="CodeAnnotation" aria-label="annotation2">2</span> FROM employees&#13;
) AS employees;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-23">Listing 16-23</a>: Generating key names with a subquery</p>&#13;
<p>We write a subquery <span class="CodeAnnotation" aria-label="annotation1">1</span> that grabs the columns we want and alias the result as <code>employees</code>. In the process, we alias a column name <span class="CodeAnnotation" aria-label="annotation2">2</span> to shorten its appearance as a key in the JSON.</p>&#13;
<p>The results should look like this:</p>&#13;
<pre><code>        json_rows&#13;
--------------------------&#13;
{"emp_id":1,"ln":"Reyes"}&#13;
{"emp_id":2,"ln":"King"}&#13;
{"emp_id":3,"ln":"Pappas"}&#13;
{"emp_id":4,"ln":"Taylor"}</code></pre>&#13;
<p>Finally, <a href="#listing16-24" id="listinganchor16-24">Listing 16-24</a> shows how to compile all the rows of JSON into a single array of objects. You may want to do this if you’re providing this data to another application that will iterate over the array of objects to perform a task, such as a calculation, or to render data on a device.</p>&#13;
<pre><code><span epub:type="pagebreak" title="329" id="Page_329"/><span class="CodeAnnotationHang" aria-label="annotation1">1</span> SELECT json_agg(to_json(employees)) AS json&#13;
FROM (&#13;
    SELECT emp_id, last_name AS ln FROM employees&#13;
) AS employees;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-24">Listing 16-24</a>: Aggregating the rows and converting to JSON</p>&#13;
<p>We wrap <code>to_json()</code> in the PostgreSQL-specific <code>json_agg()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function, which aggregates values, including <code>NULL</code>, into a JSON array. Its output should look like this:</p>&#13;
<pre><code>                                         json&#13;
--------------------------------------------------------------------------------------------&#13;
[{"emp_id":1,"ln":"Reyes"}, {"emp_id":2,"ln":"King"}, {"emp_id":3,"ln":"Pappas"}, <var>--snip--</var> ]</code></pre>&#13;
<p>These are simple examples, but you can build more complex JSON structures using subqueries to generate nested objects. We’ll consider one way to do that as part of our “Try It Yourself” exercises at the end of the chapter.</p>&#13;
<h3 id="h2-501065c16-0010">Adding, Updating, and Deleting Keys and Values</h3>&#13;
<p class="BodyFirst">We can add to, update, and delete from JSON with a combination of concatenation and PostgreSQL-specific functions. Let’s work through some examples.</p>&#13;
<h4 id="h3-501065c16-0006">Adding or Updating a Top-Level Key/Value Pair</h4>&#13;
<p class="BodyFirst">In <a href="#listing16-25" id="listinganchor16-25">Listing 16-25</a>, we return to our <code>films</code> table and add a top-level key/value pair <code>"studio": "Pixar"</code> to the film <em>The Incredibles</em> using two different techniques:</p>&#13;
<pre><code>UPDATE films&#13;
SET film = film ||<span class="CodeAnnotationCode" aria-label="annotation1">1</span> '{"studio": "Pixar"}'::jsonb&#13;
WHERE film @&gt; '{"title": "The Incredibles"}'::jsonb;&#13;
&#13;
UPDATE films&#13;
SET film = film || jsonb_build_object('studio', 'Pixar')<span class="CodeAnnotationCode" aria-label="annotation2">2</span>&#13;
WHERE film @&gt; '{"title": "The Incredibles"}'::jsonb;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-25">Listing 16-25</a>: Adding a top-level key/value pair via concatenation</p>&#13;
<p>Both examples use <code>UPDATE</code> statements to set new values for the <code>jsonb</code> column <code>film</code>. In the first, we use the PostgreSQL concatenation operator <code>||</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to combine the existing film JSON with the new key value/pair that we cast to <code>jsonb</code>. In the second, we use concatenation again but with <code>jsonb_build_object()</code>. This function takes a series of key and value names as arguments and returns a <code>jsonb</code> object, letting us concatenate several key/value pairs at a time if we wanted.</p>&#13;
<p>Both statements will insert the new key/value pair if the key doesn’t exist in the JSON being concatenated; it will overwrite a key that’s present. <span epub:type="pagebreak" title="330" id="Page_330"/>There’s no functional difference between the two statements, so feel free to use whichever you prefer. Note that this behavior is specific to <code>jsonb</code>, which doesn’t allow duplicate key names.</p>&#13;
<p>If you <code>SELECT * FROM films;</code> and double-click the updated data in the <code>film</code> column, you should see the new key/value pair:</p>&#13;
<pre><code><var>--snip--</var>&#13;
    "rating": {&#13;
        "MPAA": "PG"&#13;
    },&#13;
    "studio": "Pixar",&#13;
    "characters": [&#13;
<var>--snip--</var></code></pre>&#13;
<h4 id="h3-501065c16-0007">Updating a Value at a Path</h4>&#13;
<p class="BodyFirst">Currently we have two entries for the <code>genre</code> key for <em>Cinema Paradiso</em>:</p>&#13;
<pre><code>"genre": ["romance", "drama"]</code></pre>&#13;
<p>To add a third entry to the array, we use the function <code>jsonb_set()</code>, which allows us to specify a value to update at a specific JSON path. In <a href="#listing16-26" id="listinganchor16-26">Listing 16-26</a>, we use the <code>UPDATE</code> statement and <code>jsonb_set()</code> to add the genre <code>World War II</code>.</p>&#13;
<pre><code>UPDATE films&#13;
SET film = jsonb_set(film, <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
                 '{genre}', <span class="CodeAnnotationCode" aria-label="annotation2">2</span>&#13;
                  film #&gt; '{genre}' || '["World War II"]', <span class="CodeAnnotationCode" aria-label="annotation3">3</span>&#13;
                  true<span class="CodeAnnotation" aria-label="annotation4">4</span>)&#13;
WHERE film @&gt; '{"title": "Cinema Paradiso"}'::jsonb;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-26">Listing 16-26</a>: Adding an array value at a path with <code>jsonb_set()</code></p>&#13;
<p>In <code>UPDATE</code>, we <code>SET</code> the value of <code>film</code> to the result of <code>jsonb_set()</code> and use <code>WHERE</code> to limit the update to just the row with <em>Cinema Paradiso</em>. The function’s first argument <span class="CodeAnnotation" aria-label="annotation1">1</span> is the target JSON we want to modify, here <code>film</code>. The second argument is the path <span class="CodeAnnotation" aria-label="annotation2">2</span> to the array value—the <code>genre</code> key. Third, we give the new value for <code>genre</code>, which we specify as the current value of <code>genre</code> concatenated with an array <span class="CodeAnnotation" aria-label="annotation3">3</span> with one value, <code>"World War II"</code>. That concatenation will produce an array with three elements. The final argument is an optional Boolean value <span class="CodeAnnotation" aria-label="annotation4">4</span> that dictates whether <code>jsonb_set()</code> should create the value if it’s not already present. It’s redundant here since <code>genre</code> already exists; I’ve shown it for reference.</p>&#13;
<p>Run the query and then perform a quick <code>SELECT</code> to check the updated JSON. You should see the <code>genre</code> array including three values: <code>["romance", "drama", "World War II"]</code>.</p>&#13;
<h4 id="h3-501065c16-0008"><span epub:type="pagebreak" title="331" id="Page_331"/>Deleting a Value</h4>&#13;
<p class="BodyFirst">We can remove keys and values from a JSON object by pairing two operators. <a href="#listing16-27" id="listinganchor16-27">Listing 16-27</a> shows two <code>UPDATE</code> examples.</p>&#13;
<pre><code>UPDATE films&#13;
SET film = film -<span class="CodeAnnotation" aria-label="annotation1">1</span> 'studio'&#13;
WHERE film @&gt; '{"title": "The Incredibles"}'::jsonb;&#13;
&#13;
UPDATE films&#13;
SET film = film #-<span class="CodeAnnotation" aria-label="annotation2">2</span> '{genre, 2}'&#13;
WHERE film @&gt; '{"title": "Cinema Paradiso"}'::jsonb;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-27">Listing 16-27</a>: Deleting values from JSON</p>&#13;
<p>The minus sign <span class="CodeAnnotation" aria-label="annotation1">1</span> acts as a <em>deletion operator</em>, removing the key <code>studio</code> and its value, which we added earlier for <em>The Incredibles</em>. Supplying a text string after the minus sign indicates we want to remove a key and its value; supplying an integer will remove the element at that index.</p>&#13;
<p>The <code>#-</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> sign is a <em>path deletion operator</em> that removes the JSON element that exists at a path we specify. The syntax is similar to that of the path extraction operators <code>#&gt;</code> and <code>#&gt;&gt;</code>. Here, we use <code>{genre, 2}</code> to indicate the third element of the array for <code>genre</code> (remember, JSON array indexes begin counting at zero). This will remove the value <code>World War II</code> that we added earlier to <em>Cinema Paradiso</em>.</p>&#13;
<p>Run both statements and then use <code>SELECT</code> to view the altered film JSON. You should see both elements removed.</p>&#13;
<h2 id="h1-501065c16-0008">Using JSON Processing Functions</h2>&#13;
<p class="BodyFirst">To finish our JSON studies, we’ll review a selection of PostgreSQL-specific functions for processing JSON data, including expanding array values into table rows and formatting output. You can find a complete listing of functions in the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/functions-json.html" class="LinkURL">https://www.postgresql.org/docs/current/functions-json.html</a>.</p>&#13;
<h3 id="h2-501065c16-0011">Finding the Length of an Array</h3>&#13;
<p class="BodyFirst">Counting the number of items in an array is a routine programming and analysis task. We might, for example, want to know how many actors are stored for each film in our JSON. To do this, we can use the <code>jsonb_array_length()</code> function in <a href="#listing16-28" id="listinganchor16-28">Listing 16-28</a>.</p>&#13;
<pre><code>SELECT id,&#13;
       film -&gt;&gt; 'title' AS title,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> jsonb_array_length(film -&gt; 'characters') AS num_characters&#13;
FROM films&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-28">Listing 16-28</a>: Finding the length of an array</p>&#13;
<p><span epub:type="pagebreak" title="332" id="Page_332"/>As its only argument, the function <span class="CodeAnnotation" aria-label="annotation1">1</span> takes an expression that extracts the value of the <code>character</code> key from <code>film</code>. Running the query should produce these results:</p>&#13;
<pre><code>id      title      num_characters&#13;
-- --------------- --------------&#13;
 1 The Incredibles              3&#13;
 2 Cinema Paradiso              2</code></pre>&#13;
<p>The output correctly shows that we have three characters for <em>The Incredibles</em> and two for <em>Cinema Paradiso</em>. Note there’s a similar <code>json_array_length()</code> function for the <code>json</code> type.</p>&#13;
<h3 id="h2-501065c16-0012">Returning Array Elements as Rows</h3>&#13;
<p class="BodyFirst">The <code>jsonb_array_elements()</code> and <code>jsonb_array_elements_text()</code> functions convert array elements into rows, with one row per element. This is a useful tool for data processing. To convert JSON into structured SQL data, for example, we could use this function to generate the rows to <code>INSERT</code> into a table or to generate rows that we can aggregate by grouping and counting.</p>&#13;
<p><a href="#listing16-29" id="listinganchor16-29">Listing 16-29</a> uses both functions to turn the <code>genre</code> key’s array values into rows. Each function takes a <code>jsonb</code> array as an argument. The difference between the two is that <code>jsonb_array_elements()</code> returns the array elements as rows of <code>jsonb</code> values, while <code>jsonb_array_elements_text()</code> returns elements as, you guessed it, <code>text</code>.</p>&#13;
<pre><code>SELECT id,&#13;
       jsonb_array_elements(film -&gt; 'genre') AS genre_jsonb,&#13;
       jsonb_array_elements_text(film -&gt; 'genre') AS genre_text&#13;
FROM films&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-29">Listing 16-29</a>: Returning array elements as rows</p>&#13;
<p>Running the code should produce these results:</p>&#13;
<pre><code>id genre_jsonb genre_text&#13;
-- ----------- ----------&#13;
 1 "animation" animation&#13;
 1 "action"    action&#13;
 1 "sci-fi"    sci-fi&#13;
 2 "romance"   romance&#13;
 2 "drama"     drama</code></pre>&#13;
<p>On an array with a simple list of values, that works nicely, but if an array contains a collection of JSON objects with their own key/value pairs, like <code>character</code> in our <code>film</code> JSON, we need additional processing to unpack the values first. <a href="#listing16-30" id="listinganchor16-30">Listing 16-30</a> walks through the process.</p>&#13;
<pre><code>SELECT id,&#13;
       jsonb_array_elements(film -&gt; 'characters') <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
FROM films&#13;
<span epub:type="pagebreak" title="333" id="Page_333"/>ORDER BY id;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> WITH characters (id, json) AS (&#13;
    SELECT id,&#13;
           jsonb_array_elements(film -&gt; 'characters')&#13;
    FROM films&#13;
)&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT id,&#13;
       json -&gt;&gt; 'name' AS name,&#13;
       json -&gt;&gt; 'actor' AS actor&#13;
FROM characters&#13;
ORDER BY id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing16-30">Listing 16-30</a>: Returning key values from each item in an array</p>&#13;
<p>We use <code>jsonb_array_elements()</code> to return the elements of the <code>characters</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> array, which should return each JSON object in the array as a row:</p>&#13;
<pre><code>id                  jsonb_array_elements&#13;
-- ------------------------------------------------------&#13;
 1 {"name": "Mr. Incredible", "actor": "Craig T. Nelson"}&#13;
 1 {"name": "Elastigirl", "actor": "Holly Hunter"}&#13;
 1 {"name": "Frozone", "actor": "Samuel L. Jackson"}&#13;
 2 {"name": "Salvatore", "actor": "Salvatore Cascio"}&#13;
 2 {"name": "Alfredo", "actor": "Philippe Noiret"}</code></pre>&#13;
<p>To convert the <code>name</code> and <code>actor</code> values to columns, we employ a common table expression (CTE) as covered in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>. Our CTE <span class="CodeAnnotation" aria-label="annotation2">2</span> uses <code>jsonb_array_elements()</code> to generate a simple temporary <code>characters</code> table with two columns: the film’s <code>id</code> and the unpacked array values in a column called <code>json</code>. We follow with a <code>SELECT</code> statement <span class="CodeAnnotation" aria-label="annotation3">3</span> that queries the temporary table, extracting the values of <code>name</code> and <code>actor</code> from the <code>json</code> column:</p>&#13;
<pre><code>id      name            actor&#13;
-- -------------- -----------------&#13;
 1 Mr. Incredible Craig T. Nelson&#13;
 1 Elastigirl     Holly Hunter&#13;
 1 Frozone        Samuel L. Jackson&#13;
 2 Salvatore      Cascio&#13;
 2 Alfredo        Philippe Noiret</code></pre>&#13;
<p>Those values are neatly parsed into a standard SQL structure and suitable for further analysis using standard SQL.</p>&#13;
<h2 id="h1-501065c16-0009">Wrapping Up</h2>&#13;
<p class="BodyFirst">JSON is such a ubiquitous format that it’s likely you’ll encounter it often in your journey analyzing data. You’ve learned that PostgreSQL easily handles loading, indexing, and parsing JSON, but JSON sometimes requires extra steps to process that aren’t needed with data handled via standard SQL conventions. As with many areas of coding, your decision on whether to <span epub:type="pagebreak" title="334" id="Page_334"/>make use of JSON will depend on your specific circumstances. Now, you’re equipped to understand the context.</p>&#13;
<p>JSON itself is a standard, but the data types and the majority of functions and syntax in this chapter were PostgreSQL-specific. That’s because the ANSI SQL standard leaves it to database vendors to decide how to implement most JSON support. If your work involves using Microsoft SQL Server, MySQL, SQLite, or another system, consult their documentation. You’ll find many similarities in capabilities even if the function names differ.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2>Try It Yourself</h2>&#13;
<p class="BoxBodyFirst">Use your new JSON skills to answer these questions:</p>&#13;
<ol>&#13;
<li value="1">The earthquakes JSON has a key <code>tsunami</code> that’s set to a value of <code>1</code> for large earthquakes in oceanic regions (though it doesn’t mean a tsunami actually happened). Using either path or field extraction operators, find earthquakes with a <code>tsunami</code> value of <code>1</code> and include their location, time, and magnitude in your results.</li>&#13;
<li value="2">Use the following <code>CREATE TABLE</code> statement to add the table <code>earthquakes_from_json</code> to your <code>analysis</code> database:&#13;
<pre><code>CREATE TABLE earthquakes_from_json (&#13;
    id text PRIMARY KEY,&#13;
    title text,&#13;
    type text,&#13;
    quake_date timestamp with time zone,&#13;
    mag numeric,&#13;
    place text,&#13;
    earthquake_point geography(POINT, 4326),&#13;
    url text&#13;
);</code></pre>&#13;
<p class="ListBody">Using field and path extraction operators, write an <code>INSERT</code> statement to fill the table with the correct values for each earthquake. Refer to the full sample earthquake JSON in your <em>Chapter_16.sql</em> file for any key names and paths you need.</p></li>&#13;
<li value="3">Bonus (difficult) question: Try writing a query to generate the following JSON using the data in the <code>teachers</code> and <code>teachers_lab_access</code> tables from <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>:&#13;
<pre><code>{&#13;
    "id": 6,&#13;
    "fn": "Kathleen",&#13;
    "ln": "Roush",&#13;
    "lab_access": [{&#13;
        "lab_name": "Science B",&#13;
<span epub:type="pagebreak" title="335" id="Page_335"/>        "access_time": "2022-12-17T16:00:00-05:00"&#13;
    }, {&#13;
        "lab_name": "Science A",&#13;
        "access_time": "2022-12-07T10:02:00-05:00"&#13;
    }]&#13;
}</code></pre>&#13;
<p class="ListBody">It’s helpful to remember that the <code>teachers</code> table has a one-to-many relationship with <code>teachers_lab_access</code>; the first three keys must come from <code>teachers</code>, and the JSON objects in the array of <code>lab_access</code> will come from <code>teachers_lab_access</code>. Hint: you’ll need to use a subquery in your <code>SELECT</code> list and a function called <code>json_agg()</code> to create the <code>lab_access</code> array. If you’re stumped, take a peek in your <em>Try_It_Yourself.sql</em> file included with the book’s resources, where I’ve placed the answers to all these exercises.</p>&#13;
</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>