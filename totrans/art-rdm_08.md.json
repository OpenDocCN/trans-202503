["```\n> python3 random_sounds.py 3 tmp.wav\n```", "```\nfrom scipy.io.wavfile import write as wavwrite\n\ndef WriteOutputWav(samples, name):\n    s = (samples - samples.min()) / (samples.max() - samples.min())\n    s = (-1.0 + 2.0*s).astype(\"float32\")\n    wavwrite(name, rate, s)\n\nrate = 22050\nduration = float(sys.argv[1])\noname = sys.argv[2]\n\nnsamples = int(duration * rate)\nsamples = -1.0 + 2.0*np.random.random(nsamples)\n\nWriteOutputWav(samples, oname)\n```", "```\n> python3 sine_walker.py 5 3 walk.wav\n```", "```\nnsamples = int(duration * rate)\nsamples = np.zeros(nsamples, dtype=\"float32\")\ndur = 0.5\nstep_samp = int(dur * rate)\nfstep = 5\nfreq = np.zeros(nwalkers, dtype=\"uint32\")\nfreq[:] = (440 + 800*(rng.random(nwalkers)-0.5)).astype(\"uint32\")\n```", "```\n   k = 0\n➊ while (k < nsamples):\n    ➋ for i in range(nwalkers):\n           r = rng.random()\n           if (r < 0.33333):\n               freq[i] += fstep\n           elif (r < 0.66666):\n               freq[i] -= fstep\n           freq[i] = min(max(100,freq[i]),4000)\n        ➌ amp = rng.random()\n           if (i == 0):\n               t = amp*np.sin(2*np.pi*np.arange(rate*dur)*freq[i]/rate)\n           else:\n               t += amp*np.sin(2*np.pi*np.arange(rate*dur)*freq[i]/rate)\n       n = 1\n    ➍ while (np.abs(t[-n]) > 1e-4):\n           n += 1\n       t = t[:-n]\n       if ((k+len(t)) < nsamples):\n        ➎ samples[k:(k+len(t))] = t\n       k += len(t)\n\n   lo = np.quantile(samples, 0.1)\n   hi = np.quantile(samples, 0.9)\n   samples[np.where(samples <= lo)] = lo\n   samples[np.where(samples >= hi)] = hi\n   WriteOutputWav(samples, oname)\n```", "```\nfrequencies = np.array([\n146.83 ,  164.81 ,  174.61 ,  196\\.   ,\n220\\.   ,  246.94 ,  261.63 ,  293.66 ,  329.63 ,  349.23 ,\n392\\.   ,  440\\.   ,  493.88 ,  523.25 ,  587.33 ,  659.26 ,\n698.46 ,  783.99 ,  880\\.   ,  987.77 , 1046.5  ])\n```", "```\n> sudo apt-get install wildmidi\n```", "```\n> sudo pip3 install midiutil\n```", "```\n> sudo apt-get install musescore3\n```", "```\n> python3 melody_maker.py\n\nmelody_maker <length> <outfile> <npart> <max_iter> <alg> <mode> [<kind> | <kind> <seed>]\n\n  <length>   - number of notes in the melody\n  <outdir>   - output directory\n  <npart>    - swarm size\n  <max_iter> - maximum number of iterations\n  <alg>      - algorithm: PSO,DE,RO,GWO,JAYA,GA,BARE\n  <mode>     - mode\n  <kind>     - randomness source\n  <seed>     - random seed\n```", "```\n> python3 melody_maker.py 20 tmp 20 10000 bare mixolydian\n\nMelody maker:\n\nnpart = 20\nniter = 10000\nalg = BARE\nOptimization time = 114.775 seconds\n63,0.90 60,0.60 63,0.60 60,0.60 63,0.60 60,0.60 61,1.20 \n65,0.60 68,0.60 65,0.60 68,1.20 72,1.20 68,0.60 65,1.20 \n70,0.60 67,1.20 63,1.20 67,0.60 70,1.20 73,0.60 \n\n31 best updates, final objective value 1.6637\n```", "```\n> wildmidi tmp/melody_BARE.mid\n```", "```\n> sh melody_examples\n```", "```\ndef Evaluate(self, p):\n    self.fcount += 1\n    s = self.Distance(p[::2], self.mode)\n    d = self.Durations(p)\n    i = self.Intervals(p[::2], self.mode)\n    l = self.Leaps(p[::2], self.mode)\n    return 4*s+3*d+2*i+l\n```", "```\ndef Distance(self, notes, mode):\n    A,B = self.ModeNotes(notes, mode)\n    lo = int(notes.min() - self.lo)\n    hi = int(notes.max() - self.lo)\n    a = A[lo:(hi+2)]\n    b = B[lo:(hi+2)]\n    score = (np.logical_xor(a,b)*1).sum()\n    score /= len(a)\n    return score\n```", "```\ndef Durations(self, p):\n    d = p[1::2].astype(\"int32\")\n    dp = np.bincount(d, minlength=8)\n    b = dp / dp.sum()\n    a = np.array([0,0,100,0,60,0,20,0])\n    a = a / a.sum()\n    return np.sqrt(((a-b)**2).sum())\n```", "```\ndef Intervals(self, notes, mode):\n    _,B = self.ModeNotes(notes, mode)\n    minor = major = fifth = 0\n    for i in range(len(notes)-1):\n        x = int(notes[i]-self.lo)\n        y = int(notes[i+1]-self.lo)\n        if (B[x] == 1) and (B[y] == 1):\n            if (abs(x-y) == 3):\n                minor += 1\n            if (abs(x-y) == 4):\n                major += 1\n            if (abs(x-y) == 7):\n                fifth += 1\n    w = (3*minor + 3*major + fifth) / 7\n    return 1.0 - w/len(notes)\n```", "```\ndef Leaps(self, notes, mode):\n    _,B = self.ModeNotes(notes, mode)\n    leaps = 0\n    for i in range(len(notes)-1):\n        x = int(notes[i]-self.lo)\n        y = int(notes[i+1]-self.lo)\n        if (B[x] == 1) and (B[y] == 1):\n            if (abs(x-y) > 5):\n                leaps += 1\n    return leaps / len(notes)\n```"]