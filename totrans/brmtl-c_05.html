<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="53" id="Page_53"/>4</span><br/>
<span class="ChapterTitle">Numbers and Variables</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Now that we have written a trivial program or two, it’s time to get the machine to do some real work. In this chapter you will learn how to manipulate numbers.</p>
<p>As embedded programmers, we are concerned with exactly what the numbers are doing. For example, the number 32 could represent the number of sheep in a barnyard, or it could energize GPIO pin #4, which turns on the big red warning light. What’s worse, our STM32 groups up to 32 different GPIOs into a single number, so while 32 might tell the device to “turn on the big red light,” 34 could tell it to “turn on the big red light and sound the klaxon.” To control our devices, we need to know precisely what these numbers are doing. Thus, we will take a deep dive into the numbers as seen by the computer.</p>
<p>Once you know what a number is, you will learn how to work with it by using variables to store the information in our program. Next, you’ll practice manipulating the bits in the hardware’s I/O registers to turn various functions on or off. In the process, you’ll see how the program in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> worked behind the scenes.</p>
<h2 id="h1-501621c04-0001"><span epub:type="pagebreak" title="54" id="Page_54"/>Working with Integers</h2>
<p class="BodyFirst">We’ll start with integers, or whole numbers. These are numbers without a decimal point, such as 37, 45, –8, and 256.</p>
<p><a href="#table4-1" id="tableanchor4-1">Table 4-1</a> lists the operations you can do with numbers in C.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-1">Table 4-1</a>: Number Operators in C</p></figcaption>
<table id="table-501621c04-0001" border="1">
<thead>
<tr>
<td><b>Operator</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>Add</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtract</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiply</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Divide (truncates to a whole number)</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Modulus (returns the remainder after division)</td>
</tr>
</tbody>
</table>
</figure>
<p>The following listing illustrates how these operators work:</p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
    printf("3 + 2 is %d\n", 3 + 2);
    printf("3 - 2 is %d\n", 3 - 2);
    printf("3 * 2 is %d\n", 3 * 2);
    printf("3 / 2 is %d\n", 3 / 2);
    printf("10 / 9 is %d\n", 10 / 9);
    printf("3 %% 2 is %d\n", 3 % 2);
    return (0);
}</code></pre>
<p>We demonstrate each operation inside a <code>printf</code> statement that prints the result. To print the result of a calculation using <code>printf</code>, put a <code>%d</code> in the string where you want a number to appear and then list the calculation as a second argument to <code>printf</code>. Notice that if you want to print a <code>%</code> to represent the modulus operation, you need to specify it twice.</p>
<p>To view this program’s output, let’s get it into our IDE. Start System Workbench for STM32 and then go through the list of steps in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> to create a program. (A checklist in the <span class="xref" itemid="xref_target_appendix">appendix</span> summarizes these steps.) This time, however, instead of creating a “Hello World” program, we’ll create an empty native C/C++ project, so select <b>C Managed Build</b> as the template.</p>
<p>Under Project Type, choose <b>Executable</b><span class="MenuArrow">▶</span><b>Empty Project</b>. Next, create the program file by selecting <b>File</b><span class="MenuArrow">▶</span><b>New</b><span class="MenuArrow">▶</span><b>Source File</b>.</p>
<p>Enter the program text into the editing window and then save the file. Build the binary and run it as you did in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. The program should display its output at the bottom of the Console window (see <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a>).</p>
<span epub:type="pagebreak" title="55" id="Page_55"/><figure>
<img src="image_fi/501621c04/f04001.png" alt="f04001" class=""/>
<figcaption><p><a id="figure4-1">Figure 4-1</a>: The run result</p></figcaption>
</figure>
<p>As you can see, the program should print the result of each calculation it performs.</p>
<h3 id="h2-501621c04-0001">Declaring Variables to Hold Integers</h3>
<p class="BodyFirst">Our program performed operations on fixed numbers, but we can also use variables to store information that can change. Before any variable can be used, it has to be <em>declared</em>. The format of a variable declaration is as follows:</p>
<pre><code><var>type variable_name</var><code>; // </code><var>Comment explaining what this variable does</var></code></pre>
<p>For example, using <code>int</code> as the type would indicate that the variable is an integer. To be precise, it is the type of integer that the computer can most easily handle. We will get into other types of integers later in this chapter.</p>
<p>Variable names begin with a letter and must contain only letters, digits, and the underscore. The STM32 firmware library uses the camel case variable naming style, where words within the name are capitalized, so to be compatible, we use camel case throughout this book:</p>
<pre><code>startTime   currentStation  area</code></pre>
<p>While names can begin with an underscore, such names are considered reserved for system functions and should not be used in ordinary programming. Also, never use <code>l</code> (lowercase <em>L</em>) or <code>O</code> (uppercase <em>O</em>) as a variable name. In case the reasons aren’t obvious, consider the following code:</p>
<pre><code>O = l + 1 + O * 0;  // This sort of programming will get you shot.</code></pre>
<p><span epub:type="pagebreak" title="56" id="Page_56"/>Technically, you can omit the comment from your variable declaration. However, including a comment gives the people who work with the code after you an idea of why you declared the variable and what it does. In other words, it helps you create a mini-dictionary or glossary.</p>
<h3 id="h2-501621c04-0002">Assigning Values to Variables</h3>
<p class="BodyFirst">Once we’ve declared a variable, we can assign it a value with an assignment statement. The general form of an assignment statement is as follows:</p>
<pre><code><var>variable</var> = <var>expression</var>;</code></pre>
<p>This tells the computer to compute the value of the expression and store it in the variable. Variables can then be used anyplace we put an integer, such as a <code>printf</code> statement. The following program demonstrates variable declaration, assignment, and use:</p>
<p class="CodeLabel"><b>var.c</b></p>
<pre><code>/*  
 * A program to sum two variables
 */  
#include &lt;stdio.h&gt;
 
int main()
{
    int aNumber;        // Some number
    int otherNumber;    // Some other number

    aNumber = 5;
    otherNumber = 7;

    printf("Sum is %d\n", aNumber + otherNumber);
    return (0);
}</code></pre>
<p>This program creates two variables, <code>aNumber</code> and <code>otherNumber</code>, and then assigns them each a value and prints the sum. Enter this program into System Workbench for STM32 now.</p>
<h3 id="h2-501621c04-0003">Initializing Variables</h3>
<p class="BodyFirst">When you declare a variable in your program, you tell the C compiler to allocate memory space for an integer (<code>int</code>). But before you specify a value for it, this variable is considered <em>uninitialized</em>; it may contain any random garbage value left over from the last time the memory was used.</p>
<p>To see this at work in the program we just wrote, open the debugger and take a look at the Variables panel as you step through the program. Before you assign them values, our two variables, <code>aNumber</code> and <code>otherNumber</code>, have values of zero. But uninitialized variables could have any value; the fact that they’re zero here is pure luck.</p>
<p><span epub:type="pagebreak" title="57" id="Page_57"/>We can initialize a variable at declaration time by adding an assignment to it:</p>
<pre><code>int aNumber = 5;           // Some number</code></pre>
<p>This is a good idea in most cases, as it makes sure our program is working with an expected value. Let’s rewrite our program to add these initializers:</p>
<pre><code>/*  
 * A program to see if we can sum two variables
 */  
#include &lt;stdio.h&gt;
 
int main()
{
    int aNumber = 5;        // Some number
    int otherNumber = 7;    // Some other number

    printf("Sum is %d\n", aNumber + otherNumber);
    return (0);
}</code></pre>
<p>Once we’ve made that change, we can delete the lines that initialize the variables later in the program.</p>
<h2 id="h1-501621c04-0002">Integer Sizes and Representations</h2>
<p class="BodyFirst">C has integer types other than <code>int</code> that it uses to represent numbers of different sizes.</p>
<p>As computers evolved, people discovered that the most efficient way to organize memory is in 8-bit groups called <em>bytes</em>. The computer lets you combine multiple bytes into 2-byte, 4-byte, and 8-byte values, and the <code>int</code> type tells C to define an integer using the most efficient number of bytes for the computer you are using. This may be a 16-bit (2-byte) integer or a 32-bit (4-byte) integer, depending on the system. The compiler for our chip, the ARM Cortex-M0 CPU, uses a 32-bit integer.</p>
<p>To make programs even more efficient, C lets you select the type of integer you want. For example, you may wish to store numbers in the range of 0 to 100. You don’t need a full-size integer for that, so you can use a <code>short int</code>, which is like an integer but takes up less space. (Technically, the C standard only states that a <code>short int</code> is no larger than a regular <code>int</code>, but in most implementations it is smaller.)</p>
<p>The following declares a <code>short int</code>:</p>
<pre><code>short int shortNumber;  // A shorter-than-normal integer</code></pre>
<p>A longer-than-normal integer can be declared with the modifier <code>long</code>:</p>
<pre><code>long int longNumber;    // A longer-than-normal integer</code></pre>
<p><span epub:type="pagebreak" title="58" id="Page_58"/>When computers gained the ability to efficiently process even longer numbers, people needed an integer type that could contain even more bits than a <code>long</code> does. The result was the (somewhat silly) <code>long long</code> integer:</p>
<pre><code>long long int veryLongNumber;   // An even longer integer</code></pre>
<p>The C standard does not define the size of each type of integer. They could all be the same size, and you’d still have a standard compiler. However, it does guarantee the following:</p>
<pre><code>sizeof(short int) &lt;= sizeof(int) &lt;= sizeof(long int) &lt;= sizeof(long long int)</code></pre>
<p>The <code>sizeof</code> operator returns the number of bytes it takes to store a variable or type.</p>
<p>Let’s see how much space each type of integer takes for the compiler on our system using a short program to print the sizes of the various flavors of integer:</p>
<p class="CodeLabel"><b>size.c</b></p>
<pre><code>/*
 * Show different number types.
 */
#include &lt;stdio.h&gt;

int main()
{
    short int aShortInt;        // Short integer
    int aInteger;               // Default integer
    long int aLongInt;          // Long integer
    long long int aLongLongInt; // Long long integer

    printf("Size of (short int) = %ld (bytes) %ld bits\n",
            sizeof(aShortInt), sizeof(aShortInt)*8);

    printf("Size of (int) = %ld (bytes) %ld bits\n",
            sizeof(aInteger), sizeof(aInteger)*8);

    printf("Size of (long int) = %ld (bytes) %ld bits\n",
            sizeof(aLongInt), sizeof(aLongInt)*8);

    printf("Size of (long long int) = %ld (bytes) %ld bits\n",
            sizeof(aLongLongInt), sizeof(aLongLongInt)*8);

    return (0);
}</code></pre>
<p>Earlier, we used <code>%d</code> to print a number. In this program, we use <code>%ld</code>, because <code>sizeof</code> returns a <code>long int</code> and <code>%ld</code> is used to print <code>long int</code> numbers.</p>
<p>The program produces the following output on my system:</p>
<pre><code>Size of (short int) = 2 (bytes) 16 bits
Size of (int) = 4 (bytes) 32 bits
Size of (long int) = 8 (bytes) 64 bits
Size of (long long int) = 8 (bytes) 64 bits</code></pre>
<p><span epub:type="pagebreak" title="59" id="Page_59"/>From this, we can see that the size of a <code>long int</code> is the same as a <code>long long int</code>. However, that is true only for this compiler on this system (GNU GCC on an x86_64 processor). Different compilers might implement things differently.</p>
<h3 id="h2-501621c04-0004">Number Representations</h3>
<p class="BodyFirst">Let’s say we have five cows. In English, we could represent that number as “five,” “5,” or “V.” Likewise, in C, you can use four number representations: decimal, binary, octal, and hexadecimal.</p>
<p>People typically use decimal (base 10), but computers store numbers in binary (base 2) because it’s cheap and easy to make binary circuits. For example, we might write the following assignment statement using decimal:</p>
<pre><code>aNumber = 5;</code></pre>
<p>This same statement could be written in binary like this:</p>
<pre><code>aNumber = 0b101;    // 5 in binary</code></pre>
<p>The prefix 0b indicates a binary number follows. (We could use 0B too, but it’s harder to read.)</p>
<p>Or, we could use octal (base 8):</p>
<pre><code>aNumber = 05;   // 5 in octal</code></pre>
<p>Finally, we can use hexadecimal (base 16):</p>
<pre><code>aNumber = 0x5;  // 5 in hexadecimal</code></pre>
<p>Binary numbers take up a lot of room to write, so to make things more compact, we often use hexadecimal notation in programming to represent exact binary values. Each single hex digit translates into four binary bits, as shown in <a href="#table4-2" id="tableanchor4-2">Table 4-2</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-2">Table 4-2</a>: Converting Between Binary and Hex</p></figcaption>
<table id="table-501621c04-0002" border="1">
<thead>
<tr>
<td><b>Binary</b></td>
<td><b>Hex</b></td>
<td><b>Binary</b></td>
<td><b>Hex</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>0</td>
<td>1000</td>
<td>8</td>
</tr>
<tr>
<td>0001</td>
<td>1</td>
<td>1001</td>
<td>9</td>
</tr>
<tr>
<td>0010</td>
<td>2</td>
<td>1010</td>
<td>A</td>
</tr>
<tr>
<td>0011</td>
<td>3</td>
<td>1011</td>
<td>B</td>
</tr>
<tr>
<td>0100</td>
<td>4</td>
<td>1100</td>
<td>C</td>
</tr>
<tr>
<td>0101</td>
<td>5</td>
<td>1101</td>
<td>D</td>
</tr>
<tr>
<td>0110</td>
<td>6</td>
<td>1110</td>
<td>E</td>
</tr>
<tr>
<td>0111</td>
<td>7</td>
<td>1111</td>
<td>F</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="60" id="Page_60"/>As you can see, 1111 1100b is the equivalent of the hex value 0xFC. Similarly, 0xA5 is 1010 0101b. Using this table, you can quickly and easily translate between binary and hexadecimal.</p>
<p>While the computer stores a number as a set of bits, the meaning of those bits is entirely up to us. For example, the bit pattern 0000 0101 could mean 5 if we interpret it as a binary number. But 0000 0101 could also mean 10,005. How did I get that number? I made it up. In this case, I arbitrarily picked a strange value. Other arbitrary meanings could include “May,” the letter “E,” and “LED0+LED2.”</p>
<p>One less common but still useful bit pattern mapping is shown in <a href="#table4-3" id="tableanchor4-3">Table 4-3</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-3">Table 4-3</a>: A Bit Pattern to Number Mapping</p></figcaption>
<table id="table-501621c04-0003" border="1">
<thead>
<tr>
<td><b>Bit pattern</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>001</td>
<td>1</td>
</tr>
<tr>
<td>011</td>
<td>2</td>
</tr>
<tr>
<td>010</td>
<td>3</td>
</tr>
<tr>
<td>110</td>
<td>4</td>
</tr>
<tr>
<td>111</td>
<td>5</td>
</tr>
<tr>
<td>101</td>
<td>6</td>
</tr>
<tr>
<td>100</td>
<td>7</td>
</tr>
</tbody>
</table>
</figure>
<p>At first glance, it looks random. But if you look closely, you’ll see that only one bit changes between each number. This makes it ideal for use in encoders (see <a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a>). It is, in fact, a standard bit pattern encoding called <em>Gray code</em>.</p>
<figure>
<img src="image_fi/501621c04/f04002.png" alt="f04002" class=""/>
<figcaption><p><a id="figure4-2">Figure 4-2</a>: A Gray code encoder</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="61" id="Page_61"/>Remember that C has no idea how to interpret a bit pattern until you tell it how.</p>
<h3 id="h2-501621c04-0005">Standard Integers</h3>
<p class="BodyFirst">The big problem with the integer types is that nothing in the standard tells you how big they are, just their relative sizes. If you want to write to a 32-bit device, you have to guess which type of <code>int</code> will be the size you want.</p>
<p>Guessing and programming do not mix well together, so people devised systems using a technique called <em>conditional compilation</em> (see <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>) and other tricks to define new types that hold a precise number of bits: <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, and <code>int64_t</code>. The name of the type specifies the size of the integer. For example, the type <code>int32_t</code> has 32 bits in it no matter what size the <code>int</code> is. Like most good ideas, these new types became widely used—so widely used that the C standards committee decided to add them to the language with the <code>stdint</code> library. They are not part of the built-in C types, so you have to include them by using the following statement:</p>
<pre><code>#include &lt;stdint.h&gt;</code></pre>
<p><a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a> shows our new integer types in action.</p>
<pre><code>/*
 * Demonstrate different sizes of integers.
 */
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main()
{
    int8_t   has8bits = 0x12;               // 8-bit integer
    int16_t has16bits = 0x1234;             // 16-bit integer
    int32_t has32bits = 0x12345678;         // 32-bit integer
    int64_t has64bits = 0x123456789abcdef0; // 64-bit integer

    printf(" 8 bits %x\n", has8bits);
    printf("16 bits %x\n", has16bits);
    printf("32 bits %x\n", has32bits);
    printf("64 bits %lx\n", has64bits);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: Integer demonstration</p>
<p>In this program, we use the formatting character <code>%x</code> to print the numbers in hexadecimal. Specifically, the <code>%x</code> format character prints an <code>int</code> in hexadecimal, but we can also use it for <code>int8_t</code>, <code>int16_t</code>, and <code>int32_t</code> because of some behind-the-scenes stuff called <em>argument promotion</em>.</p>
<p>C is a somewhat lazy language. Because it’s hard to pass a 16-bit integer to <code>printf</code> when your processor has 32-bit registers, C takes the <code>int16_t</code> and converts, or <em>promotes</em>, it to an <code>int32_t</code> for this one operation, which lets us get away with using <code>%x</code> for an <code>int16_t</code>. Similarly, we can use <code>%x</code> for an <code>int8_t</code> because <span epub:type="pagebreak" title="62" id="Page_62"/>it will get promoted to an <code>int32_t</code> as well. (Strictly speaking, the C standard states that promotion <em>may</em> occur. It does not require it. This code works on our x86_64 machine with this compiler, but it is not portable to other systems.)</p>
<p>Now we come to <code>int64_t</code>. If C were to change this into an <code>int</code> (<code>int32_t</code>), we’d lose half our number. C can’t do anything to it, so it passes an <code>int64_t</code> argument as an <code>int64_t</code> argument. The format had to change from <code>%x</code> (<code>int</code>) to <code>%lx</code> (<code>int64_t</code>) to print the longer value.</p>
<p>Investigation for the reader: try changing <code>%lx</code> to <code>%x</code> in the example and see what you get.</p>
<h3 id="h2-501621c04-0006">Unsigned Integer Types</h3>
<p class="BodyFirst">In the last section, we used signed integer types, which can be either positive or negative. Unsigned integer types hold only positive values and are simpler than their signed counterparts. The standard unsigned types are <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, and <code>uint64_t</code>. The type <code>uint8_t</code> is an unsigned 8-bit integer that can hold numbers from 0 (0000 0000b) to 255 (1111 1111b). The ranges of the unsigned integer types are shown in <a href="#table4-4" id="tableanchor4-4">Table 4-4</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-4">Table 4-4</a>: Unsigned Integer Type Ranges</p></figcaption>
<table id="table-501621c04-0004" border="1">
<thead>
<tr>
<td><b>Type</b></td>
<td><b>Low</b></td>
<td><b>High</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>uint8_t</code></td>
<td>0000 0000 (0)</td>
<td>1111 1111 (255)</td>
</tr>
<tr>
<td><code>uint16_t</code></td>
<td>0000 0000 0000 0000 (0)</td>
<td>1111 1111 1111 1111 (65,535)</td>
</tr>
<tr>
<td><code>uint32_t</code></td>
<td>0000 0000 0000 0000 0000 0000 0000 0000 (0)</td>
<td>1111 1111 1111 1111 1111 1111 1111 1111 (4,294,967,295)</td>
</tr>
<tr>
<td><code>uint64_t</code></td>
<td>0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 (0)</td>
<td>1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 (18,446,744,073,709,551,615)</td>
</tr>
</tbody>
</table>
</figure>
<p>Here’s a simple example of using a <code>uint8_t</code> variable. This program prints three different representations for <code>smallNumber</code> without changing its value:</p>
<pre><code>/*
 * Simple use of uint8_t
 */

#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main()
{
    uint8_t smallNumber = 0x12; // A small number

    printf("0x12 is %u decimal\n", smallNumber);
    printf("0x12 is %o octal\n", smallNumber);
    printf("0x12 is %x hex\n", smallNumber);
    return(0);
}</code></pre>
<p><span epub:type="pagebreak" title="63" id="Page_63"/>The <code>%u printf</code> specification tells C we want to print an unsigned <code>int</code> (the default unsigned integer type). We use the format specification <code>%o</code> to print in octal and <code>%x</code> to print in hexadecimal.</p>
<p>The output of this program looks like this:</p>
<pre><code>0x12 is 18 decimal
0x12 is 22 octal
0x12 is 12 hex</code></pre>
<h3 id="h2-501621c04-0007">Overflow</h3>
<p class="BodyFirst">Now we will explore the limits of our machine. Actually, we will exceed them. The biggest <code>uint8_t</code> number is 255 (0b1111 1111). What happens when we go beyond that and try to print 255 + 1? Let’s try it:</p>
<pre><code>/*
 * See what happens when we exceed the maximum number.
 * (Contains a mistake)
 */
 
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
 
int main()
{
    // Very small integer, set to the maximum
    uint8_t smallNumber = 255;

  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> printf("255+1 is %u\n", smallNumber + 1);
    return (0);
}</code></pre>
<p>According to this program, the result of adding 1 to the 8-bit unsigned integer 255 is 256, but the number 256 in binary is 0b1 0000 0000, or 0x100, which can’t fit in 8 bits. Either we’ve warped the laws of the universe or something went wrong with our program.</p>
<p>To understand what’s going on, let’s take a look at the print statement <span class="CodeAnnotation" aria-label="annotation1">1</span>. The type of <code>smallNumber</code> is <code>uint8_t</code>; however, on most 32-bit computers, it’s hard, if not impossible, to add two 8-bit integers. Because of the way the computer is constructed, you have to add two 32-bit numbers. So, to compute an expression, the C compiler does the following:</p>
<ol class="decimal">
<li value="1">Converts <code>shortNumber</code> to a <code>unit32_t</code> value</li>
<li value="2">Adds 1 to the result (of type <code>uint32_t</code>)</li>
<li value="3">Prints the result (256) as a <code>uint32_t</code></li>
</ol>
<p>The result is a <code>uint32_t</code> that can hold the value 256, and that’s what’s printed. So, we did not cause an 8-bit overflow (which we wanted to demonstrate). Instead, we demonstrated automatic promotion, which we discussed earlier in this chapter.</p>
<p><span epub:type="pagebreak" title="64" id="Page_64"/>To get the result we want, we need to make a slight adjustment to the program to store the result in a <code>uint8_t</code> value (I’ve highlighted the changes to our program in bold):</p>
<pre><code>/*
 * See what happens when we exceed the maximum number.
 */

#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main()
{
    uint8_t smallNumber;
<b>    uint8_t result;</b>

    smallNumber = 255;
    <b>result = smallNumber + 1;</b>
    printf("255+1 is %d\n", <b>result</b>);
    return (0);
}</code></pre>
<p>Now the result is 0. Why? Because our calculation returned 0b1111 1111 + 0b000 0001 = 0b1 <b>0000 0000</b>. Only the bold portion was stored due to the limited space in which to store the variable.</p>
<p><em>Overflow</em> occurs when the result is too big for the machine to handle. In this case, the 9-bit result won’t fit in an 8-bit value. Think of a car’s odometer. It can display mileage to 999,999. What happens if someone drives a million miles?</p>
<p>Understanding how the compiler is manipulating the numbers is key to making good embedded programs. For example, I once had a GPS that kept altitude as an unsigned number. (It was not designed to work on submarines.) I took it on a trip to Death Valley, and it died. That’s because when I reached Badwater Basin, elevation –282 feet, it couldn’t handle the negative altitude. The GPS’s designers had assumed that all altitudes would be greater than zero. After all, the GPS was not designed to work underwater. Therefore, using an unsigned integer for altitude was not an unreasonable decision—except for users in locations like Badwater Basin, where the altitude is negative, causing the GPS to die. This mistake shows why it’s important to know the limitations of your numbering system.</p>
<h3 id="h2-501621c04-0008">Two’s Complement Representation in Signed Integer Types</h3>
<p class="BodyFirst">Signed numbers are represented by using one bit (the leftmost) as a sign bit: if the bit is 1, the number is negative. Thus, 8-bit signed integers (<code>int8_t</code>) can represent numbers from 127 to –128.</p>
<p>Almost all computers today use two’s complement numbers to represent negative values. <em>Two’s complement representation</em> stores a number as that number pre-subtracted from 0.</p>
<p><span epub:type="pagebreak" title="65" id="Page_65"/>For example, –1 can be determined by the following calculation:</p>
<pre><code> 0000 0000
-0000 0001
 ---------
 1111 1111</code></pre>
<p>This works because the computer adds a magic “borrow” bit to the left of the number, making the arithmetic look like this:</p>
<pre><code> 1 0000 0000
-  0000 0001
   ---------
   1111 1111</code></pre>
<p>Two’s complement is similar to a mechanical car odometer. Let’s say you buy a brand-new car and its odometer reads 000,000. If you drove backward, your odometer would read 999,999, which is the ten’s complement of –1.</p>
<p>You may have noticed that the biggest number a <code>uint8_t</code> can hold is 255, whereas an <code>int8_t</code> can store only values up to 127 (half that). That’s because one bit is used as the sign bit, leaving only seven bits to store the number part.</p>
<p>What happens when we exceed the boundaries with 8-bit signed numbers? I’m going to let you investigate that yourself. See what happens with the operations 127 + 1 and –128 – 1. Also see what happens with –(–128), the negation of –128.</p>
<h2 id="h1-501621c04-0003">Shorthand Operators</h2>
<p class="BodyFirst">You’ve learned about integers and the simple operations that can be done on them, but to let you do arithmetic faster, C provides a number of shorthand operators.</p>
<p>For example, consider adding a value to a number, like this:</p>
<pre><code>aNumber = aNumber + 5;</code></pre>
<p>You can shorten this operation to the following:</p>
<pre><code>aNumber += 5;</code></pre>
<p>You can perform similar shortcuts for all the other arithmetic operators. </p><p>Additionally, you can condense the operation of adding 1 to a number:</p>
<pre><code>aNumber += 1;</code></pre>
<p>It can be shortened to this:</p>
<pre><code>++aNumber;</code></pre>
<p><span epub:type="pagebreak" title="66" id="Page_66"/>To decrement numbers by 1, use the <code>--</code> (minus minus) operator.</p>
<p>There is a caveat. C lets you combine the increment (<code>++</code>) and decrement (<code>--</code>) operations with other statements:</p>
<pre><code>result = ++aNumber;   // Don't do this.</code></pre>
<p>Please don’t do this, as it can cause the program to have undefined behavior. For example, consider the following statements:</p>
<pre><code>aNumber = 2;
result = ++aNumber * ++aNumber + ++aNumber;</code></pre>
<p>The second statement tells C to increment <code>aNumber</code>, then increment <code>aNumber</code> again. It then multiplies <code>aNumber</code> with itself and increments <code>aNumber</code> a third time. Finally, it adds this to the result.</p>
<p>Unfortunately, nothing tells C that these operations have to occur in the order I’ve listed here. For example, all the increments could come at the beginning, making the result (5 × 5 + 5) = 30. Or they could come one at a time, and we would have (3 × 4 + 5) = 17. For those reasons, be sure to put <code>++</code> and <code>--</code> on lines by themselves.</p>
<p>One more thing: there are two forms of increment and decrement operations. You can place the operator either before or after the variable you would like to increment:</p>
<pre><code>aNumber = 5;
result = ++aNumber;
aNumber = 5;
result = aNumber++;</code></pre>
<p>These do slightly different things. I leave it to the reader to write a small program to print the results of the preceding code and figure out what they do—and then please never again use <code>++</code> combined with another statement.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In C, the following two statements are equivalent:</p>
<pre><code>++aNumber;
aNumber++;</code></pre>
<p class="continued">For operations on simple numbers, there is no difference between these two operations. The good news is that C only lets you do <code>++</code> on simple numbers.</p>

<p class="continued">However, C++ allows you to define your own data types and, through operator overloading, define your own <code>++</code> and <code>--</code> operations. When you are dealing with a complex C++ object, the prefix version is much more efficient in most cases, so it is a good idea to get into the habit of using the first form just in case you need to step into the world of C++.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501621c04-0004"><span epub:type="pagebreak" title="67" id="Page_67"/>Controlling Memory-Mapped I/O Registers Using Bit Operations</h2>
<p class="BodyFirst">We can organize eight bits into a single number, but these bits can also represent eight different things. For example, they can be wired to eight different LED lights. In fact, when you place values in special memory locations called <em>memory-mapped I/O registers</em>, these values turn on or off I/O pins. Since there are eight bits to the register’s byte, a single register can control eight LEDs. (Or, in our case, one LED and seven pins on which we can add more LEDs.)</p>
<p>Bits are normally numbered from 7 to 0, with 7 being the leftmost, or most significant, bit. Let’s say our LED register is set up as follows:</p>
<table id="tabular-501621c04-0005" border="1"><tbody>
<tr>
<td>Bit 7</td>
<td>Bit 6</td>
<td>Bit 5</td>
<td>Bit 4</td>
<td>Bit 3</td>
<td>Bit 2</td>
<td>Bit 1</td>
<td>Bit 0</td>
</tr>
</tbody>
<tbody>
<tr>
<td>Out 7</td>
<td>Out 6</td>
<td>Out 5</td>
<td>Out 4</td>
<td>Out 3</td>
<td>Out 2</td>
<td>Out 1</td>
<td>LED 0</td>
</tr>
</tbody>
</table>
<p>Say we want to turn on LED #0. As each LED is off, our register has the value  0000 0000 in it. To turn on LED #0, we need to flip the final bit to a value of 1. To do that, we just add 1 to the register to get 0000 0001. LED #0 turns on and all the others stay off.</p>
<p>But what if the LED was already on? Then our register would contain 0000 0001, and when we add 1, we’ll get 2, which in binary is 0000 0010. Thus, LED #0 turns off and OUT #1 turns on. Not what we wanted.</p>
<p>The problem here is that the arithmetic operators we’ve been using treat our 8-bit integer as a single integer. The <em>bitwise operators</em> treat the number as a set of individual bits, each of which can be turned on, turned off, and tested independently.</p>
<h3 id="h2-501621c04-0009">OR</h3>
<p class="BodyFirst">The first bitwise operator is <em>OR</em> (<code>|</code>). The single-bit version of OR gives a true (or 1) result if either of its two operands is set to 1. I’m going to show how it operates using a <em>truth table</em>. It’s like the addition and multiplication tables you used in first grade, only it shows the operation of Boolean operators such as OR.</p>
<p>The truth table for OR looks like this:</p>
<table id="tabular-501621c04-0006" border="1"><tbody>
<tr>
<td>OR (<code>|</code>)</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>OR is a bitwise operator, which means that to “OR” two 8-bit values together, you perform the operation for each pair of bits in the two values. For example:</p>
<pre><code>  0010 0101
| 0000 1001
  ---------
  0010 1101</code></pre>
<p><span epub:type="pagebreak" title="68" id="Page_68"/>To set bit 0 (that is, to turn on LED #0), we use the following C code:</p>
<pre><code>ledRegister = ledRegister | 0x01;</code></pre>
<p>Alternatively, we can use the following shorthand operator:</p>
<pre><code>ledRegister |= 0x01;</code></pre>
<h3 id="h2-501621c04-0010">AND</h3>
<p class="BodyFirst">The <em>AND</em> (<code>&amp;</code>) operator returns a true (1) only if both of its operands are true. The following is the AND truth table:</p>
<table id="tabular-501621c04-0007" border="1"><tbody>
<tr>
<td>AND (<code>&amp;</code>)</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Like OR, the AND operator works on each pair of bits:</p>
<pre><code>  0010 0101
&amp; 0000 1001
  ---------
  0000 0001</code></pre>
<p>To turn off LED #0, we can set bit 0 to a value of 0 with the following operation:</p>
<pre><code>ledRegister &amp;= 0b11111110;</code></pre>
<p>This command “ANDs” our register with a bit pattern that has every bit set <em>except</em> bit 0, so bit 0 will be cleared and all the other bits will be unchanged. (ANDing a bit with 1 keeps its value.)</p>
<h3 id="h2-501621c04-0011">NOT</h3>
<p class="BodyFirst">The <em>invert</em>, or <em>NOT</em>, operator (<code>~</code>) takes one operand and inverts it. Thus, if the bit is 0, it becomes 1, and if it’s 1, it becomes 0. The truth table for the NOT operator is rather simple:</p>
<table id="tabular-501621c04-0008" border="1"><tbody>
<tr>
<td/>
<td>0</td>
<td>1</td>
</tr>
</tbody>
<tbody>
<tr>
<td><code>~</code></td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates how this operator works:</p>
<pre><code>~ 0000 0001
  ---------
  1111 1110</code></pre>
<p><span epub:type="pagebreak" title="69" id="Page_69"/>Using the bitwise operators we’ve covered so far, we can already write some code to turn off all registers and then turn on and off the LED:</p>
<pre><code>const uint8_t LED_BIT = 0b0000001;

// Turn off everything.
ledRegister = 0;

// Turn on the LED.
ledRegister |= LED_BIT;

// Wait a while.
sleep(5);

// Turn off the LED.
ledRegister &amp;= ~LED_BIT;</code></pre>
<p>This is exactly what the blink program from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> was doing, except that the STM library hid these details from us.</p>
<h3 id="h2-501621c04-0012">Exclusive OR</h3>
<p class="BodyFirst">The result of the bitwise operator <em>exclusive OR</em> (<code>^</code>) is true if one or the other bit is set, but not both. Here is its truth table:</p>
<table id="tabular-501621c04-0009" border="1"><tbody>
<tr>
<td>Exclusive OR (<code>^</code>)</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>To see how it works, consider the following example:</p>
<pre><code>  0010 0101
^ 0000 1001
  ---------
  0010 1100</code></pre>
<p>Exclusive OR is useful if we want to invert the value of the LED in our <code>ledRegister</code>, like this:</p>
<pre><code>ledRegister ^= LED_BIT; // Toggle the LED bit.</code></pre>
<p>Inverting an LED makes it blink slowly.</p>
<h3 id="h2-501621c04-0013">Shifting</h3>
<p>The <em>left shift</em> operator (<code>&lt;&lt;</code>) shifts the contents of a variable to the left by a given number of bits, filling in zeros for the missing bits. For example, consider the following operation:</p>
<pre><code>uint8_t result = 0xA5 &lt;&lt; 2</code></pre>
<p><span epub:type="pagebreak" title="70" id="Page_70"/>This causes the computer to move the bits two places to the left so that the following:</p>
<pre><code>1010 0101</code></pre>
<p class="BodyContinued">becomes this:</p>
<pre><code>1001 0100</code></pre>
<p>The <em>right shift</em> operator (<code>&gt;&gt;</code>) is a little more tricky. For unsigned numbers, it works just like the left shift, except it shifts the bits in the rightward direction. Again, the computer fills in zeros for the missing bits. Thus, <code>uint8_t result = 0xA5 &gt;&gt; 2;</code> would be computed so that the following:</p>
<pre><code>1010 0101</code></pre>
<p class="BodyContinued">becomes this:</p>
<pre><code>0010 1001</code></pre>
<p>But when the number is signed, the computer uses the sign bit to supply the missing bits. For example, consider the following operation:</p>
<pre><code>int8_t result = 0xA5 &gt;&gt; 2;  // Note the lack of "u"</code></pre>
<p>This would be computed such that the following:</p>
<pre><code>1010 0101</code></pre>
<p class="BodyContinued">becomes this:</p>
<pre><code>1110 1001</code></pre>
<p>Because it’s a signed number shifting right, the missing bits on the right side are filled in with copies of the sign bit, so the result is 0xE9, which is –23.</p>
<h2 id="h1-501621c04-0005">Defining the Meaning of Bits</h2>
<p class="BodyFirst">Hardware people love defining things in terms of bits. That’s because when the signals come out of the chip, they leave from single pins on the hardware that have names like GPIO A-3 (which means GPIO register A, bit 3). As the signal on a single pin is either <em>high</em> (1) or <em>low</em> (0), you can represent it with a single bit.</p>
<p>But by the time the programmer sees the signal, it has been bundled with a bunch of others into an 8-bit, 16-bit, or 32-bit register. Therefore, we need a way of easily translating hardware speak (like “bit 3”) into software speak (such as “0x04”). The shift operators, properly used, can be a big help with this translation.</p>
<p><span epub:type="pagebreak" title="71" id="Page_71"/>For example, let’s say we have a light board whose hardware specification is the following:</p>
<pre><code>+----+----+----+----++----+----+----+----+
|  7 |  6 |  5 |  4 ||  3 |  2 |  1 |  0 |
| MF | DF | OL | OP || PW | PF | AP | CF |
+----+----+----+----++----+----+----+----+</code></pre>
<ol class="none">
<li><span class="RunInHead">MF (bit 7)</span>  Master fail: Lights when any other failure light gets lit.</li>
<li><span class="RunInHead">DF (bit 6)</span>  Data fail: Incoming data is inconsistent or corrupt.</li>
<li><span class="RunInHead">OL (bit 5)</span>  Oil low: The oil level in the accumulator is low.</li>
<li><span class="RunInHead">OP (bit 4)</span>  Oil pressure: The accumulator oil pressure is low.</li>
<li><span class="RunInHead">PW (bit 3)</span>  Power failure: The main power supply has failed.</li>
<li><span class="RunInHead">PF (bit 2)</span>  Position fault: The position frame has hit a limit switch and is not where it is supposed to be.</li>
<li><span class="RunInHead">AP (bit 1)</span>  Air pressure: The air compressor has failed.</li>
<li><span class="RunInHead">CF (bit 0)</span>  Clean filter: The filter to the air compressor needs cleaning.</li>
</ol>
<p>Each of these bits is connected to a light. The light circuit is wired to the GPIO pins of our controller. For example, if we set bit 0 of the GPIO device, the “Clean Filter” light will come on:</p>
<pre><code>ledRegister = 1;  // Turn on clean filter.
                  // (Turn all others off.)</code></pre>
<p>Even so, it’s still not easy to remember which number goes with which bit. Bit 0 is the first value, bit 1 is the second value, and so on. Quick: Which bit is represented by the 6th value? There is a nice way of making this easier. Bit 0 holds value 1, which is equivalent to the expression <code>(1 &lt;&lt; 0)</code>. Bit 1 is value 2, which is <code>(1 &lt;&lt; 2)</code>, and bit 3 is <code>(1 &lt;&lt; 3)</code>, and so on. From this, it’s easy to see that bit 5 is <code>(1 &lt;&lt; 5)</code>. Using this system, we can define constants to represent each bit:</p>
<pre><code>const uint8_t MASTER_FAIL       = (1 &lt;&lt; 7);
const uint8_t DATA_FAIL         = (1 &lt;&lt; 6);
const uint8_t OIL_LOW           = (1 &lt;&lt; 5);
const uint8_t OIL_PRESSURE      = (1 &lt;&lt; 4);
const uint8_t POWER_FAILURE     = (1 &lt;&lt; 3);
const uint8_t POSITION_FAULT    = (1 &lt;&lt; 2);
const uint8_t AIR_PRESSURE      = (1 &lt;&lt; 1);
const uint8_t CLEAN_FILTER      = (1 &lt;&lt; 0);</code></pre>
<p>Let’s once again turn on the <code>CLEAN_FILTER</code> LED and leave all the others alone, this time using our new constant to reference the relevant bit:</p>
<pre><code>ledRegister |= CLEAN_FILTER; // Turn on clean filter.</code></pre>
<p><span epub:type="pagebreak" title="72" id="Page_72"/>Notice here that we also used the <code>|=</code> shorthand operator introduced earlier in this chapter.</p>
<h3 id="h2-501621c04-0014">Setting the Values of Two Bits at Once</h3>
<p class="BodyFirst">Now let’s say we want to set the values of both <code>POWER_FAILURE</code> and <code>MASTER_FAIL</code>. We can accomplish that with the following statement:</p>
<pre><code>ledRegister |= MASTER_FAIL | POWER_FAILURE;</code></pre>
<p>Since <code>MASTER_FAIL</code> has a value of 1 in bit 7, and any nonzero value results in a value of 1, the <code>MASTER_FAIL</code> bit will be set in the panel.</p>
<h3 id="h2-501621c04-0015">Turning Off a Bit</h3>
<p class="BodyFirst">We use the following pattern to turn off a bit:</p>
<pre><code>bitSet &amp;= ~bitToTurnOff;</code></pre>
<p>To understand how this operation works, let’s go through it in detail using the following statement:</p>
<pre><code>ledRegister &amp;= ~(MASTER_FAIL | POWER_FAILURE);</code></pre>
<p>Let’s start with the result of <code>(MASTER_FAIL | POWER_FAIL)</code>:</p>
<pre><code>1000 1000 (MASTER_FAIL | POWER_FAIL)</code></pre>
<p>Now we apply the invert or NOT (<code>~</code>) operator:</p>
<pre><code>0111 0111 ~(MASTER_FAIL|POWER_FAIL)</code></pre>
<p>Next, we take a look at the existing value of <code>ledRegister</code>. For this example, it has <code>MASTER_FAIL</code> and <code>CLEAN_FILTER</code> set.</p>
<pre><code>1000 0001 (ledRegister: MASTER_FAIL, CLEAN_FILTER)</code></pre>
<p>Now we “AND” the results together:</p>
<pre><code>0111 0111 ~(MASTER_FAIL|POWER_FAIL)
1000 0001 (ledRegister: MASTER_FAIL, CLEAN_FILTER)
Result:  0000 0001 (CLEAN_FILTER)</code></pre>
<h3 id="h2-501621c04-0016">Checking the Values of Bits</h3>
<p class="BodyFirst">The following program shows a typical use of <em>bit-banging</em>, the art of turning on and off individual bits. It also contains logic to check the values of the different bits:</p>
<pre><code>/*
 * Program to demonstrate the use of bit operations
<span epub:type="pagebreak" title="73" id="Page_73"/> */
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

//&lt; Master fail -- shows if any other error is present.
const uint8_t MASTER_FAIL       = (1 &lt;&lt; 7);
//&lt; Indicates that inconsistent data was received.
const uint8_t DATA_FAIL         = (1 &lt;&lt; 6);
//&lt; Oil container is low.
const uint8_t OIL_LOW           = (1 &lt;&lt; 5);
//&lt; Oil pressure is low.
const uint8_t OIL_PRESSURE      = (1 &lt;&lt; 4);
//&lt; Main power supply failed.
const uint8_t POWER_FAILURE     = (1 &lt;&lt; 3);
//&lt; We told the position to go to x and it didn't.
const uint8_t POSITION_FAULT    = (1 &lt;&lt; 2);
//&lt; Air compressor stopped.
const uint8_t AIR_PRESSURE      = (1 &lt;&lt; 1);
//&lt; Air filter has reached end of life.
const uint8_t CLEAN_FILTER      = (1 &lt;&lt; 0);
/*!
 * Prints the state of the bits
 * (Substitutes for a real LCD panel)
 *
 * \param ledRegister Register containing the LED bits
 */
static void printLED(const uint8_t ledRegister)
{
    printf("Leds: ");
    if ((MASTER_FAIL &amp; ledRegister) != 0)
        printf("MASTER_FAIL ");
    if ((DATA_FAIL &amp; ledRegister) != 0)
        printf("DATA_FAIL ");
    if ((OIL_LOW &amp; ledRegister) != 0)
        printf("OIL_LOW ");
    if ((OIL_PRESSURE &amp; ledRegister) != 0)
        printf("OIL_PRESSURE ");
    if ((POWER_FAILURE &amp; ledRegister) != 0)
        printf("POWER_FAILURE ");
    if ((POSITION_FAULT &amp; ledRegister) != 0)
        printf("POSITION_FAULT ");
    if ((AIR_PRESSURE &amp; ledRegister) != 0)
        printf("AIR_PRESSURE ");
    if ((CLEAN_FILTER &amp; ledRegister) != 0)
        printf("CLEAN_FILTER ");
    printf("\n");
}

int main()
{
    uint8_t ledRegister = 0x00;         // Start with all off.

    printLED(ledRegister);

    // Power went out.
<span epub:type="pagebreak" title="74" id="Page_74"/>    ledRegister |= POWER_FAILURE | MASTER_FAIL;
    printLED(ledRegister);

    // Now the air went out.
    ledRegister |= AIR_PRESSURE;
    printLED(ledRegister);

    // Power back, air out, so master is on.
    ledRegister &amp;= ~POWER_FAILURE;
    printLED(ledRegister);
    return (0);
}</code></pre>
<p>Let’s start by looking at the <code>printLED</code> function, which contains a bunch of lines that test each individual bit and print a message if it is set. (You’ll learn about the <code>if</code> statements used to do this in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.) To understand the logic of the test, take a look at the following statement:</p>
<pre><code>if ((MASTER_FAIL &amp; ledRegister) != 0)
    printf("MASTER_FAIL ");</code></pre>
<p>The message will print if the expression on the first line is not equal to 0. Because the expression uses the AND operator, each bit in <code>ledRegister</code> must match the corresponding bit in <code>MASTER_FAIL</code> for that bit to have a value of 1. If at least one set of bits both have a value of 1, the <code>printf</code> is executed. In other words, behind the scenes, the operation looks something like this:</p>
<pre><code>  1000 0000 (MASTER_FAIL)
&amp; 1000 0001 (ledRegister with MASTER_FAIL and CLEAN_FILTER set)
  ---------
= 1000 0000 (Since this is not zero, print "MASTER FAIL")</code></pre>
<p>The entire function will perform a similar test and print every bit that’s set in the register. This function is used here because we don’t have a hardware light panel and we want to see what’s happening.</p>
<p>Later in the program, we play with the bits. For example, we simulate a power failure by turning on the <code>POWER_FAILURE</code> and _<code>MASTER_FAIL</code> bits. Thus, when we print the LEDs now, we get the following message:</p>
<pre><code>Leds: MASTER_FAIL POWER_FAILURE</code></pre>
<p>The rest of the program sets and clears the various bits to produce the following messages:</p>
<pre><code>Leds:
Leds: MASTER_FAIL POWER_FAILURE
Leds: MASTER_FAIL POWER_FAILURE AIR_PRESSURE
Leds: MASTER_FAIL AIR_PRESSURE</code></pre>
<h2 id="h1-501621c04-0006"><span epub:type="pagebreak" title="75" id="Page_75"/>Summary</h2>
<p class="BodyFirst">This chapter covered what you can do with simple integers. There’s the usual add, subtract, multiply, and divide, but you also saw how a computer stores the data and, most importantly, what happens when you run into problems like overflow.</p>
<p>You also learned about bit manipulation, where you treat an integer as a group of 8, 16, or 32 bits. This is very important because embedded programmers frequently deal with bitmapped registers. For example, the GPIO register we used to turn on and off our LED contains bits for 31 other GPIOs. The other 31 pins are entirely unrelated to our LED and have other functions (or they would have if we wired them to anything).</p>
<p>In the next chapter, you’ll learn how to make decisions based on those computations.</p>
<h2 id="h1-501621c04-0007">Programming Problems</h2>
<ol class="decimal">
<li value="1">The largest <code>int16_t</code> value is 32,767. Write a program to find out what the <code>int16_t</code> value of 32,767 + 1 is.</li>
<li value="2">There is a serial I/O register that contains a 2-bit value for the parity, as specified here:<pre><code>+----+----+----+----++----+----+----+----+
|  7 |  6 |  5 |  4 ||  3 .  2 |  1 .  0 |
| IE | TE | RD | BR || Parity  | X Bits  |
+----+----+----+----++----+----+----+----+</code></pre>
<ol class="lower-alpha">
<li value="1">Write an expression to extract the parity-checking number (in the range 0 to 3) from the register. The parity is stored in bits 2 and 3 as a 2-bit unsigned binary number.</li>
<li value="2">Write code to set the value to 2 (binary 0x10).</li>
</ol>
</li>
</ol>
</section>
</body></html>