- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MONGODB
    AND MONGOOSE</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most applications rely on a database management system, or *database* for short,
    to organize and grant access to a collection of datasets. In this chapter, you’ll
    work with the MongoDB non-relational database and Mongoose, its accompanying object
    mapper.
  prefs: []
  type: TYPE_NORMAL
- en: Because MongoDB returns data as JSON and uses JavaScript for database queries,
    it provides a natural choice for full-stack JavaScript developers. In the following
    sections, you’ll learn how to create a Mongoose model through which you can query
    your database, simplify your interactions with MongoDB, and craft middleware that
    connects your frontend to your backend database. You’ll also write service functions
    to implement the four CRUD operations on the database.
  prefs: []
  type: TYPE_NORMAL
- en: In [Exercise 7](#Exe7) on page 125, you’ll add a database to the GraphQL API
    you created in [Chapter 6](chapter6.xhtml), replacing its current static datastore.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Apps Use Databases and Object-Relational
    Mappers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An app needs a database to store and manipulate data. So far in this book, our
    app’s APIs returned only predefined datasets, saved in files, that couldn’t change.
    We used parameters in our requests to add to the dataset but couldn’t store the
    data between different API calls (called *persisting* the data). If we wanted
    to update the app’s weather information, for example, we’d need a database to
    persist the data so that the next API call could read it. In full-stack development,
    we commonly use databases to store user-related data. Another example of a database
    is the one that your email client uses to store your messages.
  prefs: []
  type: TYPE_NORMAL
- en: To work with a database, we first need to connect to it and authenticate with
    it. Once we have access to the data, we can execute queries to ask for certain
    datasets. The query returns the results containing data that our app can display
    or use in some other way. How each of these steps works in practice depends on
    the specific database in use.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the data by using the database’s API tends to be clumsy because it
    usually requires a good amount of boilerplate code, even to simply establish and
    maintain the connection. Hence, we often use an *object-relational mapper* or
    *object data modeling tool*, which simplifies working with the databases by abstracting
    some of the details. For example, the Mongoose object data modeling tool for MongoDB
    handles database connections for us, saving us from having to check for an open
    database connection during each interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose also makes it easier to handle the fact that MongoDB runs on a separate
    database server. Working with distributed systems requires making asynchronous
    calls, which you learned about in [Chapter 2](chapter2.xhtml). With Mongoose,
    we can access the data with an object-oriented <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> interface instead of using
    clumsy callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, MongoDB is schema-less; it doesn’t require us to predefine and
    strictly adhere to a schema. While convenient, this flexibility is also a common
    source of errors, especially in large-scale applications or projects with a rotating
    cast of developers. In [Chapter 3](chapter3.xhtml), we discussed the benefits
    of adding types to JavaScript by using TypeScript. Mongoose types and verifies
    the integrity of MongoDB’s data models similarly, as you’ll discover in “Defining
    a Mongoose Model” on page 118.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Relational and Non-Relational Databases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Databases can organize data in several ways, which fall into two main categories:
    relational and non-relational. *Relational databases*, such as MySQL and PostgreSQL,
    store data in one or more tables. You can think of these databases as resembling
    Excel spreadsheets. As in Excel, each table has a unique name and contains columns
    and rows. The columns define properties, such as the data type, for all data stored
    in the column, and the rows contain the actual datasets, each of which is identified
    by a unique ID. Relational databases use some variation of Structured Query Language
    (SQL) for their database operations.'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is a *non-relational database*. Unlike traditional relational databases,
    it stores data as JSON documents instead of tables and doesn’t use SQL. Sometimes
    termed *NoSQL*, non-relational databases can store data in many different formats.
    For example, the popular NoSQL databases Redis and Memcached use key-value storage,
    which makes them highly performant and easily scalable. Thus, they’re often used
    as in-memory caches. Another NoSQL database, Neo4j, is a *graph database* that
    uses graph theory to store data as nodes, a concept we mentioned in [Chapter 6](chapter6.xhtml).
    These are just a few examples of non-relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is the most widely used *document database*; instead of tables, rows,
    and columns, it organizes data in collections, documents, and fields. The *field*
    is the smallest unit in the database. It defines the data type and additional
    properties and contains the actual data. You can consider it the rough equivalent
    of a column in a SQL table. *Documents*, which are made of fields, are like rows
    in a SQL table. We sometimes call them records, and MongoDB uses *BSON*, a binary
    representation of a JSON object, to store them. A *collection* is roughly equivalent
    to a SQL table, but instead of rows and columns, it aggregates documents.
  prefs: []
  type: TYPE_NORMAL
- en: Because non-relational databases can store data in different formats, each database
    uses a specific, optimized query language for CRUD operations. These low-level
    APIs focus on accessing and manipulating the data, and not necessarily on the
    developer experience. By contrast, object-relational mappers provide a high-level
    abstraction with a clean and simplified interface to the query language. So, while
    MongoDB has the MongoDB Query Language (MQL), we’ll use Mongoose to access it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up MongoDB and Mongoose</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start using MongoDB and Mongoose, you must add them to your sample
    project. For the sake of simplicity, we’ll use an in-memory implementation of
    MongoDB rather than install and maintain a real database server on our machines.
    This is appropriate for testing the chapter’s examples, but not for deploying
    an actual application, as it does not persist the data between restarts. You’ll
    gain experience setting up a real MongoDB server when you build the Food Finder
    application in [Part II](part2.xhtml). [Chapter 11](chapter11.xhtml) will show
    you how to use a pre-built Docker container that contains the MongoDB server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command in the root directory of the refactored Next.js app from [Chapter
    6](chapter6.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create two new folders in the root directory, next to the *package .json*
    file: one for the Mongoose code, called *mongoose*, with subfolder *weather*,
    and one called *middleware*, which will hold the necessary middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defining a Mongoose Model</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to verify the integrity of our data, we must create a schema-based
    Mongoose *model*, which acts as a direct interface to a MongoDB collection in
    a database. All interactions with the database will happen through the model.
    Before we create the model, though, we need to create the schema itself, which
    defines the structure of the database’s data and maps the Mongoose instance to
    the documents in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Our Mongoose schema will match the schema created for the GraphQL API in [Chapter
    6](chapter6.xhtml). That’s because we’ll connect the GraphQL API to the database
    in [Exercise 7](#Exe7) on page 125, allowing us to replace the static JSON object
    with datasets we queried from the database.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Interface</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before writing the Mongoose model and schema in TypeScript, let’s declare a
    TypeScript interface. Without a matching interface, we won’t be able to type the
    model or schema for TSC, and the code won’t compile. Paste the code shown in [Listing
    7-1](chapter7.xhtml#Lis7-1) into the *mongoose/weather/interface.ts* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: The interface for the Mongoose weather model'
  prefs: []
  type: TYPE_NORMAL
- en: The code is a regular TypeScript interface with properties matching the GraphQL
    and Mongoose schemas.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Schema</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 7-2](chapter7.xhtml#Lis7-2) shows the Mongoose schema. Its top-level
    properties represent the fields in the document. Each field has a type and a flag
    indicating whether it is required. Fields can also have additional optional properties,
    such as custom or built-in validators. Here we use the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">required</samp>
    validator; other common built-in validators are <samp class="SANS_TheSansMonoCd_W5Regular_11">minlength</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">maxlength</samp> for strings,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">min</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    for numbers. Add the code to the *mongoose/weather/schema.ts* file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: The schema for the Mongoose weather model'
  prefs: []
  type: TYPE_NORMAL
- en: We use an object passed to the schema constructor to create the schema and set
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> as its SchemaType.
    Therefore, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp>
    function from the *mongoose* package and the interface we created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Like TypeScript, which adds custom types to JavaScript, Mongoose casts each
    property to its associated *SchemaType*, which provides the configuration of the
    model. The available types are a mixture of built-in JavaScript types, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Array</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Date</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Number</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>, and custom types,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectId</samp>,
    the latter of which refers to the default unique <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>
    property that Mongoose adds to each document upon creation. This is similar to
    the primary key you might know from relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The weather API we created in [Chapter 6](chapter6.xhtml) returned an object
    with four properties: <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tempF</samp>, each of which
    is a string. In addition, we have one array of strings in the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    property. In this schema, we define the same properties, then export the schema.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Model</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have a schema, we can create the Mongoose model. This wrapper on
    the schema will provide access to the MongoDB documents in the collection for
    all CRUD operations. We write the model in the *mongoose/weather/model.ts* file,
    whose code is in [Listing 7-3](chapter7.xhtml#Lis7-3). Keep in mind that we haven’t
    yet connected it to the MongoDB database on the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: The Mongoose weather model'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we import the Mongoose module and the model constructor from the *mongoose*
    package, as well as the interface and the schema we created earlier. Then we set
    up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> model, using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> to type
    it. We pass it two parameters: the model’s name, <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>,
    and the schema, which defines the model’s internal data structure. Mongoose binds
    the newly created model to our MongoDB instance’s collection. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp>
    collection resides in the *Weather* database, both of which Mongoose creates.
    Note that we need to check for an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    model on <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.models</samp>
    before creating a new one; otherwise, Mongoose will throw an error. We export
    the model so that we can use it in our following modules.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Database-Connection
    Middleware</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Several times in this book so far, we’ve mentioned that full-stack development
    covers an application’s frontend, backend, and middleware, which is often also
    referred to as “application glue.” Now it’s time to create our first dedicated
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: This middleware will open a connection to the database, then use Mongoose’s
    asynchronous helper function to maintain that connection. Next, it will map Mongoose’s
    models to the MongoDB collections so that we can access them through Mongoose.
    Conveniently, the connection helper will buffer the operations and reconnect to
    the database if necessary, so we don’t need to handle connectivity issues by ourselves.
    Paste the code from [Listing 7-4](chapter7.xhtml#Lis7-4) into the *middleware/db-connect.ts*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: The Mongoose middleware'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *mongoose* package and the *mongodb-memory-server* database. The
    async function <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>,
    which we define and then export, manages the connection to the database server
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.connect</samp>
    function. We create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp>
    to persist our data in memory rather than use a real database server, as discussed.
    Then we store the connection string in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGOIO_URI</samp>.
    Because we are using the in-memory server, this string is dynamic, but for a remote
    database, it would be a static string representing the database’s server address.
    Then we close all existing connections and use Mongoose to open a new connection.
    The Mongoose models are already mapped and available, so we’re ready to perform
    our first queries.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Querying the Database</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it’s time to write database queries. Instead of sprinkling these queries
    around your application code or writing them directly in the GraphQL resolvers,
    you should extract them as services.
  prefs: []
  type: TYPE_NORMAL
- en: A *service* is a function that performs the actual CRUD operations on the Mongoose
    model and returns the result. Each GraphQL resolver can then call a service function,
    and all internal database access should happen through these functions. Moreover,
    each service should be responsible for only one specific CRUD operation. Mongoose
    automatically queues the commands and executes them, maintains the connection,
    and then processes the queue as soon as there is a connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces service functions and basic Mongoose commands. However,
    it isn’t a complete reference. When you start working with Mongoose on your own
    projects, look up all the functions you’ll need in the Mongoose documentation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Document</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first and most basic operation is the “create” operation. It is conveniently
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.create</samp> and,
    fortunately, we can use it to both create and update a dataset. That’s because
    Mongoose automatically creates a new database entry, or document, if the entry
    doesn’t already exist. Hence, we don’t need to check whether a dataset exists
    and then conditionally create it before updating it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](chapter7.xhtml#Lis7-5) shows a basic implementation of a service
    function that stores a dataset in the database. Place the code in the *mongoose/weather/
    services.ts* file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: Creating a document through Mongoose'
  prefs: []
  type: TYPE_NORMAL
- en: To store a document, we create and export the async function <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp>,
    which takes the dataset as the argument. Here we type it as <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>.
    Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function
    on the model and pass the dataset to it. The function will create and insert the
    document in <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>,
    which is the weather collection in the MongoDB instance. Finally, it returns a
    Boolean to indicate the status of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading a Document</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To implement the “read” operation, we query MongoDB through Mongoose’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp> function. It takes one
    argument, an object with the properties to look for, and returns the first match.
    Extend the *mongoose/weather/services.ts* file with the code in [Listing 7-6](chapter7.xhtml#Lis7-6).
    It defines a <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> function
    to find and return the first document from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp>
    collection whose <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> property
    matches the ZIP code passed to the function as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: Reading data through Mongoose'
  prefs: []
  type: TYPE_NORMAL
- en: We add and export the async function <samp class="SANS_TheSansMonoCd_W5Regular_11">readByZip</samp>
    to the services in the *services.ts* file. The function takes one string parameter,
    the ZIP code, and returns either an array with documents or an empty array. Inside
    the new service function, we call Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>
    function on the model and pass a filter object, looking for the document whose
    <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> field matches the parameter’s
    value. Finally, the function returns the result or <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating a Document</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We mentioned that we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp>
    function to update documents. However, there is also a specific API for this task:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>. It takes two arguments.
    The first is the filter object, similar to the filter we used with <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>,
    and the second is an object with the new values. You can think of <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>
    as a combination of the “find” and “create” functions. Extend the *mongoose/weather/services.ts*
    file with the code from [Listing 7-7](chapter7.xhtml#Lis7-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: Updating data through Mongoose'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp> function
    that we add to the services takes two parameters. The first one is a string, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">paramZip</samp>, which is the ZIP code
    we use to query for the document we want to update. The second parameter is the
    new dataset, which we type as <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>.
    We call Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>
    function on the model, passing it a filter object and the latest data. The function
    should return a Boolean to indicate the status.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Deleting a Document</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last CRUD operation we need to implement is a service to delete a document.
    For this, we use Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp>
    function and add the code from [Listing 7-8](chapter7.xhtml#Lis7-8) to the *mongoose/weather/services.ts*
    file. It is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>
    function, except that it directly deletes the query’s result. Mongoose queues
    the operations and deletes the document from the database automatically once there
    is a connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: Deleting data through Mongoose'
  prefs: []
  type: TYPE_NORMAL
- en: The async function <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteByZip</samp>
    takes one string parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>.
    We use it to query the model and find the document to delete, passing the filter
    to Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp> function.
    The function should return a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating an End-to-End Query</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In full-stack development, *end-to-end* typically refers to the ability of data
    to travel all the way from the app’s frontend (or from one of its APIs) through
    the middleware to the backend, and then all the way back to its original source.
    For practice, let’s create a simple end-to-end example using the */zipcode* endpoint
    of our REST API.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll modify the API to take the query parameter from the URL, find the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> object for the requested
    ZIP code in the database, and then return it, effectively replacing the static
    JSON response with a dynamic query result. Modify the file *pages/api/v1/weather/[zipcode].ts*
    to match [Listing 7-9](chapter7.xhtml#Lis7-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: The end-to-end REST API'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the modified API handler. We made two major changes to it. First we called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> to connect to the
    database. Then we used the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp>
    service and passed it the query parameter cast to a string type. Instead of the
    static JSON object as before, we now return the dynamic <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    that we receive from the service function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to perform one more step before we can receive data in response to
    the API call: *seeding* the database, or adding initial datasets to it. For simplicity,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocuments</samp>
    service and seed directly in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function. Modify the *middleware/db-connect.ts* file to match the code in [Listing
    7-10](chapter7.xhtml#Lis7-10), which imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp>
    service and adds the datasets after establishing the database connection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: The naive data seeding in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dbConnect</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can perform the end-to-end request. Visit the REST API endpoint in the
    browser at *http://localhost:3000/api/v1/weather/96815*. You should see the dataset
    from the MongoDB database as the API response. Try adjusting the query parameter
    in the URL to another valid ZIP code. You should get another dataset in the response.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7: Connect the GraphQL API
    to the Database</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s rework our weather application’s GraphQL API so that it reads the response
    data from the database instead of from a static JSON file. The code will look
    familiar, as we’ll use the same patterns as for the REST API example in the preceding
    section.
  prefs: []
  type: TYPE_NORMAL
- en: First, verify that you’ve added the MongoDB memory implementation and Mongoose
    to your project. If not, add them now by following the instructions in “Setting
    Up MongoDB and Mongoose” on page 117. Next, check that you’ve created the files
    in the *middleware* and *mongoose* folders described throughout this chapter and
    that they contain the code from [Listings 7-1](chapter7.xhtml#Lis7-1) through
    [7-10](chapter7.xhtml#Lis7-10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to connect the GraphQL API to the database, we need to do two things:
    implement the database connection and refactor the GraphQL resolvers to use its
    datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Connecting to the
    Database</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To query the database through the GraphQL API, we need to have a connection
    to the database. As you learned in [Chapter 6](chapter6.xhtml), all API calls
    have the same endpoint, */graphql*. This fact will now prove incredibly convenient
    for us; because all requests have the same entry point, we need to handle the
    database connection only once. Hence, we open the file *api/graphql.ts* and modify
    it to match the code in [Listing 7-11](chapter7.xhtml#Lis7-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: The api/graphql.ts file including a connection to the database'
  prefs: []
  type: TYPE_NORMAL
- en: We made three changes to the file. First we imported the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function from the middleware; then we created a new wrapper similar to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">allowCors</samp> function and used it
    to ensure that each API call connects to the API. We could safely do so because
    we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    to enforce only one database connection at the same time. Finally, we wrapped
    the handler with the new wrapper and exported it as the default.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Services to
    GraphQL Resolvers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now it’s time to add the services to the resolvers. In [Chapter 6](chapter6.xhtml),
    you learned that query resolvers implement the reading of data, whereas mutation
    resolvers implement the creation, updating, and deletion of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There, we also defined two resolvers: one to return a weather object for a
    given ZIP code and one to update a location’s weather data. Now we’ll add the
    services <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp>, which we created in
    this chapter, to the resolvers. Instead of the naïve implementations with the
    static data object, we modify the resolvers to query and update the MongoDB documents
    through the services.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-12](chapter7.xhtml#Lis7-12) shows the modified code for the *graphql/resolvers.ts*
    file in which we refactor these two resolvers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: The graphql/resolvers.ts file using services'
  prefs: []
  type: TYPE_NORMAL
- en: We replace the naive <samp class="SANS_TheSansMonoCd_W5Regular_11">array.filter</samp>
    functionality with the appropriate services. To query the data, we use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> service and pass it the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> variable from the request
    payload and then return the result data wrapped in an array. For the mutation,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp> service.
    Per type definition, the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    mutation returns the updated dataset. To do so, we query for the modified document
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> service
    once again and return the result as an array item.
  prefs: []
  type: TYPE_NORMAL
- en: Visit the GraphQL sandbox at *http://localhost:3000/api/graphql* and play with
    the API endpoints to read and update documents from the MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you explored using the non-relational database MongoDB and
    its Mongoose object data modeling tool, which lets you add and enforce schemas
    as well as perform CRUD operations on MongoDB instances. We covered the differences
    between relational and non-relational databases and how they store data. Then
    you created a Mongoose schema and a model, connected Mongoose to the MongoDB instance,
    and wrote the services to perform operations on the MongoDB collection.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you connected the REST and GraphQL APIs to the MongoDB database. Now,
    instead of static datasets, all of your APIs return dynamic documents, and you
    can both read and update documents through them.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB and Mongoose are extensive technologies with a huge array of functionalities.
    To learn more about them, consult the official documentation at [*https://<wbr>mongoosejs<wbr>.com*](https://mongoosejs.com)
    and read the articles at [*https://<wbr>www<wbr>.geeksforgeeks<wbr>.org<wbr>/mongoose<wbr>-module<wbr>-introduction*](https://www.geeksforgeeks.org/mongoose-module-introduction)/.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers Jest, a modern testing framework for conducting unit,
    snapshot, and integration tests.
  prefs: []
  type: TYPE_NORMAL
