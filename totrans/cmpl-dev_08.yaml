- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MONGODB
    AND MONGOOSE</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MONGODB
    和 MONGOOSE</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: Most applications rely on a database management system, or *database* for short,
    to organize and grant access to a collection of datasets. In this chapter, you’ll
    work with the MongoDB non-relational database and Mongoose, its accompanying object
    mapper.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序依赖于数据库管理系统，简称*数据库*，来组织和授予对数据集集合的访问权限。在本章中，你将使用 MongoDB 非关系型数据库和 Mongoose
    作为其附带的对象映射工具。
- en: Because MongoDB returns data as JSON and uses JavaScript for database queries,
    it provides a natural choice for full-stack JavaScript developers. In the following
    sections, you’ll learn how to create a Mongoose model through which you can query
    your database, simplify your interactions with MongoDB, and craft middleware that
    connects your frontend to your backend database. You’ll also write service functions
    to implement the four CRUD operations on the database.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 MongoDB 以 JSON 格式返回数据，并使用 JavaScript 进行数据库查询，它为全栈 JavaScript 开发人员提供了自然的选择。在接下来的章节中，你将学习如何创建一个
    Mongoose 模型，通过它你可以查询数据库，简化与 MongoDB 的交互，并编写中间件将前端与后端数据库连接起来。你还将编写服务函数来实现对数据库的四个
    CRUD 操作。
- en: In [Exercise 7](#Exe7) on page 125, you’ll add a database to the GraphQL API
    you created in [Chapter 6](chapter6.xhtml), replacing its current static datastore.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章练习](#Exe7)（第 125 页）中，你将为你在[第 6 章](chapter6.xhtml)中创建的 GraphQL API 添加一个数据库，替换当前的静态数据存储。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Apps Use Databases and Object-Relational
    Mappers</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">应用程序如何使用数据库和对象关系映射器</samp>
- en: An app needs a database to store and manipulate data. So far in this book, our
    app’s APIs returned only predefined datasets, saved in files, that couldn’t change.
    We used parameters in our requests to add to the dataset but couldn’t store the
    data between different API calls (called *persisting* the data). If we wanted
    to update the app’s weather information, for example, we’d need a database to
    persist the data so that the next API call could read it. In full-stack development,
    we commonly use databases to store user-related data. Another example of a database
    is the one that your email client uses to store your messages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序需要数据库来存储和操作数据。在本书的前面部分，我们的应用程序的 API 仅返回了预定义的数据集，这些数据集存储在文件中，且无法更改。我们使用请求中的参数来添加到数据集中，但不能在不同的
    API 调用之间存储数据（这被称为*数据持久化*）。例如，如果我们想要更新应用程序的天气信息，我们需要一个数据库来持久化数据，以便下一个 API 调用可以读取它。在全栈开发中，我们通常使用数据库来存储与用户相关的数据。另一个数据库的例子是你的电子邮件客户端用来存储你消息的数据库。
- en: To work with a database, we first need to connect to it and authenticate with
    it. Once we have access to the data, we can execute queries to ask for certain
    datasets. The query returns the results containing data that our app can display
    or use in some other way. How each of these steps works in practice depends on
    the specific database in use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用数据库，我们首先需要连接到它并进行身份验证。一旦我们获得了数据访问权限，就可以执行查询来请求特定的数据集。查询返回的结果包含数据，我们的应用程序可以展示这些数据或以其他方式使用它。每一步如何实现，取决于具体使用的数据库。
- en: Querying the data by using the database’s API tends to be clumsy because it
    usually requires a good amount of boilerplate code, even to simply establish and
    maintain the connection. Hence, we often use an *object-relational mapper* or
    *object data modeling tool*, which simplifies working with the databases by abstracting
    some of the details. For example, the Mongoose object data modeling tool for MongoDB
    handles database connections for us, saving us from having to check for an open
    database connection during each interaction.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库的 API 查询数据往往会显得笨拙，因为它通常需要大量的样板代码，即便只是建立和维护连接。因此，我们通常使用*对象关系映射器*或*对象数据建模工具*，通过抽象一些细节来简化与数据库的交互。例如，MongoDB
    的 Mongoose 对象数据建模工具为我们处理数据库连接，避免了我们在每次交互时都需要检查数据库连接是否开启。
- en: Mongoose also makes it easier to handle the fact that MongoDB runs on a separate
    database server. Working with distributed systems requires making asynchronous
    calls, which you learned about in [Chapter 2](chapter2.xhtml). With Mongoose,
    we can access the data with an object-oriented <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> interface instead of using
    clumsy callback functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 还简化了 MongoDB 在独立数据库服务器上运行的处理方式。使用分布式系统需要进行异步调用，这点你在[第 2 章](chapter2.xhtml)中已经学过。使用
    Mongoose，我们可以通过面向对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> 接口来访问数据，而不需要使用繁琐的回调函数。
- en: In addition, MongoDB is schema-less; it doesn’t require us to predefine and
    strictly adhere to a schema. While convenient, this flexibility is also a common
    source of errors, especially in large-scale applications or projects with a rotating
    cast of developers. In [Chapter 3](chapter3.xhtml), we discussed the benefits
    of adding types to JavaScript by using TypeScript. Mongoose types and verifies
    the integrity of MongoDB’s data models similarly, as you’ll discover in “Defining
    a Mongoose Model” on page 118.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，MongoDB 是无模式的；它不要求我们预定义并严格遵守模式。虽然这种灵活性很方便，但它也是常见错误的来源，尤其是在大型应用程序或开发者团队不断变动的项目中。在[第
    3 章](chapter3.xhtml)中，我们讨论了通过使用 TypeScript 为 JavaScript 添加类型的好处。Mongoose 通过类似的方式对
    MongoDB 的数据模型进行类型化并验证其完整性，正如你将在“定义 Mongoose 模型”（第 118 页）中发现的那样。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Relational and Non-Relational Databases</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">关系型与非关系型数据库</samp>
- en: 'Databases can organize data in several ways, which fall into two main categories:
    relational and non-relational. *Relational databases*, such as MySQL and PostgreSQL,
    store data in one or more tables. You can think of these databases as resembling
    Excel spreadsheets. As in Excel, each table has a unique name and contains columns
    and rows. The columns define properties, such as the data type, for all data stored
    in the column, and the rows contain the actual datasets, each of which is identified
    by a unique ID. Relational databases use some variation of Structured Query Language
    (SQL) for their database operations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库可以以多种方式组织数据，这些方式主要分为两大类：关系型和非关系型。*关系型数据库*，如 MySQL 和 PostgreSQL，数据存储在一个或多个表中。你可以把这些数据库想象成类似于
    Excel 电子表格。与 Excel 类似，每个表都有一个唯一名称，并包含列和行。列定义所有存储在该列中的数据的属性，如数据类型，而行包含实际的数据集，每行都有一个唯一
    ID。关系型数据库使用某种变体的结构化查询语言（SQL）来进行数据库操作。
- en: MongoDB is a *non-relational database*. Unlike traditional relational databases,
    it stores data as JSON documents instead of tables and doesn’t use SQL. Sometimes
    termed *NoSQL*, non-relational databases can store data in many different formats.
    For example, the popular NoSQL databases Redis and Memcached use key-value storage,
    which makes them highly performant and easily scalable. Thus, they’re often used
    as in-memory caches. Another NoSQL database, Neo4j, is a *graph database* that
    uses graph theory to store data as nodes, a concept we mentioned in [Chapter 6](chapter6.xhtml).
    These are just a few examples of non-relational databases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个*非关系型数据库*。与传统的关系型数据库不同，它以 JSON 文档的形式存储数据，而不是以表格形式存储，并且不使用 SQL。非关系型数据库有时被称为*NoSQL*，它们可以以多种不同格式存储数据。例如，流行的
    NoSQL 数据库 Redis 和 Memcached 使用键值存储，这使它们具有高性能和易于扩展的特点。因此，它们常被用作内存缓存。另一个 NoSQL 数据库，Neo4j，是一个*图形数据库*，它使用图论将数据存储为节点，这个概念我们在[第
    6 章](chapter6.xhtml)中提到过。这些只是非关系型数据库的一些例子。
- en: MongoDB is the most widely used *document database*; instead of tables, rows,
    and columns, it organizes data in collections, documents, and fields. The *field*
    is the smallest unit in the database. It defines the data type and additional
    properties and contains the actual data. You can consider it the rough equivalent
    of a column in a SQL table. *Documents*, which are made of fields, are like rows
    in a SQL table. We sometimes call them records, and MongoDB uses *BSON*, a binary
    representation of a JSON object, to store them. A *collection* is roughly equivalent
    to a SQL table, but instead of rows and columns, it aggregates documents.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是最广泛使用的*文档数据库*；它不是通过表格、行和列来组织数据，而是通过集合、文档和字段。*字段*是数据库中最小的单位，它定义数据类型和其他属性，并包含实际数据。你可以将其视为
    SQL 表中的列的粗略等价物。*文档*由字段构成，类似于 SQL 表中的行。我们有时称它们为记录，MongoDB 使用 *BSON*，即 JSON 对象的二进制表示，来存储它们。*集合*大致等同于
    SQL 表，但它不是由行和列组成，而是聚合了文档。
- en: Because non-relational databases can store data in different formats, each database
    uses a specific, optimized query language for CRUD operations. These low-level
    APIs focus on accessing and manipulating the data, and not necessarily on the
    developer experience. By contrast, object-relational mappers provide a high-level
    abstraction with a clean and simplified interface to the query language. So, while
    MongoDB has the MongoDB Query Language (MQL), we’ll use Mongoose to access it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非关系型数据库可以以不同格式存储数据，因此每个数据库使用特定的、优化过的查询语言进行 CRUD 操作。这些低级 API 关注的是访问和操作数据，而不一定是开发者体验。相比之下，面向对象的关系映射工具提供了高级抽象，拥有清晰简化的查询语言接口。因此，虽然
    MongoDB 有 MongoDB 查询语言（MQL），我们将使用 Mongoose 来访问它。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up MongoDB and Mongoose</samp>
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置 MongoDB 和 Mongoose</samp>
- en: Before you start using MongoDB and Mongoose, you must add them to your sample
    project. For the sake of simplicity, we’ll use an in-memory implementation of
    MongoDB rather than install and maintain a real database server on our machines.
    This is appropriate for testing the chapter’s examples, but not for deploying
    an actual application, as it does not persist the data between restarts. You’ll
    gain experience setting up a real MongoDB server when you build the Food Finder
    application in [Part II](part2.xhtml). [Chapter 11](chapter11.xhtml) will show
    you how to use a pre-built Docker container that contains the MongoDB server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 MongoDB 和 Mongoose 之前，必须将它们添加到您的示例项目中。为了简化，我们将使用 MongoDB 的内存实现，而不是在机器上安装和维护真实的数据库服务器。这对于测试本章示例是合适的，但不适用于部署实际的应用程序，因为它在重启时不会持久化数据。当您在[第二部分](part2.xhtml)构建食品查找应用时，您将获得设置真实
    MongoDB 服务器的经验。[第11章](chapter11.xhtml)将展示如何使用预构建的 Docker 容器，该容器包含 MongoDB 服务器。
- en: 'Run this command in the root directory of the refactored Next.js app from [Chapter
    6](chapter6.xhtml):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](chapter6.xhtml)的重构版 Next.js 应用的根目录下运行此命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then create two new folders in the root directory, next to the *package .json*
    file: one for the Mongoose code, called *mongoose*, with subfolder *weather*,
    and one called *middleware*, which will hold the necessary middleware.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在根目录中创建两个新文件夹，位于 *package.json* 文件旁边：一个用于 Mongoose 代码，命名为 *mongoose*，并在其中创建子文件夹
    *weather*；另一个命名为 *middleware*，用于存放所需的中间件。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defining a Mongoose Model</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">定义 Mongoose 模型</samp>
- en: In order to verify the integrity of our data, we must create a schema-based
    Mongoose *model*, which acts as a direct interface to a MongoDB collection in
    a database. All interactions with the database will happen through the model.
    Before we create the model, though, we need to create the schema itself, which
    defines the structure of the database’s data and maps the Mongoose instance to
    the documents in the collection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们数据的完整性，我们必须创建一个基于架构的 Mongoose *模型*，它充当与数据库中 MongoDB 集合的直接接口。所有与数据库的交互将通过该模型进行。然而，在创建模型之前，我们需要先创建架构本身，架构定义了数据库数据的结构，并将
    Mongoose 实例映射到集合中的文档。
- en: Our Mongoose schema will match the schema created for the GraphQL API in [Chapter
    6](chapter6.xhtml). That’s because we’ll connect the GraphQL API to the database
    in [Exercise 7](#Exe7) on page 125, allowing us to replace the static JSON object
    with datasets we queried from the database.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Mongoose 架构将与[第6章](chapter6.xhtml)中为 GraphQL API 创建的架构相匹配。这是因为我们将在第125页的[练习7](#Exe7)中将
    GraphQL API 连接到数据库，从而允许我们用从数据库查询的数据集替换静态 JSON 对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Interface</samp>
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">接口</samp>
- en: Before writing the Mongoose model and schema in TypeScript, let’s declare a
    TypeScript interface. Without a matching interface, we won’t be able to type the
    model or schema for TSC, and the code won’t compile. Paste the code shown in [Listing
    7-1](chapter7.xhtml#Lis7-1) into the *mongoose/weather/interface.ts* file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在用 TypeScript 编写 Mongoose 模型和架构之前，让我们先声明一个 TypeScript 接口。如果没有匹配的接口，我们将无法为 TSC
    类型化模型或架构，代码也无法编译。将[列表 7-1](chapter7.xhtml#Lis7-1)中显示的代码粘贴到 *mongoose/weather/interface.ts*
    文件中。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-1: The interface for the Mongoose weather model'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：Mongoose 天气模型的接口
- en: The code is a regular TypeScript interface with properties matching the GraphQL
    and Mongoose schemas.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个常规的 TypeScript 接口，属性与 GraphQL 和 Mongoose 架构相匹配。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Schema</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">架构</samp>
- en: '[Listing 7-2](chapter7.xhtml#Lis7-2) shows the Mongoose schema. Its top-level
    properties represent the fields in the document. Each field has a type and a flag
    indicating whether it is required. Fields can also have additional optional properties,
    such as custom or built-in validators. Here we use the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">required</samp>
    validator; other common built-in validators are <samp class="SANS_TheSansMonoCd_W5Regular_11">minlength</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">maxlength</samp> for strings,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">min</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>
    for numbers. Add the code to the *mongoose/weather/schema.ts* file.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-2](chapter7.xhtml#Lis7-2)展示了 Mongoose 架构。它的顶层属性代表文档中的字段。每个字段都有一个类型和一个标志，指示该字段是否是必需的。字段还可以具有其他可选属性，例如自定义或内建的验证器。这里我们使用了内建的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">required</samp> 验证器；其他常见的内建验证器包括用于字符串的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">minlength</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">maxlength</samp>，以及用于数字的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">min</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">max</samp>。将代码添加到
    *mongoose/weather/schema.ts* 文件中。'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-2: The schema for the Mongoose weather model'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2：Mongoose 天气模型的架构
- en: We use an object passed to the schema constructor to create the schema and set
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> as its SchemaType.
    Therefore, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp>
    function from the *mongoose* package and the interface we created previously.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用传递给架构构造函数的对象来创建架构，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>
    设置为其 SchemaType。因此，我们从 *mongoose* 包中导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp>
    函数，并导入之前创建的接口。
- en: Like TypeScript, which adds custom types to JavaScript, Mongoose casts each
    property to its associated *SchemaType*, which provides the configuration of the
    model. The available types are a mixture of built-in JavaScript types, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Array</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Date</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Number</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>, and custom types,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectId</samp>,
    the latter of which refers to the default unique <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>
    property that Mongoose adds to each document upon creation. This is similar to
    the primary key you might know from relational databases.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 TypeScript 为 JavaScript 添加自定义类型，Mongoose 会将每个属性转换为其关联的 *SchemaType*，该类型提供模型的配置。可用的类型包括内建的
    JavaScript 类型，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Array</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Date</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Number</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp>，以及自定义类型，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Buffer</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectId</samp>，后者指的是
    Mongoose 在创建每个文档时添加的默认唯一 <samp class="SANS_TheSansMonoCd_W5Regular_11">_id</samp>
    属性。这类似于你可能知道的关系数据库中的主键。
- en: 'The weather API we created in [Chapter 6](chapter6.xhtml) returned an object
    with four properties: <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">tempF</samp>, each of which
    is a string. In addition, we have one array of strings in the <samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    property. In this schema, we define the same properties, then export the schema.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第六章](chapter6.xhtml)中创建的天气 API 返回了一个包含四个属性的对象：<samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">tempC</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tempF</samp>，每个属性的值都是字符串。此外，<samp class="SANS_TheSansMonoCd_W5Regular_11">friends</samp>
    属性中包含一个字符串数组。在这个架构中，我们定义了相同的属性，然后导出该架构。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Model</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">模型</samp>
- en: Now that we have a schema, we can create the Mongoose model. This wrapper on
    the schema will provide access to the MongoDB documents in the collection for
    all CRUD operations. We write the model in the *mongoose/weather/model.ts* file,
    whose code is in [Listing 7-3](chapter7.xhtml#Lis7-3). Keep in mind that we haven’t
    yet connected it to the MongoDB database on the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了一个模式，现在可以创建 Mongoose 模型了。这个模式的封装器将提供对集合中 MongoDB 文档的访问，以执行所有的 CRUD 操作。我们在
    *mongoose/weather/model.ts* 文件中编写模型，其代码位于[清单 7-3](chapter7.xhtml#Lis7-3)。请记住，我们还没有将其连接到服务器上的
    MongoDB 数据库。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-3: The Mongoose weather model'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-3：Mongoose 天气模型
- en: 'First we import the Mongoose module and the model constructor from the *mongoose*
    package, as well as the interface and the schema we created earlier. Then we set
    up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> model, using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> to type
    it. We pass it two parameters: the model’s name, <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>,
    and the schema, which defines the model’s internal data structure. Mongoose binds
    the newly created model to our MongoDB instance’s collection. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp>
    collection resides in the *Weather* database, both of which Mongoose creates.
    Note that we need to check for an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    model on <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.models</samp>
    before creating a new one; otherwise, Mongoose will throw an error. We export
    the model so that we can use it in our following modules.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 Mongoose 模块和来自 *mongoose* 包的模型构造函数，以及我们之前创建的接口和模式。然后，我们设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp>
    模型，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp> 来为其指定类型。我们传入两个参数：模型的名称
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> 和定义模型内部数据结构的模式。Mongoose
    会将新创建的模型绑定到我们 MongoDB 实例的集合上。<samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp>
    集合位于 *Weather* 数据库中，两个都会由 Mongoose 创建。请注意，在创建新模型之前，我们需要检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.models</samp>
    上是否已存在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Weather</samp> 模型；否则，Mongoose
    将抛出错误。我们导出该模型，以便在后续的模块中使用它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Database-Connection
    Middleware</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数据库连接中间件</samp>
- en: Several times in this book so far, we’ve mentioned that full-stack development
    covers an application’s frontend, backend, and middleware, which is often also
    referred to as “application glue.” Now it’s time to create our first dedicated
    middleware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本书到目前为止，我们多次提到全栈开发涵盖了应用程序的前端、后端和中间件，后者通常也被称为“应用程序粘合剂”。现在是时候创建我们的第一个专用中间件了。
- en: This middleware will open a connection to the database, then use Mongoose’s
    asynchronous helper function to maintain that connection. Next, it will map Mongoose’s
    models to the MongoDB collections so that we can access them through Mongoose.
    Conveniently, the connection helper will buffer the operations and reconnect to
    the database if necessary, so we don’t need to handle connectivity issues by ourselves.
    Paste the code from [Listing 7-4](chapter7.xhtml#Lis7-4) into the *middleware/db-connect.ts*
    file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件将打开与数据库的连接，然后使用 Mongoose 的异步辅助函数保持该连接。接下来，它将把 Mongoose 的模型映射到 MongoDB 集合，以便我们通过
    Mongoose 访问它们。方便的是，连接助手将缓冲操作，并在必要时重新连接到数据库，因此我们不需要自己处理连接问题。将代码从[清单 7-4](chapter7.xhtml#Lis7-4)粘贴到
    *middleware/db-connect.ts* 文件中。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-4: The Mongoose middleware'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-4：Mongoose 中间件
- en: We import the *mongoose* package and the *mongodb-memory-server* database. The
    async function <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>,
    which we define and then export, manages the connection to the database server
    through the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.connect</samp>
    function. We create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp>
    to persist our data in memory rather than use a real database server, as discussed.
    Then we store the connection string in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGOIO_URI</samp>.
    Because we are using the in-memory server, this string is dynamic, but for a remote
    database, it would be a static string representing the database’s server address.
    Then we close all existing connections and use Mongoose to open a new connection.
    The Mongoose models are already mapped and available, so we’re ready to perform
    our first queries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 *mongoose* 包和 *mongodb-memory-server* 数据库。我们定义并导出的异步函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.connect</samp> 函数管理与数据库服务器的连接。我们创建一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp> 实例，将数据保存在内存中，而不是使用真实的数据库服务器，如前所述。然后，我们将连接字符串存储在常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGOIO_URI</samp> 中。由于我们使用的是内存服务器，这个字符串是动态的，但对于远程数据库，它将是一个表示数据库服务器地址的静态字符串。接着，我们关闭所有现有的连接，并使用
    Mongoose 打开一个新连接。Mongoose 模型已经映射并可用，因此我们已经准备好执行我们的第一个查询。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Querying the Database</samp>
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">查询数据库</samp>
- en: Now it’s time to write database queries. Instead of sprinkling these queries
    around your application code or writing them directly in the GraphQL resolvers,
    you should extract them as services.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是编写数据库查询的时候了。你应该将这些查询提取为服务，而不是在应用程序代码中随意分散这些查询或直接在 GraphQL 解析器中编写它们。
- en: A *service* is a function that performs the actual CRUD operations on the Mongoose
    model and returns the result. Each GraphQL resolver can then call a service function,
    and all internal database access should happen through these functions. Moreover,
    each service should be responsible for only one specific CRUD operation. Mongoose
    automatically queues the commands and executes them, maintains the connection,
    and then processes the queue as soon as there is a connection to the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务*是执行实际 CRUD 操作并返回结果的函数。每个 GraphQL 解析器可以调用一个服务函数，所有的数据库访问都应通过这些函数进行。此外，每个服务应只负责一个特定的
    CRUD 操作。Mongoose 会自动排队命令并执行它们，保持连接，并在与数据库建立连接后立即处理队列。'
- en: This section introduces service functions and basic Mongoose commands. However,
    it isn’t a complete reference. When you start working with Mongoose on your own
    projects, look up all the functions you’ll need in the Mongoose documentation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了服务功能和基本的 Mongoose 命令。然而，这并不是一个完整的参考。当你开始在自己的项目中使用 Mongoose 时，请查阅 Mongoose
    文档以获取所有需要的功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Document</samp>
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建文档</samp>
- en: The first and most basic operation is the “create” operation. It is conveniently
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.create</samp> and,
    fortunately, we can use it to both create and update a dataset. That’s because
    Mongoose automatically creates a new database entry, or document, if the entry
    doesn’t already exist. Hence, we don’t need to check whether a dataset exists
    and then conditionally create it before updating it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最基本的操作是“创建”操作。它被方便地称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.create</samp>，幸运的是，我们可以用它来创建和更新数据集。这是因为如果数据条目尚不存在，Mongoose
    会自动创建一个新的数据库条目或文档。因此，我们无需先检查数据集是否存在，然后再有条件地创建它再进行更新。
- en: '[Listing 7-5](chapter7.xhtml#Lis7-5) shows a basic implementation of a service
    function that stores a dataset in the database. Place the code in the *mongoose/weather/
    services.ts* file.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-5](chapter7.xhtml#Lis7-5) 展示了一个基本的服务函数实现，该函数将数据集存储到数据库中。将代码放入 *mongoose/weather/services.ts*
    文件中。'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-5: Creating a document through Mongoose'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-5：通过 Mongoose 创建文档
- en: To store a document, we create and export the async function <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp>,
    which takes the dataset as the argument. Here we type it as <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>.
    Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function
    on the model and pass the dataset to it. The function will create and insert the
    document in <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>,
    which is the weather collection in the MongoDB instance. Finally, it returns a
    Boolean to indicate the status of the operation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储文档，我们创建并导出异步函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp>，该函数以数据集作为参数。这里我们将其类型设为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>。然后，我们在模型上调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> 函数，并将数据集传递给它。该函数将创建并插入文档到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp> 中，该模型是 MongoDB
    实例中的天气集合。最后，它返回一个布尔值，表示操作的状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reading a Document</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">读取文档</samp>
- en: To implement the “read” operation, we query MongoDB through Mongoose’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp> function. It takes one
    argument, an object with the properties to look for, and returns the first match.
    Extend the *mongoose/weather/services.ts* file with the code in [Listing 7-6](chapter7.xhtml#Lis7-6).
    It defines a <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> function
    to find and return the first document from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp>
    collection whose <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> property
    matches the ZIP code passed to the function as a parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现“读取”操作，我们通过 Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>
    函数查询 MongoDB。它接受一个参数——一个包含要查找属性的对象，并返回第一个匹配项。通过 [清单 7-6](chapter7.xhtml#Lis7-6)
    中的代码，扩展 *mongoose/weather/services.ts* 文件。它定义了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp>
    函数，用于查找并返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">Weathers</samp> 集合中第一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> 属性与传递给函数的 ZIP 代码匹配的文档。
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-6: Reading data through Mongoose'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-6：通过 Mongoose 读取数据
- en: We add and export the async function <samp class="SANS_TheSansMonoCd_W5Regular_11">readByZip</samp>
    to the services in the *services.ts* file. The function takes one string parameter,
    the ZIP code, and returns either an array with documents or an empty array. Inside
    the new service function, we call Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>
    function on the model and pass a filter object, looking for the document whose
    <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> field matches the parameter’s
    value. Finally, the function returns the result or <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 *services.ts* 文件中的服务添加并导出异步函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">readByZip</samp>。该函数接受一个字符串参数——ZIP
    代码，并返回一个包含文档的数组或一个空数组。在新的服务函数内部，我们在模型上调用 Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>
    函数，并传递一个过滤对象，查找其 <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> 字段与参数值匹配的文档。最后，函数返回结果或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating a Document</samp>
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更新文档</samp>
- en: 'We mentioned that we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp>
    function to update documents. However, there is also a specific API for this task:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>. It takes two arguments.
    The first is the filter object, similar to the filter we used with <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>,
    and the second is an object with the new values. You can think of <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>
    as a combination of the “find” and “create” functions. Extend the *mongoose/weather/services.ts*
    file with the code from [Listing 7-7](chapter7.xhtml#Lis7-7).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> 函数来更新文档。然而，也有一个专门用于此任务的
    API：<samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>。它接受两个参数。第一个是过滤对象，类似于我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp> 中使用的过滤器，第二个是包含新值的对象。你可以将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp> 看作是 “find” 和 “create”
    函数的结合。通过 [清单 7-7](chapter7.xhtml#Lis7-7) 中的代码，扩展 *mongoose/weather/services.ts*
    文件。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-7: Updating data through Mongoose'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-7：通过 Mongoose 更新数据
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp> function
    that we add to the services takes two parameters. The first one is a string, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">paramZip</samp>, which is the ZIP code
    we use to query for the document we want to update. The second parameter is the
    new dataset, which we type as <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>.
    We call Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp>
    function on the model, passing it a filter object and the latest data. The function
    should return a Boolean to indicate the status.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到服务中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp> 函数接受两个参数。第一个是字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">paramZip</samp>，它是我们用来查询要更新的文档的邮政编码。第二个参数是新的数据集，我们将其类型定义为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>。我们在模型上调用
    Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">updateOne</samp> 函数，传入一个过滤器对象和最新的数据。该函数应返回一个布尔值，表示操作状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Deleting a Document</samp>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">删除文档</samp>
- en: The last CRUD operation we need to implement is a service to delete a document.
    For this, we use Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp>
    function and add the code from [Listing 7-8](chapter7.xhtml#Lis7-8) to the *mongoose/weather/services.ts*
    file. It is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp>
    function, except that it directly deletes the query’s result. Mongoose queues
    the operations and deletes the document from the database automatically once there
    is a connection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个 CRUD 操作是一个删除文档的服务。为此，我们使用 Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp>
    函数，并将 [Listing 7-8](chapter7.xhtml#Lis7-8) 中的代码添加到 *mongoose/weather/services.ts*
    文件中。它与 <samp class="SANS_TheSansMonoCd_W5Regular_11">findOne</samp> 函数类似，不同之处在于它直接删除查询结果。Mongoose
    会排队执行这些操作，并在连接建立后自动从数据库中删除文档。
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-8: Deleting data through Mongoose'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-8: 通过 Mongoose 删除数据'
- en: The async function <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteByZip</samp>
    takes one string parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>.
    We use it to query the model and find the document to delete, passing the filter
    to Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp> function.
    The function should return a Boolean.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteByZip</samp> 接受一个字符串参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp>。我们使用它查询模型，找到要删除的文档，并将过滤器传递给
    Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">deleteOne</samp> 函数。该函数应返回一个布尔值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating an End-to-End Query</samp>
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建一个端到端查询</samp>
- en: In full-stack development, *end-to-end* typically refers to the ability of data
    to travel all the way from the app’s frontend (or from one of its APIs) through
    the middleware to the backend, and then all the way back to its original source.
    For practice, let’s create a simple end-to-end example using the */zipcode* endpoint
    of our REST API.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈开发中，*端到端* 通常指的是数据能够从应用程序的前端（或它的某个 API）一路传递，通过中间件到达后端，然后再回到它的原始来源。为了练习，让我们使用
    REST API 的 */zipcode* 端点创建一个简单的端到端示例。
- en: We’ll modify the API to take the query parameter from the URL, find the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> object for the requested
    ZIP code in the database, and then return it, effectively replacing the static
    JSON response with a dynamic query result. Modify the file *pages/api/v1/weather/[zipcode].ts*
    to match [Listing 7-9](chapter7.xhtml#Lis7-9).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 API，以便从 URL 中获取查询参数，查找数据库中对应邮政编码的 <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    对象，然后返回它，实际上是用动态查询结果替换了静态的 JSON 响应。修改文件 *pages/api/v1/weather/[zipcode].ts* 以匹配
    [Listing 7-9](chapter7.xhtml#Lis7-9)。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-9: The end-to-end REST API'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-9: 完整的 REST API'
- en: Notice the modified API handler. We made two major changes to it. First we called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> to connect to the
    database. Then we used the imported <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp>
    service and passed it the query parameter cast to a string type. Instead of the
    static JSON object as before, we now return the dynamic <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    that we receive from the service function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意修改后的 API 处理程序。我们对它做了两个主要修改。首先，我们调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    来连接数据库。然后，我们使用导入的 <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp>
    服务，并将查询参数转换为字符串类型传递给它。与之前使用静态 JSON 对象不同，我们现在返回从服务函数接收到的动态 <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>。
- en: 'We need to perform one more step before we can receive data in response to
    the API call: *seeding* the database, or adding initial datasets to it. For simplicity,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocuments</samp>
    service and seed directly in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function. Modify the *middleware/db-connect.ts* file to match the code in [Listing
    7-10](chapter7.xhtml#Lis7-10), which imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp>
    service and adds the datasets after establishing the database connection.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够接收 API 调用响应数据之前，还需要执行一步：*初始化数据*，即向数据库中添加初始数据集。为了简化操作，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocuments</samp>
    服务，并直接在 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> 函数中进行初始化。修改
    *middleware/db-connect.ts* 文件，使其与 [列表 7-10](chapter7.xhtml#Lis7-10) 中的代码一致，该代码导入了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">storeDocument</samp> 服务，并在建立数据库连接后添加数据集。
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-10: The naive data seeding in the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dbConnect</samp>
    function'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-10：在 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dbConnect</samp>
    函数中的简单数据初始化
- en: Now we can perform the end-to-end request. Visit the REST API endpoint in the
    browser at *http://localhost:3000/api/v1/weather/96815*. You should see the dataset
    from the MongoDB database as the API response. Try adjusting the query parameter
    in the URL to another valid ZIP code. You should get another dataset in the response.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行端到端请求。在浏览器中访问 REST API 端点 *http://localhost:3000/api/v1/weather/96815*。你应该能看到来自
    MongoDB 数据库的数据集作为 API 响应。尝试在 URL 中调整查询参数为另一个有效的邮政编码。你应该会在响应中获得另一个数据集。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 7: Connect the GraphQL API
    to the Database</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 7：将 GraphQL API 连接到数据库</samp>
- en: Let’s rework our weather application’s GraphQL API so that it reads the response
    data from the database instead of from a static JSON file. The code will look
    familiar, as we’ll use the same patterns as for the REST API example in the preceding
    section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新设计天气应用的 GraphQL API，使其从数据库读取响应数据，而不是从静态的 JSON 文件中读取。代码看起来会很熟悉，因为我们将使用与前一节
    REST API 示例相同的模式。
- en: First, verify that you’ve added the MongoDB memory implementation and Mongoose
    to your project. If not, add them now by following the instructions in “Setting
    Up MongoDB and Mongoose” on page 117. Next, check that you’ve created the files
    in the *middleware* and *mongoose* folders described throughout this chapter and
    that they contain the code from [Listings 7-1](chapter7.xhtml#Lis7-1) through
    [7-10](chapter7.xhtml#Lis7-10).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，验证是否已将 MongoDB 内存实现和 Mongoose 添加到你的项目中。如果没有，请按照第 117 页的《设置 MongoDB 和 Mongoose》中的说明进行添加。接下来，检查是否已创建本章中描述的
    *middleware* 和 *mongoose* 文件夹中的文件，并确保它们包含从 [列表 7-1](chapter7.xhtml#Lis7-1) 到 [7-10](chapter7.xhtml#Lis7-10)
    的代码。
- en: 'Now, to connect the GraphQL API to the database, we need to do two things:
    implement the database connection and refactor the GraphQL resolvers to use its
    datasets.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将 GraphQL API 连接到数据库，我们需要做两件事：实现数据库连接，并重构 GraphQL 解析器以使用其数据集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Connecting to the
    Database</samp>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">连接到数据库</samp>
- en: To query the database through the GraphQL API, we need to have a connection
    to the database. As you learned in [Chapter 6](chapter6.xhtml), all API calls
    have the same endpoint, */graphql*. This fact will now prove incredibly convenient
    for us; because all requests have the same entry point, we need to handle the
    database connection only once. Hence, we open the file *api/graphql.ts* and modify
    it to match the code in [Listing 7-11](chapter7.xhtml#Lis7-11).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-11: The api/graphql.ts file including a connection to the database'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: We made three changes to the file. First we imported the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function from the middleware; then we created a new wrapper similar to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">allowCors</samp> function and used it
    to ensure that each API call connects to the API. We could safely do so because
    we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    to enforce only one database connection at the same time. Finally, we wrapped
    the handler with the new wrapper and exported it as the default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Services to
    GraphQL Resolvers</samp>
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now it’s time to add the services to the resolvers. In [Chapter 6](chapter6.xhtml),
    you learned that query resolvers implement the reading of data, whereas mutation
    resolvers implement the creation, updating, and deletion of data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'There, we also defined two resolvers: one to return a weather object for a
    given ZIP code and one to update a location’s weather data. Now we’ll add the
    services <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp>, which we created in
    this chapter, to the resolvers. Instead of the naïve implementations with the
    static data object, we modify the resolvers to query and update the MongoDB documents
    through the services.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-12](chapter7.xhtml#Lis7-12) shows the modified code for the *graphql/resolvers.ts*
    file in which we refactor these two resolvers.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-12: The graphql/resolvers.ts file using services'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We replace the naive <samp class="SANS_TheSansMonoCd_W5Regular_11">array.filter</samp>
    functionality with the appropriate services. To query the data, we use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> service and pass it the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> variable from the request
    payload and then return the result data wrapped in an array. For the mutation,
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateByZip</samp> service.
    Per type definition, the <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp>
    mutation returns the updated dataset. To do so, we query for the modified document
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp> service
    once again and return the result as an array item.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Visit the GraphQL sandbox at *http://localhost:3000/api/graphql* and play with
    the API endpoints to read and update documents from the MongoDB database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *http://localhost:3000/api/graphql* 上的 GraphQL 沙盒，玩转 API 端点以读取和更新 MongoDB
    数据库中的文档。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you explored using the non-relational database MongoDB and
    its Mongoose object data modeling tool, which lets you add and enforce schemas
    as well as perform CRUD operations on MongoDB instances. We covered the differences
    between relational and non-relational databases and how they store data. Then
    you created a Mongoose schema and a model, connected Mongoose to the MongoDB instance,
    and wrote the services to perform operations on the MongoDB collection.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你探索了使用非关系型数据库 MongoDB 以及其 Mongoose 对象数据建模工具，Mongoose 让你能够添加和强制执行模式，并对 MongoDB
    实例进行 CRUD 操作。我们讲解了关系型数据库和非关系型数据库的区别以及它们存储数据的方式。然后，你创建了一个 Mongoose 模式和一个模型，将 Mongoose
    连接到 MongoDB 实例，并编写了服务以在 MongoDB 集合上执行操作。
- en: Finally, you connected the REST and GraphQL APIs to the MongoDB database. Now,
    instead of static datasets, all of your APIs return dynamic documents, and you
    can both read and update documents through them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将 REST 和 GraphQL APIs 连接到了 MongoDB 数据库。现在，所有的 API 都返回动态文档，而非静态数据集，你可以通过它们进行文档的读取和更新。
- en: MongoDB and Mongoose are extensive technologies with a huge array of functionalities.
    To learn more about them, consult the official documentation at [*https://<wbr>mongoosejs<wbr>.com*](https://mongoosejs.com)
    and read the articles at [*https://<wbr>www<wbr>.geeksforgeeks<wbr>.org<wbr>/mongoose<wbr>-module<wbr>-introduction*](https://www.geeksforgeeks.org/mongoose-module-introduction)/.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 和 Mongoose 是功能强大的技术，拥有丰富的功能。如果你想深入了解它们，请查阅官方文档 [*https://<wbr>mongoosejs<wbr>.com*](https://mongoosejs.com)
    和 [*https://<wbr>www<wbr>.geeksforgeeks<wbr>.org<wbr>/mongoose<wbr>-module<wbr>-introduction*](https://www.geeksforgeeks.org/mongoose-module-introduction)/。
- en: The next chapter covers Jest, a modern testing framework for conducting unit,
    snapshot, and integration tests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 Jest，这是一个现代的测试框架，用于进行单元测试、快照测试和集成测试。
