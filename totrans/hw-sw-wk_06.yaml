- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data Compression**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Sometimes the hard work of software is obvious to everyone, as it is with movie
    CGI and video game graphics. You don’t have to know anything about how computers
    work to be impressed with the visuals in films like *Avatar* and games like *Crysis*.
    Sometimes, though, software is doing its most amazing work when it looks like
    it’s not working hard at all.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Watching a high-definition movie on a disc or streamed over the Internet is
    something most of us take for granted. Isn’t that just storing and displaying
    images? Why would that require special techniques? To understand why we should
    be impressed with Blu-ray video and Netflix streaming, let’s look at what video
    was like before these formats came to be.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Videocassettes, the earliest home video medium, recorded images on a roll of
    magnetic tape. These were analog recordings—magnetic transcriptions of the same
    signal that would’ve been broadcast by television antennas. The video resolution
    was even lower than what we now call “standard definition,” and as with other
    analog recordings like audiocassettes and vinyl records, the quality of the video
    would degrade over time. The one upside to videocassettes was their capacity:
    a longer movie merely required a longer spool of tape.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Next came the LaserDisc. About the size of LP records, these discs looked like
    larger versions of today’s DVDs and Blu-ray discs, but like videocassettes, they
    were still storing the analog broadcast-format signal. However, LaserDiscs recorded
    a higher-resolution picture that came close to standard definition, and allowed
    you to jump to particular places in the video without having to rewind or fast-forward
    the way you would with a videocassette. For a while, the LaserDisc seemed like
    the future of video, but now capacity was a problem. Unlike the effectively limitless
    capacity of a magnetic tape roll, LaserDiscs could hold only 60 minutes of video
    per side, so watching a movie meant flipping the disc halfway through or even
    switching discs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Today, the problem of capacity is even more serious. Our Blu-ray discs are much
    smaller than LaserDiscs, but our videos are a much higher resolution. Let me put
    the problem into numbers. In high-definition video each frame is a 1920×1080 bitmap,
    a total of 2,073,600 pixels. If each pixel is stored in three-byte RGB format,
    one frame of a high-definition movie would require 6,220,800 bytes, or about 6.2
    megabytes (*mega* means “million”). Movies are recorded at 24 or 30 frames per
    second, which is 1,800 frames per minute, 108,000 frames per hour, or 216,000
    frames for a two-hour film. If each frame is 6,220,800 bytes, then 216,000 frames
    is 1,343,693 megabytes, or about 1,345 gigabytes (*giga* means “billion”).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: How can all of that data fit on a Blu-ray disc? Part of the answer is the “blu-ray”
    itself, a blue laser that’s narrower than the laser used on LaserDiscs or even
    conventional DVDs, allowing more data to be packed into a smaller area, just as
    smaller print allows more words on a page. Even so, a Blu-ray can store only about
    50 gigabytes(GB) of data, less than 4 percent of what’s required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么所有这些数据如何能存储在一张蓝光光盘上呢？部分原因是“蓝光”本身，它使用的蓝激光比激光唱片或甚至传统DVD上使用的激光更窄，从而允许将更多数据压缩到更小的区域，就像更小的字体可以让一页上容纳更多的文字一样。即便如此，一张蓝光光盘最多也只能存储约50GB的数据，这还不到所需数据的4%。
- en: Streaming video has the same problem. If one frame of video is 6.2 megabytes
    (MB), and the video is running at 30 frames per second, then streaming requires
    an Internet connection of 186 megabytes per second (MBps). A typical home broadband
    connection is more like 4MBps. What’s worse, because of traffic congestion and
    hiccups in the network, you can’t count on maintaining the full rated bandwidth
    over the course of a long transmission. Realistically, streaming video should
    use no more than a couple of MBps at most.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 流媒体视频也面临同样的问题。如果一个视频帧是6.2兆字节（MB），并且视频以每秒30帧的速度播放，那么流媒体就需要每秒186兆字节（MBps）的互联网连接。而典型的家庭宽带连接大约只有4MBps。更糟糕的是，由于网络拥堵和波动，你无法指望在长时间传输过程中保持满负荷带宽。实际上，流媒体视频应该最多使用几兆字节每秒。
- en: So how can we fit giant amounts of video data into these small containers? The
    answer is *data compression*—storing data in a format that requires fewer bytes
    than the original format. Compression techniques can be broadly divided into two
    categories. With *lossless compression*, the compressed data can be restored to
    its exact original state. In contrast, *lossy compression* accepts that the restored
    data may be slightly different than the original. Video streaming and storage
    uses a combination of both types of compression. In this chapter, we’ll first
    investigate some general compression techniques using simple examples. Then we’ll
    see how these ideas apply to video, producing highly compressed sequences of images
    that look nearly as good as the uncompressed originals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何将大量的视频数据存储进这些小容器中呢？答案是*数据压缩*——以比原始格式所需更少的字节来存储数据。压缩技术大致可以分为两类。*无损压缩*可以将压缩后的数据恢复到完全原始的状态。而*有损压缩*则接受恢复的数据可能与原始数据略有不同。视频流媒体和存储通常使用这两种压缩方式的结合。在本章中，我们将首先通过简单的例子研究一些通用的压缩技术。接着，我们将看到这些思想如何应用于视频，生成几乎与未压缩的原始图像一样清晰的高度压缩图像序列。
- en: '**Run-Length Encoding**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游程编码**'
- en: 'Most of us have employed some form of lossless compression, though we wouldn’t
    have called it that, because many techniques for lossless compression are commonsense
    ideas. One such method is *run-length encoding*. Suppose I were to show you a
    27-digit number for one minute to see whether you could remember it an hour later.
    That might sound hard, but look at the number:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人都使用过某种形式的无损压缩，虽然我们可能没这么称呼它，因为许多无损压缩的技术其实是常识性的方法。一个这样的例子是*游程编码*。假设我给你展示一个27位的数字，让你看一分钟，看看你是否能在一个小时后记住它。听起来可能很难，但看看这个数字：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I suspect you wouldn’t try to remember each digit individually. Instead, you’d
    count the occurrences of each digit, and remember it as “nine sevens, nine fives,
    and nine twos.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑你不会试图单独记住每个数字。相反，你会统计每个数字的出现次数，并把它记作“九个七，九个五，和九个二”。
- en: That’s run-length encoding in action. Repeats of the same piece of data (in
    this case, a digit) are called *runs*, and when runs are common, we can shorten
    the data by recording the lengths of the runs rather than the whole number. Run-length
    encoding is lossless compression, because if we remember the shorthand version
    of the number, we can reproduce the number in its original form whenever needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游程编码的作用。当相同的数据片段（在这个例子中是数字）重复出现时，这些重复的片段称为*游程*，当游程很常见时，我们可以通过记录游程的长度而不是整个数字来缩短数据。游程编码是无损压缩，因为如果我们记住了简写版本的数字，我们可以在需要时恢复出它的原始形式。
- en: Just by itself, run-length encoding can provide excellent compression for certain
    types of images, such as icons, logos, comic-book-style illustrations— any image
    with large blocks of solid color. When pixels have the same color as their neighbors,
    we can reduce the storage requirements considerably. As an example, I’ll describe
    the system used by the *TGA* image file format. TGA is short for *Truevision Graphics
    Adapter*, an early piece of graphics hardware designed for video editors. The
    file format, if not the adapter, is still in use in the video industry, and is
    probably the simplest example of run-length encoding for images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The image data in a TGA file is compressed on a row-by-row basis. Within each
    row, each run of two or more pixels of exactly the same color is identified. The
    remaining pixels are called *raw* pixels. Consider the selected row in the sample
    image in [Figure 6-1](ch06.html#ch6fig1). In this row, there are several short
    runs of pixels, and several raw pixels that are different from their neighbors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: The selected row has a mix of runs and raw pixels.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The TGA format organizes runs and raw pixels into *packets*. Each packet begins
    with a one-byte header. The leftmost bit of the header byte determines whether
    it is a run packet or a raw packet. The other seven bits denote the size of the
    packet in pixels. Because the smallest packet has one pixel, TGA encodes the packet’s
    size as one less than its actual size; that is, a size field of 0000000 represents
    a size of 1, and 0000001 represents 2, and so on. Following the header is either
    the encoded color of all the pixels in the run, or for a raw packet, the colors
    of each individual pixel. Using the RGB color format, the row of pixels from [Figure
    6-1](ch06.html#ch6fig1) would be encoded as shown in [Table 6-1](ch06.html#ch6tab1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** TGA Encoding of Pixel Row'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '| **Run/raw** | **Size** | **Red** | **Green** | **Blue** | **Description**
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0000001 | 11111111 | 11111111 | 11111111 | Run of two white pixels |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0000010 | 11001100 | 11001100 | 00000000 | Run of three yellow pixels
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0000001 | 11111111 | 11111111 | 11111111 | Raw packet of two pixels;
    first is white |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '|  |  | 00000000 | 10000000 | 00000000 | Second pixel in raw packet; dark green
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0000001 | 00000000 | 00000000 | 11111111 | Run of two blue pixels |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0000000 | 11111111 | 11111111 | 11111111 | One raw white pixel |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: This encoding requires 23 bytes versus the uncompressed size of 30 bytes. This
    *compression ratio* of 30:23, or about 4:3, isn’t very high, but note that a mere
    4 bytes are needed to store rows where every pixel is the same color, like the
    top row of [Figure 6-1](ch06.html#ch6fig1). The overall compression ratio of this
    bitmap in TGA format is an impressive 300:114, or about 5:2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary Compression**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just by itself, run-length encoding can compress pictures with large blocks
    of solid colors, but most of the images in movies aren’t like that. For photographs
    and other types of digital images with lots of color variation, software has to
    work much harder to find patterns exploitable by compression. One of the key tools
    is known as *dictionary compression*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用自身，行程编码能够压缩包含大块纯色的图像，但电影中的大多数图像并不是这样。对于照片和其他类型的数字图像，其中有大量颜色变化，软件必须更加努力地寻找可以通过压缩利用的模式。一个关键工具被称为*词典压缩*。
- en: '***The Basic Method***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本方法***'
- en: Later we’ll see how dictionary compression is used on images, but the idea is
    easiest to understand when it is applied to a text document, so let’s start there.
    An uncompressed text document is stored as a series of character codes such as
    ASCII.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将看到词典压缩如何应用于图像，但最容易理解这一概念的是将其应用于文本文件，因此我们从这里开始。未压缩的文本文件是作为一系列字符代码存储的，例如ASCII。
- en: 'We’ll compress this sample paragraph:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将压缩这个示例段落：
- en: Those pictures created by a computer are called computer graphics. When these
    pictures created by the computer are viewed in a sequence, that sequence is called
    an animation. An entire movie created from an animation, a sequence of pictures
    created by a computer, is called a computer-animated movie.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由计算机创建的图像称为计算机图形。当这些由计算机创建的图像按顺序查看时，这个顺序被称为动画。由动画组成的完整电影，即由计算机创建的一系列图像，称为计算机动画电影。
- en: 'To make this example simpler, I’ll ignore the spaces and punctuation in this
    text and just worry about the letters. There are 234 letters in this paragraph;
    stored as uncompressed ASCII text, the letters would require 234 bytes. To employ
    dictionary compression on this text, we first need a *dictionary*, which in this
    context is a numbered list of every word in the document being compressed. [Table
    6-2](ch06.html#ch6tab2) is our list of words, numbered both in decimal and binary.
    Note that capitalization counts: *an* and *An* are separate entries.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个示例，我将忽略文本中的空格和标点，只关注字母。这个段落中有234个字母；如果以未压缩的ASCII文本存储，这些字母将需要234字节。要对这些文本进行词典压缩，我们首先需要一个*词典*，在这个上下文中，词典是一个编号列表，列出了文档中每个被压缩的单词。[表6-2](ch06.html#ch6tab2)就是我们的单词列表，按十进制和二进制编号。请注意，大写字母和小写字母算作不同的条目：*an*
    和 *An* 是不同的条目。
- en: '**Table 6-2:** Dictionary Compression'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2：** 词典压缩'
- en: '| **Position** | **Binary-encoded position** | **Word** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **二进制编码位置** | **单词** |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 00000 | a |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 00000 | 一个 |'
- en: '| 2 | 00001 | an |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 00001 | 一个 |'
- en: '| 3 | 00010 | An |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 00010 | 一个 |'
- en: '| 4 | 00011 | animated |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 00011 | 动画 |'
- en: '| 5 | 00100 | animation |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 00100 | 动画 |'
- en: '| 6 | 00101 | are |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 00101 | 是 |'
- en: '| 7 | 00110 | by |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 00110 | 由 |'
- en: '| 8 | 00111 | called |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 00111 | 被称为 |'
- en: '| 9 | 01000 | computer |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 01000 | 计算机 |'
- en: '| 10 | 01001 | created |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 01001 | 创建 |'
- en: '| 11 | 01010 | entire |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 01010 | 整个 |'
- en: '| 12 | 01011 | from |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 01011 | 从 |'
- en: '| 13 | 01100 | graphics |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 01100 | 图形 |'
- en: '| 14 | 01101 | in |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 01101 | 在 |'
- en: '| 15 | 01110 | is |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 01110 | 是 |'
- en: '| 16 | 01111 | movie |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 01111 | 电影 |'
- en: '| 17 | 10000 | of |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 10000 | 的 |'
- en: '| 18 | 10001 | pictures |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 10001 | 图像 |'
- en: '| 19 | 10010 | sequence |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 10010 | 顺序 |'
- en: '| 20 | 10011 | the |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 10011 | 那个 |'
- en: '| 21 | 10100 | these |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 10100 | 这些 |'
- en: '| 22 | 10101 | Those |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 10101 | 那些 |'
- en: '| 23 | 10110 | viewed |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 10110 | 查看 |'
- en: '| 24 | 10111 | When |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 10111 | 当 |'
- en: As shown, 5 bits are sufficient to represent the range of positions used. Each
    word in the original paragraph is replaced with its position in this table. For
    example, instead of using eight ASCII codes (64 bits) for each appearance of the
    word *computer*, the 5-bit dictionary entry is used instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，5位足以表示所使用的位置范围。原文中的每个单词都被替换为该表中的位置。例如，代替每次出现的*计算机*使用八个ASCII码（64位），我们改用5位的词典条目。
- en: The dictionary itself takes up space, however, and must be included in the compressed
    document, so we save space only when a word appears more than once. In this example,
    the total number of letters for all words in our dictionary is 116, requiring
    116 bytes. Replacing each of the 48 words in the sample paragraph with a 5-bit
    dictionary reference requires 235 bits, or about 30 bytes. The total compressed
    storage, then, is 146 bytes, which compared to the original 234 uncompressed bytes
    is a compression ratio of about 8:5\. With longer documents the savings will be
    even better, because the text grows much faster than the dictionary. A typical
    novel, for example, is about 80,000 words long, but uses a vocabulary of only
    a few thousand words.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '***Huffman Encoding***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In almost every text, some words are used much more than others. A technique
    called *Huffman encoding* takes advantage of this fact to improve on basic dictionary
    compression.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: To create a Huffman code, the words in the document are ranked by frequency.
    Imagine a children’s story with the 10-word vocabulary shown in [Table 6-3](ch06.html#ch6tab3).
    As with basic dictionary compression, each word is assigned a binary code, but
    here shorter codes are assigned to the words that appear most frequently in the
    story.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-3:** Huffman Code for a Children’s Story'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '| **Word** | **Frequency** | **Binary code** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| the | 25% | 01 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| a | 20% | 000 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| princess | 12% | 100 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| good | 11% | 110 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| witch | 10% | 111 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| evil | 8% | 0010 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| ate | 7% | 0011 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| magic | 4% | 1010 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| toadstool | 2% | 10110 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| forevermore | 1% | 10111 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: 'With the table in place, Huffman code compression is the same as basic dictionary
    compression: each word is replaced with its corresponding binary code. For example,
    the encoding for *the princess ate a magic toadstool* would start with 01 for
    *the*, then 100 for *princess*, and so on. In full, the encoding is:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you may have noticed, the list of binary codes in [Table 6-3](ch06.html#ch6tab3)
    skips some possible codes, such as 011 or 0110\. Skipping codes is necessary to
    make this a *prefix code*, in which no binary code appears at the start of another.
    For example, because 01 is the code for *the*, other codes that begin with 01,
    such as 011 or 0110, are forbidden. Because the individual codes vary in length,
    a prefix code is necessary to know where each code ends. With our example, the
    01 that begins the bit sequence must be the code for *the* because no other code
    starts with 01; the only way to partition the whole sequence is as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we allowed a code that broke the prefix rule, the sequences could become
    ambiguous. Suppose *forevermore* is assigned the code 00\. While this is a shorter
    code, it means the example sequence could also be partitioned as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This would decode as the phrase *the princess forevermore good forevermore magic
    toadstool*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: By assigning the shortest codes to the most common words, Huffman encoding can
    achieve greater compression than dictionary compression alone when data can be
    stored as a relatively small set of codes and some codes are more common than
    others.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为最常见的单词分配最短的编码，霍夫曼编码在数据能够以相对较小的编码集存储且某些编码比其他编码更常见时，比仅使用字典压缩能获得更大的压缩效果。
- en: '**Reorganizing Data for Better Compression**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为了更好的压缩重组数据**'
- en: Unfortunately, the images we see in videos are not good candidates for Huffman
    encoding. Unlike the color-block images we compressed with the run-length technique,
    the pixels in a video image vary across the full range of possible colors. With
    16 million different possible RGB colors, it’s unlikely video images will have
    enough repetition to allow Huffman encoding to work. However, sometimes it’s possible
    to create repetition in varied data by changing how the data is stored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们在视频中看到的图像并不是霍夫曼编码的理想对象。与我们使用游程编码压缩的色块图像不同，视频图像中的像素颜色覆盖了所有可能的颜色范围。由于RGB颜色有1600多万种不同的可能性，视频图像很可能没有足够的重复性来使霍夫曼编码有效。然而，有时可以通过改变数据存储方式，在变化的数据中创造出重复性。
- en: '***Predictive Encoding***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***预测编码***'
- en: 'For one such approach, consider a weather station that records the temperature
    once per hour, and over the course of one day stores the following readings:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以某种方法为例，考虑一个每小时记录一次温度的气象站，在一天的时间里，记录了以下数据：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**COMPRESSION IN ZIP FILES**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**ZIP文件中的压缩**'
- en: Dictionary compression and Huffman encoding are at the heart of most general
    compression schemes. The *.zip* archive format, for example, can choose from a
    half-dozen compression methods but usually employs an algorithm called *deflate*.
    Rather than replacing duplicated data with a reference number from a list of words,
    this algorithm employs a variation of dictionary compression called a *sliding
    window*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字典压缩和霍夫曼编码是大多数通用压缩方案的核心。例如，*.zip*存档格式可以选择多种压缩方法，但通常使用一种叫做*deflate*的算法。与其用一个来自单词列表的参考编号替换重复数据，这个算法使用一种称为*滑动窗口*的字典压缩变体。
- en: With this method, duplicate data is replaced with numerical indicators showing
    where the data occurred previously. In the textual example of [Figure 6-2](ch06.html#ch6fig2),
    there are three duplicate runs of characters. The first member of each pair is
    the number of characters to go back, and the second number is the length of the
    run. For example, the pair 5, 2 means “go back five characters, and copy two characters.”
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，重复的数据被用数字指示符替换，显示数据之前出现的位置。在[图6-2](ch06.html#ch6fig2)中的文本示例中，有三个重复的字符序列。每一对数字的第一个数字是回溯的字符数，第二个数字是连续字符的长度。例如，数字对5,
    2表示“回溯五个字符，并复制两个字符。”
- en: '![image](graphics/f06-02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-02.jpg)'
- en: '*Figure 6-2: Sliding-window compression*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：滑动窗口压缩*'
- en: The compressed version of this text can be symbolically written as “Then t[5,2]
    scar[5,5]ed[16,4]m.” Instead of the number pairs being stored directly, though,
    they are Huffman-encoded, so the most commonly occurring pairs are assigned shorter
    codes. The deflate method is a highly effective general compression scheme, capable
    of reducing the 3,138,473 characters in a raw text version of Tolstoy’s *War and
    Peace* to a *.zip* file of around 930,000 bytes, about a 10:3 ratio.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文本的压缩版本可以象征性地写成“Then t[5,2] scar[5,5]ed[16,4]m。”不过，这些数字对并不是直接存储的，而是经过霍夫曼编码的，因此最常见的数字对会被分配更短的编码。deflate方法是一种非常有效的通用压缩方案，能够将托尔斯泰《战争与和平》的原始文本版本中的3,138,473个字符压缩成大约930,000字节的*.zip*文件，压缩比大约为10:3。
- en: 'If we assume a temperature range of 120 to –50, we can store each temperature
    in an 8-bit byte, using 192 bits total. There aren’t many duplicates in this list,
    though, so Huffman encoding won’t be effective. The situation improves if we rewrite
    this list using *predictive encoding*. For every temperature after the first,
    we’ll record not the temperature itself, but its difference from the previous
    temperature. Now the list looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设温度范围从120到-50，我们可以用一个8位字节存储每个温度，共使用192位。不过，这个列表中没有太多重复项，因此霍夫曼编码并不有效。如果我们使用*预测编码*重新编写这个列表，情况就有所改善。对于第一个温度之后的每一个温度，我们记录的不是温度本身，而是它与前一个温度的差值。现在，列表看起来是这样的：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whereas the original data had few duplicates, the predictive-encoded data has
    many. Now we can apply Huffman encoding with excellent results.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据重复较少，而预测编码后的数据重复性较强。现在我们可以应用霍夫曼编码，取得非常好的效果。
- en: '***Quantization***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***量化***'
- en: 'Another approach, if we are willing to accept some degradation of the data,
    is *quantization*, where we store the data with less precision. Suppose the weather
    station from the previous example also records daily rainfall amounts, taking
    the following readings over the course of three weeks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These readings have two decimal places, but maybe we don’t actually need this
    much precision in the data. For one thing, any amount below 0.05 might represent
    condensation on the collector rather than actual rain; likewise, condensation
    might also be the only difference between readings like 1.23 and 1.21\. So let’s
    leave off the last digit of every number:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By itself, this compresses the data, since storing one place after the decimal
    will take fewer bits than storing two. In addition, the quantized data also has
    several runs of zeros that can be compressed with run-length encoding, and some
    duplicates that can be compressed by Huffman encoding.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: These techniques point to a general multistage approach for compression. First,
    reorganize the data to increase the runs and duplicates, by storing small differences
    between numbers rather than the raw numbers themselves, quantizing the data, or
    both. Then compress the data with run-length and Huffman encoding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**JPEG Images**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have almost all the tools needed to compress video. The logical first
    step in compressing a video is to compress the individual images in the video.
    However, we can’t directly apply predictive encoding and quantization to digital
    photographs and other images with lots of subtle color variation; we need to convert
    these pictures to another format first.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: That’s the idea behind *JPEG*, a common compressed-image format designed specifically
    for digital photographs. (The name is the acronym for the *Joint Photography Experts
    Group* that developed the format.) The compression method for this format is based
    on a couple of key observations of photography and human perception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: First, although pixel colors may vary widely throughout an image, individual
    pixels tend to be similar to their neighbors. If you take a picture of a leafy
    tree against a partly cloudy sky, lots of green leaf pixels will be next to other
    green pixels, blue sky pixels will neighbor blue sky pixels, and gray cloud pixels
    will neighbor gray cloud pixels.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Second, among neighboring pixels, there will be more noticeable variation in
    brightness levels than in color tone. For our tree photograph, each of the myriad
    leaf pixels will reflect a different quantity of sunlight, but the underlying
    color of each pixel will be roughly similar. Also, although the mechanisms of
    human vision are not completely understood, tests indicate that we perceive differences
    in brightness more distinctly than differences in color.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: High compression of digital photographs is possible only with lossy compression;
    we have to accept some degradation of the image. Following these key observations,
    though, allows the JPEG format to throw away the data that is least likely to
    be missed. In our tree photograph, the most important distinctions are the broad
    differences between leaf and sky, or sky and cloud, not between two neighboring
    cloud pixels. After that, the most important distinction is the relative brightness
    of pixels, more so than relative color. The JPEG format therefore gives priority
    to broad differences over fine differences, and brightness over color.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数字照片的高压缩仅能通过有损压缩实现；我们必须接受图像的某些退化。然而，遵循这些关键观察结果，可以使 JPEG 格式丢弃那些最不容易被察觉的数据。在我们的树木照片中，最重要的区分是树叶和天空之间的广泛差异，或者天空和云朵之间的差异，而不是两颗相邻云朵像素之间的差异。之后，最重要的区分是像素的相对亮度，而非相对颜色。因此，JPEG
    格式优先考虑广泛差异而非细微差异，优先考虑亮度而非颜色。
- en: '***A Different Way to Store Colors***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***另一种存储颜色的方式***'
- en: 'JPEG compression divides images into 8×8 blocks of pixels that are independently
    compressed. To compress brightness and color differently, each pixel’s R, G, and
    B values are converted to three other numbers *Y*, *Cb*, and *Cr*. Here, Y is
    the *luminance* of the pixel, or how much light the pixel produces. Cb is the
    *blue difference*, and Cr is the *red difference*. The simplest way to envision
    the YCbCr system is to imagine a dark green video screen with three knobs labeled
    Y, Cb, and Cr initially set to zero: turn up Y and the screen is brighter; turn
    up Cb and the screen becomes more blue and less green; turn up Cr and the screen
    becomes more red and less green. [Table 6-4](ch06.html#ch6tab4) lists a few named
    colors in both systems for comparison. (A historical note: YCbCr is derived from
    the color system used in broadcast television. In the early days of color television,
    the remaining black-and-white televisions could properly display color transmissions
    by interpreting only the Y component of the signal.)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG 压缩将图像划分为 8×8 像素块，并对每个块进行独立压缩。为了分别压缩亮度和颜色，每个像素的 R、G 和 B 值会被转换为三个其他数值 *Y*、*Cb*
    和 *Cr*。这里，Y 表示像素的 *亮度*，即像素产生的光的强度。Cb 是 *蓝色差值*，Cr 是 *红色差值*。最简单的理解 YCbCr 系统的方法是想象一个黑绿色的视频屏幕，屏幕上有三个旋钮标记为
    Y、Cb 和 Cr，初始时都设为零：提高 Y，屏幕变亮；提高 Cb，屏幕变得更蓝且绿色减少；提高 Cr，屏幕变得更红且绿色减少。[表 6-4](ch06.html#ch6tab4)列出了在两种系统中比较的几种命名颜色。（历史注：YCbCr
    来源于电视广播中使用的颜色系统。在早期彩色电视的时代，剩下的黑白电视机通过只解释信号中的 Y 分量就能正确显示彩色图像。）
- en: '**Table 6-4:** Select Colors in the RGB and YCbCr Color Systems'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-4：** RGB 和 YCbCr 颜色系统中的选择颜色'
- en: '| **R** | **G** | **B** | **Color description** | **Y** | **Cb** | **Cr** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **R** | **G** | **B** | **颜色描述** | **Y** | **Cb** | **Cr** |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 255 | 0 | Lime green | 145 | 54 | 34 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 255 | 0 | 青柠绿 | 145 | 54 | 34 |'
- en: '| 255 | 255 | 255 | Pure white | 235 | 128 | 128 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 255 | 255 | 纯白色 | 235 | 128 | 128 |'
- en: '| 0 | 255 | 255 | Aqua | 170 | 166 | 16 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 255 | 255 | 水绿色 | 170 | 166 | 16 |'
- en: '| 128 | 0 | 0 | Maroon | 49 | 109 | 184 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 0 | 0 | 栗色 | 49 | 109 | 184 |'
- en: JPEG compresses the Y, Cb, and Cr data separately, so we can think of each 8×8
    block of pixels as becoming three 8×8 blocks of Y, Cb, and Cr data. Separating
    the data this way takes advantage of the greater variation in brightness than
    in color. Under the YCbCr system, most of the differences between the pixels will
    be concentrated in the Y component. The lower variance in the Cb and Cr blocks
    will make them easier to compress, and because we’re more sensitive to variations
    in luminance than variations of color, the Cb and Cr blocks can be compressed
    more heavily.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JPEG 分别压缩 Y、Cb 和 Cr 数据，因此我们可以将每个 8×8 像素块看作是由三个 8×8 的 Y、Cb 和 Cr 数据块组成。这种数据分离方式利用了亮度比颜色变化更大的特点。在
    YCbCr 系统下，大多数像素之间的差异会集中在 Y 分量中。Cb 和 Cr 数据块的低方差使得它们更容易压缩，而且由于我们对亮度变化的敏感度高于对颜色变化的敏感度，Cb
    和 Cr 数据块可以进行更高比例的压缩。
- en: '***The Discrete Cosine Transform***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***离散余弦变换***'
- en: The conversion to YCbCr follows the observation that brightness is more important
    than color. To take advantage of the greater importance of broad changes over
    narrow changes, though, we need to convert each 8×8 data blocks yet again. The
    *discrete cosine transform (DCT)* converts the absolute luminance and color data
    into relative measurements of how these values differ from pixel to pixel. Although
    this transformation is applied to an entire 8×8 block of numbers, I’ll first illustrate
    the idea with a single row of eight numbers from the luminance (Y) block, shown
    as shades of gray in [Figure 6-3](ch06.html#ch6fig3).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: A row of luminance levels*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: To begin the DCT, we subtract 128 from each number, which has the effect of
    moving the 0–255 range to a range centered around 0, so that maximum brightness
    is 127 and absolute black is –128\. The resulting luminance levels for the row
    are depicted as a line chart in [Figure 6-4](ch06.html#ch6fig4).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: Subtracting 128 from each luminance level centers the range of
    possible numbers around 0.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The DCT produces eight new numbers that each combine the eight luminance levels
    in a different way. [Figure 6-5](ch06.html#ch6fig5) shows the DCT of the previous
    figure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: The discrete cosine transform of the data in [Figure 6-4](ch06.html#ch6fig4).*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the numbers are labeled with a range from “coarse” to “fine.” The
    leftmost number in the DCT is the simplest combination of the luminance levels:
    their sum. Thus, the first number is the overall brightness of the pixels, and
    will be positive for a bright row of pixels and negative for a dark row. The second
    number effectively compares the luminance levels on the left end of the row against
    those on the right, and is positive in this example because our luminance levels
    are brighter on the left than on the right. The rightmost number effectively compares
    each luminance value against its immediate neighbors, and is close to 0 here because
    the numbers in [Figure 6-4](ch06.html#ch6fig4) change gradually.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'These DCT numbers are the coefficients that result from an operation called
    *matrix multiplication*. If your eyes just glazed over, don’t worry: the operation
    involves nothing more than multiplication and addition. We produce each coefficient
    by multiplying the luminance values by a different, predetermined vector. In this
    context, a *vector* is just an ordered list of numbers. The eight vectors used
    in the DCT are illustrated in [Figure 6-6](ch06.html#ch6fig6). (The numbers in
    each vector are related to the cosine function from trigonometry, which is where
    the discrete cosine transform gets its name, but we can safely ignore that for
    this discussion.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: The vectors needed for our single-row DCT*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: To produce a coefficient for our luminance row, we multiply each number in a
    vector by the luminance in the same position. For example, [Table 6-5](ch06.html#ch6tab5)
    shows the computation of the Vector 2 coefficient for our luminance row. Each
    number from the luminance row is multiplied by the number in the same position
    in Vector 1; then, these products are summed to get 157.386.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-5:** Computing the Coefficient for Vector 2'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '| **Position** | **Luminance (from [Figure 6-4](ch06.html#ch6fig4))** | **Vector**
    | **Product** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| 1 | 76 | 0.49 | 37.24 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| 2 | 127 | 0.416 | 52.832 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| 3 | 127 | 0.278 | 35.306 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| 4 | 76 | 0.098 | 7.448 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| 5 | 25 | –0.098 | –2.45 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| 6 | –26 | –0.278 | 7.228 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| 7 | –77 | –0.416 | 32.032 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 8 | 25 | –0.49 | –12.25 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| Total |  |  | 157.386 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: Looking at the vectors of [Figure 6-6](ch06.html#ch6fig6), you can see how each
    combines the luminance levels differently. Because every number in Vector 1 is
    the same positive number, the Vector 1 coefficient becomes a measure of overall
    brightness. Because Vector 2’s numbers gradually sweep from high to low, the second
    coefficient will be positive when luminance tends to fall off from the left to
    right in the pixel row, and negative when luminance tends to increase. Vector
    3’s coefficient is a measure of how the ends of the row differ from the middle,
    and so on. You’ve already seen the resulting coefficients charted in [Figure 6-5](ch06.html#ch6fig5);
    [Table 6-6](ch06.html#ch6tab6) shows the result numerically.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-6:** Coefficients from the Discrete Cosine Transform of the Sample
    Luminance Row'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '| **Vector number** | **Coefficient** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| 1 | 124.804 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| 2 | 157.296 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| 3 | –9.758 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| 4 | –87.894 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| 5 | 18.031 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| 6 | –49.746 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| 7 | 23.559 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| 8 | –13.096 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: 'The process is reversible: we can retrieve the original luminance numbers from
    [Figure 6-4](ch06.html#ch6fig4) by multiplying the eight coefficients against
    eight different vectors, a process called the *inverse discrete cosine transform
    (IDCT)*. [Table 6-7](ch06.html#ch6tab7) shows how the second luminance value,
    127, is extracted from the coefficients.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-7:** Computing the Second Luminance Value from the Coefficients'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '| **Position** | **Coefficient** | **Vector** | **Product** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| 1 | 124.804 | 0.354 | 44.125 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| 2 | 157.296 | 0.416 | 65.393 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| 3 | –9.758 | 0.191 | –1.867 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| 4 | –87.894 | –0.098 | 8.574 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| 5 | 18.031 | –0.354 | –6.375 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| 6 | –49.746 | –0.49 | 24.395 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| 7 | –23.559 | –0.462 | –10.833 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| 8 | –13.096 | –0.278 | 3.638 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| Total |  |  | 127 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: 'The DCT, then, gives us a different way of storing the same numbers: as the
    relationship between the data rather than the data itself. Why is this useful?
    Remember that fine distinctions between pixels are less noticeable than broader
    distinctions. Later, you’ll see how the DCT allows the JPEG format to compress
    the fine details more than the broad.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '***The DCT for Two Dimensions***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JPEG compression works not on rows of pixels but on 8×8 pixel blocks, so now
    let’s see how the DCT operates in two dimensions. The one-dimensional DCT multiplies
    eight vectors with the original eight numbers to produce eight coefficients. The
    two-dimensional DCT, though, requires 64 *matrices*, each matrix being an 8×8
    table of numbers. Like the vectors, each matrix will multiply all 64 pieces of
    data in the 8×8 block.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The matrices themselves are two-dimensional combinations of the vectors we saw
    earlier. This is easiest to understand pictorially. [Figure 6-7](ch06.html#ch6fig7)
    shows the combination of a horizontal Vector 1 and a vertical Vector 1\. Because
    the numbers in Vector 1 are all the same, the numbers in the resulting matrix
    are as well. In these matrix illustrations, lighter gray means a higher number.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-07.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: The matrix combination of Vector 1 and itself*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-8](ch06.html#ch6fig8), horizontal Vector 1 is combined with vertical
    Vector 2\. The resulting matrix gradually varies from top to bottom as Vector
    2 gradually varies, but doesn’t vary left to right because the numbers in Vector
    1 don’t vary.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: The matrix combination of Vector 1 and Vector 2*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-9](ch06.html#ch6fig9) shows a last example, Vector 8 combined with
    Vector 8\. Because Vector 8 swings back and forth from positive to negative, the
    combination matrix has a checkerboard quality.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: The matrix combination of Vector 8 and itself*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The two-dimensional DCT replaces each of the 64 numbers in an 8×8 block with
    a matrix coefficient. [Figure 6-10](ch06.html#ch6fig10) shows which matrices are
    used for a few locations. Similar to the one-dimensional DCT, the coefficient
    in the upper left, which is the same shown in [Figure 6-7](ch06.html#ch6fig7),
    sums all the numbers in the original block equally. As we progress downward and
    to the right, the distinctions being measured grow finer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-10.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Some of the matrices used in the two-dimensional DCT*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the two-dimensional DCT, I’ll use just the luminance values of
    the pixel block shown in [Figure 6-11](ch06.html#ch6fig11).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-11.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: A block of pixels and the associated luminance (Y) block*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-12](ch06.html#ch6fig12) shows the same luminance block with 128 subtracted
    from each number to make a range from –127 to 128 centered around 0.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-12.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: The luminance block from [Figure 6-11](ch06.html#ch6fig11) with
    the range of possible values centered around 0*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-13](ch06.html#ch6fig13) shows the luminance block after DCT. Each
    number is the coefficient resulting from multiplying the matrix of luminance values
    in [Figure 6-12](ch06.html#ch6fig12) with one of the matrices from [Figure 6-10](ch06.html#ch6fig10).
    Remember that these numbers, too, are centered around 0\. So the 132 in the upper
    left, for example, indicates a high luminance level for the block as a whole.
    Notice that the numbers in the upper left are largest in magnitude (furthest from
    0 in either direction), indicating that broad luminance differences are much greater
    than the fine differences in this pixel block. This result is typical of JPEG-encoded
    photographs.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-13.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: The DCT of the block in [Figure 6-12](ch06.html#ch6fig12)*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '***Compressing the Results***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now the real compression can begin, the first step of which is quantization.
    [Figure 6-14](ch06.html#ch6fig14) shows the 8×8 block of divisors used for quantizing
    the luminance block. Each number in the coefficient block of [Figure 6-13](ch06.html#ch6fig13)
    is divided by the number in the same position in [Figure 6-14](ch06.html#ch6fig14),
    with results rounded to the nearest whole number. This degrades the image through
    quantization error, but note that the divisors in [Figure 6-14](ch06.html#ch6fig14)
    are smallest in the upper left. Thus, the quantization error is most pronounced
    in the coefficients that measure the finest distinctions, where the error is least
    likely to be noticed. The actual values of the divisors varies according to the
    compression quality, with larger divisors used to quantize the Cr and Cb blocks,
    but the divisor block always follows this general pattern (lower values in the
    upper left, higher in the bottom right).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-14.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: The divisors used to quantize luminance blocks*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The result of quantization for our sample block is shown in [Figure 6-15](ch06.html#ch6fig15).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: You can see how suitable these numbers are for run-length and Huffman encoding.
    Most of the coefficients have been quantized all the way down to 0, with many
    duplicate coefficients among the rest.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: After quantization, nonzero results tend to cluster in the upper left of the
    matrix, so the quantized numbers are listed in the zigzag pattern shown in [Figure
    6-16](ch06.html#ch6fig16).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-15.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: The quantized luminance block*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-16.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: Storing coefficients in a zigzag order*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'This zigzag pattern tends to produce a very long run of zeros at the end, as
    it does in our example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To encode the runs of zeros, we replace each nonzero entry in the list by a
    pair of numbers: the number of zeros skipped (possibly none), and the coefficient
    itself. For example, the eighth number in our list is a –2 that is preceded by
    one 0\. This would become the number pair 1, –2\. At this stage, our list looks
    like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Some of these number pairs, such as 0, –1, appear very frequently in these lists
    compared to other pairs like 0, 10\. For maximum compression, the JPEG standard
    defines a Huffman encoding for every possible number pair in these lists. The
    common 0, –1 pair, for example, becomes the short Huffman code 001, while the
    uncommon 0, 10 pair becomes the longer code 10110010\. There’s also a special
    code, 1010, to signal that all the rest of the coefficients in the list are 0\.
    The Huffman encoding for our list is shown in [Table 6-8](ch06.html#ch6tab8).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-8:** The Huffman Encoding of the Coefficients from [Figure 6-15](ch06.html#ch6fig15)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '| **Zeros skipped** | **Coefficient** | **Huffman encoding** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| 0 |   8 | 10110000 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| 0 | 10 | 10110010 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| 0 | –7 | 100111 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| 0 | –7 | 100111 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| 0 |   6 | 100010 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| 0 | –4 | 100100 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| 1 | –2 | 11100110 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| 0 |   1 | 000 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| 0 | –2 | 0110 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| 0 | –1 | 001 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| 0 | –1 | 001 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| 0 |   1 | 000 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| 0 | –1 | 001 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| 1 | –1 | 11001 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| 2 |   1 | 110110 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| 2 | –1 | 110111 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| (Nothing left but zeros) |  | 1010 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: All of the bits in the rightmost column, strung together, represent the compressed
    encoding of our original luminance block. The original block represented the luminance
    levels as 64 bytes, or 512 bits total. In contrast, the encoding in [Table 6-8](ch06.html#ch6tab8)
    uses a mere 88 bits.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The two color blocks, Cr and Cb, would show even higher compression because
    the divisors used on the color blocks are even larger, which produces smaller
    numbers with shorter Huffman codes and more zeros for the run-length encoding.
    Overall, JPEG images typically achieve a 10:1 compression ratio. The amount of
    compression can be increased or reduced by using smaller or larger divisors than
    those shown in [Figure 6-14](ch06.html#ch6fig14). These divisors are adjusted
    by the “quality” slider in image-manipulation programs. Sliding the control to
    “low quality” increases the divisors, reducing the file size while increasing
    the quantization error.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '***JPEG Picture Quality***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: High compression is great only if the restored image is indistinguishable from
    the original, or nearly so. Typically the alterations JPEG compression makes to
    an image are difficult to see. To get a feel for the changes introduced by compression,
    let’s compare the original block of luminance values to the block that results
    from compressing and decompressing, as shown in [Figure 6-17](ch06.html#ch6fig17).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-17.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: The original luminance block, and the result of compressing and
    decompressing the block*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s tough to visually compare these two blocks of numbers, [Figure 6-18](ch06.html#ch6fig18)
    shows the differences as a grayscale matrix. As you can see, most of the matrix
    is neutral gray, indicating numbers very close to the original.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-19.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-19: The amount of error in each location of the luminance block*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The best evidence for the quality of JPEGs is shown in [Figure 6-19](ch06.html#ch6fig19).
    On the top is an uncompressed digital photograph. Because this photo is in grayscale,
    we don’t need RGB pixel color, just a single byte indicating the grayscale level.
    At a resolution of 975×731, this uncompressed photo requires just under 713 kilobytes
    of storage. In the middle is a compressed JPEG version of the original photo,
    requiring just 75 kilobytes of storage, which is virtually indistinguishable from
    the original. The photo on the bottom is a low-quality JPEG using larger divisors.
    While the photo takes up only about 7 kilobytes, compression artifacts are clearly
    visible. Many of the individual 8×8 pixel blocks have been reduced to solid squares
    of the same gray level. In general, JPEG can result in a 10:1 compression ratio
    without sacrificing visual quality.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**Compressing High-Definition Video**'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JPEG format does a fantastic job of compressing images with only small sacrifices
    in quality, but for high-definition video we need even more compression. Remember,
    uncompressed high-definition video requires about 186MBps. Individually compressing
    each image as a JPEG would reduce that requirement to about 18MBps—a big improvement,
    but for streaming or disc storage we need to shrink the data to just a few MBps
    per second.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-18.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-18: An uncompressed photo (top), high-quality JPEG compression (middle),
    and low-quality JPEG compression (bottom)*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '***Temporal Redundancy***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To hit this target, video compression techniques take advantage of similarities
    between images in sequence. [Figure 6-20](ch06.html#ch6fig20) shows an image sequence
    from a movie’s opening credits.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-20.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-20: A few frames of an opening title sequence*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Each of these images will be shown for several seconds; which means that the
    sequence will contain many duplicate frames in a row. Also, even as the video
    transitions from one image to the next, most of the picture remains unchanged.
    Only the area in the center varies.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the image sequence shown in [Figure 6-21](ch06.html#ch6fig21).
    Although each frame differs from the next, the same elements are present in each
    frame, just in different places on the screen.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-21.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-21: An image sequence with a moving object*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: These examples show two different forms of *temporal redundancy*, continuity
    of data from one frame to the next. Compression that exploits such redundancy
    is called *temporal compression*, and as we’ll see in the next section, it’s the
    key to achieving the compression ratios needed for video streaming and storage.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '***MPEG-2 Video Compression***'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One method of temporal compression is employed by *MPEG-2*, a common video format
    supported by Blu-ray discs and digital broadcast television. More advanced techniques
    exist, but they are extensions of the ideas demonstrated here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**Groups of Frames**'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: MPEG-2 videos are divided into sequences of around 15 frames called *groups
    of pictures (GOPs)*. Exactly one frame in each GOP is selected to be a basic JPEG-encoded
    image called an *intracoded frame (I-Frame)*. This frame is the rock upon which
    the rest of the GOP is built. All of the other frames use temporal compression,
    which means they are stored not as the absolute colors of the pixels in the image,
    but by how those colors differ from those in another image in the GOP, as we’ll
    see shortly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The other frames in the group are assigned one of two types, *predicted frames
    (P-Frames)* and *bidirectional frames (B-Frames)*. A P-Frame stores the difference
    between its pixels and those of a previous frame, while a B-Frame stores the difference
    between its pixels and those of a previous *and* a later frame.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: A GOP is shown in [Figure 6-22](ch06.html#ch6fig22), with arrows indicating
    the frames referenced by the temporal compression. As you can see, everything
    depends on the I-Frame. During playback, it must be decoded before any other image
    in the GOP, after which the frames that directly reference the I-Frame can be
    decoded, and so on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-22.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-22: A GOP, or group of pictures*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Grouping pictures this way simplifies encoding and decoding, and also limits
    the length of the reference “chain.” Just like a photocopy of a photocopy, the
    longer the chain of temporal compression, the fuzzier the image gets. The regular
    appearance of I-Frames is also what allows you to see images as you fast-forward
    or rewind; the video player just picks out the I-Frames, which can be decoded
    and displayed independently of the other frames in its GOP.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The MPEG specification gives encoding software wide discretion in forming GOPs.
    The number of I-Frames, which directly determines the size of GOPs, is up to the
    encoder, as is the number of B-Frames between the other frame types. Like the
    divisors used in JPEG quantization, the ability to change the relative numbers
    of the three frame types offers a trade-off between quality and compression. In
    applications where compression is paramount, like videoconferencing, I-Frames
    are rare and B-Frames are common, while in a Blu-ray, the encoder will use as
    many I-Frames as possible while still fitting all the video data on the disc.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Temporal Compression**'
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'So how does the temporal compression of P-Frames and B-Frames work? In this
    example, we’re compressing a P-Frame by referencing an I-Frame. First, the pixels
    in the P-Frame are divided into 16×16 *macroblocks*. For each macroblock, the
    I-Frame is searched for a matching block of pixels with the same color data. This
    matching block may not appear in exactly the same place in the I-Frame, though,
    so it is indicated by its *offset*: the difference between the location in the
    P-Frame and the location in the I-Frame, expressed in screen coordinates. For
    example, an offset of –100, 50 indicates that the macroblock’s location in the
    I-Frame is 100 pixels left and 50 pixels down from its location in the P-Frame,
    as shown in [Figure 6-23](ch06.html#ch6fig23).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-23.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-23: A macroblock in a P-Frame referencing a matching block of pixels
    in a previous frame*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, an exact match won’t be found, so in addition to storing the
    location of the best match, the differences between the two macroblocks must also
    be stored. [Figure 6-24](ch06.html#ch6fig24) shows a luminance block from the
    P-Frame and the best match in the I-Frame. (I’m using 8×8 blocks instead of a
    full 16×16 macroblock to keep the example manageable.)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-24.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-24: A luminance block and its best match in a prior frame*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, a block of differences is computed: each number in the I-Frame block
    is subtracted from the number in the same position in the P-Frame block. The result
    for our example is shown in [Figure 6-25](ch06.html#ch6fig25).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-25.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-25: The difference between the two luminance blocks in [Figure 6-24](ch06.html#ch6fig24)*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Because the blocks are a close match, these values are all small. This is a
    form of predictive encoding, just like the list of temperatures shown earlier
    in the chapter. By storing differences, we’ve made the range of data much smaller,
    and therefore more easily compressed. When we apply the DCT and quantize the results,
    the numbers are downright tiny, as shown in [Figure 6-26](ch06.html#ch6fig26).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f06-26.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-26: The result of quantizing the block in [Figure 6-25](ch06.html#ch6fig25)
    and applying the DCT*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'This block is highly susceptible to the last stage of compression: the combination
    of run-length and Huffman encoding. As shown in [Table 6-9](ch06.html#ch6tab9),
    the original luminance block has been reduced to a mere 39 bits.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-9:** The Huffman Encoding of the Numbers in [Figure 6-26](ch06.html#ch6fig26)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '| **Run length** | **Coefficient** | **Huffman encoding** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| 4 |   1 | 1110110 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| 1 | –1 | 11001 |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| 0 |   1 | 000 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| 0 |   1 | 000 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| 0 | –1 | 001 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| 1 |   1 | 11000 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| 7 |   1 | 111110100 |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| (Nothing left but zeros) |  | 1010 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: Not every macroblock in the P-Frame is encoded in this way. In some cases, a
    macroblock may not be similar enough to any block of pixels in the previous frame
    to save any space by storing the difference. Those macroblocks can be recorded
    directly, like the macroblocks in an I-Frame. For a B-Frame, matching macroblocks
    can be found in a previous frame or a later frame, which improves the odds of
    a close match.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '***Video Quality with Temporal Compression***'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Temporal compression depends upon temporal redundancy—sequences of frames with
    few changes. For this reason, some videos compress much better than others. Movies
    with lots of camera movement, like *Cloverfield* or *The Blair Witch Project*,
    are difficult to compress, while movies with long takes where the camera doesn’t
    move, like *2001: A Space Odyssey*, are ideal.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, video compression is a bit of an art as well as a science. As stated
    earlier, different MPEG-2 encoders can produce different results for the same
    sequence of images. Shorter GOPs, with more I-Frames and fewer B-Frames, produce
    better-looking video than longer GOPs, but longer GOPs mean better compression.
    An encoder can vary the mix of frames even within the same video, using longer
    GOPs when there’s high temporal redundancy and shorter GOPs when there isn’t.
    Also, good encoders will try to line up GOP boundaries with sharp cuts in a movie;
    if you’ve ever seen a video that was momentarily very blocky when the scene changed,
    it’s likely because a GOP stretched over the cut.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the question of performance, especially if the video is being compressed
    in real time, as with a live event. There might not be enough time to find the
    absolute best match for a macroblock in the other frame.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Playback quality can vary as well. For example, because of how frames are broken
    into individually processed macroblocks, seams may appear along the borders of
    the blocks. To reduce this effect, a decoder may apply a *deblocking filter*.
    This smoothes block boundaries by averaging pixel colors, much like the anti-aliasing
    methods shown in previous chapters. The strength of the filter can be adjusted
    based on the likelihood of a clean boundary. In a B-Frame, for example, if one
    block references the previous frame while an adjacent block references the next
    frame, there’s a greater likelihood of a rough boundary, which calls for stronger
    filtering.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, the resolution of the video and the display resolution may not
    match. For example, when you’re streaming an episode of the old cop show *Adam-12*
    (it’s not just me, right?) on a high-definition television, either the television
    or the player has to convert the original 640×480 images to fill the 1920×1080
    display. This is the same problem we solved in [Chapter 5](ch05.html#ch05) with
    texture mapping—applying a bitmap to a larger area—and video devices can employ
    the same sorts of techniques. Early high-definition players effectively used nearest-neighbor
    sampling, which produced poor results. Newer players employ techniques similar
    to trilinear filtering. Instead of blending between bilinear samples from two
    different levels in a mipmap, however, they blend between successive frames. This
    is especially effective in smoothing objects in motion.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Although not as computationally intense as the original encoding, playing back
    a temporally compressed video is still a lot of work for a processor. Also, the
    structure of a GOP requires decoding the frames out of order. This in turn requires
    that frames be *buffered*, held in a queue prior to display. For streaming video,
    much larger buffers are used so that minor hiccups in the network don’t disrupt
    playback.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**The Present and Future of Video Compression**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The latest video compression standard, known as H.264 or MPEG-4, extends the
    techniques used in MPEG-2 but isn’t fundamentally different. The primary differences
    improve the quality of macroblock matching. Instead of being matched against just
    one or two other frames, macroblocks can be matched against 32 other frames. Also,
    the 16×16 macroblocks themselves can be broken down into separately matched 8×8
    blocks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Through such improvements, MPEG-4 can often achieve twice the compression ratio
    of MPEG-2 with the same quality result. For that reason, MPEG-4 is an industry
    standard for both streaming and storage. Most Blu-ray videos use it, as do YouTube
    and Netflix. Its chief competition is a format called Theora, which uses similar
    compression methods but is freely licensed, unlike the proprietary MPEG-4.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Today’s compression formats do an amazing job at shrinking video data, but they
    do so at a high computational cost. The next time you watch a clip on YouTube,
    think about a GOP, all the macroblocks being copied and updated from one frame
    to the next, and all the number crunching that goes into performing the DCT over
    and over again. It’s a dizzying amount of calculation just to show a cat falling
    off a piano.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Even more computational horsepower will be needed in the future. The new *ultra
    high definition (UHD)* format, seen in theaters in films like Peter Jackson’s
    *Hobbit* series, is starting to trickle down to home video. UHD images are 3840×2160,
    which is four times the number of pixels as current high definition. The frame
    rate will also increase, from today’s 24 or 30 fps to 48, 60, or even 120 fps.
    UHD video could increase the bit requirements from today’s 1,400Mbps to over 23,000,
    which will require a corresponding increase in bandwidth and disc storage capacity—unless
    someone clever comes up with an even better way for software to shrink the data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
