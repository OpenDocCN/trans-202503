- en: '![Image](../images/common1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MAD MOVEMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll use a few different types of motors to make two of
    the most impressive projects in this book: an animatronic head that swivels its
    eyes and talks and a robotic, remote-controlled rover. These toys can amuse the
    Mad Scientist for hours.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXPERIMENT 8: MAKING A SERVOMOTOR MOVE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One way to get things moving is to use a servomotor, like the one shown in [Figure
    6-1](ch06.xhtml#ch6fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: A servomotor connected to a micro:bit*'
  prefs: []
  type: TYPE_NORMAL
- en: A *servomotor* is a small, low-powered motor with an arm you can control with
    your program. Unlike most other motors, servomotors don’t rotate all the way around.
    Instead, they have a 180-degree range of motion. Your program can set the position
    of the motor arm to a particular angle.
  prefs: []
  type: TYPE_NORMAL
- en: In this experiment, you’ll learn how to connect a servomotor to a micro:bit
    and investigate how the servomotor moves.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0132-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Micro:bit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Servomotor** A 9-g servomotor is ideal. A micro:bit has just enough power
    to drive a small servomotor but would struggle with a full-size one. Choose a
    servomotor that is 3V compatible. See the [appendix](app01.xhtml) for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alligator clip-to-male jumper cables** These connect the micro:bit to the
    servomotor. (You can also use male-to-male jumper cables; see below.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**USB connection to a computer, Monk Makes Power for micro:bit or USB battery
    pack** An AAA battery box may (depending on the servo) work, but AAA batteries
    may not provide enough voltage for the servomotor. See the [appendix](app01.xhtml)
    for options for powering your micro:bit.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the alligator clip-to-male jumper cables, you could use the
    more common male-to-male jumper cables by pushing one end of the cable into the
    servomotor connector and clipping an alligator cable to the other end. However,
    you would need to make sure the connections don’t accidentally short out. In general,
    alligator clip-to-male jumper cables will be a useful thing to have in your micro:bit
    toolbox, so it’s worth getting some.
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Connect the servomotor to your micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to access the book’s code repository and click the link for **Experiment 8: Servomotors**.
    Once the program has opened, click **Download** and then copy the hex file onto
    your micro:bit. If you get stuck on this, head back to [Chapter 1](ch01.xhtml#ch01).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you prefer to use Python, you’ll find the code for this at the same website.
    For instructions for downloading and using the book’s examples, see “Downloading
    the Code” on [page 34](ch01.xhtml#page_34). The Python file for this experiment
    is *Experiment_08.py*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Servomotors come with different kinds of arms that can be attached to the cog-like
    shaft of the motor. For this project, select a simple arm like the one shown in
    [Figure 6-1](ch06.xhtml#ch6fig1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE** *Your servomotor should come with a little screw. This is intended
    to fix the arm more permanently to the shaft. If you’re planning to do the animatronic
    head project, keep the screw nearby; otherwise, put it in a safe place for later
    use.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect your micro:bit to the servomotor using the alligator clip, as shown
    in [Figure 6-2](ch06.xhtml#ch6fig2).![Image](../images/06fig02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-2: A servomotor connected to a micro:bit*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The servomotor has three connections, which are color-coded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Control** Orange or yellow (This pin controls the position of the servomotor’s
    arm.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**+V** The red wire is the positive power wire. Servomotors ideally use 5V,
    but most small servomotors will also work with the 3V of a micro:bit.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**GND** Usually brown, sometimes black (This is the negative power wire.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once powered up, the servomotor arm should jump to a 90-degree position, perpendicular
    to the servomotor. The micro:bit will use this position as a reference point.
    If the arm isn’t at 90 degrees, take it off and put it back on so that it is,
    as shown in [Figure 6-1](ch06.xhtml#ch6fig1). If you plan to make the animatronic
    head, use the small screw to fix the arm in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have a functioning servomotor! Pressing button A should move the servo
    arm 10 degrees in one direction. Pressing button B should move the servo arm 10
    degrees in the other direction. If you press both buttons together, the current
    angle of the arm should scroll across the micro:bit’s display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both programs follow the same approach of first setting the servomotor’s angle
    to 90 degrees and then waiting for button presses to increase the angle, decrease
    it, or display it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocks Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the Blocks code for this experiment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0135-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We use a variable called `angle` to remember the current angle of the servomotor.
    We define the `angle` variable in the `on start` block and give it an initial
    value of 90\. When the next servo `write pin` block runs, it moves the servo arm
    to the position set in `angle` so that the arm jumps to a 90-degree angle on power-up.
  prefs: []
  type: TYPE_NORMAL
- en: If you press button A, the `on button A pressed` block is called. If you press
    button B, `on button B pressed` is called. The buttons work in a similar way.
    The block for button A first checks whether the angle is still greater than or
    equal to 10 and, if so, subtracts 10 from the angle to move the arm in one direction.
    The block for Button B checks whether the angle is less than or equal to 170 and,
    if it is, adds 10 to the angle and moves the arm in the opposite direction. Both
    use the `servo write pin` to set the servo to the new angle as a result of the
    buttons being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '**MicroPython Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is the MicroPython version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: from microbit import *
  prefs: []
  type: TYPE_NORMAL
- en: 'def set_servo_angle(pin, angle):'
  prefs: []
  type: TYPE_NORMAL
- en: duty = 26 + (angle * 51) / 90
  prefs: []
  type: TYPE_NORMAL
- en: pin.write_analog(duty)
  prefs: []
  type: TYPE_NORMAL
- en: angle = 90
  prefs: []
  type: TYPE_NORMAL
- en: set_servo_angle(pin2, angle)
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if button_a.was_pressed() and angle >= 10:'
  prefs: []
  type: TYPE_NORMAL
- en: angle -= 10
  prefs: []
  type: TYPE_NORMAL
- en: set_servo_angle(pin2, angle)
  prefs: []
  type: TYPE_NORMAL
- en: 'if button_b.was_pressed() and angle <= 170:'
  prefs: []
  type: TYPE_NORMAL
- en: angle += 10
  prefs: []
  type: TYPE_NORMAL
- en: set_servo_angle(pin2, angle)
  prefs: []
  type: TYPE_NORMAL
- en: 'if button_a.is_pressed() and button_b.is_pressed():'
  prefs: []
  type: TYPE_NORMAL
- en: display.scroll(str(angle))
  prefs: []
  type: TYPE_NORMAL
- en: 'The MicroPython code works in much the same way as the Blocks code. But unlike
    in the Blocks code, there is no predefined function to set the servomotor to a
    particular angle. Fortunately, we can write our own method using a little math
    and PWM analog outputs (see “Making an Analog Signal: Pulse Width Modulation”
    on [page 8](ch01.xhtml#page_8)), which generate the pulses that our servomotor
    expects (more on this next).'
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works: Servomotors and Pulses**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You control servomotors by sending them a series of repeating electrical pulses—in
    this case, from the micro:bit. The pulses are generated by turning a pin on and
    off very quickly. The servomotor knows how to act based on how long the pulse
    has been high (3V) over a certain time period. The proportion of time that the
    signal is high, and thus the pin is on, is known as the *duty cycle*. This is
    different from the actual amount of time that the signal is high, which is known
    as the *pulse width*. We refer to this amount of time, measured in milliseconds
    (ms), as a *width* because we can visualize pulses as a square wave (see [Figure
    6-3](ch06.xhtml#ch6fig3)). The total length of the wave (between each *on* pulse)
    is the *period*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: Pulses controlling a servomotor*'
  prefs: []
  type: TYPE_NORMAL
- en: A servomotor expects to receive a pulse every 20 milliseconds, or at a rate
    of 50 pulses a second. Each pulse has a width between 0.5 milliseconds and 2.5
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 6-3](ch06.xhtml#ch6fig3), the length of the pulse
    determines the position of the arm. If the pulse width is 0.5 ms, the servomotor’s
    arm will be at one end of its range (0 degrees). If the pulse width is 1.5 ms,
    the arm will be at its center position (90 degrees). And if the width is 2.5 ms,
    the arm will be at 180 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Conveniently, the micro:bit’s default frequency for analog output (see [Chapter
    1](ch01.xhtml#ch01)) is 50Hz—exactly the right frequency for a servomotor. However,
    even the longest pulse is only 2.5 ms out of a total period of 20 ms, meaning
    that the longest pulse will only be high about one-tenth of the time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-4](ch06.xhtml#ch6fig4) helps to explain how the numbers used in the
    MicroPython `set_servo_angle` function were calculated. The *duty value* is the
    number supplied to the `set_servo_angle` function. This value must be between
    0 and 1023, where 0 is no pulse at all and 1023 is a pulse so long that it lasts
    until the next cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: Correspondence of duty values to pulse widths to servo arm angles*'
  prefs: []
  type: TYPE_NORMAL
- en: The top line of [Figure 6-4](ch06.xhtml#ch6fig4) shows the servo arm’s range
    of positions in terms of angles from 0 to 180 degrees. The code must convert this
    into a different range of numbers, from 0.5 to 2.5, that are the pulse widths
    corresponding to those angles.
  prefs: []
  type: TYPE_NORMAL
- en: To convert an angle in degrees to a pulse width in milliseconds, we’ll start
    with the information that a pulse of length 0.5 ms is equal to an angle of 0 degrees
    and a pulse of length 2.5 ms is equal to an angle of 180 degrees. We can then
    find the degrees per millisecond by dividing the range of degrees (180) by the
    range of pulse lengths (2), giving 90 degrees per millisecond. Then, to calculate
    the pulse length of a new angle, we begin with our baseline, 0.5 ms and add the
    angle we are using divided by 90, the degrees per millisecond.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example. If the angle is 0 degrees, the pulse length in milliseconds
    will be 0.5 (0.5 + 0/90 = 0.5). If the angle is 90 degrees, the pulse length will
    be 0.5 + (90/90) = 1.5 ms. And if the angle is 180 degrees, the pulse length will
    be 0.5 + (180/90) = 2.5 ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a formula for the pulse length for an angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pulse_length` = 0.5 + `angle`/90'
  prefs: []
  type: TYPE_NORMAL
- en: But, referring to [Figure 6-5](ch06.xhtml#ch6fig5) again, we need to convert
    the pulse length in milliseconds to a duty value between 0 and 1023 because the
    `set_servo_angle` function expects a value in that range.
  prefs: []
  type: TYPE_NORMAL
- en: The duty value (0 to 1023) is calculated by multiplying the pulse length in
    milliseconds by the number of steps per millisecond (1023/20 ≈ 51). For example,
    a pulse length of 1.5 milliseconds would require a duty value of 1.5 × 51 ≈ 77.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '`duty_value` = `pulse_length` × 51'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining these two formulas, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`duty_value` = (0.5 + `angle`/90) × 51'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can also be written as (with rounding):'
  prefs: []
  type: TYPE_NORMAL
- en: '`duty_value` = 26 + `angle` × 51/90'
  prefs: []
  type: TYPE_NORMAL
- en: So the values used in the `write_analog` function are between 26 and 128\. This
    range reflects the fact that the pulses are quite short in comparison to the maximum
    duty cycle value of 1023.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT: ANIMATRONIC HEAD (MIKE THE MICRO:BIT ROBOT)**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Difficulty: Hard*'
  prefs: []
  type: TYPE_NORMAL
- en: This animatronic head, shown in [Figure 6-5](ch06.xhtml#ch6fig5), makes a great
    project for a Halloween display. A servomotor moves a pair of ping-pong ball eyes
    from left to right, and it uses the micro:bit’s display as a mouth. When the head
    talks, the lights simulate a simple animation of lips moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: The animatronic head*'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro:bit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Servomotor** A small 9g servomotor is ideal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amplified speaker** For the head’s voice (Monk Makes Speaker for micro:bit
    is a good choice.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 × Alligator clip-to-male jumper cables** To attach the servomotor'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 × Alligator clip cables** To attach the speaker'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 × Ping-pong balls** For the eyeballs (Balls without any writing or logos
    on them make decoration easier. Grab a couple of spares, just in case.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thick card** Roughly letter or A4 card that is 3 mm or more thick'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paper and access to a printer** To print a template for cutting out the framework'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 × 3-inch (75 mm) paper clips** These are used to make the axles that allow
    the eyes to swivel and the frame that connects the eyes to the servomotor. Ideally,
    these are 1.5 mm in diameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adhesive tape** For sticking the cardboard together and sticking various
    things to the cardboard'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blu-Tack adhesive putty** To attach the speaker to the cardboard'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paper glue** To stick the template onto the cardboard'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scissors and/or craft knife**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paint or pens** To draw the eyeballs'
  prefs: []
  type: TYPE_NORMAL
- en: '**A drill with 5/64-inch (#47) or 2-mm bit** To make holes in the ping-pong
    balls'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pliers** To bend the wire'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll begin by creating the eyeballs.
  prefs: []
  type: TYPE_NORMAL
- en: Grab two ping-pong balls ([Figure 6-6](ch06.xhtml#ch6fig6)) and prepare to decorate.
    The best way to draw an eyeball is to first find two small circular items, one
    a bit bigger than the other (perhaps the lid of a toothpaste tube and a ring)
    and then, using the circular items and a pencil, trace two concentric circles
    on the surface of the ping-pong ball. Once this is done, color the outer ring
    (the iris) and the inner circle (the pupil) two different colors.![Image](../images/06fig06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-6: Decorating an eyeball*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you’ve drawn on the two balls to make them look like eyes, drill three
    holes in each, through which you’ll feed wires. Using a pencil, make three marks:
    with the pupil of the eye facing you, make one mark at the bottom of the ball,
    one at the top, and a final mark on the back opposite the pupil. The holes on
    the top and bottom will be used to thread the eyeball onto a vertical wire to
    hold it in position. The hole in the back will be used to attach the second wire,
    which will move the eye left and right.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**WARNING** *Using a drill can be dangerous! For this part of the project,
    a responsible adult should use the drill or at least supervise. The main precaution
    is to keep the ping-pong ball on a flat surface and hold it from the sides. Then
    drill from above, as shown in [Figure 6-7](ch06.xhtml#ch6fig7). If you have a
    vise to clamp the ball in place, that’s even better.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/06fig07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 6-7 Drilling the eyeball*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you’re happy with the position of the marks, grab a drill bit with a diameter
    slightly larger than that of the paper clip wire and drill into the ping-pong
    ball. For the 1.5 mm paper clips, a 5/64-inch (#47) or 2-mm drill bit is perfect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a frame for the eyeballs. Start by completely straightening out a paper
    clip. Then make the three bends labeled A, B, and C in [Figure 6-8](ch06.xhtml#ch6fig8).![Image](../images/06fig08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-8: Where to bend the paper clip to make the eye frame*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make bends A and C first. Both should be 90 degrees. These will hold the eyeballs
    upright. Next, make a slight bend at the center of the wire—this is bend B. Bend
    B will provide something to tape onto the cardboard chassis you will make next.
    Place the eyeballs on the frame as shown in [Figure 6-9](ch06.xhtml#ch6fig9).![Image](../images/06fig09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-9: Placing the eyes on the frame*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you’ve mounted the eyeballs, you can bend the 10 mm tips of the wires over
    the eyeballs to prevent them from falling off, as shown in [Figure 6-9](ch06.xhtml#ch6fig9).
    Use pliers to avoid hurting your fingers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE** *These bends don’t have to be perfect the first time. Plan to make
    some adjustments as you build the project.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now let’s start assembling the cardboard chassis that will hold everything together.
    To make this easier, I’ve provided a template that can be downloaded with the
    code for the book. The template is in the folder *other downloads* and is called
    *Animatronic_Head_Template*. It is available in PDF, PNG, and SVG formats. Download
    it, print it out, and fix it onto a slightly larger piece of cardboard, as shown
    in [Figure 6-10](ch06.xhtml#ch6fig10).![Image](../images/06fig10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-10: The paper template glued to a piece of cardboard*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Except for the places noted in [Figure 6-10](ch06.xhtml#ch6fig10), cut along
    the lines. This will give you the pieces of cardboard shown in [Figure 6-11](ch06.xhtml#ch6fig11).
    For many of the cuts, scissors will be fine, but you’ll really need a craft knife
    to make the cutouts for the slots and servomotor.![Image](../images/06fig11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-11: The cardboard pieces for the chassis*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**WARNING** *Only use a craft knife with adult supervision. Craft knives are
    very sharp, and it’s easy to accidentally cut yourself with them.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Attach the micro:bit to the front card by poking holes through the pairs of
    small circles marked on the front of the board. Then, for each pair of holes,
    clip an alligator clip through the back. These clips will both allow you to make
    electrical connections and keep the micro:bit securely attached to the card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the alligator clips in the order suggested in [Figure 6-12](ch06.xhtml#ch6fig12):
    red to 3V, black to GND, and yellow to pin 0\. Make sure to attach two alligator
    clips each to the GND and 3V connections of the micro:bit.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/06fig12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 6-12: Connecting cables to the micro:bit*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To connect the micro:bit to the servomotor, you’ll need to attach three alligator
    clips with male jumper cables on one end. Clip a yellow alligator clip with a
    male jumper cables to pin 2\. Then, pull back the insulating sheath on the red
    alligator clip already attached to the 3V, expose some of the metal, and clip
    the red alligator clip with male jumper cable to the red clip. Do the same with
    the black GND cable, pulling back the insulating sheath of GND’s black alligator
    clip and attaching the black alligator to male jumper cable ([Figure 6-13](ch06.xhtml#ch6fig13)).![Image](../images/06fig13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-13: Attaching the micro:bit to the front of the cardboard*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now slot the bottom piece of cardboard into the front piece and fix it in place
    using adhesive tape ([Figure 6-14](ch06.xhtml#ch6fig14)).![Image](../images/06fig14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-14: Attaching the bottom card to the front card*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now attach the speaker to the back card; use adhesive tape or putty to secure
    it. Clip the other end of the three alligator clips you’ve connected to the micro:bit
    (black, red, and yellow) to their corresponding ports on the speaker (GND, 3V,
    and 0, respectively). Affix the back card to the bottom card using adhesive tape.
    As you can see in [Figure 6-15](ch06.xhtml#ch6fig15), your chassis should now
    be in a U shape. The red, blue, and yellow alligator clips here are waiting to
    be attached to the servomotor.![Image](../images/06fig15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-15: The back card and speaker*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the servomotor arm fixed in place at 90 degrees (review the end of Experiment
    8 if needed), push the servomotor through the top card (the round face), threading
    the servomotor’s wire through first. Notice that the servomotor’s shaft is not
    in the center of the servomotor but rather toward one end; that end should be
    at the end of the servomotor cutout that is closest to the center of the top card
    (see [Figure 6-16](ch06.xhtml#ch6fig16)).![Image](../images/06fig16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-16: Connecting the servomotor*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Attach the male jumper pins to the servomotor’s socket, as described in Experiment
    8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With everything connected together, attach the top piece of cardboard to the
    rest of the chassis. The two circles marking the position of the eyes on the top
    piece should face the micro:bit end of the chassis (refer to [Figure 6-5](ch06.xhtml#ch6fig5)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now attach the eyeballs and wire frame to the top card, as shown in [Figure
    6-17](ch06.xhtml#ch6fig17). Adjust the bend in the middle of the wire frame so
    that the eyeballs are centered over the two circles drawn on the top card. Then
    use adhesive tape to hold the wire in place. Give the eyeballs a little spin to
    make sure they can turn freely.![Image](../images/06fig17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-17: Connecting the eyeballs*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To connect the servomotor to the eyeballs, you’ll need to straighten out the
    other paper clip, as shown in [Figure 6-18](ch06.xhtml#ch6fig18).![Image](../images/06fig18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-18: Making the connector between the servomotor and the eyeballs*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make the loop in the center of the wire, wrap the wire tightly around a small
    screwdriver shaft (shown in [Figure 6-19](ch06.xhtml#ch6fig19)). The diameter
    of the screwdriver I used was about 3 mm, making the outside diameter of the little
    loop around 5 mm. Use a screwdriver with a sharp end that’s narrower than the
    shaft, or it will be hard to slide the wire off once it’s been bent. Make sure
    to straighten the legs of the wire as shown.![Image](../images/06fig19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-19: Using a screwdriver to bend a loop in the servomotor-to-eyeball
    connector*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**NOTE** Screwdrivers are sharp and it takes strong hands to bend the thick
    wire around the screwdriver, so you might need adult help for this bit.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adjust the connector by bending the paper clip until the arms are the same distance
    apart as the holes in the backs of the eyeballs. Then, hook the wire into the
    backs of the eyeballs. Use one of the screws provided with the servomotor to fasten
    the loop to the tip of the servomotor’s arm, as shown in [Figure 6-20](ch06.xhtml#ch6fig20).
    Depending on how snugly the servomotor fits its cutout in the top card, you may
    need to tape down the motor to prevent it from moving.![Image](../images/06fig20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-20: Fitting the servomotor–eyeball connector to the card*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now connect the USB cable from your micro:bit and try the project out!
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we’ll use the code from Experiment 8 to test that our mechanisms are
    all working. Once you’re sure everything is working well, switch to the code for
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Code from Experiment 8 as a Test**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    and click the link for **Experiment 8: Servomotors**. Once the program has opened,
    click **Download** and then copy the hex file onto your micro:bit. If you prefer
    to use Python while testing, download the Python file, *Experiment_08.py*, from
    the same website.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the code is loaded, try pressing the A and B buttons to move the servomotor’s
    arm left and right. You will probably need to adjust the connector wire slightly
    so that the eyes are lined up and move freely left to right. Only take the servomotor
    arm a few steps to either side of the 90-degree position or the linkage might
    get jammed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Real Project Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you’re satisfied that the eyeballs are moving the way they should, you
    can switch to the real project code.
  prefs: []
  type: TYPE_NORMAL
- en: Because this project uses a speech library, it is only available in MicroPython
    form. Go to *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    to download the Python file is *ch_06_Animatronic_Head.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Flash it onto your micro:bit and then gently poke the robot. The accelerometer
    should pick up the movement and tell your animatronic head to swivel its eyes,
    say something witty, and then look straight ahead again. For a video of this project,
    go to my YouTube channel (*[https://www.youtube.com/watch?v=FAJTS2Z8ZDA](https://www.youtube.com/watch?v=FAJTS2Z8ZDA)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The software for this project does two things: it detects when the head is
    poked, and it triggers talking events after random periods of time have elapsed.
    The code is rather long, so instead of showing all of it, I’ll just highlight
    the key parts. If you want to follow along, load the code into Mu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it seem as though your animatronic head has a mind of its own, we use
    the Python random library to give us random numbers, which will trigger random
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: Rather than give the head a free range of eye movements, we keep a list of possible
    eye angles in the array `eye_angles`. When we want to set the eyes in a random
    direction, we simply use the `random` function from the random library to take
    an angle from this array.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve played around with the head, you’ve probably noticed that it doesn’t
    know that many sentences. The phrases it speaks are contained in the array `sentences`,
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: sentences = [
  prefs: []
  type: TYPE_NORMAL
- en: '"Hello my name is Mike",'
  prefs: []
  type: TYPE_NORMAL
- en: '"What is your name",'
  prefs: []
  type: TYPE_NORMAL
- en: '"I am looking at you",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Exterminate exterminate exterminate",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Number Five is alive",'
  prefs: []
  type: TYPE_NORMAL
- en: '"I cant do that Dave",'
  prefs: []
  type: TYPE_NORMAL
- en: '"daisee daisee give me your answer do"'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: As with the eye angles, when we want a sentence, we’ll take it from this array.
    As you can see in the code, with robotic speakers, sometimes it’s better to spell
    a word phonetically than spell it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three lip images for the speech animation are created as custom `Image`
    objects. Here is the one for the resting lip animation, a horizontal line:'
  prefs: []
  type: TYPE_NORMAL
- en: lips0 = Image("00000:"
  prefs: []
  type: TYPE_NORMAL
- en: '"00000:"'
  prefs: []
  type: TYPE_NORMAL
- en: '"99999:"'
  prefs: []
  type: TYPE_NORMAL
- en: '"00000:"'
  prefs: []
  type: TYPE_NORMAL
- en: '"00000")'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the five rows in `Image` is a string representing one row of the display;
    each digit in the string represents the brightness from 0 to 9 of a particular
    LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'The images for the lips are held as an array in the variable `lips`:'
  prefs: []
  type: TYPE_NORMAL
- en: lips = [lips0, lips1, lips2]
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the speaking and the lip animation are controlled by the function `speak`,
    which takes in the `sentence` to speak as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: def speak
  prefs: []
  type: TYPE_NORMAL
- en: '(sentence):'
  prefs: []
  type: TYPE_NORMAL
- en: words = sentence.split()
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, len(words)):'
  prefs: []
  type: TYPE_NORMAL
- en: display.show(random.choice(lips))
  prefs: []
  type: TYPE_NORMAL
- en: speech.say(words[i])
  prefs: []
  type: TYPE_NORMAL
- en: display.show(lips0)
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that the lips animate as the words are spoken, we use the `split`
    method to break the sentence into the list of individual words saved as `words`.
    Then, for every word in the list, we display one of the lip images (chosen at
    random using the `choice` method from the random library) and have `speech` speak
    the word. When all the words have been spoken, the lip display shows the default
    `lips0` image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define an `act()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def act():'
  prefs: []
  type: TYPE_NORMAL
- en: set_servo_angle(pin2, random.choice(eye_angles))
  prefs: []
  type: TYPE_NORMAL
- en: sleep(300)
  prefs: []
  type: TYPE_NORMAL
- en: speak(random.choice(sentences))
  prefs: []
  type: TYPE_NORMAL
- en: set_servo_angle(pin2, 90)
  prefs: []
  type: TYPE_NORMAL
- en: sleep(2000)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `act` function does three things: it moves the eyes at random by setting
    the servomotor to a random angle, it selects a sentence to speak by calling `speak`,
    and it resets the eyes by setting the servomotor angle back to 90 degrees. To
    allow for some time between each step, the code makes a call to `sleep`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the main body of our code that uses all of our variables and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: new_z = abs(accelerometer.get_z())
  prefs: []
  type: TYPE_NORMAL
- en: 'if abs(new_z - base_z) > 20:'
  prefs: []
  type: TYPE_NORMAL
- en: base_z = new_z
  prefs: []
  type: TYPE_NORMAL
- en: act()
  prefs: []
  type: TYPE_NORMAL
- en: 'if random.randint(0, 1000) == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: act()
  prefs: []
  type: TYPE_NORMAL
- en: sleep(50)
  prefs: []
  type: TYPE_NORMAL
- en: In the main body of the code, we have a `while True` loop, which means the commands
    execute until the code is signaled to stop. This is useful for when you need code
    to respond continuously to input. Here, we want to be ready for the sudden change
    in acceleration caused by a tap on the robot’s head. First, the loop registers
    the acceleration from the accelerometer. Then, it uses the `abs` function to get
    the magnitude of the acceleration—in this case, we don’t care about the direction,
    just how large the acceleration is.
  prefs: []
  type: TYPE_NORMAL
- en: In the first `if` statement, we check whether the acceleration value has changed
    by more than 20 mg (milligravities). If so, the base acceleration is updated to
    the new acceleration (ensuring that the next time through the loop, the acceleration
    has to change by *another* 20 mg), and `act` is called.
  prefs: []
  type: TYPE_NORMAL
- en: In the second `if` statement, we give the animatronic head a bit of randomness.
    The code picks a random number between 0 and 1,000\. If it is equal to 0 (a 1
    in 1,001 chance), the `act` function is called. Even though this probability is
    very low, since the value gets checked hundreds of times a second, the head springs
    into action several times a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '**Things to Try**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try using a USB battery or AAA battery box to power the head instead of keeping
    it tethered to your computer with a USB cable.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change up your head’s speech, go into the code and add more sentences
    to the `sentences` array.
  prefs: []
  type: TYPE_NORMAL
- en: The speech library produces rather quiet speech that is also quite indistinct.
    You can improve this a little by connecting a bigger amplified speaker.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add a bit more to the project, take a look at the code examples
    here: *[https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html](https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html)*.
    In this code, the speech library is used to produce singing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT: ROBOT ROVER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/common3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Difficulty: Hard*'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we’ll create a robotic rover. Using a clever app called Bitty
    Controller, you’ll be able to control the little buggy with your Android phone
    ([Figure 6-21](ch06.xhtml#ch6fig21)). The Mad Scientist likes to use the rover
    to deliver notes to the lab assistants.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING** *We’re going to use some low-cost chassis kits for this project,
    but the wires that come with these kits are usually loose—meaning you’ll need
    to solder the wires onto the motors. This is the only project in the book that
    requires soldering. The soldering isn’t difficult, but it is dangerous and you
    can easily get burned. So please find an adult to do this part.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-21: A micro:bit-controlled roving robot*'
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ll Need**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Micro:bit**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android phone**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kitronik Motor Driver Board for micro:bit (V2)** To control the motors'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-cost robot chassis kit** Includes two gear motors and a 4 × AA battery
    box'
  prefs: []
  type: TYPE_NORMAL
- en: '**4 × AA batteries**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitty Controller App for Android** From Google Play Store (about $5)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assorted screwdrivers** Suitable for both the nuts and bolts on the chassis
    and the screw terminals on the motor controller board'
  prefs: []
  type: TYPE_NORMAL
- en: '**Soldering equipment** To attach the wires to the gearmotors'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blu-Tack adhesive putty** To attach the motor control board and micro:bit
    to the chassis'
  prefs: []
  type: TYPE_NORMAL
- en: If you search eBay or Amazon for robot chassis, you’ll find low-cost robot chassis
    kits like the one shown in [Figure 6-22](ch06.xhtml#ch6fig22). Look for one that
    includes a 4 × AA battery box and two gearmotors (motors with a built-in gearbox).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-22: The low-cost robot chassis used by this Mad Scientist*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Maybe the trickiest part of this project is the chassis kit assembly. Getting
    the screws and bolts in the right place will require precision and finesse.
  prefs: []
  type: TYPE_NORMAL
- en: Not all chassis will be the same, so instead of taking you through the assembly
    step-by-step, I’ll just give you some high-level advice. Your chassis should come
    with instructions, although they may be somewhat cryptic. In general, you’ll need
    to attach the gear motors, the castor wheel (the wheel that can turn freely in
    any direction), the motor controller, and the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: Solder the supplied wires onto the motor terminals, as shown in [Figure 6-23a–c](ch06.xhtml#ch6fig23).
    If you work quickly, a good soldering joint can be made by melting a generous
    amount of solder onto the motor terminal and then pressing the wire onto the dome
    of solder with the iron ([Figure 6-23a](ch06.xhtml#ch6fig23)).![Image](../images/06fig23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-23: Soldering wires onto the motor*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It doesn’t matter much which terminal you attach the red wire to. Just be sure
    to be consistent between the two motors. That is, if you decide to attach the
    red wire to the right-hand terminal on one motor, solder the red wire to the right-hand
    terminal of the other motor as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the layer of paper covering the chassis. [Figure 6-24a–e](ch06.xhtml#ch6fig24)
    shows the assembly process at a high level. You may find that your chassis is
    different.![Image](../images/06fig24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-24: Building the chassis*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are a few things to remember when building the chassis:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Don’t overtighten the nuts and bolts, as doing
    so can cause the plastic chassis to crack.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  When attaching the gearmotors, put the nuts toward
    the inside of the chassis so that the motor-fixing bolts that stick out beyond
    the nut won’t get in the way of the wheels.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  If the bolt doesn’t turn smoothly into the nut,
    try turning the bolt counterclockwise a little to find the start of the nut’s
    thread. You may want to use a pair of small pliers to grip the nut while you turn
    the screw with a screwdriver.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have the chassis securely assembled, attach the micro:bit to the Kitronik
    Motor Driver board with the micro:bit’s screen facing outward, as shown in [Figure
    6-25](ch06.xhtml#ch6fig25). Line up the micro:bit’s edge connector carefully with
    the socket on the Motor Controller and press it firmly into place. When your controller
    looks like [Figure 6-25](ch06.xhtml#ch6fig25), stick it to the chassis using adhesive
    putty, also shown in [Figure 6-25](ch06.xhtml#ch6fig25).![Image](../images/06fig25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-25: Attaching the micro:bit*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s time to wire up the motors and battery box. First, look at [Figure 6-26](ch06.xhtml#ch6fig26)
    to see what you are aiming for. Unscrew the screw on the relevant terminal, place
    the wire firmly inside the terminal, and then screw the screw back in fairly tightly.![Image](../images/06fig26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 6-26: Wiring up*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make the following connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Red (positive) wire from the battery box to the
    screw terminal marked `RED +` on the Motor Controller'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Black (negative) wire from the battery box to
    the screw terminal marked `BLACK -` on the Motor Controller'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Red wire from the left (as viewed from the back
    of the rover) motor to the screw terminal on the Motor Controller labeled `MOTOR1
    P12`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Black wire from the left motor to the screw terminal
    on the Motor Controller labeled `MOTOR1 P8`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Red wire from the right motor to the screw terminal
    on the Motor Controller labeled `MOTOR2 P0`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/play.jpg)  Black wire from the right motor to the screw
    terminal on the Motor Controller labeled `MOTOR1 P16`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this project, you’ll use an Android app to control the rover via Bluetooth.
    You can find the code that runs on the micro:bit at *[http://www.bittysoftware.com/downloads.html#controller](http://www.bittysoftware.com/downloads.html#controller)*.
    Click the link **micro:bit hex file for** **Kitronik Buggy - no pairing required**
    and download the hex file. This file is also available with the book downloads
    in the *Other Downloads* folder. Next, connect the micro:bit to your computer
    with a USB and copy the downloaded hex file onto your micro:bit. You won’t need
    batteries just yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To install the app on your Android phone, open Google Play and search for *Bitty
    Controller*. You’ll have to pay a few dollars for the app. Download and install
    the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re one step away from trying out the project! Put four AA batteries into
    the battery box. These will power both the motors and your micro:bit, meaning
    you can disconnect the USB cable—it’s time to set your rover free.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Bitty Controller app ([Figure 6-27](ch06.xhtml#ch6fig27)) and click
    **Scan**. This should find your micro:bit. In [Figure 6-27](ch06.xhtml#ch6fig27),
    it’s called *BBC micro:bit [gaviv]*. Click this and the RC-style controller of
    [Figure 6-28](ch06.xhtml#ch6fig28) should appear. The micro:bit’s display should
    also show a `C`, indicating that it’s connected to your phone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-27: Starting Bitty Controller*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-28: The Dual D-Pad Controller*'
  prefs: []
  type: TYPE_NORMAL
- en: Use the top and bottom square buttons to control the forward and backward motion
    of the rover. To turn the rover left and right, use the left and right round buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a first test, do something simple: flip the rover onto its back and use
    the app to control the wheels. Do they spin? Once the rover passes that test,
    put it on the floor and try driving it around. If you don’t like the controller
    layout, head to Options on the Bitty Controller app to find other layouts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rover may move forward when you tell it to go backward and vice versa.
    If this happens, your wires are swapped: switch the red and black wires for motor
    1 and motor 2\. If your rover drives around in a circle, swap one of the pairs
    of wires on one of the motors.'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to turn off your rover (a good way to make your batteries last
    longer), just lift one end of one of the batteries out of the battery holder.
    Ta-da! Now you have a crude switch.
  prefs: []
  type: TYPE_NORMAL
- en: '**How It Works: Motors and the Flow of Electricity**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The direction of the gear motors is controlled by the direction of the current
    flowing through them—if you reverse the direction, you reverse the motors. As
    you can see in [Figure 6-29](ch06.xhtml#ch6fig29), a motor turns clockwise if
    connection A is positive and connection B is negative. If A and B are reversed,
    so that A is negative and B is positive, the motor moves the other way.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/06fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-29: Controlling the direction of a motor*'
  prefs: []
  type: TYPE_NORMAL
- en: The Kitronik Motor Controller contains a chip that controls the direction of
    current in two motors. It also supplies the relatively high current that the motors
    need.
  prefs: []
  type: TYPE_NORMAL
- en: '**SUMMARY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We covered a lot of ground in this chapter. First, we learned about servomotors
    and how to set one up using the micro:bit. Then, we built two complex projects:
    the animatronic head and the remote-controlled rover. Along the way, we learned
    about PWM and current flow and picked up a few basic programming tricks to boot.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to make things move, you can start thinking about other
    projects you’d like to make. What things would you like to have move all on their
    own? In the next chapter, we’ll look at how to deal with time.
  prefs: []
  type: TYPE_NORMAL
