<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label="159"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch9">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">9</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">SEARCHING</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">This chapter deals with a common problem: given a set of values, find whether a certain key is in the set. This definition has similar aspects to logic that we’ll explore in future chapters when you implement a dictionary abstract data type (ADT), but we’ll be concerned only with the search part here. We won’t look at adding or deleting keys. In addition, we’ll deal only with arrays and explore other data structures in future chapters.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-42"/><span class="SANS_Futura_Std_Bold_B_11">Search Definition</span></h3>&#13;
<p class="TNI1">In all cases in this chapter, the problem to solve is that, given an array (ordered or unordered, possibly with repeated values) and a key, you want <span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label="160"/>to learn at which position of the array you can find the key. You’ll return <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> to match several of JavaScript’s own methods if the key isn’t in the array.</p>&#13;
<p class="TX">As a further optional requirement, you may sometimes want to find the first (or last) occurrence of a key in an array (in the case where the array has repeated keys), or if an array doesn’t include a key, you might want to know in which position it should have been.</p>&#13;
<p class="TX">It’s important to keep in mind whether you’re doing a single search or many searches. If the latter, you may amortize over time the cost of, say, sorting the data or building some other data structure. If the former, you just want the speediest possible search. (In later chapters you’ll explore examples of data structures that help make searches faster.)</p>&#13;
<p class="TX">There are more efficient algorithms for sorted arrays than for unsorted ones; we’ll start with the latter and then move on to better-performing ones.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-43"/><span class="SANS_Futura_Std_Bold_B_11">Searching Unsorted Arrays</span></h3>&#13;
<p class="TNI1">The first set of algorithms you’ll consider performs a linear search in a disordered array and is the most basic (these are also known as sequential or serial searches). If the array is not in any order, there’s no other way to search than to start at the beginning and go through the whole array. This kind of search is obviously slow and <i>O</i>(<i>n</i>), but for small arrays, it’s quite reasonable. Furthermore, JavaScript has its own methods for this kind of search, so if the conditions of your problem allow it, the functions in the next section are probably the best bet.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-72"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">JavaScript’s Methods</span></h4>&#13;
<p class="TNI1">To find whether a given key is in an array along with its position, JavaScript provides several interesting functions. If you just want to know whether the key is there, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">array.includes(key)</span> method, which returns true or false depending on whether the key was found. If you want the position of the key in the array (which you’ll want throughout this chapter), then <span class="SANS_TheSansMonoCd_W5Regular_11">array.indexOf(key)</span> does the job. It returns the first position at which the key is found or <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> if it wasn’t found.</p>&#13;
<p class="TX">These methods all perform in <i>O</i>(<i>n</i>) time, and they go through the array from the beginning to the end. This performance matches that of the linear search you’ll consider next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-73"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Linear Search</span></h4>&#13;
<p class="TNI1">The linear search algorithm is basically an implementation of JavaScript’s own <span class="SANS_TheSansMonoCd_W5Regular_11">.indexOf(...)</span> method. It searches simply by looping through the whole array checking whether it finds what you want.</p>&#13;
<p class="TX"><a href="chapter9.xhtml#fig9-1">Figure 9-1</a> shows two searches: a successful one for 60 and an unsuccessful one for 50.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label="161"/>&#13;
<figure class="IMG"><img class="img7" id="fig9-1" src="../images/Figure9-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-1: A linear search starts at the beginning and advances until it finds the desired key or gets to the end of the array.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The process starts at the beginning and continues until it reaches the desired key or the end of the array. This kind of algorithm is often taught very early to future developers as a basic example of looping. Here’s an implementation:</p>&#13;
<pre id="pre-142"><code>const linearSearch = (arr, key) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = 0; i &lt; n; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (arr[i] === key) {&#13;
      return i;&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return -1;&#13;
};</code></pre>&#13;
<p class="TX">Loop through the array <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and if you find the key you want <span class="CodeAnnotation" aria-label="annotation2">❷</span>, return its position. If the loop ends without success <span class="CodeAnnotation" aria-label="annotation3">❸</span>, return <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> as defined.</p>&#13;
<p class="TX">The performance of this algorithm is <i>O</i>(<i>n</i>) in the worst case, and for successful searches, you do an average of <i>n</i>/2 probes, so the result is still <i>O</i>(<i>n</i>). There’s no way to seriously speed up a search in a disordered array, but a small trick may help a little bit: using a sentinel.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-74"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Linear Search with Sentinels</span></h4>&#13;
<p class="TNI1">Before searching for a key, append that value at the end of the array, so the search is guaranteed to succeed. <a href="chapter9.xhtml#fig9-2">Figure 9-2</a> shows the same two searches from the previous section: the first is successful because it found 60 before the end of the array, but the second is a failure because it found only the 50 that was added, as that value wasn’t originally in the array.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label="162"/>&#13;
<figure class="IMG"><img class="img7" id="fig9-2" src="../images/Figure9-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-2: Adding a sentinel lets you advance without passing the end of the array.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can loop through the array without checking for its end, because you know for sure that you’ll eventually find the key. The only consideration now is where you find it: if it’s at the end, you found only the added sentinel, so the search was unsuccessful. Here’s the logic:</p>&#13;
<pre id="pre-143"><code>const linearSearch = (arr, key) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> arr[n] = key;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let i = 0;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> while (arr[i] !== key) {&#13;
    i++;&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> arr.length = n;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return i === n ? -1 : i;&#13;
};</code></pre>&#13;
<p class="TX">Start by adding the key to search for at the end of the array <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then start searching at the first position as before <span class="CodeAnnotation" aria-label="annotation2">❷</span> until you find the key <span class="CodeAnnotation" aria-label="annotation3">❸</span>. You don’t have to check for the end of the array because you know you’ll find the key you want. After finding the key, restore the array <span class="CodeAnnotation" aria-label="annotation4">❹</span> (assigning a new length is enough for this, but the <span class="SANS_TheSansMonoCd_W5Regular_11">.pop(...)</span> method is probably more common) and then decide what to return depending on where you find the key <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If it’s at the end, it’s a failure, and if it’s earlier, it’s a success.</p>&#13;
<p class="TX">The performance of this algorithm is still <i>O</i>(<i>n</i>); the only (slight) advantage may derive from the simpler check in the loop, so the iteration goes faster, but don’t expect a big impact from that. In addition, if adding the sentinel causes JavaScript to create a new array and copy the old one, the algorithm could become even slower.</p>&#13;
<p class="TX">When all is said and done, using linear search can’t be enhanced by much, and you’ve gone as far as possible with unordered arrays. You’ll now move on to doing searches in ordered (sorted) arrays, for which far better algorithms are possible.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label="163"/>&#13;
<h3 class="H1" id="sec6"><span id="h1-44"/><span class="SANS_Futura_Std_Bold_B_11">Searching Ordered Arrays</span></h3>&#13;
<p class="TNI1">If the array to be searched is ordered, you can apply better techniques. For instance, if you learn that the value at a certain position of the array is greater than the key you’re searching for, you can instantly discard all values after that position, because the key can’t be there. All the nonlinear search algorithms (also known as <i>interval searches</i>) in this section take advantage of order either to advance more quickly through the array or to discard large portions of it, reducing the area to search.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-75"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Jump Search</span></h4>&#13;
<p class="TNI1">The basic linear search described earlier potentially goes through the complete array, which makes for <i>O</i>(<i>n</i>) performance with no possibility for enhancement. However, if the array is ordered, you don’t have to go through it one by one. Just as when someone is looking for a certain page in a book, they won’t turn each page one by one; they’ll skip through the book several pages at a time, and then go one by one when closer to the goal.</p>&#13;
<p class="TX">The idea behind the jump search algorithm is similar to that of Shell sort (see <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>). You start with big jumps to get quickly to the vicinity of the key that you want and then do smaller jumps. <a href="chapter9.xhtml#fig9-3">Figure 9-3</a> shows how we’d search for 42, assuming an initial jump size of 4. (We’ll get to what the jump size should be later.)</p>&#13;
<figure class="IMG"><img class="img7" id="fig9-3" src="../images/Figure9-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-3: A jump search tries to advance faster by making big jumps whenever possible.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At the top you do a linear search but with big jumps, skipping four values at a time. The first value you find is 04, which is too low, so you jump again. Next you find 14 and then 24, but both are still too low. The next jump gets you to 49, so now you know that 42 is (if present) after the 24 and before the 49. You then start a regular linear search, with short jumps advancing one position at a time. You check 34 and 40 and succeed at 42. If you had been searching for 41 instead, when you reached 42, you’d decide that 41 wasn’t present and return –1.</p>&#13;
<p class="TX">What’s the expected number of tests for this algorithm? If the step size is <i>s</i> and the array size is <i>n</i>, you can have up to <i>n</i>/<i>s</i> long jumps, followed by <i>s</i> short jumps, which is <i>n</i>/<i>s</i> + <i>s</i> in total. Some calculus proves that this is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label="164"/>optimum when <i>s</i> is √<i>n</i>, for a maximum of 2√<i>n</i> tests, so we’ll use that value, as shown in the following implementation:</p>&#13;
<pre id="pre-144"><code>const jumpSearch = (arr, key) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const s = Math.max(2, Math.floor(Math.sqrt(n)));&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let i = 0;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> while (i + s &lt; n &amp;&amp; key &gt;= arr[i + s]) {&#13;
    i += s;&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> while (i + 1 &lt; n &amp;&amp; key &gt;= arr[i + 1]) {&#13;
    i++;&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return i &lt; n &amp;&amp; key === arr[i] ? i : -1;&#13;
};</code></pre>&#13;
<p class="TX">Start by determining the size of the long jump <span class="CodeAnnotation" aria-label="annotation1">❶</span>, making sure that it’s at least 2. (The jump size could be 1 only for very short arrays.) The <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> variable goes through the array <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Start by jumping <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> places every time <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If you don’t go past the end of the array and the array value you test is not greater than the key you are looking for, you can do a jump by updating <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>. After this series of jumps, <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> points to a value not greater than the key you want, and you do a new loop, advancing by 1 <span class="CodeAnnotation" aria-label="annotation4">❹</span>. After this loop ends <span class="CodeAnnotation" aria-label="annotation5">❺</span>, if you find the key, return its position; otherwise, return <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span>.</p>&#13;
<p class="TX">The code has two similar <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loops. In one case you jump by <span class="SANS_TheSansMonoCd_W5Regular_11">s</span>, and in the other you jump by 1.</p>&#13;
<p class="TX">Consider another implementation that suggests a more enhanced solution. First, here’s the code:</p>&#13;
<pre id="pre-145"><code>const jumpSearch = (arr, key) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let s = Math.max(2, Math.floor(Math.sqrt(n)));&#13;
  let i = 0;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> while (s &gt; 0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> while (i + s &lt; n &amp;&amp; key &gt;= arr[i + s]) {&#13;
      i += s;&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> s = s &gt; 1 ? 1 : 0;&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return i &lt; n &amp;&amp; key === arr[i] ? i : -1;&#13;
};</code></pre>&#13;
<p class="TX">You’re now not using a <span class="SANS_TheSansMonoCd_W5Regular_11">const</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> because you’ll change its value for the second loop. Set up an external loop <span class="CodeAnnotation" aria-label="annotation2">❷</span> depending on <span class="SANS_TheSansMonoCd_W5Regular_11">s</span>. When it reaches 0, you’re done. The internal loop is the same as before, where you always jump <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> places at a time <span class="CodeAnnotation" aria-label="annotation3">❸</span>, but <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> later becomes 1 to make short jumps. After finishing a loop <span class="CodeAnnotation" aria-label="annotation4">❹</span>, reduce <span class="SANS_TheSansMonoCd_W5Regular_11">s</span>. If it was greater than 1, jump by 1, and if it already was 1, end the loop, setting it to 0. Deciding what value to return <span class="CodeAnnotation" aria-label="annotation5">❺</span> is exactly the same as in the previous version of the algorithm.</p>&#13;
<p class="TX">You did the search in two stages: long jumps first, followed by shorter jumps, and you got the searches down to <i>O</i>(√<i>n</i>). What if you had three <span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label="165"/>stages, with very long jumps first, followed by not-as-long jumps, and shorter jumps to finish? Jumps at one level are proportionally greater to jumps in the next level. (We’ll revisit this concept of jumps that decrease in size when looking at skip lists in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>.) <a href="chapter9.xhtml#fig9-4">Figure 9-4</a> shows how it works with three jump levels, searching for a value in an array of 27.</p>&#13;
<figure class="IMG"><img class="img5" id="fig9-4" src="../images/Figure9-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-4: A search in three levels</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first jumps are nine elements apart. After finding in which block of nine the key should be, you start with jumps three elements apart; grayed elements are places where the key you want can’t be. After you learn in which block of three the key is (allowing you to gray out more elements), you finish with single-element jumps. In this case you’d have, on average, 4.5 tests to find a key, or 9 test tops.</p>&#13;
<p class="TX">You can code it like this:</p>&#13;
<pre id="pre-146"><code>const jumpSearch = (arr, key, levels = 3) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const b = Math.max(2, Math.floor(arr.length ** (1 / levels)));&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let s = Math.floor(n / b);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> let i = 0;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> while (s &gt; 0) {&#13;
    while (i + s &lt; n &amp;&amp; key &gt;= arr[i + s]) {&#13;
      i += s;&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> s = Math.floor(s / b);&#13;
  }&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return i &lt; n &amp;&amp; key === arr[i] ? i : -1;&#13;
};</code></pre>&#13;
<p class="TX">Start by defining the number of blocks <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> at each level <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and again (as with the jump size in previous algorithms) you want to have at least two blocks at each level. Then set the initial (longest) jump size <span class="CodeAnnotation" aria-label="annotation2">❷</span>. And then proceed to search by levels in the same way as before: starting at the beginning <span class="CodeAnnotation" aria-label="annotation3">❸</span> and continuing the search until the number of jumps becomes zero <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The difference is how you reduce the jump size <span class="CodeAnnotation" aria-label="annotation5">❺</span>, making it <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> times smaller every time. (Because <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> &gt; 1, <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> is guaranteed to eventually reach 0, making the outer loop end.) The final return <span class="CodeAnnotation" aria-label="annotation6">❻</span> is the same as with other versions of jump searching.</p>&#13;
<p class="TX">It can be shown that this scheme leads to <i>O</i>(<sup>3</sup>√<i>n</i>) test if you choose jumps that are each <sup>3</sup>√<i>n</i> greater than the next, so the algorithm is even <span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label="166"/>better. You could keep adding more and more levels (though, of course, that would be meaningful only with a seriously large array) and get the order of the algorithm to <i>O</i>(<sup>4</sup>√<i>n</i>), then <i>O</i>(<sup>5</sup>√<i>n</i>), and so on. (Question 9.3 shows just how far you can go.)</p>&#13;
<p class="TX">We’ve managed to speed up the search algorithms from <i>O</i>(<i>n</i>) to <i>O</i>(<i><sup>p</sup></i>√<i>n</i>), if we search in <i>p</i> levels. Let’s try a different approach and see if we can do even better.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-76"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Binary Search</span></h4>&#13;
<p class="TNI1">Now try applying the divide-and-conquer idea to create a search algorithm: given an array to search, check its center value. If it’s the value you want, you’re done. If the center value is greater than the value you want, you can discard the right side of the array and search the left portion recursively. Similarly, if the center value is greater than the value, discard the left side and search the right. If at some point you have to search an empty array, you know the value wasn’t present. <a href="chapter9.xhtml#fig9-5">Figure 9-5</a> illustrates the procedure where the search value is 18.</p>&#13;
<figure class="IMG"><img class="img7" id="fig9-5" src="../images/Figure9-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-5: A binary search recursively splits the array to be searched in half at every pass.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="chapter9.xhtml#fig9-5">Figure 9-5</a>, the triangle with an <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> points to the middle element of the array. Initially, the middle element is 22, so 18 (if present) had to be on the left side; you can discard the rest. The second line shows how you’d continue: the middle element is 12, so you search on the right. On the third line you succeed, as the middle element is what you wanted. You can code the method as follows:</p>&#13;
<pre id="pre-147"><code>const binarySearch = (arr, key, l = 0, r = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation1">❶</span> if (l &gt; r) {&#13;
    return -1;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span> const m = (l + r) &gt;&gt; 1;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span> if (arr[m] === key) {&#13;
      return m;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span>} else if (arr[m] &gt; key) {&#13;
      return binarySearch(arr, key, l, m - 1);&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span>} else {&#13;
      return binarySearch(arr, key, m + 1, r);&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label="167"/>If at any time the interval to search is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the search was a failure. If not <span class="CodeAnnotation" aria-label="annotation2">❷</span>, compute the middle of the interval. Using the right shift <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</span> operator is an elegant and concise way of doing this rather than the more pedestrian <span class="SANS_TheSansMonoCd_W5Regular_11">Math.floor((l+r)/2)</span>. If the value in the middle is the key that you’re looking for <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you’re done. If the middle value is greater than the key you want <span class="CodeAnnotation" aria-label="annotation4">❹</span>, search the left portion of the array; otherwise, search the right <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Since all of the recursion here is tail recursion, you can easily convert this method to an equivalent iterative one. In <a href="chapter9.xhtml#fig9-6">Figure 9-6</a>, the <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> (left and right) triangles show the portion of the array that you are searching, and the <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> (middle) triangle indicates the middle point of that portion. Once more, the search value is 18.</p>&#13;
<figure class="IMG"><img class="img7" id="fig9-6" src="../images/Figure9-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-6: An iterative version of the algorithm uses two pointers (</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">l</span> <span class="SANS_Futura_Std_Book_Oblique_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">r</span><span class="SANS_Futura_Std_Book_Oblique_11">) to keep track of the portion of the array that you’re searching.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Grayed-out values won’t be considered further in the algorithm. Depending on the result of the comparison of the middle value with the key you want, you update <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> and loop again until you succeed or fail.</p>&#13;
<p class="TX">How do you recognize a failed search? If you were searching for 17 instead, the search procedure would have continued as shown in <a href="chapter9.xhtml#fig9-7">Figure 9-7</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig9-7" src="../images/Figure9-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-7: If the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">l</span> <span class="SANS_Futura_Std_Book_Oblique_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">r</span> <span class="SANS_Futura_Std_Book_Oblique_11">pointers get “crossed,” you can conclude that the search was unsuccessful.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When the search fails, the <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> pointers become “crossed,” which means the value can’t be in the array. (The missing value, 17, should have been to the left of <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and to the right of <span class="SANS_TheSansMonoCd_W5Regular_11">r</span>.)</p>&#13;
<p class="TX">You can implement the algorithm as follows:</p>&#13;
<pre id="pre-148"><code>const binarySearch = (arr, key, l = 0, r = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation1">❶</span> while (l &lt;= r) {&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span> const m = (l + r) &gt;&gt; 1;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span> if (arr[m] === key) {&#13;
      return m;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span>} else if (arr[m] &gt; key) {&#13;
      r = m - 1;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label="168"/>  <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span>} else {&#13;
      l = m + 1;&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation6">❻</span> return -1;&#13;
};</code></pre>&#13;
<p class="TX">Keep searching <span class="CodeAnnotation" aria-label="annotation1">❶</span> as long as the <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> pointers don’t cross. You calculate the middle <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> the same way <span class="CodeAnnotation" aria-label="annotation2">❷</span> as for the recursive binary search. If the middle value equals the key you want <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you’re done. If the middle key is greater than the value you want <span class="CodeAnnotation" aria-label="annotation4">❹</span>, update the right pointer <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> to keep looking in the left portion; otherwise, change the <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> pointer to search on the right <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If the loop ends without finding the key you want <span class="CodeAnnotation" aria-label="annotation6">❻</span>, we return <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> to show the failure.</p>&#13;
<p class="TX">What’s the performance of this method? We have seen a similar analysis before, and it should remind you of quicksort, for example. Each step halves the size of the array to search, so the order of the binary search is <i>O</i>(log <i>n</i>), which is a very good improvement on all the previous algorithms you’ve seen. (For math-oriented readers, question 9.4 calculates the actual average number of tests.) Let’s consider another algorithm that shows a similar performance, which actually uses binary search.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-77"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Exponential Search</span></h4>&#13;
<p class="TNI1"><i>Exponential search</i> (also known as <i>doubling</i> or <i>galloping search</i>) is a combination of two methods: first you determine in which range of the array you should find the desired key, and then you apply binary search to finish the job. For the first step, you want to find a value in the array that’s greater than the key you want to find, and you test the value at position 1; then the value at position 2; then at positions 4, 8, 16; and so on, always doubling, until you decide where to continue searching. <a href="chapter9.xhtml#fig9-8">Figure 9-8</a> shows how the algorithm would search for 42.</p>&#13;
<figure class="IMG"><img class="img7" id="fig9-8" src="../images/Figure9-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-8: An exponential search combines ever-longer jumps with binary search.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, the doubling jumps are taken (size 1, 2, 4, and so on) until finding the section in which 42, if present, should be. (If you were looking for 22, the jumps would have ended after looking at the element in position 8, for instance.) After finding the portion of the array to search, binary search completes the process.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label="169"/>Here’s the code:</p>&#13;
<pre id="pre-149"><code>const exponentialSearch = (arr, key) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let i = 1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> while (i &lt; n &amp;&amp; arr[i] &lt; key) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> i &lt;&lt;= 1;&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> return binarySearch(arr, key, (i &gt;&gt; 1), Math.min(i, n - 1));&#13;
};</code></pre>&#13;
<p class="TX">First initialize the series of jumps at 1 <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and although you have neither reached the end nor found a value greater than the key you want <span class="CodeAnnotation" aria-label="annotation2">❷</span>, double the jump size <span class="CodeAnnotation" aria-label="annotation3">❸</span> and loop again. If this line looks weird, you could also write it as <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">i &lt;&lt; 1</span>, and the left shift <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</span> operator (you’ve already used the right shift operator in binary search) makes it equivalent to <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">i * 2</span>. After completing all the necessary jumps <span class="CodeAnnotation" aria-label="annotation4">❹</span>, do a binary search, again using the shift operator to divide <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> by 2.</p>&#13;
<p class="TX">What’s the order of this algorithm? Let’s start with the worst case, when you look for the last value in an array with up to 2<i><sup>p</sup></i> elements. The first loop will be executed <i>p</i> times, and that will be followed by a binary search in an array with a size of less than 2<i><sup>p</sup></i> <sup>− 1</sup>: that also is <i>O</i>(<i>p</i>). As <i>p</i> is approximately log <i>n</i>, the total performance is, at worst, <i>O</i>(log <i>n</i>), but it’ll be better the closer the element is to the beginning. In fact, if the key is found at position <i>k</i>, the search will be <i>O</i>(log <i>k</i>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-78"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Interpolation Search</span></h4>&#13;
<p class="TNI1">When searching for a word in the dictionary, no matter how well versed you are in binary search, if you are looking for a word starting with the letter <i>S</i>, you’d open the dictionary near the end, but if you’re looking for a word starting with <i>B</i>, you’d open the book nearer the beginning. You can apply this idea to searching in an ordered array, if you can interpolate and estimate the position at which a given value should be, assuming that values in the array are somewhat uniformly distributed.</p>&#13;
<p class="TX">But first some math. If the value at position <i>l</i> (for left) is <i>L</i> and the value at position <i>r</i> (for right) is <i>R</i> (with <i>R &gt; L</i>), the position that would correspond to value <i>V</i> can be calculated as <i>l</i> + (<i>r – l</i>)(<i>V – L</i>)/(<i>R – L</i>). We can check this out. If <i>V</i> equals <i>L</i>, the formula produces <i>l</i>, which is correct. Similarly, if <i>V</i> equals <i>R</i>, the formula produces <i>r</i>, which is correct again. If you are searching an array with values that can be converted to numbers, you can apply this interpolation to more quickly find the value you want.</p>&#13;
<p class="TX">Consider this in practice. <a href="chapter9.xhtml#fig9-9">Figure 9-9</a> shows a search for the value 34.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label="170"/>&#13;
<figure class="IMG"><img class="img7" id="fig9-9" src="../images/Figure9-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-9: An interpolation search tries to estimate the position of the searched-for value to find it faster.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To start, the left value (at position 0) is 4 and the right value (at position 14) is 60, so the estimate is that 34 should be around position 7. (See <a href="chapter9.xhtml#fig9-10">Figure 9-10</a>; the dotted line joins the extreme values, and its intersection with a horizontal line at height 34 is between 7 and 8.) Since the value at that position is smaller than 34, move the left pointer to position 8. Then redo the estimation with 24 at 8 and 60 at 14, so 34 should be at 10. The value there is higher than 34, so now move the right pointer to 9. The third iteration is successful, as 34 is estimated to be (and found at) position 9.</p>&#13;
<figure class="IMG"><img class="img7" id="fig9-10" src="../images/Figure9-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 9-10: Estimating the position for 42, if 4 is the start of the array and 60 is the end</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can directly implement the method:</p>&#13;
<pre id="pre-150"><code>const interpolationSearch = (arr, key) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation1">❶</span> let l = 0;&#13;
   let r = arr.length - 1;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span> while (l &lt;= r) {&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span> const m =&#13;
      arr[l] === arr[r]&#13;
        ? l&#13;
        : Math.round(l + ((r - l) * (key - arr[l])) / (arr[r] - arr[l]));&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label="171"/>  <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span> if (m &lt; l || m &gt; r) {&#13;
      return -1;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span>} else if (arr[m] === key) {&#13;
      return m;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation6">❻</span>} else if (arr[m] &gt; key) {&#13;
      r = m - 1;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation7">❼</span>} else /* arr[m] &lt; key */ {&#13;
      l = m + 1;&#13;
    }&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation8">❽</span> return -1;&#13;
};</code></pre>&#13;
<p class="TX">Start by setting variables <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> to point to the extremes of the search range <span class="CodeAnnotation" aria-label="annotation1">❶</span> as in binary search, and the loop <span class="CodeAnnotation" aria-label="annotation2">❷</span> is the same as in that algorithm. Instead of calculating <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> as the middle point of <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, use the interpolation formula, but check whether the values at the extremes are equal because then you’d be dividing by zero. If <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> ends outside the interval from <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">r</span>, the value you want isn’t in the array (because the key you want must be smaller than the value at <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> or greater than the value at <span class="SANS_TheSansMonoCd_W5Regular_11">r</span>), and you return <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. On the other hand, if <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> lies between <span class="SANS_TheSansMonoCd_W5Regular_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> inclusive, compare the value at its position to the desired key. If the value is equal, you succeeded <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If the value is greater, search to the left <span class="CodeAnnotation" aria-label="annotation6">❻</span>, and if the value is smaller, search to the right <span class="CodeAnnotation" aria-label="annotation7">❼</span>. If the key wasn’t found, return <span class="SANS_TheSansMonoCd_W5Regular_11">–1</span> <span class="CodeAnnotation" aria-label="annotation8">❽</span>.</p>&#13;
<p class="TX">This method performs well, but it has a couple of drawbacks. First, you must be working with numeric keys (as in the example) or with keys that can be transformed to numbers in order to perform interpolation (one possibility could be transforming characters to their ASCII or Unicode equivalents). This challenge needs to be solved in order to use interpolation search with more general keys.</p>&#13;
<p class="TX">The second possible drawback has to do with the algorithm’s performance. Unlike binary search that always halves the search range at each stage, interpolation might do not so well (quicksort behaved similarly), and the performance would be <i>O</i>(<i>n</i>). (A possible case for bad performance is if values in the array are in a geometric progression, which means linear interpolation won’t produce good estimates; however, such a distribution isn’t really very likely.) On the other hand, if values are uniformly distributed, it can be shown (you won’t see it here) that performance will be <i>O</i>(log log <i>n</i>), which is a great improvement.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-45"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter we’ve considered algorithms for searching ordered or unordered arrays of values, which is a common function. The methods covered have different rates of performance, and several of them are based on previous methods in order to illustrate interesting algorithm development techniques.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label="172"/>This chapter ends the second part of the book. In <a href="part3.xhtml">Part III</a>, we’ll start our exploration of data structures, beginning with lists, an important dynamic structure with plenty of uses.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-46"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>9.1  Searching Right?</b></p>&#13;
<p class="ListPlainFirst">Implement a framework to test a given search function and see whether it works on every element in the array and on missing elements as well. I used such a test on all of my code for this chapter, and I found some bugs!</p>&#13;
<p class="ListHead"><b>9.2  JavaScript’s Own</b></p>&#13;
<p class="ListPlainFirst">Can you implement an alternative to JavaScript’s own <span class="SANS_TheSansMonoCd_W5Regular_11">array.indexOf(...)</span> using some other available array methods?</p>&#13;
<p class="ListHead"><b>9.3  Infinite Jump Levels?</b></p>&#13;
<p class="ListPlainFirst">In the generalized jump search algorithm, what happens if you want to do the search on an infinite number of levels? (Hint: imagine that <span class="SANS_TheSansMonoCd_W5Regular_11">levels</span> is infinitely large, and see how the algorithm behaves.) What’s the resulting algorithm like?</p>&#13;
<p class="ListHead"><b>9.4  Exactly How Much?</b></p>&#13;
<p class="ListPlainFirst">This question is for the mathematically inclined. Calculate the actual average of number of tests for a successful search. It may help to assume that the array is of length 2<i><sup>n</sup></i> – 1. In this case 1 element is found in just one question, 2 elements in two questions, 4 found in three, 8 in four, and so on, up to 2<i><sup>n</sup></i> <sup>− 1</sup> found in <i>n</i> questions.</p>&#13;
<p class="ListHead"><b>9.5  Three Tops Two?</b></p>&#13;
<p class="ListPlainFirst">Inspired by binary search, which uses a comparison to split the array to search in two, you could think of a ternary search, using comparisons to split the array in three, so you’ll have a smaller subarray to work with. How does this compare to binary search? Is ternary search really an improvement?</p>&#13;
<p class="ListHead"><b>9.6  Binary First</b></p>&#13;
<p class="ListPlainFirst">Assuming that the sorted input array may have repeated values, modify binary search to return the first position of the searched key in the array. If you want to find the <i>last</i> position instead, what changes would you need?</p>&#13;
<p class="ListHead"><b>9.7  Count Faster</b></p>&#13;
<p class="ListPlainFirst">Given an input sorted array and a key, you could find how many times the key appears by writing something like <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">arr.filter(x</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=&gt; x</span> <span class="SANS_TheSansMonoCd_W5Regular_11">===</span> <span class="SANS_TheSansMonoCd_W5Regular_11">key).length</span>, but that would run in <i>O</i>(<i>n</i>) time. Can you find that count in <i>O</i>(log <i>n</i>) time?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label="173"/><b>9.8  Rotation Finding</b></p>&#13;
<p class="ListPlainFirst">Assume you have an array that was originally sorted, but later it possibly got rotated: for instance [4, 9, 12, 22, 34, 56, 60] might have become [34, 56, 60, 4, 9, 12, 22]. Write a function that determines the position of the lowest value in the rotated array. For instance, in this example, the function should return 3. Make sure your function also works for an array that <i>isn’t</i> rotated.</p>&#13;
<p class="ListHead"><b>9.9  Special First?</b></p>&#13;
<p class="ListPlainFirst">I found several implementations of exponential search that specifically tested, before any looping, whether the first position of the array had the key. Does the version in this book need this?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>