- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**GETTING CLASSY WITH OBJECT-ORIENTED PROGRAMMING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**与面向对象编程的高级应用**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: Reusability is a very important aspect of programming. It saves time and effort.
    You’ve seen this with loops and functions, and now you’ll learn about *object-oriented
    programming*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用性是编程中非常重要的一个方面。它节省了时间和精力。你已经在循环和函数中看到了这一点，现在你将学习*面向对象编程*。
- en: Object-oriented programming is an approach to programming that groups functions
    and variables together to create *classes*. Each class can be used to create *objects*
    that share the same variables and functions as the class. You can create many
    objects from the same class, making the class’s variables and functions reusable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种将函数和变量组合在一起以创建*类*的编程方法。每个类都可以用来创建*对象*，这些对象共享类的变量和函数。你可以从同一个类创建许多对象，从而使类的变量和函数可重用。
- en: When a function is part of a class, it’s called a *method*, and a variable that’s
    part of a class is called an *attribute*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数是类的一部分时，它被称为*方法*，而类中的变量被称为*属性*。
- en: In this chapter, you’ll learn object-oriented programming and use classes to
    reuse code. Mastering object-oriented programming and classes makes building programs
    a breeze, and you can even use object-oriented programming to make games. In the
    missions in this chapter, you’ll use classes to make some basic programs. You’ll
    start by creating a simple building, but soon you’ll build an entire town.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习面向对象编程，并使用类来重用代码。掌握面向对象编程和类使得构建程序变得轻松，你甚至可以使用面向对象编程来制作游戏。在本章的任务中，你将使用类来制作一些基本程序。你将从创建一个简单的建筑开始，但很快你就会建造整个城镇。
- en: '**OBJECT-ORIENTED BASICS**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**面向对象编程基础**'
- en: 'Object-oriented programming is very popular, and you can use it to create all
    kinds of cool software, but it can be a tricky concept to understand. Let’s relate
    it to something that’s more familiar: you.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程非常流行，你可以用它来创建各种酷的软件，但它也可能是一个难以理解的概念。让我们把它与更熟悉的东西联系起来：你。
- en: 'You’re a person. You have a number of methods: you can eat, breathe, sleep,
    count to 10, and do lots of other things. You also have attributes: name, age,
    height, shoe size, and so on.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一个人。你有许多方法：你可以吃、呼吸、睡觉、数到10，还能做很多其他事情。你也有属性：名字、年龄、身高、鞋码等等。
- en: Your friend Mary has the same methods as you; she too can eat, breathe, sleep,
    count to 10, and do lots of other things. She also has the same attributes (name,
    age, and so on), although they contain different values.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友玛丽和你有相同的方法；她也能吃、呼吸、睡觉、数到10，并做许多其他事情。她也有相同的属性（名字、年龄等等），尽管它们包含不同的值。
- en: In fact, everyone has these methods and attributes. You can describe people
    as a class. You and Mary are both people, so you could say you are both objects
    in the `Person` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每个人都有这些方法和属性。你可以把人描述为一个类。你和玛丽都是人，因此你可以说你们俩都是`Person`类中的对象。
- en: In object-oriented programming, objects are called *instances* of a class. All
    objects share the methods and attributes of the class, but the values of the attributes
    can be different for each object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，对象被称为类的*实例*。所有对象都共享类的方法和属性，但属性的值对于每个对象可能不同。
- en: Let’s jump into Python and make a class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳进Python，创建一个类。
- en: '**CREATING A CLASS**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建一个类**'
- en: 'You’ll start by creating a class and then create all your objects from that
    class. To create a class, you use the `class` keyword, the name you want to call
    the class, and the `object` class in parentheses (I’ll explain the `object` class
    in “[Inheriting a Class](ch12.html#ch12lev2sec07)” on [page 274](ch12.html#page_274)):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从创建一个类开始，然后从这个类创建所有的对象。要创建一个类，你使用`class`关键字、你想要的类名，以及括号中的`object`类（我将在 “[继承类](ch12.html#ch12lev2sec07)”
    的[第274页](ch12.html#page_274)解释`object`类）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It’s good practice to capitalize the names of your classes. This makes it easier
    to tell the difference between classes and functions, which should start with
    a lowercase letter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将类的名称大写是一个很好的实践。这使得区分类和函数更加容易，函数应该以小写字母开头。
- en: When you create a new class, you need to include the `__init__()` method and
    pass in `self` as an argument. The `self` argument is required by every method
    in a class. It references the class the method belongs to. The `__init__()` method
    tells Python what you want the class to do when you use it for the first time
    in a program. This is called *initializing* the class, which is what `__init__()`
    is short for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新类时，你需要包含`__init__()`方法并传入`self`作为参数。`self`参数是类中每个方法都必须有的，它指代该方法所属的类。`__init__()`方法告诉Python当你第一次在程序中使用这个类时，它应该做些什么。这叫做*初始化*类，`__init__()`正是初始化的缩写。
- en: 'For example, let’s create a class called `Cat` and then make some cat objects.
    The `Cat` class will store two attributes for each cat, their `name` and their
    `weight` in kilograms. Each cat object will have its own `name` and `weight` values.
    Open a new file in IDLE’s text editor and save it as *catClass.py* in a new folder
    called *classes*. Enter the following code to create a class called `Cat`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们来创建一个名为`Cat`的类，然后制作一些猫对象。`Cat`类将为每只猫存储两个属性，它们的`name`（名字）和`weight`（体重，单位：千克）。每个猫对象将拥有自己独立的`name`和`weight`值。打开IDLE的文本编辑器，创建一个新文件并将其保存为*catClass.py*，并放在一个名为*classes*的新文件夹中。输入以下代码来创建一个名为`Cat`的类：
- en: '*catClass.py*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the `__init__()` method takes three arguments ➊. The first
    is `self`, which is a required argument in every class method. The second argument,
    `name`, and the last argument, `weight`, are additional arguments to create attributes
    for all the cats.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`__init__()`方法接受三个参数 ➊。第一个是`self`，它是每个类方法中必需的参数。第二个参数`name`和最后一个参数`weight`是额外的参数，用来为所有猫创建属性。
- en: The last two lines create the attributes `name` ➋ and `weight` ➌ and set them
    to the values of the `name` and `weight` arguments. When you create attributes
    inside a class, you use dot notation with `self`. Attributes are always identified
    by a `self`, which tells Python that an attribute belongs to the class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行代码创建了属性`name` ➋和`weight` ➌，并将它们设置为`name`和`weight`参数的值。当你在类中创建属性时，需要使用带有`self`的点表示法。属性总是通过`self`来标识，它告诉Python某个属性属于该类。
- en: Next, you’ll learn how to use this class to create instances of objects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用这个类来创建对象的实例。
- en: '**CREATING AN OBJECT**'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**创建对象**'
- en: Using the newly created class, let’s create some cat objects, or instances of
    the `Cat` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新创建的类，让我们创建一些猫对象，或者说`Cat`类的实例。
- en: Initializing an object is similar to creating a variable. To initialize an object,
    you enter the name of the object, an equal sign (`=`), and the class name. You
    pass arguments to the class in parentheses, just as you do with a function call.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化对象类似于创建变量。要初始化一个对象，你只需输入对象的名称，等号（`=`）和类名。你将参数传递给类，就像调用函数一样，放在圆括号中。
- en: 'For example, let’s adopt a cat and name it Fluff. Using the `Cat` class, we
    can create a cat object called `fluff` by adding the following code on the last
    line of *catClass.py* (notice that it’s not indented):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们领养了一只猫并给它取名Fluff。使用`Cat`类，我们可以通过在*catClass.py*的最后一行添加以下代码来创建一个名为`fluff`的猫对象（请注意，它没有缩进）：
- en: '*catClass.py*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you create an object, the number of arguments you provide depends on the
    arguments in its `__init__()` function. Here we include two arguments, one for
    `name` (`"Fluff"`) and one for `weight` (`4.5`). You don’t need to include the
    `self` argument when creating an object because the `self` argument is added automatically
    by Python.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个对象时，提供的参数数量取决于`__init__()`函数中的参数。在这里，我们包括了两个参数，一个是`name`（`"Fluff"`），另一个是`weight`（`4.5`）。创建对象时不需要包含`self`参数，因为`self`参数是Python自动添加的。
- en: Creating an object is also known as *calling a constructor*. The `__init__()`
    method is often referred to as a constructor because it constructs a class when
    called. The `__init__()` method is a special type of method because you don’t
    reference it by name. Instead, it runs when you create an object using the name
    of the class. For example, here the code `fluff = Cat("Fluff", 4.5)` calls the
    `__init__()` method, which constructs a `Cat` object called `fluff`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个对象也叫做*调用构造函数*。`__init__()`方法通常被称为构造函数，因为它在被调用时构造了一个类。`__init__()`方法是一种特殊类型的方法，因为你不会通过名称引用它。相反，它会在你使用类名创建对象时自动运行。例如，这段代码`fluff
    = Cat("Fluff", 4.5)`调用了`__init__()`方法，从而构造了一个名为`fluff`的`Cat`对象。
- en: Next, you’ll learn how to access the `fluff` object’s attributes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何访问`fluff`对象的属性。
- en: '**ACCESSING ATTRIBUTES**'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问属性**'
- en: 'You can access the attributes of an object to get more information about that
    object. For example, add the following code to *catClass.py* after the `fluff`
    object to print the `weight` attribute of the `fluff` object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问对象的属性，以获取有关该对象的更多信息。例如，在`fluff`对象之后将以下代码添加到*catClass.py*中，以打印`fluff`对象的`weight`属性：
- en: '*catClass.py*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The value that prints when you run the program should be 4.5, because that’s
    what you set the `weight` attribute to when you created the object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时打印出来的值应该是4.5，因为那是你在创建对象时为`weight`属性设置的值。
- en: Notice that we’re using dot notation between the object’s name, `fluff`, and
    the `weight` attribute. The dot means you want to use the attribute that belongs
    to a specific object. In this case, the value of the `weight` attribute belongs
    to the `fluff` object. Whenever you get or set the value of an object’s attribute,
    you use dot notation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在对象名`fluff`和`weight`属性之间使用了点号表示法。点号表示你要使用属于特定对象的属性。在这种情况下，`weight`属性的值属于`fluff`对象。每当你获取或设置对象的属性值时，都使用点号表示法。
- en: 'You can change the value of an attribute as you would any other variable—by
    using an equal sign (`=`). For example, let’s change Fluff’s weight to 5 because
    he gained weight during the winter holidays. We do this by changing the `weight`
    attribute in the `fluff` object to 5:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像更改任何其他变量一样更改属性的值——通过使用等号（`=`）。例如，让我们将Fluff的体重改为5，因为他在寒假期间增加了体重。我们通过将`fluff`对象的`weight`属性更改为5来实现这一点：
- en: '*catClass.py*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now whenever you access the `weight` attribute on the `fluff` object, it will
    be 5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你访问`fluff`对象的`weight`属性时，它的值将是5。
- en: Using the knowledge you now have about making a class and creating an instance
    of it, let’s make some cool stuff in Minecraft.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运用你现在拥有的关于创建类和实例化它的知识，让我们在Minecraft中做一些酷炫的东西。
- en: '**MISSION #68: LOCATION OBJECTS**'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #68：位置对象**'
- en: Throughout the book, you’ve stored locations, such as your house, a castle,
    or a palace, in your Minecraft world. You’ve used variables, lists, tuples, and
    dictionaries to do this in a variety of ways.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你已经在Minecraft世界中存储了许多位置，比如你的房子、城堡或宫殿。你已经使用变量、列表、元组和字典以各种方式完成了这些操作。
- en: You can also create and store related information, like locations, using object-oriented
    programming. For example, you can use objects to store the coordinates of a bunch
    of different locations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用面向对象编程创建并存储相关信息，比如位置。例如，你可以使用对象来存储一堆不同位置的坐标。
- en: Each location has an x-, y-, and z-coordinate, but the values for each location
    are different. By creating a location class, you can store and access the coordinates
    of different locations. That will help you keep track of all the awesome things
    you build in Minecraft. You’ll be able to easily access the coordinates of all
    your Minecraft creations so you can teleport the player to them in an instant!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个位置都有一个x、y和z坐标，但每个位置的坐标值不同。通过创建位置类，你可以存储并访问不同位置的坐标。这将帮助你跟踪在Minecraft中建造的所有精彩事物。你将能够轻松访问所有Minecraft创作的坐标，以便你可以瞬间将玩家传送到它们的位置！
- en: '[Listing 12-1](ch12.html#ch12ex1) contains the start of the `Location` class.
    When the code is finished, it can be used to store the coordinates of a location
    in a single object. Copy the code into a new file called *locationClass.py* in
    the *classes* folder.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-1](ch12.html#ch12ex1)包含了`Location`类的起始部分。当代码完成后，它可以用来在单个对象中存储位置的坐标。将代码复制到*classes*文件夹中的一个新文件，命名为*locationClass.py*。'
- en: '*locationClass.py*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*locationClass.py*'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-1: The start of the* `Location` *class*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-1：* `Location` *类的起始部分*'
- en: To start the class, I included the `class` keyword and named the class `Location`
    ➊. At ➍ is the code to initialize an object called `bedroom`, which will store
    the location of the bedroom in my Minecraft home. The `setTilePos()` method sets
    the player’s position to the bedroom’s location—the `bedroom` object’s `x`, `y`,
    and `z` attributes ➎. However, the program is incomplete. You need to finish the
    `__init__()` method of the class and set the `y` and `z` attributes to the values
    of the arguments passed to the `__init__()` method. I set the value of the `x`
    attribute ➋, but it’s your task to do the same for the `y` and `z` attributes
    ➌. Don’t forget to use the location of your own bedroom at ➍!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始创建类，我使用了`class`关键字并命名为`Location` ➊。在 ➍ 处是初始化一个名为`bedroom`的对象的代码，它将存储我的Minecraft家中的卧室位置。`setTilePos()`方法将玩家的位置设置为卧室位置——`bedroom`对象的`x`、`y`和`z`属性
    ➎。然而，程序是不完整的。你需要完成类的`__init__()`方法，并将`y`和`z`属性设置为传递给`__init__()`方法的参数的值。我设置了`x`属性的值
    ➋，但是你需要对`y`和`z`属性做同样的操作 ➌。别忘了使用你自己卧室的位置信息在 ➍！
- en: '[Figure 12-1](ch12.html#ch12fig1) shows the completed program in action as
    it teleports the player into my bedroom.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](ch12.html#ch12fig1)显示了完整的程序运行情况，它将玩家传送到我的卧室。'
- en: '![image](graphics/f12-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-01.jpg)'
- en: '*Figure 12-1: The program has teleported the player into my bedroom.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：程序已将玩家传送到我的卧室。*'
- en: '**BONUS OBJECTIVE: HOME SWEET HOME**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：温馨的家**'
- en: Which other rooms in your house do you want to teleport to? Create more objects
    using the `Location` class to zip around your house in style!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你还想传送到你家里的哪些房间？使用`Location`类创建更多对象，以便在家里轻松移动！
- en: '**UNDERSTANDING METHODS**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解方法**'
- en: Classes can contain methods, which are functions associated with the class.
    Writing class methods lets you create functions that all instances of that class
    can use. This is a great way to save time and reuse code, because you’ll only
    have to write one method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以包含方法，方法是与类相关的函数。编写类的方法可以让你创建所有该类实例都可以使用的函数。这是一种节省时间和重用代码的好方法，因为你只需要编写一个方法。
- en: 'To create a method, you write a function in the body of a class using the `def`
    keyword. You’ve used the `def` keyword in previous chapters to create functions.
    Methods are also created with the `def` keyword, but they’re indented under the
    class they belong to. For example, let’s update the `Cat` class in *catClass.py*.
    We want the cat to be able to eat, so let’s add a method called `eat()` to the
    `Cat` class. Enter the code and make the changes to *catClass.py* as you follow
    along:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个方法，你在类的主体中使用`def`关键字写一个函数。你在前面的章节中已经用过`def`关键字来创建函数。方法也是使用`def`关键字创建的，但它们在所属类的下面缩进。例如，让我们更新*catClass.py*中的`Cat`类。我们希望猫咪能吃东西，所以让我们在`Cat`类中添加一个名为`eat()`的方法。按照代码的顺序输入并修改*catClass.py*：
- en: '*catClass.py*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the method definition and body of the method are indented by an
    extra four spaces so Python knows they belong to the class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，方法的定义和方法体比正常的代码多缩进了四个空格，这样Python就能知道它们属于这个类。
- en: Like functions, methods can take arguments. Here the `eat()` method takes an
    argument called `food` that states what the cat is eating. The `eat()` method
    increases the `weight` attribute of the cat by `0.05` and then prints a message
    that the cat is eating the food.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 像函数一样，方法也可以接受参数。在这里，`eat()`方法接受一个名为`food`的参数，表示猫咪正在吃的食物。`eat()`方法将猫咪的`weight`属性增加`0.05`，然后打印出猫咪正在吃食物的消息。
- en: 'After creating an object, you can call any of its class’s methods. For example,
    you can call the `eat()` method using the `fluff` object. Add this code to the
    end of *catClass.py*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象后，你可以调用它所属类的任何方法。例如，你可以使用`fluff`对象调用`eat()`方法。将以下代码添加到*catClass.py*的末尾：
- en: '*catClass.py*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here we see our earlier code, where we created an object called `fluff` that
    is part of the `Cat` class. Then we call the `eat()` method and give it the argument
    `"tuna"`. When you run the program, the output will look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到了之前的代码，我们创建了一个名为`fluff`的对象，它是`Cat`类的一部分。然后我们调用了`eat()`方法，并传递了参数`"tuna"`。当你运行程序时，输出会是这样的：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now Fluff is happily eating tuna. Remember that the `eat()` method also increases
    the weight attribute. After calling the `eat()` method, add the code to print
    `fluff`’s weight.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Fluff正开心地吃着金枪鱼。记住，`eat()`方法还会增加体重属性。调用`eat()`方法后，添加代码打印`fluff`的体重。
- en: 'You can also call methods from inside the class by calling a method inside
    another method. Let’s create another method called `eatAndSleep()` inside the
    `Cat` class. The `eatAndSleep()` method calls the `eat()` method and then prints
    that the cat is sleeping. Add this code to *catClass.py*, just after the `eat()`
    method (make sure you indent the new method as shown so Python knows it’s part
    of the class):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在另一个方法内部调用方法来从类内部调用方法。让我们在`Cat`类内部创建另一个名为`eatAndSleep()`的方法。`eatAndSleep()`方法调用`eat()`方法，然后打印出猫正在睡觉的信息。将此代码添加到*catClass.py*文件中，紧接在`eat()`方法后面（确保像示例中一样缩进新方法，以便Python知道它是类的一部分）：
- en: '*catClass.py*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To call a method from inside the class it belongs to, you add `self.` to the
    beginning of the method name. Here the `eat()` method is called using `self.eat()`.
    Note that this is different from calling a method outside of a class. When you
    do that, you only have to enter the object name and the method you’re calling.
    For example, the following code calls the new `eatAndSleep()` method on the `fluff`
    object. Add it to your *catClass.py* file. This should be the last line of code
    in your program:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要从类内部调用方法，你需要在方法名的前面加上`self.`。这里`eat()`方法通过`self.eat()`被调用。请注意，这与在类外部调用方法是不同的。当你这样做时，只需输入对象名和你要调用的方法。例如，以下代码在`fluff`对象上调用了新的`eatAndSleep()`方法。将其添加到你的*catClass.py*文件中，这应该是程序的最后一行代码：
- en: '*catClass.py*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the output that you should get when you run the program:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你运行程序时应该得到的输出：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s the full program so you can see where all the pieces belong:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的程序，你可以查看所有部分的位置：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s take the new skills you’ve learned into the world of Minecraft!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将你学到的新技能带入Minecraft的世界吧！
- en: '**MISSION #69: GHOST HOUSE**'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #69：鬼屋**'
- en: The best thing about programming with Python and Minecraft is that you can start
    with a silly idea and run with it. Your idea might start small, but with just
    a few lines of code, you can build a fun program very quickly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python和Minecraft编程的最佳之处在于，你可以从一个愚蠢的想法开始，然后把它实现。你的想法可能开始得很小，但只需几行代码，你就能很快构建出一个有趣的程序。
- en: Wouldn’t it be fun to build a ghost house that appeared in a game, only to disappear
    30 seconds later? The house could then reappear somewhere else and then disappear
    again if you wanted it to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 建造一个在游戏中出现，30秒后又消失的鬼屋，岂不是很有趣吗？然后，鬼屋可以在别的地方重新出现，再次消失，前提是你希望它如此。
- en: Here’s the first version of the ghost house program. Save [Listing 12-2](ch12.html#ch12ex2)
    in a file called *ghostHouse.py* in the *classes* folder.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是鬼屋程序的第一个版本。将[清单12-2](ch12.html#ch12ex2)保存为*ghostHouse.py*文件，并放在*classes*文件夹中。
- en: '*ghostHouse.py*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*ghostHouse.py*'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 12-2: The* `Building` *class creates a building.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-2：* `Building` *类创建一个建筑。*'
- en: '[Listing 12-2](ch12.html#ch12ex2) uses a class called `Building` ➊ with an
    `__init__()` method to set the house’s position and size ➋. It creates a `Building`
    object with the name `ghostHouse` ➐. The building appears and then mysteriously
    disappears after 30 seconds using the `build()` ➌ and `clear()` ➎ methods. The
    only problem is that it doesn’t look like a house. Right now it looks like a large,
    empty shell made of cobblestone.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-2](ch12.html#ch12ex2)使用了一个名为`Building` ➊的类，它通过`__init__()`方法设置房子的坐标和大小
    ➋。它创建了一个名为`ghostHouse` ➐的`Building`对象。该建筑物出现后会神秘消失，30秒后通过`build()` ➌和`clear()`
    ➎方法。唯一的问题是它看起来不像房子。现在它看起来像一个由鹅卵石做成的大空壳。'
- en: You need to make the ghost house look more like a house and less like a shell,
    because ghost shells aren’t as scary as ghost houses. To make the building look
    more house-like, your mission is to add a method that builds a door at the front
    of the house and a second method that adds windows. Call these two methods from
    inside the `build()` method so they’re built at the same time ➍.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要让鬼屋看起来更像一座房子，而不是像一个空壳，因为鬼壳不像鬼屋那么可怕。为了让建筑物看起来更像房子，你的任务是添加一个方法，在房子的前面建造一扇门，并添加第二个方法来安装窗户。从`build()`方法中调用这两个方法，以便它们同时构建
    ➍。
- en: After adding the methods to build a door and windows, you’ll need to update
    the `clear()` method to delete them ➏; otherwise, they’ll be left behind when
    the house disappears.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加构建门和窗户的方法后，你需要更新`clear()`方法来删除它们➏；否则，当房子消失时，它们将被遗留在原地。
- en: When you’ve added the extra methods, move the building to a new location by
    changing the `x`, `y`, and `z` attributes of the `ghostHouse` object and adding
    more calls to the `build()` and `clear()` methods. I’ve started this for you by
    changing the house’s `x` position ➑.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加了额外的方法后，通过更改 `ghostHouse` 对象的 `x`、`y` 和 `z` 属性，并添加更多对 `build()` 和 `clear()`
    方法的调用来将建筑物移动到新位置。我已经为你做了一些修改，改变了房子的 `x` 位置 ➑。
- en: When you run the program, the ghost house should suddenly appear and then disappear
    30 seconds later, only to reappear somewhere else. Spooky!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，鬼屋应该会突然出现，然后在 30 秒后消失，再次出现在其他地方。好吓人！
- en: '[Figure 12-2](ch12.html#ch12fig2) shows my ghost house.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-2](ch12.html#ch12fig2) 显示了我的鬼屋。'
- en: '![image](graphics/f12-02.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-02.jpg)'
- en: '*Figure 12-2: The ghost house appears and then disappears.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：鬼屋出现后又消失。*'
- en: '**BONUS OBJECTIVE: HOME IMPROVEMENT**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：家庭改造**'
- en: At the moment, the ghost house is very basic. Using the amazing Python skills
    you’ve learned in this book, add whatever you want to the `build()` function to
    customize your house.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，鬼屋非常基础。利用你在本书中学到的 Python 技巧，向 `build()` 函数中添加任何你想要的内容，以定制你的房子。
- en: '**RETURNING VALUES WITH METHODS**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过方法返回值**'
- en: 'Like functions, methods can also return values, or an object’s attributes,
    using the `return` keyword. For example, let’s say we want to convert Fluff the
    cat’s weight from kilograms to grams. A kilogram is equal to 1000 grams, so to
    make the conversion, you multiply the `weight` attribute by 1000 and return it.
    Add the following `getWeightInGrams()` method to the `Cat` class in *catClass.py*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 像函数一样，方法也可以使用 `return` 关键字返回值或对象的属性。例如，假设我们想将猫 Fluff 的体重从千克转换为克。1 千克等于 1000
    克，因此为了进行转换，你需要将 `weight` 属性乘以 1000 并返回它。将以下 `getWeightInGrams()` 方法添加到 *catClass.py*
    中的 `Cat` 类：
- en: '*catClass.py*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To output the value returned by the method, you create an object and call the
    method. In the following code, the `fluff` object is used, and the method is called
    inside a `print()` function to get the cat’s weight in grams:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出方法返回的值，你需要创建一个对象并调用该方法。在以下代码中，使用了 `fluff` 对象，并在 `print()` 函数中调用该方法，以获取猫的体重（以克为单位）：
- en: '*catClass.py*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now when you run the file, it will output the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行该文件时，它将输出以下内容：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next mission, we’ll extend the ghost house program to include a method
    that returns information about the building.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个任务中，我们将扩展鬼屋程序，加入一个返回建筑物信息的方法。
- en: '**MISSION #70: GHOST CASTLE**'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #70：鬼屋城堡**'
- en: 'I have all kinds of names in mind for the different places I’ve built in my
    Minecraft world: the beach house, the plant farm, the animal farm, the storage
    room, the palace, the underwater palace, the underground palace, and loads more.
    The problem is that the names only exist in my head!'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我有各种各样的名字，分别对应我在 Minecraft 世界中建造的不同地方：海滩房、植物农场、动物农场、储藏室、宫殿、水下宫殿、地下宫殿，等等。问题是这些名字仅存在于我的脑海中！
- en: 'With classes, you can create attributes like location and size for things you
    build, as you saw in [Mission #69](ch12.html#ch12lev2sec04) ([page 263](ch12.html#page_263)).
    You can also include names!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '使用类，你可以为你建造的事物创建诸如位置和大小等属性，正如你在 [任务 #69](ch12.html#ch12lev2sec04)（[第 263 页](ch12.html#page_263)）中看到的那样。你还可以包括名称！'
- en: 'Let’s name the ghost house and have Python remember it for us. We’ll update
    the `Building` class from [Mission #69](ch12.html#ch12lev2sec04) to add an extra
    method that returns the name of the building. Copy [Listing 12-3](ch12.html#ch12ex3)
    into a new file called *ghostCastle.py* in the *classes* folder.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们给鬼屋起个名字，并让 Python 为我们记住它。我们将更新 [任务 #69](ch12.html#ch12lev2sec04) 中的 `Building`
    类，添加一个额外的方法来返回建筑物的名称。将 [清单 12-3](ch12.html#ch12ex3) 复制到一个名为 *ghostCastle.py* 的新文件中，放在
    *classes* 文件夹中。'
- en: '*ghostCastle.py*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*ghostCastle.py*'
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 12-3:* `NamedBuilding` *is very similar to the* `Building` *class,
    except it has an extra attribute called* `name` *and an extra method that returns
    a description of the building.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3：* `NamedBuilding` *与* `Building` *类非常相似，不同之处在于它有一个额外的属性* `name` *和一个返回建筑物描述的额外方法。*'
- en: First, I changed the name of the class to `NamedBuilding` so we won’t confuse
    it with the `Building` class from the previous mission ➊. I’ve added an extra
    argument and attribute to the constructor called `name` ➋. The argument allows
    you to give a name to the building, and the constructor assigns the name to the
    `name` attribute ➌.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将类的名称改为`NamedBuilding`，以免与之前任务中的`Building`类混淆 ➊。我在构造函数中添加了一个额外的参数和属性，叫做`name`
    ➋。该参数允许你为建筑物命名，构造函数将该名称赋给`name`属性 ➌。
- en: Your mission is to add a method called `getInfo()` to the new class `NamedBuilding`
    that returns the name and position of the building. I’ve added the start of the
    `getInfo()` method for you at ➍. You just need to add the body. The `getInfo()`
    method is called on the `ghostCastle` object at ➎ so it outputs the string returned
    by the method to the Minecraft chat. For example, if the ghost castle is located
    at `x = -310`, `y = 64`, `z = 1081`, the `getInfo()` method should return the
    string `"Ghost Castle's location is at -310, 64, 1081"`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是向新的`NamedBuilding`类添加一个名为`getInfo()`的方法，该方法返回建筑物的名字和位置。我已经为你在➍处添加了`getInfo()`方法的开头。你只需补充方法体即可。在➎处调用了`getInfo()`方法，它会将方法返回的字符串输出到Minecraft聊天框。例如，如果鬼屋位于`x
    = -310`，`y = 64`，`z = 1081`，`getInfo()`方法应返回字符串`"Ghost Castle's location is at
    -310, 64, 1081"`。
- en: '[Figure 12-3](ch12.html#ch12fig3) shows my working program. Although the ghost
    castle is taller, it looks like the house from [Mission #69](ch12.html#ch12lev2sec04).
    This is because the `build()` methods are the same for both, but feel free to
    change your version of the code so your building looks more like a castle.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-3](ch12.html#ch12fig3)显示了我的工作程序。尽管鬼屋更高，但它看起来像[任务 #69](ch12.html#ch12lev2sec04)中的房子。这是因为`build()`方法在两者之间是相同的，但你可以随意修改你的代码版本，使你的建筑更像一座城堡。'
- en: '![image](graphics/f12-03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-03.jpg)'
- en: '*Figure 12-3: The description of the ghost castle is displayed.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：鬼屋的描述被显示出来。*'
- en: '**BONUS OBJECTIVE: A WARM WELCOME**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：热烈欢迎**'
- en: 'Wouldn’t it be cool if the name of any building you walked into appeared in
    the chat automatically? Well, it’s possible, but it’s a bit challenging. If you
    want to try this, you can use the *shower.py* program from [Mission #32](ch06.html#ch06lev2sec11)
    ([page 120](ch06.html#page_120)) as a starting point. The file should be in your
    *ifStatements* folder. You can use the program to detect the coordinates of the
    player and, if they’re inside the building, call the `building` object’s `getInfo()`
    method.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你走进任何建筑物时，建筑物的名字自动出现在聊天框里，不是很酷吗？其实是可能的，但有点挑战。如果你想试试，可以使用[任务 #32](ch06.html#ch06lev2sec11)中的*shower.py*程序（[第120页](ch06.html#page_120)）作为起点。该文件应该在你的*ifStatements*文件夹里。你可以使用该程序检测玩家的坐标，并且如果玩家在建筑物内，就调用`building`对象的`getInfo()`方法。'
- en: '**CREATING MULTIPLE OBJECTS**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建多个对象**'
- en: 'You can make several objects from the same class by creating objects with different
    names using the same class constructor (remember that *constructor* is another
    name for the `__init__()` method). For example, let’s say we found a second cat
    named Stella who is now friends with Fluff. Open *catClass.py* and enter the following
    code to add Stella:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用相同的类构造函数创建具有不同名称的对象，从而从同一个类中创建多个对象（记住，*构造函数*是`__init__()`方法的另一种说法）。例如，假设我们找到了第二只猫，名叫Stella，现在她和Fluff成为了朋友。打开*catClass.py*并输入以下代码来添加Stella：
- en: '*catClass.py*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we have two cat objects, `fluff` and `stella`. Each has the same attributes,
    `name` and `weight`, but with different values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个猫对象，`fluff` 和 `stella`。它们有相同的属性，`name` 和 `weight`，但值不同。
- en: 'Add the following code to *catClass.py* to print the cats’ names:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到*catClass.py*以打印猫的名字：
- en: '*catClass.py*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you run the file, you’ll get this output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行文件时，你将得到以下输出：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The two cat objects also have access to the same methods. Both can call the
    `eat()` function. Add this code to *catClass.py*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个猫对象也可以访问相同的方法。它们都可以调用`eat()`函数。将以下代码添加到*catClass.py*：
- en: '*catClass.py*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the output will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Writing a class makes creating lots of objects very easy. Let’s try creating
    multiple objects with Minecraft!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类使得创建多个对象变得非常容易。让我们尝试在Minecraft中创建多个对象！
- en: '**MISSION #71: GHOST TOWN**'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #71：鬼镇**'
- en: What’s scarier than one ghost house? That’s right, two ghost houses. But three
    ghost houses would be even scarier. And more than three ghost houses? I need to
    stop thinking about this, or I won’t get any sleep tonight!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 什么比一座幽灵房子更可怕？没错，两个幽灵房子。但三座幽灵房子会更可怕。而超过三座幽灵房子？我得停止这样想，否则今晚我就睡不着了！
- en: 'In [Mission #69](ch12.html#ch12lev2sec04) ([page 263](ch12.html#page_263)),
    you made a class that builds a house that disappears. Now you can create several
    objects using the same class, and Python will remember each of the object’s attributes
    and methods. You can make as many houses as you want, and you can make them appear
    and disappear with ease.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在[任务#69](ch12.html#ch12lev2sec04)（[第263页](ch12.html#page_263)）中，你创建了一个可以建造消失房子的类。现在你可以使用相同的类创建多个对象，Python会记住每个对象的属性和方法。你可以创建任意数量的房子，并轻松地让它们出现和消失。
- en: Your mission is to create four or more ghost house objects and arrange them
    in a village. After a certain amount of time, make them all disappear and reappear
    elsewhere on the map, just like a real ghost town.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建四个或更多幽灵房子对象，并将它们布置成一个村庄。在一定时间后，让它们全部消失，并在地图的其他地方重新出现，就像一个真正的鬼镇一样。
- en: 'Open *ghostHouse.py* in IDLE—we’ll use this as a base. When you created a house
    in the *ghostHouse.py* program, your code should have looked like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE中打开*ghostHouse.py*——我们将以此为基础。当你在*ghostHouse.py*程序中创建房子时，你的代码应该像这样：
- en: '*ghostHouse.py*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*ghostHouse.py*'
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Save *ghostHouse.py* as a new file called *ghostVillage.py*, and then create
    three or more objects in the file using the `Building` class to build the village.
    To help you get started, I’ve created a second object called `shop` in [Listing
    12-4](ch12.html#ch12ex4). I’ve also set the variables `x`, `y`, and `z` to hold
    the player’s current position, which we find using `player.getTilePos()`. This
    makes it easier to build the village all around you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将*ghostHouse.py*保存为一个名为*ghostVillage.py*的新文件，然后在文件中使用`Building`类创建三个或更多对象来构建村庄。为了帮助你入门，我在[Listing
    12-4](ch12.html#ch12ex4)中创建了一个名为`shop`的第二个对象。我还设置了`x`、`y`和`z`变量，用于存储玩家当前位置，这个位置通过`player.getTilePos()`来获取。这样可以更方便地在你周围构建村庄。
- en: '*ghostVillage.py*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*ghostVillage.py*'
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 12-4: Creating multiple ghost building objects*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-4：创建多个幽灵建筑对象*'
- en: '[Figure 12-4](ch12.html#ch12fig4) shows my ghost village. After 30 seconds,
    the ghost buildings suddenly disappear.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 12-4](ch12.html#ch12fig4)展示了我的幽灵村庄。30秒后，幽灵建筑突然消失。'
- en: '![image](graphics/f12-04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-04.jpg)'
- en: '*Figure 12-4: Look at all the ghost buildings in the ghost village!*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 12-4：看看幽灵村庄里的所有幽灵建筑！*'
- en: '**CLASS ATTRIBUTES**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**类属性**'
- en: Sometimes you might want to set attributes that have the same value for every
    object instance in a class. It would be redundant to pass the same argument to
    the class every time an object is created. Instead, you can create a preset attribute
    in the class, and all the instances of objects in that class will share those
    attributes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想为类中的每个对象实例设置具有相同值的属性。每次创建对象时传递相同的参数是冗余的。相反，你可以在类中创建一个预设的属性，类中所有对象实例将共享这些属性。
- en: 'When multiple objects share the same attribute, it’s called a *class attribute*.
    For example, all the cat objects we’ve created are owned by Craig (me). I can
    revisit the `Cat` class in the *catClass.py* file, create a class attribute called
    `owner`, and set it to `"Craig"`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个对象共享相同的属性时，这被称为*类属性*。例如，我们创建的所有猫对象都由Craig（我）拥有。我可以在*catClass.py*文件中重新访问`Cat`类，创建一个名为`owner`的类属性，并将其设置为`"Craig"`：
- en: '*catClass.py*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, class attributes don’t use `self` before their name. In this
    example, `owner` is a class attribute and `self.name` is an attribute. Notice
    that you define class attributes outside the `__init__()` function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，类属性在名称前不使用`self`。在这个例子中，`owner`是一个类属性，而`self.name`是一个实例属性。注意，类属性是在`__init__()`函数之外定义的。
- en: 'Class attributes work the same as any other attribute in an object. For example,
    you can access the value of a class attribute as you would a normal attribute.
    In this case, to find Fluff’s owner, we can print the `owner` class attribute
    of the `fluff` object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性与对象中的任何其他属性工作方式相同。例如，你可以像访问普通属性一样访问类属性的值。在这个例子中，为了找出Fluff的所有者，我们可以打印`fluff`对象的`owner`类属性：
- en: '*catClass.py*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The printed value should be `"Craig"`. If we printed Stella’s owner, the value
    would be the same because class attributes are the same for every object in that
    class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的值应该是`"Craig"`。如果我们打印Stella的所有者，值也会是一样的，因为类属性对该类中的每个对象都是相同的：
- en: '*catClass.py*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The printed value here is also `"Craig"`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里打印的值也是`"Craig"`。
- en: 'You can change the value of class attributes for individual objects. This will
    change the value of the attribute for that object, but no other objects in the
    class. For example, Stella has been adopted by my friend Matthew, so we need to
    change Stella’s owner to `"Matthew"`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改变单个对象的类属性值。这会改变该对象的属性值，但不会影响类中其他对象。例如，Stella已被我的朋友Matthew收养，所以我们需要将Stella的所有者改为`"Matthew"`：
- en: '*catClass.py*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the `owner` attribute of `stella` is printed, it shows `"Matthew"`, but
    `fluff`’s owner is still `"Craig"`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印`stella`的`owner`属性时，它显示的是`"Matthew"`，但是`fluff`的所有者仍然是`"Craig"`。
- en: After all the changes we’ve made to *catClass.py*, the final program looks like
    the following. It’s also available in the book’s resources at *[https://www.nostarch.com/pythonwithminecraft/](https://www.nostarch.com/pythonwithminecraft/)*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对*catClass.py*做了所有更改后，最终的程序如下所示。它也可以在本书的资源中找到，地址是*[https://www.nostarch.com/pythonwithminecraft/](https://www.nostarch.com/pythonwithminecraft/)*。
- en: '*catClass.py*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*catClass.py*'
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that you’ve seen how to use objects, let’s see how to make them even more
    powerful with inheritance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到如何使用对象了，让我们来看一下如何通过继承让它们更强大。
- en: '**UNDERSTANDING INHERITANCE**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解继承**'
- en: '*Inheritance* occurs when classes share the same methods and attributes as
    other classes. For example, ducks are a type of bird. They share the same methods
    as other birds (flying, eating, and so on), and they have the same attributes
    as other birds (weight, wingspan, and so on). So you could say that *ducks* inherit
    their attributes and methods from the class *birds*. [Figure 12-5](ch12.html#ch12fig5)
    shows this relationship in a diagram.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承*发生在类共享与其他类相同的方法和属性时。例如，鸭子是一种鸟类。它们与其他鸟类共享相同的方法（飞行、进食等），并且具有与其他鸟类相同的属性（体重、翼展等）。因此，你可以说*鸭子*从*鸟类*继承了它们的属性和方法。[图12-5](ch12.html#ch12fig5)展示了这种关系的示意图。'
- en: '![image](graphics/f12-05.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-05.jpg)'
- en: '*Figure 12-5: Penguins and ducks are both types of birds.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-5：企鹅和鸭子都是鸟类的一种。*'
- en: The class that other classes inherit from is called a *superclass*; the class
    that inherits from the superclass is called a *subclass*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类继承的类称为*父类*；从父类继承的类称为*子类*。
- en: 'Inheritance is useful because it allows you to create subtle differences between
    similar objects. For example, penguins are also a type of bird, but they can swim
    underwater, unlike most birds. To represent penguins, you need to create a subclass
    that inherits from the bird class but has adaptations so the penguins can swim
    underwater. These adaptations are the reason you create subclasses: you can keep
    the main superclass features to avoid having to write the code again, and just
    add the methods and attributes you need in the subclass.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 继承很有用，因为它允许你在相似的对象之间创建细微的差异。例如，企鹅也是一种鸟类，但它们可以在水下游泳，而不像大多数鸟类。为了表示企鹅，你需要创建一个从鸟类继承的子类，但该子类有适应性，使得企鹅能够在水下游泳。这些适应性是你创建子类的原因：你可以保留父类的主要特征，以避免重复编写代码，并且仅在子类中添加所需的方法和属性。
- en: '**INHERITING A CLASS**'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**继承类**'
- en: When a subclass inherits from a superclass, the subclass can use all the superclass’s
    methods and attributes. The subclass can also add extra classes and attributes
    without altering the original superclass.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类从父类继承时，子类可以使用父类的所有方法和属性。子类还可以添加额外的类和属性，而无需修改原始父类。
- en: 'Let’s use the birds example to illustrate this. First, we’ll write the code
    for the `Bird` superclass. Open a new file in IDLE, name it *birdClass.py*, and
    then add the following code to make the class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用鸟类的例子来说明这一点。首先，我们将编写`Bird`父类的代码。打开IDLE中新建一个文件，命名为*birdClass.py*，然后添加以下代码来创建类：
- en: '*birdClass.py*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We create a class called `Bird` ➊, but notice that the `Bird` class inherits
    from `object`. The `object` class is a base class that all other classes will
    be built on top of. All classes inherit from the `object` class, and you use it
    when there are no other superclasses to inherit from. Even if there are several
    levels of inheritance where lots of classes inherit from each other, the `object`
    class will always be the superclass used on the highest level of inheritance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Bird`的类➊，但请注意，`Bird`类继承自`object`。`object`类是一个基类，所有其他类都将基于它来构建。所有类都继承自`object`类，当没有其他父类可供继承时，你就会使用它。即使存在多个继承层次，许多类彼此继承，`object`类始终是继承体系中最高层次的父类。
- en: 'The `Bird` class’s `__init__()` method takes two arguments that set two attributes:
    the `name` of the bird and its `wingspan` ➋. It has two methods: `birdcall()`
    ➌ and `fly()` ➍. At the moment, the `birdcall()` method just prints `"chirp"`
    and the `fly()` method just prints `"flap"`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bird`类的`__init__()`方法有两个参数，用于设置两个属性：鸟的`name`和它的`wingspan` ➋。它有两个方法：`birdcall()`
    ➌和`fly()` ➍。目前，`birdcall()`方法只是打印“chirp”，而`fly()`方法只是打印“flap”。'
- en: 'In the same file, create an object called `gardenBird` using the `Bird` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，使用`Bird`类创建一个名为`gardenBird`的对象：
- en: '*birdClass.py*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code will output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that you’ve created a superclass, you can create a subclass that inherits
    from the superclass but gets its own method. You’ll do that in the next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个超类，你可以创建一个继承超类的子类，并且该子类有自己的方法。在下一部分中你将实现这一点。
- en: '**ADDING NEW METHODS TO SUBCLASSES**'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**向子类添加新方法**'
- en: 'Let’s add a class for penguins to *birdClass.py* and call it `Penguin`. Because
    penguins can swim underwater, you can add an extra method to the `Penguin` class
    called `swim()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为企鹅在*birdClass.py*中添加一个类，命名为`Penguin`。因为企鹅可以在水下游泳，所以你可以向`Penguin`类添加一个名为`swim()`的额外方法：
- en: '*birdClass.py*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you define a subclass and want it to inherit from another superclass instead
    of `object`, you put the name of the superclass to inherent from in parentheses.
    Notice that I didn’t create an `__init__()` method for the `Penguin` class. The
    reason is that it inherits from the `Bird` class, so it uses the `Bird` class
    `__init__()` method. Let’s use that `__init__()` method and test the `swim()`
    function by creating a penguin:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个子类并希望它继承另一个超类而不是`object`时，你需要在括号中放入超类的名称。请注意，我没有为`Penguin`类创建`__init__()`方法。原因是它继承了`Bird`类，因此使用的是`Bird`类的`__init__()`方法。让我们使用该`__init__()`方法，并通过创建企鹅来测试`swim()`函数：
- en: '*birdClass.py*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code will output the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出以下内容：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Penguin` class can also use the `fly()` and `birdcall()` methods because
    it inherits them from `Bird`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Penguin`类也可以使用`fly()`和`birdcall()`方法，因为它继承了这些方法来自`Bird`。'
- en: '*birdClass.py*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this case, the output will look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将是这样的：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But `flap` and `chirp` don’t make sense for a penguin because penguins can’t
    fly and their birdcall is more of a quack! We’ll learn how to override inherited
    methods and fix this in “[Overriding Methods and Attributes](ch12.html#ch12lev1sec08)”
    on [page 278](ch12.html#page_278).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`flap`和`chirp`对于企鹅来说没有意义，因为企鹅不能飞，而且它们的鸟鸣更像是嘎嘎声！我们将在[《重写方法和属性》](ch12.html#ch12lev1sec08)中学习如何重写继承的方法并修复这个问题，参见[第278页](ch12.html#page_278)。
- en: But first, let’s return to Minecraft and create some new ghost buildings using
    inheritance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是首先，让我们回到Minecraft，并利用继承创建一些新的鬼建筑。
- en: '**MISSION #72: GHOST HOTEL**'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #72: 鬼酒店**'
- en: 'Houses and hotels are both types of buildings: they have doors, windows, rooms,
    stairs, and walls. Hotels are just fancy houses with extras like balconies, lots
    of rooms, and a pretty entrance.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 房屋和酒店都是建筑物类型：它们有门、窗、房间、楼梯和墙壁。酒店只是豪华的房子，增加了阳台、更多的房间和一个漂亮的入口。
- en: How can you program some ghost hotels using the code you’ve already created
    for ghost houses? The basic structure of the buildings is the same. So let’s say
    the only difference is that ghost hotels have extra methods to create carpets
    inside the rooms and add flowers around the edge of the building. That means the
    ghost hotel class can inherit all the methods from the ghost house class. Then
    all the ghost hotel class needs is two extra methods for the carpets and flowers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如何利用你已经为鬼屋创建的代码编写一些鬼酒店？建筑物的基本结构是相同的。所以可以说唯一的区别是鬼酒店在房间内有创建地毯和在建筑物边缘添加花卉的额外方法。这意味着鬼酒店类可以继承鬼屋类的所有方法。然后，鬼酒店类只需要两个额外的方法来处理地毯和花卉。
- en: In IDLE, create a new file and save it as *ghostHotel.py* in the *classes* folder.
    Copy and paste the code for the `Building` class from the *ghostHouse.py* program
    into the file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE中，创建一个新文件并将其保存为*ghostHotel.py*，保存在*classes*文件夹中。将*ghostHouse.py*程序中`Building`类的代码复制并粘贴到该文件中。
- en: Create a new class called `FancyBuilding` that inherits from the `Building`
    class. The `FancyBuilding` class should have a new method called `upgrade()` that
    adds carpet inside the building and flowers around the walls. [Listing 12-5](ch12.html#ch12ex5)
    shows my code for the `upgrade()` method, but feel free to customize your hotels.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`FancyBuilding`的新类，它继承自`Building`类。`FancyBuilding`类应该有一个新的方法`upgrade()`，该方法在建筑物内部添加地毯，并在墙壁周围种植花卉。[代码清单
    12-5](ch12.html#ch12ex5)展示了我的`upgrade()`方法的代码，但你可以根据需要自定义你的酒店。
- en: '*ghostHotel.py*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*ghostHotel.py*'
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 12-5: A method for the* `FancyBuilding` *class that adds carpet and
    flowers to the building*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 12-5：为`FancyBuilding`类添加地毯和花卉的一个方法*'
- en: After you’ve created the class and added the new method, create an instance
    of the `FancyBuilding` class and call it `ghostHotel`. Build the ghost hotel using
    the `build()` method, and then add the extra bits using the `upgrade()` method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了类并添加了新方法后，创建一个`FancyBuilding`类的实例，并命名为`ghostHotel`。使用`build()`方法构建幽灵酒店，然后使用`upgrade()`方法添加额外的元素。
- en: '[Figure 12-6](ch12.html#ch12fig6) shows my fancy ghost hotel.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-6](ch12.html#ch12fig6)展示了我的华丽幽灵酒店。'
- en: '![image](graphics/f12-06.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-06.jpg)'
- en: '*Figure 12-6: Look at those flowers and that carpet!*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：看看那些花和地毯！*'
- en: '**BONUS OBJECTIVE: FANCY VILLAGE**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：华丽的村庄**'
- en: 'In [Mission #71](ch12.html#ch12lev2sec06), you created a ghost village in which
    all the buildings looked about the same. It’s rare to see identical buildings
    in real towns. Change the ghost village program by creating several classes that
    inherit from the `Building` class. You could make a `Shop` class, a `Hospital`
    class, and a `Restaurant` class, for example. Then when you create the objects,
    you can choose which type of building to create by using the different classes.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '在[任务 #71](ch12.html#ch12lev2sec06)中，你创建了一个幽灵村庄，其中所有建筑物看起来差不多。在现实中的城市中，很少会看到完全相同的建筑。通过创建多个从`Building`类继承的类，来修改这个幽灵村庄程序。你可以创建一个`Shop`类，一个`Hospital`类，一个`Restaurant`类，例如。然后在创建对象时，你可以通过使用不同的类来选择创建哪种类型的建筑。'
- en: '**OVERRIDING METHODS AND ATTRIBUTES**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重写方法和属性**'
- en: It’s possible for a subclass to redefine methods and attributes from its superclass.
    This is useful when you want to use the same name for a method but you want it
    to behave differently in the subclass.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以重新定义其父类中的方法和属性。这在你希望使用相同名称的函数，但希望在子类中表现得不同的时候非常有用。
- en: 'In “[Understanding Inheritance](ch12.html#ch12lev1sec07)” on [page 273](ch12.html#page_273),
    we created a `Bird` class and a `Penguin` class. The `Penguin` class inherited
    from `Bird` so it shared all its methods. But penguins can’t fly, and their birdcall
    is more of a quack sound than a chirp. So, we should change the `fly()` and `birdcall()`
    methods to reflect this. Open *birdClass.py* and add this code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在[《理解继承》](ch12.html#ch12lev1sec07)一节中，[第273页](ch12.html#page_273)，我们创建了一个`Bird`类和一个`Penguin`类。`Penguin`类继承自`Bird`，因此它共享所有父类的方法。但是，企鹅不能飞，它们的鸟叫声更像是呱呱声，而不是鸟鸣。因此，我们应该修改`fly()`和`birdcall()`方法以反映这一点。打开*birdClass.py*并添加以下代码：
- en: '*birdClass.py*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I’ve made two changes to the `Penguin` class. I’ve added a `birdcall()` ➊ method
    and a `fly()` ➋ method. Because both methods are spelled the same as they are
    in the `Bird` superclass, they will override the superclass’s methods.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我对`Penguin`类做了两个修改。我添加了一个`birdcall()` ➊方法和一个`fly()` ➋方法。由于这两个方法的拼写与`Bird`父类中的方法相同，因此它们会重写父类中的方法。
- en: 'Call the methods by adding this code to *birdClass.py*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下代码添加到*birdClass.py*中来调用这些方法：
- en: '*birdClass.py*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now when you run the program, you’ll get this output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行程序时，你会看到以下输出：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Overriding a method from a superclass will change what the method does for the
    subclass but not the superclass. So penguins won’t be able to fly, but other birds
    that inherit from `Bird` will still be able to fly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重写父类中的方法会改变该方法对子类的作用，但不会影响父类。因此，企鹅不能飞，但其他继承自`Bird`的鸟类仍然可以飞。
- en: You can also overwrite the `__init__()` method in a subclass. This means that
    when the subclass object is created, it can have different attributes or behaviors
    than the superclass.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在子类中重写`__init__()`方法。这意味着当子类对象被创建时，它可以有不同于父类的属性或行为。
- en: 'For example, let’s create a `Parrot` subclass of `Bird` in the same file. Parrots
    can be different colors, so let’s include an extra argument in the `__init__()`
    method for a `color` attribute:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在同一个文件中创建一个`Parrot`类，作为`Bird`类的子类。鹦鹉可以有不同的颜色，所以我们在`__init__()`方法中添加一个`color`属性作为额外的参数：
- en: '*birdClass.py*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I’ve included a new `__init__()` method for the `Parrot` class that has an extra
    argument, `color` ➊, when compared to the original `Bird` class.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我已为`Parrot`类添加了一个新的`__init__()`方法，与原始的`Bird`类相比，它有一个额外的参数`color`➊。
- en: 'Now when we create a new `Parrot` object, we can access the `color` attribute.
    We can also access the `birdcall()` and `fly()` methods because they were inherited
    from the `Bird` superclass:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们创建一个新的`Parrot`对象时，我们可以访问`color`属性。我们还可以访问`birdcall()`和`fly()`方法，因为它们是从`Bird`超类继承来的：
- en: '*birdClass.py*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code will output the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出以下内容：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Remember that you can overwrite any method that a subclass inherits from a superclass;
    you can even overwrite the `__init__()` method. This gives you a lot of control
    over objects and their many attributes and methods.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以重写任何子类继承自超类的方法；甚至可以重写`__init__()`方法。这使你可以对对象及其许多属性和方法有很大的控制权。
- en: After all the changes we’ve made to *birdClass.py*, the final program looks
    like the following. It’s also available in the book’s resources at *[https://www.nostarch.com/pythonwithminecraft/](https://www.nostarch.com/pythonwithminecraft/)*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对*birdClass.py*做出所有更改后，最终的程序如下所示。它也可以在本书的资源中找到，网址是*[https://www.nostarch.com/pythonwithminecraft/](https://www.nostarch.com/pythonwithminecraft/)*。
- en: '*birdClass.py*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*birdClass.py*'
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You’ll try overriding methods and attributes in the next mission.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个任务中，你将尝试重写方法和属性。
- en: '**MISSION #73: GHOST TREE**'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #73：幽灵树**'
- en: You’ve created several forms of ghost buildings. Let’s take it to the next level
    and create a ghost tree. That’s an amazing idea, but how can we do it? The `Building`
    class is for buildings, which have walls and ceilings—trees don’t have walls or
    ceilings. Worry not! You can work around this by modifying your ghost `Building`
    class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了几种形式的幽灵建筑。让我们将其提升到一个新的层次，创建一棵幽灵树。这是个了不起的想法，但我们该怎么做呢？`Building`类是为建筑物设计的，建筑物有墙壁和天花板——而树没有墙壁或天花板。别担心！你可以通过修改你的幽灵`Building`类来解决这个问题。
- en: Like the ghost buildings, the ghost tree will appear and disappear using the
    `build()` and `clear()` methods. But the methods need to work differently because
    trees look different from houses. So, you need to create a class that inherits
    from the `Building` class and then override the `build()` and `clear()` methods.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 像幽灵建筑一样，幽灵树将通过`build()`和`clear()`方法出现和消失。但由于树与房屋不同，方法需要进行不同的处理。所以，你需要创建一个从`Building`类继承的类，然后重写`build()`和`clear()`方法。
- en: To get you started, I’ve grabbed the function that creates a tree from the *forest.py*
    file ([page 149](ch08.html#page_149)) and put it in [Listing 12-6](ch12.html#ch12ex6).
    Copy it into a new file called *ghostTree.py* in the *classes* folder.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你开始，我从*forest.py*文件中提取了创建树的函数（[第149页](ch08.html#page_149)），并将其放入[清单12-6](ch12.html#ch12ex6)。将其复制到*classes*文件夹中的新文件*ghostTree.py*中。
- en: '*ghostTree.py*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*ghostTree.py*'
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 12-6: A function to create a tree*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-6：创建树的函数*'
- en: To finish the program, copy and paste the code for the `Building` class from
    *ghostHouse.py* into the new file. Then create a new class called `Tree` that
    inherits from the `Building` class. Inside the `Tree` class, add a `build()` method
    and a `clear()` method to override the methods from the `Building` class and build
    a tree instead of a house. Make sure you include the `self` argument in front
    of the attributes in the final `growTree()` method ➊.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成程序，将*ghostHouse.py*中的`Building`类代码复制并粘贴到新文件中。然后，创建一个名为`Tree`的新类，继承自`Building`类。在`Tree`类内部，添加一个`build()`方法和一个`clear()`方法，以重写`Building`类中的方法，从而建立一棵树而不是房子。确保在最终的`growTree()`方法中，属性前面加上`self`参数➊。
- en: After you’ve created the program, make a `Tree` object called `ghostTree`. Call
    the `build()` method to make the tree appear, wait a bit, and then make it vanish
    using `clear()`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完程序后，创建一个名为`ghostTree`的`Tree`对象。调用`build()`方法让树出现，稍等片刻，然后使用`clear()`让它消失。
- en: '[Figure 12-7](ch12.html#ch12fig7) shows the result of my program.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-7](ch12.html#ch12fig7)显示了我的程序结果。'
- en: '![image](graphics/f12-07.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f12-07.jpg)'
- en: '*Figure 12-7: That’s a spooky tree!*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-7：那是一棵诡异的树！*'
- en: '**BONUS OBJECTIVE: GHOST FOREST**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：幽灵森林**'
- en: Modify the code in *ghostTree.py* to build a ghost forest. What kinds of treasures
    do you think you could find in a ghost forest?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 修改*ghostTree.py*中的代码，创建一个幽灵森林。你认为在幽灵森林中可以找到什么样的宝藏？
- en: '**WHAT YOU LEARNED**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: 'You just learned the basics of one of the most important concepts in programming
    today: object-oriented programming! You learned how to write a class and create
    objects, and you learned how to use inheritance to customize classes and object
    behavior. You’ll be able to apply this very useful skill not only in Minecraft
    but also in any kind of programming adventure that you choose to go on to next!'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了当今编程中最重要的概念之一：面向对象编程！你学会了如何编写类和创建对象，也学会了如何使用继承来定制类和对象的行为。你将能够将这一非常有用的技能应用到不仅是Minecraft中，还可以在你选择的任何编程冒险中！
