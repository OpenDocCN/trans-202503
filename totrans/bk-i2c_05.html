<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_67" title="67"/>4</span><br/>&#13;
<span class="ChapterTitle">Tools for Analyzing and Debugging I<sup>2</sup>C Transmissions</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">When designing I<sup>2</sup>C hardware and writing software to work with I<sup>2</sup>C hardware, you will often discover that software-based debuggers and <code>printf</code> statements are insufficient for quickly tracking down problems in the hardware and software. If you’re going to program I<sup>2</sup>C devices regularly, you will want to invest in some proper hardware tools to reduce debugging and testing effort. </p>&#13;
<p>This chapter discusses several of those tools, including multimeters, oscilloscopes, logic analyzers, bus monitors, and protocol analyzers. Although such tools cost money, using them will reduce the time you spend debugging code.</p>&#13;
<h2 id="h1-502468c04-0001"><span epub:type="pagebreak" id="Page_68" title="68"/>	4.1	Generic Hardware Testing and Debugging Tools</h2>&#13;
<p class="BodyFirst">If you’re working with hardware devices (generic, not just I<sup>2</sup>C), there are a few tools you should have available in your tool chest:</p>&#13;
<ul>&#13;
<li>A digital multimeter (DMM)</li>&#13;
<li>An oscilloscope</li>&#13;
<li>5-V, 3.3-V, and variable power supplies (0 V to 10 V, at the very least)</li>&#13;
</ul>&#13;
<p>The DMM comes in handy for checking the power supply pins on I<sup>2</sup>C devices, as well as any other DC signals. Most DMMs are worthless for measuring signals on pins whose voltage is changing, such as the SDA and SCL lines, because the DMM will average the voltage over a relatively long time frame, producing an inaccurate picture if the signal is not stable. </p>&#13;
<p>DMMs are also useful for measuring the pullup resistance on the I<sup>2</sup>C lines. In theory, you should be able to read the color codes or SMT resistor codes and figure out the resistance on the bus. However, if multiple pullups are scattered around the system, the resistor might be lower than what you expect. A quick ohm check between Vcc and the SDA or SCL lines could prove handy.</p>&#13;
<p>Some DMMs have a capacitance meter built into them. These are rarely good enough to measure the bus capacitance. Unless you have a <em>really expensive</em> DMM, don’t even bother trying to make such a measurement. The capacitance is usually too low for your average meter. On the other hand, capacitance meters that can handle low capacitances, and that might give you an idea of how bad the bus capacitance is in your system, are available for as little as $100. Fortunately, you can observe the signals with an oscilloscope and determine if there is too much bus capacitance, so a capacitance meter isn’t necessary. It’s not worth buying one if you don’t already have one and can’t justify the purchase for other reasons.</p>&#13;
<p>In theory, an oscilloscope isn’t absolutely necessary for debugging I<sup>2</sup>C signals, but it’s still a useful device for quickly determining whether signals are active and what the voltage levels are on those signals. As just noted, however, one useful reason for having an oscilloscope is that it allows you to monitor the analog condition of the signals appearing on the I<sup>2</sup>C bus. You can easily see if the voltage levels are reasonable—that is, not too high—and whether you’re getting huge voltage drops. An oscilloscope will also let you determine whether the bus capacitance has gotten out of control by showing you the rise times of the SCL and SDA signals. If it’s taking too long for these signals to rise, the devices on the bus might not register those signals as a logic 1. For example, <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a> shows the SCL line in a reasonable system. This image is on a 100-kHz system with a Teensy 3.2 acting as the controller and an Adafruit ADS1115 as the peripheral. It was wired together on a “wireless” breadboard (which are famous for having a high capacitance).</p>&#13;
<span epub:type="pagebreak" id="Page_69" title="69"/><figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c04/f04001.png" width="416"/>&#13;
<figcaption><p><a id="figure4-1">Figure 4-1</a>: Oscilloscope image of the SCL line</p></figcaption>&#13;
</figure>&#13;
<p><a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a> shows a really bad version of the clock signal, with a very slow rise time. In this particular case I attached a 470-pF capacitor across the SCL and Gnd lines to simulate an excessive bus capacitance. As you can see, the signal suffers considerable degradation. By the time the signal has risen enough to register as high, around 2 µsec have passed. This doesn’t leave the device that is putting a bit on the SDA line much time to do its job. These types of issues are most easily spotted using an oscilloscope, so oscilloscopes are handy to have around.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c04/f04002.png" width="416"/>&#13;
<figcaption><p><a id="figure4-2">Figure 4-2</a>: Oscilloscope image of the SCL line with high bus capacitance</p></figcaption>&#13;
</figure>&#13;
<p>A “decent” oscilloscope, one that is good enough for debugging I<sup>2</sup>C signals, will probably cost you around $300 to $600. Of course, a good, brand-name oscilloscope will cost you several thousand dollars. However, such devices are probably overkill for observing I<sup>2</sup>C bus signals. Unless you have other projects requiring the speed and features of such devices—or you really want to impress your friends—you can stick with one of the “advanced hobbyist” devices.</p>&#13;
<p><span epub:type="pagebreak" id="Page_70" title="70"/>Some really cheap devices (sub-$100 to around $200) use a low-end LCD display or connect to your computer. They might work for someone on an extreme budget, but at some point or another you’ll wind up buying a real oscilloscope if you actually use it regularly. As they say: “buy once, cry once.”</p>&#13;
<h2 id="h1-502468c04-0002">	4.2	Logic Analyzers </h2>&#13;
<p class="BodyFirst">Without question, the most important tool you should obtain when working with I<sup>2</sup>C hardware and software is a logic analyzer. Like oscilloscopes, logic analyzers come in all different shapes and sizes, with widely varying feature lists, and ranging in price from less than $30 to thousands of dollars.</p>&#13;
<p>At the low end are two interesting devices that, despite their low price, are actually quite useful: the I<sup>2</sup>C Driver and the Bus Pirate. These two devices are probably more correctly called <em>bus monitors</em> or <em>bus drivers</em> rather than logic analyzers. While they have some of the features of an actual logic analyzer, the software support attached to these (open hardware or open software) projects isn’t quite up to par with that you would find on true logic analyzers.</p>&#13;
<p>In the $300 to $500 range, things start to get more interesting. Total Phase offers several different I<sup>2</sup>C and SPI debugging modules. These devices connect to a PC (Windows, Linux, or macOS), and software running on those machines allows you to capture and manipulate the I<sup>2</sup>C data. (See “For More Information” at the end of this chapter for links to the Total Phase and other debugging modules this section describes.)</p>&#13;
<p>Another interesting device, from Analog Devices (the IC manufacturer, which makes several I<sup>2</sup>C ICs), is the ADALM2000 Active Learning Module. This device is intended for student laboratories and supports a wide range of measurement and control options, I<sup>2</sup>C monitoring among them.</p>&#13;
<p>If you really want to spend some money, the BusPro-I from Corelis is a professional-level I<sup>2</sup>C bus analyzer available for around $1,700. Corelis also has an advanced version (at greater cost, no doubt) that can emulate I<sup>2</sup>C controller and peripheral devices. </p>&#13;
<p>The devices I’ve described up to this point have been tools that were largely built for I<sup>2</sup>C and SPI measurement. For the most part, these devices are simple versions of what is known as a logic analyzer. A <em>logic analyzer</em> is similar to an oscilloscope insofar as it takes a sequence of readings over time and displays the state of those readings (typically on some sort of LCD display, which is either built into the logic analyzer or on a PC to which the logic analyzer connects). There are a couple of major differences between oscilloscopes and logic analyzers, however:</p>&#13;
<ul>&#13;
<li>Logic analyzers are inherently <em>digital</em> devices, whereas oscilloscopes are <em>analog</em> devices.</li>&#13;
<li>Logic analyzers tend to store data and display it after the fact, whereas oscilloscopes tend to be more real time.</li>&#13;
<li><span epub:type="pagebreak" id="Page_71" title="71"/>Logic analyzers often interpret the digital information they record according to some protocol (such as the I<sup>2</sup>C protocol), whereas oscilloscopes tend to display just raw analog data.</li>&#13;
<li>Logic analyzers tend to capture many pieces (bits) of data simultaneously (often 4 to 16 channels), whereas oscilloscopes are generally limited to 1 to 4 channels.</li>&#13;
</ul>&#13;
<p>Not all of these differences are absolute; for example, some storage oscilloscopes can also store data, and certain logic analyzers can display their data and analysis in real time. It is even possible to get a logic analyzer and oscilloscope built into the same box. For example, the Siglent SDS1104X-E is a 100-MHz scope with a 4-channel logic analyzer, and the Owon MSO8102T and Rigol MSO1104Z-S offer 16 channels along with oscilloscope functionality.</p>&#13;
<p>Of course, if you’re spending someone else’s money, you can get some really fancy logic analyzers from Tektronix, Keysight Technologies, NCI Logic Analyzers, National Instruments, and other high-end professional instrumentation companies. However, if you don’t need gigahertz sampling rates, scores of input channels, and a fancy name, or if you’re having to foot the bill for this device from your own pocket, then you’ll probably need to look at something a little lower end.</p>&#13;
<p>In the $100 to $1,000 range, a wide variety of decent logic analyzers that are USB-based and connect to a PC are available; see “For More Information” for details. </p>&#13;
<p>Ultimately, you’ll want to ask the following questions when looking for a logic analyzer: </p>&#13;
<ul>&#13;
<li>Does it support the protocols you’re interested in (I<sup>2</sup>C for the time being, but you’ll probably use it to debug SPI, CAN, and other bus protocols, too)?</li>&#13;
<li>Is the software high quality, and does it run on your development machine?</li>&#13;
<li>Is it well documented?</li>&#13;
<li>Is there ongoing support (for example, software updates)?</li>&#13;
</ul>&#13;
<p>I own a Saleae Logic 8 and can vouch for the fact that it is a high-quality unit with great support. That is not to say that these other units I’ve listed aren’t also excellent (I don’t know, I’ve never used them) or that some other unit not listed here would also work out well for you. However, the Saleae units have been well-received by the engineering community. Perhaps the only complaint is that they are a bit pricey ($400 to $1,000), but that’s the price associated with high-quality hardware and software.</p>&#13;
<p>The remainder of this chapter will concentrate on three of the devices mentioned to this point: the I<sup>2</sup>C Driver, the Bus Pirate, and the Saleae Logic 8.</p>&#13;
<h2 id="h1-502468c04-0003"><span epub:type="pagebreak" id="Page_72" title="72"/>	4.3	The I<sup>2</sup>C Driver</h2>&#13;
<p class="BodyFirst">The I<sup>2</sup>C Driver is a small board with a small-format color LCD display. It has three sets of I<sup>2</sup>C probes coming off the board; I’m not sure why it has more than one set, as the connectors all have the same signals and are wired together. It has a micro-USB port to connect to a Linux, Mac, or Windows PC. </p>&#13;
<p>When the unit comes up, it displays any I<sup>2</sup>C activity on the little LCD display. While this is pretty, it’s not all that useful: I<sup>2</sup>C data transfer may be slow compared to other protocols, but it is still much faster than you can see on a display in real time.</p>&#13;
<p>The real functionality lies in the software that runs on the PC at the other end of the USB cable. Excamera Labs, the outfit that developed the I<sup>2</sup>C Driver, supplies some Python code to support the I<sup>2</sup>C Driver. The software is crude and bare bones but about what you can expect for $30.</p>&#13;
<p>The main Python software provides an interface like a command line (within Python). You perform various activities by manually calling Python functions. For example, if you want to do a bus scan to see what peripheral devices respond on the bus, enter the command <code class="bold">i2c.scan()</code> after the Python <code>&gt;</code> prompt. The <code>i2c.scan()</code> function call displays something like the following:</p>&#13;
<pre><code>-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
48 -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
-- -- -- -- -- -- -- -- &#13;
[72]</code></pre>&#13;
<p class="BodyContinued">where <code>--</code> indicates that a device did not respond at the particular I<sup>2</sup>C address and a hexadecimal numeric value (48 being the only example here that corresponds to a responsive device address). In this case, I have a single Adafruit ADS1115 ADC breakout board configured for address 0x48 installed on the I<sup>2</sup>C bus.</p>&#13;
<p>The I<sup>2</sup>C Driver Python software provides many additional commands you can execute or call from Python code you write. The call <code>help(i2cdriver)</code> displays the Python application programming interface (API). Some useful commands you can execute directly include the following:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><code>setspeed(speed)</code></span>  Argument is 100 or 400 (corresponding to 100 kHz or 400 kHz, respectively)</li>&#13;
<li><span class="RunInHead"><code>setpullups(bitmask)</code></span>  Argument is a 6-bit value specifying pullup values for the three I<sup>2</sup>C connectors (2 bits each, for SCL and SDA) on the I<sup>2</sup>C Driver</li>&#13;
<li><span epub:type="pagebreak" id="Page_73" title="73"/><span class="RunInHead"><code>reset()</code></span>  Sends a bus reset (general call address)</li>&#13;
<li><span class="RunInHead"><code>scan()</code></span>  Scans the bus and displays addresses that respond</li>&#13;
<li><span class="RunInHead"><code>monitor(flag)</code></span>  Turns on monitor mode if <code>flag</code> is true (nonzero); turns it off if <code>flag</code> is false (0)</li>&#13;
<li><span class="RunInHead"><code>getstatus()</code></span>  Displays status information</li>&#13;
</ol>&#13;
<p class="BodyContinued">There are also commands for starting an I<sup>2</sup>C bus transaction, writing data to the bus, reading data from the bus, and sending a stop command. However, those are operations you’d normally do within a Python program.</p>&#13;
<p>The I<sup>2</sup>C Driver software also has a GUI application that brings up the window shown in <a href="#figure4-3" id="figureanchor4-3">Figure 4-3</a>. Click the <b>Monitor mode</b> button to activate monitor mode on the I<sup>2</sup>C Driver’s built-in LCD. Click the button again to turn monitor mode off. While not in monitor mode, select one of the addresses (if there is a device attached at that address) and read or write data to that device using the edit boxes at the bottom of the window.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="755" src="image_fi/502468c04/f04003.png" width="489"/>&#13;
<figcaption><p><a id="figure4-3">Figure 4-3</a>: I<sup>2</sup>C Driver GUI display on a Mac</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_74" title="74"/>While there is activity on the I<sup>2</sup>C bus, click the <b>Capture mode</b> button to redirect I<sup>2</sup>C to a comma-separated values (<em>.csv</em>) file. Here’s a small sample of the data from one such file:</p>&#13;
<pre><code>START,WRITE,72,ACK&#13;
BYTE,WRITE,0,ACK&#13;
STOP,,,&#13;
START,READ,72,ACK&#13;
BYTE,READ,12,ACK&#13;
BYTE,READ,23,NACK&#13;
STOP,,,&#13;
START,WRITE,72,ACK&#13;
BYTE,WRITE,1,ACK&#13;
BYTE,WRITE,193,ACK&#13;
BYTE,WRITE,131,ACK&#13;
STOP,,,&#13;
START,WRITE,72,ACK&#13;
BYTE,WRITE,0,ACK&#13;
STOP,,,&#13;
START,READ,72,ACK&#13;
BYTE,READ,12,ACK&#13;
BYTE,READ,43,NACK&#13;
STOP,,,&#13;
START,WRITE,72,ACK&#13;
BYTE,WRITE,1,ACK&#13;
BYTE,WRITE,193,ACK&#13;
BYTE,WRITE,131,ACK&#13;
STOP,,,</code></pre>&#13;
<p>While the I<sup>2</sup>C Driver was capturing data on the bus, I had a Teensy 3.2 talking to an Adafruit ADS1115 breakout board. Sadly, all the numbers this program displays are in decimal format, rather than the more useful hexadecimal format. The value 72<sub>10</sub> is 0x48—the address of the ADS1115.</p>&#13;
<p>It would be easy enough to write some software to parse each of these lines and display the data in a more appropriate fashion. Unfortunately, timing information is missing from this display. However, it’s open source software, so feel free to go in and modify it if you would like a different output.</p>&#13;
<p>Perhaps the most interesting use of the I<sup>2</sup>C Driver capture mode is for generating test result data. You can run some tests with your I<sup>2</sup>C software for a controller or peripheral, capture the output, and then compare the output against known data or run the output through a filter program that examines it for correctness. This way of generating test results is a useful tool for semi-automating complex test procedures.</p>&#13;
<p>Because the I<sup>2</sup>C Driver also lets you read and write data to an I<sup>2</sup>C peripheral, it’s also useful for checking the operation of a peripheral device you’ve created. You can manually write bytes to the device, read the response from the device, and verify the results are what you expect.</p>&#13;
<p>Although the I<sup>2</sup>C Driver is not the be-all and end-all of I<sup>2</sup>C debugging tools, it’s an interesting tool. Furthermore, it provides a USB interface to the I<sup>2</sup>C bus, which you can program from your PC; see their website for <span epub:type="pagebreak" id="Page_75" title="75"/>details (link provided in “For More Information”). For less than $30, having this device in your toolbox is a no-brainer.</p>&#13;
<h2 id="h1-502468c04-0004">	4.4	The Bus Pirate</h2>&#13;
<p class="BodyFirst">The Bus Pirate is another open-hardware, less-than-$30 device you can use to analyze signals on the I<sup>2</sup>C bus. Whereas the I<sup>2</sup>C Driver is basically a USB-to-I<sup>2</sup>C device with a display bolted to it, the Bus Pirate is actually a small microcontroller (a PIC) that is programmed to read and write various digital I/O pins. Using bit-banging software, it emulates (slowly) the I<sup>2</sup>C protocol. Because it’s open hardware and software, is low cost, and has been around forever, the Bus Pirate has gained a tremendous following for people who want low-cost hardware hacking, analyzing, or testing capabilities.</p>&#13;
<p>The Bus Pirate is different from most of the other devices mentioned in this chapter because it doesn’t really have any PC-related software. The Bus Pirate looks like a serial device (USB-to-serial), so you operate the Bus Pirate using a serial terminal emulation program. You enter commands into the terminal and the Bus Pirate responds appropriately. In operation, this is similar to the command-line mode of the I<sup>2</sup>C Driver.</p>&#13;
<p>Most of the Bus Pirate commands are single character inputs. The most important command for you to know is the <code>?</code> command. This is the help command that displays a list of all the commands to the terminal.</p>&#13;
<p>By default, the Bus Pirate comes up in a special <em>Hi-Z</em> (high-impedance) mode, which basically turns all the outputs off to prevent any damage to the Bus Pirate or to any device connected to the Bus Pirate. You switch to a new mode by pressing <b>M</b>. This will present you with a menu to select the new operation mode (such as I<sup>2</sup>C mode). If you select I<sup>2</sup>C, it will ask you to input a bus frequency.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The Bus Pirate uses a software-only bit-banging implementation of the I<sup>2</sup>C protocol. While it can, in theory, operate as fast as 400 kHz, it probably wouldn’t hurt to operate at a sub-100 kHz speed, especially if the devices you want to monitor don’t require the high speed.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Once the Bus Pirate is running in I<sup>2</sup>C mode, you can write data to the bus, read data from the bus, or monitor data on the bus (similar to the I<sup>2</sup>C Driver). See the Bus Pirate documentation for more details (link provided in “For More Information”).</p>&#13;
<h2 id="h1-502468c04-0005">	4.5	The Saleae Logic Analyzers</h2>&#13;
<p class="BodyFirst">Although the I<sup>2</sup>C Driver and Bus Pirate are useful devices for certain types of I<sup>2</sup>C monitoring, testing, and debugging, they aren’t true logic analyzers. They aren’t great at monitoring and displaying I<sup>2</sup>C information in near real time. Furthermore, although both devices can monitor—and to a certain extent, capture—data on the bus, they’re nearly useless for timing analysis <span epub:type="pagebreak" id="Page_76" title="76"/>like, for example, verifying each bit happens within a certain amount of time. This is where a real logic analyzer excels.</p>&#13;
<p>The Saleae Logic 8, Logic 8 Pro, and Logic 16 Pro devices are fully featured logic analyzers with 8 or 16 channels. The Logic 8 unit operates at 100 million samples per second (Msps), and the Logic 8 Pro or Logic 16 Pro units operate at 500 Msps. Generally, you want your logic analyzer to run five to ten times faster than the fastest signal you need to capture, so the Logic 8 (100 Msps) is easily good for signals in the 10 MHz to 20 MHz range. This certainly covers all I<sup>2</sup>C frequencies.</p>&#13;
<p>The devices themselves provide 8 or 16 probes to connect to your circuitry. For standard I<sup>2</sup>C measurements, you really need to connect only two of these probes, plus a ground wire. Having additional channels is useful because they let you check the status of other pins in your system during an I<sup>2</sup>C transmission. For example, if you’re sending data to a GPIO expander, you can connect some of the probes to input or output pins to see their levels change before, during, and after the I<sup>2</sup>C transmissions.</p>&#13;
<p>The Logic software that runs on a PC looks something like that appearing in <a href="#figure4-4" id="figureanchor4-4">Figure 4-4</a> (macOS version). The left side of the screen defines the signals; you can specify the names appearing here. The middle section of the screen displays the timing and protocol information, and the right side of the screen lets you choose the protocols to decode.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="449" src="image_fi/502468c04/f04004.png" width="841"/>&#13;
<figcaption><p><a id="figure4-4">Figure 4-4</a>: Logic software running on macOS </p></figcaption>&#13;
</figure>&#13;
<p>Clicking the <b>Start</b> button on the left side of the window initiates a capture operation. You can specify how much data to capture; I have my personal copy set up to capture data for two seconds. <a href="#figure4-5" id="figureanchor4-5">Figure 4-5</a> shows a typical data capture. As usual for this chapter, the logic analyzer is capturing the communication between a Teensy 3.2 and an ADS1115.</p>&#13;
<span epub:type="pagebreak" id="Page_77" title="77"/><figure>&#13;
<img alt="" class="keyline" height="366" src="image_fi/502468c04/f04005.png" width="842"/>&#13;
<figcaption><p><a id="figure4-5">Figure 4-5</a>: Logic software timing display</p></figcaption>&#13;
</figure>&#13;
<p>Logic has been programmed to analyze an I<sup>2</sup>C data stream. As such, it displays the address byte and R/W command and each data byte passing on the bus. It’s not clear in this black-and-white image, but the display also marks the start and stop conditions with green and red dots on the data waveforms.</p>&#13;
<p>I’ve shrunk this timing diagram so you can see a complete I<sup>2</sup>C transmission. However, Logic allows you to expand or shrink the timing diagram so you can adjust the level of detail. <a href="#figure4-6" id="figureanchor4-6">Figure 4-6</a> shows the expansion of the first (address) byte transmission from <a href="#figure4-5">Figure 4-5</a>.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="83" src="image_fi/502468c04/f04006.png" width="844"/>&#13;
<figcaption><p><a id="figure4-6">Figure 4-6</a>: A timing expansion in Logic</p></figcaption>&#13;
</figure>&#13;
<p>Another nice feature in Logic is that you can move the cursor over a section of one of the timing signals and get timing information. <a href="#figure4-7" id="figureanchor4-7">Figure 4-7</a> shows what happened when I moved the cursor over one of the SCL clock pulses. Logic responded by displaying the width of the pulse and the frequency (5.12 µsec and 96.9 kHz). I made considerable use of this feature when working on the software-based I<sup>2</sup>C controller and peripheral implementations in the previous chapter. This is how I fine-tuned the delays to get the software I<sup>2</sup>C emulation running close to 100 kHz.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="79" src="image_fi/502468c04/f04007.png" width="844"/>&#13;
<figcaption><p><a id="figure4-7">Figure 4-7</a>: Extracting timing information from Logic</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_78" title="78"/>Logic also lets you set cursors within the timing diagrams so you can measure the time between any two arbitrary points, not just the width of some signal pulse. This comes in handy, for example, when measuring the time of a whole transmission rather than a single bit of a transmission.</p>&#13;
<p>At just under $400, the least expensive Saleae unit isn’t super cheap, but having one of these devices is a sound investment if you’re going to be debugging lots of I<sup>2</sup>C code and hardware.</p>&#13;
<h2 id="h1-502468c04-0006">	4.6	A Final Comment on I<sup>2</sup>C Monitors and Logic Analyzers</h2>&#13;
<p class="BodyFirst">Because this is <em>The Book of I</em><sup><em>2</em></sup><em>C</em>, the discussion of the analyzers in this chapter has centered on their use for debugging and analyzing I<sup>2</sup>C signals. In fact, most of the devices in this chapter support several other protocols as well, including SPI, CANBUS, MIDI, DMX, 1-Wire, and just about any typical protocol you can imagine. (The I<sup>2</sup>C Driver is the exception to this; it supports only I<sup>2</sup>C monitoring.) Therefore, the purchase of a device such as the Saleae Logic 8 is actually a good investment because you can use it for testing and debugging all kinds of hardware, not just I<sup>2</sup>C signals.</p>&#13;
<h2 id="h1-502468c04-0007">	4.7	Chapter Summary</h2>&#13;
<p class="BodyFirst">Writing software to work with I<sup>2</sup>C devices invariably requires testing and debugging said software. Such work is much easier accomplished using hardware testing and debugging tools. This chapter discussed several types of devices you can use for this purpose, including oscilloscopes, logic analyzers, and bus sniffers. It highlighted several commercially available options, including the I<sup>2</sup>C Driver, the Bus Pirate, and the Salae Logic Analyer. It also mentioned various combination oscilloscope and logic analyzer options and concluded by noting that these devices are useful for debugging other protocols, not just I<sup>2</sup>C devices, which makes them more universally applicable.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<p class="BoxBodyFirst">For more information on logic analyzers, Google is your friend. Just search for “logic analyzers” or “USB-based” logic analyzers, and you should be set. You can also visit the websites of the products mentioned in this chapter:</p>&#13;
<ol class="none">&#13;
<li>Tech Tools DigiView: <a class="LinkURL" href="https://www.tech-tools.com/logic-analyzer.htm">https://www.tech-tools.com/logic-analyzer.htm</a></li>&#13;
<li>Digital Discovery’s Digilent: <a class="LinkURL" href="https://store.digilentinc.com/digital-discovery-portable-usb-logic-analyzer-and-digital-pattern-generator">https://store.digilentinc.com/digital-discovery-portable-usb-logic-analyzer-and-digital-pattern-generator</a></li>&#13;
<li>Intronix LogicPort: <a class="LinkURL" href="https://www.pctestinstruments.com">https://www.pctestinstruments.com</a></li>&#13;
<li><span epub:type="pagebreak" id="Page_79" title="79"/>Perytech Logic Analyzer: <a class="LinkURL" href="https://www.perytech.com/Logic-Analyzer.htm">https://www.perytech.com/Logic-Analyzer.htm</a></li>&#13;
<li>BitScope: <a class="LinkURL" href="https://bitscope.com">https://bitscope.com</a></li>&#13;
<li>DSLogic U3Pro16: <a class="LinkURL" href="https://www.dreamsourcelab.com/shop/logic-analyzer/dslogic-u3pro16">https://www.dreamsourcelab.com/shop/logic-analyzer/dslogic-u3pro16</a></li>&#13;
<li>Saleae Logic 8, Logic 8 Pro, and Logic 16 Pro: <a class="LinkURL" href="https://www.saleae.com">https://www.saleae.com</a></li>&#13;
<li>Bus Pirate: <a class="LinkURL" href="http://dangerousprototypes.com/docs/Bus_Pirate">http://dangerousprototypes.com/docs/Bus_Pirate</a></li>&#13;
<li>Total Phase debugging modules: <a class="LinkURL" href="https://www.totalphase.com/solutions/apps/i2c-guide">https://www.totalphase.com/solutions/apps/i2c-guide</a></li>&#13;
<li>Analog Devices ADALM2000 active learning module: <a class="LinkURL" href="https://wiki.analog.com/university/tools/m2k">https://wiki.analog.com/university/tools/m2k</a></li>&#13;
<li>BusPro-I from Corelis: <a class="LinkURL" href="https://www.corelis.com/products/serial-bus-analyzers/i2c-bus-analyzer-exerciser-products/buspro-i2c-bus-analyzer">https://www.corelis.com/products/serial-bus-analyzers/i2c-bus-analyzer-exerciser-products/buspro-i2c-bus-analyzer</a></li>&#13;
<li>I<sup>2</sup>C Driver: <a class="LinkURL" href="https://i2cdriver.com">https://i2cdriver.com</a></li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>