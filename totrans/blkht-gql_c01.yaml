- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Primer on GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll provide an overview of GraphQL, including why it exists
    and which of its features make it interesting to many of today’s technology giants.
    You’ll also explore how it differs from RESTful APIs and send your very first
    GraphQL query.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*GraphQL* is an open source data query and manipulation language for application
    programming interfaces (APIs). APIs allow two applications to exchange information
    in the form of requests and responses by following a set of rules that define
    the way the applications should connect and communicate. Typically, a web browser,
    like Google Chrome or Mozilla Firefox, acts as the API client, or *consumer.*
    This consumer interacts with an application server, via the application’s API,
    to read or alter certain information on the server. API consumers aren’t always
    browsers; machines, such as other servers on the network, can be GraphQL API consumers
    too.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other API formats, GraphQL allows an API consumer to request specific
    data from an application’s server without also receiving unnecessary information.
    Contrast this approach with traditional REST API architectures, which provide
    a fixed data structure and then rely on the clients to filter out any unnecessary
    information they don’t need. We’ll compare the REST and GraphQL API response structures
    in “GraphQL APIs vs. REST APIs” on page 9 to illustrate the differences between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, GraphQL’s design provides an advantage. Because
    GraphQL doesn’t return data that the client doesn’t explicitly ask for, its use
    reduces opportunities for information disclosure issues. Returning more data than
    a client needs could lead to the unintentional exposure of sensitive data, such
    as personally identifiable information (PII), which could cause many other problems,
    especially for companies operating under heavy regulatory rules. However, as you’ll
    soon see, GraphQL also has security weaknesses that we, as hackers, can exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Origins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Facebook developed GraphQL in 2012 and used it for a few years in its production
    environments before releasing it as open source software in 2015\. That year,
    Facebook also developed and released the GraphQL specification and a reference
    implementation named *GraphQL.js* ([https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)),
    built using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is now maintained by the GraphQL Foundation ([https://graphql.org/foundation/](https://graphql.org/foundation/)),
    an organization founded by global technology companies. The foundation funds mentorship
    and project grants for GraphQL maintainers, manages policies of the GraphQL trademark,
    provides legal support for projects, and supports community-related infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just about any application and device can use GraphQL. Companies may consider
    using it if their clients often request a lot of information at the same time,
    which would otherwise require making many REST API calls. Using GraphQL could
    reduce bandwidth usage and improve client performance.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, imagine a website dashboard that consolidates information about
    the weather from multiple third-party weather websites and that is consumed by
    mobile clients on slow data networks. If the dashboard had to make a bunch of
    calls to the various weather networks and filter through the data, this wouldn’t
    be an optimized process. GraphQL allows the fetching of complex data structures
    in a single request, significantly reducing the required number of client and
    server round trips. You’ll learn more about this bandwidth-optimization design
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Today, many large-scale companies, such as Facebook, Atlassian, GitHub, and
    GitLab, use GraphQL, serving hundreds of millions of customers on various platforms,
    such as mobile phones, desktop computers, and even smart TVs.
  prefs: []
  type: TYPE_NORMAL
- en: Specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2015, Facebook publicly released the GraphQL specification document, which
    defined rules, design principles, and standard practices to which all implementations
    of GraphQL must adhere. This specification is a reference for implementing GraphQL
    for multiple languages, similar to request for comments (RFC) documents. You can
    think of it as a blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we, as hackers, can use it to better understand how GraphQL is meant
    to be implemented and verify that the target application we’re hacking conforms
    to these predefined rules. Because implementations often deviate from the standard
    for various reasons, chances increase for us to find bugs in them, some of which
    may have security implications.
  prefs: []
  type: TYPE_NORMAL
- en: How Do Communications Work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical GraphQL implementation incorporates a few components you should become
    familiar with if you hope to search it for security flaws. [Figure 1-1](#figure1-1)
    describes these.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: Core GraphQL components'
  prefs: []
  type: TYPE_NORMAL
- en: When a client wants to communicate with a GraphQL server (for example, to read
    a list of usernames and emails), that client will use the HyperText Transfer Protocol
    (HTTP) POST method to send the server a GraphQL query. You might already be noticing
    that this doesn’t follow standard HTTP method conventions, as data reads are more
    often than not implemented with the HTTP GET method; you will learn more about
    this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The server, in turn, will process the query by using a query parser. *Query
    parsers* read and validate that the query is properly formatted and that the server
    can support it. This validation involves checking the query against the application’s
    GraphQL schema. If the query is deemed valid, it will be handled by resolver functions,
    which are responsible for generating the response to the client’s query. Talk
    about many moving pieces! Let’s break down these core components to better explain
    how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: The Schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GraphQL *schema* represents the type of data a client can query for. Schemas
    are defined using *schema definition language (SDL)*. [Listing 1-1](#listing1-1)
    shows its syntax for defining two object types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-1: Schema definition language'
  prefs: []
  type: TYPE_NORMAL
- en: '*Object* types are the most basic component of a GraphQL schema; they represent
    a piece of data you can fetch from the service running GraphQL. Object types have
    *fields*, which are object-specific attributes that have a value. In [Listing
    1-1](#listing1-1), we define an object type called `User` and another type called
    `Location`. The `User` type has two fields, named `username` and `email`, both
    of which are of the `String` scalar type. The `Location` type also has two fields,
    named `latitude` and `longitude`, which are of `Int` (integer) scalar type.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, the objects and fields in our example schema aren’t connected to each
    other. However, GraphQL allows us to form links between objects in various ways.
    To visualize how this works, we can represent our schema as a graph consisting
    of nodes and edges. In our example, the `User` and `Location` object types are
    *nodes*, as shown in [Figure 1-2](#figure1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: Graph nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '*Edges* are a way to create a link between multiple nodes. For example, an
    object could have a field that references another object. Let’s say you have a
    list of users, as well as a list of physical locations from which they last logged
    in, and you want to return a user’s location whenever a client queries for that
    user. [Listing 1-2](#listing1-2) shows how to do this by using edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-2: The linking of nodes'
  prefs: []
  type: TYPE_NORMAL
- en: We added an additional `location` field to the `User` object type ❶ and linked
    it to the `Location` object type ❷. In practice, this means that you can request
    a `User` object and get its associated location data. However, you won’t be able
    to query for a username by using the `Location` object type, because we haven’t
    defined that edge in our schema. [Figure 1-3](#figure1-3) illustrates how the
    two nodes now have a one-way link relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: One-way link relationship between nodes'
  prefs: []
  type: TYPE_NORMAL
- en: Edges are not limited to one-way link relationships. In fact, you can create
    a two-way link relationship between the same objects, as shown in [Figure 1-4](#figure1-4).
    Legitimate use cases exist for connecting two nodes in this way. In the `User`
    and `Location` example, imagine that clients of our API need the ability to fetch
    usernames and see their locations as part of the returned data. Also, let’s say
    that clients should be able to fetch specific locations and see which users have
    logged in at each location. Two-way link relationships allow for this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: Two-way link relationship between nodes'
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, two-way link relationships often lead to unwanted
    denial-of-service (DoS) conditions, which could completely take down a system.
    When two-way link relationships exist, API developers should introduce security
    controls to mitigate these vulnerabilities, which we’ll explain in more detail
    in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once an API’s schema is defined, clients can fetch information from it by using
    specially crafted queries written in the declarative GraphQL query language. In
    GraphQL, all queries begin with a definition of the operation’s *root type*, which
    specifies one of the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Queries* are used for read-only operations. These operations don’t involve
    data manipulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mutations* are used for data manipulation, such as data writes. These operations
    involve data modifications, data additions, data deletions, and so on. Mutations
    can be used to write and read data at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Subscriptions* are used for real-time communications between clients and GraphQL
    servers. They allow a GraphQL server to push data to the client when different
    events occur. Subscriptions typically are used in conjunction with transport protocols
    such as WebSocket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three operations are the starting point for each GraphQL query we compose.
    For example, a query operation uses the `query` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A mutation operation type uses the `mutation` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, a subscription operation type uses the `subscription` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before a client can perform one of these operations, the developer must have
    defined the operation in the schema and specified the fields that clients can
    use. For example, [Listing 1-3](#listing1-3) defines the `Query` type and establishes
    the path that allows clients to fetch one of the object types we defined earlier,
    `User`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-3: The full schema, with an entry point to querying the `User` type'
  prefs: []
  type: TYPE_NORMAL
- en: By querying the `users` field in the `Query` type, clients can access the `User`
    object type we defined. The square brackets `[]` surrounding the `User` object
    type indicate that this query will return an array of `User` objects. We’ll discuss
    this syntax in Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-4](#listing1-4) is an example query that a client might send to
    a GraphQL server implementing the schema in [Listing 1-3](#listing1-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-4: A GraphQL query'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, GraphQL queries are pretty easy to read: all this query does
    is get the username and email of all users of the application. We define the query
    by using the `query` root operation. Then we request `users` as the query’s top-level
    field, specifying the `username` and `email` fields we want. Because this query
    only reads information and doesn’t change any data, we perform a query operation
    rather than a mutation.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that blank spaces are used to separate components like names and values.
    The number of spaces used doesn’t matter; whether there’s a single space or multiple
    spaces, the query will remain the same and return consistent results.
  prefs: []
  type: TYPE_NORMAL
- en: The Query Parser and Resolver Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, what happens when a GraphQL server receives a query? Well, it makes use
    of a *query parser* to read and extract the information it needs to execute the
    incoming query. The query parser is responsible for turning the query string into
    an *abstract syntax tree (AST)* and validating it against the schema to ensure
    that only valid queries are accepted. An AST is a hierarchical object that represents
    the query. It includes fields, arguments, and other information and can be easily
    traversed by different language parsers.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is *strongly typed*, which means that when clients use the wrong data
    types, the server returns an error. For example, if some data is defined as an
    `Int`, using a `String` instead would yield errors. This allows development teams
    to rely on the API to perform the type validation. We’ll discuss these types in
    more detail in Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a response to the client’s query containing the requested data,
    the server uses *resolver functions*, also simply called *resolvers*. Resolvers
    are responsible for populating the response with data for each field specified
    in the client query. To do so, resolvers may implement code logic to take on tasks
    such as querying relational databases, cache databases, or other servers on the
    network. Every field has a corresponding resolver function responsible for returning
    the field’s response.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to fulfill the query we showed in [Listing 1-4](#listing1-4), a
    resolver function may connect to an external database such as MySQL, and query
    its users table to get a list of the available username and email entries. Because
    resolver functions are the GraphQL component responsible for query resolution,
    this is also where vulnerabilities can exist. If the functions are written poorly,
    they may contain bugs, which may lead to security flaws.
  prefs: []
  type: TYPE_NORMAL
- en: Resolvers are not limited to reading from a database. They can read data from
    the local filesystem or make HTTP requests to additional systems over REST APIs.
    In fact, GraphQL APIs commonly make REST calls behind the scenes, especially when
    companies are gradually transitioning from using REST to GraphQL. Sometimes GraphQL
    is used as a consolidator API layer to multiple backend REST services that remain
    invisible to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you can think of GraphQL as a query layer that sits between the
    client (such as a browser running on a user’s mobile phone or laptop) and the
    application logic. Clients seeking to interact with a GraphQL API could use a
    variety of available open source GraphQL client libraries, such as Apollo Client
    ([https://www.apollographql.com/docs/react](https://www.apollographql.com/docs/react)),
    currently maintained by Apollo for TypeScript, or Relay ([https://relay.dev](https://relay.dev)),
    currently maintained by Facebook for JavaScript. Using dedicated GraphQL clients
    isn’t required; you can also query GraphQL APIs using command line HTTP clients
    such as cURL. In Chapter 3, we’ll cover how GraphQL works at the lower levels.
  prefs: []
  type: TYPE_NORMAL
- en: What Problems Does GraphQL Solve?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL improves the speed of client-server interactions by saving the client
    from having to make multiple requests in order to retrieve the complete set of
    data it needs from an application. Because GraphQL allows clients to define a
    precise query structure, it avoids costly performance issues such as *over-fetching*
    (returning data to the client that isn’t used) or *under-fetching* (returning
    too little data, forcing the client to make a second request). You’ll learn more
    about these differences and why they matter for performance in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL has additional useful features, such as schema stitching and schema
    federation. *Schema stitching* is a way to create a single GraphQL schema from
    multiple underlying GraphQL services, allowing GraphQL to be used as a unified
    gateway. Essentially, it packages (stitches) multiple schemas into one big schema,
    creating a single integration point for clients. Because multiple microservices
    can define their own GraphQL schemas and have their own GraphQL endpoints, allowing
    a single GraphQL API gateway to consolidate many schemas into one can make it
    easier for clients to integrate with an application.
  prefs: []
  type: TYPE_NORMAL
- en: '*Schema federation* is similar to schema stitching, except it doesn’t require
    you to manually stitch schemas together. Instead, schema federation lets you tell
    the GraphQL API gateway where to look for additional schemas. The gateway then
    does the stitching automatically. Federation is a lower-maintenance approach for
    consolidating multiple APIs into a single gateway.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex API applications, such as ones that require schema federation or schema
    stitching, may introduce security vulnerabilities, potentially allowing hackers
    to access data to which they shouldn’t otherwise have access. In general, the
    more complex an application is, the higher the chance that its internal complexities
    could lead to vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL APIs vs. REST APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we discussed the challenges of traditional APIs that
    GraphQL attempts to solve. For example, REST APIs often provide more data than
    the client needs (over-fetching) or too little data (under-fetching), forcing
    the client to make additional API requests. In this section, we’ll walk through
    an example to demonstrate how an application fronted by a REST API compares to
    one that uses GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Table 1-1](#table1-1), a database table with information about an
    application’s user base. A simple web application might display this information
    as part of an admin panel that lets the systems administrator list all available
    accounts and get their state. We’ll call this the Users Administration page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-1: Users Database Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **User ID** | **Username** | **Email** | **First name** | **Last name** |
    **State** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | dsmith | *david@example.com* | David | Smith | Disabled |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | clarry | *chris@example.com* | Chris | Larry | Enabled |'
  prefs: []
  type: TYPE_TB
- en: In the following sections, we’ll describe the API requests a client would have
    to make to retrieve user data if the application were using a REST API, and how
    it might do the same in an application using GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: The REST Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In applications that use REST APIs, we define specific *endpoints*, or *routes*,
    at which clients can perform actions such as reading or writing data using specific
    HTTP methods (such as GET or POST). [Table 1-2](#table1-2) defines two REST API
    endpoints for two purposes: one for getting a list of users and another to get
    information about a user’s login history.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-2: REST API Definitions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP method** | **API endpoint** | **Endpoint description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GET | */rest/v1/users* | Returns a list of all available users and their
    information |'
  prefs: []
  type: TYPE_TB
- en: '| GET | */rest/v1/history/<user_id>* | Returns a list of the login timestamps
    for a given user |'
  prefs: []
  type: TYPE_TB
- en: When a systems administrator wants to view the Users Administration page, their
    web client, such as a web browser, will need to obtain information about all available
    users through the web application’s API. To retrieve this data using the API endpoints
    in [Table 1-2](#table1-2), the web browser would need to send a GET request to
    */rest/v1/users.* [Listing 1-5](#listing1-5) shows this request and its response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-5: GET request to */rest/v1/users* that lists all system users'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this request returns the list of all users in JavaScript Object
    Notation (JSON) format, along with their emails, names, IDs, and account states.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the system administrator wants to retrieve only certain information
    about users, such as their email addresses, without returning any other information?
    Using the API definitions in [Table 1-2](#table1-2), this wouldn’t be possible.
    Instead, the response in [Listing 1-5](#listing1-5) would need to be processed
    in its entirety, and the `email` field would need to be extracted out of the response.
    This is an example of the over-fetching problem in REST APIs: the client receives
    more data than it needs and then has to filter it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that you are the systems administrator and have been tasked with
    identifying any intrusion attempts on the network. You plan to write a script
    that will run every night and check for suspicious behavior. For example, it should
    flag users who have logged in after normal work hours, which are from 9 AM to
    5 PM. To achieve this goal, the script will need to make an API request using
    the GET method to the */rest/v1/history/<user_id>* endpoint. However, if you look
    closely at the endpoint structure, you’ll notice that it requires the client to
    supply a specific user ID. How will the script know the ID of the application’s
    users? The short answer: it won’t, unless it first fetches all of the available
    user IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this means that in order for the script to successfully run, read
    a user’s last login timestamp, and identify a possible intrusion, it first needs
    to list all user accounts on the system using the API endpoint */rest/v1/users*.
    This should return every user’s username, email, first name, last name, state,
    and user ID.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it needs to make a second API request to */rest/v1/history/1*, where *1*
    is the user ID obtained from the first request, as shown in [Listing 1-6](#listing1-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-6: Response from */rest/v1/history/1*'
  prefs: []
  type: TYPE_NORMAL
- en: To get the entire list of all historical user logins, the client would need
    to make additional requests until it had fetched all user IDs. If we have 1,000
    users, that will require 1,000 requests. Sounds like an inefficient process, doesn’t
    it? This is an example of the under-fetching problem that REST APIs tend to have.
    RESTful APIs can be designed to return specific information, but the complexity
    required to allow for such querying flexibility across a variety of REST endpoints
    will make it challenging to maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: While making two requests to retrieve the login info of a single user may not
    seem like a big deal at first glance, imagine that the application serves millions
    of clients simultaneously. At this scale, every request counts; any additional
    cross-network calls will result in increased latency on the server and impact
    the client’s experience. This will decrease the overall speed and efficiency of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to see these requests in action, you can experiment with this
    example’s APIs by pointing your web browser to the live lab located at [http://lab.blackhatgraphql.com/start](http://lab.blackhatgraphql.com/start).
    There, click the two links to navigate to the REST from within your web browser,
    as shown in [Figure 1-5](#figure1-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: A live REST API example'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve demonstrated the under-fetching and over-fetching problems of REST APIs.
    How will GraphQL solve these? Let’s explore the exact same scenario in the GraphQL
    world.
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that our Users Administration web application has scrapped its REST
    API in favor of GraphQL, and that we’ve established a schema defining a data-graph
    edge between the users and history nodes. Now, when the systems administrator
    views the Users Administration page, their web browser will use the application’s
    GraphQL API endpoint to return all the data needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser might use the query in [Listing 1-7](#listing1-7) to retrieve information
    such as user IDs, emails, first names, last names, historical information such
    as the timestamp of their last login, and account states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-7: GraphQL query to fetch information about the users'
  prefs: []
  type: TYPE_NORMAL
- en: A response to such a query can be seen in [Listing 1-8](#listing1-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-8: GraphQL query response containing all available users and their
    information'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the response contains a `data` JSON field, which includes the `users`
    field, and that the `users` field is an array containing all users on the system.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, there aren’t any visible differences between the REST and GraphQL
    APIs. So, how does GraphQL address the over-fetching and under-fetching problems?
    Well, if we wanted to specifically request a certain field, such as the users’
    email addresses, we could omit any irrelevant fields and include only the `email`
    field, as shown in [Listing 1-9](#listing1-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-9: GraphQL query that returns only email addresses'
  prefs: []
  type: TYPE_NORMAL
- en: By explicitly including the fields we’re interested in returning, we limit the
    response to relevant data, as shown in [Listing 1-10](#listing1-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-10: GraphQL server response containing only email addresses'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the response contains only the email addresses, as instructed
    by the query. If 100 email addresses were stored in the backend database, all
    of them would have been returned with such a query.
  prefs: []
  type: TYPE_NORMAL
- en: Now, remember when, earlier, we wanted to return users’ last login timestamps
    for our intrusion detection task? With GraphQL, we can do so using a query similar
    to the one shown in [Listing 1-11](#listing1-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-11: GraphQL query that returns the timestamp of the last logins made
    by users, along with their emails'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, we receive only the relevant fields, as shown in [Listing 1-12](#listing1-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-12: GraphQL response containing only the `email` and `last_login_timestamp`
    fields'
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL’s powerful declarative language, we can craft very selective queries
    that fetch only the necessary information. In later chapters, you’ll learn how
    to leverage this query syntax to attack GraphQL servers.
  prefs: []
  type: TYPE_NORMAL
- en: Other Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section lists other significant differences between REST APIs and GraphQL
    APIs that security professionals should be aware of. These include the specific
    HTTP methods an application should use, which HTTP status codes to return in specific
    error scenarios, and more. Some of these differences might seem odd to anyone
    who has performed penetration tests of REST applications, as in certain cases
    GraphQL strays from the guidance of the HTTP RFC.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Request Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier in this chapter, we mentioned that GraphQL communications typically
    happen over the POST method, whether for writing data, deleting data, or simply
    reading data. By contrast, REST APIs use HTTP methods to indicate the client’s
    intention. For example, they would use GET for reading data and POST for creating
    or updating data.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that GraphQL can, in fact, accept queries over the GET
    method. Even though GraphQL applications mostly use POST, you should test a GraphQL
    application for the support of the GET method, as it can open up opportunities
    to identify and abuse vulnerabilities such as cross-site request forgery (CSRF).
    We’ll discuss CSRF in more detail in Chapter 9.
  prefs: []
  type: TYPE_NORMAL
- en: API Endpoint Paths
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In GraphQL, the endpoint exposed to the client is usually located at */graphql*.
    Applications may also choose to offer multiple versions of an API, in which case
    you may see endpoints such as */v1/graphql* or */v2/graphql*.
  prefs: []
  type: TYPE_NORMAL
- en: No matter which endpoint the API uses, it will remain the same across all client
    requests. This differs from REST APIs, which expose each resource at a separate
    endpoint. Every REST endpoint could have its own set of controls and supported
    methods. For instance, a */history* endpoint might allow only GET requests so
    that clients can fetch historical records, while a */users* endpoint might support
    both GET- and POST-based requests, to allow clients to fetch the list of users
    as well as add new user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL instead defines client intentions in the query payload, through operations
    such as queries and mutations. The endpoint remains consistent no matter the resource
    accessed or action performed.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Status Codes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HTTP status codes such as *200 OK*, *404 Not Found*, and *401 Unauthorized*
    play a key role in REST APIs, because they signal to the client the outcome of
    their request. For example, when a user attempts to log in to a web page with
    an incorrect username or password, an application with a REST API may return the
    status code of *401 Unauthorized* to signal to the client that they aren’t authorized.
  prefs: []
  type: TYPE_NORMAL
- en: In GraphQL APIs, the status code returned by the server will almost exclusively
    be *200 OK*, even if the action failed because of authorization errors or because
    the requested resource doesn’t exist on the server. GraphQL indicates errors to
    the client by returning an `errors` field as part of the response payload, as
    shown in [Listing 1-13](#listing1-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-13: The GraphQL response error format'
  prefs: []
  type: TYPE_NORMAL
- en: You might see a status code other than *200 OK* if the server fails to serve
    the request completely because of a critical server-side error, such as a database
    being down or another backend failure. In these cases, GraphQL may return the
    expected *500 Server Error* status code.
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Running GraphQL-Tailored Security Tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These differences in HTTP status codes, request methods, and API endpoint paths
    necessitate a significant shift in our approach to security analysis, intrusion
    detection, and penetration testing. During traditional penetration tests, we often
    rely on hacking tools to handle the heavy lifting when it comes to vulnerability
    assessment and application scanning. When we test GraphQL applications, these
    security tools may report false-positive findings if they don’t have GraphQL support
    built in.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional web application scanners are tailored to the RFC 2616 HTTP standard
    and assume that applications conform with this RFC when it comes to the status
    codes they return. For example, a web application vulnerability scanner that conducts
    a brute-force attack may report that a successful exploitation occurred if it
    ever receives a *200 OK* status code from the target server. However, you shouldn’t
    interpret a *200 OK* status code in the same way when it is returned from GraphQL-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to security analysis, security operators face a challenge when
    they attempt to interpret the access logs of a GraphQL application, especially
    if they are used to interacting with REST API applications. Consider the HTTP
    access log sample shown in [Listing 1-14](#listing1-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-14: Access log patterns for a GraphQL application'
  prefs: []
  type: TYPE_NORMAL
- en: If a security operator is analyzing this log data for suspicious patterns, it
    won’t be particularly insightful if the logs were generated by a GraphQL application.
    Finding useful information will require implementing specialized tooling and logging
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Very often, developers deploy newer technology, such as GraphQL, without customizations
    or prior research. As hackers, this gives us some leverage. The fact that GraphQL
    doesn’t comply with standard HTTP status code principles may allow us to evade
    security controls such as web application firewalls (WAFs), as well as go under
    the radar when security operators are looking for anomalous patterns in HTTP error
    codes, especially if those security operators aren’t aware that GraphQL behaves
    differently than REST.
  prefs: []
  type: TYPE_NORMAL
- en: Your First Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve learned about APIs and the differences between GraphQL and REST,
    it’s time for you to experiment with a real GraphQL application. In this exercise,
    you’ll use common tools to build your first query and receive a successful response
    from a GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise doesn’t require you to install any special tools. GraphQL implementations
    often provide a graphical user interface (GUI) for running queries in the form
    of an integrated development environment (IDE). A few such tools are out there,
    including *GraphiQL Explorer* (pronounced *graphical*; note the lowercase *i*)
    and *GraphQL Playground*, which are available as either an additional package
    to install or as part of the base installation, depending on the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use GraphiQL Explorer, which allows a user to query GraphQL with auto-completion
    features, read autogenerated schema documentation, identify syntax errors in queries
    through error highlighting, see historical queries, and use query variables. These
    features make it very easy for first-time GraphQL users to interact with an application.
    As hackers, we can also benefit from access to such tools. You’ll learn more about
    how we can find and abuse these types of interfaces in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and experiment with writing GraphQL queries. Open any browser
    and navigate to [http://lab.blackhatgraphql.com/graphiql](http://lab.blackhatgraphql.com/graphiql).
    You will be greeted with a screen similar to the one shown in [Figure 1-6](#figure1-6).
  prefs: []
  type: TYPE_NORMAL
- en: In the left pane, you can enter queries. The resulting output will display in
    the right pane. Try entering the simple query shown in [Listing 1-15](#listing1-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-15: GraphQL query that displays user information'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: The GraphiQL Explorer panel'
  prefs: []
  type: TYPE_NORMAL
- en: To send the query to the server, click the play button located at the top-left
    corner. You should see the result shown in [Figure 1-7](#figure1-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: GraphQL query result'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed a small drop-down menu appear as soon as you start typing
    a query. This menu provides auto-completion options, as shown in [Figure 1-8](#figure1-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-8: GraphiQL Explorer auto-completion suggestions'
  prefs: []
  type: TYPE_NORMAL
- en: The auto-completion feature is useful, especially when you need to interact
    with GraphQL applications that have complex schemas. Without insight into the
    schema, it would be fairly challenging to guess what a valid query might look
    like. The auto-completion feature is available when GraphiQL Explorer is able
    to query the GraphQL server by using the introspection query, GraphQL’s self-documenting
    API feature. You will learn more about introspection in Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: To view additional information about the application’s GraphQL schema, click
    the **Docs** tab located in the right pane. This will open up autogenerated documentation,
    as shown in [Figure 1-9](#figure1-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-9: GraphiQL Explorer autogenerated schema documentation'
  prefs: []
  type: TYPE_NORMAL
- en: GraphiQL Explorer also gives you a view of all previously sent queries, as shown
    in [Figure 1-10](#figure1-10). You can click a query to replay it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c01/f01010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-10: Historical queries in GraphiQL Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL servers are unauthenticated by default, which allows graphical interfaces
    such as GraphiQL Explorer and GraphQL Playground to interact with them freely.
    Typically, protecting these graphical interfaces doesn’t make a ton of sense,
    because they are simple frontends to the API, and we could still use other clients,
    such as cURL, to perform direct API calls to the server. The API server itself
    should implement protections to avoid unauthorized API queries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you received an introduction to GraphQL. We covered what GraphQL
    is and the problems it attempts to solve. We also walked through examples that
    demonstrate the fundamental differences between REST and GraphQL APIs, and why
    it’s important to understand these differences in the context of security. Additionally,
    you had your first hands-on experience of querying a GraphQL API by using the
    GraphiQL Explorer tool.
  prefs: []
  type: TYPE_NORMAL
