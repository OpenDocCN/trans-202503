- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: A Primer on GraphQL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 入门
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’ll provide an overview of GraphQL, including why it exists
    and which of its features make it interesting to many of today’s technology giants.
    You’ll also explore how it differs from RESTful APIs and send your very first
    GraphQL query.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述 GraphQL，包括它的存在意义以及哪些特性使得它对许多当今的科技巨头具有吸引力。你还将了解它与 RESTful API 的区别，并发送你的第一个
    GraphQL 查询。
- en: The Basics
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础
- en: '*GraphQL* is an open source data query and manipulation language for application
    programming interfaces (APIs). APIs allow two applications to exchange information
    in the form of requests and responses by following a set of rules that define
    the way the applications should connect and communicate. Typically, a web browser,
    like Google Chrome or Mozilla Firefox, acts as the API client, or *consumer.*
    This consumer interacts with an application server, via the application’s API,
    to read or alter certain information on the server. API consumers aren’t always
    browsers; machines, such as other servers on the network, can be GraphQL API consumers
    too.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*GraphQL* 是一种开源数据查询和操作语言，用于应用程序编程接口（API）。API 允许两个应用程序通过遵循一套规则进行信息交换，请求和响应数据，定义了应用程序如何连接和通信。通常，像
    Google Chrome 或 Mozilla Firefox 这样的网页浏览器充当 API 客户端，或称为 *消费者*。这个消费者通过应用程序的 API
    与应用服务器进行交互，读取或修改服务器上的特定信息。API 消费者不一定总是浏览器；例如，网络上的其他服务器等机器，也可以是 GraphQL API 的消费者。'
- en: Unlike other API formats, GraphQL allows an API consumer to request specific
    data from an application’s server without also receiving unnecessary information.
    Contrast this approach with traditional REST API architectures, which provide
    a fixed data structure and then rely on the clients to filter out any unnecessary
    information they don’t need. We’ll compare the REST and GraphQL API response structures
    in “GraphQL APIs vs. REST APIs” on page 9 to illustrate the differences between
    the two.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 API 格式不同，GraphQL 允许 API 使用者从应用服务器请求特定的数据，而无需接收不必要的信息。将这种方法与传统的 REST API
    架构进行对比，后者提供固定的数据结构，并依赖客户端过滤掉它们不需要的任何不必要信息。我们将在第 9 页的“GraphQL APIs 与 REST APIs”中比较
    REST 和 GraphQL 的 API 响应结构，以说明两者之间的区别。
- en: From a security perspective, GraphQL’s design provides an advantage. Because
    GraphQL doesn’t return data that the client doesn’t explicitly ask for, its use
    reduces opportunities for information disclosure issues. Returning more data than
    a client needs could lead to the unintentional exposure of sensitive data, such
    as personally identifiable information (PII), which could cause many other problems,
    especially for companies operating under heavy regulatory rules. However, as you’ll
    soon see, GraphQL also has security weaknesses that we, as hackers, can exploit.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，GraphQL 的设计提供了优势。因为 GraphQL 不会返回客户端未明确请求的数据，它的使用减少了信息泄露问题的发生。返回比客户端所需更多的数据可能会导致敏感数据的无意暴露，例如个人身份信息（PII），这可能会引发许多其他问题，尤其是对于那些在严格监管规则下运营的公司。然而，正如你很快会看到的，GraphQL
    也存在安全漏洞，我们作为黑客，可以加以利用。
- en: Origins
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 起源
- en: Facebook developed GraphQL in 2012 and used it for a few years in its production
    environments before releasing it as open source software in 2015\. That year,
    Facebook also developed and released the GraphQL specification and a reference
    implementation named *GraphQL.js* ([https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)),
    built using JavaScript.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 于 2012 年开发了 GraphQL，并在其生产环境中使用了几年，直到 2015 年才将其作为开源软件发布。那一年，Facebook
    还开发并发布了 GraphQL 规范以及一个名为 *GraphQL.js* 的参考实现（[https://github.com/graphql/graphql-js](https://github.com/graphql/graphql-js)），该实现是使用
    JavaScript 构建的。
- en: GraphQL is now maintained by the GraphQL Foundation ([https://graphql.org/foundation/](https://graphql.org/foundation/)),
    an organization founded by global technology companies. The foundation funds mentorship
    and project grants for GraphQL maintainers, manages policies of the GraphQL trademark,
    provides legal support for projects, and supports community-related infrastructure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 现在由 GraphQL 基金会（[https://graphql.org/foundation/](https://graphql.org/foundation/)）维护，该基金会由全球技术公司成立。基金会资助
    GraphQL 维护者的指导和项目资助，管理 GraphQL 商标政策，为项目提供法律支持，并支持与社区相关的基础设施。
- en: Use Cases
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用场景
- en: Just about any application and device can use GraphQL. Companies may consider
    using it if their clients often request a lot of information at the same time,
    which would otherwise require making many REST API calls. Using GraphQL could
    reduce bandwidth usage and improve client performance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用程序和设备都可以使用 GraphQL。如果公司的客户经常同时请求大量信息，而这通常需要多次调用 REST API，企业可以考虑使用 GraphQL。使用
    GraphQL 可以减少带宽使用并提高客户端性能。
- en: For instance, imagine a website dashboard that consolidates information about
    the weather from multiple third-party weather websites and that is consumed by
    mobile clients on slow data networks. If the dashboard had to make a bunch of
    calls to the various weather networks and filter through the data, this wouldn’t
    be an optimized process. GraphQL allows the fetching of complex data structures
    in a single request, significantly reducing the required number of client and
    server round trips. You’ll learn more about this bandwidth-optimization design
    later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设有一个网站仪表盘，将来自多个第三方天气网站的天气信息汇总，并由处于慢速数据网络中的移动客户端使用。如果仪表盘必须向多个天气网络发出大量请求并筛选数据，这将不是一个优化的过程。GraphQL
    允许通过单一请求获取复杂的数据结构，从而显著减少客户端和服务器之间的往返次数。你将在本章后面了解更多关于这种带宽优化设计的内容。
- en: Today, many large-scale companies, such as Facebook, Atlassian, GitHub, and
    GitLab, use GraphQL, serving hundreds of millions of customers on various platforms,
    such as mobile phones, desktop computers, and even smart TVs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多大型公司，如 Facebook、Atlassian、GitHub 和 GitLab，都在使用 GraphQL，为数亿客户提供服务，覆盖多个平台，如手机、桌面计算机，甚至智能电视。
- en: Specification
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范
- en: In 2015, Facebook publicly released the GraphQL specification document, which
    defined rules, design principles, and standard practices to which all implementations
    of GraphQL must adhere. This specification is a reference for implementing GraphQL
    for multiple languages, similar to request for comments (RFC) documents. You can
    think of it as a blueprint.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年，Facebook 公开发布了 GraphQL 规范文档，定义了所有 GraphQL 实现必须遵守的规则、设计原则和标准实践。这个规范类似于请求评论（RFC）文档，是多语言实现
    GraphQL 的参考。你可以将其视为一份蓝图。
- en: As such, we, as hackers, can use it to better understand how GraphQL is meant
    to be implemented and verify that the target application we’re hacking conforms
    to these predefined rules. Because implementations often deviate from the standard
    for various reasons, chances increase for us to find bugs in them, some of which
    may have security implications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为黑客，我们可以利用它更好地理解 GraphQL 的实现方式，并验证我们正在破解的目标应用程序是否符合这些预定义的规则。由于实现往往由于各种原因偏离标准，因此我们有更多的机会发现其中的漏洞，其中一些漏洞可能涉及安全问题。
- en: How Do Communications Work?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信是如何工作的？
- en: A typical GraphQL implementation incorporates a few components you should become
    familiar with if you hope to search it for security flaws. [Figure 1-1](#figure1-1)
    describes these.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 GraphQL 实现包含一些你应该熟悉的组件，如果你希望搜索其中的安全漏洞。[图 1-1](#figure1-1) 描述了这些组件。
- en: '![](image_fi/502840c01/f01001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01001.png)'
- en: 'Figure 1-1: Core GraphQL components'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：核心 GraphQL 组件
- en: When a client wants to communicate with a GraphQL server (for example, to read
    a list of usernames and emails), that client will use the HyperText Transfer Protocol
    (HTTP) POST method to send the server a GraphQL query. You might already be noticing
    that this doesn’t follow standard HTTP method conventions, as data reads are more
    often than not implemented with the HTTP GET method; you will learn more about
    this later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要与 GraphQL 服务器进行通信（例如，读取用户名和电子邮件列表）时，客户端将使用超文本传输协议（HTTP）POST 方法向服务器发送 GraphQL
    查询。你可能已经注意到，这与标准的 HTTP 方法约定不符，因为数据读取通常是通过 HTTP GET 方法实现的；你将在本章稍后了解更多有关这方面的内容。
- en: The server, in turn, will process the query by using a query parser. *Query
    parsers* read and validate that the query is properly formatted and that the server
    can support it. This validation involves checking the query against the application’s
    GraphQL schema. If the query is deemed valid, it will be handled by resolver functions,
    which are responsible for generating the response to the client’s query. Talk
    about many moving pieces! Let’s break down these core components to better explain
    how they work together.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器反过来会使用查询解析器来处理查询。*查询解析器*读取并验证查询的格式是否正确，且服务器是否支持该查询。这个验证过程涉及将查询与应用程序的 GraphQL
    架构进行对比检查。如果查询被认为是有效的，它将由解析器函数处理，解析器函数负责生成响应客户端查询的结果。这里有很多运作的部分！让我们拆解这些核心组件，来更好地解释它们如何协同工作。
- en: The Schema
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构
- en: The GraphQL *schema* represents the type of data a client can query for. Schemas
    are defined using *schema definition language (SDL)*. [Listing 1-1](#listing1-1)
    shows its syntax for defining two object types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL *架构*表示客户端可以查询的数据类型。架构使用*架构定义语言（SDL）*来定义。[列表 1-1](#listing1-1)展示了定义两个对象类型的语法。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 1-1: Schema definition language'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-1：架构定义语言
- en: '*Object* types are the most basic component of a GraphQL schema; they represent
    a piece of data you can fetch from the service running GraphQL. Object types have
    *fields*, which are object-specific attributes that have a value. In [Listing
    1-1](#listing1-1), we define an object type called `User` and another type called
    `Location`. The `User` type has two fields, named `username` and `email`, both
    of which are of the `String` scalar type. The `Location` type also has two fields,
    named `latitude` and `longitude`, which are of `Int` (integer) scalar type.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*类型是 GraphQL 架构的最基本组成部分；它们表示你可以从运行 GraphQL 服务中获取的数据。在[列表 1-1](#listing1-1)中，我们定义了一个名为
    `User` 的对象类型和另一个名为 `Location` 的类型。`User` 类型有两个字段，分别是 `username` 和 `email`，它们都是
    `String` 标量类型。`Location` 类型也有两个字段，分别是 `latitude` 和 `longitude`，它们是 `Int`（整数）标量类型。'
- en: So far, the objects and fields in our example schema aren’t connected to each
    other. However, GraphQL allows us to form links between objects in various ways.
    To visualize how this works, we can represent our schema as a graph consisting
    of nodes and edges. In our example, the `User` and `Location` object types are
    *nodes*, as shown in [Figure 1-2](#figure1-2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们示例中的对象和字段尚未相互关联。然而，GraphQL 允许我们通过多种方式在对象之间建立链接。为了可视化这个过程，我们可以将架构表示为一个由节点和边组成的图。在我们的示例中，`User`
    和 `Location` 对象类型是*节点*，如[图 1-2](#figure1-2)所示。
- en: '![](image_fi/502840c01/f01002.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01002.png)'
- en: 'Figure 1-2: Graph nodes'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：图形节点
- en: '*Edges* are a way to create a link between multiple nodes. For example, an
    object could have a field that references another object. Let’s say you have a
    list of users, as well as a list of physical locations from which they last logged
    in, and you want to return a user’s location whenever a client queries for that
    user. [Listing 1-2](#listing1-2) shows how to do this by using edges.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*边*是创建多个节点之间链接的一种方式。例如，一个对象可能有一个字段引用另一个对象。假设你有一个用户列表，以及一个记录用户最后登录位置的物理位置列表，你希望在客户端查询该用户时返回其位置。[列表
    1-2](#listing1-2)展示了如何使用边来实现这一点。'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 1-2: The linking of nodes'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-2：节点的链接
- en: We added an additional `location` field to the `User` object type ❶ and linked
    it to the `Location` object type ❷. In practice, this means that you can request
    a `User` object and get its associated location data. However, you won’t be able
    to query for a username by using the `Location` object type, because we haven’t
    defined that edge in our schema. [Figure 1-3](#figure1-3) illustrates how the
    two nodes now have a one-way link relationship.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `User` 对象类型 ❶ 添加了一个额外的 `location` 字段，并将其与 `Location` 对象类型 ❷ 关联起来。实际上，这意味着你可以请求一个
    `User` 对象并获取其相关的位置数据。然而，你不能通过 `Location` 对象类型查询用户名，因为我们在架构中没有定义该边。[图 1-3](#figure1-3)说明了这两个节点现在具有单向链接关系。
- en: '![](image_fi/502840c01/f01003.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01003.png)'
- en: 'Figure 1-3: One-way link relationship between nodes'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：节点之间的单向链接关系
- en: Edges are not limited to one-way link relationships. In fact, you can create
    a two-way link relationship between the same objects, as shown in [Figure 1-4](#figure1-4).
    Legitimate use cases exist for connecting two nodes in this way. In the `User`
    and `Location` example, imagine that clients of our API need the ability to fetch
    usernames and see their locations as part of the returned data. Also, let’s say
    that clients should be able to fetch specific locations and see which users have
    logged in at each location. Two-way link relationships allow for this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘不仅限于单向链接关系。事实上，你可以在相同的对象之间创建双向链接关系，如[图 1-4](#figure1-4)所示。通过这种方式连接两个节点有其合理的使用场景。在`User`和`Location`的例子中，假设我们的
    API 客户端需要能够获取用户名并查看其位置，作为返回数据的一部分。同时，假设客户端还应该能够获取特定位置并查看哪些用户在每个位置登录。双向链接关系正好支持这一功能。
- en: '![](image_fi/502840c01/f01004.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01004.png)'
- en: 'Figure 1-4: Two-way link relationship between nodes'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4：节点之间的双向链接关系
- en: From a security perspective, two-way link relationships often lead to unwanted
    denial-of-service (DoS) conditions, which could completely take down a system.
    When two-way link relationships exist, API developers should introduce security
    controls to mitigate these vulnerabilities, which we’ll explain in more detail
    in Chapter 5.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，双向链接关系往往会导致不希望出现的拒绝服务（DoS）状况，这可能会完全使系统崩溃。当存在双向链接关系时，API 开发者应该引入安全控制措施以减轻这些漏洞，详细内容将在第五章中说明。
- en: Queries
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: 'Once an API’s schema is defined, clients can fetch information from it by using
    specially crafted queries written in the declarative GraphQL query language. In
    GraphQL, all queries begin with a definition of the operation’s *root type*, which
    specifies one of the following operations:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 API 的模式定义完成，客户端就可以通过使用专门编写的声明式 GraphQL 查询语言来从中获取信息。在 GraphQL 中，所有查询都以操作的*根类型*定义开始，该根类型指定以下操作之一：
- en: '*Queries* are used for read-only operations. These operations don’t involve
    data manipulation.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询*用于只读操作。这些操作不涉及数据操作。'
- en: '*Mutations* are used for data manipulation, such as data writes. These operations
    involve data modifications, data additions, data deletions, and so on. Mutations
    can be used to write and read data at the same time.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*突变*用于数据操作，比如数据写入。这些操作涉及数据修改、数据添加、数据删除等。突变可以同时用于写入和读取数据。'
- en: '*Subscriptions* are used for real-time communications between clients and GraphQL
    servers. They allow a GraphQL server to push data to the client when different
    events occur. Subscriptions typically are used in conjunction with transport protocols
    such as WebSocket.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*订阅*用于客户端与 GraphQL 服务器之间的实时通信。当发生不同事件时，它们允许 GraphQL 服务器将数据推送到客户端。订阅通常与 WebSocket
    等传输协议结合使用。'
- en: 'These three operations are the starting point for each GraphQL query we compose.
    For example, a query operation uses the `query` keyword:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种操作是我们编写每个 GraphQL 查询的起点。例如，查询操作使用`query`关键字：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A mutation operation type uses the `mutation` keyword:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个突变操作类型使用`mutation`关键字：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, a subscription operation type uses the `subscription` keyword:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，订阅操作类型使用`subscription`关键字：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before a client can perform one of these operations, the developer must have
    defined the operation in the schema and specified the fields that clients can
    use. For example, [Listing 1-3](#listing1-3) defines the `Query` type and establishes
    the path that allows clients to fetch one of the object types we defined earlier,
    `User`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端执行这些操作之前，开发者必须在模式中定义该操作，并指定客户端可以使用的字段。例如，[示例 1-3](#listing1-3)定义了`Query`类型，并建立了一个路径，允许客户端获取我们之前定义的对象类型`User`。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 1-3: The full schema, with an entry point to querying the `User` type'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-3：完整的模式，包含查询`User`类型的入口点
- en: By querying the `users` field in the `Query` type, clients can access the `User`
    object type we defined. The square brackets `[]` surrounding the `User` object
    type indicate that this query will return an array of `User` objects. We’ll discuss
    this syntax in Chapter 3.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询`Query`类型中的`users`字段，客户端可以访问我们定义的`User`对象类型。`User`对象类型周围的方括号`[]`表示此查询将返回一个`User`对象的数组。我们将在第三章讨论此语法。
- en: '[Listing 1-4](#listing1-4) is an example query that a client might send to
    a GraphQL server implementing the schema in [Listing 1-3](#listing1-3).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-4](#listing1-4)是客户端可能向实现[示例 1-3](#listing1-3)模式的 GraphQL 服务器发送的查询。'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 1-4: A GraphQL query'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-4：一个 GraphQL 查询
- en: 'As you can see, GraphQL queries are pretty easy to read: all this query does
    is get the username and email of all users of the application. We define the query
    by using the `query` root operation. Then we request `users` as the query’s top-level
    field, specifying the `username` and `email` fields we want. Because this query
    only reads information and doesn’t change any data, we perform a query operation
    rather than a mutation.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，GraphQL 查询非常容易阅读：这个查询所做的就是获取应用程序中所有用户的用户名和电子邮件。我们通过使用 `query` 根操作来定义查询。然后，我们请求
    `users` 作为查询的顶级字段，指定我们想要的 `username` 和 `email` 字段。因为这个查询只读取信息而不更改任何数据，所以我们执行的是查询操作，而不是变更操作。
- en: Notice that blank spaces are used to separate components like names and values.
    The number of spaces used doesn’t matter; whether there’s a single space or multiple
    spaces, the query will remain the same and return consistent results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空格用于分隔组件，如名称和值。使用的空格数量无关紧要；无论是单个空格还是多个空格，查询都会保持不变并返回一致的结果。
- en: The Query Parser and Resolver Functions
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询解析器与解析器函数
- en: Now, what happens when a GraphQL server receives a query? Well, it makes use
    of a *query parser* to read and extract the information it needs to execute the
    incoming query. The query parser is responsible for turning the query string into
    an *abstract syntax tree (AST)* and validating it against the schema to ensure
    that only valid queries are accepted. An AST is a hierarchical object that represents
    the query. It includes fields, arguments, and other information and can be easily
    traversed by different language parsers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当一个 GraphQL 服务器接收到查询时会发生什么呢？它会使用一个*查询解析器*来读取并提取执行传入查询所需的信息。查询解析器负责将查询字符串转化为*抽象语法树（AST）*并根据模式进行验证，以确保只接受有效的查询。AST
    是一个层次化的对象，表示查询。它包含字段、参数和其他信息，可以被不同语言的解析器轻松遍历。
- en: GraphQL is *strongly typed*, which means that when clients use the wrong data
    types, the server returns an error. For example, if some data is defined as an
    `Int`, using a `String` instead would yield errors. This allows development teams
    to rely on the API to perform the type validation. We’ll discuss these types in
    more detail in Chapter 3.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是*强类型*的，这意味着当客户端使用错误的数据类型时，服务器会返回错误。例如，如果某些数据被定义为 `Int`，而使用 `String`
    则会导致错误。这允许开发团队依赖 API 来执行类型验证。我们将在第 3 章中更详细地讨论这些类型。
- en: To generate a response to the client’s query containing the requested data,
    the server uses *resolver functions*, also simply called *resolvers*. Resolvers
    are responsible for populating the response with data for each field specified
    in the client query. To do so, resolvers may implement code logic to take on tasks
    such as querying relational databases, cache databases, or other servers on the
    network. Every field has a corresponding resolver function responsible for returning
    the field’s response.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成包含请求数据的响应，服务器使用*解析器函数*，也称为*解析器*。解析器负责根据客户端查询中指定的每个字段填充响应数据。为此，解析器可能会实现代码逻辑来执行诸如查询关系数据库、缓存数据库或网络上其他服务器等任务。每个字段都有一个对应的解析器函数，负责返回该字段的响应。
- en: For example, to fulfill the query we showed in [Listing 1-4](#listing1-4), a
    resolver function may connect to an external database such as MySQL, and query
    its users table to get a list of the available username and email entries. Because
    resolver functions are the GraphQL component responsible for query resolution,
    this is also where vulnerabilities can exist. If the functions are written poorly,
    they may contain bugs, which may lead to security flaws.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要实现我们在[清单 1-4](#listing1-4)中展示的查询，解析器函数可能会连接到外部数据库，如 MySQL，并查询其用户表以获取可用的用户名和电子邮件条目列表。由于解析器函数是负责查询解析的
    GraphQL 组件，这也是潜在漏洞的存在之地。如果这些函数编写得不好，可能会包含 bug，从而导致安全漏洞。
- en: Resolvers are not limited to reading from a database. They can read data from
    the local filesystem or make HTTP requests to additional systems over REST APIs.
    In fact, GraphQL APIs commonly make REST calls behind the scenes, especially when
    companies are gradually transitioning from using REST to GraphQL. Sometimes GraphQL
    is used as a consolidator API layer to multiple backend REST services that remain
    invisible to the client.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器不仅限于从数据库读取数据。它们可以从本地文件系统读取数据或通过 REST API 向其他系统发起 HTTP 请求。实际上，GraphQL API
    通常在后台进行 REST 调用，尤其是当公司从 REST 逐步过渡到 GraphQL 时。有时，GraphQL 被用作多个后端 REST 服务的整合 API
    层，客户端对此保持透明。
- en: In summary, you can think of GraphQL as a query layer that sits between the
    client (such as a browser running on a user’s mobile phone or laptop) and the
    application logic. Clients seeking to interact with a GraphQL API could use a
    variety of available open source GraphQL client libraries, such as Apollo Client
    ([https://www.apollographql.com/docs/react](https://www.apollographql.com/docs/react)),
    currently maintained by Apollo for TypeScript, or Relay ([https://relay.dev](https://relay.dev)),
    currently maintained by Facebook for JavaScript. Using dedicated GraphQL clients
    isn’t required; you can also query GraphQL APIs using command line HTTP clients
    such as cURL. In Chapter 3, we’ll cover how GraphQL works at the lower levels.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你可以把 GraphQL 看作是一个查询层，位于客户端（如在用户手机或笔记本上运行的浏览器）和应用程序逻辑之间。希望与 GraphQL API
    交互的客户端可以使用各种可用的开源 GraphQL 客户端库，例如 Apollo Client（[https://www.apollographql.com/docs/react](https://www.apollographql.com/docs/react)），由
    Apollo 为 TypeScript 维护，或 Relay（[https://relay.dev](https://relay.dev)），由 Facebook
    为 JavaScript 维护。使用专门的 GraphQL 客户端不是必需的；你也可以使用命令行 HTTP 客户端，如 cURL，来查询 GraphQL API。在第
    3 章中，我们将介绍 GraphQL 在更低层次上的工作原理。
- en: What Problems Does GraphQL Solve?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 解决了什么问题？
- en: GraphQL improves the speed of client-server interactions by saving the client
    from having to make multiple requests in order to retrieve the complete set of
    data it needs from an application. Because GraphQL allows clients to define a
    precise query structure, it avoids costly performance issues such as *over-fetching*
    (returning data to the client that isn’t used) or *under-fetching* (returning
    too little data, forcing the client to make a second request). You’ll learn more
    about these differences and why they matter for performance in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 通过节省客户端无需多次请求来获取完整数据集的时间，提升了客户端与服务器的交互速度。因为 GraphQL 允许客户端定义精确的查询结构，它避免了代价高昂的性能问题，例如
    *过度获取*（返回客户端不使用的数据）或 *过少获取*（返回的数据太少，迫使客户端发起第二次请求）。你将在下一节中了解更多这些差异以及它们对性能的重要性。
- en: GraphQL has additional useful features, such as schema stitching and schema
    federation. *Schema stitching* is a way to create a single GraphQL schema from
    multiple underlying GraphQL services, allowing GraphQL to be used as a unified
    gateway. Essentially, it packages (stitches) multiple schemas into one big schema,
    creating a single integration point for clients. Because multiple microservices
    can define their own GraphQL schemas and have their own GraphQL endpoints, allowing
    a single GraphQL API gateway to consolidate many schemas into one can make it
    easier for clients to integrate with an application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 还有其他有用的功能，如模式拼接和模式联合。*模式拼接* 是一种从多个底层 GraphQL 服务创建单一 GraphQL 模式的方法，使得
    GraphQL 可以作为统一的网关使用。本质上，它将多个模式打包（拼接）成一个大模式，为客户端创建一个单一的集成点。由于多个微服务可以定义自己的 GraphQL
    模式并拥有各自的 GraphQL 端点，因此允许单一的 GraphQL API 网关将多个模式合并成一个，可以让客户端更容易与应用程序集成。
- en: '*Schema federation* is similar to schema stitching, except it doesn’t require
    you to manually stitch schemas together. Instead, schema federation lets you tell
    the GraphQL API gateway where to look for additional schemas. The gateway then
    does the stitching automatically. Federation is a lower-maintenance approach for
    consolidating multiple APIs into a single gateway.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式联合* 类似于模式拼接，只是它不需要你手动拼接模式。相反，模式联合让你可以告诉 GraphQL API 网关去哪里查找额外的模式。然后，网关会自动完成拼接。联合是一种低维护的方式，用于将多个
    API 合并成一个网关。'
- en: Complex API applications, such as ones that require schema federation or schema
    stitching, may introduce security vulnerabilities, potentially allowing hackers
    to access data to which they shouldn’t otherwise have access. In general, the
    more complex an application is, the higher the chance that its internal complexities
    could lead to vulnerabilities.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的 API 应用程序，例如需要模式联合或模式拼接的应用程序，可能会引入安全漏洞，可能允许黑客访问他们本不应有权访问的数据。通常来说，应用程序越复杂，其内部复杂性就越可能导致漏洞。
- en: GraphQL APIs vs. REST APIs
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL API 与 REST API
- en: In the previous sections, we discussed the challenges of traditional APIs that
    GraphQL attempts to solve. For example, REST APIs often provide more data than
    the client needs (over-fetching) or too little data (under-fetching), forcing
    the client to make additional API requests. In this section, we’ll walk through
    an example to demonstrate how an application fronted by a REST API compares to
    one that uses GraphQL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了传统 API 存在的挑战，GraphQL 尝试解决这些挑战的方式。例如，REST API 经常会提供比客户端需要的更多数据（过度获取）或太少数据（不足获取），迫使客户端进行额外的
    API 请求。在本节中，我们将通过一个示例来演示使用 REST API 的应用与使用 GraphQL 的应用之间的差异。
- en: Consider [Table 1-1](#table1-1), a database table with information about an
    application’s user base. A simple web application might display this information
    as part of an admin panel that lets the systems administrator list all available
    accounts and get their state. We’ll call this the Users Administration page.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [表 1-1](#table1-1)，一个包含应用程序用户基本信息的数据库表。一个简单的 Web 应用可能会将这些信息显示为管理员面板的一部分，使系统管理员可以列出所有可用帐户并获取其状态。我们将其称为用户管理页面。
- en: 'Table 1-1: Users Database Table'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1：用户数据库表
- en: '| **User ID** | **Username** | **Email** | **First name** | **Last name** |
    **State** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **用户 ID** | **用户名** | **电子邮件** | **名** | **姓** | **状态** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 1 | dsmith | *david@example.com* | David | Smith | Disabled |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 1 | dsmith | *david@example.com* | David | Smith | 禁用 |'
- en: '| 2 | clarry | *chris@example.com* | Chris | Larry | Enabled |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 2 | clarry | *chris@example.com* | Chris | Larry | 启用 |'
- en: In the following sections, we’ll describe the API requests a client would have
    to make to retrieve user data if the application were using a REST API, and how
    it might do the same in an application using GraphQL.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将描述客户端必须执行的 API 请求，以便在应用程序使用 REST API 时检索用户数据，以及在使用 GraphQL 的应用程序中可能会执行相同操作。
- en: The REST Example
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REST 示例
- en: 'In applications that use REST APIs, we define specific *endpoints*, or *routes*,
    at which clients can perform actions such as reading or writing data using specific
    HTTP methods (such as GET or POST). [Table 1-2](#table1-2) defines two REST API
    endpoints for two purposes: one for getting a list of users and another to get
    information about a user’s login history.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 REST API 的应用程序中，我们定义特定的 *端点* 或 *路由*，客户端可以在这些端点上执行诸如读取或写入数据的操作，使用特定的 HTTP
    方法（如 GET 或 POST）。[表 1-2](#table1-2) 定义了两个 REST API 端点，用于两个不同的目的：一个用于获取用户列表，另一个用于获取用户登录历史信息。
- en: 'Table 1-2: REST API Definitions'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2：REST API 定义
- en: '| **HTTP method** | **API endpoint** | **Endpoint description** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 方法** | **API 端点** | **端点描述** |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| GET | */rest/v1/users* | Returns a list of all available users and their
    information |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| GET | */rest/v1/users* | 返回所有可用用户及其信息的列表 |'
- en: '| GET | */rest/v1/history/<user_id>* | Returns a list of the login timestamps
    for a given user |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| GET | */rest/v1/history/<user_id>* | 返回给定用户的登录时间戳列表 |'
- en: When a systems administrator wants to view the Users Administration page, their
    web client, such as a web browser, will need to obtain information about all available
    users through the web application’s API. To retrieve this data using the API endpoints
    in [Table 1-2](#table1-2), the web browser would need to send a GET request to
    */rest/v1/users.* [Listing 1-5](#listing1-5) shows this request and its response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统管理员希望查看用户管理页面时，他们的 Web 客户端（如 Web 浏览器）将需要通过 Web 应用程序的 API 获取所有可用用户的信息。为了通过
    [表 1-2](#table1-2) 中的 API 端点检索此数据，Web 浏览器将需要向 */rest/v1/users* 发送 GET 请求。[列表 1-5](#listing1-5)
    展示了这个请求及其响应。
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 1-5: GET request to */rest/v1/users* that lists all system users'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-5：对 */rest/v1/users* 发出的 GET 请求，列出所有系统用户
- en: As you can see, this request returns the list of all users in JavaScript Object
    Notation (JSON) format, along with their emails, names, IDs, and account states.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，此请求以 JavaScript 对象表示法（JSON）格式返回所有用户的列表，包括他们的电子邮件、姓名、ID 和帐户状态。
- en: 'But what if the system administrator wants to retrieve only certain information
    about users, such as their email addresses, without returning any other information?
    Using the API definitions in [Table 1-2](#table1-2), this wouldn’t be possible.
    Instead, the response in [Listing 1-5](#listing1-5) would need to be processed
    in its entirety, and the `email` field would need to be extracted out of the response.
    This is an example of the over-fetching problem in REST APIs: the client receives
    more data than it needs and then has to filter it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果系统管理员只想检索用户的某些信息，比如他们的电子邮件地址，而不返回任何其他信息，使用[表 1-2](#table1-2)中的API定义，这是不可能的。相反，需要处理[清单
    1-5](#listing1-5)中的整个响应，并从中提取出`email`字段。这是REST API中过度获取问题的一个示例：客户端接收到比其需求更多的数据，然后必须进行过滤。
- en: 'Now, imagine that you are the systems administrator and have been tasked with
    identifying any intrusion attempts on the network. You plan to write a script
    that will run every night and check for suspicious behavior. For example, it should
    flag users who have logged in after normal work hours, which are from 9 AM to
    5 PM. To achieve this goal, the script will need to make an API request using
    the GET method to the */rest/v1/history/<user_id>* endpoint. However, if you look
    closely at the endpoint structure, you’ll notice that it requires the client to
    supply a specific user ID. How will the script know the ID of the application’s
    users? The short answer: it won’t, unless it first fetches all of the available
    user IDs.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你是系统管理员，被要求识别网络上的任何入侵尝试。您计划编写一个每晚运行并检查可疑行为的脚本。例如，它应该标记在正常工作时间之后登录的用户，即从上午9点到下午5点。为了实现这个目标，脚本将需要使用GET方法向端点*/rest/v1/history/<user_id>*发出API请求。然而，如果仔细查看端点结构，您会注意到它要求客户端提供特定的用户ID。脚本如何知道应用程序用户的ID呢？简短的答案是：除非首先获取所有可用用户ID，否则不会。
- en: In practice, this means that in order for the script to successfully run, read
    a user’s last login timestamp, and identify a possible intrusion, it first needs
    to list all user accounts on the system using the API endpoint */rest/v1/users*.
    This should return every user’s username, email, first name, last name, state,
    and user ID.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着为了脚本能够成功运行、读取用户的最后登录时间戳并识别可能的入侵，首先需要列出系统上的所有用户账户，使用API端点*/rest/v1/users*。这应该返回每个用户的用户名、电子邮件、名字、姓氏、状态和用户ID。
- en: Next, it needs to make a second API request to */rest/v1/history/1*, where *1*
    is the user ID obtained from the first request, as shown in [Listing 1-6](#listing1-6).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它需要向*/rest/v1/history/1*发出第二个API请求，其中*1*是从第一个请求中获取的用户ID，如[清单 1-6](#listing1-6)所示。
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 1-6: Response from */rest/v1/history/1*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-6：来自*/rest/v1/history/1*的响应
- en: To get the entire list of all historical user logins, the client would need
    to make additional requests until it had fetched all user IDs. If we have 1,000
    users, that will require 1,000 requests. Sounds like an inefficient process, doesn’t
    it? This is an example of the under-fetching problem that REST APIs tend to have.
    RESTful APIs can be designed to return specific information, but the complexity
    required to allow for such querying flexibility across a variety of REST endpoints
    will make it challenging to maintain over time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有历史用户登录的完整列表，客户端需要进行额外的请求，直到获取所有用户ID为止。如果有1000个用户，这将需要1000个请求。听起来效率低下，对吧？这是REST
    API倾向于出现的不足获取问题的一个例子。RESTful API可以被设计为返回特定信息，但是要跨多个REST端点提供这种查询灵活性所需的复杂性将使其在维护上具有挑战性。
- en: While making two requests to retrieve the login info of a single user may not
    seem like a big deal at first glance, imagine that the application serves millions
    of clients simultaneously. At this scale, every request counts; any additional
    cross-network calls will result in increased latency on the server and impact
    the client’s experience. This will decrease the overall speed and efficiency of
    the application.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始看起来，为了获取单个用户的登录信息而发起两个请求似乎不是什么大问题，但想象一下应用程序同时为数百万客户端提供服务。在这个规模下，每个请求都很重要；任何额外的跨网络调用都会增加服务器的延迟并影响客户端的体验。这将降低应用程序的整体速度和效率。
- en: If you’d like to see these requests in action, you can experiment with this
    example’s APIs by pointing your web browser to the live lab located at [http://lab.blackhatgraphql.com/start](http://lab.blackhatgraphql.com/start).
    There, click the two links to navigate to the REST from within your web browser,
    as shown in [Figure 1-5](#figure1-5).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看这些请求的实际效果，可以通过将你的浏览器指向位于[http://lab.blackhatgraphql.com/start](http://lab.blackhatgraphql.com/start)的实时实验室，来尝试这个示例的API。在那里，点击这两个链接，在浏览器中导航到REST接口，如[图1-5](#figure1-5)所示。
- en: '![](image_fi/502840c01/f01005.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01005.png)'
- en: 'Figure 1-5: A live REST API example'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5：一个实时的REST API示例
- en: We’ve demonstrated the under-fetching and over-fetching problems of REST APIs.
    How will GraphQL solve these? Let’s explore the exact same scenario in the GraphQL
    world.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了REST API的过少获取和过度获取问题。GraphQL是如何解决这些问题的呢？让我们在GraphQL的世界中探索相同的场景。
- en: The GraphQL Example
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL示例
- en: Imagine that our Users Administration web application has scrapped its REST
    API in favor of GraphQL, and that we’ve established a schema defining a data-graph
    edge between the users and history nodes. Now, when the systems administrator
    views the Users Administration page, their web browser will use the application’s
    GraphQL API endpoint to return all the data needed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们的用户管理Web应用已经废弃了REST API，转而采用GraphQL，并且我们已经建立了一个定义了用户和历史节点之间数据图关系的模式。现在，当系统管理员查看用户管理页面时，他们的浏览器将使用应用程序的GraphQL
    API端点来返回所需的所有数据。
- en: 'The browser might use the query in [Listing 1-7](#listing1-7) to retrieve information
    such as user IDs, emails, first names, last names, historical information such
    as the timestamp of their last login, and account states:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器可能会使用[清单1-7](#listing1-7)中的查询来检索诸如用户ID、电子邮件、名字、姓氏、历史信息（例如最后登录的时间戳）以及账户状态等信息：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 1-7: GraphQL query to fetch information about the users'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-7：获取用户信息的GraphQL查询
- en: A response to such a query can be seen in [Listing 1-8](#listing1-8).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询的响应可以在[清单1-8](#listing1-8)中看到。
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 1-8: GraphQL query response containing all available users and their
    information'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-8：包含所有可用用户及其信息的GraphQL查询响应
- en: Notice that the response contains a `data` JSON field, which includes the `users`
    field, and that the `users` field is an array containing all users on the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，响应中包含了一个`data` JSON字段，其中包括`users`字段，而`users`字段是一个包含系统中所有用户的数组。
- en: At this point, there aren’t any visible differences between the REST and GraphQL
    APIs. So, how does GraphQL address the over-fetching and under-fetching problems?
    Well, if we wanted to specifically request a certain field, such as the users’
    email addresses, we could omit any irrelevant fields and include only the `email`
    field, as shown in [Listing 1-9](#listing1-9).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，REST和GraphQL的API之间没有任何明显的区别。那么，GraphQL是如何解决过度获取和过少获取的问题的呢？如果我们想特别请求某个字段，例如用户的电子邮件地址，我们可以省略任何无关的字段，只包含`email`字段，如[清单1-9](#listing1-9)所示。
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 1-9: GraphQL query that returns only email addresses'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-9：只返回电子邮件地址的GraphQL查询
- en: By explicitly including the fields we’re interested in returning, we limit the
    response to relevant data, as shown in [Listing 1-10](#listing1-10).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确包含我们想要返回的字段，我们将响应限制为相关数据，如[清单1-10](#listing1-10)所示。
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 1-10: GraphQL server response containing only email addresses'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-10：仅返回电子邮件地址的GraphQL服务器响应
- en: As you can see, the response contains only the email addresses, as instructed
    by the query. If 100 email addresses were stored in the backend database, all
    of them would have been returned with such a query.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，响应中只包含了电子邮件地址，正如查询所要求的那样。如果后端数据库中存储了100个电子邮件地址，这样的查询将返回全部的电子邮件地址。
- en: Now, remember when, earlier, we wanted to return users’ last login timestamps
    for our intrusion detection task? With GraphQL, we can do so using a query similar
    to the one shown in [Listing 1-11](#listing1-11).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记得我们之前提到过，要返回用户最后登录的时间戳来进行入侵检测任务吗？通过GraphQL，我们可以使用类似[清单1-11](#listing1-11)中显示的查询来实现这一目标。
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 1-11: GraphQL query that returns the timestamp of the last logins made
    by users, along with their emails'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-11：返回用户最后登录时间戳及其电子邮件的GraphQL查询
- en: As expected, we receive only the relevant fields, as shown in [Listing 1-12](#listing1-12).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们只接收到相关字段，如[清单1-12](#listing1-12)所示。
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 1-12: GraphQL response containing only the `email` and `last_login_timestamp`
    fields'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-12：仅包含`email`和`last_login_timestamp`字段的GraphQL响应
- en: Using GraphQL’s powerful declarative language, we can craft very selective queries
    that fetch only the necessary information. In later chapters, you’ll learn how
    to leverage this query syntax to attack GraphQL servers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GraphQL强大的声明性语言，我们可以编写非常选择性的查询，仅获取必要的信息。在后续章节中，您将学习如何利用这种查询语法来攻击GraphQL服务器。
- en: Other Differences
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他区别
- en: This section lists other significant differences between REST APIs and GraphQL
    APIs that security professionals should be aware of. These include the specific
    HTTP methods an application should use, which HTTP status codes to return in specific
    error scenarios, and more. Some of these differences might seem odd to anyone
    who has performed penetration tests of REST applications, as in certain cases
    GraphQL strays from the guidance of the HTTP RFC.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了REST API和GraphQL API之间的其他重要差异，安全专业人员应该注意这些差异。这些差异包括应用程序应该使用的特定HTTP方法，特定错误情景下应返回的HTTP状态码等。对于执行过REST应用程序渗透测试的人员来说，某些差异可能看起来很奇怪，因为在某些情况下，GraphQL偏离了HTTP
    RFC的指导。
- en: HTTP Request Methods
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP请求方法
- en: Earlier in this chapter, we mentioned that GraphQL communications typically
    happen over the POST method, whether for writing data, deleting data, or simply
    reading data. By contrast, REST APIs use HTTP methods to indicate the client’s
    intention. For example, they would use GET for reading data and POST for creating
    or updating data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们提到GraphQL通常使用POST方法进行通信，无论是写入数据、删除数据还是简单地读取数据。相比之下，REST API使用HTTP方法来指示客户端的意图。例如，它们会使用GET来读取数据，使用POST来创建或更新数据。
- en: It’s important to note that GraphQL can, in fact, accept queries over the GET
    method. Even though GraphQL applications mostly use POST, you should test a GraphQL
    application for the support of the GET method, as it can open up opportunities
    to identify and abuse vulnerabilities such as cross-site request forgery (CSRF).
    We’ll discuss CSRF in more detail in Chapter 9.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，GraphQL实际上可以接受GET方法的查询。尽管GraphQL应用大多数情况下使用POST，您应该测试GraphQL应用程序是否支持GET方法，因为这可以帮助您发现并利用跨站请求伪造（CSRF）等漏洞。我们将在第9章详细讨论CSRF。
- en: API Endpoint Paths
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API端点路径
- en: In GraphQL, the endpoint exposed to the client is usually located at */graphql*.
    Applications may also choose to offer multiple versions of an API, in which case
    you may see endpoints such as */v1/graphql* or */v2/graphql*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中，对客户端公开的端点通常位于*/graphql*。应用程序也可以选择提供多个API版本，此时您可能会看到像*/v1/graphql*或*/v2/graphql*这样的端点。
- en: No matter which endpoint the API uses, it will remain the same across all client
    requests. This differs from REST APIs, which expose each resource at a separate
    endpoint. Every REST endpoint could have its own set of controls and supported
    methods. For instance, a */history* endpoint might allow only GET requests so
    that clients can fetch historical records, while a */users* endpoint might support
    both GET- and POST-based requests, to allow clients to fetch the list of users
    as well as add new user accounts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无论API使用哪个端点，它在所有客户端请求中保持不变。这与REST API不同，后者在单独的端点上公开每个资源。每个REST端点都可以拥有自己的控制和支持的方法集。例如，*/history*端点可能仅允许GET请求，以便客户端可以获取历史记录，而*/users*端点可能支持基于GET和POST的请求，以允许客户端获取用户列表以及添加新用户账户。
- en: GraphQL instead defines client intentions in the query payload, through operations
    such as queries and mutations. The endpoint remains consistent no matter the resource
    accessed or action performed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，GraphQL通过查询载荷定义客户端的意图，通过查询和变更操作来操作。无论访问哪个资源或执行哪个操作，端点始终保持一致。
- en: HTTP Status Codes
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: HTTP status codes such as *200 OK*, *404 Not Found*, and *401 Unauthorized*
    play a key role in REST APIs, because they signal to the client the outcome of
    their request. For example, when a user attempts to log in to a web page with
    an incorrect username or password, an application with a REST API may return the
    status code of *401 Unauthorized* to signal to the client that they aren’t authorized.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码，如*200 OK*、*404 Not Found*和*401 Unauthorized*在REST API中起着关键作用，因为它们向客户端信号其请求的结果。例如，当用户尝试使用不正确的用户名或密码登录网页时，具有REST
    API的应用程序可能会返回*401 Unauthorized*状态码，以向客户端表示未经授权。
- en: In GraphQL APIs, the status code returned by the server will almost exclusively
    be *200 OK*, even if the action failed because of authorization errors or because
    the requested resource doesn’t exist on the server. GraphQL indicates errors to
    the client by returning an `errors` field as part of the response payload, as
    shown in [Listing 1-13](#listing1-13).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL API中，服务器返回的状态码几乎总是*200 OK*，即使操作由于授权错误或请求的资源在服务器上不存在而失败。GraphQL通过返回`errors`字段作为响应负载的一部分来向客户端指示错误，如[示例
    1-13](#listing1-13)所示。
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 1-13: The GraphQL response error format'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-13：GraphQL响应错误格式
- en: You might see a status code other than *200 OK* if the server fails to serve
    the request completely because of a critical server-side error, such as a database
    being down or another backend failure. In these cases, GraphQL may return the
    expected *500 Server Error* status code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于关键的服务器端错误（如数据库宕机或其他后端故障），服务器无法完全处理请求，您可能会看到除*200 OK*之外的状态码。在这种情况下，GraphQL可能会返回预期的*500
    服务器错误*状态码。
- en: The Importance of Running GraphQL-Tailored Security Tools
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行专门针对GraphQL的安全工具的重要性
- en: These differences in HTTP status codes, request methods, and API endpoint paths
    necessitate a significant shift in our approach to security analysis, intrusion
    detection, and penetration testing. During traditional penetration tests, we often
    rely on hacking tools to handle the heavy lifting when it comes to vulnerability
    assessment and application scanning. When we test GraphQL applications, these
    security tools may report false-positive findings if they don’t have GraphQL support
    built in.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些HTTP状态码、请求方法和API端点路径的差异要求我们在安全分析、入侵检测和渗透测试方面采取显著的调整。在传统的渗透测试中，我们通常依赖黑客工具来处理漏洞评估和应用扫描的重担。当我们测试GraphQL应用时，如果安全工具没有内置GraphQL支持，它们可能会报告错误的假阳性结果。
- en: Traditional web application scanners are tailored to the RFC 2616 HTTP standard
    and assume that applications conform with this RFC when it comes to the status
    codes they return. For example, a web application vulnerability scanner that conducts
    a brute-force attack may report that a successful exploitation occurred if it
    ever receives a *200 OK* status code from the target server. However, you shouldn’t
    interpret a *200 OK* status code in the same way when it is returned from GraphQL-based
    applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Web应用扫描器是根据RFC 2616 HTTP标准定制的，并假定应用程序在返回的状态码方面遵循该RFC。例如，执行暴力破解攻击的Web应用漏洞扫描器可能会报告成功利用发生的情况，如果它从目标服务器收到*200
    OK*状态码。然而，当GraphQL应用返回*200 OK*状态码时，您不应以相同的方式解读它。
- en: When it comes to security analysis, security operators face a challenge when
    they attempt to interpret the access logs of a GraphQL application, especially
    if they are used to interacting with REST API applications. Consider the HTTP
    access log sample shown in [Listing 1-14](#listing1-14).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行安全分析时，安全操作员在尝试解读GraphQL应用的访问日志时面临挑战，尤其是当他们习惯与REST API应用交互时。考虑[示例 1-14](#listing1-14)中显示的HTTP访问日志样本。
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 1-14: Access log patterns for a GraphQL application'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-14：GraphQL应用的访问日志模式
- en: If a security operator is analyzing this log data for suspicious patterns, it
    won’t be particularly insightful if the logs were generated by a GraphQL application.
    Finding useful information will require implementing specialized tooling and logging
    infrastructure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全操作员正在分析这些日志数据以寻找可疑模式，那么如果日志是由GraphQL应用生成的，这不会特别具有洞察力。要找到有用的信息，将需要实现专门的工具和日志基础设施。
- en: Very often, developers deploy newer technology, such as GraphQL, without customizations
    or prior research. As hackers, this gives us some leverage. The fact that GraphQL
    doesn’t comply with standard HTTP status code principles may allow us to evade
    security controls such as web application firewalls (WAFs), as well as go under
    the radar when security operators are looking for anomalous patterns in HTTP error
    codes, especially if those security operators aren’t aware that GraphQL behaves
    differently than REST.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，开发人员在没有进行定制或先前研究的情况下部署新技术，如GraphQL。作为黑客，这给了我们一些优势。GraphQL不遵守标准的HTTP状态码原则，可能使我们绕过Web应用防火墙（WAF）等安全控制，并在安全操作员寻找HTTP错误码中的异常模式时避开雷达，特别是当这些安全操作员不知道GraphQL与REST的行为不同。
- en: Your First Query
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个查询
- en: Now that you’ve learned about APIs and the differences between GraphQL and REST,
    it’s time for you to experiment with a real GraphQL application. In this exercise,
    you’ll use common tools to build your first query and receive a successful response
    from a GraphQL server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了API以及GraphQL和REST之间的差异，接下来是时候尝试一个真正的GraphQL应用程序了。在这个练习中，你将使用常用的工具构建你的第一个查询，并从GraphQL服务器收到成功的响应。
- en: This exercise doesn’t require you to install any special tools. GraphQL implementations
    often provide a graphical user interface (GUI) for running queries in the form
    of an integrated development environment (IDE). A few such tools are out there,
    including *GraphiQL Explorer* (pronounced *graphical*; note the lowercase *i*)
    and *GraphQL Playground*, which are available as either an additional package
    to install or as part of the base installation, depending on the implementation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习不需要你安装任何特殊工具。GraphQL实现通常提供一个图形用户界面（GUI），用于以集成开发环境（IDE）的形式运行查询。一些这样的工具包括*GraphiQL
    Explorer*（发音为*graphical*；注意小写的*i*）和*GraphQL Playground*，它们可以作为额外的包安装，也可以作为基础安装的一部分，具体取决于实现。
- en: We’ll use GraphiQL Explorer, which allows a user to query GraphQL with auto-completion
    features, read autogenerated schema documentation, identify syntax errors in queries
    through error highlighting, see historical queries, and use query variables. These
    features make it very easy for first-time GraphQL users to interact with an application.
    As hackers, we can also benefit from access to such tools. You’ll learn more about
    how we can find and abuse these types of interfaces in Chapter 4.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GraphiQL Explorer，它允许用户通过自动补全功能查询GraphQL，阅读自动生成的架构文档，通过错误高亮标记来识别查询中的语法错误，查看历史查询，并使用查询变量。这些功能使得初次使用GraphQL的用户能够轻松与应用程序交互。作为黑客，我们也能从访问这些工具中受益。你将在第4章中学到更多关于如何发现并利用这些接口的信息。
- en: Let’s go ahead and experiment with writing GraphQL queries. Open any browser
    and navigate to [http://lab.blackhatgraphql.com/graphiql](http://lab.blackhatgraphql.com/graphiql).
    You will be greeted with a screen similar to the one shown in [Figure 1-6](#figure1-6).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始尝试编写GraphQL查询。打开任何浏览器，访问[http://lab.blackhatgraphql.com/graphiql](http://lab.blackhatgraphql.com/graphiql)。你会看到一个与[图1-6](#figure1-6)类似的界面。
- en: In the left pane, you can enter queries. The resulting output will display in
    the right pane. Try entering the simple query shown in [Listing 1-15](#listing1-15).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧窗格中，你可以输入查询。结果会显示在右侧窗格中。尝试输入[清单1-15](#listing1-15)中显示的简单查询。
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 1-15: GraphQL query that displays user information'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 清单1-15：显示用户信息的GraphQL查询
- en: '![](image_fi/502840c01/f01006.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01006.png)'
- en: 'Figure 1-6: The GraphiQL Explorer panel'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：GraphiQL Explorer面板
- en: To send the query to the server, click the play button located at the top-left
    corner. You should see the result shown in [Figure 1-7](#figure1-7).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要将查询发送到服务器，请点击位于左上角的播放按钮。你应该会看到如[图1-7](#figure1-7)所示的结果。
- en: '![](image_fi/502840c01/f01007.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01007.png)'
- en: 'Figure 1-7: GraphQL query result'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7：GraphQL查询结果
- en: You might have noticed a small drop-down menu appear as soon as you start typing
    a query. This menu provides auto-completion options, as shown in [Figure 1-8](#figure1-8).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当你开始输入查询时，会出现一个小的下拉菜单。这个菜单提供了自动补全选项，如[图1-8](#figure1-8)所示。
- en: '![](image_fi/502840c01/f01008.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01008.png)'
- en: 'Figure 1-8: GraphiQL Explorer auto-completion suggestions'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-8：GraphiQL Explorer自动补全建议
- en: The auto-completion feature is useful, especially when you need to interact
    with GraphQL applications that have complex schemas. Without insight into the
    schema, it would be fairly challenging to guess what a valid query might look
    like. The auto-completion feature is available when GraphiQL Explorer is able
    to query the GraphQL server by using the introspection query, GraphQL’s self-documenting
    API feature. You will learn more about introspection in Chapter 3.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 自动补全功能非常有用，特别是当你需要与具有复杂架构的GraphQL应用程序交互时。如果没有对架构的了解，猜测有效的查询可能是什么样子会非常困难。当GraphiQL
    Explorer能够通过使用 introspection 查询（GraphQL的自文档化API功能）来查询GraphQL服务器时，自动补全功能就会生效。你将在第3章中学习更多关于
    introspection 的内容。
- en: To view additional information about the application’s GraphQL schema, click
    the **Docs** tab located in the right pane. This will open up autogenerated documentation,
    as shown in [Figure 1-9](#figure1-9).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用程序的GraphQL架构的更多信息，请点击位于右侧窗格中的**Docs**标签。这将打开自动生成的文档，如[图1-9](#figure1-9)所示。
- en: '![](image_fi/502840c01/f01009.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01009.png)'
- en: 'Figure 1-9: GraphiQL Explorer autogenerated schema documentation'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-9：GraphiQL Explorer 自动生成的架构文档
- en: GraphiQL Explorer also gives you a view of all previously sent queries, as shown
    in [Figure 1-10](#figure1-10). You can click a query to replay it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GraphiQL Explorer 还提供了一个查看所有之前发送过的查询的功能，如 [图 1-10](#figure1-10) 所示。你可以点击查询进行重播。
- en: '![](image_fi/502840c01/f01010.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c01/f01010.png)'
- en: 'Figure 1-10: Historical queries in GraphiQL Explorer'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10：GraphiQL Explorer 中的历史查询
- en: GraphQL servers are unauthenticated by default, which allows graphical interfaces
    such as GraphiQL Explorer and GraphQL Playground to interact with them freely.
    Typically, protecting these graphical interfaces doesn’t make a ton of sense,
    because they are simple frontends to the API, and we could still use other clients,
    such as cURL, to perform direct API calls to the server. The API server itself
    should implement protections to avoid unauthorized API queries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器默认没有认证，这使得像 GraphiQL Explorer 和 GraphQL Playground 这样的图形界面能够自由地与服务器交互。通常，保护这些图形界面没有太大意义，因为它们只是
    API 的简单前端，我们仍然可以使用其他客户端（例如 cURL）直接调用 API 服务。API 服务器本身应该实现保护机制，以避免未经授权的 API 查询。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you received an introduction to GraphQL. We covered what GraphQL
    is and the problems it attempts to solve. We also walked through examples that
    demonstrate the fundamental differences between REST and GraphQL APIs, and why
    it’s important to understand these differences in the context of security. Additionally,
    you had your first hands-on experience of querying a GraphQL API by using the
    GraphiQL Explorer tool.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 GraphQL 的基础知识。我们讲解了什么是 GraphQL 以及它试图解决的问题。我们还通过示例展示了 REST 和 GraphQL API
    之间的根本区别，并讨论了在安全性背景下理解这些区别的重要性。此外，你还通过使用 GraphiQL Explorer 工具进行了首次实践，体验了查询 GraphQL
    API。
