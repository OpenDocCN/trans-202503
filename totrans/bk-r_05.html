<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_59"/><span class="big"><strong>4</strong></span><br/><strong>NON-NUMERIC VALUES</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">So far, you’ve been working almost exclusively with numeric values. But statistical programming also requires non-numeric values. In this chapter, we’ll consider three important non-numeric data types: logicals, characters, and factors. These data types play an important role in effective use of R, especially as we get into more complex R programming in <a href="part02.xhtml#part02">Part II</a>.</p>&#13;
<h3 class="h3" id="ch04lev1sec16"><strong>4.1 Logical Values</strong></h3>&#13;
<p class="noindent">Logical values (also simply called <em>logicals</em>) are based on a simple premise: a logical-valued object can only be either <code>TRUE</code> or <code>FALSE</code>. These can be interpreted as yes/no, one/zero, satisfied/not satisfied, and so on. This is a concept that appears across all programming languages, and logical values have many important uses. Often, they signal whether a condition has been satisfied or whether a parameter should be switched on or off.</p>&#13;
<p class="indent">You encountered logical values briefly when you used the <code>sort</code> function in <a href="ch02.xhtml#ch02lev2sec21">Section 2.3.2</a> and the <code>matrix</code> function in <a href="ch03.xhtml#ch03lev1sec12">Section 3.1</a>. When using <code>sort</code>, setting <code>decreasing=TRUE</code> returns a vector ordered from largest to smallest, and <span epub:type="pagebreak" id="page_60"/><code>decreasing=FALSE</code> sorts the vector the other way around. Similarly, when constructing a matrix, <code>byrow=TRUE</code> fills the matrix entries row-wise; otherwise, the matrix is filled column-wise. Now, you’ll take a more detailed look at ways to use logicals.</p>&#13;
<h4 class="h4" id="ch04lev2sec37"><strong><em>4.1.1 TRUE or FALSE?</em></strong></h4>&#13;
<p class="noindent">Logical values in R are written fully as <code>TRUE</code> and <code>FALSE</code>, but they are frequently abbreviated as <code>T</code> or <code>F</code>. The abbreviated version has no effect on the execution of the code, so, for example, using <code>decreasing=T</code> is equivalent to <code>decreasing=TRUE</code> in the <code>sort</code> function. (But do not create objects named <code>T</code> or <code>F</code> if you want to make use of this convenience—see <a href="ch09.xhtml#ch09lev2sec81">Section 9.1.3</a>.)</p>&#13;
<p class="indent">Assigning logical values to an object is the same as assigning numeric values.</p>&#13;
<pre>R&gt; foo &lt;- TRUE<br/>R&gt; foo<br/>[1] TRUE<br/>R&gt; bar &lt;- F<br/>R&gt; bar<br/>[1] FALSE</pre>&#13;
<p class="indent">This gives you one object with the value <code>TRUE</code> and one with the value <code>FALSE</code>. Similarly, vectors can be filled with logical values.</p>&#13;
<pre>R&gt; baz &lt;- c(T,F,F,F,T,F,T,T,T,F,T,F)<br/>R&gt; baz<br/> [1]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE<br/>R&gt; length(x=baz)<br/>[1] 12</pre>&#13;
<p class="indent">Matrices (and other higher-dimensional arrays) can be created with these values too. Using <code>foo</code> and <code>baz</code> from earlier, you could construct something like this:</p>&#13;
<pre>R&gt; qux &lt;- matrix(data=baz,nrow=3,ncol=4,byrow=foo)<br/>R&gt; qux<br/>     [,1]  [,2]  [,3]  [,4]<br/>[1,] TRUE FALSE FALSE FALSE<br/>[2,] TRUE FALSE  TRUE  TRUE<br/>[3,] TRUE FALSE  TRUE FALSE</pre>&#13;
<h4 class="h4" id="ch04lev2sec38"><strong><em>4.1.2 A Logical Outcome: Relational Operators</em></strong></h4>&#13;
<p class="noindent">Logicals are commonly used to check relationships between values. For example, you might want to know whether some number <em>a</em> is greater than a predefined threshold <em>b</em>. For this, you use the standard <em>relational operators</em> shown in <a href="ch04.xhtml#ch4tab1">Table 4-1</a>, which produce logical values as results.</p>&#13;
<p class="tabt"><span epub:type="pagebreak" id="page_61"/><strong><a id="ch4tab1"/>Table 4-1:</strong> Relational Operators</p>&#13;
<table class="topbot1">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Interpretation</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>==</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Equal to</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>!=</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Not equal to</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Greater than</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>&lt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Less than</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>&gt;=</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Greater than or equal to</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>&lt;=</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Less than or equal to</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Typically, these operators are used on numeric values (though you’ll look at some other possibilities in <a href="ch04.xhtml#ch04lev2sec42">Section 4.2.1</a>). Here’s an example:</p>&#13;
<pre>R&gt; 1==2<br/>[1] FALSE<br/>R&gt; 1&gt;2<br/>[1] FALSE<br/>R&gt; (2-1)&lt;=2<br/>[1] TRUE<br/>R&gt; 1!=(2+3)<br/>[1] TRUE</pre>&#13;
<p class="indent">The results should be unsurprising: <code>1</code> being equal to <code>2</code> is <code>FALSE</code> and <code>1</code> being greater than <code>2</code> is also <code>FALSE</code>, while the result of <code>2-1</code> being less than or equal to <code>2</code> is <code>TRUE</code> and it is also <code>TRUE</code> that <code>1</code> is not equal to <code>5</code> (<code>2+3</code>). These kinds of operations are much more useful when used on numbers that are variable in some way, as you’ll see shortly.</p>&#13;
<p class="indent">You’re already familiar with R’s element-wise behavior when working with vectors. The same rules apply when using relational operators. To illustrate this, let’s first create two vectors and double-check that they’re of equal length.</p>&#13;
<pre>R&gt; foo &lt;- c(3,2,1,4,1,2,1,-1,0,3)<br/>R&gt; bar &lt;- c(4,1,2,1,1,0,0,3,0,4)<br/>R&gt; length(x=foo)==length(x=bar)<br/>[1] TRUE</pre>&#13;
<p class="indent">Now consider the following four evaluations:</p>&#13;
<pre>R&gt; foo==bar<br/> [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE<br/>R&gt; foo&lt;bar<br/> [1]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE<br/>R&gt; foo&lt;=bar<br/> [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE<br/>R&gt; foo&lt;=(bar+10)<br/> [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_62"/>The first line checks whether the entries in <code>foo</code> are equal to the corresponding entries in <code>bar</code>, which is true only for the fifth and ninth entries. The returned vector will contain a logical result for each pair of elements, so it will be the same length as the vectors being compared. The second line compares <code>foo</code> and <code>bar</code> in the same way, this time checking whether the entries in <code>foo</code> are less than the entries in <code>bar</code>. Contrast this result with the third comparison, which asks whether entries are less than <em>or equal to</em> one another. Finally, the fourth line checks whether <code>foo</code>’s members are less than or equal to <code>bar</code>, when the elements of <code>bar</code> are increased by <code>10</code>. Naturally, the results are all <code>TRUE</code>.</p>&#13;
<p class="indent">Vector recycling also applies to logicals. Let’s use <code>foo</code> from earlier, along with a shorter vector, <code>baz</code>.</p>&#13;
<pre>R&gt; baz &lt;- foo[c(10,3)]<br/>R&gt; baz<br/>[1] 3 1</pre>&#13;
<p class="indent">Here you create <code>baz</code> as a vector of length 2 comprised of the 10th and 3rd elements of <code>foo</code>. Now consider the following:</p>&#13;
<pre>R&gt; foo&gt;baz<br/> [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE</pre>&#13;
<p class="indent">Here, the two elements of <code>baz</code> are recycled and checked against the 10 elements of <code>foo</code>. Elements <code>1</code> and <code>2</code> of <code>foo</code> are checked against <code>1</code> and <code>2</code> of <code>baz</code>, elements <code>3</code> and <code>4</code> of <code>foo</code> are checked against <code>1</code> and <code>2</code> of <code>baz</code>, and so on. You can also check all the values of a vector against a single value. Here’s an example:</p>&#13;
<pre>R&gt; foo&lt;3<br/> [1] FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE</pre>&#13;
<p class="indent">This is a typical operation when handling data sets in R.</p>&#13;
<p class="indent">Now let’s rewrite the contents of <code>foo</code> and <code>bar</code> as 5 × 2 column-filled matrices.</p>&#13;
<pre>R&gt; foo.mat &lt;- matrix(foo,nrow=5,ncol=2)<br/>R&gt; foo.mat<br/>     [,1] [,2]<br/>[1,]    3    2<br/>[2,]    2    1<br/>[3,]    1   -1<br/>[4,]    4    0<br/>[5,]    1    3<br/>R&gt; bar.mat &lt;- matrix(bar,nrow=5,ncol=2)<br/>R&gt; bar.mat<br/>     [,1] [,2]<br/>[1,]    4    0<br/>[2,]    1    0<br/>[3,]    2    3<br/>[4,]    1    0<br/>[5,]    1    4</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>The same element-wise behavior applies here; if you compare the matrices, you get a matrix of the same size filled with logicals.</p>&#13;
<pre>R&gt; foo.mat&lt;=bar.mat<br/>      [,1]  [,2]<br/>[1,]  TRUE FALSE<br/>[2,] FALSE FALSE<br/>[3,]  TRUE  TRUE<br/>[4,] FALSE  TRUE<br/>[5,]  TRUE  TRUE<br/>R&gt; foo.mat&lt;3<br/>      [,1]  [,2]<br/>[1,] FALSE  TRUE<br/>[2,]  TRUE  TRUE<br/>[3,]  TRUE  TRUE<br/>[4,] FALSE  TRUE<br/>[5,]  TRUE FALSE</pre>&#13;
<p class="indent">This kind of evaluation also applies to arrays of more than two dimensions.</p>&#13;
<p class="indent">There are two useful functions you can use to quickly inspect a collection of logical values: <code>any</code> and <code>all</code>. When examining a vector, <code>any</code> returns <code>TRUE</code> if any of the logicals in the vector are <code>TRUE</code> and returns <code>FALSE</code> otherwise. The function <code>all</code> returns a <code>TRUE</code> only if <em>all</em> of the logicals are <code>TRUE</code>, and returns <code>FALSE</code> otherwise. As a quick example, let’s work with two of the logical vectors formed by the comparisons of <code>foo</code> and <code>bar</code> from the beginning of this section.</p>&#13;
<pre>R&gt; qux &lt;- foo==bar<br/>R&gt; qux<br/> [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE<br/>R&gt; any(qux)<br/>[1] TRUE<br/>R&gt; all(qux)<br/>[1] FALSE</pre>&#13;
<p class="indent">Here, the <code>qux</code> contains two <code>TRUE</code>s, and the rest are <code>FALSE</code>—so the result of <code>any</code> is of course <code>TRUE</code>, but the result of <code>all</code> is <code>FALSE</code>. Following the same rules, you get this:</p>&#13;
<pre>R&gt; quux &lt;- foo&lt;=(bar+10)<br/>R&gt; quux<br/> [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE<br/>R&gt; any(quux)<br/>[1] TRUE<br/>R&gt; all(quux)<br/>[1] TRUE</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>The <code>any</code> and <code>all</code> functions do the same thing for matrices and arrays of logical values.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch4exc1"/><strong>Exercise 4.1</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Store the following vector of 15 values as an object in your workspace: <code>c(6,9,7,3,6,7,9,6,3,6,6,7,1,9,1)</code>. Identify the following elements:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Those equal to 6</p></li>&#13;
<li><p class="noindent">Those greater than or equal to 6</p></li>&#13;
<li><p class="noindent">Those less than 6 + 2</p></li>&#13;
<li><p class="noindent">Those not equal to 6</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Create a new vector from the one used in (a) by deleting its first three elements. With this new vector, fill a 2 × 2 × 3 array. Examine the array for the following entries:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Those less than or equal to 6 divided by 2, plus 4</p></li>&#13;
<li><p class="noindent">Those less than or equal to 6 divided by 2, plus 4, <em>after</em> increasing every element in the array by 2</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Confirm the specific locations of elements equal to 0 in the 10 × 10 identity matrix <em>I<sub>10</sub></em> (see <a href="ch03.xhtml#ch03lev1sec14">Section 3.3</a>).</p></li>&#13;
<li><p class="noindents">Check whether <em>any</em> of the values of the logical arrays created in (b) are <code>TRUE</code>. If they are, check whether they are <em>all</em> <code>TRUE</code>.</p></li>&#13;
<li><p class="noindents">By extracting the diagonal elements of the logical matrix created in (c), use <code>any</code> to confirm there are no <code>TRUE</code> entries.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec39"><strong><em>4.1.3 Multiple Comparisons: Logical Operators</em></strong></h4>&#13;
<p class="noindent">Logicals are especially useful when you want to examine whether multiple conditions are satisfied. Often you’ll want to perform certain operations only if a number of different conditions have been met.</p>&#13;
<p class="indent">The previous section looked at relational operators, used to compare the literal values (that is, numeric or otherwise) of stored R objects. Now you’ll look at <em>logical operators</em>, which are used to compare two <code>TRUE</code> or <code>FALSE</code> objects. These operators are based on the statements AND and OR. <a href="ch04.xhtml#ch4tab2">Table 4-2</a> summarizes the R syntax and the behavior of logical operators. The AND and OR operators each have a “single” and “element-wise” version—you’ll see how they’re different in a moment.</p>&#13;
<p class="tabt"><span epub:type="pagebreak" id="page_65"/><strong><a id="ch4tab2"/>Table 4-2:</strong> Logical Operators Comparing Two Logical Values</p>&#13;
<table class="topbot1">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Interpretation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Results</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table"><code>&amp;</code></p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table">AND<br/>(element-wise)</p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table"><code>TRUE &amp; TRUE</code> is <code>TRUE</code><br/><code>TRUE &amp; FALSE</code> is <code>FALSE</code><br/><code>FALSE &amp; TRUE</code> is <code>FALSE</code><br/><code>FALSE &amp; FALSE</code> is <code>FALSE</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table"><code>&amp;&amp;</code></p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table">AND<br/>(single comparison)</p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table">Same as <code>&amp;</code> above</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table"><code>|</code></p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table">OR<br/>(element-wise)</p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table"><code>TRUE|TRUE</code> is <code>TRUE</code><br/><code>TRUE|FALSE</code> is <code>TRUE</code><br/><code>FALSE|TRUE</code> is <code>TRUE</code><br/><code>FALSE|FALSE</code> is <code>FALSE</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table"><code>||</code></p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table">OR<br/>(single comparison)</p></td>&#13;
<td style="vertical-align: middle;" class="table_1"><p class="table">Same as <code>|</code> above</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: middle;" class="table"><p class="table"><code>!</code></p></td>&#13;
<td style="vertical-align: middle;" class="table"><p class="table">NOT</p></td>&#13;
<td style="vertical-align: middle;" class="table"><p class="table"><code>!TRUE</code> is <code>FALSE<br/>!FALSE</code> is <code>TRUE</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The result of using any logical operator is a logical value. An AND comparison is true only if <em>both</em> logicals are <code>TRUE</code>. An OR comparison is true if at least one of the logicals is <code>TRUE</code>. The NOT operator (<code>!</code>) simply returns the opposite of the logical value it’s used on. You can combine these operators to examine multiple conditions at once.</p>&#13;
<pre>R&gt; FALSE||((T&amp;&amp;TRUE)||FALSE)<br/>[1] TRUE<br/>R&gt; !TRUE&amp;&amp;TRUE<br/>[1] FALSE<br/>R&gt; (T&amp;&amp;(TRUE||F))&amp;&amp;FALSE<br/>[1] FALSE<br/>R&gt; (6&lt;4)||(3!=1)<br/>[1] TRUE</pre>&#13;
<p class="indent">As with numeric arithmetic, there is an order of importance for logical operations in R. An AND statement has a higher precedence than an OR statement. It’s helpful to place each comparative pair in parentheses to preserve the correct order of evaluation and make the code more readable. You can see this in the first line of this code, where the innermost comparison is the first to be carried out: <code>T&amp;&amp;TRUE</code> results in <code>TRUE</code>; this is then provided as one of the logical values for the next bracketed comparison where <code>TRUE||FALSE</code> results in <code>TRUE</code>. The final comparison is then <code>FALSE||TRUE</code>, and the result, <code>TRUE</code>, is printed to the console. The second line reads as NOT <code>TRUE</code> AND <code>TRUE</code>, which of course returns <code>FALSE</code>. In the third line, once again the innermost pair is evaluated first: <code>TRUE||F</code> is <code>TRUE</code>; <code>T&amp;&amp;TRUE</code> is <code>TRUE</code>; and finally <code>TRUE&amp;&amp;FALSE</code> <span epub:type="pagebreak" id="page_66"/>is <code>FALSE</code>. The fourth and final example evaluates two distinct conditions in parentheses, which are then compared using a logical operator. Since <code>6&lt;4</code> is <code>FALSE</code> and <code>3!=1</code> is <code>TRUE</code>, that gives you a logical comparison of <code>FALSE||TRUE</code> and a final result of <code>TRUE</code>.</p>&#13;
<p class="indent">In <a href="ch04.xhtml#ch4tab2">Table 4-2</a>, there is a short (<code>&amp;</code>, <code>|</code>) and long (<code>&amp;&amp;</code>, <code>||</code>) version of the AND and OR operators. The short versions are meant for element-wise comparisons, where you have two logical vectors and you want multiple logicals as a result. The long versions, which you’ve been using so far, are meant for comparing two individual values and will return a single logical value. This is important when programming conditional checks in R in an <code>if</code> statement, which you’ll look at in <a href="ch10.xhtml#ch10">Chapter 10</a>. It’s possible to compare a single pair of logicals using the short version—though it’s considered better practice to use the longer versions when a single <code>TRUE</code>/<code>FALSE</code> result is needed.</p>&#13;
<p class="indent">Let’s look at some examples of element-wise comparisons. Suppose you have two vectors of equal length, <code>foo</code> and <code>bar</code>:</p>&#13;
<pre>R&gt; foo &lt;- c(T,F,F,F,T,F,T,T,T,F,T,F)<br/>R&gt; foo<br/> [1]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE</pre>&#13;
<p class="noindent">and</p>&#13;
<pre>R&gt; bar &lt;- c(F,T,F,T,F,F,F,F,T,T,T,T)<br/>R&gt; bar<br/> [1] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE</pre>&#13;
<p class="indent">The short versions of the logical operators match each pair of elements by position and return the result of the comparison.</p>&#13;
<pre>R&gt; foo&amp;bar<br/> [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE<br/>R&gt; foo|bar<br/> [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE</pre>&#13;
<p class="indent">Using the long version of the operators, on the other hand, means R carries out the comparison only on the first pair of logicals in the two vectors.</p>&#13;
<pre>R&gt; foo&amp;&amp;bar<br/>[1] FALSE<br/>R&gt; foo||bar<br/>[1] TRUE</pre>&#13;
<p class="indent">Notice that the last two results match the first entries of the vectors you got using the short versions of the logical operators.</p>&#13;
<div class="ex">&#13;
<p class="ext"><span epub:type="pagebreak" id="page_67"/><a id="ch4exc2"/><strong>Exercise 4.2</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Store the vector <code>c(7,1,7,10,5,9,10,3,10,8)</code> as <code>foo</code>. Identify the elements greater than 5 OR equal to 2.</p></li>&#13;
<li><p class="noindents">Store the vector <code>c(8,8,4,4,5,1,5,6,6,8)</code> as <code>bar</code>. Identify the elements less than or equal to 6 AND not equal to 4.</p></li>&#13;
<li><p class="noindents">Identify the elements that satisfy (a) in <code>foo</code> AND satisfy (b) in <code>bar</code>.</p></li>&#13;
<li><p class="noindents">Store a third vector called <code>baz</code> that is equal to the element-wise sum of <code>foo</code> and <code>bar</code>. Determine the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">The elements of <code>baz</code> greater than or equal to 14 but not equal to 15</p></li>&#13;
<li><p class="noindent">The elements of the vector obtained via an element-wise division of <code>baz</code> by <code>foo</code> that are greater than 4 OR less than or equal to 2</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Confirm that using the long version in all of the preceding exercises performs only the first comparison (that is, the results each match the first entries of the previously obtained vectors).</p></li>&#13;
</ol>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec40"><strong><em>4.1.4 Logicals Are Numbers!</em></strong></h4>&#13;
<p class="noindent">Because of the binary nature of logical values, they’re often represented with <code>TRUE</code> as 1 and <code>FALSE</code> as 0. In fact, in R, if you perform elementary numeric operations on logical values, <code>TRUE</code> is treated like <code>1</code>, and <code>FALSE</code> is treated like <code>0</code>.</p>&#13;
<pre>R&gt; TRUE+TRUE<br/>[1] 2<br/>R&gt; FALSE-TRUE<br/>[1] -1<br/>R&gt; T+T+F+T+F+F+T<br/>[1] 4</pre>&#13;
<p class="indent">These operations turn out the same as if you had used the digits 1 and 0. In some situations when you’d use logicals, you can substitute the numeric values.</p>&#13;
<pre>R&gt; 1&amp;&amp;1<br/>[1] TRUE<br/>R&gt; 1||0<br/>[1] TRUE<br/>R&gt; 0&amp;&amp;1<br/>[1] FALSE</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/>Being able to interpret logicals as zeros and ones means you can use a variety of functions to summarize a logical vector, and you’ll explore this further in <a href="part03.xhtml#part03">Part III</a>.</p>&#13;
<h4 class="h4" id="ch04lev2sec41"><strong><em>4.1.5 Logical Subsetting and Extraction</em></strong></h4>&#13;
<p class="noindent">Logicals can also be used to extract and subset elements in vectors and other objects, in the same way as you’ve done so far with index vectors. Rather than entering explicit indexes in the square brackets, you can supply logical <em>flag</em> vectors, where an element is extracted if the corresponding entry in the flag vector is <code>TRUE</code>. As such, logical flag vectors should be the same length as the vector that’s being accessed (though recycling does occur for shorter flag vectors, as a later example shows).</p>&#13;
<p class="indent">At the beginning of <a href="ch02.xhtml#ch02lev2sec22">Section 2.3.3</a> you defined a vector of length 10 as follows:</p>&#13;
<pre>R&gt; myvec &lt;- c(5,-2.3,4,4,4,6,8,10,40221,-8)</pre>&#13;
<p class="indent">If you wanted to extract the two negative elements, you could either enter <code>myvec[c(2,10)]</code>, or you could do the following using logical flags:</p>&#13;
<pre>R&gt; myvec[c(F,T,F,F,F,F,F,F,F,T)]<br/>[1] -2.3 -8.0</pre>&#13;
<p class="indent">This particular example may seem far too cumbersome for practical use. It becomes useful, however, when you want to extract elements based on whether they satisfy a certain condition (or several conditions). For example, you can easily use logicals to find negative elements in <code>myvec</code> by applying the condition <code>&lt;0</code>.</p>&#13;
<pre>R&gt; myvec&lt;0<br/> [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</pre>&#13;
<p class="indent">This a perfectly valid flag vector that you can use to subset <code>myvec</code> to get the same result as earlier.</p>&#13;
<pre>R&gt; myvec[myvec&lt;0]<br/>[1] -2.3 -8.0</pre>&#13;
<p class="indent">As mentioned, R recycles the flag vector if it’s too short. To extract every second element from <code>myvec</code>, starting with the first, you could enter the following:</p>&#13;
<pre>R&gt; myvec[c(T,F)]<br/>[1]     5     4     4     8 40221</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_69"/>You can do more complicated extractions using relational and logical operators, such as:</p>&#13;
<pre>R&gt; myvec[(myvec&gt;0)&amp;(myvec&lt;1000)]<br/>[1]  5  4  4  4  6  8 10</pre>&#13;
<p class="indent">This returns the positive elements that are less than 1,000. You can also overwrite specific elements using a logical flag vector, just as with index vectors.</p>&#13;
<pre>R&gt; myvec[myvec&lt;0] &lt;- -200<br/>R&gt; myvec<br/> [1]     5  -200     4     4     4     6     8     10 40221  -200</pre>&#13;
<p class="indent">This replaces all existing negative entries with −200. Note, though, that you cannot directly use negative logical flag vectors to delete specific elements; this can be done only with numeric index vectors.</p>&#13;
<p class="indent">As you can see, logicals are therefore very useful for element extraction. You don’t need to know beforehand which specific index positions to return, since the conditional check can find them for you. This is particularly valuable when you’re dealing with large data sets and you want to inspect records or recode entries that match certain criteria.</p>&#13;
<p class="indent">In some cases, you might want to convert a logical flag vector into a numeric index vector. This is helpful when you need the explicit indexes of elements that were flagged <code>TRUE</code>. The R function <code>which</code> takes in a logical vector as the argument <code>x</code> and returns the indexes corresponding to the positions of any and all <code>TRUE</code> entries.</p>&#13;
<pre>R&gt; which(x=c(T,F,F,T,T))<br/>[1] 1 4 5</pre>&#13;
<p class="indent">You can use this to identify the index positions of <code>myvec</code> that meet a certain condition; for example, those containing negative numbers:</p>&#13;
<pre>R&gt; which(x=myvec&lt;0)<br/>[1]  2 10</pre>&#13;
<p class="indent">The same can be done for the other <code>myvec</code> selections you experimented with. Note that a line of code such as <code>myvec[which(x=myvec&lt;0)]</code> is redundant because that extraction can be made using the condition by itself, that is, via <code>myvec[myvec&lt;0]</code>, without using <code>which</code>. On the other hand, using <code>which</code> lets you delete elements based on logical flag vectors. You can simply use <code>which</code> to identify the numeric indexes you want to delete and render them negative. To omit the negative entries of <code>myvec</code>, you could execute the following:</p>&#13;
<pre>R&gt; myvec[-which(x=myvec&lt;0)]<br/>[1]     5     4     4     4     6     8     10 40221</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>The same can be done with matrices and other arrays. In <a href="ch03.xhtml#ch03lev1sec13">Section 3.2</a>, you stored a 3 × 3 matrix as follows:</p>&#13;
<pre>R&gt; A &lt;- matrix(c(0.3,4.5,55.3,91,0.1,105.5,-4.2,8.2,27.9),nrow=3,ncol=3)<br/>R&gt; A<br/>     [,1]  [,2] [,3]<br/>[1,]  0.3  91.0 -4.2<br/>[2,]  4.5   0.1  8.2<br/>[3,] 55.3 105.5 27.9</pre>&#13;
<p class="indent">To extract the second and third column elements of the first row of <code>A</code> using numeric indexes, you could execute <code>A[1,2:3]</code>. To do this with logical flags, you could enter the following:</p>&#13;
<pre>R&gt; A[c(T,F,F),c(F,T,T)]<br/>[1] 91.0 -4.2</pre>&#13;
<p class="indent">Again, though, you usually wouldn’t explicitly specify the logical vectors. Suppose for example you want to replace all elements in <code>A</code> that are less than 1 with −7. Performing this using numeric indexes is rather fiddly. It’s much easier to use the logical flag matrix created with the following:</p>&#13;
<pre>R&gt; A&lt;1<br/>      [,1]  [,2]  [,3]<br/>[1,]  TRUE FALSE  TRUE<br/>[2,] FALSE  TRUE FALSE<br/>[3,] FALSE FALSE FALSE</pre>&#13;
<p class="indent">You can supply this logical matrix to the square bracket operators, and the replacement is done as follows:</p>&#13;
<pre>R&gt; A[A&lt;1] &lt;- -7<br/>R&gt; A<br/>     [,1]  [,2] [,3]<br/>[1,] -7.0  91.0 -7.0<br/>[2,]  4.5  -7.0  8.2<br/>[3,] 55.3 105.5 27.9</pre>&#13;
<p class="indent">This is the first time you’ve subsetted a matrix without having to list row or column positions inside the square brackets, using commas to separate out dimensions (see <a href="ch03.xhtml#ch03lev1sec13">Section 3.2</a>). This is because the flag matrix has the same number of rows and columns as the target matrix, thereby providing all the relevant structural information.</p>&#13;
<p class="indent">If you use <code>which</code> to identify numeric indexes based on a logical flag structure, you have to be a little more careful when dealing with two-dimensional objects or higher. Suppose you want the index positions of the elements that are greater than 25. The appropriate logical matrix is as follows.</p>&#13;
<pre><span epub:type="pagebreak" id="page_71"/>R&gt; A&gt;25<br/>      [,1]  [,2]  [,3]<br/>[1,] FALSE  TRUE FALSE<br/>[2,] FALSE FALSE FALSE<br/>[3,]  TRUE  TRUE  TRUE</pre>&#13;
<p class="indent">Now, say you ask R the following:</p>&#13;
<pre>R&gt; which(x=A&gt;25)<br/>[1] 3 4 6 9</pre>&#13;
<p class="indent">This returns the four indexes of the elements that satisfied the relational check, but they are provided as scalar values. How do these correspond to the row/column positioning of the matrix?</p>&#13;
<p class="indent">The answer lies in R’s default behavior for the <code>which</code> function, which essentially treats the multidimensional object as a single vector (laid out column after column) and then returns the vector of corresponding indexes. Say the matrix <code>A</code> was arranged as a vector by stacking the columns first through third, using <code>c(A[,1],A[,2],A[,3])</code>. Then the indexes returned make more sense.</p>&#13;
<pre>R&gt; which(x=c(A[,1],A[,2],A[,3])&gt;25)<br/>[1] 3 4 6 9</pre>&#13;
<p class="indent">With the columns laid out end to end, the elements that return <code>TRUE</code> are the third, fourth, sixth, and ninth elements in the list. This can be difficult to interpret, though, especially when dealing with higher-dimensional arrays. In this kind of situation, you can make <code>which</code> return dimension-specific indexes using the optional argument <code>arr.ind</code> (array indexes). By default, this argument is set to <code>FALSE</code>, resulting in the vector converted indexes. Setting <code>arr.ind</code> to <code>TRUE</code>, on the other hand, treats the object as a matrix or array rather than a vector, providing you with the row and column positions of the elements you requested.</p>&#13;
<pre>R&gt; which(x=A&gt;25,arr.ind=T)<br/>     row col<br/>[1,]   3   1<br/>[2,]   1   2<br/>[3,]   3   2<br/>[4,]   3   3</pre>&#13;
<p class="indent">The returned object is now a matrix, where each row represents an element that satisfied the logical comparison and each column provides the position of the element. Comparing the output here with <code>A</code>, you can see these positions do indeed correspond to elements where <code>A&gt;25</code>.</p>&#13;
<p class="indent">Both versions of the output (with <code>arr.ind=T</code> or <code>arr.ind=F</code>) can be useful—the correct choice depends on the application.</p>&#13;
<div class="ex">&#13;
<p class="ext"><span epub:type="pagebreak" id="page_72"/><a id="ch4exc3"/><strong>Exercise 4.3</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Store this vector of 10 values: <code>foo &lt;- c(7,5,6,1,2,10,8,3,8,2)</code>. Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Extract the elements greater than or equal to 5, storing the result as <code>bar</code>.</p></li>&#13;
<li><p class="noindent">Display the vector containing those elements from <code>foo</code> that remain after omitting all elements that are greater than or equal to 5.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Use <code>bar</code> from (a)(i) to construct a 2 × 3 matrix called <code>baz</code>, filled in a row-wise fashion. Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Replace any elements that are equal to 8 with the <em>squared</em> value of the element in row 1, column 2 of <code>baz</code> itself.</p></li>&#13;
<li><p class="noindent">Confirm that <em>all</em> values in <code>baz</code> are now less than or equal to 25 AND greater than 4.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Create a 3 × 2 × 3 array called <code>qux</code> using the following vector of 18 values: <code>c(10,5,1,4,7,4,3,3,1,3,4,3,1,7,8,3,7,3)</code>. Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Identify the dimension-specific index positions of elements that are either 3 OR 4.</p></li>&#13;
<li><p class="noindent">Replace all elements in <code>qux</code> that are less than 3 OR greater than or equal to 7 with the value 100.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Return to <code>foo</code> from (a). Use the vector <code>c(F,T)</code> to extract every second value from <code>foo</code>. In <a href="ch04.xhtml#ch04lev2sec40">Section 4.1.4</a>, you saw that in some situations, you can substitute <code>0</code> and <code>1</code> for <code>TRUE</code> and <code>FALSE</code>. Can you perform the same extraction from <code>foo</code> using the vector <code>c(0,1)</code>? Why or why not? What does R return in this case?</p></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec17"><strong>4.2 Characters</strong></h3>&#13;
<p class="noindent">Character strings are another common data type, and are used to represent text. In R, strings are often used to specify folder locations or software options (as shown briefly in <a href="ch01.xhtml#ch01lev1sec06">Section 1.2</a>); to supply an argument to a function; and to annotate stored objects, provide textual output, or help clarify plots and graphics. In a simple way, they can also be used to define different groups making up a categorical variable, though as you’ll see in see <a href="ch04.xhtml#ch04lev1sec18">Section 4.3</a>, <em>factors</em> are better suited for that.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There are three different string formats in the R environment. The default string format is called an</em> extended regular expression<em>; the other variants are named</em> Perl <em>and</em> literal regular expressions<em>. The intricacies of these variants are beyond the scope of this book, so any mention of character strings from here on refers to an extended regular expression. For more technical details about other string formats, enter</em> <code><span class="codeitalic">?regex</code></span> <em>at the prompt.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec42"><span epub:type="pagebreak" id="page_73"/><strong><em>4.2.1 Creating a String</em></strong></h4>&#13;
<p class="noindent">Character strings are indicated by double quotation marks, <code>"</code>. To create a string, just enter text between a pair of quotes.</p>&#13;
<pre>R&gt; foo &lt;- "This is a character string!"<br/>R&gt; foo<br/>[1] "This is a character string!"<br/>R&gt; length(x=foo)<br/>[1] 1</pre>&#13;
<p class="indent">R treats the string as a single entity. In other words, <code>foo</code> is a vector of length 1 because R counts only the total number of distinct strings rather than individual words or characters. To count the number of individual characters, you can use the <code>nchar</code> function. Here’s an example using <code>foo</code>:</p>&#13;
<pre>R&gt; nchar(x=foo)<br/>[1] 27</pre>&#13;
<p class="indent">Almost any combination of characters, including numbers, can be a valid character string.</p>&#13;
<pre>R&gt; bar &lt;- "23.3"<br/>R&gt; bar<br/>[1] "23.3"</pre>&#13;
<p class="indent">Note that in this form, the string has no numeric meaning, and it won’t be treated like the number 23.3. Attempting to multiply it by 2, for example, results in an error.</p>&#13;
<pre>R&gt; bar*2<br/>Error in bar * 2 : non-numeric argument to binary operator</pre>&#13;
<p class="indent">This error occurs because <code>*</code> is expecting to operate on two numeric values (not one number and one string, which makes no sense).</p>&#13;
<p class="indent">Strings can be compared in several ways, the most common comparison being a check for equality.</p>&#13;
<pre>R&gt; "alpha"=="alpha"<br/>[1] TRUE<br/>R&gt; "alpha"!="beta"<br/>[1] TRUE<br/>R&gt; c("alpha","beta","gamma")=="beta"<br/>[1] FALSE  TRUE FALSE</pre>&#13;
<p class="indent">Other relational operators work as you might expect. For example, R considers letters that come later in the alphabet to be greater than earlier <span epub:type="pagebreak" id="page_74"/>letters, meaning it can determine whether one string of letters is greater than another with respect to alphabetical order.</p>&#13;
<pre>R&gt; "alpha"&lt;="beta"<br/>[1] TRUE<br/>R&gt; "gamma"&gt;"Alpha"<br/>[1] TRUE</pre>&#13;
<p class="indent">Furthermore, uppercase letters are considered greater than lowercase letters.</p>&#13;
<pre>R&gt; "Alpha"&gt;"alpha"<br/>[1] TRUE<br/>R&gt; "beta"&gt;="bEtA"<br/>[1] FALSE</pre>&#13;
<p class="indent">Most symbols can also be used in a string. The following string is valid, for example:</p>&#13;
<pre>R&gt; baz &lt;- "&amp;4 _ 3 **%.? $ymbolic non$en$e ,; "<br/>R&gt; baz<br/>[1] "&amp;4 _ 3 **%.? $ymbolic non$en$e ,; "</pre>&#13;
<p class="indent">One important exception is the backslash <code>\</code>, also called an <em>escape</em>. When a backslash is used within the quotation marks of a string, it initiates some simple control over the printing or display of the string itself. You’ll see how this works in a moment in <a href="ch04.xhtml#ch04lev2sec44">Section 4.2.3</a>. First let’s look at two useful functions for combining strings.</p>&#13;
<h4 class="h4" id="ch04lev2sec43"><strong><em>4.2.2 Concatenation</em></strong></h4>&#13;
<p class="noindent">There are two main functions used to <em>concatenate</em> (or glue together) one or more strings: <code>cat</code> and <code>paste</code>. The difference between the two lies in how their contents are returned. The first function, <code>cat</code>, sends its output directly to the console screen and doesn’t formally <em>return</em> anything. The <code>paste</code> function concatenates its contents and then returns the final character string as a usable R object. This is useful when the result of a string concatenation needs to be passed to another function or used in some secondary way, as opposed to just being displayed. Consider the following vector of character strings:</p>&#13;
<pre>R&gt; qux &lt;- c("awesome","R","is")<br/>R&gt; length(x=qux)<br/>[1] 3<br/>R&gt; qux<br/>[1] "awesome" "R"       "is"</pre>&#13;
<p class="indent">As with numbers and logicals, you can also store any number of strings in a matrix or array structure if you want.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_75"/>When calling <code>cat</code> or <code>paste</code>, you pass arguments to the function in the order you want them combined. The following lines show identical usage yet different types of output from the two functions:</p>&#13;
<pre>R&gt; cat(qux[2],qux[3],"totally",qux[1],"!")<br/>R is totally awesome !<br/>R&gt; paste(qux[2],qux[3],"totally",qux[1],"!")<br/>[1] "R is totally awesome !"</pre>&#13;
<p class="indent">Here, you’ve used the three elements of <code>qux</code> as well as two additional strings, <code>"totally"</code> and <code>"!"</code>, to produce the final concatenated string. In the output, note that <code>cat</code> has simply concatenated and printed the text to the screen. This means you cannot directly assign the result to a new variable and treat it as a character string. For <code>paste</code>, however, the <code>[1]</code> to the left of the output and the presence of the <code>"</code> quotes indicate the returned item is a vector containing a character string, and this can be assigned to an object and used in other functions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There’s a slight difference between OS X and Windows in the default handling of string concatenation when using the R GUI. After calling</em> <code><span class="codeitalic">cat</code></span> <em>in Windows, the new R prompt awaiting your next command appears on the same line as the printed string, in which case you can just hit</em> <small>ENTER</small> <em>to move to the next line, or use an</em> escape sequence<em>, which you’ll look at in <a href="ch04.xhtml#ch04lev2sec44">Section 4.2.3</a>. In OS X, the new prompt appears on the next line as usual.</em></p>&#13;
</div>&#13;
<p class="indent">These two functions have an optional argument, <code>sep</code>, that’s used as a separator between strings as they’re concatenated. You pass <code>sep</code> a character string, and it will place this string between all other strings you’ve provided to <code>paste</code> or <code>cat</code>. For example:</p>&#13;
<pre>R&gt; paste(qux[2],qux[3],"totally",qux[1],"!",sep="---")<br/>[1] "R---is---totally---awesome---!"<br/>R&gt; paste(qux[2],qux[3],"totally",qux[1],"!",sep="")<br/>[1] "Ristotallyawesome!"</pre>&#13;
<p class="indent">The same behavior would occur for <code>cat</code>. Note that if you don’t want any separation, you set <code>sep=""</code>, an empty string, as shown in the second example. The empty string separator can be used to achieve correct sentence spacing; note the gap between <code>awesome</code> and the exclamation mark in the previous code when you first used <code>paste</code> and <code>cat</code>. If the <code>sep</code> argument isn’t included, R will insert a space between strings by default.</p>&#13;
<p class="indent">For example, using manual insertion of spaces where necessary, you can write the following:</p>&#13;
<pre>R&gt; cat("Do you think ",qux[2]," ",qux[3]," ",qux[1],"?",sep="")<br/>Do you think R is awesome?</pre>&#13;
<p class="indent">Concatenation can be useful when you want to neatly summarize the results from a certain function or set of calculations. Many kinds of R objects <span epub:type="pagebreak" id="page_76"/>can be passed directly to <code>paste</code> or <code>cat</code>; the software will attempt to automatically <em>coerce</em> these items into character strings. This means R will convert the input into a string so the values can be included in the final concatenated string. This works particularly well with numeric objects, as the following examples demonstrate:</p>&#13;
<pre>R&gt; a &lt;- 3<br/>R&gt; b &lt;- 4.4<br/>R&gt; cat("The value stored as 'a' is ",a,".",sep="")<br/>The value stored as 'a' is 3.<br/>R&gt; paste("The value stored as 'b' is ",b,".",sep="")<br/>[1] "The value stored as 'b' is 4.4."<br/>R&gt; cat("The result of a+b is ",a,"+",b,"=",a+b,".",sep="")<br/>The result of a+b is 3+4.4=7.4.<br/>R&gt; paste("Is ",a+b," less than 10? That's totally ",a+b&lt;10,".",sep="")<br/>[1] "Is 7.4 less than 10? That's totally TRUE."</pre>&#13;
<p class="indent">Here, the values of the non-string objects are placed where you want them in the final string output. The results of calculations can also appear as fields, as shown with the arithmetic <code>a+b</code> and the logical comparison <code>a+b&lt;10</code>. You’ll see more details about coercion from one kind of value to another in <a href="ch06.xhtml#ch06lev2sec62">Section 6.2.4</a>.</p>&#13;
<h4 class="h4" id="ch04lev2sec44"><strong><em>4.2.3 Escape Sequences</em></strong></h4>&#13;
<p class="noindent">In <a href="ch04.xhtml#ch04lev2sec42">Section 4.2.1</a>, I noted that a stand-alone backslash doesn’t act like a normal character within a string. The <code>\</code> is used to invoke an <em>escape sequence</em>. An escape sequence lets you enter characters that control the format and spacing of the string, rather than being interpreted as normal text. <a href="ch04.xhtml#ch4tab3">Table 4-3</a> describes some of the most common escape sequences, and you can find a full list by entering <code>?Quotes</code> at the prompt.</p>&#13;
<p class="tabt"><strong><a id="ch4tab3"/>Table 4-3:</strong> Common Escape Sequences for Use in Character Strings</p>&#13;
<table class="topbot1">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Escape sequence</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Result</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>\n</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Starts a newline</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>\t</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Horizontal tab</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>\b</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Invokes a backspace</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>\\</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Used as a single backslash</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>\"</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Includes a double quote</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Escape sequences add flexibility to the display of character strings, which can be useful for summaries of results and plot annotations. You enter the sequence precisely where you want it to take effect. Let’s look at an example.</p>&#13;
<pre><span epub:type="pagebreak" id="page_77"/>R&gt; cat("here is a string\nsplit\tto neww\b\n\n\tlines")<br/>here is a string<br/>split    to new<br/><br/>    lines</pre>&#13;
<p class="indent">Since the signal for an escape is <code>\</code> and the signal to begin and end a string is <code>"</code>, if you want either of these characters to be included in a string, you must also use an escape to have them be interpreted as a normal character.</p>&#13;
<pre>R&gt; cat("I really want a backslash: \\\nand a double quote: \"")<br/>I really want a backslash: \<br/>and a double quote: "</pre>&#13;
<p class="indent">These escape sequences mean that you can’t use a stand-alone backslash in file path strings in R. As noted in <a href="ch01.xhtml#ch01lev2sec08">Section 1.2.3</a> (where you used <code>getwd</code> to print the current working directory and <code>setwd</code> to change it), folder separation must use a forward slash <code>/</code> and not a backslash.</p>&#13;
<pre>R&gt; setwd("/folder1/folder2/folder3/")</pre>&#13;
<p class="indent">File path specification crops up when reading and writing files, which you’ll explore in <a href="ch08.xhtml#ch08">Chapter 8</a>.</p>&#13;
<h4 class="h4" id="ch04lev2sec45"><strong><em>4.2.4 Substrings and Matching</em></strong></h4>&#13;
<p class="noindent"><em>Pattern matching</em> lets you inspect a given string to identify smaller strings within it.</p>&#13;
<p class="indent">The function <code>substr</code> takes a string <code>x</code> and extracts the part of the string between two character positions (inclusive), indicated with numbers passed as <code>start</code> and <code>stop</code> arguments. Let’s try it on the object <code>foo</code> from <a href="ch04.xhtml#ch04lev2sec42">Section 4.2.1</a>.</p>&#13;
<pre>R&gt; foo &lt;- "This is a character string!"<br/>R&gt; substr(x=foo,start=21,stop=27)<br/>[1] "string!"</pre>&#13;
<p class="indent">Here, you’ve extracted the characters between positions 21 and 27, inclusive, to get <code>"string!"</code>. The function <code>substr</code> can also be used with the assignment operator to directly substitute in a new set of characters. In this case, the replacement string should contain the same number of characters as the selected area.</p>&#13;
<pre>R&gt; substr(x=foo,start=1,stop=4) &lt;- "Here"<br/>R&gt; foo<br/>[1] "Here is a character string!"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_78"/>If the replacement string is longer than the number of characters indicated by <code>start</code> and <code>stop</code>, then replacement still takes place, beginning at <code>start</code> and ending at <code>stop</code>. It cuts off any characters that overrun the number of characters you’re replacing. If the string is shorter than the number of characters you’re replacing, then replacement ends when the string is fully inserted, leaving the original characters up to <code>stop</code> untouched.</p>&#13;
<p class="indent">Substitution is more flexible using the functions <code>sub</code> and <code>gsub</code>. The <code>sub</code> function searches a given string <code>x</code> for a smaller string <code>pattern</code> contained within. It then replaces the first instance with a new string, given as the argument <code>replacement</code>. The <code>gsub</code> function does the same thing, but it replaces <em>every</em> instance of <code>pattern</code>. Here’s an example:</p>&#13;
<pre>R&gt; bar &lt;- "How much wood could a woodchuck chuck"<br/>R&gt; sub(pattern="chuck",replacement="hurl",x=bar)<br/>[1] "How much wood could a woodhurl chuck"<br/>R&gt; gsub(pattern="chuck",replacement="hurl",x=bar)<br/>[1] "How much wood could a woodhurl hurl"</pre>&#13;
<p class="indent">With <code>sub</code> and <code>gsub</code>, the <code>replacement</code> value need not have the same number of characters as the <code>pattern</code> being replaced. These functions also have search options like case-sensitivity. The help files <code>?substr</code> and <code>?sub</code> have more details, as well as noting a handful of other pattern-matching functions and techniques. You might also want to check out the <code>grep</code> command and its variants; see the relevant help file <code>?grep</code>.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch4exc4"/><strong>Exercise 4.4</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Re-create exactly the following output:</p>&#13;
<pre>"The quick brown fox<br/>    jumped over<br/>        the lazy dogs"</pre></li>&#13;
<li><p class="noindents">Suppose you’ve stored the values <code>num1 &lt;- 4</code> and <code>num2 &lt;- 0.75</code>. Write a line of R code that returns the following string:</p>&#13;
<pre>[1] "The result of multiplying 4 by 0.75 is 3"</pre>&#13;
<p class="indent">Make sure your code produces a string with the correct multiplication result for <em>any</em> two numbers stored as <code>num1</code> and <code>num2</code>.</p></li>&#13;
<li><p class="noindents">On my local machine, the directory for my work on this book is specified in R as <code>"/Users/tdavies/Documents/RBook/"</code>. Imagine it is your machine—write a line of code that replaces <code><span class="codeitalic">tdavies</code></span> in this string with your first initial and surname.</p></li>&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_79"/>In <a href="ch04.xhtml#ch04lev2sec45">Section 4.2.4</a>, you stored the following string:</p>&#13;
<pre>R&gt; bar &lt;- "How much wood could a woodchuck chuck"</pre>&#13;
<ol type="i">&#13;
<li><p class="noindents">Store a new string by gluing onto <code>bar</code> the words <code>"if a woodchuck could chuck wood"</code>.</p></li>&#13;
<li><p class="noindents">In the result of (i), replace all instances of <code>wood</code> with <code>metal</code>.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Store the string <code>"Two 6-packs for $12.99"</code>. Then do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Use a check for equality to confirm that the substring beginning with character 5 and ending with character 10 is <code>"6-pack"</code>.</p></li>&#13;
<li><p class="noindents">Make it a better deal by changing the price to $10.99.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec18"><strong>4.3 Factors</strong></h3>&#13;
<p class="noindent">In this section, you’ll look at some simple functions related to creating, handling, and inspecting <em>factors</em>. Factors are R’s most natural way of representing data points that fit in only one of a finite number of distinct categories, rather than belonging to a continuum. Categorical data like this can play an important role in data science, and you’ll look at factors again in more detail from a statistical perspective in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>&#13;
<h4 class="h4" id="ch04lev2sec46"><strong><em>4.3.1 Identifying Categories</em></strong></h4>&#13;
<p class="noindent">To see how factors work, let’s start with a simple data set. Suppose you find eight people and record their first name, sex, and month of birth in <a href="ch04.xhtml#ch4tab4">Table 4-4</a>.</p>&#13;
<p class="tabt"><strong><a id="ch4tab4"/>Table 4-4:</strong> An Example Data Set of Eight Individuals</p>&#13;
<table class="topbot1">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Person</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Sex</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Month of birth</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Liz</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Female</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">April</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jolene</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Female</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">January</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Susan</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Female</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">December</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Boris</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Male</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">September</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Rochelle</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Female</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">November</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Tim</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Male</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">July</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Simon</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Male</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">July</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Amy</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Female</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">June</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>There’s really only one sensible way to represent the name of each person in R—as a vector of character strings.</p>&#13;
<pre>R&gt; firstname &lt;- c("Liz","Jolene","Susan","Boris","Rochelle","Tim","Simon",<br/>                  "Amy")</pre>&#13;
<p class="indent">You have more flexibility when it comes to recording sex, however. Coding females as 0 and males as 1, a numeric option would be as follows:</p>&#13;
<pre>R&gt; sex.num &lt;- c(0,0,0,1,0,1,1,0)</pre>&#13;
<p class="indent">Of course, character strings are also possible, and many prefer this because you don’t need to remember the numeric code for each group.</p>&#13;
<pre>R&gt; sex.char &lt;- c("female","female","female","male","female","male","male",<br/>                 "female")</pre>&#13;
<p class="indent">There is, however, a fundamental difference between an individual’s name and their sex when stored as data. Where a person’s name is a unique identifier that can take any one of an infinite number of possibilities, there are generally only two options for recording a person’s sex. These kinds of data, where all possible values fall into a finite number of categories, are best represented in R using factors.</p>&#13;
<p class="indent">Factors are typically created from a numeric or a character vector (note that you cannot fill matrices or multidimensional arrays using factor values; factors can only take the form of vectors). To create a factor vector, use the function <code>factor</code>, as in this example working with <code>sex.num</code> and <code>sex.char</code>:</p>&#13;
<pre>R&gt; sex.num.fac &lt;- factor(x=sex.num)<br/>R&gt; sex.num.fac<br/>[1] 0 0 0 1 0 1 1 0<br/>Levels: 0 1<br/>R&gt; sex.char.fac &lt;- factor(x=sex.char)<br/>R&gt; sex.char.fac<br/>[1] female female female male   female male male female<br/>Levels: female male</pre>&#13;
<p class="indent">Here, you obtain factor versions of the two vectors storing gender values.</p>&#13;
<p class="indent">At first glance, these objects don’t look much different from the character and numeric vectors from which they were created. Indeed, factor objects work in much the same way as vectors, but with a little extra information attached (R’s internal representation of factor objects is a little different as well). Functions like <code>length</code> and <code>which</code> work the same way on factor objects as with vectors, for example.</p>&#13;
<p class="indent">The most important extra piece of information (or <em>attribute</em>; see <a href="ch06.xhtml#ch06lev2sec59">Section 6.2.1</a>) that a factor object contains is its <em>levels</em>, which store the possible values in the factor. These levels are printed at the bottom of each factor <span epub:type="pagebreak" id="page_81"/>vector. You can extract the levels as a vector of character strings using the <code>levels</code> function.</p>&#13;
<pre>R&gt; levels(x=sex.num.fac)<br/>[1] "0" "1"<br/>R&gt; levels(x=sex.char.fac)<br/>[1] "female" "male"</pre>&#13;
<p class="indent">You can also relabel a factor using <code>levels</code>. Here’s an example:</p>&#13;
<pre>R&gt; levels(x=sex.num.fac) &lt;- c("1","2")<br/>R&gt; sex.num.fac<br/>[1] 1 1 1 2 1 2 2 1<br/>Levels: 1 2</pre>&#13;
<p class="indent">This relabels the females <code>1</code> and the males <code>2</code>.</p>&#13;
<p class="indent">Factor-valued vectors are subsetted in the same way as any other vector.</p>&#13;
<pre>R&gt; sex.char.fac[2:5]<br/>[1] female female male   female<br/>Levels: female male<br/>R&gt; sex.char.fac[c(1:3,5,8)]<br/>[1] female female female female female<br/>Levels: female male</pre>&#13;
<p class="indent">Note that after subsetting a factor object, the object continues to store <em>all</em> defined levels even if some of the levels are no longer represented in the subsetted object.</p>&#13;
<p class="indent">If you want to subset from a factor using a logical flag vector, keep in mind that the levels of a factor are stored as character strings, even if the original data vector was numeric, so you need to use a string when requesting or testing for a particular level. To, for example, identify all the men using the newly relabeled <code>sex.num.fac</code>, use this:</p>&#13;
<pre>R&gt; sex.num.fac=="2"<br/>[1] FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE</pre>&#13;
<p class="indent">Since the elements in <code>firstname</code> and <code>sex</code> have corresponding positions in their factor vectors, you can then use this logical vector to obtain the names of all the men (this time using the <code>"male"</code>/<code>"female"</code> factor vector).</p>&#13;
<pre>R&gt; firstname[sex.char.fac=="male"]<br/>[1] "Boris" "Tim"   "Simon"</pre>&#13;
<p class="indent">Of course, this simple subsetting could have been achieved in much the same way with the raw numeric vector <code>sex.num</code> or the raw character vector <code>sex.char</code>. In the next section, you’ll explore some more distinctive advantages to having categorical data represented as a factor in R.</p>&#13;
<h4 class="h4" id="ch04lev2sec47"><span epub:type="pagebreak" id="page_82"/><strong><em>4.3.2 Defining and Ordering Levels</em></strong></h4>&#13;
<p class="noindent">The sex factor from the previous section represents the simplest kind of factor variable—there are only two possible levels with no ordering, in that one level is not intuitively considered “higher than” or “following” the other. Here you’ll look at factors with levels that can be logically ordered; for example, month of birth (MOB), where there are 12 levels that have a natural order. Let’s store the observed MOB data from earlier as a character vector.</p>&#13;
<pre>R&gt; mob &lt;- c("Apr","Jan","Dec","Sep","Nov","Jul","Jul","Jun")</pre>&#13;
<p class="indent">There are two problems with the data in this vector. First, not all possible categories are represented since <code>mob</code> contains only seven unique months. Second, this vector doesn’t reflect the natural order of the months. If you compare January and December to see which is greater, you get:</p>&#13;
<pre>R&gt; mob[2]<br/>[1] "Jan"<br/>R&gt; mob[3]<br/>[1] "Dec"<br/>R&gt; mob[2]&lt;mob[3]<br/>[1] FALSE</pre>&#13;
<p class="indent">Alphabetically, this result is of course correct—<em>J</em> doesn’t occur before <em>D</em>. But in terms of the order of the calendar months, which is what we’re interested in, the <code>FALSE</code> result is incorrect.</p>&#13;
<p class="indent">If you create a factor object from these values, you can deal with both of these problems by supplying additional arguments to the <code>factor</code> function. You can define additional levels by supplying a character vector of all possible values to the <code>levels</code> argument and then instruct R to order the values precisely as they appear in <code>levels</code> by setting the argument <code>ordered</code> to <code>TRUE</code>.</p>&#13;
<pre>R&gt; ms &lt;- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov",<br/>           "Dec")<br/>R&gt; mob.fac &lt;- factor(x=mob,levels=ms,ordered=TRUE)<br/>R&gt; mob.fac<br/>[1] Apr Jan Dec Sep Nov Jul Jul Jun<br/>Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; Oct &lt; Nov &lt; Dec</pre>&#13;
<p class="indent">Here, the <code>mob.fac</code> vector contains the same individual entries at the same index positions as the <code>mob</code> vector from earlier. But notice that this variable has 12 levels, even though you have not made any observations for the levels <code>"Feb"</code>, <code>"Mar"</code>, <code>"May"</code>, <code>"Aug"</code>, or <code>"Oct"</code>. (Note that if your R console window is too narrow to print all the levels to the screen, you may see a <code>...</code>, indicating there’s more output that’s been hidden. Just widen your window and reprint the object to see the hidden levels.) Also, the strict order of these levels is <span epub:type="pagebreak" id="page_83"/>shown by the <code>&lt;</code> symbol in the object output. Using this new factor object, you can perform the relational comparison from earlier and get the result you might expect.</p>&#13;
<pre>R&gt; mob.fac[2]<br/>[1] Jan<br/>Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; Oct &lt; Nov &lt; Dec<br/>R&gt; mob.fac[3]<br/>[1] Dec<br/>Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; Oct &lt; Nov &lt; Dec<br/>R&gt; mob.fac[2]&lt;mob.fac[3]<br/>[1] TRUE</pre>&#13;
<p class="indent">These improvements are far from just cosmetic. There’s a big difference, for example, between a data set with zero observations in some of the categories and the same data set defined with fewer categories to begin with. The choice of whether to instruct R to formally order a factor vector can also have important consequences in the implementation of various statistical methods, such as regression and other types of modeling.</p>&#13;
<h4 class="h4" id="ch04lev2sec48"><strong><em>4.3.3 Combining and Cutting</em></strong></h4>&#13;
<p class="noindent">As you’ve seen, it’s usually simple to combine multiple vectors of the same kind (whether numeric, logical, or character) using the <code>c</code> function. Here’s an example:</p>&#13;
<pre>R&gt; foo &lt;- c(5.1,3.3,3.1,4)<br/>R&gt; bar &lt;- c(4.5,1.2)<br/>R&gt; c(foo,bar)<br/>[1] 5.1 3.3 3.1 4.0 4.5 1.2</pre>&#13;
<p class="indent">This combines the two numeric vectors into one.</p>&#13;
<p class="indent">However, the <code>c</code> function doesn’t work the same way with factor-valued vectors. Let’s see what happens when you use it on the data in <a href="ch04.xhtml#ch4tab4">Table 4-4</a> and the MOB factor vector <code>mob.fac</code>, from <a href="ch04.xhtml#ch04lev2sec47">Section 4.3.2</a>. Suppose you now observe three more individuals with MOB values <code>"Oct"</code>, <code>"Feb"</code>, and <code>"Feb"</code>, which are stored as a factor object, as follows.</p>&#13;
<pre>R&gt; new.values &lt;- factor(x=c("Oct","Feb","Feb"),levels=levels(mob.fac),<br/>                        ordered=TRUE)<br/>R&gt; new.values<br/>[1] Oct Feb Feb<br/>Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; Oct &lt; Nov &lt; Dec</pre>&#13;
<p class="indent">Now you have <code>mob.fac</code> with the original eight observations and <code>new.values</code> with an additional three. Both are factor objects, defined with identical, ordered levels. You might expect that you can just use <code>c</code> to combine the two as follows.</p>&#13;
<pre><span epub:type="pagebreak" id="page_84"/>R&gt; c(mob.fac,new.values)<br/> [1]  4  1 12  9 11  7  7  6 10  2  2</pre>&#13;
<p class="indent">Clearly, this has not done what you want it to do. Combining the two factor objects resulted in a numeric vector. This is because the <code>c</code> function interprets factors as integers. Comparing this with the defined levels, you can see that the numbers refer to the index of each month within the ordered levels.</p>&#13;
<pre>R&gt; levels(mob.fac)<br/> [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"</pre>&#13;
<p class="indent">This means you can use these integers with <code>levels(mob.fac)</code> to retrieve a character vector of the complete observed data—the original eight observations plus the additional three.</p>&#13;
<pre>R&gt; levels(mob.fac)[c(mob.fac,new.values)]<br/> [1] "Apr" "Jan" "Dec" "Sep" "Nov" "Jul" "Jul" "Jun" "Oct" "Feb" "Feb"</pre>&#13;
<p class="indent">Now you have all the observations stored in a vector, but they are currently stored as strings, not factor values. The final step is to turn this vector into a factor object.</p>&#13;
<pre>R&gt; mob.new &lt;- levels(mob.fac)[c(mob.fac,new.values)]<br/>R&gt; mob.new.fac &lt;- factor(x=mob.new,levels=levels(mob.fac),ordered=TRUE)<br/>R&gt; mob.new.fac<br/> [1] Apr Jan Dec Sep Nov Jul Jul Jun Oct Feb Feb<br/>Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; Oct &lt; Nov &lt; Dec</pre>&#13;
<p class="indent">As this example shows, combining factors requires you to essentially deconstruct the two objects, obtaining the numeric index positions of each entry with respect to the factor levels, and then rebuild them together. This helps ensure that the levels are consistent and the observations are valid in the final product.</p>&#13;
<p class="indent">Factors are also often created from data that was originally measured on a continuum, for example the weight of a set of adults or the amount of a drug given to a patient. Sometimes you’ll need to group (or <em>bin</em>) these types of observations into categories, like Small/Medium/Large or Low/High. In R, you can mold this kind of data into discrete factor categories using the <code>cut</code> function. Consider the following numeric vector of length 10:</p>&#13;
<pre>R&gt; Y &lt;- c(0.53,5.4,1.5,3.33,0.45,0.01,2,4.2,1.99,1.01)</pre>&#13;
<p class="indent">Suppose you want to bin the data as follows: <em>Small</em> refers to observations in the interval [0,2), <em>Medium</em> refers to [2,4), and <em>Large</em> refers <span epub:type="pagebreak" id="page_85"/>to [4,6]. A square bracket refers to <em>inclusion</em> of its nearest value, and a parenthesis indicates <em>exclusion</em>, so an observation <em>y</em> will fall in the Small interval if 0 ≤ <em>y</em> &lt; 2, in Medium if 2 ≤ <em>y</em> &lt; 4, or in Large if 4 ≤ <em>y</em> ≤ 6. For this you’d use <code>cut</code> and supply your desired break intervals to the <code>breaks</code> argument:</p>&#13;
<pre>R&gt; br &lt;- c(0,2,4,6)<br/>R&gt; cut(x=Y,breaks=br)<br/> [1] (0,2] (4,6] (0,2] (2,4] (0,2] (0,2] (0,2] (4,6] (0,2] (0,2]<br/>Levels: (0,2] (2,4] (4,6]</pre>&#13;
<p class="indent">This gives you a factor, with each observation now assigned an interval. However, notice that your boundary intervals are back-to-front—you want the boundary levels on the left like [0,2), rather than the right as they appear by default, (0,2]. You can fix this by setting the logical argument <code>right</code> to <code>FALSE</code>.</p>&#13;
<pre>R&gt; cut(x=Y,breaks=br,right=F)<br/> [1] [0,2) [4,6) [0,2) [2,4) [0,2) [0,2) [2,4) [4,6) [0,2) [0,2)<br/>Levels: [0,2) [2,4) [4,6)</pre>&#13;
<p class="indent">Now you’ve swapped which boundaries are inclusive and exclusive. This is important because it changes which categories the values fall into. Notice that the seventh observation has changed categories. But there’s still a problem: the final interval currently <em>excludes</em> 6, and you want this maximum value to be <em>included</em> in the highest level. You can fix this with another logical argument: <code>include.lowest</code>. Even though it’s called “<code>include.lowest</code>,” this argument can also be used to include the <em>highest</em> value if <code>right</code> is <code>FALSE</code>, as indicated in the help file <code>?cut</code>.</p>&#13;
<pre>R&gt; cut(x=Y,breaks=br,right=F,include.lowest=T)<br/> [1] [0,2) [4,6] [0,2) [2,4) [0,2) [0,2) [2,4) [4,6] [0,2) [0,2)<br/>Levels: [0,2) [2,4) [4,6]</pre>&#13;
<p class="indent">The intervals are now defined how you want. Finally, you want to add better labels to the categories, rather than using the interval levels that R applies by default, by passing a character string vector to the <code>labels</code> argument. The order of labels must match the order of the levels in the factor object.</p>&#13;
<pre>R&gt; lab &lt;- c("Small","Medium","Large")<br/>R&gt; cut(x=Y,breaks=br,right=F,include.lowest=T,labels=lab)<br/> [1] Small  Large  Small  Medium Small  Small  Medium Large  Small  Small<br/>Levels: Small Medium Large</pre>&#13;
<div class="ex">&#13;
<p class="ext"><span epub:type="pagebreak" id="page_86"/><a id="ch4exc5"/><strong>Exercise 4.5</strong></p>&#13;
<p class="noindentz">The New Zealand government consists of the political parties National, Labour, Greens, and M<span class="ent">ā</span>ori, with several smaller parties labeled as Other. Suppose you asked 20 New Zealanders which of these they identified most with and obtained the following data:</p>&#13;
<p class="bullz">• There were 12 males and 8 females; the individuals numbered 1, 5–7, 12, and 14–16 were females.</p>&#13;
<p class="bullz">• The individuals numbered 1, 4, 12, 15, 16, and 19 identified with Labour; no one identified with M<span class="ent">ā</span>ori; the individuals numbered 6, 9, and 11 identified with Greens; 10 and 20 identified with Other; and the rest identified with National.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Use your knowledge of vectors (for example, subsetting and overwriting) to create two character vectors: <code>sex</code> with entries <code>"M"</code> (male) and <code>"F"</code> (female) and <code>party</code> with entries <code>"National"</code>, <code>"Labour"</code>, <code>"Greens"</code>, <code>"Maori"</code>, and <code>"Other"</code>. Make sure the entries are placed in the correct positions as outlined earlier.</p></li>&#13;
<li><p class="noindents">Create two different factor vectors based on <code>sex</code> and <code>party</code>. Does it make any sense to use <code>ordered=TRUE</code> in either case? How has R appeared to arrange the levels?</p></li>&#13;
<li><p class="noindents">Use factor subsetting to do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Return the factor vector of chosen parties for only the male participants.</p></li>&#13;
<li><p class="noindent">Return the factor vector of genders for those who chose National.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Another six people joined the survey, with the results <code>c("National","Maori","Maori","Labour","Greens","Labour")</code> for the preferred party and <code>c("M","M","F","F","F","M")</code> as their gender. Combine these results with the original factors from (b).</p></li>&#13;
</ol>&#13;
<p class="indentz">Suppose you also asked all individuals to state how confident they were that Labour will win more seats in Parliament than National in the next election and to attach a subjective percentage to that confidence. The following 26 results were obtained: 93, 55, 29, 100, 52, 84, 56, 0, 33, 52, 35, 53, 55, 46, 40, 40, 56, 45, 64, 31, 10, 29, 40, 95, 18, 61.</p>&#13;
<ol type="a" start="5">&#13;
<li><p class="noindents">Create a factor with levels of confidence as follows: Low for percentages [0,30]; Moderate for percentages (30,70]; and High for percentages (70,100].</p></li>&#13;
<li><p class="noindents">From (e), extract the levels corresponding to those individuals who originally said they identified with Labour. Do this also for National. What do you notice?</p></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch04lev3sec11"><span epub:type="pagebreak" id="page_87"/><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>TRUE</code>, <code>FALSE</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Reserved logical values</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec37">Section 4.1.1</a>, <a href="ch04.xhtml#page_60">p. 60</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>T</code>, <code>F</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Unreserved versions of above</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec37">Section 4.1.1</a>, <a href="ch04.xhtml#page_60">p. 60</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">relational operators</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec38">Section 4.1.2</a>, <a href="ch04.xhtml#page_61">p. 61</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>any</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Checks whether any entries are <code>TRUE</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec38">Section 4.1.2</a>, <a href="ch04.xhtml#page_63">p. 63</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>all</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Checks whether all entries are <code>TRUE</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec38">Section 4.1.2</a>, <a href="ch04.xhtml#page_63">p. 63</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>&amp;&amp;</code>, <code>&amp;</code>, <code>||</code>, <code>|</code>, <code>!</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">logical operators</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec39">Section 4.1.3</a>, <a href="ch04.xhtml#page_65">p. 65</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>which</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Determines indexes of <code>TRUE</code>s</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec41">Section 4.1.5</a>, <a href="ch04.xhtml#page_69">p. 69</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>" "</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Creates a character string</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec42">Section 4.2.1</a>, <a href="ch04.xhtml#page_73">p. 73</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>nchar</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Gets number of characters in a string</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec42">Section 4.2.1</a>, <a href="ch04.xhtml#page_73">p. 73</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>cat</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Concatenates strings (no return)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec43">Section 4.2.2</a>, <a href="ch04.xhtml#page_74">p. 74</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>paste</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pastes strings (returns a string)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec43">Section 4.2.2</a>, <a href="ch04.xhtml#page_74">p. 74</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>\</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">String escape</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec44">Section 4.2.3</a>, <a href="ch04.xhtml#page_76">p. 76</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>substr</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Subsets a string</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec45">Section 4.2.4</a>, <a href="ch04.xhtml#page_77">p. 77</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>sub</code>, <code>gsub</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">String matching and replacement</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec45">Section 4.2.4</a>, <a href="ch04.xhtml#page_78">p. 78</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>factor</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Creates a factor vector</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec46">Section 4.3.1</a>, <a href="ch04.xhtml#page_80">p. 80</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>levels</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Gets levels of a factor</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec46">Section 4.3.1</a>, <a href="ch04.xhtml#page_81">p. 81</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>cut</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Creates factor from continuum</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch04.xhtml#ch04lev2sec48">Section 4.3.3</a>, <a href="ch04.xhtml#page_85">p. 85</a><span epub:type="pagebreak" id="page_88"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>