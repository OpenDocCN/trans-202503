<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="139" id="Page_139"/>7</span><br/>
<span class="ChapterTitle">Web Applications</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">This chapter will help you understand how WebAssembly interacts with the DOM through JavaScript. Although it might seem cumbersome, it’s a necessary evil to understand WebAssembly and its strengths and weaknesses. If you’re using a WebAssembly toolchain, you need to know how much additional code that toolchain will generate as JavaScript glue code. From this point forward, most of the examples will run from a web page instead of using <code>node</code> from the command line.</p>
<p>We’ll begin by creating a simple static web server using Node.js. WebAssembly web applications cannot be loaded directly from the filesystem in a web browser; instead, they require you to run a web server. Node.js provides all the tools we need to create a web server. We’ll then write our first WebAssembly web application.</p>
<p><span epub:type="pagebreak" title="140" id="Page_140"/>The second web application we’ll write reuses functions we wrote in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> to take in a number from an input element in the HTML and pass it into WebAssembly, which converts the number into a decimal, hexadecimal, and binary string.</p>
<p>By the end of this chapter, you’ll understand the basics of writing a web application that loads and instantiates a WebAssembly module and then calls functions from within that module. The applications will also write data from those modules to DOM elements. The examples in this chapter aren’t representative of the types of applications you would typically write with WebAssembly. They only demonstrate how a web page can load, instantiate, and interact with WebAssembly modules.</p>
<h2 id="h1-501737c07-0001">The DOM</h2>
<p class="BodyFirst">Modern web-based applications are so sophisticated it’s easy to forget that an HTML page, at its core, is a simple document. The web was conceived as a means to share documents and information, but it soon became apparent that we needed a standard method for dynamically updating those documents using a language like JavaScript or Java. The DOM was designed as a language-independent interface for manipulating HTML and XML documents. Because an HTML document is a tree structure, the DOM represents a document as a logical tree. The DOM is how JavaScript and other languages modify the HTML in a web application.</p>
<p>The WebAssembly 1.0 release has no means of directly manipulating the DOM, so the JavaScript must make all modifications to the HTML document. If you’re using a toolchain, such as Rust or Emscripten, manipulation of the DOM is usually done from JavaScript glue code. As a general rule, the WebAssembly portion of a web application should focus on working with numeric data, but with the DOM most of the data processing will likely be string manipulation. The performance of string manipulation from within WebAssembly is entirely dependent on the library you use for the task. For this reason, DOM heavy work is usually best kept in the JavaScript portion of the app.</p>
<h2 id="h1-501737c07-0002">Setting Up a Simple Node Server</h2>
<p class="BodyFirst">To set up a static web server with Node.js, create a folder for your project and open it in VS Code or your choice of IDE. We need to install two packages using <code>npm</code>. Install the first package, <code>connect</code>, using the command in <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>.</p>
<pre><code>npm install connect --save-dev</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Use <code>npm</code> to install the connect package.</p>
<p><span epub:type="pagebreak" title="141" id="Page_141"/>Install the second package, <code>serve-static</code>, using the command in <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a>.</p>
<pre><code>npm install serve-static --save-dev</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: Use <code>npm</code> to install <code>serve-static</code>.</p>
<p>With the packages installed, create a file named <em>server.js</em> and enter the code in <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a> to define a static web server.</p>
<p class="CodeLabel"><b>server.js</b></p>
<pre><code>var connect = require('connect');
var serveStatic = require('serve-static');
connect().use(serveStatic(__dirname + "/")).listen(8080, function(){
  console.log('localhost:8080');
});</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: Node.js http server code</p>
<p>We’ve created a static server that serves files from the current directory, but we don’t yet have any files to serve. Use VS Code to create a file named <em>index.html </em>and enter some HTML,<em> </em>something like the code in <a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a>.</p>
<p class="CodeLabel"><b>index.html</b></p>
<pre><code>&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;OUR SERVER WORKS!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: A simple web page</p>
<p>Now you can run your Node.js web server using the following command:</p>
<pre><code>node server.js</code></pre>
<p>A web server starts running on port 8080. Test this by entering <em>localhost:8080</em> into your browser; you should see something like <a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a>.</p>
<figure>
<img src="Images/f07001.png" alt="f07001" width="510" height="255"/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: Testing our simple static server</p></figcaption></figure>
<p>Now that we have a working Node.js web server, let’s create our first WebAssembly web app.</p>
<h2 id="h1-501737c07-0003"><span epub:type="pagebreak" title="142" id="Page_142"/>Our First WebAssembly Web Application</h2>
<p class="BodyFirst">We’ll begin with a simple web app that takes two number inputs, adds them together, and then displays those values. The final version of this app is available at <a href="https://wasmbook.com/add_message.html" class="LinkURL">https://wasmbook.com/add_message.html</a>.</p>
<p>This app demonstrates how WebAssembly interacts with the DOM. You’ll find that we don’t change the way the WebAssembly module works, but instead change the embedding environment while the WebAssembly remains none the wiser. </p>
<p>To create a web app, we must run a web server, write an HTML page with JavaScript that will interact with the DOM, and load the WebAssembly module using the <code>instantiateStreaming</code> function (instead of using <code>instantiate</code> as we did in previous chapters). We’ll define a WebAssembly module that adds two integers together and an HTML file that loads and runs that WebAssembly module. In Listing 1-8, JavaScript ran the <code>AddInt</code> function using Node.js to load and execute the WebAssembly module. In this app, the HTML file will contain that JavaScript, and a browser will be required to run the app. </p>
<p><a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a> shows the WAT module with the adding functionality. Create the file <em>add_message.wat</em> and add the code in <a href="#listing7-5">Listing 7-5</a>.</p>
<p class="CodeLabel"><b>add_message.wat</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "env" "log_add_message"
    (func $log_add_message (param i32 i32 i32)))

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (func (export "add_message")
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (param $a i32) (param $b i32)
      (local $sum i32)
    
      local.get $a
      local.get $b
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> i32.add
      local.set $sum

    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (call $log_add_message
      <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (local.get $a) (local.get $b) (local.get $sum))
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: The <em>add_message.wat</em> file adds two numbers and calls a JavaScript log function.</p>
<p>This WAT module should look very familiar at this point. It imports <code>log_add_message</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> from the JavaScript and defines the function <code>add_message</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> that will be exported to the embedding environment. It also takes two <code>i32</code> parameters <span class="CodeAnnotation" aria-label="annotation3">3</span>. These two parameters are added <span class="CodeAnnotation" aria-label="annotation4">4</span> together and stored in a local variable <code>$sum</code>. It then calls the JavaScript function <code>log_add_message </code><span class="CodeAnnotation" aria-label="annotation5">5</span>, passing in the <code>$a</code> and <code>$b</code> parameters, as well as <code>$sum</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>, the sum of those two parameters. </p>
<p>At this point, you might be wondering how the WebAssembly interacts with the DOM. The unfortunate truth is that WebAssembly 1.0 doesn’t <span epub:type="pagebreak" title="143" id="Page_143"/>directly interact with the DOM. It must rely on the embedding environment (JavaScript) to perform all the interaction. All the differences between calling a WebAssembly module from Node.js and a web page will be in the embedding environment. The WebAssembly module can only make function calls to the embedding environment. We’ll create JavaScript functions inside the HTML page. The WebAssembly module will call these JavaScript functions, which will update the DOM. Compile <em>add_message.wat</em> using <code>wat2wasm</code>.</p>
<h3 id="h2-501737c07-0001">Defining the HTML Header</h3>
<p class="BodyFirst">Now we’ll create our HTML page. When we’ve previously used Node.js as our embedding environment, we could work in pure JavaScript, but for a static website, you need an HTML page. A web browser doesn’t execute JavaScript directly in the same way as Node.js. Web browsers load HTML pages, which embed JavaScript inside <code>&lt;script</code><code>&gt;</code> tags. I’ll assume you have some familiarity with the basics of HTML, but this example should be fairly easy to follow if not. Create a new file <em>add_message.html</em> and add the code in <a href="#listing7-6" id="listinganchor7-6">Listing 7-6</a>.</p>
<p class="CodeLabel"><b>add_message.html (part 1 of 3)</b></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport"
        content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Add Message&lt;/title&gt;
...</code></pre>
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: The HTML header for the <em>add_message</em> app is mostly HTML boilerplate.</p>
<p>This is the HTML opening tag and header information. It simply sets some font configuration and displays the app name, <code>Add Message</code>, as the title.</p>
<h3 id="h2-501737c07-0002">The JavaScript</h3>
<p class="BodyFirst">Before ending the head element, we include a <code>script</code> tag for the JavaScript. Similar to when we used Node.js, JavaScript code is required to instantiate and execute functions in the WebAssembly module. An HTML page uses a <code>script</code> tag to contain this JavaScript, as shown in <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a>. </p>
<p class="CodeLabel"><b>add_message.html (part 2 of 3)</b></p>
<pre><code>...
  &lt;script&gt;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> //const sleep = m =&gt; new Promise(r =&gt; setTimeout(r, m));
    var output = null;
    var add_message_function;

  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> var log_add_message = (a, b, sum) =&gt; {
      if (output == null) {
        console.log("page load not complete: log_add_message");
        return;
      }
<span epub:type="pagebreak" title="144" id="Page_144"/>    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> output.innerHTML += `${a} + ${b} = ${sum}&lt;br&gt;`;
    };

    let importObject = {
      env: {
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> log_add_message: log_add_message,
      }
    };


    (async () =&gt; {
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> // await sleep(5000);
      let obj = await
    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> WebAssembly.instantiateStreaming(fetch('add_message.wasm'),
                                        importObject);
      add_message_function = obj.instance.exports.add_message;
    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> let btn = document.getElementById("add_message_button");
      btn.style.display = "block";
    })();

  <span class="CodeAnnotationCode" aria-label="annotation8">8</span> function onPageLoad() {
      //(async () =&gt; {
    <span class="CodeAnnotationCode" aria-label="annotation9">9</span> //await sleep(5000);
    <span class="CodeAnnotationCode" aria-label="annotationa">a</span> output = document.getElementById("output");
      //})();
    }
  &lt;/script&gt;
...</code></pre>
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: The JavaScript that loads a WebAssembly module is inside a <code>script</code> tag.</p>
<p>When building a web page, we need to be aware of when all the web page elements have completed loading and the time it takes to stream and instantiate our WebAssembly module.</p>
<p> This application writes messages to the paragraph tag <code>output</code>. The output paragraph hasn’t yet loaded when the JavaScript executes, because it’s further down the HTML page. The WebAssembly module will be streamed and loaded asynchronously, so you can’t be sure whether the WebAssembly module is instantiated before or after the page load completes.</p>
<p>To test that this function works no matter what order these events occur, we create a <code>sleep</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function at the beginning to force the JavaScript to wait. This function is commented out here. To test load order, uncomment <code>sleep</code> here as well as inside the IIFE or the <code>onPageLoad</code> function.</p>
<p>We create the <code>add_message_function</code> variable as a placeholder that will change to point to the <code>add_message</code> function inside our WebAssembly module as soon as the module is instantiated.</p>
<p>Next, we define <code>log_add_message</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which contains an arrow function that checks whether <code>output</code> is set to something other than <code>null</code>. The default value for <code>output</code> is <code>null</code>, but as soon as the page is loaded, <code>output</code> is set to the paragraph element with an <code>id</code> of <code>output</code>; so this function will log a message if the function runs before the page has finished loading. The <code>log_add_message</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> function is imported by and called from the WebAssembly <span epub:type="pagebreak" title="145" id="Page_145"/>module, which passes to <code>log_add_message</code> the two parameters to add and the sum of those parameters. This function then writes those values to the <code>output</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> HTML paragraph tag from <a href="#listing7-8" id="listinganchor7-8">Listing 7-8</a>.</p>
<p>In the IIFE, the <code>sleep</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> function is commented out, but you can restore it for testing. However, when loading a WebAssembly module from a web page, you use <code>WebAssembly.instantiateStreaming</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> combined with a call to <code>fetch</code> to retrieve the module. Once the module is instantiated, the <code>add_message_button</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> element is retrieved from the DOM and made visible when we set its <code>style.display</code> attribute to <code>block</code>. The user will now be able to click this button to run the WebAssembly function.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Unfortunately, Safari 14.0 hasn’t implemented <code>instantiateStreaming</code>, so you’ll need to polyfill <code>WebAssembly.instantiateStreaming</code> using <code>WebAssembly.instantiate</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Additionally, we define the <code>onPageLoad</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> function, which executes when the HTML <code>body</code> is finished loading. This function sets the <code>output</code> <span class="CodeAnnotation" aria-label="annotationa">a</span> variable defined near the top of <a href="#listing7-7">Listing 7-7</a> to the paragraph tag with an <code>id</code> of <code>output</code>. Prior to the page loading, the output variable has a value of <code>null</code>. If a function that requires the <code>output</code> tag executes before the page has finished loading, it can check for <code>null</code> before using it. This prevents the code from trying to use the paragraph tag before it has loaded. We included an optional <code>sleep</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> function, which can be used to delay setting the <code>output</code> variable. That allows us to simulate what happens when the page takes longer than expected to finish loading.</p>
<h3 id="h2-501737c07-0003">The HTML Body</h3>
<p class="BodyFirst">The HTML <code>body</code> tag contains the DOM elements that will be displayed on our web page. Add the code in <a href="#listing7-8">Listing 7-8</a> inside <em>add_message.html</em> below the <code>script</code> tag.</p>
<p class="CodeLabel"><b>add_message.html (part 3 of 3)</b></p>
<pre><code>...
&lt;/head&gt;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> &lt;body onload="onPageLoad()"
      style="font-family: 'Courier New', Courier, monospace;"&gt;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> &lt;input type="number" id="a_val" value="0"&gt;&lt;br&gt;&lt;br&gt;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> &lt;input type="number" id="b_val" value="0"&gt;&lt;br&gt;&lt;br&gt;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> &lt;button id="add_message_button" type="button" style="display:none"
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> onclick="add_message_function(  
                document.getElementById('a_val').value,
                document.getElementById('b_val').value )"&gt;
    Add Values
  &lt;/button&gt;
  &lt;br&gt;
<span class="CodeAnnotationHang" aria-label="annotation6">6</span> &lt;p id="output" style="float:left; width:200px; min-height:300px;"&gt;
  &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing7-8">Listing 7-8</a>: The DOM elements in the HTML <code>body</code> tag</p>
<p><span epub:type="pagebreak" title="146" id="Page_146"/>The <code>body</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> tag includes an <code>onload</code> attribute that calls the JavaScript <code>onPageLoad</code> function. This ensures that the <code>output</code> variable in our JavaScript isn’t set until the <code>output</code> paragraph tag exists.</p>
<p>Then we have two <code>input</code> elements with the <code>id</code> inputs <code>a_val</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>b_val</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. The values in these inputs are passed to the WebAssembly when the <code>button</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> element is clicked. The button attribute <code>onclick</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> is set to call the <code>add_message_function</code>, which calls the <code>add_message</code> function in the WebAssembly module once the module is instantiated. The <code>add_message</code> function is called, passing in the values in the two input fields (<code>a_val</code> and <code>b_val</code>) above the <code>button</code>. In addition, we have a paragraph tag with an <code>id</code> of <code>output</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> that we’ll populate with values from the WebAssembly module.</p>
<h3 id="h2-501737c07-0004">Our Completed Web App</h3>
<p class="BodyFirst">We should now be able to run our web application. As mentioned earlier, we must serve the web page from a web server, so first make sure the web server in <a href="#listing7-3">Listing 7-3</a> is running by using the command in <a href="#listing7-9" id="listinganchor7-9">Listing 7-9</a>.</p>
<pre><code>node server.js</code></pre>
<p class="CodeListingCaption"><a id="listing7-9">Listing 7-9</a>: Run the simple web server.</p>
<p>If you receive the error in <a href="#listing7-10" id="listinganchor7-10">Listing 7-10</a>, you already have a web server running on that port.</p>
<pre><code>Error: listen EADDRINUSE: address already in use :::8080</code></pre>
<p class="CodeListingCaption"><a id="listing7-10">Listing 7-10</a>: The web server error if the port is already in use</p>
<p>Getting this error likely means you’re running <em>server.js</em> from a different command line. With your web server running, open the following URL in a browser: <a href="http://localhost:8080/add_message.html" class="LinkURL">http://localhost:8080/add_message.html</a>.</p>
<p>You should see something like the screen in <a href="#figure7-2" id="figureanchor7-2">Figure 7-2</a>.</p>
<figure>
<img src="Images/f07002.png" alt="f07002" width="506" height="333"/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: The <em>add_message.html</em> web app</p></figcaption></figure>
<p><span epub:type="pagebreak" title="147" id="Page_147"/>Set values in the two number fields, and click <b>Add Values</b> to see the results of that addition (<a href="#figure7-3" id="figureanchor7-3">Figure 7-3</a>).</p>
<figure>
<img src="Images/f07003.png" alt="f07003" width="506" height="333"/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: Two addition messages added with the app</p></figcaption></figure>
<p>Notice that the WebAssembly module called JavaScript functions, as was done in other chapters. You didn’t have to learn any new commands in WAT in this chapter. Because working directly with the DOM isn’t possible from within Wasm 1.0, we made all our changes to the DOM inside the JavaScript. Even though this was the first time we used an HTML page, it didn’t affect what WebAssembly does. WebAssembly 1.0 is fairly limited and is most useful for increasing performance for math-heavy applications. This characteristic will change with later WebAssembly releases as more features are added. But for now, you need to keep these limitations in mind as you decide which applications are best suited for this new technology.</p>
<h2 id="h1-501737c07-0004">Hex and Binary Strings</h2>
<p class="BodyFirst">We’ll continue and create a second app that uses our functions from <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> to convert numeric data into decimal, hexadecimal, and binary strings, and display them to a web page. See the final app at <a href="https://wasmbook.com/hex_and_binary.html" class="LinkURL">https://wasmbook.com/hex_and_binary.html</a><em>.</em></p>
<h3 id="h2-501737c07-0005">The HTML</h3>
<p class="BodyFirst">The HTML is pretty much the same as <a href="#listing7-6">Listing 7-6</a> but with different <code>title</code><code> </code>contents. Create a file named <em>hex_and_binary.html</em> and add the code in <a href="#listing7-11" id="listinganchor7-11">Listing 7-11</a>.</p>
<p class="CodeLabel"><b>hex_and_binary.html (part 1 of 3)</b></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport"
<span epub:type="pagebreak" title="148" id="Page_148"/>        content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt; <span class="CodeAnnotationCode" aria-label="annotation1">1</span> Hex and Binary&lt;/title&gt;
...</code></pre>
<p class="CodeListingCaption"><a id="listing7-11">Listing 7-11</a>: The boilerplate at the beginning of <em>hex_and_binary.html</em></p>
<p>The <code>title</code><code> </code>tag here contains <code>Hex</code><code> and Binary</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. Next, in <a href="#listing7-12" id="listinganchor7-12">Listing 7-12</a>, we add the <code>script</code> tag and the JavaScript code that will instantiate and call the WebAssembly module.</p>
<p class="CodeLabel"><b>hex_and_binary.html (part 2 of 3)</b></p>
<pre><code>...
  &lt;script&gt;
<span class="LiteralGray">    // allocate a 64K block of memory</span>
    const memory = new WebAssembly.Memory({ initial: 1 });
    var output = null;

<span class="LiteralGray">    // function will change when WebAssembly module is instantiated</span>
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> var setOutput = (number) =&gt; {
<span class="LiteralGray">      // this message will appear if you run the function</span>
<span class="LiteralGray">      // before the WebAssembly module is instantiated.</span>
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> console.log("function not available");
      return 0;
    };

<span class="LiteralGray">    // This function will be called from a button click and runs</span>
<span class="LiteralGray">    // the setOutput function in the WebAssembly module.</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> function setNumbers(number) {
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> if (output == null) {
<span class="LiteralGray">        // if page has not fully loaded return</span>
        return;
      }

<span class="LiteralGray">      // calling WebAssembly setOutput function generates the HTML</span>
<span class="LiteralGray">      // string and puts it in linear memory returning its length</span>
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> let len = setOutput(number);

<span class="LiteralGray">      // we know the position and length of the HTML string in</span>
<span class="LiteralGray">      // linear memory so we can take it out of the memory buffer</span>
    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> let bytes = new Uint8Array(memory.buffer, 1024, len);

<span class="LiteralGray">      // convert the bytes taken from linear memory into a</span>
<span class="LiteralGray">      // JavaScript string and use it to set the HTML in output</span>
    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> output.innerHTML = new TextDecoder('utf8').decode(bytes);
    }


  <span class="CodeAnnotationCode" aria-label="annotation8">8</span> function onPageLoad() {
<span class="LiteralGray">      // when the page load is complete, set the output variable</span>
<span class="LiteralGray">      // to the element with an id of "output"</span>
    <span class="CodeAnnotationCode" aria-label="annotation9">9</span> output = document.getElementById("output");
      var message_num = 0;
    }

    let importObject = {
      env: {
<span epub:type="pagebreak" title="149" id="Page_149"/>        buffer: memory
      }
    };

    (async () =&gt; {
<span class="LiteralGray">      // use WebAssembly.instantiateStreaming in combination with</span>
<span class="LiteralGray">      // fetch instead of WebAssembly.instantiate and fs.readFileSync</span>
      let obj = await WebAssembly.instantiateStreaming(
                        fetch('hex_and_binary.wasm'),
                        importObject);
<span class="LiteralGray">      // reset the setOutput variable to the setOutput</span>
<span class="LiteralGray">      // function from the WASM module</span>
    <span class="CodeAnnotationCode" aria-label="annotationa">a</span> setOutput = obj.instance.exports.setOutput;
         let btn = document.getElementById("set_numbers_button");
         btn.style.display = "block";
    })();

  &lt;/script&gt;
&lt;/head&gt;
...</code></pre>
<p class="CodeListingCaption"><a id="listing7-12">Listing 7-12</a>: JavaScript for the <em>hex_and_binary.html </em>file</p>
<p>The <code>script</code> tag first creates the variable <code>setOutput</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and sets it to an arrow function that logs <code>"function not available"</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to the console. This message will display if the user clicks the <b>Set Numbers</b> button before the WebAssembly module has finished loading. </p>
<p>Next, we define the <code>setNumbers</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function that will be called when the user clicks the <b>Set Numbers</b> button. If the page load hasn’t finished, the <code>output</code> is still <code>null</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> at the button click, and we return from this function. The <code>setNumbers</code> function then calls <code>setOutput</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> in the WebAssembly module, which creates an HTML string from the number passed in and returns the length of that string, which we’ll use to retrieve the string from linear memory. We take the <code>bytes</code> that will be used to create the display string from the linear memory <code>buffer</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>. </p>
<p>Then the <code>output</code> tag’s <code>innerHTML</code> <span class="CodeAnnotation" aria-label="annotation7">7</span> attribute is set to the display string generated from those <code>bytes</code> using a <code>TextDecoder</code> object, which displays the string in the web page. </p>
<p>We define the <code>onPageLoad</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> function, which the <code>body</code> tag executes once it has finished loading. That function sets the <code>output</code> <span class="CodeAnnotation" aria-label="annotation9">9</span> variable used to display the output string from the WebAssembly module. It also instantiates the WebAssembly module and sets the <code>setOutput</code> <span class="CodeAnnotation" aria-label="annotationa">a</span> variable to the <code>setOutput</code> function in the WebAssembly module, so we can call <code>setOutput</code> from the JavaScript. </p>
<p>Finally, we need the <code>body</code> tag, which contains an <code>output</code> tag to display the output from the WebAssembly function call, a number <code>input</code> to take in the user input, and a <code>button</code> to click that will call the <code>setNumbers</code> function. <a href="#listing7-13" id="listinganchor7-13">Listing 7-13</a> shows that code.</p>
<p class="CodeLabel"><b>hex_and_binary.html (part 3 of 3)</b></p>
<pre><code>...
<span class="LiteralGray">&lt;!-- body tag calls onPageLoad when the body load is complete --&gt;</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> &lt;body onload="onPageLoad()"
      style="font-family: 'Courier New', Courier, monospace;"&gt;
<span epub:type="pagebreak" title="150" id="Page_150"/><span class="CodeAnnotationCode" aria-label="annotation2">2</span> &lt;div id="output"&gt;<span class="LiteralGray">&lt;!-- displays output from WebAssembly --&gt;</span>
    &lt;h1&gt;0&lt;/h1&gt;
    &lt;h4&gt;0x0&lt;/h4&gt;
    &lt;h4&gt; 0000 0000 0000 0000 0000 0000 0000 0000&lt;/h4&gt;
  &lt;/div&gt;
  &lt;br&gt;
<span class="LiteralGray">  &lt;!-- user enters input to convert to hex and binary here --&gt;</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> &lt;input type="number" id="val" value="0"&gt;&lt;br&gt;&lt;br&gt;
<span class="LiteralGray">  &lt;!-- when user clicks this button, the WASM function is run --&gt;</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> &lt;button id="set_numbers_button" type="button" style="display:none"
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> onclick="setNumbers( document.getElementById('val').value )"&gt;
    Set Numbers
  &lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing7-13">Listing 7-13</a>: The UI elements of the HTML page</p>
<p>The <code>onload</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> attribute tells the browser to execute <code>onPageLoad</code> when the <code>body</code> has completed loading. The tag <span class="CodeAnnotation" aria-label="annotation2">2</span> <code>&lt;div</code><code> id</code><code>="output"&gt;</code> is where the output from the WebAssembly module will be displayed. The number <code>input</code> tag <span class="CodeAnnotation" aria-label="annotation3">3</span>, <code>&lt;input </code><code>type="number" id="val" </code><code>value="0"&gt;</code> is where the user enters the number to convert to hexadecimal and binary. The <code>button</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> calls the WebAssembly module when it’s clicked using the <code>onclick</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> attribute. Now that we have our HTML page, we can create the WAT file for this application.</p>
<h3 id="h2-501737c07-0006">The WAT</h3>
<p class="BodyFirst">There’s a lot of WAT code in this app, so we’ll break it into four sections. Also, you’ll need to copy several functions from <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>. Create a file named <em>hex_and_binary.wat</em> and add the code in <a href="#listing7-14" id="listinganchor7-14">Listing 7-14</a>.</p>
<p class="CodeLabel"><b>hex_and_binary.wat (part 1 of 4)</b></p>
<pre><code>(module
  (import "env" "buffer" (memory 1))

<span class="LiteralGray">  ;; hexadecimal digits</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> (global $digit_ptr i32 (i32.const 128))
  (data (i32.const 128) "0123456789ABCDEF")
<span class="LiteralGray">  ;; the decimal string pointer, length and data section</span>
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> (global $dec_string_ptr  i32 (i32.const 256))
(global $dec_string_len  i32 (i32.const 16))
  (data (i32.const 256) "               0")

<span class="LiteralGray">  ;; the hexadecimal string pointer, length and data section</span>
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> (global $hex_string_ptr  i32 (i32.const 384))
(global $hex_string_len  i32 (i32.const 16))
(data (i32.const 384) "             0x0")

<span class="LiteralGray">  ;; the binary string pointer, length and data section</span>
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> (global $bin_string_ptr  i32 (i32.const 512))
(global $bin_string_len  i32 (i32.const 40))
(data (i32.const 512) " 0000 0000 0000 0000 0000 0000 0000 0000")

<span class="LiteralGray">  ;; the h1 open tag string pointer, length and data section</span>
<span epub:type="pagebreak" title="151" id="Page_151"/><span class="CodeAnnotationHang" aria-label="annotation5">5</span> (global $h1_open_ptr i32  (i32.const 640))
(global $h1_open_len i32  (i32.const 4))
(data (i32.const 640) "&lt;H1&gt;")

<span class="LiteralGray">  ;; the h1 close tag string pointer, length and data section</span>
<span class="CodeAnnotationHang" aria-label="annotation6">6</span> (global $h1_close_ptr i32  (i32.const 656))
(global $h1_close_len i32  (i32.const 5))
(data (i32.const 656) "&lt;/H1&gt;")

<span class="LiteralGray">  ;; the h4 open tag string pointer, length and data section</span>
<span class="CodeAnnotationHang" aria-label="annotation7">7</span> (global $h4_open_ptr i32  (i32.const 672))
(global $h4_open_len i32  (i32.const 4))
(data (i32.const 672) "&lt;H4&gt;")

<span class="LiteralGray">  ;; the h4 close tag string pointer, length and data section</span>
<span class="CodeAnnotationHang" aria-label="annotation8">8</span> (global $h4_close_ptr i32  (i32.const 688))
(global $h4_close_len i32  (i32.const 5))
(data (i32.const 688) "&lt;/H4&gt;")
  
<span class="LiteralGray">  ;; the output string length and data section</span>
<span class="CodeAnnotationHang" aria-label="annotation9">9</span> (global $out_str_ptr i32 (i32.const 1024))
(global $out_str_len (mut i32) (i32.const 0))

...</code></pre>
<p class="CodeListingCaption"><a id="listing7-14">Listing 7-14</a>: String data definitions at the beginning of the module</p>
<p>We define a series of data sections, pointers, and data lengths that will be used to assemble decimal, hexadecimal, and binary strings from integer data. The <code>$digit_ptr</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> global variable is a pointer to the data segment that contains the 16 hexadecimal digits 0 to F defined at linear memory location <code>128</code>. This data is used for all three conversions from integer to string. We also have a length and pointer global variable, as well as a data segment for our decimal <span class="CodeAnnotation" aria-label="annotation2">2</span>, hexadecimal <span class="CodeAnnotation" aria-label="annotation3">3</span>, and binary <span class="CodeAnnotation" aria-label="annotation4">4</span> string. Much of the code we’ll use is taken from sections in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<p>Next, we have several strings that represent HTML tags. There are opening <span class="CodeAnnotation" aria-label="annotation5">5</span> and closing <span class="CodeAnnotation" aria-label="annotation6">6</span> <code>H1</code> tag pointers, length and data segments, as well as opening <span class="CodeAnnotation" aria-label="annotation7">7</span> and closing <span class="CodeAnnotation" aria-label="annotation8">8</span> data for <code>H4</code> tags. These strings will be used to assemble our HTML output string that will be stored in the linear memory position <code>1024</code> <span class="CodeAnnotation" aria-label="annotation9">9</span>, which I chose because it was unused. </p>
<p>As we copy string data to the output string, we’ll need to keep track of the new length of this string and pass that value to the JavaScript; so we use the global variable <code>$out_str_len</code> to keep track of the output string length. Instead of including the code for the original functions from <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, I include an ellipsis (…) and a comment indicating the listing number that has the function code to copy. Copy and paste the function code from the original listing for all six of the functions in <a href="#listing7-15" id="listinganchor7-15">Listing 7-15</a>.</p>
<p class="CodeLabel"><b>hex_and_binary.wat (part 2 of 4)</b></p>
<pre><code>...
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> (func $set_bin_string (param $num i32) (param $string_len i32)
  <span class="LiteralGray">;; $set_bin_string defined in listing 5-35</span>
...
<span epub:type="pagebreak" title="152" id="Page_152"/>)

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> (func $set_hex_string (param $num i32) (param $string_len i32)
  <span class="LiteralGray">;; $set_hex_string defined in listing 5-30</span>
...
) <span class="LiteralGray">;; end $set_hex_string</span>

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> (func $set_dec_string (param $num i32) (param $string_len i32)
  <span class="LiteralGray">;; $set_dec_string defined in listing 5-24</span>
...
)

<span class="CodeAnnotationHang" aria-label="annotation4">4</span> (func $byte_copy
  (param $source i32) (param $dest i32) (param $len i32)
  <span class="LiteralGray">;; $byte_copy defined in listing 5-17</span>
...
)

<span class="CodeAnnotationHang" aria-label="annotation5">5</span> (func $byte_copy_i64
  (param $source i32) (param $dest i32) (param $len i32)
  <span class="LiteralGray">;; $byte_copy_i64 defined in listing 5-18</span>
...
)

<span class="CodeAnnotationHang" aria-label="annotation6">6</span> (func $string_copy
  (param $source i32) (param $dest i32) (param $len i32)
  <span class="LiteralGray">;; $string_copy defined in listing 5-19</span>
...
  )
...</code></pre>
<p class="CodeListingCaption"><a id="listing7-15">Listing 7-15</a>: Functions reused from Chapter 5</p>
<p>First are the number-to-string conversion functions. The <code>$set_bin_string</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function converts a number into a binary string. As parameters it takes an <code>i32 $num</code> to be converted into a binary string and <code>$string_len</code> as the length of the output string, which includes nibble padding with spaces (Listing 5-35). Next is <code>$set_hex_string</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which converts the number and length to a hexadecimal string prefixed with a <code>0x</code> to indicate that the string represents a hexadecimal number (Listing 5-30). Then <code>$set_dec_string</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> converts a number to a decimal string (Listing 5-24). </p>
<p>Next are the three copy functions that copy a byte at a time, eight bytes at a time, and strings. Each takes three parameters: the <code>$source</code> parameter is the string that we’re copying from, the <code>$dest</code> parameter is the string we’re copying to, and <code>$len</code> is the length of the string. First is the <code>$byte_copy</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> function, which copies data one byte at a time (Listing 5-17). The <code>$byte_copy_i64</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> function copies eight bytes at a time (Listing 5-18). The <code>$string_copy</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> function copies bytes eight at a time using <code>$byte_copy_i64</code> until there are less than eight bytes remaining and then copies the remaining bytes one by one using <code>$byte_copy</code> (Listing 5-17). </p>
<p><span epub:type="pagebreak" title="153" id="Page_153"/>There is one final copy command not in <a href="#listing7-15">Listing 7-15</a>. This is the <code>$append_out</code> function that will always append a given source string to the output string by copying it to the end of the current output string. Add the code in <a href="#listing7-16" id="listinganchor7-16">Listing 7-16</a> to <em>hex_and_binary.wat</em>.</p>
<p class="CodeLabel"><b>hex_and_binary.wat (part 3 of 4)</b></p>
<pre><code>...
<span class="LiteralGray">  ;; append the source string to the output string</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> (func $append_out (param $source i32) (param $len i32)
 <span class="CodeAnnotationHang" aria-label="annotation2">2</span> (call $string_copy
   (local.get $source)
     (i32.add
      (global.get $out_str_ptr)
      (global.get $out_str_len)
    )
   (local.get $len)
  )

<span class="LiteralGray">  ;; add length to the output string length</span>
  global.get $out_str_len
  local.get $len
  i32.add
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> global.set $out_str_len
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing7-16">Listing 7-16</a>: The <code>$append_out</code> function appends to the output string.</p>
<p>The <code>$append_out</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function appends the source string to the end of the output string using <code>$string_copy</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and then adds the length of the string just appended to the <code>$out_str_len</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which represents the output string length. </p>
<p>The final function in this module is <code>setOutput</code>, which creates the string we use to set the <code>output</code> <code>div</code> tag. This is exported so it can be called from JavaScript. Add the code in <a href="#listing7-17" id="listinganchor7-17">Listing 7-17</a> to the end of the WAT file.</p>
<p class="CodeLabel"><b>hex_and_binary.wat (part 4 of 4)</b></p>
<pre><code>...
(func (export "setOutput") (param $num i32) (result i32)
<span class="LiteralGray">  ;; create a decimal string from $num value</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $set_dec_string
    (local.get $num) (global.get $dec_string_len))    
<span class="LiteralGray">  ;; create a hexadecimal string from $num value</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $set_hex_string
    (local.get $num) (global.get $hex_string_len))    
<span class="LiteralGray">  ;; create a binary string from $num value</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (call $set_bin_string
    (local.get $num) (global.get $bin_string_len))    

    i32.const 0
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> global.set $out_str_len <span class="LiteralGray">;; set $out_str_len to 0</span>

<span class="LiteralGray">    ;; append &lt;h1&gt;${decimal_string}&lt;/h1&gt; to output string</span>
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (call $append_out
      (global.get $h1_open_ptr) (global.get $h1_open_len))
    (call $append_out
<span epub:type="pagebreak" title="154" id="Page_154"/>      (global.get $dec_string_ptr) (global.get $dec_string_len))
    (call $append_out
      (global.get $h1_close_ptr) (global.get $h1_close_len))

<span class="LiteralGray">    ;; append &lt;h4&gt;${hexadecimal_string}&lt;/h4&gt; to output string</span>
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (call $append_out
      (global.get $h4_open_ptr) (global.get $h4_open_len))
    (call $append_out
      (global.get $hex_string_ptr) (global.get $hex_string_len))
    (call $append_out
      (global.get $h4_close_ptr) (global.get $h4_close_len))

<span class="LiteralGray">    ;; append &lt;h4&gt;${binary_string}&lt;/h4&gt; to output string</span>
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> (call $append_out
      (global.get $h4_open_ptr) (global.get $h4_open_len))
    (call $append_out
      (global.get $bin_string_ptr) (global.get $bin_string_len))
    (call $append_out
      (global.get $h4_close_ptr) (global.get $h4_close_len))

<span class="LiteralGray">    ;; return output string length</span>
  <span class="CodeAnnotationCode" aria-label="annotation8">8</span> global.get $out_str_len
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing7-17">Listing 7-17</a>: The <code>setOutput</code> function exported to be called from JavaScript</p>
<p>The first three calls made by the <code>set_output</code> function in <a href="#listing7-17">Listing 7-17</a> are to <code>$set_dec_string</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, <code>$set_hex_string</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, and <code>$set_bin_string</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. These functions take the number passed into <code>setOutput</code> and convert it into a decimal string, a hexadecimal string, and a binary string in linear memory. Once these strings are set, the global variable <code>$out_str_len</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> is set to <code>0</code>, which resets the output string so that appending to the output string writes over the string currently in memory. After we reset the value, we can begin to append to the output string.</p>
<p>Next are nine calls to <code>$append_out</code>, grouped into three blocks. The first three calls append an opening and closing <code>H1</code> tag with the decimal <span class="CodeAnnotation" aria-label="annotation5">5</span> string inside it. This creates the HTML string to display the decimal numeric value in our web page. The next block of three appends the hexadecimal <span class="CodeAnnotation" aria-label="annotation6">6</span> string inside an <code>H4</code> element, and then the binary <span class="CodeAnnotation" aria-label="annotation7">7</span> string is appended inside an <code>H4</code> element. Finally, the length of the output string is loaded on the stack using a call to <code>global.get</code><code> $out_str_len</code> <span class="CodeAnnotation" aria-label="annotation8">8</span>, which returns it to the calling JavaScript.</p>
<h3 id="h2-501737c07-0007">Compile and Run</h3>
<p class="BodyFirst">The WAT module is complete, so use <code>wat2wasm</code> to compile your <em>hex_and_binary.wasm</em> file, as shown in <a href="#listing7-18" id="listinganchor7-18">Listing 7-18</a>.</p>
<pre><code>wat2wasm hex_and_binary.wat</code></pre>
<p class="CodeListingCaption"><a id="listing7-18">Listing 7-18</a>: Compiling <em>hex_and_binary.wat</em> using <code>wat2wasm</code></p>
<p><span epub:type="pagebreak" title="155" id="Page_155"/>Verify that you’re running your <em>server.js</em>, and open <em>hex_and_binary.html</em> in a browser using the address <em>http://localhost:8080/hex_and_binary.html</em>.</p>
<p><a href="#figure7-4" id="figureanchor7-4">Figure 7-4</a> shows something similar to what you should see onscreen.</p>
<figure>
<img src="Images/f07004.png" alt="f07004" width="506" height="333"/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: Converting decimal to hexadecimal and binary</p></figcaption></figure>
<p>Enter a number and give it a go. For example, in <a href="#figure7-5" id="figureanchor7-5">Figure 7-5</a>, I entered the number 1025 and clicked Set Numbers.</p>
<figure>
<img src="Images/f07005.png" alt="f07005" width="506" height="333"/>
<figcaption><p><a id="figure7-5">Figure 7-5</a>: Convert 1025 to hexadecimal and binary</p></figcaption></figure>
<p>This application used several WebAssembly functions we created in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> to convert a decimal number to hexadecimal and binary strings. We added some additional functionality that created HTML tags in the WebAssembly module so we could pass HTML to the JavaScript and display it on the web page. As you can tell, working with strings and manipulating the DOM from WAT is rather cumbersome. If you’re working with a toolchain, much of this hard work is done for you. Some of this functionality might compile into JavaScript glue code.</p>
<h2 id="h1-501737c07-0005"><span epub:type="pagebreak" title="156" id="Page_156"/>Summary</h2>
<p class="BodyFirst">WebAssembly 1.0 doesn’t directly work with user interfaces. Its sweet spot is math-intensive applications. When interacting with the DOM from a web application built on top of WebAssembly, manipulating the DOM is primarily a task for the JavaScript portion. Working with strings from within WebAssembly entirely depends on the implementation. WebAssembly is still an excellent choice for many web applications, especially graphical applications, such as games. But in its current state, it’s not designed to work directly with the DOM.</p>
<p>We began this chapter by creating a simple JavaScript web server to run using Node.js. You can’t load a WebAssembly web app from the filesystem but instead must serve your page using a web server. We wrote our first WebAssembly web application, which added two numbers together and then logged those numbers to the DOM in a paragraph tag called <code>output</code>.</p>
<p>The primary difference between web applications and Node.js applications is in the embedding environment. Node.js command line apps are written entirely in JavaScript, where the web application has its JavaScript inside an HTML web page. Node.js can load the WebAssembly module directly from the filesystem, whereas the web application uses <code>instantiateStreaming</code> and <code>fetch</code> to instantiate a WebAssembly module streaming it from a web server. A Node.js application would have logged its output to the console, whereas the HTML page updated the <code>innerHTML</code> of a DOM element.</p>
<p>The second application we wrote displayed the decimal, hexadecimal, and binary representations of a number passed into the WebAssembly module. This was done by assembling a string containing the HTML elements to be displayed in the application. This application reused several functions created in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> for string manipulation. The JavaScript in this application wrote the string to the <code>innerHTML</code> of a <code>div</code> tag on our web page.</p>
<p>Neither of the applications we wrote is a particularly good use case for WebAssembly. My goal in this chapter was to create our first few WebAssembly web apps, not necessarily to make web applications that made sense to create using WebAssembly. In the next chapter, we’ll render to the HTML canvas and examine collision detection between a large number of objects on that canvas. These tasks, commonly found in web games, better represent what WebAssembly 1.0 can do to improve your web application’s performance.</p>
</section>
</div></body></html>