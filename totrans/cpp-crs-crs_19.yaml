- en: '**16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STREAMS**
  prefs: []
  type: TYPE_NORMAL
- en: '*Either write something worth reading or do something worth writing.'
  prefs: []
  type: TYPE_NORMAL
- en: —Benjamin Franklin*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces streams, the major concept that enables you to connect
    inputs from any kind of source and outputs to any kind of destination using a
    common framework. You’ll learn about the classes that form the base elements of
    this common framework, several built-in facilities, and how to incorporate streams
    into user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Streams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *stream* models a *stream of data*. In a stream, data flows between objects,
    and those objects can perform arbitrary processing on the data. When you’re working
    with streams, output is data going into the stream and input is data coming out
    of the stream. These terms reflect the streams as viewed from the user’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, streams are the primary mechanism for performing input and output (I/O).
    Regardless of the source or destination, you can use streams as the common language
    to connect inputs to outputs. The STL uses class inheritance to encode the relationships
    between various stream types. The primary types in this hierarchy are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::basic_ostream` class template in the `<ostream>` header that represents
    an output device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::basic_istream` class template in the `<istream>` header that represents
    an input device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::basic_iostream` class template in the `<iostream``>` header for devices
    that are input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three stream types require two template parameters. The first corresponds
    to the stream’s underlying data type and the second to a traits type.
  prefs: []
  type: TYPE_NORMAL
- en: This section covers streams from a user’s perspective rather than from a library
    implementer’s perspective. You’ll understand the streams interface and know how
    to interact with standard I/O, files, and strings using the STL’s built-in stream
    support. If you must implement a new kind of stream (for example, for a new library
    or framework), you’ll need a copy of the ISO C++ 17 Standard, some working examples,
    and an ample supply of coffee. I/O is complicated, and you’ll see this difficulty
    reflected in a stream implementation’s internal complexity. Fortunately, a well-designed
    stream class hides much of this complexity from users.
  prefs: []
  type: TYPE_NORMAL
- en: '***Stream Classes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All STL stream classes that users interact with derive from `basic_istream,
    basic_ostream`, or both via `basic_iostream`. The headers that declare each type
    also provide `char` and `wchar_t` specializations for those templates, as outlined
    in [Table 16-1](ch16.xhtml#ch16tab01). These heavily used specializations are
    particularly useful when you’re working with human-language data input and output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-1:** Template Specializations for the Primary Stream Templates'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Template** | **Parameter** | **Specialization** | **Header** |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_istream` | `char` | `istream` | `<istream>` |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_ostream` | `char` | `ostream` | `<ostream>` |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_iostream` | `char` | `iostream` | `<iostream>` |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_istream` | `wchar_t` | `wistream` | `<istream>` |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_ostream` | `wchar_t` | `wostream` | `<ostream>` |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_iostream` | `wchar_t` | `wiostream` | `<iostream>` |'
  prefs: []
  type: TYPE_TB
- en: The objects in [Table 16-1](ch16.xhtml#ch16tab01) are abstractions that you
    can use in your programs to write generic code. Do you want to write a function
    that logs output to an arbitrary source? If so, you can accept an `ostream` reference
    parameter and not deal with all the nasty implementation details. (Later in the
    “Output File Streams” on [page 542](ch16.xhtml#page_542), you’ll learn how to
    do this.)
  prefs: []
  type: TYPE_NORMAL
- en: Often, you’ll want to perform I/O with the user (or the program’s environment).
    Global stream objects provide a convenient, stream-based wrapper for you to work
    against.
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Stream Objects**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The STL provides several *global stream objects* in the `<iostream>` header
    that wrap the input, output, and error streams stdin, stdout, and stderr. These
    implementation-defined standard streams are preconnected channels between your
    program and its executing environment. For example, in a desktop environment,
    stdin typically binds to the keyboard and stdout and stderr bind to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recall that in [Part I](part01.xhtml#part01) you saw extensive use of `printf`
    to write to stdout.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-2](ch16.xhtml#ch16tab02) lists the global stream objects, all of
    which reside in the `std` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-2:** The Global Stream Objects'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Object** | **Type** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cout``wcout` | `ostream``wostream` | Output, like a screen |'
  prefs: []
  type: TYPE_TB
- en: '| `cin``wcin` | `istream``wistream` | Input, like a keyboard |'
  prefs: []
  type: TYPE_TB
- en: '| `cerr``wcerr` | `ostream``wostream` | Error output (unbuffered) |'
  prefs: []
  type: TYPE_TB
- en: '| `clog``wclog` | `ostream``wostream` | Error output (buffered) |'
  prefs: []
  type: TYPE_TB
- en: 'So how do you use these objects? Well, stream classes support operations that
    you can partition into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Formatted operations** Might perform some preprocessing on their input parameters
    before performing I/O'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unformatted operations** Perform I/O directly'
  prefs: []
  type: TYPE_NORMAL
- en: The following sections explain each of these categories in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '**Formatted Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All formatted I/O passes through two functions: the *standard stream operators*,
    `operator<<` and `operator>>`. You’ll recognize these as the left and right shift
    operators from “Logical Operators” on [page 182](ch07.xhtml#page_182). Somewhat
    confusingly, streams overload the left and right shift operators with completely
    unrelated functionality. The semantic meaning of the expression `i << 5` depends
    entirely on the type of `i`. If `i` is an integral type, this expression means
    *take* i *and shift the bits to the left by five binary digits*. If `i` is not
    an integral type, it means *write the value 5 into* i. Although this notational
    collision is unfortunate, in practice it doesn’t cause too much trouble. Just
    pay attention to the types you’re using and test your code well.'
  prefs: []
  type: TYPE_NORMAL
- en: Output streams overload `operator<<`, which is referred to as the *output operator*
    or the *inserter*. The `basic_ostream` class template overloads the output operator
    for all fundamental types (except `void` and `nullptr_t`) and some STL containers,
    such as `basic_string, complex`, and `bitset`. As an `ostream` user, you need
    not worry about how these overloads translate objects into readable output.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-1](ch16.xhtml#ch16ex01) illustrates how to use the output operator
    to write various types into `cout`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-1: Using `cout` and `operator<<` to write into stdout*'
  prefs: []
  type: TYPE_NORMAL
- en: You use the output `operator``<<` to write a `bitset` ➊, a `char` ➋, a `string`
    ➌, a `size_t` ➍, and a null-terminated string literal ➎ to stdout via `cout`.
    Even though you write five distinct types to the console, you never deal with
    serialization issues. (Consider the hoops you would have had to jump through to
    get `printf` to yield similar output given these types.)
  prefs: []
  type: TYPE_NORMAL
- en: 'One very nice feature of the standard stream operators is that they generally
    return a reference to the stream. Conceptually, overloads are typically defined
    along the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This means you can chain output operators together. Using this technique, you
    can refactor [Listing 16-1](ch16.xhtml#ch16ex01) so `cout` appears only once,
    as [Listing 16-2](ch16.xhtml#ch16ex02) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-2: Refactoring [Listing 16-1](ch16.xhtml#ch16ex01) by chaining
    output operators together*'
  prefs: []
  type: TYPE_NORMAL
- en: Because each invocation of `operator<<` returns a reference to the output stream
    (here, `cout`), you simply chain the calls together to obtain identical output
    ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Input streams overload `operator>>`, which is referred to as the *input operator*
    or the *extractor*. The `basic_istream` class has corresponding overloads for
    the input operator for all the same types as `basic_ostream`, and again as a user,
    you can largely ignore the deserialization details.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-3](ch16.xhtml#ch16ex03) illustrates how to use the input operator
    to read two `double` objects and a `string` from `cin`, then print the implied
    mathematical operation’s result to stdout.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-3: A primitive calculator program using `cin` and `operator<<`
    to collect input*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you collect two `double`s `x` ➊ and `y` ➋ followed by the `string op`
    ➌, which encodes the desired operation. Using an `if` statement, you can output
    the specified operation’s result for addition ➍, subtraction ➎, multiplication
    ➏, and division ➐, or indicate to the user that `op` is unknown ➑.
  prefs: []
  type: TYPE_NORMAL
- en: To use the program, you type the requested values into the console when directed.
    A newline will send the input (as stdin) to `cin`, as [Listing 16-4](ch16.xhtml#ch16ex04)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-4: A sample run of the program in [Listing 16-3](ch16.xhtml#ch16ex03)
    that calculates the circumference of Earth in miles*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You input the two `double` objects: the radius of Earth in miles, `3959` ➊
    and 2π, 6.283185 ➋, and you specify multiplication `*` ➌. The result is Earth’s
    circumference in miles ➍. Note that you don’t need to provide a decimal point
    for an integral value ➊; the stream is smart enough to know that there’s an implicit
    decimal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You might wonder what happens in [Listing 16-4](ch16.xhtml#ch16ex04) if you
    input a non-numeric string for `X` ➊ or `Y` ➋. The stream enters an error state,
    which you’ll learn about later in this chapter in the “Stream State” section on
    [page 530](ch16.xhtml#page_530). In an error state, the stream ceases to accept
    input, and the program won’t accept any more input.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unformatted Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When you’re working with text-based streams, you’ll usually want to use formatted
    operators; however, if you’re working with binary data or if you’re writing code
    that needs low-level access to streams, you’ll want to know about the unformatted
    operations. Unformatted I/O involves a lot of detail. For brevity, this section
    provides a summary of the relevant methods, so if you need to use unformatted
    operations, refer to [input.output].
  prefs: []
  type: TYPE_NORMAL
- en: The `istream` class has many unformatted input methods. These methods manipulate
    streams at the byte level and are summarized in [Table 16-3](ch16.xhtml#ch16tab03).
    In this table, `is` is of type `std::istream <T>, s` is a `char*, n` is a stream
    size, `pos` is a position type, and `d` is a delimiter of type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-3:** Unformatted Read Operations for `istream`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| is.`get([`c`])` | Returns next character or writes to character reference
    c if provided. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`get(`s, n, `[`d`])`is.`getline(`s, n, `[`d`])` | The operation `get`
    reads up to n characters into the buffer s, stopping if it encounters a newline,
    or d if provided. The operation `getline` is the same except it reads the newline
    character as well. Both write a terminating null character to s. You must ensure
    `s` has enough space. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`read(`s, n`)`is.`readsome(`s, n`)` | The operation `read` reads up to
    n characters into the buffer s; encountering end of file is an error. The operation
    `readsome` is the same except it doesn’t consider end of file an error. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`gcount()` | Returns the number of characters read by is’s last unformatted
    read operation. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`ignore()` | Extracts and discards a single character. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`ignore(`n, `[`d`])` | Extracts and discards up to n characters. If d
    is provided, `ignore` stops if d is found. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`peek()` | Returns the next character to be read without extracting. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`unget()` | Puts the last extracted character back into the string. |'
  prefs: []
  type: TYPE_TB
- en: '| is.`putback(`c`)` | If `c` is the last character extracted, executes `unget`.
    Otherwise, sets the `badbit`. Explained in the “Stream State” section. |'
  prefs: []
  type: TYPE_TB
- en: Output streams have corollary unformatted write operations, which manipulate
    streams at a very low level, as summarized in [Table 16-4](ch16.xhtml#ch16tab04).
    In this table, `os` is of type `std::ostream <T>``, s` is a `char*`, and `n` is
    a stream size.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-4:** Unformatted Write Operations for `ostream`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| os.`put(`c`)` | Writes c to the stream |'
  prefs: []
  type: TYPE_TB
- en: '| os.`write(`s, n`)` | Writes n characters from s to the stream |'
  prefs: []
  type: TYPE_TB
- en: '| os.`flush()` | Writes all buffered data to the underlying device |'
  prefs: []
  type: TYPE_TB
- en: '**Special Formatting for Fundamental Types**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All fundamental types, in addition to `void` and `nullptr`, have input and
    output operator overloads, but some have special rules:'
  prefs: []
  type: TYPE_NORMAL
- en: char **and** wchar_t The input operator skips whitespace when assigning character
    types.
  prefs: []
  type: TYPE_NORMAL
- en: char* **and** wchar_t* The input operator first skips whitespace and then reads
    the string until it encounters another whitespace or an end-of-file (EOF). You
    must reserve enough space for the input.
  prefs: []
  type: TYPE_NORMAL
- en: void* Address formats are implementation dependent for input and output operators.
    On desktop systems, addresses take hexadecimal literal form, such as `0x01234567`
    for 32-bit or `0x0123456789abcdef` for 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'bool The input and output operators treat Boolean values as numbers: 1 for
    `true` and 0 for `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numeric types** The input operator requires that input begin with at least
    one digit. Badly formed input numbers yield a zero-valued result.'
  prefs: []
  type: TYPE_NORMAL
- en: These rules might seem a bit strange at first, but they’re fairly straightforward
    once you get used to them.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Avoid reading into C-style strings, because it’s up to you to ensure that
    you’ve allocated enough space for the input data. Failure to perform adequate
    checking results in undefined behavior and possibly major security vulnerabilities.
    Use `std::string` instead.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Stream State***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A stream’s state indicates whether I/O failed. Each stream type exposes the
    constant static members referred to collectively as its *bits*, which indicate
    a possible stream state: `goodbit, badbit, eofbit`, and `failbit`. To determine
    whether a stream is in a particular state, you invoke member functions that return
    a `bool` indicating whether the stream is in the corresponding state. [Table 16-5](ch16.xhtml#ch16tab05)
    lists these member functions, the stream state corresponding to a `true` result,
    and the state’s meaning.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-5:** The Possible Stream States, Their Accessor Methods, and Their
    Meanings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **State** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `good()` | `goodbit` | The stream is in a good working state. |'
  prefs: []
  type: TYPE_TB
- en: '| `eof()` | `eofbit` | The stream encountered an EOF. |'
  prefs: []
  type: TYPE_TB
- en: '| `fail()` | `failbit` | An input or output operation failed, but the stream
    might still be in a good working state. |'
  prefs: []
  type: TYPE_TB
- en: '| `bad()` | `badbit` | A catastrophic error occurred, and the stream is not
    in a good state. |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To reset a stream’s status to indicate a good working state, you can invoke
    its `clear()` method.*'
  prefs: []
  type: TYPE_NORMAL
- en: Streams implement an implicit bool conversion (`operator bool`), so you can
    check whether a stream is in a good working state simply and directly. For example,
    you can read input from stdin word by word until it encounters an EOF (or some
    other failure condition) using a simple `while` loop. [Listing 16-5](ch16.xhtml#ch16ex05)
    illustrates a simple program that uses this technique to generate word counts
    from stdin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-5: A program that counts words from stdin*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare a `string` called `word` to receive words from stdin ➊, and you
    initialize a `count` variable to zero ➋. Within the `while` loop’s Boolean expression,
    you attempt to assign new input into `word` ➌. When this succeeds, you increment
    `count` ➍. Once it fails—for example, due to encountering an EOF—you cease incrementing
    and print the final tally ➎.
  prefs: []
  type: TYPE_NORMAL
- en: You can try two methods to test [Listing 16-5](ch16.xhtml#ch16ex05). First,
    you can simply invoke the program, enter some input, and provide an EOF. How to
    send EOF depends on your operating system. In the Windows command line, you can
    enter EOF by pressing CTRL-Z and pressing enter. In Linux bash or in the OS X
    shell, you press CTRL-D. [Listing 16-6](ch16.xhtml#ch16ex06) demonstrates how
    to invoke [Listing 16-5](ch16.xhtml#ch16ex05) from the Windows command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-6: Invoking the program in [Listing 16-5](ch16.xhtml#ch16ex05)
    by typing input into the console*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you invoke your program ➊. Next, enter some arbitrary text followed by
    a new line ➋. Then issue EOF. The Windows command line shows the somewhat cryptic
    sequence **^Z** on the command line, after which you must press ENTER. This causes
    `std::cin` to enter the `eofbit` state, ending the `while` loop in [Listing 16-5](ch16.xhtml#ch16ex05)
    ➌. The program indicates that you’ve sent 70 words into stdin ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux and Mac and in Windows PowerShell, you have another option. Rather
    than entering the input directly into the console, you can save the text to a
    file, say *yoda.txt*. The trick is to use `cat` to read the text file and then
    use the pipe operator `|` to send the contents to your program. The pipe operator
    “pipes” the stdout of the program to its left into the stdin of the program on
    the right. The following command illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command reads the contents of *yoda.txt* ➊. The pipe operator ➋ pipes
    the stdout of `cat` into stdin of `listing_15_4` ➌. Because `cat` sends EOF when
    it encounters the end of *yoda.txt*, you don’t need to enter it manually.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you’ll want streams to throw an exception when certain fail bits occur.
    You can do this easily with a stream’s `exceptions` method, which accepts a single
    argument corresponding to the bit you want to throw exceptions. If you desire
    multiple bits, you can simply join them together using Boolean OR (`|`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-7](ch16.xhtml#ch16ex07) illustrates how to refactor [Listing 16-5](ch16.xhtml#ch16ex05)
    so it handles the `badbit` with exceptions and `eofbit`/`failbit` with the default
    handling.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-7: Refactoring [Listing 16-5](ch16.xhtml#ch16ex05) to handle `badbit`
    with exceptions*'
  prefs: []
  type: TYPE_NORMAL
- en: You start the program by invoking the exceptions method on `std::cin` ➊. Because
    `cin` is an `istream`, you pass `istream::badbit` as the argument of `exception`,
    indicating that you want `cin` to throw an exception any time it gets into a catastrophic
    state. To account for possible exceptions, you wrap the existing code in a `try`-`catch`
    block ➋, so if `cin` sets `badbit` while it’s reading input ➌, the user never
    receives a message about the word count ➍. Instead, the program catches the resulting
    exception ➎ and prints the error message ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '***Buffering and Flushing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many `ostream` class templates involve operating system calls under the hood,
    for example, to write to a console, a file, or a network socket. Relative to other
    function calls, system calls are usually slow. Rather than invoking a system call
    for each output element, an application can wait for multiple elements and then
    send them all together to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: The queuing behavior is called *buffering*. When the stream empties the buffered
    output, it’s called *flushing*. Usually, this behavior is completely transparent
    to the user, but sometimes you want to manually flush the `ostream`. For this
    (and other tasks), you turn to manipulators.
  prefs: []
  type: TYPE_NORMAL
- en: '***Manipulators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Manipulators* are special objects that modify how streams interpret input
    or format output. Manipulators exist to perform many kinds of stream alterations.
    For example, `std::ws` modifies an `istream` to skip over whitespace. Here are
    some other manipulators that work on `ostreams`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::flush` empties any buffered output directly to an `ostream`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::ends` sends a null byte.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::endl` is like `std::flush` except it sends a newline before flushing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 16-6](ch16.xhtml#ch16tab06) summarizes the manipulators in the `<istream>`
    and `<ostream>` headers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-6:** Four Manipulators in the `<istream>` and `<ostream>` Headers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Manipulator** | **Class** | **Behavior** |'
  prefs: []
  type: TYPE_TB
- en: '| `ws` | `istream` | Skips over all whitespaces |'
  prefs: []
  type: TYPE_TB
- en: '| `flush` | `ostream` | Writes any buffered data to the stream by invoking
    its `flush` method |'
  prefs: []
  type: TYPE_TB
- en: '| `ends` | `ostream` | Sends a null byte |'
  prefs: []
  type: TYPE_TB
- en: '| `endl` | `ostream` | Sends a newline and flushes |'
  prefs: []
  type: TYPE_TB
- en: 'For example, you could replace ➍ in [Listing 16-7](ch16.xhtml#ch16ex07) with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will print a newline and also flush output.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a general rule, use `std::endl` when your program has finished outputting
    text to the stream for a while and `\n` when you know your program will output
    more text soon.*'
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib provides many other manipulators in the `<ios>` header. You can,
    for example, determine whether an `ostream` will represent Boolean values textually
    (`boolalpha`) or numerically (`noboolalpha`); integral values as octal (`oct`),
    decimal (`dec`), or hexadecimal (`hex`); and floating-point numbers as decimal
    notation (`fixed`) or scientific notation (`scientific`). Simply pass one of these
    manipulators to an `ostream` using `operator<<` and *all* subsequent insertions
    of the corresponding type will be manipulated (not just an immediately preceding
    operand).
  prefs: []
  type: TYPE_NORMAL
- en: You can also set a stream’s width parameter using the `setw` manipulator. A
    stream’s width parameter has varied effects, depending on the stream. For example,
    with `std::cout, setw` will fix the number of output characters allocated to the
    next output object. Additionally, for floating-point output, `setprecision` will
    set the following numbers’ precision.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-8](ch16.xhtml#ch16ex08) illustrates how these manipulators perform
    functions similar to those of the various `printf` format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-8: A program illustrating some of the manipulators available in
    the `<iomanip>` header*'
  prefs: []
  type: TYPE_NORMAL
- en: The `boolalpha` manipulator in the first line causes Boolean values to print
    textually as `true` and `false` ➊, whereas `noboolalpha` causes them to print
    as 1 and 0 instead ➋. For integral values, you can print as octal with `oct` ➌
    or hexadecimal with `hex` ➍. For floating-point values, you can specify scientific
    notation with `scientific` ➎, and you can set the number of digits to print with
    `setprecision` and specify decimal notation with `fixed` ➏. Because manipulators
    apply to all subsequent objects you insert into a stream, when you print another
    integral value at the end of the program, the last integral manipulator (`hex`)
    applies, so you get a hexadecimal representation ➐. Finally, you employ `setw`
    to set the field width for output to 4, and you print some integral values ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-7](ch16.xhtml#ch16tab07) summarizes this sampling of common manipulators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-7:** Many of the Manipulators Available in the `<iomanip>` Header'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Manipulator** | **Behavior** |'
  prefs: []
  type: TYPE_TB
- en: '| `boolalpha` | Represents Booleans textually rather than numerically. |'
  prefs: []
  type: TYPE_TB
- en: '| `noboolalpha` | Represents Booleans numerically rather than textually. |'
  prefs: []
  type: TYPE_TB
- en: '| `oct` | Represents integral values as octal. |'
  prefs: []
  type: TYPE_TB
- en: '| `dec` | Represents integral values as decimal. |'
  prefs: []
  type: TYPE_TB
- en: '| `hex` | Represents integral values as hexadecimal. |'
  prefs: []
  type: TYPE_TB
- en: '| `setw(`n`)` | Sets the width parameter of a stream to n. The exact effect
    depends on the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `setprecision(`p`)` | Specifies floating-point precision as p. |'
  prefs: []
  type: TYPE_TB
- en: '| `fixed` | Represents floating-point numbers in decimal notation. |'
  prefs: []
  type: TYPE_TB
- en: '| `scientific` | Represents floating-point numbers in scientific notation.
    |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Refer to [Chapter 15](ch15.xhtml#ch15) in *The C++ Standard Library*, 2nd
    Edition, by Nicolai M. Josuttis or [iostream.format].*'
  prefs: []
  type: TYPE_NORMAL
- en: '***User-Defined Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can make user-defined types work with streams by implementing certain non-member
    functions. To implement the output operator for type `YourType`, the following
    function declaration serves most purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For most cases, you’ll simply return ➊ the same `ostream` you receive ➋. It’s
    up to you how to send output into the `ostream`. But typically, this involves
    accessing fields on `YourType` ➌, optionally performing some formatting and transformations,
    and then using the output operator. For example, [Listing 16-9](ch16.xhtml#ch16ex09)
    shows how to implement an output operator for `std::vector` to print its size,
    capacity, and elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-9: A program illustrating how to implement an output operator for
    a `vector`*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you define a custom output operator as a template, using the template
    parameter as the template parameter of `std::vector` ➊. This allows you to use
    the output operator for many kinds of `vector`s (as long as the type `T` also
    supports the output operator). The first three lines of output give the size and
    capacity of `vector`, as well as the title `Elements` indicating that the elements
    of the `vector` follow ➋. The following `for` loop iterates over each element
    in the `vector`, sending each on a separate line to the `ostream` ➌. Finally,
    you return the stream reference `s` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you initialize a `vector` called `characters` containing four
    strings ➎. Thanks to your user-defined output operator, you can simply send `characters`
    to `cout` as if it were a fundamental type ➏. The second example uses a `vector<bool>`
    called `bits`, which you also initialize with four elements ➐ and print to stdout
    ➑. Notice that you use the `boolalpha` manipulator, so when your user-defined
    output operator runs, the `bool` elements print textually ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also provide user-defined input operators, which work similarly. A
    simple corollary is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As with the output operator, the input operator typically returns ➊ the same
    stream it receives ➋. However, unlike with the output operator, the `YourType`
    reference will generally not be `const`, because you’ll want to modify the corresponding
    object using input from the stream ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 16-10](ch16.xhtml#ch16ex10) illustrates how to specify an input operator
    for `deque` so it pushes elements into the container until an insertion fails
    (for example, due to an EOF character).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-10: A program illustrating how to implement an input operator for
    a `deque`*'
  prefs: []
  type: TYPE_NORMAL
- en: Your user-defined input operator is a function template so you can accept any
    `deque` containing a type that supports the input operator ➊. First, you construct
    an element of type `T` so you can store input from the `istream` ➋. Next, you
    use the familiar `while` construct to accept input from the `istream` until the
    input operation fails ➌. (Recall from the “Stream State” section that streams
    can get into failed states in many ways, including reaching an EOF or encountering
    an I/O error.) After each insertion, you `move` the result into `emplace_back`
    on the `deque` to avoid unnecessary copies ➍. Once you’re done inserting, you
    simply return the `istream` reference ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you prompt the user for numbers ➏ and then use the insertion
    operator on a newly initialized `deque` to insert elements from stdin. In this
    sample program run, you input the numbers 1 to 5 ➐. For a bit of fun, you compute
    a cumulative sum by keeping a tally and iterating over each element, printing
    that iteration’s result ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The preceding examples are simple user-defined implementations of input and
    output operators. You might want to elaborate these implementations in production
    code. For example, the implementations only work with `ostream` classes, which
    implies that they won’t work with any non-`char` sequences.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***String Streams***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *string stream classes* provide facilities for reading from and writing
    to character sequences. These classes are useful in several situations. Input
    strings are especially useful if you want to parse string data into types. Because
    you can use the input operator, all the standard manipulator facilities are available
    to you. Output strings are excellent for building up strings from variable-length
    input.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output String Streams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Output string streams* provide output-stream semantics for character sequences,
    and they all derive from the class template `std::basic_ostringstream` in the
    `<sstream>` header, which provides the following specializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output string streams support all the same features as an `ostream`. Whenever
    you send input to the string stream, the stream stores this input into an internal
    buffer. You can think of this as functionally equivalent to the `append` operation
    of `string` (except that string streams are potentially more efficient).
  prefs: []
  type: TYPE_NORMAL
- en: Output string streams also support the `str()` method, which has two modes of
    operation. Given no argument, `str` returns a copy of the internal buffer as a
    `basic_string` (so `ostringstream` returns a `string`; `wostringstream` returns
    a `wstring`). Given a single `basic_string` argument, the string stream will replace
    its buffer’s current contents with the contents of the argument. [Listing 16-11](ch16.xhtml#ch16ex11)
    illustrates how to use an `ostringstream`, send character data to it, build a
    `string`, reset its contents, and repeat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-11: Using an `ostringstream` to build strings*'
  prefs: []
  type: TYPE_NORMAL
- en: After declaring an `ostringstream` ➊, you treat it just like any other `ostream`
    and use the output operator to send it three separate character sequences ➋. Next,
    you invoke `str` without an argument, which produces a `string` called `lazarus`
    ➌. Then you invoke `str` with the string literal `I am Groot` ➍, which replaces
    the contents of `ostringstream` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recall from “C-Style Strings” on [page 45](ch02.xhtml#page_45) that you can
    place multiple string literals on consecutive lines and the compiler will treat
    them as one. This is done purely for source code–formatting purposes.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input String Streams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Input string streams* provide input stream semantics for character sequences,
    and they all derive from the class template `std::basic_istringstream` in the
    `<sstream>` header, which provides the following specializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These are analogous to the `basic_ostringstream` specializations. You can construct
    input string streams by passing a `basic_string` with appropriate specialization
    (`string` for an `istringstream` and `wstring` for a `wistringstream`). [Listing
    16-12](ch16.xhtml#ch16ex12) illustrates by constructing an input string stream
    with a string containing three numbers and using the input operator to extract
    them. (Recall from “Formatted Operations” on [page 525](ch16.xhtml#page_525) that
    whitespace is the appropriate delimiter for string data.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-12: Using a `string` to build `istringstream` objects and extract
    numeric types*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `string` from the literal `1 2.23606 2` ➊, which you pass into
    the constructor of an `istringstream` called `ss` ➋. This allows you to use the
    input operator to parse out `int` objects ➌ and `float` objects ➍ just like any
    other input stream. Once you’ve exhausted the stream and the output operator fails,
    `ss` converts to `false` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**String Streams Supporting Input and Output**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Additionally, if you want a string stream that supports input and output operations,
    you can use the `basic_stringstream`, which has the following specializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This class supports the input and output operators, the `str` method, and construction
    from a string. [Listing 16-13](ch16.xhtml#ch16ex13) illustrates how to use a combination
    of input and output operators to extract tokens from a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-13: Using a `stringstream` for input and output*'
  prefs: []
  type: TYPE_NORMAL
- en: You create a `stringstream` and sent the `Zed's DEAD` with the output operator
    ➊. Next, you parse `Zed's` out of the `stringstream` using the input operator
    ➋. Because `DEAD` is a valid hexadecimal integer, you use the input operator and
    the `std::hex` manipulator to extract it into an `int` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All string streams are moveable.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary of String Stream Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 16-8](ch16.xhtml#ch16tab08) provides a partial list of `basic_stringstream`
    operations. In this table, `ss, ss1`, and `ss2` are of type `std::basic_stringstream<T>`;
    `s` is a `std::basic_string<``T``>`; `obj` is a formatted object; `pos` is a position
    type; `dir` is a `std::ios_base::seekdir`; and `flg` is a `std::ios_base::iostate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-8:** A Partial List of `std::basic_stringstream` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_stringstream<`T`>``{ [`s`], [`om`] }` | Performs braced initialization
    of a newly constructed string stream. Defaults to empty string s and `in&#124;out`
    open mode om. |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_stringstream<`T`>``{ move(`ss`) }` | Takes ownership of ss’s internal
    buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| `~basic_stringstream` | Destructs internal buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`rdbuf()` | Returns raw string device object. |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`str()` | Gets the contents of the string device object. |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`str(`s`)` | Sets the contents of the string device object to s. |'
  prefs: []
  type: TYPE_TB
- en: '| ss `>>` obj | Extracts formatted data from the string stream. |'
  prefs: []
  type: TYPE_TB
- en: '| ss `<<` obj | Inserts formatted data into the string stream. |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`tellg()` | Returns the input position index. |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`seekg(`pos`)`ss.`seekg(`pos, dir`)` | Sets the input position indicator.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`flush()` | Synchronizes the underlying device. |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`good()`ss.`eof()`ss.`bad()`!ss | Inspects the string stream’s bits. |'
  prefs: []
  type: TYPE_TB
- en: '| ss.`exceptions(`flg`)` | Configures the string stream to throw an exception
    whenever a bit in flg gets set. |'
  prefs: []
  type: TYPE_TB
- en: '| ss1.`swap(`ss2`)``swap(`ss1, ss2`)` | Exchanges each element of ss1 with
    those of ss2. |'
  prefs: []
  type: TYPE_TB
- en: '***File Streams***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *file stream classes* provide facilities for reading from and writing to
    character sequences. The file stream class structure follows that of the string
    stream classes. File stream class templates are available for input, output, and
    both.
  prefs: []
  type: TYPE_NORMAL
- en: 'File stream classes provide the following major benefits over using native
    system calls to interact with file contents:'
  prefs: []
  type: TYPE_NORMAL
- en: You get the usual stream interfaces, which provide a rich set of features for
    formatting and manipulating output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file stream classes are RAII wrappers around the files, meaning it’s impossible
    to leak resources, such as files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File stream classes support move semantics, so you can have tight control over
    where files are in scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opening Files with Streams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You have two options for opening a file with any file stream. The first option
    is the `open` method, which accepts a `const char* filename` and an optional `std::ios_base::openmode`
    bitmask argument. The `openmode` argument can be one of the many possible combinations
    of values listed in [Table 16-9](ch16.xhtml#ch16tab09).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-9:** Possible Stream States, Their Accessor Methods, and Their Meanings'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** (**in** `std::ios`) | **File** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Must exist | Read |'
  prefs: []
  type: TYPE_TB
- en: '| `out` | Created if doesn’t exist | Erase the file; then write |'
  prefs: []
  type: TYPE_TB
- en: '| `app` | Created if doesn’t exist | Append |'
  prefs: []
  type: TYPE_TB
- en: '| `in&#124;out` | Must exist | Read and write from beginning |'
  prefs: []
  type: TYPE_TB
- en: '| `in&#124;app` | Created if doesn’t exist | Update at end |'
  prefs: []
  type: TYPE_TB
- en: '| `out&#124;app` | Created if doesn’t exist | Append |'
  prefs: []
  type: TYPE_TB
- en: '| `out&#124;trunc` | Created if doesn’t exist | Erase the file; then read and
    write |'
  prefs: []
  type: TYPE_TB
- en: '| `in&#124;out&#124;app` | Created if doesn’t exist | Update at end |'
  prefs: []
  type: TYPE_TB
- en: '| `in&#124;out&#124;trunc` | Created if doesn’t exist | Erase the file; then
    read and write |'
  prefs: []
  type: TYPE_TB
- en: Additionally, you can add the `binary` flag to any of these combinations to
    put the file in *binary mode*. In binary mode, the stream won’t convert special
    character sequences, like end of line (for example, a carriage return plus a line
    feed on Windows) or EOF.
  prefs: []
  type: TYPE_NORMAL
- en: The second option for specifying a file to open is to use the stream’s constructor.
    Each file stream provides a constructor taking the same arguments as the `open`
    method. All file stream classes are RAII wrappers around the file handles they
    own, so the files will be automatically cleaned up when the file stream destructs.
    You can also manually invoke the `close` method, which takes no arguments. You
    might want to do this if you know you’re done with the file but your code is written
    in such a way that the file stream class object won’t destruct for a while.
  prefs: []
  type: TYPE_NORMAL
- en: File streams also have default constructors, which don’t open any files. To
    check whether a file is open, invoke the `is_open` method, which takes no arguments
    and returns a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output File Streams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Output file streams* provide output stream semantics for character sequences,
    and they all derive from the class template `std::basic_ofstream` in the `<fstream>`
    header, which provides the following specializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The default `basic_ofstream` constructor doesn’t open a file, and the non-default
    constructor’s second optional argument defaults to `ios::out`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you send input to the file stream, the stream writes the data to the
    corresponding file. [Listing 16-14](ch16.xhtml#ch16ex14) illustrates how to use
    `ofstream` to write a simple message to a text file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-14: A program opening the file lunchtime.txt and appending a message
    to it. (The output corresponds to the contents of lunchtime.txt after a single
    program execution.)*'
  prefs: []
  type: TYPE_NORMAL
- en: You initialize an `ofstream` called `file` with the path `lunchtime.txt` and
    the flags `out` and `app` ➊. Because this combination of flags appends output,
    any data you send through the output operator into this file stream gets appended
    to the end of the file. As expected, the file contains the message you passed
    to the output operator ➋➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the `ios::app` flag, the program will append output to *lunchtime.txt*
    if it exists. For example, if you run the program again, you’ll get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The second iteration of the program added the same phrase to the end of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input File Streams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Input file streams* provide input stream semantics for character sequences,
    and they all derive from the class template `std::basic_ifstream` in the `<fstream>`
    header, which provides the following specializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The default `basic_ifstream` constructor doesn’t open a file, and the non-default
    constructor’s second optional argument defaults to `ios::in`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you read from the file stream, the stream reads data from the corresponding
    file. Consider the following sample file, *numbers.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 16-15](ch16.xhtml#ch16ex15) contains a program that uses an `ifstream`
    to read from a text file containing integers and return the maximum. The output
    corresponds with invoking the program and passing the path of the file *numbers.txt*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-15: A program that reads the text file* numbers.txt *and prints
    its maximum integer*'
  prefs: []
  type: TYPE_NORMAL
- en: You first initialize an `istream` to open the *numbers.txt* text file ➊. Next,
    you initialize the maximum variable with the minimum value an `int` can take ➋.
    Using the idiomatic input stream and `while`-loop combination ➌, you cycle through
    each integer in the file, updating the maximum as you find higher values ➍. Once
    the file stream cannot parse any more integers, you print the result to stdout
    ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling Failure**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As with other streams, file streams fail silently. If you use a file stream
    constructor to open a file, you must check the `is_open` method to determine whether
    the stream successfully opened the file. This design differs from most other stdlib
    objects where invariants are enforced by exceptions. It’s hard to say why the
    library implementors chose this approach, but the fact is that you can opt into
    an exception-based approach fairly easily.
  prefs: []
  type: TYPE_NORMAL
- en: You can make your own factory functions to handle file-opening failures with
    exceptions. [Listing 16-16](ch16.xhtml#ch16ex16) illustrates how to implement
    an `ifstream` factory called `open`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-16: A factory function for generating `ifstream`s that handle errors
    with exceptions rather than failing silently*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your factory function returns an `ifstream` ➊ and accepts the same arguments
    as a file stream’s constructor (and `open` method): a file `path` ➋ and an `openmode`
    ➌. You pass these two arguments into the constructor of `ifstream` ➍ and then
    determine whether the file opened successfully ➎. If it didn’t, you throw a `runtime_error`
    ➏. If it did, you tell the resulting `ifstream` to throw an exception whenever
    its `badbit` gets set in the future ➐.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary of File Stream Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 16-10](ch16.xhtml#ch16tab010) provides a partial list of `basic_fstream`
    operations. In this table, `fs, fs1`, and `fs2` are of type `std:: basic_fstream
    <T>`; `p` is a C-style string, `std::string`, or a `std::filesystem::path`; `om`
    is an `std::ios_base::openmode`; `s` is a `std::basic_string<``T``>`; `obj` is
    a formatted object; `pos` is a position type; `dir` is a `std::ios_base::seekdir`;
    and `flg` is a `std::ios_base::iostate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 16-10:** A Partial List of `std::basic_fstream` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_fstream<`T`>``{ [`p`], [`om`] }` | Performs braced initialization
    of a newly constructed file stream. If p is provided, attempts to open file at
    path p. Defaults to not opened and `in&#124;out` open mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `basic_fstream<`T`>``{ move(`fs`) }` | Takes ownership of the internal buffer
    of fs. |'
  prefs: []
  type: TYPE_TB
- en: '| `~basic_fstream` | Destructs internal buffer. |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`rdbuf()` | Returns raw string device object. |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`str()` | Gets the contents of the file device object. |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`str(`s`)` | Puts the contents of the file device object into s. |'
  prefs: []
  type: TYPE_TB
- en: '|  fs `>>` obj  | Extracts formatted data from the file stream. |'
  prefs: []
  type: TYPE_TB
- en: '| fs `<<` obj | Inserts formatted data into the file stream. |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`tellg()` | Returns the input position index. |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`seekg(`pos`)`fs.`seekg(`pos, dir`)` | Sets the input position indicator.
    |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`flush()` | Synchronizes the underlying device. |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`good()`fs.`eof()`fs.`bad()``!`fs | Inspects the file stream’s bits. |'
  prefs: []
  type: TYPE_TB
- en: '| fs.`exceptions(`flg`)` | Configures the file stream to throw an exception
    whenever a bit in flg gets set. |'
  prefs: []
  type: TYPE_TB
- en: '| fs1.`swap(`fs2`)``swap(`fs1, fs2`)` | Exchanges each element of fs1 with
    one of fs2. |'
  prefs: []
  type: TYPE_TB
- en: '***Stream Buffers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Streams don’t read and write directly. Under the covers, they use stream buffer
    classes. At a high level, *stream buffer classes* are templates that send or extract
    characters. The implementation details aren’t important unless you’re planning
    on implementing your own stream library, but it’s important to know that they
    exist in several contexts. The way you obtain stream buffers is by using a stream’s
    `rdbuf` method, which all streams provide.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing Files to sdout**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes you just want to write the contents of an input file stream directly
    into an output stream. To do this, you can extract the stream buffer pointer from
    the file stream and pass it to the output operator. For example, you can dump
    the contents of a file to stdout using `cout` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It’s that easy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output Stream Buffer Iterators**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Output stream buffer iterators* are template classes that expose an output
    iterator interface that translates writes into output operations on the underlying
    stream buffer. In other words, these are adapters that allow you to use output
    streams as if they were output iterators.'
  prefs: []
  type: TYPE_NORMAL
- en: To construct an output stream buffer iterator, use the `ostreambuf_iterator`
    template class in the `<iterator>` header. Its constructor takes a single output
    stream argument and a single template parameter corresponding to the constructor
    argument’s template parameter (the character type). [Listing 16-17](ch16.xhtml#ch16ex17)
    shows how to construct an output stream buffer iterator from `cout`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-17: Writing the message `Hi` to stdout using the `ostreambuf_iterator`
    class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you construct an output stream buffer iterator from `cout` ➊, which you
    write to in the usual way for an output operator: assign ➋, increment ➌, assign
    ➍, and so on. The result is character-by-character output to stdout. (Recall the
    procedures for handling output operators in “Output Iterators” on [page 464](ch14.xhtml#page_464).)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input Stream Buffer Iterators**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Input stream buffer iterators* are template classes that expose an input iterator
    interface that translates reads into read operations on the underlying stream
    buffer. These are entirely analogous to output stream buffer iterators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct an input stream buffer iterator, use the `istreambuf_iterator`
    template class in the `<iterator>` header. Unlike `ostreambuf_iterator`, it takes
    a stream buffer argument, so you must call `rdbuf()` on whichever input stream
    you want to adapt. This argument is optional: the default constructor of `istreambuf_iterator`
    corresponds to the end-of-range iterator of input iterator. For example, [Listing
    16-18](ch16.xhtml#ch16ex18) illustrates how to construct a string from `std::cin`
    using the range-based constructor of `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-18: Constructing a string from `cin` using input stream buffer
    iterators*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct an `istreambuf_iterator` from the stream buffer of `cin` ➊ as
    well as the end-of-range iterator ➋. After sending a prompt to the program’s user
    ➌, you construct the `string name` using its range-based constructor ➍. When the
    user sends input (terminated by EOF), the string’s constructor copies it. You
    then bid the user farewell using their `name` ➎. (Recall from “Stream State” on
    [page 530](ch16.xhtml#page_530) that methods for sending EOF to the console differ
    by operating system.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Random Access***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll want random access into a stream (especially a file stream).
    The input and output operators clearly don’t support this use case, so `basic_istream`
    and `basic_ostream` offer separate methods for random access. These methods keep
    track of the cursor or position, the index of the stream’s current character.
    The position indicates the next byte that an input stream will read or an output
    stream will write.
  prefs: []
  type: TYPE_NORMAL
- en: 'For input streams, you can use the two methods `tellg` and `seekg`. The `tellg`
    method takes no arguments and returns the position. The `seekg` method allows
    you to set the cursor position, and it has two overloads. Your first option is
    to provide a `pos_type` position argument, which sets the read position. The second
    is to provide an `off_type` offset argument plus an `ios_base::seekdir` direction
    argument. The `pos_type` and `off_type` are determined by the template arguments
    to the `basic_istream` or `basic_ostream`, but usually these convert to/from integer
    types. The `seekdir` type takes one of the following three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ios_base::beg` specifies that the position argument is relative to the beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios_base::cur` specifies that the position argument is relative to the current
    position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios_base::end` specifies that the position argument is relative to the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For output streams, you can use the two methods `tellp` and `seekp`. These
    are roughly analogous to the `tellg` and `seekg` methods of input streams: the
    `p` stands for put and the `g` stands for get.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a file *introspection.txt* with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 16-19](ch16.xhtml#ch16ex19) illustrates how to employ random access
    methods to reset the file cursor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-19: A program using random access methods to read arbitrary characters
    in a text file*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the factory function in [Listing 16-16](ch16.xhtml#ch16ex16) ➊, you open
    the text file *introspection.txt* ➋. Next, you print the contents to stdout using
    the `rdbuf` method ➌, rewind the cursor to the first character ➍, and print the
    contents again. Notice that these yield identical output (because the file hasn’t
    changed) ➎. You then use the relative offset overload of `seekg` to navigate to
    the fourth character from the end ➏. Using `tellg`, you learn that this is the
    49th character (with zero-base indexing) ➐. When you print the input file to stdout,
    the output is only `end.`, because these are the last four characters in the file
    ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost offers an IOStream library with a rich set of additional features that
    stdlib doesn’t have, including facilities for memory mapped file I/O, compression,
    and filtering.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about streams, the major concept that provides
    a common abstraction for performing I/O. You also learned about files as a primary
    source and destination for I/O. You first learned about the fundamental stream
    classes in the stdlib and how to perform formatted and unformatted operations,
    inspect stream state, and handle errors with exceptions. You learned about manipulators
    and how to incorporate streams into user-defined types, string streams, and file
    streams. This chapter culminated with stream buffer iterators, which allow you
    to adapt a stream to an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: '**16-1.** Implement an output operator that prints information about the `AutoBrake`
    from “An Extended Example: Taking a Brake” on [page 283](ch10.xhtml#page_283).
    Include the vehicle’s current collision threshold and speed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**16-2.** Write a program that takes output from stdin, capitalizes it, and
    writes the result to stdout.'
  prefs: []
  type: TYPE_NORMAL
- en: '**16-3.** Read the introductory documentation for Boost IOStream.'
  prefs: []
  type: TYPE_NORMAL
- en: '**16-4.** Write a program that accepts a file path, opens the file, and prints
    summary information about the contents, including word count, average word length,
    and a histogram of the characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Standard C++ IOStreams and Locales: Advanced Programmer’s Guide and Reference*
    by Angelika Langer (Addison-Wesley Professional, 2000)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
