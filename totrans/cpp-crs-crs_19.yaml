- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16'
- en: STREAMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 流**
- en: '*Either write something worth reading or do something worth writing.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*要么写些值得阅读的东西，要么做些值得书写的事情。'
- en: —Benjamin Franklin*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —本杰明·富兰克林*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter introduces streams, the major concept that enables you to connect
    inputs from any kind of source and outputs to any kind of destination using a
    common framework. You’ll learn about the classes that form the base elements of
    this common framework, several built-in facilities, and how to incorporate streams
    into user-defined types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍流这一主要概念，它使你能够使用一个通用框架连接来自任何源的输入和任何目标的输出。你将了解构成该通用框架的基本元素的类、几个内置功能，并学习如何将流集成到用户定义的类型中。
- en: '**Streams**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流**'
- en: A *stream* models a *stream of data*. In a stream, data flows between objects,
    and those objects can perform arbitrary processing on the data. When you’re working
    with streams, output is data going into the stream and input is data coming out
    of the stream. These terms reflect the streams as viewed from the user’s perspective.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*流* 模拟 *数据流*。在流中，数据在对象之间流动，这些对象可以对数据执行任意处理。当你使用流时，输出是进入流的数据，输入是流中出来的数据。这些术语反映了用户视角下的流。'
- en: 'In C++, streams are the primary mechanism for performing input and output (I/O).
    Regardless of the source or destination, you can use streams as the common language
    to connect inputs to outputs. The STL uses class inheritance to encode the relationships
    between various stream types. The primary types in this hierarchy are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，流是执行输入输出（I/O）的主要机制。无论数据源或目标是什么，你都可以使用流作为连接输入和输出的通用语言。STL 使用类继承来编码不同流类型之间的关系。这些层次结构中的主要类型有：
- en: The `std::basic_ostream` class template in the `<ostream>` header that represents
    an output device
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ostream>`头文件中的`std::basic_ostream`类模板代表输出设备'
- en: The `std::basic_istream` class template in the `<istream>` header that represents
    an input device
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<istream>`头文件中的`std::basic_istream`类模板代表输入设备'
- en: The `std::basic_iostream` class template in the `<iostream``>` header for devices
    that are input and output
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<iostream>`头文件中的`std::basic_iostream`类模板代表同时具有输入输出功能的设备'
- en: All three stream types require two template parameters. The first corresponds
    to the stream’s underlying data type and the second to a traits type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种流类型都需要两个模板参数。第一个对应流的底层数据类型，第二个对应特征类型。
- en: This section covers streams from a user’s perspective rather than from a library
    implementer’s perspective. You’ll understand the streams interface and know how
    to interact with standard I/O, files, and strings using the STL’s built-in stream
    support. If you must implement a new kind of stream (for example, for a new library
    or framework), you’ll need a copy of the ISO C++ 17 Standard, some working examples,
    and an ample supply of coffee. I/O is complicated, and you’ll see this difficulty
    reflected in a stream implementation’s internal complexity. Fortunately, a well-designed
    stream class hides much of this complexity from users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本节从用户的角度介绍流，而不是从库实现者的角度。你将了解流的接口，并知道如何使用 STL 内置的流支持与标准 I/O、文件和字符串进行交互。如果你必须实现一种新的流（例如，为新的库或框架），你将需要一份
    ISO C++ 17 标准、一些工作示例以及大量的咖啡。I/O 很复杂，你会看到这种复杂性在流实现的内部结构中有所体现。幸运的是，设计良好的流类会将这些复杂性隐藏起来，使得用户不必直接面对。
- en: '***Stream Classes***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流类***'
- en: All STL stream classes that users interact with derive from `basic_istream,
    basic_ostream`, or both via `basic_iostream`. The headers that declare each type
    also provide `char` and `wchar_t` specializations for those templates, as outlined
    in [Table 16-1](ch16.xhtml#ch16tab01). These heavily used specializations are
    particularly useful when you’re working with human-language data input and output.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户交互的 STL 流类都来源于`basic_istream`、`basic_ostream`，或者通过`basic_iostream`同时继承这两者。声明每种类型的头文件还为这些模板提供了`char`和`wchar_t`的特化，如[表16-1](ch16.xhtml#ch16tab01)所示。这些广泛使用的特化在处理人类语言数据的输入输出时尤其有用。
- en: '**Table 16-1:** Template Specializations for the Primary Stream Templates'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-1：** 主要流模板的模板特化'
- en: '| **Template** | **Parameter** | **Specialization** | **Header** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **模板** | **参数** | **特化** | **头文件** |'
- en: '| `basic_istream` | `char` | `istream` | `<istream>` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `basic_istream` | `char` | `istream` | `<istream>` |'
- en: '| `basic_ostream` | `char` | `ostream` | `<ostream>` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `basic_ostream` | `char` | `ostream` | `<ostream>` |'
- en: '| `basic_iostream` | `char` | `iostream` | `<iostream>` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `basic_iostream` | `char` | `iostream` | `<iostream>` |'
- en: '| `basic_istream` | `wchar_t` | `wistream` | `<istream>` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `basic_istream` | `wchar_t` | `wistream` | `<istream>` |'
- en: '| `basic_ostream` | `wchar_t` | `wostream` | `<ostream>` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `basic_ostream` | `wchar_t` | `wostream` | `<ostream>` |'
- en: '| `basic_iostream` | `wchar_t` | `wiostream` | `<iostream>` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `basic_iostream` | `wchar_t` | `wiostream` | `<iostream>` |'
- en: The objects in [Table 16-1](ch16.xhtml#ch16tab01) are abstractions that you
    can use in your programs to write generic code. Do you want to write a function
    that logs output to an arbitrary source? If so, you can accept an `ostream` reference
    parameter and not deal with all the nasty implementation details. (Later in the
    “Output File Streams” on [page 542](ch16.xhtml#page_542), you’ll learn how to
    do this.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-1](ch16.xhtml#ch16tab01)中的对象是你可以在程序中使用的抽象，你可以利用它们编写通用代码。你想写一个将输出日志记录到任意源的函数吗？如果是，你可以接受一个
    `ostream` 引用参数，而不需要处理所有那些令人头疼的实现细节。（稍后在“输出文件流”部分[第 542 页](ch16.xhtml#page_542)，你将学到如何实现这一点。）'
- en: Often, you’ll want to perform I/O with the user (or the program’s environment).
    Global stream objects provide a convenient, stream-based wrapper for you to work
    against.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能需要与用户（或程序的执行环境）进行 I/O 操作。全局流对象提供了一个方便的基于流的封装，供你操作。
- en: '**Global Stream Objects**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**全局流对象**'
- en: The STL provides several *global stream objects* in the `<iostream>` header
    that wrap the input, output, and error streams stdin, stdout, and stderr. These
    implementation-defined standard streams are preconnected channels between your
    program and its executing environment. For example, in a desktop environment,
    stdin typically binds to the keyboard and stdout and stderr bind to the console.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: STL 在 `<iostream>` 头文件中提供了几个 *全局流对象*，它们封装了输入、输出和错误流 stdin、stdout 和 stderr。这些实现定义的标准流是你程序与其执行环境之间的预连接通道。例如，在桌面环境中，stdin
    通常绑定到键盘，stdout 和 stderr 则绑定到控制台。
- en: '**NOTE**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall that in [Part I](part01.xhtml#part01) you saw extensive use of `printf`
    to write to stdout.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*回想一下，在 [第一部分](part01.xhtml#part01)中，你看到过广泛使用 `printf` 向 stdout 写入数据。*'
- en: '[Table 16-2](ch16.xhtml#ch16tab02) lists the global stream objects, all of
    which reside in the `std` namespace.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-2](ch16.xhtml#ch16tab02)列出了全局流对象，所有这些对象都位于 `std` 命名空间中。'
- en: '**Table 16-2:** The Global Stream Objects'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-2：** 全局流对象'
- en: '| **Object** | **Type** | **Purpose** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **类型** | **目的** |'
- en: '| --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `cout``wcout` | `ostream``wostream` | Output, like a screen |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `cout``wcout` | `ostream``wostream` | 输出，如屏幕 |'
- en: '| `cin``wcin` | `istream``wistream` | Input, like a keyboard |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `cin``wcin` | `istream``wistream` | 输入，如键盘 |'
- en: '| `cerr``wcerr` | `ostream``wostream` | Error output (unbuffered) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `cerr``wcerr` | `ostream``wostream` | 错误输出（无缓冲） |'
- en: '| `clog``wclog` | `ostream``wostream` | Error output (buffered) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `clog``wclog` | `ostream``wostream` | 错误输出（有缓冲） |'
- en: 'So how do you use these objects? Well, stream classes support operations that
    you can partition into two categories:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何使用这些对象呢？流类支持的操作可以分为两类：
- en: '**Formatted operations** Might perform some preprocessing on their input parameters
    before performing I/O'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式化操作** 可能会在执行 I/O 之前对输入参数进行一些预处理'
- en: '**Unformatted operations** Perform I/O directly'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**未格式化操作** 直接执行 I/O 操作'
- en: The following sections explain each of these categories in turn.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分会依次解释这些类别。
- en: '**Formatted Operations**'
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**格式化操作**'
- en: 'All formatted I/O passes through two functions: the *standard stream operators*,
    `operator<<` and `operator>>`. You’ll recognize these as the left and right shift
    operators from “Logical Operators” on [page 182](ch07.xhtml#page_182). Somewhat
    confusingly, streams overload the left and right shift operators with completely
    unrelated functionality. The semantic meaning of the expression `i << 5` depends
    entirely on the type of `i`. If `i` is an integral type, this expression means
    *take* i *and shift the bits to the left by five binary digits*. If `i` is not
    an integral type, it means *write the value 5 into* i. Although this notational
    collision is unfortunate, in practice it doesn’t cause too much trouble. Just
    pay attention to the types you’re using and test your code well.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有格式化 I/O 都通过两个函数传递：*标准流操作符*，`operator<<` 和 `operator>>`。你会认出这些是来自“逻辑运算符”部分的左移和右移操作符[第
    182 页](ch07.xhtml#page_182)。有些令人困惑的是，流重载了左移和右移操作符，赋予它们完全不同的功能。表达式 `i << 5` 的语义完全依赖于
    `i` 的类型。如果 `i` 是一个整数类型，这个表达式的意思是 *取* i *并将其按左移五个二进制位*。如果 `i` 不是一个整数类型，它意味着 *将值
    5 写入* i。虽然这种符号冲突很不幸，但在实际应用中并不会造成太大问题。只需要注意你使用的类型，并且充分测试你的代码。
- en: Output streams overload `operator<<`, which is referred to as the *output operator*
    or the *inserter*. The `basic_ostream` class template overloads the output operator
    for all fundamental types (except `void` and `nullptr_t`) and some STL containers,
    such as `basic_string, complex`, and `bitset`. As an `ostream` user, you need
    not worry about how these overloads translate objects into readable output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出流重载了`operator<<`，它被称为*输出操作符*或*插入器*。`basic_ostream`类模板为所有基本类型（除了`void`和`nullptr_t`）及一些STL容器（如`basic_string`、`complex`和`bitset`）重载了输出操作符。作为`ostream`的用户，你无需担心这些重载如何将对象转换为可读输出。
- en: '[Listing 16-1](ch16.xhtml#ch16ex01) illustrates how to use the output operator
    to write various types into `cout`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-1](ch16.xhtml#ch16ex01)展示了如何使用输出操作符将各种类型写入`cout`。'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 16-1: Using `cout` and `operator<<` to write into stdout*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-1：使用`cout`和`operator<<`写入标准输出*'
- en: You use the output `operator``<<` to write a `bitset` ➊, a `char` ➋, a `string`
    ➌, a `size_t` ➍, and a null-terminated string literal ➎ to stdout via `cout`.
    Even though you write five distinct types to the console, you never deal with
    serialization issues. (Consider the hoops you would have had to jump through to
    get `printf` to yield similar output given these types.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用输出`操作符`<<`将`bitset` ➊、`char` ➋、`string` ➌、`size_t` ➍和一个以空字符终止的字符串文字 ➎通过`cout`写入标准输出。尽管你向控制台输出了五种不同类型的数据，但你无需处理序列化问题。（考虑如果使用`printf`来得到类似的输出，你将不得不跳过多少障碍。）
- en: 'One very nice feature of the standard stream operators is that they generally
    return a reference to the stream. Conceptually, overloads are typically defined
    along the following lines:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标准流操作符的一个非常棒的特点是，它们通常会返回对流的引用。从概念上讲，重载通常是这样定义的：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means you can chain output operators together. Using this technique, you
    can refactor [Listing 16-1](ch16.xhtml#ch16ex01) so `cout` appears only once,
    as [Listing 16-2](ch16.xhtml#ch16ex02) illustrates.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以将输出操作符链接在一起。通过这种技巧，你可以重构[清单 16-1](ch16.xhtml#ch16ex01)，使得`cout`只出现一次，正如[清单
    16-2](ch16.xhtml#ch16ex02)所示。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 16-2: Refactoring [Listing 16-1](ch16.xhtml#ch16ex01) by chaining
    output operators together*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-2：通过链式调用输出操作符重构[清单 16-1](ch16.xhtml#ch16ex01)*'
- en: Because each invocation of `operator<<` returns a reference to the output stream
    (here, `cout`), you simply chain the calls together to obtain identical output
    ➊.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次调用`operator<<`都会返回一个对输出流（此处为`cout`）的引用，你只需将这些调用链接在一起，就能获得相同的输出 ➊。
- en: Input streams overload `operator>>`, which is referred to as the *input operator*
    or the *extractor*. The `basic_istream` class has corresponding overloads for
    the input operator for all the same types as `basic_ostream`, and again as a user,
    you can largely ignore the deserialization details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输入流重载了`operator>>`，它被称为*输入操作符*或*提取器*。`basic_istream`类为所有与`basic_ostream`相同的类型提供了对应的输入操作符重载，同样作为用户，你也可以在很大程度上忽略反序列化的细节。
- en: '[Listing 16-3](ch16.xhtml#ch16ex03) illustrates how to use the input operator
    to read two `double` objects and a `string` from `cin`, then print the implied
    mathematical operation’s result to stdout.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-3](ch16.xhtml#ch16ex03)展示了如何使用输入操作符从`cin`读取两个`double`对象和一个`string`，然后将推导出的数学运算结果输出到标准输出。'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 16-3: A primitive calculator program using `cin` and `operator<<`
    to collect input*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-3：一个原始计算器程序，使用`cin`和`operator<<`收集输入*'
- en: Here, you collect two `double`s `x` ➊ and `y` ➋ followed by the `string op`
    ➌, which encodes the desired operation. Using an `if` statement, you can output
    the specified operation’s result for addition ➍, subtraction ➎, multiplication
    ➏, and division ➐, or indicate to the user that `op` is unknown ➑.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你收集了两个`double`类型的值`x` ➊和`y` ➋，接着是`string op` ➌，它编码了所需的运算类型。通过`if`语句，你可以输出指定运算的结果，如加法
    ➍、减法 ➎、乘法 ➏和除法 ➐，或者告诉用户`op`是未知的 ➑。
- en: To use the program, you type the requested values into the console when directed.
    A newline will send the input (as stdin) to `cin`, as [Listing 16-4](ch16.xhtml#ch16ex04)
    illustrates.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该程序，你需要按照指示在控制台中输入请求的值。一个换行符将会把输入（作为stdin）传递给`cin`，如[清单 16-4](ch16.xhtml#ch16ex04)所示。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 16-4: A sample run of the program in [Listing 16-3](ch16.xhtml#ch16ex03)
    that calculates the circumference of Earth in miles*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-4：一个示例程序运行，计算地球的周长（以英里为单位），来自[清单 16-3](ch16.xhtml#ch16ex03)*'
- en: 'You input the two `double` objects: the radius of Earth in miles, `3959` ➊
    and 2π, 6.283185 ➋, and you specify multiplication `*` ➌. The result is Earth’s
    circumference in miles ➍. Note that you don’t need to provide a decimal point
    for an integral value ➊; the stream is smart enough to know that there’s an implicit
    decimal.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你输入了两个`double`对象：地球的半径，单位为英里，`3959` ➊ 和 2π，6.283185 ➋，并指定了乘法`*` ➌。结果是地球的周长，单位为英里
    ➍。注意，对于整数值➊，你不需要提供小数点；流会智能地知道有一个隐式的小数点。
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might wonder what happens in [Listing 16-4](ch16.xhtml#ch16ex04) if you
    input a non-numeric string for `X` ➊ or `Y` ➋. The stream enters an error state,
    which you’ll learn about later in this chapter in the “Stream State” section on
    [page 530](ch16.xhtml#page_530). In an error state, the stream ceases to accept
    input, and the program won’t accept any more input.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会想，如果在[示例16-4](ch16.xhtml#ch16ex04)中输入一个非数字字符串作为`X` ➊ 或 `Y` ➋ 会发生什么。流进入错误状态，稍后你将在本章的“流状态”部分（[第530页](ch16.xhtml#page_530)）了解这个问题。在错误状态下，流停止接受输入，程序将不再接受任何输入。*'
- en: '**Unformatted Operations**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**未格式化操作**'
- en: When you’re working with text-based streams, you’ll usually want to use formatted
    operators; however, if you’re working with binary data or if you’re writing code
    that needs low-level access to streams, you’ll want to know about the unformatted
    operations. Unformatted I/O involves a lot of detail. For brevity, this section
    provides a summary of the relevant methods, so if you need to use unformatted
    operations, refer to [input.output].
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在处理基于文本的流时，通常会想使用格式化操作符；然而，如果你在处理二进制数据或编写需要低级访问流的代码时，你需要了解未格式化操作。未格式化输入输出涉及很多细节。为了简洁起见，本节提供了相关方法的总结，如果你需要使用未格式化操作，请参考[input.output]。
- en: The `istream` class has many unformatted input methods. These methods manipulate
    streams at the byte level and are summarized in [Table 16-3](ch16.xhtml#ch16tab03).
    In this table, `is` is of type `std::istream <T>, s` is a `char*, n` is a stream
    size, `pos` is a position type, and `d` is a delimiter of type `T`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream`类有许多未格式化的输入方法。这些方法在字节级别操作流，并在[表16-3](ch16.xhtml#ch16tab03)中进行了总结。在此表中，`is`是类型为`std::istream
    <T>`，`s`是`char*`，`n`是流大小，`pos`是位置类型，`d`是类型`T`的定界符。'
- en: '**Table 16-3:** Unformatted Read Operations for `istream`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-3：** `istream`的未格式化读取操作'
- en: '| **Method** | **Description** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| is.`get([`c`])` | Returns next character or writes to character reference
    c if provided. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| is.`get([`c`])` | 返回下一个字符，或者如果提供了字符引用c，则写入该字符。 |'
- en: '| is.`get(`s, n, `[`d`])`is.`getline(`s, n, `[`d`])` | The operation `get`
    reads up to n characters into the buffer s, stopping if it encounters a newline,
    or d if provided. The operation `getline` is the same except it reads the newline
    character as well. Both write a terminating null character to s. You must ensure
    `s` has enough space. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| is.`get(`s, n, `[`d`])`is.`getline(`s, n, `[`d`])` | 操作`get`将最多n个字符读取到缓冲区s中，遇到换行符时停止，若提供了d，则在遇到d时停止。操作`getline`与之相同，唯一的区别是它还会读取换行符。两者都会将终止的空字符写入s。你必须确保`s`有足够的空间。
    |'
- en: '| is.`read(`s, n`)`is.`readsome(`s, n`)` | The operation `read` reads up to
    n characters into the buffer s; encountering end of file is an error. The operation
    `readsome` is the same except it doesn’t consider end of file an error. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| is.`read(`s, n`)`is.`readsome(`s, n`)` | 操作`read`将最多n个字符读取到缓冲区s中；遇到文件结尾时会报错。操作`readsome`与之相同，唯一的区别是它不把文件结尾视为错误。
    |'
- en: '| is.`gcount()` | Returns the number of characters read by is’s last unformatted
    read operation. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| is.`gcount()` | 返回`is`上次未格式化读取操作所读取的字符数。 |'
- en: '| is.`ignore()` | Extracts and discards a single character. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| is.`ignore()` | 提取并丢弃一个字符。 |'
- en: '| is.`ignore(`n, `[`d`])` | Extracts and discards up to n characters. If d
    is provided, `ignore` stops if d is found. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| is.`ignore(`n, `[`d`])` | 提取并丢弃最多n个字符。如果提供了d，则在遇到d时停止。 |'
- en: '| is.`peek()` | Returns the next character to be read without extracting. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| is.`peek()` | 返回下一个待读取的字符，但不提取它。 |'
- en: '| is.`unget()` | Puts the last extracted character back into the string. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| is.`unget()` | 将最后提取的字符放回字符串中。 |'
- en: '| is.`putback(`c`)` | If `c` is the last character extracted, executes `unget`.
    Otherwise, sets the `badbit`. Explained in the “Stream State” section. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| is.`putback(`c`)` | 如果`c`是最后提取的字符，执行`unget`操作。否则，设置`badbit`。详见“流状态”部分。 |'
- en: Output streams have corollary unformatted write operations, which manipulate
    streams at a very low level, as summarized in [Table 16-4](ch16.xhtml#ch16tab04).
    In this table, `os` is of type `std::ostream <T>``, s` is a `char*`, and `n` is
    a stream size.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出流有相应的未格式化写入操作，它们在非常低的层次上操作流，如[表16-4](ch16.xhtml#ch16tab04)所总结。在该表中，`os` 是
    `std::ostream <T>` 类型，`s` 是 `char*`，`n` 是流的大小。
- en: '**Table 16-4:** Unformatted Write Operations for `ostream`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-4：** `ostream` 的未格式化写入操作'
- en: '| **Method** | **Description** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| os.`put(`c`)` | Writes c to the stream |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| os.`put(`c`)` | 将 c 写入流 |'
- en: '| os.`write(`s, n`)` | Writes n characters from s to the stream |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| os.`write(`s, n`)` | 将 n 个字符从 s 写入流 |'
- en: '| os.`flush()` | Writes all buffered data to the underlying device |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| os.`flush()` | 将所有缓冲数据写入底层设备 |'
- en: '**Special Formatting for Fundamental Types**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基本类型的特殊格式化**'
- en: 'All fundamental types, in addition to `void` and `nullptr`, have input and
    output operator overloads, but some have special rules:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基本类型，除了 `void` 和 `nullptr`，都重载了输入和输出操作符，但有些类型有特殊规则：
- en: char **and** wchar_t The input operator skips whitespace when assigning character
    types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: char **和** wchar_t 输入操作符会跳过空白字符来处理字符类型。
- en: char* **and** wchar_t* The input operator first skips whitespace and then reads
    the string until it encounters another whitespace or an end-of-file (EOF). You
    must reserve enough space for the input.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: char* **和** wchar_t* 输入操作符首先跳过空白字符，然后读取字符串，直到遇到另一个空白字符或文件结尾（EOF）。必须为输入保留足够的空间。
- en: void* Address formats are implementation dependent for input and output operators.
    On desktop systems, addresses take hexadecimal literal form, such as `0x01234567`
    for 32-bit or `0x0123456789abcdef` for 64-bit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: void* 地址格式依赖于实现，输入和输出操作符也是如此。在桌面系统上，地址通常以十六进制字面量形式表示，如32位的 `0x01234567` 或64位的
    `0x0123456789abcdef`。
- en: 'bool The input and output operators treat Boolean values as numbers: 1 for
    `true` and 0 for `false`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: bool 输入和输出操作符将布尔值视为数字：`true` 为 1，`false` 为 0。
- en: '**Numeric types** The input operator requires that input begin with at least
    one digit. Badly formed input numbers yield a zero-valued result.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字类型** 输入操作符要求输入必须以至少一个数字开头。格式不正确的输入数字会导致零值结果。'
- en: These rules might seem a bit strange at first, but they’re fairly straightforward
    once you get used to them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则乍一看可能有些奇怪，但一旦习惯了，它们其实相当简单明了。
- en: '**NOTE**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Avoid reading into C-style strings, because it’s up to you to ensure that
    you’ve allocated enough space for the input data. Failure to perform adequate
    checking results in undefined behavior and possibly major security vulnerabilities.
    Use `std::string` instead.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免读取 C 风格字符串，因为你需要确保为输入数据分配了足够的空间。未进行充分检查会导致未定义行为，可能带来严重的安全漏洞。建议使用 `std::string`
    替代。*'
- en: '***Stream State***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流状态***'
- en: 'A stream’s state indicates whether I/O failed. Each stream type exposes the
    constant static members referred to collectively as its *bits*, which indicate
    a possible stream state: `goodbit, badbit, eofbit`, and `failbit`. To determine
    whether a stream is in a particular state, you invoke member functions that return
    a `bool` indicating whether the stream is in the corresponding state. [Table 16-5](ch16.xhtml#ch16tab05)
    lists these member functions, the stream state corresponding to a `true` result,
    and the state’s meaning.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 流的状态指示了输入/输出是否失败。每种流类型都暴露出常量静态成员，统称为它的*位标志*，这些标志指示流的可能状态：`goodbit`、`badbit`、`eofbit`
    和 `failbit`。要判断流是否处于特定状态，可以调用返回`bool`值的成员函数，表示流是否处于对应状态。[表16-5](ch16.xhtml#ch16tab05)列出了这些成员函数、`true`结果对应的流状态以及该状态的含义。
- en: '**Table 16-5:** The Possible Stream States, Their Accessor Methods, and Their
    Meanings'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-5：** 可能的流状态、它们的访问方法及其含义'
- en: '| **Method** | **State** | **Meaning** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **状态** | **含义** |'
- en: '| `good()` | `goodbit` | The stream is in a good working state. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `good()` | `goodbit` | 流处于良好的工作状态。 |'
- en: '| `eof()` | `eofbit` | The stream encountered an EOF. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `eof()` | `eofbit` | 流遇到文件结尾（EOF）。 |'
- en: '| `fail()` | `failbit` | An input or output operation failed, but the stream
    might still be in a good working state. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `fail()` | `failbit` | 输入或输出操作失败，但流可能仍处于良好的工作状态。 |'
- en: '| `bad()` | `badbit` | A catastrophic error occurred, and the stream is not
    in a good state. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `bad()` | `badbit` | 发生了灾难性错误，流不处于良好状态。 |'
- en: '**NOTE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To reset a stream’s status to indicate a good working state, you can invoke
    its `clear()` method.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*要将流的状态重置为良好的工作状态，可以调用其 `clear()` 方法。*'
- en: Streams implement an implicit bool conversion (`operator bool`), so you can
    check whether a stream is in a good working state simply and directly. For example,
    you can read input from stdin word by word until it encounters an EOF (or some
    other failure condition) using a simple `while` loop. [Listing 16-5](ch16.xhtml#ch16ex05)
    illustrates a simple program that uses this technique to generate word counts
    from stdin.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 流实现了隐式的布尔转换（`operator bool`），因此你可以简单直接地检查流是否处于良好的工作状态。例如，你可以使用一个简单的`while`循环逐词从stdin读取输入，直到遇到EOF（或其他失败条件）。[清单16-5](ch16.xhtml#ch16ex05)展示了一个使用此技巧生成stdin单词计数的简单程序。
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 16-5: A program that counts words from stdin*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-5：一个从stdin读取并计数单词的程序*'
- en: You declare a `string` called `word` to receive words from stdin ➊, and you
    initialize a `count` variable to zero ➋. Within the `while` loop’s Boolean expression,
    you attempt to assign new input into `word` ➌. When this succeeds, you increment
    `count` ➍. Once it fails—for example, due to encountering an EOF—you cease incrementing
    and print the final tally ➎.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个名为`word`的`string`类型变量来接收来自stdin的单词➊，并将`count`变量初始化为零➋。在`while`循环的布尔表达式中，你尝试将新的输入赋值给`word`➌。当成功时，你会增加`count`的值➍。一旦失败——例如，遇到EOF——你就停止增加并打印最终的计数结果➎。
- en: You can try two methods to test [Listing 16-5](ch16.xhtml#ch16ex05). First,
    you can simply invoke the program, enter some input, and provide an EOF. How to
    send EOF depends on your operating system. In the Windows command line, you can
    enter EOF by pressing CTRL-Z and pressing enter. In Linux bash or in the OS X
    shell, you press CTRL-D. [Listing 16-6](ch16.xhtml#ch16ex06) demonstrates how
    to invoke [Listing 16-5](ch16.xhtml#ch16ex05) from the Windows command line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试两种方法来测试[清单16-5](ch16.xhtml#ch16ex05)。首先，你可以直接调用程序，输入一些文本，然后提供EOF。如何发送EOF取决于你的操作系统。在Windows命令行中，你可以通过按CTRL-Z并回车来输入EOF。在Linux
    bash或OS X shell中，你按CTRL-D。[清单16-6](ch16.xhtml#ch16ex06)演示了如何从Windows命令行调用[清单16-5](ch16.xhtml#ch16ex05)。
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 16-6: Invoking the program in [Listing 16-5](ch16.xhtml#ch16ex05)
    by typing input into the console*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-6：通过在控制台输入来调用[清单16-5](ch16.xhtml#ch16ex05)中的程序*'
- en: First, you invoke your program ➊. Next, enter some arbitrary text followed by
    a new line ➋. Then issue EOF. The Windows command line shows the somewhat cryptic
    sequence **^Z** on the command line, after which you must press ENTER. This causes
    `std::cin` to enter the `eofbit` state, ending the `while` loop in [Listing 16-5](ch16.xhtml#ch16ex05)
    ➌. The program indicates that you’ve sent 70 words into stdin ➍.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你调用你的程序➊。接着，输入一些任意文本，后跟换行符➋。然后发出EOF。在Windows命令行中，命令行上会显示一些有些晦涩的序列**^Z**，此时你必须按回车键。这会导致`std::cin`进入`eofbit`状态，从而结束[清单16-5](ch16.xhtml#ch16ex05)中的`while`循环➌。程序显示你已将70个单词发送到stdin
    ➍。
- en: 'On Linux and Mac and in Windows PowerShell, you have another option. Rather
    than entering the input directly into the console, you can save the text to a
    file, say *yoda.txt*. The trick is to use `cat` to read the text file and then
    use the pipe operator `|` to send the contents to your program. The pipe operator
    “pipes” the stdout of the program to its left into the stdin of the program on
    the right. The following command illustrates this process:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和Mac以及Windows PowerShell中，你有另一个选择。你可以将文本保存到一个文件中，比如*yoda.txt*，而不是直接在控制台中输入。诀窍是使用`cat`命令读取文本文件，然后使用管道操作符`|`将内容传递给你的程序。管道操作符将程序左侧的stdout传递到右侧程序的stdin。以下命令演示了这一过程：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `cat` command reads the contents of *yoda.txt* ➊. The pipe operator ➋ pipes
    the stdout of `cat` into stdin of `listing_15_4` ➌. Because `cat` sends EOF when
    it encounters the end of *yoda.txt*, you don’t need to enter it manually.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令读取*yoda.txt*的内容➊。管道操作符➋将`cat`的stdout传递到`listing_15_4`的stdin➌。由于`cat`在遇到*yoda.txt*的结尾时会发送EOF，因此你无需手动输入EOF。'
- en: Sometimes you’ll want streams to throw an exception when certain fail bits occur.
    You can do this easily with a stream’s `exceptions` method, which accepts a single
    argument corresponding to the bit you want to throw exceptions. If you desire
    multiple bits, you can simply join them together using Boolean OR (`|`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你希望在出现某些故障位时，流会抛出异常。你可以通过流的`exceptions`方法轻松做到这一点，该方法接受一个参数，表示你希望抛出异常的位。如果你希望多个位抛出异常，只需使用布尔OR
    (`|`)将它们连接起来。
- en: '[Listing 16-7](ch16.xhtml#ch16ex07) illustrates how to refactor [Listing 16-5](ch16.xhtml#ch16ex05)
    so it handles the `badbit` with exceptions and `eofbit`/`failbit` with the default
    handling.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例16-7](ch16.xhtml#ch16ex07) 展示了如何重构 [示例16-5](ch16.xhtml#ch16ex05)，以便用异常处理
    `badbit`，并默认处理 `eofbit`/`failbit`。'
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 16-7: Refactoring [Listing 16-5](ch16.xhtml#ch16ex05) to handle `badbit`
    with exceptions*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例16-7：重构 [示例16-5](ch16.xhtml#ch16ex05) 来处理 `badbit` 异常*'
- en: You start the program by invoking the exceptions method on `std::cin` ➊. Because
    `cin` is an `istream`, you pass `istream::badbit` as the argument of `exception`,
    indicating that you want `cin` to throw an exception any time it gets into a catastrophic
    state. To account for possible exceptions, you wrap the existing code in a `try`-`catch`
    block ➋, so if `cin` sets `badbit` while it’s reading input ➌, the user never
    receives a message about the word count ➍. Instead, the program catches the resulting
    exception ➎ and prints the error message ➏.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通过调用 `std::cin` 上的异常方法开始 ➊。由于 `cin` 是一个 `istream`，你将 `istream::badbit` 作为
    `exception` 参数传递，表示希望每当 `cin` 进入灾难性状态时抛出异常。为了处理可能出现的异常，你将现有代码包裹在一个 `try`-`catch`
    块中 ➋，这样，如果 `cin` 在读取输入时设置了 `badbit` ➌，用户就不会收到关于词数的消息 ➍。相反，程序会捕获由此产生的异常 ➎ 并打印错误信息
    ➏。
- en: '***Buffering and Flushing***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缓冲与刷新***'
- en: Many `ostream` class templates involve operating system calls under the hood,
    for example, to write to a console, a file, or a network socket. Relative to other
    function calls, system calls are usually slow. Rather than invoking a system call
    for each output element, an application can wait for multiple elements and then
    send them all together to improve performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 `ostream` 类模板在底层涉及操作系统调用，例如，写入控制台、文件或网络套接字。与其他函数调用相比，系统调用通常比较慢。为了避免每输出一个元素都调用一次系统调用，应用程序可以等待多个元素一起输出，从而提高性能。
- en: The queuing behavior is called *buffering*. When the stream empties the buffered
    output, it’s called *flushing*. Usually, this behavior is completely transparent
    to the user, but sometimes you want to manually flush the `ostream`. For this
    (and other tasks), you turn to manipulators.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 排队行为被称为 *缓冲*。当流清空缓冲区并输出内容时，这被称为 *刷新*。通常，这种行为对用户是完全透明的，但有时你可能希望手动刷新 `ostream`。为此（以及其他任务），你可以使用操控符。
- en: '***Manipulators***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操控符***'
- en: '*Manipulators* are special objects that modify how streams interpret input
    or format output. Manipulators exist to perform many kinds of stream alterations.
    For example, `std::ws` modifies an `istream` to skip over whitespace. Here are
    some other manipulators that work on `ostreams`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*操控符* 是一些特殊的对象，用于修改流的输入解释方式或格式化输出。操控符的存在是为了执行许多类型的流操作。例如，`std::ws` 修改一个 `istream`，跳过空白字符。以下是一些其他适用于
    `ostream` 的操控符：'
- en: '`std::flush` empties any buffered output directly to an `ostream`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::flush` 会将任何缓冲区中的输出直接刷新到 `ostream`。'
- en: '`std::ends` sends a null byte.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ends` 发送一个空字节。'
- en: '`std::endl` is like `std::flush` except it sends a newline before flushing.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::endl` 类似于 `std::flush`，不过它会先发送一个换行符再进行刷新。'
- en: '[Table 16-6](ch16.xhtml#ch16tab06) summarizes the manipulators in the `<istream>`
    and `<ostream>` headers.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[表16-6](ch16.xhtml#ch16tab06) 总结了 `<istream>` 和 `<ostream>` 头文件中的操控符。'
- en: '**Table 16-6:** Four Manipulators in the `<istream>` and `<ostream>` Headers'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-6：** `<istream>` 和 `<ostream>` 头文件中的四个操控符'
- en: '| **Manipulator** | **Class** | **Behavior** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **操控符** | **类** | **行为** |'
- en: '| `ws` | `istream` | Skips over all whitespaces |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `ws` | `istream` | 跳过所有空白字符 |'
- en: '| `flush` | `ostream` | Writes any buffered data to the stream by invoking
    its `flush` method |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `flush` | `ostream` | 通过调用其 `flush` 方法将任何缓冲数据写入流 |'
- en: '| `ends` | `ostream` | Sends a null byte |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `ends` | `ostream` | 发送一个空字节 |'
- en: '| `endl` | `ostream` | Sends a newline and flushes |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `endl` | `ostream` | 发送换行并刷新输出 |'
- en: 'For example, you could replace ➍ in [Listing 16-7](ch16.xhtml#ch16ex07) with
    the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将 [示例16-7](ch16.xhtml#ch16ex07) 中的 ➍ 替换为以下内容：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will print a newline and also flush output.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印一个换行符，并同时刷新输出。
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a general rule, use `std::endl` when your program has finished outputting
    text to the stream for a while and `\n` when you know your program will output
    more text soon.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为一般规则，当程序在一段时间内已经完成向流输出文本时，使用 `std::endl`，当你知道程序很快会继续输出文本时，使用 `\n`。*'
- en: The stdlib provides many other manipulators in the `<ios>` header. You can,
    for example, determine whether an `ostream` will represent Boolean values textually
    (`boolalpha`) or numerically (`noboolalpha`); integral values as octal (`oct`),
    decimal (`dec`), or hexadecimal (`hex`); and floating-point numbers as decimal
    notation (`fixed`) or scientific notation (`scientific`). Simply pass one of these
    manipulators to an `ostream` using `operator<<` and *all* subsequent insertions
    of the corresponding type will be manipulated (not just an immediately preceding
    operand).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '标准库提供了许多其他操作符，位于 `<ios>` 头文件中。例如，你可以确定 `ostream` 是以文本方式（`boolalpha`）还是数字方式（`noboolalpha`）表示布尔值；以八进制（`oct`）、十进制（`dec`）或十六进制（`hex`）表示整数值；以十进制表示浮点数（`fixed`）或科学记数法表示（`scientific`）。只需将其中一个操作符传递给
    `ostream`，使用 `operator<<`，那么所有后续插入的相应类型的数据都会被操控（不仅仅是紧接着的一个操作数）。 '
- en: You can also set a stream’s width parameter using the `setw` manipulator. A
    stream’s width parameter has varied effects, depending on the stream. For example,
    with `std::cout, setw` will fix the number of output characters allocated to the
    next output object. Additionally, for floating-point output, `setprecision` will
    set the following numbers’ precision.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '你还可以使用 `setw` 操作符设置流的宽度参数。流的宽度参数会根据流的不同产生不同的效果。例如，在 `std::cout` 中，`setw` 将固定分配给下一个输出对象的字符数。此外，对于浮点输出，`setprecision`
    将设置随后的数字精度。 '
- en: '[Listing 16-8](ch16.xhtml#ch16ex08) illustrates how these manipulators perform
    functions similar to those of the various `printf` format specifiers.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-8](ch16.xhtml#ch16ex08) 演示了这些操作符如何执行与各种 `printf` 格式说明符类似的功能。 '
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 16-8: A program illustrating some of the manipulators available in
    the `<iomanip>` header*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 16-8：演示 `<iomanip>` 头文件中一些操作符的程序*'
- en: The `boolalpha` manipulator in the first line causes Boolean values to print
    textually as `true` and `false` ➊, whereas `noboolalpha` causes them to print
    as 1 and 0 instead ➋. For integral values, you can print as octal with `oct` ➌
    or hexadecimal with `hex` ➍. For floating-point values, you can specify scientific
    notation with `scientific` ➎, and you can set the number of digits to print with
    `setprecision` and specify decimal notation with `fixed` ➏. Because manipulators
    apply to all subsequent objects you insert into a stream, when you print another
    integral value at the end of the program, the last integral manipulator (`hex`)
    applies, so you get a hexadecimal representation ➐. Finally, you employ `setw`
    to set the field width for output to 4, and you print some integral values ➑.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的 `boolalpha` 操作符使布尔值以文本形式打印为 `true` 和 `false` ➊，而 `noboolalpha` 则使其以 1 和
    0 形式打印 ➋。对于整数值，你可以使用 `oct` ➌ 打印为八进制，或使用 `hex` ➍ 打印为十六进制。对于浮点值，你可以使用 `scientific`
    ➎ 指定科学记数法，并且可以通过 `setprecision` 设置打印的数字精度，使用 `fixed` 指定十进制表示法 ➏。因为操作符应用于所有后续插入流中的对象，所以当你在程序结尾打印另一个整数值时，最后使用的整数操作符（`hex`）会被应用，因此你将得到一个十六进制表示
    ➐。最后，你使用 `setw` 设置输出字段宽度为 4，然后打印一些整数值 ➑。
- en: '[Table 16-7](ch16.xhtml#ch16tab07) summarizes this sampling of common manipulators.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-7](ch16.xhtml#ch16tab07) 总结了常见操作符的示例。 '
- en: '**Table 16-7:** Many of the Manipulators Available in the `<iomanip>` Header'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-7：** `<iomanip>` 头文件中可用的许多操作符 '
- en: '| **Manipulator** | **Behavior** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **行为** |'
- en: '| `boolalpha` | Represents Booleans textually rather than numerically. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `boolalpha` | 以文本形式表示布尔值，而非数字形式。 |'
- en: '| `noboolalpha` | Represents Booleans numerically rather than textually. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `noboolalpha` | 以数字形式表示布尔值，而非文本形式。 |'
- en: '| `oct` | Represents integral values as octal. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `oct` | 以八进制表示整数值。 |'
- en: '| `dec` | Represents integral values as decimal. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `dec` | 以十进制表示整数值。 |'
- en: '| `hex` | Represents integral values as hexadecimal. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `hex` | 以十六进制表示整数值。 |'
- en: '| `setw(`n`)` | Sets the width parameter of a stream to n. The exact effect
    depends on the stream. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `setw(n)` | 将流的宽度参数设置为 n。具体效果取决于流。 |'
- en: '| `setprecision(`p`)` | Specifies floating-point precision as p. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `setprecision(p)` | 设置浮点数精度为 p。 |'
- en: '| `fixed` | Represents floating-point numbers in decimal notation. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `fixed` | 以十进制表示浮点数。 |'
- en: '| `scientific` | Represents floating-point numbers in scientific notation.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `scientific` | 以科学记数法表示浮点数。 |'
- en: '**NOTE**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** '
- en: '*Refer to [Chapter 15](ch15.xhtml#ch15) in *The C++ Standard Library*, 2nd
    Edition, by Nicolai M. Josuttis or [iostream.format].*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅 Nicolai M. Josuttis 所著《C++ 标准库》第 2 版的 [第 15 章](ch15.xhtml#ch15)，或参考 [iostream.format]。*'
- en: '***User-Defined Types***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户定义类型***'
- en: 'You can make user-defined types work with streams by implementing certain non-member
    functions. To implement the output operator for type `YourType`, the following
    function declaration serves most purposes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现某些非成员函数，使用户自定义类型与流兼容。要为`YourType`实现输出操作符，以下函数声明可以满足大多数用途：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For most cases, you’ll simply return ➊ the same `ostream` you receive ➋. It’s
    up to you how to send output into the `ostream`. But typically, this involves
    accessing fields on `YourType` ➌, optionally performing some formatting and transformations,
    and then using the output operator. For example, [Listing 16-9](ch16.xhtml#ch16ex09)
    shows how to implement an output operator for `std::vector` to print its size,
    capacity, and elements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你只需返回➊接收到的相同`ostream` ➋。如何将输出发送到`ostream`是由你决定的。但通常，这涉及访问`YourType`上的字段
    ➌，可选地执行一些格式化和转换，然后使用输出操作符。例如，[清单 16-9](ch16.xhtml#ch16ex09)展示了如何为`std::vector`实现输出操作符，以打印其大小、容量和元素。
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 16-9: A program illustrating how to implement an output operator for
    a `vector`*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-9：演示如何为`vector`实现输出操作符的程序*'
- en: First, you define a custom output operator as a template, using the template
    parameter as the template parameter of `std::vector` ➊. This allows you to use
    the output operator for many kinds of `vector`s (as long as the type `T` also
    supports the output operator). The first three lines of output give the size and
    capacity of `vector`, as well as the title `Elements` indicating that the elements
    of the `vector` follow ➋. The following `for` loop iterates over each element
    in the `vector`, sending each on a separate line to the `ostream` ➌. Finally,
    you return the stream reference `s` ➍.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义一个自定义输出操作符作为模板，使用模板参数作为`std::vector`的模板参数➊。这样，你就可以将输出操作符应用于多种类型的`vector`（只要类型`T`也支持输出操作符）。输出的前三行显示`vector`的大小和容量，以及标题`Elements`，指示接下来是`vector`的元素➋。接下来的`for`循环遍历`vector`中的每个元素，将每个元素分别发送到`ostream`中➌。最后，返回流引用`s`
    ➍。
- en: Within `main`, you initialize a `vector` called `characters` containing four
    strings ➎. Thanks to your user-defined output operator, you can simply send `characters`
    to `cout` as if it were a fundamental type ➏. The second example uses a `vector<bool>`
    called `bits`, which you also initialize with four elements ➐ and print to stdout
    ➑. Notice that you use the `boolalpha` manipulator, so when your user-defined
    output operator runs, the `bool` elements print textually ➌.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，你初始化了一个名为`characters`的`vector`，其中包含四个字符串 ➎。借助你定义的输出操作符，你可以像处理基本类型一样，直接将`characters`发送到`cout`
    ➏。第二个示例使用了一个名为`bits`的`vector<bool>`，你也用四个元素初始化它 ➐，并打印到标准输出 ➑。注意，你使用了`boolalpha`操作符，这样当你定义的输出操作符运行时，`bool`元素会以文本形式打印
    ➌。
- en: 'You can also provide user-defined input operators, which work similarly. A
    simple corollary is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供用户自定义的输入操作符，其工作方式类似。一个简单的推论如下：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with the output operator, the input operator typically returns ➊ the same
    stream it receives ➋. However, unlike with the output operator, the `YourType`
    reference will generally not be `const`, because you’ll want to modify the corresponding
    object using input from the stream ➌.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与输出操作符类似，输入操作符通常返回➊接收到的相同流 ➋。然而，与输出操作符不同，`YourType`的引用通常不会是`const`，因为你希望使用流中的输入来修改相应的对象
    ➌。
- en: '[Listing 16-10](ch16.xhtml#ch16ex10) illustrates how to specify an input operator
    for `deque` so it pushes elements into the container until an insertion fails
    (for example, due to an EOF character).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-10](ch16.xhtml#ch16ex10)演示了如何为`deque`指定输入操作符，使其将元素推送到容器中，直到插入失败（例如，遇到EOF字符）。'
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 16-10: A program illustrating how to implement an input operator for
    a `deque`*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-10：演示如何为`deque`实现输入操作符的程序*'
- en: Your user-defined input operator is a function template so you can accept any
    `deque` containing a type that supports the input operator ➊. First, you construct
    an element of type `T` so you can store input from the `istream` ➋. Next, you
    use the familiar `while` construct to accept input from the `istream` until the
    input operation fails ➌. (Recall from the “Stream State” section that streams
    can get into failed states in many ways, including reaching an EOF or encountering
    an I/O error.) After each insertion, you `move` the result into `emplace_back`
    on the `deque` to avoid unnecessary copies ➍. Once you’re done inserting, you
    simply return the `istream` reference ➎.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你的用户定义的输入运算符是一个函数模板，因此你可以接受任何支持输入运算符的 `deque` 类型 ➊。首先，你构造一个 `T` 类型的元素，以便从 `istream`
    中存储输入 ➋。接下来，你使用熟悉的 `while` 结构从 `istream` 接受输入，直到输入操作失败 ➌。（回想一下“流状态”一节，流可能因多种原因进入失败状态，包括到达文件末尾或遇到
    I/O 错误。）每次插入后，你将结果 `move` 到 `deque` 的 `emplace_back` 中，以避免不必要的拷贝 ➍。插入完成后，你只需返回
    `istream` 引用 ➎。
- en: Within `main`, you prompt the user for numbers ➏ and then use the insertion
    operator on a newly initialized `deque` to insert elements from stdin. In this
    sample program run, you input the numbers 1 to 5 ➐. For a bit of fun, you compute
    a cumulative sum by keeping a tally and iterating over each element, printing
    that iteration’s result ➑.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，你提示用户输入数字 ➏，然后使用插入运算符对新初始化的 `deque` 执行插入操作，将元素从标准输入流插入。在本示例程序的运行中，你输入了数字
    1 到 5 ➐。为了增加趣味性，你通过保持一个累积和并对每个元素进行迭代，打印每次迭代的结果 ➑。
- en: '**NOTE**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The preceding examples are simple user-defined implementations of input and
    output operators. You might want to elaborate these implementations in production
    code. For example, the implementations only work with `ostream` classes, which
    implies that they won’t work with any non-`char` sequences.*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*前面的示例是简单的用户定义输入和输出运算符的实现。你可能希望在生产代码中扩展这些实现。例如，这些实现仅适用于 `ostream` 类，这意味着它们无法与任何非
    `char` 序列一起使用。*'
- en: '***String Streams***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串流***'
- en: The *string stream classes* provide facilities for reading from and writing
    to character sequences. These classes are useful in several situations. Input
    strings are especially useful if you want to parse string data into types. Because
    you can use the input operator, all the standard manipulator facilities are available
    to you. Output strings are excellent for building up strings from variable-length
    input.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串流类* 提供了从字符序列中读取和写入的功能。这些类在多个场合都非常有用。输入字符串尤其有用，如果你想将字符串数据解析为不同类型。因为你可以使用输入运算符，所以所有标准的操作符功能都可以使用。输出字符串非常适合从可变长度的输入中构建字符串。'
- en: '**Output String Streams**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输出字符串流**'
- en: '*Output string streams* provide output-stream semantics for character sequences,
    and they all derive from the class template `std::basic_ostringstream` in the
    `<sstream>` header, which provides the following specializations:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出字符串流* 为字符序列提供输出流语义，它们都从 `<sstream>` 头文件中的类模板 `std::basic_ostringstream`
    派生，并提供以下特化：'
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output string streams support all the same features as an `ostream`. Whenever
    you send input to the string stream, the stream stores this input into an internal
    buffer. You can think of this as functionally equivalent to the `append` operation
    of `string` (except that string streams are potentially more efficient).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出字符串流支持与 `ostream` 相同的所有功能。每当你向字符串流发送输入时，流会将这些输入存储到内部缓冲区中。你可以将其视为与 `string`
    的 `append` 操作在功能上等效（除了字符串流可能更高效）。
- en: Output string streams also support the `str()` method, which has two modes of
    operation. Given no argument, `str` returns a copy of the internal buffer as a
    `basic_string` (so `ostringstream` returns a `string`; `wostringstream` returns
    a `wstring`). Given a single `basic_string` argument, the string stream will replace
    its buffer’s current contents with the contents of the argument. [Listing 16-11](ch16.xhtml#ch16ex11)
    illustrates how to use an `ostringstream`, send character data to it, build a
    `string`, reset its contents, and repeat.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出字符串流还支持 `str()` 方法，它有两种操作模式。如果没有传递参数，`str` 返回内部缓冲区的副本作为 `basic_string`（因此
    `ostringstream` 返回 `string`；`wostringstream` 返回 `wstring`）。如果传递了一个 `basic_string`
    参数，字符串流将用该参数的内容替换其缓冲区的当前内容。[清单 16-11](ch16.xhtml#ch16ex11) 演示了如何使用 `ostringstream`，将字符数据发送到其中，构建一个
    `string`，重置其内容并重复此过程。
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 16-11: Using an `ostringstream` to build strings*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-11：使用 `ostringstream` 构建字符串*'
- en: After declaring an `ostringstream` ➊, you treat it just like any other `ostream`
    and use the output operator to send it three separate character sequences ➋. Next,
    you invoke `str` without an argument, which produces a `string` called `lazarus`
    ➌. Then you invoke `str` with the string literal `I am Groot` ➍, which replaces
    the contents of `ostringstream` ➎.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明一个`ostringstream` ➊之后，你像使用其他任何`ostream`一样使用它，利用输出操作符发送三个独立的字符序列 ➋。接下来，你调用不带参数的`str`，它生成一个名为`lazarus`的`string`
    ➌。然后你使用带有字符串字面量`I am Groot` ➍调用`str`，这会替换`ostringstream`的内容 ➎。
- en: '**NOTE**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Recall from “C-Style Strings” on [page 45](ch02.xhtml#page_45) that you can
    place multiple string literals on consecutive lines and the compiler will treat
    them as one. This is done purely for source code–formatting purposes.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*回忆一下，在“C风格字符串”部分，[第45页](ch02.xhtml#page_45)提到过，你可以将多个字符串字面量放在连续的行中，编译器会将它们视为一个字符串。这完全是为了源代码格式化的目的。*'
- en: '**Input String Streams**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输入字符串流**'
- en: '*Input string streams* provide input stream semantics for character sequences,
    and they all derive from the class template `std::basic_istringstream` in the
    `<sstream>` header, which provides the following specializations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入字符串流*为字符序列提供输入流语义，它们都继承自`<sstream>`头文件中的类模板`std::basic_istringstream`，该类提供了以下特化：'
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These are analogous to the `basic_ostringstream` specializations. You can construct
    input string streams by passing a `basic_string` with appropriate specialization
    (`string` for an `istringstream` and `wstring` for a `wistringstream`). [Listing
    16-12](ch16.xhtml#ch16ex12) illustrates by constructing an input string stream
    with a string containing three numbers and using the input operator to extract
    them. (Recall from “Formatted Operations” on [page 525](ch16.xhtml#page_525) that
    whitespace is the appropriate delimiter for string data.)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特化类似于`basic_ostringstream`。你可以通过传递一个适当特化的`basic_string`（对于`istringstream`是`string`，对于`wistringstream`是`wstring`）来构造输入字符串流。[列表16-12](ch16.xhtml#ch16ex12)演示了通过构造一个包含三个数字的字符串输入流，并使用输入操作符提取它们。（回忆一下在“格式化操作”中提到的内容，关于[第525页](ch16.xhtml#page_525)，空白符是字符串数据的适当分隔符。）
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 16-12: Using a `string` to build `istringstream` objects and extract
    numeric types*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-12：使用`string`构建`istringstream`对象并提取数值类型*'
- en: You construct a `string` from the literal `1 2.23606 2` ➊, which you pass into
    the constructor of an `istringstream` called `ss` ➋. This allows you to use the
    input operator to parse out `int` objects ➌ and `float` objects ➍ just like any
    other input stream. Once you’ve exhausted the stream and the output operator fails,
    `ss` converts to `false` ➎.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你从字面量`1 2.23606 2` ➊构建一个`string`，并将其传入名为`ss` ➋的`istringstream`构造函数。这使得你可以像处理任何其他输入流一样，使用输入操作符解析出`int`对象
    ➌和`float`对象 ➍。当你耗尽流并且输出操作符失败时，`ss`会转换为`false` ➎。
- en: '**String Streams Supporting Input and Output**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持输入和输出的字符串流**'
- en: 'Additionally, if you want a string stream that supports input and output operations,
    you can use the `basic_stringstream`, which has the following specializations:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你需要一个支持输入和输出操作的字符串流，可以使用`basic_stringstream`，它具有以下特化：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This class supports the input and output operators, the `str` method, and construction
    from a string. [Listing 16-13](ch16.xhtml#ch16ex13) illustrates how to use a combination
    of input and output operators to extract tokens from a string.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该类支持输入和输出操作符、`str`方法以及从字符串构造的功能。[列表16-13](ch16.xhtml#ch16ex13)演示了如何使用输入和输出操作符的组合从字符串中提取标记。
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 16-13: Using a `stringstream` for input and output*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表16-13：使用`stringstream`进行输入和输出*'
- en: You create a `stringstream` and sent the `Zed's DEAD` with the output operator
    ➊. Next, you parse `Zed's` out of the `stringstream` using the input operator
    ➋. Because `DEAD` is a valid hexadecimal integer, you use the input operator and
    the `std::hex` manipulator to extract it into an `int` ➌.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个`stringstream`，并使用输出操作符发送`Zed's DEAD` ➊。接下来，你使用输入操作符从`stringstream`中解析出`Zed's`
    ➋。因为`DEAD`是一个有效的十六进制整数，所以你使用输入操作符和`std::hex`操纵符将其提取为`int` ➌。
- en: '**NOTE**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All string streams are moveable.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有字符串流都是可移动的。*'
- en: '**Summary of String Stream Operations**'
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串流操作总结**'
- en: '[Table 16-8](ch16.xhtml#ch16tab08) provides a partial list of `basic_stringstream`
    operations. In this table, `ss, ss1`, and `ss2` are of type `std::basic_stringstream<T>`;
    `s` is a `std::basic_string<``T``>`; `obj` is a formatted object; `pos` is a position
    type; `dir` is a `std::ios_base::seekdir`; and `flg` is a `std::ios_base::iostate`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-8](ch16.xhtml#ch16tab08) 提供了 `basic_stringstream` 操作的部分列表。在此表中，`ss, ss1`
    和 `ss2` 类型为 `std::basic_stringstream<T>`；`s` 为 `std::basic_string<``T``>`；`obj`
    为格式化对象；`pos` 为位置类型；`dir` 为 `std::ios_base::seekdir`；`flg` 为 `std::ios_base::iostate`。'
- en: '**Table 16-8:** A Partial List of `std::basic_stringstream` Operations'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-8：** `std::basic_stringstream` 操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `basic_stringstream<`T`>``{ [`s`], [`om`] }` | Performs braced initialization
    of a newly constructed string stream. Defaults to empty string s and `in&#124;out`
    open mode om. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `basic_stringstream<`T`>``{ [`s`], [`om`] }` | 执行新构造的字符串流的花括号初始化。默认为空字符串
    s 和 `in&#124;out` 打开模式 om。 |'
- en: '| `basic_stringstream<`T`>``{ move(`ss`) }` | Takes ownership of ss’s internal
    buffer. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `basic_stringstream<`T`>``{ move(`ss`) }` | 获取 ss 的内部缓冲区所有权。 |'
- en: '| `~basic_stringstream` | Destructs internal buffer. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `~basic_stringstream` | 析构内部缓冲区。 |'
- en: '| ss.`rdbuf()` | Returns raw string device object. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| ss.`rdbuf()` | 返回原始字符串设备对象。 |'
- en: '| ss.`str()` | Gets the contents of the string device object. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| ss.`str()` | 获取字符串设备对象的内容。 |'
- en: '| ss.`str(`s`)` | Sets the contents of the string device object to s. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| ss.`str(`s`)` | 将字符串设备对象的内容设置为 s。 |'
- en: '| ss `>>` obj | Extracts formatted data from the string stream. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| ss `>>` obj | 从字符串流中提取格式化数据。 |'
- en: '| ss `<<` obj | Inserts formatted data into the string stream. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| ss `<<` obj | 将格式化数据插入到字符串流中。 |'
- en: '| ss.`tellg()` | Returns the input position index. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| ss.`tellg()` | 返回输入位置索引。 |'
- en: '| ss.`seekg(`pos`)`ss.`seekg(`pos, dir`)` | Sets the input position indicator.
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| ss.`seekg(`pos`)`ss.`seekg(`pos, dir`)` | 设置输入位置指示符。 |'
- en: '| ss.`flush()` | Synchronizes the underlying device. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| ss.`flush()` | 同步底层设备。 |'
- en: '| ss.`good()`ss.`eof()`ss.`bad()`!ss | Inspects the string stream’s bits. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| ss.`good()`ss.`eof()`ss.`bad()`!ss | 检查字符串流的位状态。 |'
- en: '| ss.`exceptions(`flg`)` | Configures the string stream to throw an exception
    whenever a bit in flg gets set. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| ss.`exceptions(`flg`)` | 配置字符串流，在 flg 中的某一位被设置时抛出异常。 |'
- en: '| ss1.`swap(`ss2`)``swap(`ss1, ss2`)` | Exchanges each element of ss1 with
    those of ss2. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| ss1.`swap(`ss2`)``swap(`ss1, ss2`)` | 交换 ss1 和 ss2 的每个元素。 |'
- en: '***File Streams***'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件流***'
- en: The *file stream classes* provide facilities for reading from and writing to
    character sequences. The file stream class structure follows that of the string
    stream classes. File stream class templates are available for input, output, and
    both.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件流类* 提供了读取和写入字符序列的功能。文件流类的结构遵循字符串流类的结构。文件流类模板可用于输入、输出或二者兼有。'
- en: 'File stream classes provide the following major benefits over using native
    system calls to interact with file contents:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 文件流类提供了相较于使用原生系统调用操作文件内容的以下主要优势：
- en: You get the usual stream interfaces, which provide a rich set of features for
    formatting and manipulating output.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将获得常规流接口，这些接口提供了丰富的功能，用于格式化和操作输出。
- en: The file stream classes are RAII wrappers around the files, meaning it’s impossible
    to leak resources, such as files.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件流类是文件的 RAII 包装器，这意味着不可能泄露资源，例如文件。
- en: File stream classes support move semantics, so you can have tight control over
    where files are in scope.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件流类支持移动语义，因此您可以精确控制文件的作用范围。
- en: '**Opening Files with Streams**'
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用流打开文件**'
- en: You have two options for opening a file with any file stream. The first option
    is the `open` method, which accepts a `const char* filename` and an optional `std::ios_base::openmode`
    bitmask argument. The `openmode` argument can be one of the many possible combinations
    of values listed in [Table 16-9](ch16.xhtml#ch16tab09).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择两种方式使用文件流打开文件。第一种方法是 `open` 方法，它接受 `const char* filename` 和一个可选的 `std::ios_base::openmode`
    位掩码参数。`openmode` 参数可以是 [表 16-9](ch16.xhtml#ch16tab09) 中列出的多种值组合之一。
- en: '**Table 16-9:** Possible Stream States, Their Accessor Methods, and Their Meanings'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-9：** 可能的流状态、其访问方法及含义'
- en: '| **Flag** (**in** `std::ios`) | **File** | **Meaning** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **标志** (**in** `std::ios`) | **文件** | **含义** |'
- en: '| `in` | Must exist | Read |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 必须存在 | 读取 |'
- en: '| `out` | Created if doesn’t exist | Erase the file; then write |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `out` | 如果不存在则创建 | 删除文件，然后写入 |'
- en: '| `app` | Created if doesn’t exist | Append |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `app` | 如果不存在则创建 | 追加 |'
- en: '| `in&#124;out` | Must exist | Read and write from beginning |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `in&#124;out` | 必须存在 | 从开头读写 |'
- en: '| `in&#124;app` | Created if doesn’t exist | Update at end |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `in|app` | 如果文件不存在则创建 | 在文件末尾更新 |'
- en: '| `out&#124;app` | Created if doesn’t exist | Append |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `out|app` | 如果文件不存在则创建 | 追加模式 |'
- en: '| `out&#124;trunc` | Created if doesn’t exist | Erase the file; then read and
    write |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `out|trunc` | 如果文件不存在则创建 | 清空文件后进行读写 |'
- en: '| `in&#124;out&#124;app` | Created if doesn’t exist | Update at end |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `in|out|app` | 如果文件不存在则创建 | 在文件末尾更新 |'
- en: '| `in&#124;out&#124;trunc` | Created if doesn’t exist | Erase the file; then
    read and write |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `in|out|trunc` | 如果文件不存在则创建 | 清空文件后进行读写 |'
- en: Additionally, you can add the `binary` flag to any of these combinations to
    put the file in *binary mode*. In binary mode, the stream won’t convert special
    character sequences, like end of line (for example, a carriage return plus a line
    feed on Windows) or EOF.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以将`binary`标志添加到这些组合中的任何一个，以使文件处于*二进制模式*。在二进制模式下，流不会转换特殊字符序列，如行结束符（例如，Windows上的回车符加换行符）或EOF。
- en: The second option for specifying a file to open is to use the stream’s constructor.
    Each file stream provides a constructor taking the same arguments as the `open`
    method. All file stream classes are RAII wrappers around the file handles they
    own, so the files will be automatically cleaned up when the file stream destructs.
    You can also manually invoke the `close` method, which takes no arguments. You
    might want to do this if you know you’re done with the file but your code is written
    in such a way that the file stream class object won’t destruct for a while.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要打开的文件的第二种方法是使用流的构造函数。每个文件流提供一个构造函数，接受与`open`方法相同的参数。所有文件流类都是对它们所拥有的文件句柄的RAII封装，因此当文件流对象析构时，文件会自动清理。你也可以手动调用`close`方法，该方法不接受任何参数。如果你知道文件操作已经完成，但你的代码结构使得文件流类对象不会立即析构，那么你可能想手动调用这个方法。
- en: File streams also have default constructors, which don’t open any files. To
    check whether a file is open, invoke the `is_open` method, which takes no arguments
    and returns a Boolean.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 文件流也有默认构造函数，这些构造函数不会打开任何文件。要检查文件是否已打开，可以调用`is_open`方法，该方法不接受任何参数，返回一个布尔值。
- en: '**Output File Streams**'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输出文件流**'
- en: '*Output file streams* provide output stream semantics for character sequences,
    and they all derive from the class template `std::basic_ofstream` in the `<fstream>`
    header, which provides the following specializations:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出文件流*提供字符序列的输出流语义，它们都从`std::basic_ofstream`类模板派生，该模板定义在`<fstream>`头文件中，并提供以下特化：'
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The default `basic_ofstream` constructor doesn’t open a file, and the non-default
    constructor’s second optional argument defaults to `ios::out`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`basic_ofstream`构造函数不会打开文件，而非默认构造函数的第二个可选参数默认设置为`ios::out`。
- en: Whenever you send input to the file stream, the stream writes the data to the
    corresponding file. [Listing 16-14](ch16.xhtml#ch16ex14) illustrates how to use
    `ofstream` to write a simple message to a text file.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你向文件流发送输入时，流会将数据写入相应的文件。[清单16-14](ch16.xhtml#ch16ex14)展示了如何使用`ofstream`将简单的消息写入文本文件。
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 16-14: A program opening the file lunchtime.txt and appending a message
    to it. (The output corresponds to the contents of lunchtime.txt after a single
    program execution.)*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-14：一个打开文件lunchtime.txt并向其中追加消息的程序。（输出对应程序执行一次后lunchtime.txt的内容。）*'
- en: You initialize an `ofstream` called `file` with the path `lunchtime.txt` and
    the flags `out` and `app` ➊. Because this combination of flags appends output,
    any data you send through the output operator into this file stream gets appended
    to the end of the file. As expected, the file contains the message you passed
    to the output operator ➋➌.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化了一个名为`file`的`ofstream`对象，使用路径`lunchtime.txt`和标志`out`与`app` ➊。因为这个标志组合是追加输出，所以你通过输出运算符发送到此文件流的数据会被追加到文件末尾。如预期，文件包含你通过输出运算符传递的消息
    ➋➌。
- en: 'Thanks to the `ios::app` flag, the program will append output to *lunchtime.txt*
    if it exists. For example, if you run the program again, you’ll get the following
    output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于`ios::app`标志，如果*lunchtime.txt*文件存在，程序会将输出追加到该文件。例如，如果你再次运行程序，输出将是：
- en: '[PRE23]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second iteration of the program added the same phrase to the end of the
    file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二次迭代将相同的短语添加到了文件末尾。
- en: '**Input File Streams**'
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输入文件流**'
- en: '*Input file streams* provide input stream semantics for character sequences,
    and they all derive from the class template `std::basic_ifstream` in the `<fstream>`
    header, which provides the following specializations:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入文件流*提供字符序列的输入流语义，它们都从`std::basic_ifstream`类模板派生，该模板定义在`<fstream>`头文件中，并提供以下特化：'
- en: '[PRE24]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The default `basic_ifstream` constructor doesn’t open a file, and the non-default
    constructor’s second optional argument defaults to `ios::in`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`basic_ifstream`构造函数不会打开文件，而非默认构造函数的第二个可选参数默认为`ios::in`。
- en: 'Whenever you read from the file stream, the stream reads data from the corresponding
    file. Consider the following sample file, *numbers.txt*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你从文件流中读取数据时，流会从相应的文件中读取数据。考虑下面的示例文件，*numbers.txt*：
- en: '[PRE25]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Listing 16-15](ch16.xhtml#ch16ex15) contains a program that uses an `ifstream`
    to read from a text file containing integers and return the maximum. The output
    corresponds with invoking the program and passing the path of the file *numbers.txt*.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-15](ch16.xhtml#ch16ex15)包含了一个程序，使用`ifstream`从包含整数的文本文件中读取数据并返回最大值。输出与调用程序并传递*numbers.txt*文件路径相对应。'
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 16-15: A program that reads the text file* numbers.txt *and prints
    its maximum integer*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-15：一个读取文本文件* numbers.txt *并打印其最大整数的程序*'
- en: You first initialize an `istream` to open the *numbers.txt* text file ➊. Next,
    you initialize the maximum variable with the minimum value an `int` can take ➋.
    Using the idiomatic input stream and `while`-loop combination ➌, you cycle through
    each integer in the file, updating the maximum as you find higher values ➍. Once
    the file stream cannot parse any more integers, you print the result to stdout
    ➎.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化一个`istream`来打开*numbers.txt*文本文件 ➊。接着，使用`int`类型的最小值初始化最大值变量 ➋。通过典型的输入流和`while`循环组合
    ➌，你遍历文件中的每个整数，在找到更大值时更新最大值 ➍。一旦文件流无法再解析任何整数，你就将结果打印到标准输出 ➎。
- en: '**Handling Failure**'
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理失败**'
- en: As with other streams, file streams fail silently. If you use a file stream
    constructor to open a file, you must check the `is_open` method to determine whether
    the stream successfully opened the file. This design differs from most other stdlib
    objects where invariants are enforced by exceptions. It’s hard to say why the
    library implementors chose this approach, but the fact is that you can opt into
    an exception-based approach fairly easily.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他流一样，文件流默默失败。如果你使用文件流构造函数打开文件，你必须检查`is_open`方法来确定流是否成功打开了文件。这个设计与大多数其他标准库对象不同，后者通过异常来强制执行不变量。很难说为什么库实现者选择了这种方法，但事实是，你可以相对容易地选择基于异常的方法。
- en: You can make your own factory functions to handle file-opening failures with
    exceptions. [Listing 16-16](ch16.xhtml#ch16ex16) illustrates how to implement
    an `ifstream` factory called `open`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建自己的工厂函数，用异常处理文件打开失败。[列表 16-16](ch16.xhtml#ch16ex16)展示了如何实现一个名为`open`的`ifstream`工厂。
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 16-16: A factory function for generating `ifstream`s that handle errors
    with exceptions rather than failing silently*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-16：一个工厂函数，用于生成处理异常而非默默失败的 `ifstream`*'
- en: 'Your factory function returns an `ifstream` ➊ and accepts the same arguments
    as a file stream’s constructor (and `open` method): a file `path` ➋ and an `openmode`
    ➌. You pass these two arguments into the constructor of `ifstream` ➍ and then
    determine whether the file opened successfully ➎. If it didn’t, you throw a `runtime_error`
    ➏. If it did, you tell the resulting `ifstream` to throw an exception whenever
    its `badbit` gets set in the future ➐.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工厂函数返回一个`ifstream` ➊，并接受与文件流构造函数（以及`open`方法）相同的参数：文件`path` ➋和`openmode` ➌。你将这两个参数传递给`ifstream`的构造函数
    ➍，然后判断文件是否成功打开 ➎。若未成功，你抛出一个`runtime_error` ➏；若成功，你告诉结果`ifstream`在未来每当其`badbit`被设置时抛出异常
    ➐。
- en: '**Summary of File Stream Operations**'
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**文件流操作概述**'
- en: '[Table 16-10](ch16.xhtml#ch16tab010) provides a partial list of `basic_fstream`
    operations. In this table, `fs, fs1`, and `fs2` are of type `std:: basic_fstream
    <T>`; `p` is a C-style string, `std::string`, or a `std::filesystem::path`; `om`
    is an `std::ios_base::openmode`; `s` is a `std::basic_string<``T``>`; `obj` is
    a formatted object; `pos` is a position type; `dir` is a `std::ios_base::seekdir`;
    and `flg` is a `std::ios_base::iostate`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-10](ch16.xhtml#ch16tab010)提供了`basic_fstream`操作的部分列表。在这个表格中，`fs, fs1`和`fs2`是`std::
    basic_fstream <T>`类型；`p`是一个C风格字符串，`std::string`或`std::filesystem::path`；`om`是`std::ios_base::openmode`；`s`是`std::basic_string<``T``>`；`obj`是一个格式化对象；`pos`是一个位置类型；`dir`是`std::ios_base::seekdir`；`flg`是`std::ios_base::iostate`。'
- en: '**Table 16-10:** A Partial List of `std::basic_fstream` Operations'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-10：** `std::basic_fstream` 操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `basic_fstream<`T`>``{ [`p`], [`om`] }` | Performs braced initialization
    of a newly constructed file stream. If p is provided, attempts to open file at
    path p. Defaults to not opened and `in&#124;out` open mode. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `basic_fstream<`T`>``{ [`p`], [`om`] }` | 对新构建的文件流进行花括号初始化。如果提供了p，则尝试在路径p打开文件。默认情况下不打开，并且使用`in|out`打开模式。
    |'
- en: '| `basic_fstream<`T`>``{ move(`fs`) }` | Takes ownership of the internal buffer
    of fs. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `basic_fstream<`T`>``{ move(`fs`) }` | 获取fs的内部缓冲区的所有权。 |'
- en: '| `~basic_fstream` | Destructs internal buffer. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `~basic_fstream` | 析构内部缓冲区。 |'
- en: '| fs.`rdbuf()` | Returns raw string device object. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| fs.`rdbuf()` | 返回原始字符串设备对象。 |'
- en: '| fs.`str()` | Gets the contents of the file device object. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| fs.`str()` | 获取文件设备对象的内容。 |'
- en: '| fs.`str(`s`)` | Puts the contents of the file device object into s. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| fs.`str(`s`)` | 将文件设备对象的内容放入s中。 |'
- en: '|  fs `>>` obj  | Extracts formatted data from the file stream. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|  fs `>>` obj  | 从文件流中提取格式化数据。 |'
- en: '| fs `<<` obj | Inserts formatted data into the file stream. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| fs `<<` obj | 将格式化数据插入到文件流中。 |'
- en: '| fs.`tellg()` | Returns the input position index. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| fs.`tellg()` | 返回输入位置索引。 |'
- en: '| fs.`seekg(`pos`)`fs.`seekg(`pos, dir`)` | Sets the input position indicator.
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| fs.`seekg(`pos`)`fs.`seekg(`pos, dir`)` | 设置输入位置指示器。 |'
- en: '| fs.`flush()` | Synchronizes the underlying device. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| fs.`flush()` | 同步底层设备。 |'
- en: '| fs.`good()`fs.`eof()`fs.`bad()``!`fs | Inspects the file stream’s bits. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| fs.`good()`fs.`eof()`fs.`bad()``!`fs | 检查文件流的状态位。 |'
- en: '| fs.`exceptions(`flg`)` | Configures the file stream to throw an exception
    whenever a bit in flg gets set. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| fs.`exceptions(`flg`)` | 配置文件流，在flg中的某一位被设置时抛出异常。 |'
- en: '| fs1.`swap(`fs2`)``swap(`fs1, fs2`)` | Exchanges each element of fs1 with
    one of fs2. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| fs1.`swap(`fs2`)``swap(`fs1, fs2`)` | 交换fs1中的每个元素与fs2中的一个元素。 |'
- en: '***Stream Buffers***'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流缓冲区***'
- en: Streams don’t read and write directly. Under the covers, they use stream buffer
    classes. At a high level, *stream buffer classes* are templates that send or extract
    characters. The implementation details aren’t important unless you’re planning
    on implementing your own stream library, but it’s important to know that they
    exist in several contexts. The way you obtain stream buffers is by using a stream’s
    `rdbuf` method, which all streams provide.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 流不会直接读写数据。背后，它们使用流缓冲区类。从高层次来看，*流缓冲区类* 是模板类，负责发送或提取字符。除非你计划实现自己的流库，否则实现细节不重要，但需要知道它们在多个上下文中存在。你通过使用流的`rdbuf`方法来获取流缓冲区，这是所有流都提供的。
- en: '**Writing Files to sdout**'
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向sdout写文件**'
- en: 'Sometimes you just want to write the contents of an input file stream directly
    into an output stream. To do this, you can extract the stream buffer pointer from
    the file stream and pass it to the output operator. For example, you can dump
    the contents of a file to stdout using `cout` in the following way:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你只想将输入文件流的内容直接写入输出流。为此，你可以从文件流中提取流缓冲区指针，并将其传递给输出操作符。例如，你可以使用`cout`以如下方式将文件内容输出到stdout：
- en: '[PRE28]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It’s that easy.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。
- en: '**Output Stream Buffer Iterators**'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输出流缓冲迭代器**'
- en: '*Output stream buffer iterators* are template classes that expose an output
    iterator interface that translates writes into output operations on the underlying
    stream buffer. In other words, these are adapters that allow you to use output
    streams as if they were output iterators.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出流缓冲迭代器* 是模板类，暴露了一个输出迭代器接口，将写入操作转换为底层流缓冲区的输出操作。换句话说，这些是适配器，允许你像使用输出迭代器一样使用输出流。'
- en: To construct an output stream buffer iterator, use the `ostreambuf_iterator`
    template class in the `<iterator>` header. Its constructor takes a single output
    stream argument and a single template parameter corresponding to the constructor
    argument’s template parameter (the character type). [Listing 16-17](ch16.xhtml#ch16ex17)
    shows how to construct an output stream buffer iterator from `cout`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造输出流缓冲迭代器，可以使用`ostreambuf_iterator`模板类（在`<iterator>`头文件中）。它的构造函数接受一个输出流参数和一个对应于构造函数参数模板参数（字符类型）的单一模板参数。[示例16-17](ch16.xhtml#ch16ex17)展示了如何从`cout`构造一个输出流缓冲迭代器。
- en: '[PRE29]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 16-17: Writing the message `Hi` to stdout using the `ostreambuf_iterator`
    class*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例16-17：使用`ostreambuf_iterator`类将消息`Hi`写入stdout*'
- en: 'Here, you construct an output stream buffer iterator from `cout` ➊, which you
    write to in the usual way for an output operator: assign ➋, increment ➌, assign
    ➍, and so on. The result is character-by-character output to stdout. (Recall the
    procedures for handling output operators in “Output Iterators” on [page 464](ch14.xhtml#page_464).)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你从`cout`构造一个输出流缓冲区迭代器 ➊，然后像通常的输出操作符那样进行写操作：赋值 ➋，递增 ➌，赋值 ➍，以此类推。结果是逐字符输出到标准输出(stdout)。（回顾“输出迭代器”中关于输出操作符的处理方法，见[第464页](ch14.xhtml#page_464)。）
- en: '**Input Stream Buffer Iterators**'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输入流缓冲区迭代器**'
- en: '*Input stream buffer iterators* are template classes that expose an input iterator
    interface that translates reads into read operations on the underlying stream
    buffer. These are entirely analogous to output stream buffer iterators.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入流缓冲区迭代器*是模板类，暴露出一个输入迭代器接口，将读取操作转换为对底层流缓冲区的读取操作。这与输出流缓冲区迭代器完全类似。'
- en: 'To construct an input stream buffer iterator, use the `istreambuf_iterator`
    template class in the `<iterator>` header. Unlike `ostreambuf_iterator`, it takes
    a stream buffer argument, so you must call `rdbuf()` on whichever input stream
    you want to adapt. This argument is optional: the default constructor of `istreambuf_iterator`
    corresponds to the end-of-range iterator of input iterator. For example, [Listing
    16-18](ch16.xhtml#ch16ex18) illustrates how to construct a string from `std::cin`
    using the range-based constructor of `string`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个输入流缓冲区迭代器，使用`istreambuf_iterator`模板类，该类位于`<iterator>`头文件中。与`ostreambuf_iterator`不同，它接受一个流缓冲区参数，因此你必须在要适配的输入流上调用`rdbuf()`。这个参数是可选的：`istreambuf_iterator`的默认构造函数对应于输入迭代器的范围结束迭代器。例如，[清单
    16-18](ch16.xhtml#ch16ex18)展示了如何使用`string`的基于范围的构造函数从`std::cin`构造一个字符串。
- en: '[PRE30]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 16-18: Constructing a string from `cin` using input stream buffer
    iterators*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-18：使用输入流缓冲区迭代器从`cin`构造一个字符串*'
- en: You construct an `istreambuf_iterator` from the stream buffer of `cin` ➊ as
    well as the end-of-range iterator ➋. After sending a prompt to the program’s user
    ➌, you construct the `string name` using its range-based constructor ➍. When the
    user sends input (terminated by EOF), the string’s constructor copies it. You
    then bid the user farewell using their `name` ➎. (Recall from “Stream State” on
    [page 530](ch16.xhtml#page_530) that methods for sending EOF to the console differ
    by operating system.)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你从`cin`的流缓冲区构造一个`istreambuf_iterator` ➊，以及范围结束迭代器 ➋。向程序的用户发送提示 ➌ 后，你使用`string
    name`的基于范围的构造函数 ➍ 构造该字符串。当用户输入内容（以EOF结束）时，字符串的构造函数会复制输入内容。然后，你使用他们的`name`向用户告别
    ➎。（回顾“流状态”部分，见[第530页](ch16.xhtml#page_530)，不同操作系统向控制台发送EOF的方法有所不同。）
- en: '***Random Access***'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机访问***'
- en: Sometimes you’ll want random access into a stream (especially a file stream).
    The input and output operators clearly don’t support this use case, so `basic_istream`
    and `basic_ostream` offer separate methods for random access. These methods keep
    track of the cursor or position, the index of the stream’s current character.
    The position indicates the next byte that an input stream will read or an output
    stream will write.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要对流进行随机访问（特别是文件流）。输入和输出操作符显然不支持这种用例，因此`basic_istream`和`basic_ostream`提供了单独的随机访问方法。这些方法跟踪光标或位置，也就是流中当前字符的索引。位置指示输入流将读取的下一个字节或输出流将写入的下一个字节。
- en: 'For input streams, you can use the two methods `tellg` and `seekg`. The `tellg`
    method takes no arguments and returns the position. The `seekg` method allows
    you to set the cursor position, and it has two overloads. Your first option is
    to provide a `pos_type` position argument, which sets the read position. The second
    is to provide an `off_type` offset argument plus an `ios_base::seekdir` direction
    argument. The `pos_type` and `off_type` are determined by the template arguments
    to the `basic_istream` or `basic_ostream`, but usually these convert to/from integer
    types. The `seekdir` type takes one of the following three values:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入流，你可以使用`tellg`和`seekg`两种方法。`tellg`方法不接受参数，返回当前位置。`seekg`方法允许你设置光标位置，并且有两个重载。第一个选项是提供一个`pos_type`位置参数，用于设置读取位置。第二个选项是提供一个`off_type`偏移量参数，以及一个`ios_base::seekdir`方向参数。`pos_type`和`off_type`由`basic_istream`或`basic_ostream`的模板参数决定，但通常它们会转换为整数类型。`seekdir`类型有以下三种值：
- en: '`ios_base::beg` specifies that the position argument is relative to the beginning.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_base::beg`指定位置参数相对于起始位置。'
- en: '`ios_base::cur` specifies that the position argument is relative to the current
    position.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_base::cur`指定位置参数相对于当前位置。'
- en: '`ios_base::end` specifies that the position argument is relative to the end.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_base::end`指定位置参数是相对于文件末尾的。'
- en: 'For output streams, you can use the two methods `tellp` and `seekp`. These
    are roughly analogous to the `tellg` and `seekg` methods of input streams: the
    `p` stands for put and the `g` stands for get.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出流，您可以使用两个方法`tellp`和`seekp`。它们大致与输入流的`tellg`和`seekg`方法类似：`p`代表put，`g`代表get。
- en: 'Consider a file *introspection.txt* with the following contents:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个文件*introspection.txt*，其内容如下：
- en: '[PRE31]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Listing 16-19](ch16.xhtml#ch16ex19) illustrates how to employ random access
    methods to reset the file cursor.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-19](ch16.xhtml#ch16ex19)展示了如何使用随机访问方法来重置文件游标。'
- en: '[PRE32]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 16-19: A program using random access methods to read arbitrary characters
    in a text file*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-19：使用随机访问方法读取文本文件中任意字符的程序*'
- en: Using the factory function in [Listing 16-16](ch16.xhtml#ch16ex16) ➊, you open
    the text file *introspection.txt* ➋. Next, you print the contents to stdout using
    the `rdbuf` method ➌, rewind the cursor to the first character ➍, and print the
    contents again. Notice that these yield identical output (because the file hasn’t
    changed) ➎. You then use the relative offset overload of `seekg` to navigate to
    the fourth character from the end ➏. Using `tellg`, you learn that this is the
    49th character (with zero-base indexing) ➐. When you print the input file to stdout,
    the output is only `end.`, because these are the last four characters in the file
    ➑.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[清单16-16](ch16.xhtml#ch16ex16)中的工厂函数 ➊，您打开文本文件*introspection.txt* ➋。接下来，使用`rdbuf`方法
    ➌将内容打印到stdout，重置游标到文件的第一个字符 ➍，然后再次打印内容。请注意，这两次输出是相同的（因为文件没有变化） ➎。然后，您使用`seekg`的相对偏移重载来导航到文件末尾前第四个字符
    ➏。使用`tellg`，您会发现这是第49个字符（以零为基础的索引） ➐。当您将输入文件打印到stdout时，输出只有`end.`，因为这些是文件中的最后四个字符
    ➑。
- en: '**NOTE**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost offers an IOStream library with a rich set of additional features that
    stdlib doesn’t have, including facilities for memory mapped file I/O, compression,
    and filtering.*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost提供了一个IOStream库，具有std库所没有的丰富附加功能，包括内存映射文件I/O、压缩和过滤等功能。*'
- en: '**Summary**'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about streams, the major concept that provides
    a common abstraction for performing I/O. You also learned about files as a primary
    source and destination for I/O. You first learned about the fundamental stream
    classes in the stdlib and how to perform formatted and unformatted operations,
    inspect stream state, and handle errors with exceptions. You learned about manipulators
    and how to incorporate streams into user-defined types, string streams, and file
    streams. This chapter culminated with stream buffer iterators, which allow you
    to adapt a stream to an iterator.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了流，这是提供执行I/O的公共抽象的主要概念。您还了解了文件作为I/O的主要源和目标。您首先了解了stdlib中的基本流类，以及如何执行格式化和非格式化操作、检查流状态和处理异常错误。您了解了操作符和如何将流整合到用户定义的类型、字符串流和文件流中。本章的高潮是流缓冲区迭代器，它使您能够将流适配为迭代器。
- en: '**EXERCISES**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**16-1.** Implement an output operator that prints information about the `AutoBrake`
    from “An Extended Example: Taking a Brake” on [page 283](ch10.xhtml#page_283).
    Include the vehicle’s current collision threshold and speed.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**16-1.** 实现一个输出操作符，打印“扩展示例：刹车”中的`AutoBrake`信息（参见[第283页](ch10.xhtml#page_283)）。包括车辆当前的碰撞阈值和速度。'
- en: '**16-2.** Write a program that takes output from stdin, capitalizes it, and
    writes the result to stdout.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**16-2.** 编写一个程序，接受stdin中的输出，将其大写，并将结果写入stdout。'
- en: '**16-3.** Read the introductory documentation for Boost IOStream.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**16-3.** 阅读Boost IOStream的介绍文档。'
- en: '**16-4.** Write a program that accepts a file path, opens the file, and prints
    summary information about the contents, including word count, average word length,
    and a histogram of the characters.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**16-4.** 编写一个程序，接受一个文件路径，打开文件并打印有关文件内容的摘要信息，包括单词计数、平均单词长度和字符的直方图。'
- en: '**FURTHER READING**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Standard C++ IOStreams and Locales: Advanced Programmer’s Guide and Reference*
    by Angelika Langer (Addison-Wesley Professional, 2000)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《标准C++ IOStreams和区域设置：高级程序员指南与参考》*，作者：Angelika Langer（Addison-Wesley Professional，2000）'
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO国际标准ISO/IEC（2017）— C++编程语言*（国际标准化组织；瑞士日内瓦；* [https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)
    *）'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost C++库*，第二版，由Boris Schäling编写（XML Press，2014年）'
