<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_149"/><strong><span class="big">15</span><br/>RACE CONDITIONS</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">A <em>race condition</em> occurs when two processes race to complete based on an initial condition that becomes invalid while the processes are executing. A classic example is transferring money between bank accounts:</p>&#13;
<ol>&#13;
<li class="noindent">You have $500 in your bank account, and you need to transfer the entire amount to a friend.</li>&#13;
<li class="noindent">Using your phone, you log into your banking app and request a transfer of $500 to your friend.</li>&#13;
<li class="noindent">After 10 seconds, the request is still processing. So you log into the banking site on your laptop, see that your balance is still $500, and request the transfer again.</li>&#13;
<li class="noindent">The laptop and mobile requests finish within a few seconds of each other.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_150"/>Your bank account is now $0.</li>&#13;
<li class="noindent">Your friend messages you to say he received $1,000.</li>&#13;
<li class="noindent">You refresh your account, and your balance is still $0.</li>&#13;
</ol>&#13;
<p class="indent">Although this is an unrealistic example of a race condition, because (hopefully) all banks prevent money from just appearing out of thin air, the process represents the general concept. The condition for the transfers in steps 2 and 3 is that you have enough money in your account to initiate a transfer. But your account balance is validated only at the start of each transfer process. When the transfers execute, the initial condition is no longer valid, but both processes still complete.</p>&#13;
<p class="indent">HTTP requests can seem instantaneous when you have a fast internet connection, but processing requests still takes time. While you’re logged into a site, every HTTP request you send must be reauthenticated by the receiving site; additionally, the site must load the data necessary for your requested action. A race condition could occur in the time it takes the HTTP request to complete both tasks. The following are examples of race condition vulnerabilities found in web applications.</p>&#13;
<h3 class="h3" id="ch15lev1sec1"><strong>Accepting a HackerOne Invite Multiple Times</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>hackerone.com/invitations/&lt;INVITE_TOKEN&gt;/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/119354/">https://hackerone.com/reports/119354/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> February 28, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Swag</p>&#13;
<p class="noindent">When you’re hacking, watch for situations where your action depends on a condition. Look for any actions that seem to execute a database lookup, apply application logic, and update a database.</p>&#13;
<p class="indent">In February 2016, I was testing HackerOne for unauthorized access to program data. The invite functionality that adds hackers to programs and members to teams caught my eye.</p>&#13;
<p class="indent">Although the invitation system has since changed, at the time of my testing, HackerOne emailed invites as unique links that weren’t associated with the recipient email address. Anyone could accept an invitation, but the invite link was meant to be accepted only once and used by a single account.</p>&#13;
<p class="indent">As bug hunters, we can’t see the actual process the site uses to accept invitations, but we can still guess how the application works and use our assumptions to find bugs. HackerOne used a unique, token-like link for invites. So, most likely, the application would look up the token in a database, add an account based on the database’s entry, and then update the token record in the database so the link couldn’t be used again.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_151"/>This type of workflow can cause race conditions for two reasons. First, the process of looking up a record and then acting on the record using coding logic creates a delay. The lookup is the precondition that must be met to initiate the invite process. If the application code is slow, two near-instantaneous requests could both perform the lookup and satisfy their conditions to execute.</p>&#13;
<p class="indent">Second, updating records in the database can create a delay between the condition and the action that modifies the condition. For example, updating records requires looking through the database table to find the record to update, which takes time.</p>&#13;
<p class="indent">To test whether a race condition existed, I created a second and third account in addition to my primary HackerOne account (I’ll refer to the accounts as Users A, B, and C). As User A, I created a program and invited User B to it. Then I logged out as User A. I received the invite email as User B and logged into that account in my browser. I logged in as User C in another private browser and opened the same invite.</p>&#13;
<p class="indent">Next, I lined up the two browsers and invite acceptance buttons so they were almost on top of each other, as shown in <a href="ch15.xhtml#ch15fig01">Figure 15-1</a>.</p>&#13;
<div class="image"><a id="ch15fig01"/><img alt="image" src="../images/15fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 15-1: Two stacked browser windows showing the same HackerOne invite</em></p>&#13;
<p class="indent">Then I clicked both Accept buttons as quickly as possible. My first attempt didn’t work, which meant I had to go through the process again. But my second attempt was successful, and I managed to add two users to a program using one invite.</p>&#13;
<h4 class="h4" id="ch15lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">In some cases, you can manually test for race conditions—although you might need to adapt your workflow so you can perform actions as quickly as possible. In this case, I could arrange the buttons side by side, which made the exploit possible. In situations where you need to perform complicated steps, you might not be able to use manual testing. Instead, automate your testing so you can perform actions almost simultaneously.</p>&#13;
<h3 class="h3" id="ch15lev1sec2"><span epub:type="pagebreak" id="page_152"/><strong>Exceeding Keybase Invitation Limits</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://keybase.io/_/api/1.0/send_invitations.json/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/115007/">https://hackerone.com/reports/115007/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> February 5, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $350</p>&#13;
<p class="noindent">Look for race conditions in situations when a site has a limit to the number of actions you’re permitted to perform. For example, the security app Keybase limited the number of people allowed to sign up by providing registered users with three invites. As in the previous example, hackers could guess how Keybase was limiting invitations: most likely, Keybase was receiving the request to invite another user, checking the database to see whether the user had invites left, generating a token, sending the invite email, and decrementing the number of invites the user had left. Josip Franjković recognized that this behavior could be vulnerable to a race condition.</p>&#13;
<p class="indent">Franjković visited the URL <em><a href="https://keybase.io/account/invitations/">https://keybase.io/account/invitations/</a></em> where he could send invites, enter email addresses, and submit multiple invites simultaneously. Unlike with HackerOne’s invitation race condition, sending multiple invitations would be difficult to do manually, so Franjković likely used Burp Suite to generate the invite HTTP requests.</p>&#13;
<p class="indent">Using Burp Suite, you can send requests to the Burp Intruder, which allows you to define an insertion point in HTTP requests. You can specify payloads to iterate through for each HTTP request and add the payload to the insertion point. In this case, had Franjković been using Burp, he would have specified multiple email addresses as the payloads and had Burp send each request simultaneously.</p>&#13;
<p class="indent">As a result, Franjković was able to bypass the three-user limit and invite seven users to the site. Keybase confirmed the faulty design when resolving the issue and addressed the vulnerability by using a <em>lock</em>. A lock is a programmatic concept that restricts access to resources so other processes can’t access them.</p>&#13;
<h4 class="h4" id="ch15lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">In this case, Keybase accepted the invitation race condition, but not all bug bounty programs will pay an award for vulnerabilities with minor impact, as demonstrated earlier in “<a href="ch15.xhtml#ch15lev1sec1">Accepting a HackerOne Invite Multiple Times</a>” on <a href="ch15.xhtml#page_150">page 150</a>.</p>&#13;
<h3 class="h3" id="ch15lev1sec3"><span epub:type="pagebreak" id="page_153"/><strong>HackerOne Payments Race Condition</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> N/A</p>&#13;
<p class="hang"><strong>Source:</strong> Undisclosed</p>&#13;
<p class="hang"><strong>Date reported:</strong> April 12, 2017</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $1,000</p>&#13;
<p class="noindent">Some websites update records based on your interactions with them. For example, when you submit a report on HackerOne, the submission triggers an email that is sent to the team you submitted to, which triggers an update to the team’s stats.</p>&#13;
<p class="indent">But some actions, such as payments, don’t occur immediately in response to an HTTP request. For instance, HackerOne uses a <em>background job</em> to create money transfer requests for payment services like PayPal. Background job actions are usually performed in a batch and are initiated by some trigger. Sites commonly use them when they need to process a lot of data, but they’re independent from a user’s HTTP request. This means that when a team awards you a bounty, the team will get a receipt for the payment as soon as your HTTP request is processed, but the money transfer will be added to a background job to be completed later.</p>&#13;
<p class="indent">Background jobs and data processing are important components in race conditions because they can create a delay between the act of checking the conditions (time of check) and the act of completing the actions (time of use). If a site only checks for conditions when adding something to a background job, but not when the condition is actually used, the site’s behavior can lead to a race condition.</p>&#13;
<p class="indent">In 2016, HackerOne began combining bounties awarded to hackers into a single payment when using PayPal as the payment processor. Previously, when you were awarded multiple bounties in a day, you would receive separate payments from HackerOne for each bounty. After the change, you’d receive a lump sum payment for all the bounties.</p>&#13;
<p class="indent">In April 2017, Jigar Thakkar tested this functionality and recognized he could duplicate payouts. During the payment process, HackerOne would collect the bounties according to email address, combine them into one amount, and then send the payment request to PayPal. In this case, the precondition was looking up the email addresses associated with the bounties.</p>&#13;
<p class="indent">Thakkar found that if two HackerOne users had the same email address registered with PayPal, HackerOne would combine the bounties into a single payment for that single Paypal address. But if the user who found the bug changed their PayPal address after the bounty payments were combined but before HackerOne’s background job sent the request to PayPal, the lump sum payment would go to both the original PayPal address and the new email address that the user who found the bug changed it to.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>Although Thakkar successfully tested this bug, exploiting background jobs can be tricky: you have to know when the processing initiates, and you only have a few seconds to modify the conditions.</p>&#13;
<h4 class="h4" id="ch15lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">If you notice a site is performing actions well after you’ve visited it, it’s likely using a background job to process data. This is an opportunity for testing. Change the conditions that define the job and check whether the job is processed using the new conditions instead of the old ones. Be sure to test the behavior as though the background job would execute immediately—background processing can often occur quickly, depending on how many jobs have been queued and the site’s approach to processing data.</p>&#13;
<h3 class="h3" id="ch15lev1sec4"><strong>Shopify Partners Race Condition</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> N/A</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/300305/">https://hackerone.com/reports/300305/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> December 24, 2017</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $15,250</p>&#13;
<p class="noindent">Previously disclosed reports can tell you where to find more bugs. Tanner Emek used this strategy to find a critical vulnerability in Shopify’s Partners platform. The bug allowed Emek to access any Shopify store as long as he knew the email address belonging to a store’s current staff member.</p>&#13;
<p class="indent">Shopify’s Partner platform allows shop owners to give partnered developers access to their stores. Partners request access to Shopify stores through the platform, and the store owners must approve the request before partners can access the store. But to send a request, a partner must have a verified email address. Shopify verifies email addresses by sending a unique Shopify URL to the supplied email address. When the partner accesses the URL, the email address is considered verified. This process occurs whenever a partner registers an account or changes their email address on an existing account.</p>&#13;
<p class="indent">In December 2017, Emek read a report written by @uzsunny that was awarded $20,000. The report revealed a vulnerability that allowed @uzsunny to access any Shopify store. The bug occurred when two partner accounts shared the same email and requested access to the same store one after another. Shopify’s code would automatically convert a store’s existing staff account to a collaborator account. When a partner had a preexisting staff account on a store and requested collaborator access from the Partners platform, Shopify’s code automatically accepted and <span epub:type="pagebreak" id="page_155"/>converted the account to a collaborator account. In most situations, this conversion made sense because the partner already had access to the store with a staff account.</p>&#13;
<p class="indent">But the code didn’t properly check what type of existing account was associated with the email address. An existing collaborator account in the “pending” state, not yet accepted by the store owner, would be converted to an active collaborator account. The partner would effectively be able to approve their own collaborator request without the store owner’s interaction.</p>&#13;
<p class="indent">Emek recognized that the bug in @uzsunny’s report relied on being able to send a request through a verified email address. He realized that if he could create an account and change the account’s email address to one that matched a staff member’s email, he might be able to use the same method as @uzsunny to maliciously convert the staff account to a collaborator account he controlled. To test whether this bug was possible through a race condition, Emek created a partner account using an email address he controlled. He received a verification email from Shopify but didn’t visit the URL right away. Instead, in the Partner platform, he changed his email address to <em><a href="mailto:cache@hackerone.com">cache@hackerone.com</a></em>, an address he didn’t own, and intercepted the email change request using Burp Suite. He then clicked and intercepted the verification link to validate his email address. Once he had intercepted both HTTP requests, Emek used Burp to send the email change request and verification request one after the other, almost simultaneously.</p>&#13;
<p class="indent">After sending the requests, Emek reloaded the page and found Shopify had executed the change request and the verification request. These actions caused Shopify to validate Emek’s email address as <em><a href="mailto:cache@hackerone.com">cache@hackerone.com</a></em>. Requesting collaborator access to any Shopify store that had an existing staff member with the email address <em><a href="mailto:cache@hackerone.com">cache@hackerone.com</a></em> would allow Emek access to that store without any administrator interaction. Shopify confirmed the bug was due to a race condition in the application’s logic when changing and verifying email addresses. Shopify fixed the bug by locking the account database record during each action and requiring store administrators to approve all collaborator requests.</p>&#13;
<h4 class="h4" id="ch15lev2sec4"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Recall from the “<a href="ch05.xhtml#ch05lev1sec2">HackerOne Unintended HTML Inclusion</a>” report on <a href="ch05.xhtml#page_44">page 44</a> that fixing one vulnerability doesn’t fix all vulnerabilities associated with an application’s functionality. When a site discloses new vulnerabilities, read the report and retest the application. You might not find any issues, you might bypass the developer’s intended fix, or you might find a new vulnerability. At a minimum, you’ll develop new skills by testing that functionality. Thoroughly test any verification systems, thinking about how developers could have coded the functionality and whether it could be vulnerable to a race condition.</p>&#13;
<h3 class="h3" id="ch15lev1sec5"><span epub:type="pagebreak" id="page_156"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Any time a site performs actions that depend on a condition being true and changes the condition as a result of the action being performed, there’s an opportunity for race conditions. Be on the lookout for sites that limit the number of actions you’re permitted to perform or that process actions using background jobs. A race condition vulnerability usually requires conditions to change very quickly, so if you think something is vulnerable, you might need multiple attempts to actually exploit the behavior.</p>&#13;
</body></html>