- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    AUTHENTICATION</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before you can interact with a Windows system, you need to complete its complex
    authentication process, which converts a set of credentials, such as a username
    and a password, into a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object that represents the user’s identity.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is too big a topic to cover in a single chapter; therefore, I’ve
    split it into three parts. This chapter and the next one will provide an overview
    of Windows authentication, how the operating system stores a user’s configuration,
    and how to inspect that configuration. In the chapters that follow, we’ll discuss
    *interactive authentication*, the mechanism used to interact directly with a Windows
    system, such as via the GUI. The book’s final chapters cover *network authentication*,
    a type of authentication that allows users who are not physically connected to
    a system to supply credentials and generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object that represents their identity. For example, if you connect to a Windows
    system using its file-sharing network connection, you’ll use network authentication
    under the hood to provide the identity needed to access file shares.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter with an overview of domain authentication. Then we’ll
    take a deep dive into how the authentication configuration is stored locally,
    as well as how we can access that configuration using PowerShell. We’ll finish
    with an overview of how Windows stores the local configuration internally and
    how you can use your knowledge of it to extract a user’s hashed password.
  prefs: []
  type: TYPE_NORMAL
- en: To make the most of these authentication chapters, I recommend setting up domain
    network virtual machines, as described in [Appendix A](appendix-A.xhtml). You
    can still run many of the examples without setting up the domain network, but
    any command that requires a network domain won’t function without it. Also note
    that the actual output of certain commands might change depending on how you set
    up the virtual machines, but the general concepts should stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Domain Authentication</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of authentication, Windows sorts its users and groups into
    domains. A *domain* provides a policy for how users and groups can access resources;
    it also provides storage for configuration information such as passwords. The
    architecture of Windows domains is complex enough to require its own book. However,
    you should familiarize yourself with some basic concepts before we dig deep into
    the authentication configuration.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Authentication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest domain in Windows lives on a stand-alone computer, as shown in
    [Figure 10-1](chapter10.xhtml#fig10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: A local domain
    on a stand-alone computer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The users and groups on the computer can access only local resources. A local
    domain has a *local policy* that defines the application and security configuration
    on the computer. The domain is assigned the same name as the computer: *GRAPHITE*,
    in this example. The local domain is the only type you’ll be able to inspect if
    you don’t have an enterprise network configured.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enterprise Network
    Domains</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 10-2](chapter10.xhtml#fig10-2) shows the next level of complexity,
    an enterprise network domain.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: A single enterprise
    network domain</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of requiring each individual workstation or server to maintain its own
    users and groups, an enterprise network domain maintains these centrally on a
    *domain controller*. It stores the user configuration in a database on the domain
    controller called *Active Directory*. When a user wants to authenticate to the
    domain, the computer passes the authentication request to the domain controller,
    which knows how to use the user configuration to verify the request. We’ll cover
    exactly how domain authentication requests are handled in [Chapters 12](chapter12.xhtml)
    and [14](chapter14.xhtml), when we discuss interactive authentication and Kerberos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple domain controllers can manage a single domain; the domain controllers
    use a special replication protocol to duplicate the configuration so that they’re
    always up to date. Having multiple domain controllers ensures redundancy: if one
    domain controller fails, another can provide authentication services to the computers
    and users in the domain.'
  prefs: []
  type: TYPE_NORMAL
- en: Each domain controller also maintains a *group policy*, which computers in the
    network can query to automatically configure themselves using a common domain
    policy. This group policy can override the existing local policy and security
    configuration, making it easier to manage a large enterprise network. Each computer
    has a special user account that allows them to authenticate to the domain. This
    allows the computer to access the group policy configuration without a domain
    user being authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Since Windows 2000, the name of the domain has been a DNS name; in [Figure 10-2](chapter10.xhtml#fig10-2),
    it’s *mineral.local*. For compatibility with older versions of Windows or applications
    that don’t understand DNS names, the operating system also makes a simple domain
    name available. For example, the simple name in this case might be *MINERAL*,
    although the administrator is free to select their own simple name when setting
    up the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the local domain on an individual computer will still exist, even
    if there is a configured enterprise network domain. A user can always authenticate
    to their computer (the local domain) with credentials specific to that computer,
    unless an administrator disables the option by changing the local policy on the
    system. However, even though the computer itself is joined to a domain, those
    local credentials won’t work for accessing remote resources in the enterprise
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The local groups also determine the access granted to a domain user when they
    authenticate. For example, if a domain user is in the local *Administrators* group,
    then they’ll be an administrator for the local computer. However, that access
    won’t extend beyond that single computer. The fact that a user is a local administrator
    on one computer doesn’t mean they will get administrator access on another computer
    on the network.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Domain Forests</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next level of complexity is the *domain forest*. In this context, a *forest*
    refers to a group of related domains. The domains might share a common configuration
    or organizational structure. In [Figure 10-3](chapter10.xhtml#fig10-3), three
    domains make up the forest: *mineral.local*, which acts as the forest’s root domain,
    and two child domains, *engineering.mineral.local* and *sales.mineral.local*.
    Each domain maintains its own users, computers, and group policies.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: A domain forest</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: From a security perspective, some of the most important features in a forest
    are its *trust relationships*. A domain can be configured to trust another domain’s
    users and groups. This trust can be *one-way*, meaning a domain trusts another’s
    users, but not vice versa, or it can be *bidirectional*, meaning each domain trusts
    the other’s users. For example, in [Figure 10-3](chapter10.xhtml#fig10-3), there
    is bidirectional trust between the root domain and the *engineering.mineral.local*
    domain. This means that users in either domain can freely access resources in
    the other. There is also bidirectional trust between *sales.mineral.local* and
    the root. By default, when a new domain is added to an existing forest, a bidirectional
    trust relationship is established between the parent and child domains.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there’s no explicit trust relationship between the *engineering.mineral.local*
    and *sales.mineral.local* domains. Instead, the two domains have a bidirectional
    *transitive trust* relationship; as both domains have a bidirectional trust relationship
    with their common parent, the parent allows users in engineering to access resources
    in sales, and vice versa. We’ll discuss how trust relationships are implemented
    in [Chapter 14](chapter14.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The forest also contains a shared *global catalog*. This catalog is a subset
    of the information stored in all the Active Directory databases in the forest.
    It allows users in one domain or subtree to find resources in the forest without
    having to go to each domain separately.
  prefs: []
  type: TYPE_NORMAL
- en: You can combine multiple forests by establishing inter-forest trust relationships,
    as shown in [Figure 10-4](chapter10.xhtml#fig10-4). These trust relationships
    can also be one-way or bidirectional, and they can be established between entire
    forests or between individual domains as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: Multiple forests
    with trust relationships</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In general, inter-forest trust relationships are not transitive. So, while in
    [Figure 10-4](chapter10.xhtml#fig10-4) *vegetable.local* trusts *mineral.local*,
    it won’t automatically trust anything in the *sales.animal.local* domain even
    though there’s a bidirectional trust relationship between *sales.animal.local*
    and *sales.mineral.local*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Managing trust relationships can be complex, especially as the numbers of
    domains and forests grow. It’s possible to inadvertently create trust relationships
    that a malicious user could exploit to compromise an enterprise network. I won’t
    discuss how to analyze these relationships to find security issues; however, the
    security tool BloodHound (*[https://<wbr>github<wbr>.com<wbr>/SpecterOps<wbr>/BloodHound](https://github.com/SpecterOps/BloodHound)*)
    can help with this.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The next few chapters will focus on the configuration of a local domain and
    a simple forest. If you want to know about more complex domain relationships,
    the Microsoft technical documentation is a good resource. For now, let’s continue
    by detailing how a local domain stores authentication configurations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Local Domain Configuration</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A user must authenticate to the Windows system before a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object can be created for them, and to authenticate to the system, the user must
    provide proof of their identity. This might take the form of a username and password,
    a smart card, or biometrics, such as a fingerprint.
  prefs: []
  type: TYPE_NORMAL
- en: The system must store these credentials securely so that they can be used to
    authenticate the user but are not publicly disclosed. For the local domain configuration,
    this information is maintained by the *Local Security Authority (LSA)*, which
    runs in the LSASS process. [Figure 10-5](chapter10.xhtml#fig10-5) gives an overview
    of the local domain configuration databases maintained by the LSA.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: Local domain configuration
    databases</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LSA exposes various APIs that an application such as PowerShell can call.
    These APIs access two configuration databases: the user database and the LSA policy
    database. Let’s go through what information is stored in each database and how
    they can be accessed from PowerShell.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The User Database</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *user database* stores two containers of information for the purposes of
    local authentication. One container holds local usernames, their SIDs, and passwords.
    The other holds local group names, their SIDs, and user membership. We’ll look
    at each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inspecting Local User Accounts</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can inspect the local user accounts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    command, which is built into PowerShell ([Listing 10-1](chapter10.xhtml#Lis10-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Displaying local user accounts using the Get-LocalUser command'
  prefs: []
  type: TYPE_NORMAL
- en: This command lists the names and SIDs of all the local users on the device,
    and indicates whether each user is enabled. If a user is not enabled, the LSA
    won’t allow the user to authenticate, even if they provide the correct password.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that all the SIDs have a common prefix; only the last RID changes.
    This common prefix is the *machine SID*, and it’s randomly generated when Windows
    is installed. Because it’s generated randomly, each machine should have a unique
    one. You can get the machine SID by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    and specifying the name of the local computer, as shown in [Listing 10-2](chapter10.xhtml#Lis10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: Querying the machine SID'
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to extract a local user’s password using a public API. In any
    case, by default, Windows doesn’t store the actual password; instead, it stores
    an MD4 hash of the password, commonly called the *NT hash*. When a user authenticates,
    they provide the password to the LSA, which hashes it using the same MD4 hash
    algorithm and compares it against the value in the user database. If they match,
    the LSA assumes that the user knew the password, and the authentication is verified.
  prefs: []
  type: TYPE_NORMAL
- en: You might be concerned that the use of an obsolete message digest algorithm
    (MD4) for the password hash is insecure—and you’d be right. Having access to the
    NT hashes is useful, because you might be able to crack the passwords to get the
    original text versions. You can also use a technique called *pass-the-hash* to
    perform remote network authentication without needing the original password.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Windows used to store a separate* LAN Manager (LM) hash *along with the NT
    hash. Since Windows Vista, this is disabled by default. The LM hash is extremely
    weak; for example, the password from which the hash is derived can’t be longer
    than 14 uppercase characters. Cracking an LM hash password is significantly simpler
    than cracking an NT hash, which is also weak.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can create a new local user using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp>
    command, as demonstrated in [Listing 10-3](chapter10.xhtml#Lis10-3). You’ll need
    to provide a username and password for the user. You’ll also need to run this
    command as an administrator; otherwise, it would be easy to gain additional privileges
    on the local system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: Creating a new local user'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new local user, first we must get the user’s password ❶. This password
    must be a secure string, so we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp>
    parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp>
    command. We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp>
    command to create the user, passing it the name of the user and the secure password
    ❷. If you don’t see an error returned, the creation succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the user, we can query the SID that the LSA assigned
    to the new user. We do this by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    command and passing it the full name for the user, including the local computer
    name ❸. You’ll notice that the SID consists of the machine SID and the incrementing
    final RID. In this case, the next RID is <samp class="SANS_TheSansMonoCd_W5Regular_11">1003</samp>,
    but it could be anything, depending on what other users or groups have been created
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the user created in [Listing 10-3](chapter10.xhtml#Lis10-3) from
    the local system, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalUser</samp>
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this command only removes the account; the deletion doesn’t guarantee
    that any resources the user might have created will be removed. For this reason,
    the LSA should never reuse a RID: that might allow a new user access to resources
    for a previous user account that was deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inspecting Local Groups</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can inspect local groups in a manner similar to inspecting users, by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command
    ([Listing 10-4](chapter10.xhtml#Lis10-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: Displaying local groups using the Get-LocalGroup command'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that there are two types of SIDs in the list. The first group,
    *Awesome Users*, has a SID prefixed with the machine SID. This is a locally defined
    group. The rest of the groups have a different prefix. As we saw in [Chapter 5](chapter5.xhtml),
    this is the domain SID for the *BUILTIN* domain. These groups, such as *BUILTIN\Administrators*,
    are created by default along with the user database.
  prefs: []
  type: TYPE_NORMAL
- en: Each local group in the user database has a list of members, which can be users
    or other groups. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroupMember</samp>
    command to get the list of group members, as shown in [Listing 10-5](chapter10.xhtml#Lis10-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: Displaying local group members for the <samp class="SANS_Futura_Std_Book_11">Awesome
    Users</samp> group'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-5](chapter10.xhtml#Lis10-5) shows three columns for each member
    of the *Awesome Users* group. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp>
    column represents the type of entry (in this case, either <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp>). If a group has
    been added as an entry, all members of that group will also be members of the
    enclosing group. Therefore, this output indicates that all members of the *INTERACTIVE*
    group are also members of the *Awesome Users* group.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-6](chapter10.xhtml#Lis10-6) shows how to add a new group and a
    new group member, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalGroup</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp>
    commands. You’ll need to run these commands as an administrator.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Adding a new local group and group member'
  prefs: []
  type: TYPE_NORMAL
- en: We start by adding a new local group, specifying the group’s name ❶. As with
    a user, we can query for the group’s SID using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    command ❷.
  prefs: []
  type: TYPE_NORMAL
- en: To add a new member to the group, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp>
    command, specifying the group and the members we want to add ❸. Querying the group
    membership shows that the user was added successfully ❹. Note that the user won’t
    be granted access to the additional group until the next time they successfully
    authenticate; that is, the group won’t be automatically added to existing tokens
    for that user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the local group added in [Listing 10-6](chapter10.xhtml#Lis10-6),
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalGroup</samp>
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all we’ll say about the user database for now. Let’s turn to the other
    database maintained by the LSA: the policy database.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The LSA Policy Database</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second database the LSA maintains is the LSA policy database, which stores
    account rights and additional related information, such as the system audit policy
    we covered in [Chapter 9](chapter9.xhtml) and arbitrary secret objects used to
    protect various system services and credentials. We’ll cover the account rights
    in this section and secrets later in this chapter, when we discuss remote access
    to the LSA policy database.
  prefs: []
  type: TYPE_NORMAL
- en: '*Account rights* define what privileges a user’s token will be assigned when
    they authenticate, as well as what mechanisms the user can use to authenticate
    (logon rights). Like local groups, they contain a list of member users and groups.
    We can inspect the assigned account rights using the PowerShell module’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp> command, as
    shown in [Listing 10-7](chapter10.xhtml#Lis10-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: Displaying the privilege account rights for the local system'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we list only the privileges by specifying the appropriate <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value. In the output, we can
    see the name of each privilege (these are described in [Chapter 4](chapter4.xhtml)),
    as well as a column containing the users or groups that are assigned the privilege.
    You’ll need to run the command as an administrator to see the list of SIDs.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that some of these entries are empty. This doesn’t necessarily
    mean that no user or group is assigned this privilege, however; for example, when
    a *SYSTEM* user token is created privileges such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    are automatically assigned, without reference to the account rights assignment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you assign certain high-level privileges to a user (such as SeTcbPrivilege,
    which permits security controls to be bypassed), it will make the user equivalent
    to an administrator even if they’re not in the* Administrators *group. We’ll see
    a case in which this is important when we discuss token creation in [Chapter 12](chapter12.xhtml).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We can list the logon account rights using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    command with a different <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    value. Run the command in [Listing 10-8](chapter10.xhtml#Lis10-8) as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: Displaying the logon account rights for the local system'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the names in the first column, you might think they look like privileges;
    however, they’re not. The logon rights represent the authentication roles a user
    or group can perform. Each one has both an allow and a deny form, as described
    in [Table 10-1](chapter10.xhtml#tab10-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">Account
    Logon Rights</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Allow right</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Deny
    right</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate for an interactive session.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate from the network.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp> | <samp
    class="SANS_Futura_Std_Book_11">Authenticate to the local system without an interactive
    console session.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate for a service process.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate to interact with a remote
    desktop.</samp> |'
  prefs: []
  type: TYPE_TB
- en: If a user or group is not assigned a logon right, they won’t be granted permission
    to authenticate in that role. For example, if a user who is not granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> attempts
    to authenticate to the physical console, they’ll be denied access. However, if
    they are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>,
    the user might still be able to connect to the Windows system over the network
    to access a file share and authenticate successfully. The deny rights are inspected
    before the allow rights, so you can allow a general group, such as *Users*, and
    then deny specific accounts.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell module also provides commands to modify the user rights assignment.
    You can add a SID to an account right using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp>
    command. To remove a SID, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp>
    command. We’ll see examples of how to use these commands in [Chapter 12](chapter12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Remote LSA Services</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section demonstrated communicating with the LSA on the local system
    and extracting information from its configuration databases in PowerShell using
    commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>. I
    previously described the mechanisms used to access this information as a single
    set of local APIs, but it’s actually a lot more complicated than that. [Figure
    10-6](chapter10.xhtml#fig10-6) shows how the two local domain configuration databases
    are exposed to an application such as PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The LSA’s remote
    services and objects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    command, which calls a Win32 API to enumerate the local users. The user database
    is stored in the *security account manager (SAM) database* and is accessed using
    the *SAM remote service*. To enumerate the list of users in the local SAM database,
    an application must first request access to a domain object. From that domain
    object, the API can query the user list, or different APIs could enumerate local
    groups or aliases instead.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the LSA policy database is stored in the SECURITY database,
    and to access it, we use the *domain policy remote service*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the network protocols used to access the SAM and SECURITY databases are
    different, they share a couple of common idioms:'
  prefs: []
  type: TYPE_NORMAL
- en: The client initially requests a connection to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once connected, the client can request access to individual objects, such as
    domains or users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database and objects have configured security descriptors used to control
    access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PowerShell commands interact with the local LSA, but the same network protocol
    could be used to query the LSA on another machine in an enterprise network. To
    get a better understanding of how the database access works, we need to use the
    low-level APIs to drive the protocol, as the higher-level APIs used by commands
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> hide
    much of the complexity and structure. The following sections discuss how you can
    access the databases directly to inspect their security information and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SAM Remote Service</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft documents the service used to access the SAM in the *MS-SAMR* document,
    which is available online. Luckily, however, we don’t need to reimplement this
    protocol ourselves. We can make a connection to the SAM using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamConnect</samp>
    Win32 API, which returns a handle we can use for subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 10-9](chapter10.xhtml#Lis10-9), we make a connection to the SAM
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connect-SamServer</samp>
    command, which exposes the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamConnect</samp>
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: Connecting to the SAM and displaying its security descriptor'
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the name of the server containing the SAM using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerName</samp>
    property. In this case, we use *localhost* (for clarity; specifying this value
    is redundant, as it’s the default for the command). The connection has an associated
    security descriptor that we query using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>
    command introduced in [Chapter 5](chapter5.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In [Chapter 6](chapter6.xhtml) we discussed using the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Set-NtSecurityDescriptor</samp>
    command to modify a security descriptor. You could use this to grant other users
    access to the SAM, but doing so is not recommended; if done incorrectly, it could
    grant a low-privileged user SAM access, which could lead to an elevation of privileges
    or even a remote compromise of the Windows system.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can request specific access rights on the connection with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>
    parameter. If it’s not specified (as was the case in [Listing 10-9](chapter10.xhtml#Lis10-9)),
    the command will request the maximum allowed access. The following are the defined
    access rights for the SAM server connection:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Connect  </samp>Enables connecting
    to the SAM server
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shutdown</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables
    shutting down the SAM server
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Initialize  </samp>Enables initializing
    the SAM database
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateDomain  </samp>Enables creating
    a new domain in the SAM database
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EnumerateDomains  </samp>Enables
    enumerating domains in the SAM database
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">LookupDomain  </samp>Enables looking
    up a domain’s information from the SAM database
  prefs: []
  type: TYPE_NORMAL
- en: To connect to the SAM server, the security descriptor must grant the caller
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connect</samp> access right.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Shutdown</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Initialize</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDomain</samp> access rights
    were defined for operations no longer supported by the SAM service.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The default configuration allows only users who are members of the computer’s
    local* Administrators *group to access the SAM remotely. If the caller is not
    a local administrator, access will be denied, regardless of the security descriptor
    configuration on the SAM. Windows 10 introduced this additional restriction to
    make it harder for* *malicious users to enumerate local users and groups on domain-joined
    systems or exploit weak security configurations. It does not apply to domain controllers
    or when accessing the SAM locally.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Domain Objects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *domain object* is a securable resource exposed by the SAM. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateDomains</samp>
    access right on the connection allows you to enumerate the names of the domains
    in the SAM database, while <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupDomain</samp>
    allows you to convert those names to SIDs, which are required to open a domain
    object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenDomain</samp>
    API.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell implements this API in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamDomain</samp>
    command. In [Listing 10-10](chapter10.xhtml#Lis10-10), we use it to inspect the
    domain configuration in the SAM database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-10: Enumerating and opening domains'
  prefs: []
  type: TYPE_NORMAL
- en: We start by enumerating the domains accessible to the SAM. Because we use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp> parameter, this
    command won’t open any domain objects; it will just return the names and domain
    SIDs. We’re querying a workstation, so the first entry is the local workstation
    name, in this case *GRAPHITE*, and the local machine SID. The second is the built-in
    domain, which contains groups such as *BUILTIN\Administrators*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the domains being enumerated are on a domain controller, the SAM
    service doesn’t query a local SAM database. Instead, the service accesses the
    user data from Active Directory. In this case, the whole domain replaces the local
    domain object; it’s not possible to directly query local users on a domain controller.
    We’ll see in [Chapter 11](chapter11.xhtml) how to access the same information
    using native network protocols for Active Directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same command to open a domain object directory by specifying
    its name or SID. In this case, we choose to use the name. As the domain is a securable
    object, you can specify the specific access rights with which to open the domain
    object from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPasswordParameters</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables reading password parameters
    (such as the policy)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePasswordParams  </samp>Enables
    writing password parameters
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOtherParameters  </samp>Enables
    reading general domain information
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOtherParameters  </samp>Enables
    writing general domain information
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateUser  </samp>Enables creating
    a new user
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateGroup  </samp>Enables creating
    a new group
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateAlias  </samp>Enables creating
    a new alias
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetAliasMembership  </samp>Enables
    getting the membership of an alias
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListAccounts  </samp>Enables enumerating
    users, groups, or aliases in the domain
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Lookup  </samp>Enables looking
    up names or IDs of users, groups, or aliases
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdministerServer</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables
    changing the domain configuration, such as for domain replication
  prefs: []
  type: TYPE_NORMAL
- en: With the appropriate access, you can read or write properties of the domain
    object. For example, if you’ve been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadPasswordParameters</samp>
    access, you can query the password policy for the domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PasswordInformation</samp>
    property, as we did in [Listing 10-10](chapter10.xhtml#Lis10-10).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve been granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListAccounts</samp>
    access right, you can also use the domain object to enumerate three other types
    of resources: users, groups, and aliases. We’ll look at each of these in turn
    in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">User Objects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *user object* represents what you’d expect: a local user account. You can
    open a user object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenUser</samp>
    API or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp> PowerShell
    command. [Listing 10-11](chapter10.xhtml#Lis10-11) shows how to enumerate users
    in the domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp>
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-11: Enumerating users in the domain'
  prefs: []
  type: TYPE_NORMAL
- en: The list of usernames and SIDs returned here should match the output from [Listing
    10-1](chapter10.xhtml#Lis10-1), where we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    command. To get more information about a user, you need to open the user object
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: One property you can query on the opened user is the list of User Account Control
    flags. These flags define various properties of the user. In this case, as we’ve
    opened the *WDAGUtilityAccount* user, we find that it has the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountDisabled</samp>
    flag set ❷. This matches the output in [Listing 10-1](chapter10.xhtml#Lis10-1),
    which had the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> value
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> for this user
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the connection and the domain, each user object can have its own security
    descriptor configured. These can grant the following access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGeneral  </samp>Enables reading
    general properties; for example, the username and full name properties
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPreferences  </samp>Enables
    reading preferences; for example, the user’s text code page preference
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePreferences  </samp>Enables
    writing preferences; for example, the user’s text code page preference
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadLogon  </samp>Enables reading
    the logon configuration and statistics; for example, the last logon time
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadAccount  </samp>Enables reading
    the account configuration; for example, the user account control flags
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>Enables writing
    the account configuration; for example, the user account control flags
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ChangePassword  </samp>Enables
    changing the user’s password
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ForcePasswordChange  </samp>Enables
    force-changing a user’s password
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListGroups  </samp>Enables listing
    the user’s group memberships
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGroupInformation</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Currently unused
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteGroupInformation  </samp>Currently
    unused
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most interesting of these access rights are <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>.
    The first allows the user’s password to be changed using an API like <samp class="SANS_TheSansMonoCd_W5Regular_11">SamChangePassword</samp>.
    For this to succeed, the caller must provide the old password along with the new
    password to set. If the old password doesn’t match the one that’s currently set,
    the server rejects the change request. You can see in [Listing 10-11](chapter10.xhtml#Lis10-11)
    that the *Everyone* group ❸ and the *WDAGUtilityAccount* user are granted the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp> access right.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are circumstances where an administrator might need to be able
    to change a user’s password even if they don’t know the previous password (if
    the user has forgotten it, for example). A caller who is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access on the user object can assign a new one without needing to know the old
    password. In this case the password is set using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamSetInformationUser</samp>
    API. In [Listing 10-11](chapter10.xhtml#Lis10-11), only the *Administrators* group
    is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Group Objects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Group objects* configure the group membership of a user’s token when it’s
    created. We can enumerate the groups in a domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroup</samp>
    command and the members of a group using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp>,
    as shown in [Listing 10-12](chapter10.xhtml#Lis10-12).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-12: Listing domain group objects and enumerating members'
  prefs: []
  type: TYPE_NORMAL
- en: The output of this command might surprise you. Where are the rest of the groups
    we saw in [Listing 10-4](chapter10.xhtml#Lis10-4) as the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    command? Also, if you check that earlier output, you won’t find the *None* group,
    even though we see it returned here. What’s going on?
  prefs: []
  type: TYPE_NORMAL
- en: First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    command returns groups in both the local domain and the separate *BUILTIN* domain.
    In [Listing 10-12](chapter10.xhtml#Lis10-12), we’re looking at only the local
    domain, so we wouldn’t expect to see a group such as *BUILTIN\Administrators*.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> group
    is hidden from view by the higher-level APIs used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    command, as it’s not really a group you’re supposed to modify. It’s managed by
    the LSA, which adds new members automatically when new users are created. If we
    list the members by opening the group ❶ and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp>
    command ❷, we see that the members are stored as the user’s relative ID along
    with group attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the group doesn’t store the whole SID. This means a group can contain
    members in the same domain only, which severely limits their use. This is why
    the higher-level APIs don’t expose an easy way to manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the default security descriptor for a domain object doesn’t grant
    anyone the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateGroup</samp> access
    right, which allows for new groups to be created. Windows really doesn’t want
    you using group objects (although, if you really wanted to, you could change the
    security descriptor manually as an administrator to allow group creation to succeed).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Alias Objects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final object type is the *alias object*. These objects represent the groups
    you’re more familiar with, as they’re the underlying type returned by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command. For example,
    the *BUILTIN* domain object has aliases for groups such as *BUILTIN\Administrators*,
    which is used only on the local Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: As [Listing 10-13](chapter10.xhtml#Lis10-13) demonstrates, we can enumerate
    the aliases in a domain with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAlias</samp>
    command and query its members with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-13: Listing domain alias objects and enumerating members'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the only alias in the local domain is *Awesome Users* ❶. To see
    a list of its members, we can open the alias by name ❷ and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp>
    command ❸. Note that the entire SID is stored for each member, which means that
    (unlike with groups) the members of an alias can be from different domains. This
    makes aliases much more useful as a grouping mechanism and is likely why Windows
    does its best to hide the group objects from view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Group and alias objects support the same access rights, although the raw access
    mask values differ. You can request the following types of access on both kinds
    of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AddMember  </samp>Enables adding
    a new member to the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">RemoveMember  </samp>Enables removing
    a member from the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListMembers  </samp>Enables listing
    members of the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadInformation  </samp>Enables
    reading properties of the object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>Enables writing
    properties of the object
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of the SAM remote service. Let’s now take a quick
    look at the second remote service, which allows you to access the domain policy.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Domain Policy
    Remote Service</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft documents the protocol used to access the LSA policy (and thus the
    SECURITY database) in *MS-LSAD*. We can make a connection to the LSA policy using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaOpenPolicy</samp> Win32 API,
    which returns a handle for subsequent calls. PowerShell exposes this API with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPolicy</samp> command,
    as demonstrated in [Listing 10-14](chapter10.xhtml#Lis10-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-14: Opening the LSA policy, querying its security descriptor, and
    looking up a SID'
  prefs: []
  type: TYPE_NORMAL
- en: First, we open the LSA policy on the local system. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemName</samp>
    parameter to specify the system to access if it’s not the local system. The LSA
    policy is a securable object, and we can query its security descriptor as shown
    here, assuming we have <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify one or more of the following access rights for the open policy
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> parameter
    when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPolicy</samp>
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ViewLocalInformation  </samp>Enables
    viewing policy information
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ViewAuditInformation  </samp>Enables
    viewing audit information
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetPrivateInformation  </samp>Enables
    viewing private information
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TrustAdmin  </samp>Enables managing
    the domain trust configuration
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateAccount  </samp>Enables creating
    a new account object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateSecret  </samp>Enables creating
    a new secret object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreatePrivilege  </samp>Enables
    creating a new privilege (unsupported)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetDefaultQuotaLimits  </samp>Enables
    setting default quota limits (unsupported)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetAuditRequirements  </samp>Enables
    setting the audit event configuration
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AuditLogAdmin  </samp>Enables managing
    the audit log
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ServerAdmin  </samp>Enables managing
    the server configuration
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">LookupNames  </samp>Enables looking
    up SIDs or names of accounts
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Notification  </samp>Enables receiving
    notifications of policy changes
  prefs: []
  type: TYPE_NORMAL
- en: 'With the policy object and the appropriate access rights, you can manage the
    server’s configuration. You can also look up and open the three types of objects
    in the SECURITY database shown in [Figure 10-6](chapter10.xhtml#fig10-6): accounts,
    secrets, and trusted domains. The following sections describe these objects.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Account Objects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An *account object* is not the same as the user objects we accessed via the
    SAM remote service. An account object doesn’t need to be tied to a registered
    user account; instead, it’s used to configure the account rights we discussed
    earlier. For example, if you want to assign a specific privilege to a user account,
    you must ensure that an account object exists for the user’s SID and then add
    the privilege to that object.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a new account object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaCreateAccount</samp>
    API if you have <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateAccount</samp>
    access on the policy object. However, you don’t normally need to do this directly.
    Instead, you’ll typically access account objects from the LSA policy, as shown
    in [Listing 10-15](chapter10.xhtml#Lis10-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-15: Listing and opening LSA account objects'
  prefs: []
  type: TYPE_NORMAL
- en: We first open the policy with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ViewLocalInformation</samp>
    access right ❶, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccount</samp>
    PowerShell command to enumerate the account objects ❷. You can see that the output
    lists the internal groups, not the local users we inspected earlier in the chapter,
    returning the name and SID for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then open an account object by its SID; for example, here we open the
    built-in user’s account object ❸. The account objects are securable and have an
    associated security descriptor that you can query. In this case, we can see in
    the formatted output that only the *Administrators* group gets full access to
    an account ❹. The only other ACE grants <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access to *Everyone*, which prevents the rights for an account from being enumerated.
    If the security descriptor allows it, account objects can be assigned the following
    access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">View  </samp>Enables viewing information
    about the account object, such as privileges and logon rights
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustPrivileges  </samp>Enables
    adjusting the assigned privileges
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustQuotas  </samp>Enables adjusting
    user quotas
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustSystemAccess  </samp>Enables
    adjusting the assigned logon rights
  prefs: []
  type: TYPE_NORMAL
- en: If we rerun the commands in [Listing 10-15](chapter10.xhtml#Lis10-15) as an
    administrator, we can then use the account object to enumerate privileges and
    logon rights, as in [Listing 10-16](chapter10.xhtml#Lis10-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-16: Enumerating privileges and logon rights'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is interesting here is that privileges and logon rights are listed in
    separate ways, even though you saw earlier that account rights were represented
    in a manner similar to privileges: using the name to identify the right to assign.
    For the account object, privileges are stored as a list of LUIDs, which is the
    same format used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object. However, the logon rights are stored as a set of bit flags in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SystemAccess</samp> property.'
  prefs: []
  type: TYPE_NORMAL
- en: This difference is due to the way Microsoft designed the account right APIs
    that are used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    and related commands. These APIs merge the various account rights and privileges
    into one to make it easier for a developer to write correct code. I’d recommend
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    or the underlying API rather than going directly to the LSA policy to inspect
    and modify the account rights.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Secret Objects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The LSA can maintain secret data for other services on the system, as well as
    for itself. It exposes this data through *secret objects*. To create a new secret
    object you need to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateSecret</samp>
    access right on the policy. [Listing 10-17](chapter10.xhtml#Lis10-17) shows how
    to open and inspect an existing LSA secret object. Run these commands as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-17: Opening and inspecting an LSA secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by opening the policy, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSecret</samp>
    command to open a secret by name ❶. There is no API to enumerate the stored secrets;
    you must know their names to open them. In this case, we open a secret that should
    exist on every system: the *Data Protection API (DPAPI)* master key, named *DPAPI_SYSTEM*.
    The DPAPI is used to encrypt data based on the user’s password. For it to function,
    it needs a system master key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the secret is securable, we can check its security descriptor ❷, which can
    assign the following access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetValue  </samp>Enables setting
    the value of the secret
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryValue  </samp>Enables querying
    the value of the secret
  prefs: []
  type: TYPE_NORMAL
- en: If you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryValue</samp>
    access right, you can inspect the contents of the key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    method, as we do in [Listing 10-17](chapter10.xhtml#Lis10-17) ❸. The secret contains
    the current value and a previous value, as well as timestamps for when those values
    were set. Here, we display the current value as hex ❹. The contents of the secret’s
    value are defined by the DPAPI, which we won’t dig into further in this book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Trusted Domain Objects</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final type of object in the SECURITY database is the *trusted domain object*.
    These objects describe the trust relationships between domains in a forest. Although
    the domain policy remote service was designed for use with domains prior to the
    introduction of Active Directory, it can still be used to query the trust relationships
    on a modern domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-18](chapter10.xhtml#Lis10-18) shows an example of how to open the
    policy on a domain controller and then query for the list of trusted domains.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-18: Enumerating trust relationships for a domain controller'
  prefs: []
  type: TYPE_NORMAL
- en: To inspect and configure trust relationships, you should use Active Directory
    commands, not the domain policy remote service’s commands. Therefore, I won’t
    dwell on these objects any further; we’ll come back to the subject of inspecting
    trust relationships in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*While trusted domains are securable objects, the security descriptors are
    not configurable through any of the remote service APIs; attempting this will
    generate an error. This is because the security is implemented by Active Directory,
    not the LSA.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Name Lookup and Mapping</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re granted <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access, the domain policy remote service will let you translate SIDs to names,
    and vice versa. For example, as shown in [Listing 10-19](chapter10.xhtml#Lis10-19),
    you can specify one or more SIDs to receive the corresponding users and domains
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaName</samp> PowerShell
    command. You can also specify a name and receive the SID using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSid</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-19: Looking up a SID or a name from the policy'
  prefs: []
  type: TYPE_NORMAL
- en: Before Windows 10, it was possible for an unauthenticated user to use the lookup
    APIs to enumerate users on a system, as the anonymous user was granted <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access. This was a problem because an attack calling *RID cycling* could brute-force
    valid users on the system. As you witnessed in [Listing 10-14](chapter10.xhtml#Lis10-14),
    current versions of Windows explicitly deny the <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access right. However, RID cycling remains a useful technique for authenticated
    non-administrator domain users, as non-administrators can’t use the SAM remote
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to add mappings from SIDs to names, even if they’re not
    well-known SIDs or registered accounts in the SAM database. The Win32 API <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LsaManageSidNameMapping</samp> controls
    this. It’s used by the SCM (discussed in [Chapter 3](chapter3.xhtml)) to set up
    service-specific SIDs to control resource access, and you can use it yourself,
    although you’ll encounter the following restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The caller needs <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled and must be on the same system as the LSA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SID to map must be in the NT security authority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first RID of the SID must be between <samp class="SANS_TheSansMonoCd_W5Regular_11">80</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> (inclusive of those
    values).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must first register a domain SID before you can add a child SID in that
    domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaManageSidNameMapping</samp>
    API to add or remove mappings using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSidName</samp> PowerShell
    commands. [Listing 10-20](chapter10.xhtml#Lis10-20) shows how to add SID-to-name
    mappings to the LSA as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-20: Adding and removing SID-to-name mappings'
  prefs: []
  type: TYPE_NORMAL
- en: We first define the domain SID with a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>
    ❶, then create a user SID based on the domain SID with a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    ❷. We’re impersonating the *SYSTEM* user, so we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    privilege, which means we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp>
    parameter to add the mapping ❸. (Recall that you need to register the domain before
    adding the user.) We then use the policy to check the SID mappings for the LSA
    ❹. Finally, we remove the SID-to-name mappings to clean up the changes we’ve made
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of the LSA policy. Let’s now look at how the two
    configuration databases, SAM and SECURITY, are stored locally.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The SAM and SECURITY Databases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve seen how to access the SAM and SECURITY databases using the remote services.
    However, you’ll find it instructive to explore how these databases are stored
    locally, as registry keys. By accessing the databases directly, you can obtain
    information not exposed by the remote services, such as password hashes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*These registry keys aren’t designed to be accessed directly, so the way in
    which they store the user and policy configurations could change at any time.
    Keep in mind that the description provided in this section might no longer be
    accurate at the time you’re reading it. Also, because direct access is a common
    technique used by malicious software, it’s very possible that script code in this
    section that you attempt to run may be blocked by any antivirus product running
    on your system.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the SAM
    Database Through the Registry</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start with the SAM database, found in the registry at *REGISTRY\MACHINE\SAM.*
    It’s secured so that only the *SYSTEM* user can read and write to its registry
    keys. You could run PowerShell as the *SYSTEM* user with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Win32ChildProcess</samp>
    command and then access the registry that way, but there is a simpler approach.
  prefs: []
  type: TYPE_NORMAL
- en: As an administrator, we can bypass the read access check on the registry by
    enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>.
    If we create a new object manager drive provider while this privilege is enabled,
    we can inspect the SAM database registry key using the shell. Run the commands
    in [Listing 10-21](chapter10.xhtml#Lis10-21) as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-21: Mapping the <samp class="SANS_Futura_Std_Book_11">MACHINE</samp>
    registry key with SeBackupPrivilege and listing the SAM database registry key'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>.
    With the privilege enabled, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-PSDrive</samp>
    command to map a view of the *MACHINE* registry key to the *SEC:* drive. This
    enables the drive to use <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>
    to circumvent security checking.
  prefs: []
  type: TYPE_NORMAL
- en: We can list the contents of the SAM database registry key using the normal PowerShell
    commands. The two most important keys are *Account* ❶ and *Builtin* ❷. The *Account*
    key represents the local domain we accessed using the SAM remote service and contains
    the details of local users and groups. The *Builtin* key contains the local built-in
    groups; for example, *BUILTIN\Administrators*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Extracting User Configurations</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s use our access to the SAM database registry key to extract the configuration
    of a user account. [Listing 10-22](chapter10.xhtml#Lis10-22) shows how to inspect
    a user’s configuration. Run these commands as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-22: Displaying data for the default administrator user'
  prefs: []
  type: TYPE_NORMAL
- en: The registry key stores user information in keys where the name is the hexadecimal
    representation of the user’s RID in the domain. For example, in [Listing 10-22](chapter10.xhtml#Lis10-22),
    we query for the *Administrator* user, which always has a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp>
    in decimal. Therefore, we know it will be stored in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">000001F4</samp>,
    which is the RID in hexadecimal ❶. You could also list the *Users* key to find
    other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key contains a small number of binary values ❷. In this example, we have
    three values: the <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp> value,
    which is a set of fixed-sized attributes for the user; <samp class="SANS_TheSansMonoCd_W5Regular_11">V</samp>,
    which is a set of variable-sized attributes; and <samp class="SANS_TheSansMonoCd_W5Regular_11">SupplementalCredentials</samp>,
    which could be used to store credentials other than the NT hash, such as online
    accounts or biometric information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start of the variable-sized attributes value is an attribute index table.
    Each index entry has an offset, a size, and additional flags. The important user
    data is stored in these indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 0    **The user object’s security descriptor ❸'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 1    **The user’s name ❹'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 13    **The user’s LM hash ❺'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 14    **The user’s NT hash ❻'
  prefs: []
  type: TYPE_NORMAL
- en: The LM and NT hash values aren’t stored in plaintext; the LSA obfuscates them
    using a couple of different encryption algorithms, such as RC4 and Advanced Encryption
    Standard (AES). Let’s develop some code to extract the hash values for a user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Extracting the System Key</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the original version of Windows NT, you needed only the SAM database registry
    key to decrypt the NT hash. In Windows 2000 and later, you need an additional
    key, the *LSA system key*, which is hidden inside the *SYSTEM* registry key. This
    key is also used as part of the obfuscation mechanism for values in the SECURITY
    database registry key.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to extracting an NT hash is extracting the system key into a
    form we can use. [Listing 10-23](chapter10.xhtml#Lis10-23) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-23: Extracting the obfuscated LSA system key'
  prefs: []
  type: TYPE_NORMAL
- en: The key is stored in four separate parts inside the LSA configuration key ❶.
    To add a layer of obfuscation, the parts aren’t stored as registry values; instead,
    they’re hexadecimal text strings stored in the rarely used registry key class
    name value. We can extract these values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>
    property and then convert them to bytes ❷.
  prefs: []
  type: TYPE_NORMAL
- en: We must then permutate the boot key’s byte values using a fixed ordering to
    generate the final key ❸. We can run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSystemKey</samp>
    PowerShell command to display the bytes ❹. Note that the value of the key is system
    specific, so the output you see will almost certainly be different.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting thing to note is that getting the boot key doesn’t require administrator
    access. This means that an arbitrary file-read vulnerability could enable a non-administrator
    to extract the registry hive files backing the *SAM* and *SECURITY* registry keys
    and decrypt their contents (which doesn’t seem like a particularly good application
    of defense in depth).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypting the Password Encryption
    Key</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next step in the deobfuscation process is to decrypt the *password encryption
    key (PEK)* using the system key. The PEK is used to encrypt the user hash values
    we extracted in [Listing 10-22](chapter10.xhtml#Lis10-22). In [Listing 10-24](chapter10.xhtml#Lis10-24),
    we define the function to decrypt the PEK.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-24: Defining the Unprotect-PasswordEncryptionKey decryption function'
  prefs: []
  type: TYPE_NORMAL
- en: First we query the registry value ❶ that contains the data associated with the
    PEK. Next, we find the encrypted PEK in the fixed-attribute registry variable
    at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0x68</samp> ❷ (remember
    that this location could change). The first 32-bit integer represents the type
    of encryption used, either RC4 or AES128\. The second 32-bit integer is the length
    of the trailing encrypted PEK. We extract the data and then call an algorithm-specific
    decryption function ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the decryption functions. [Listing 10-25](chapter10.xhtml#Lis10-25)
    shows how to decrypt the password using RC4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-25: Decrypting the password encryption key using RC4'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating some helper functions for the decryption process, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-MD5Hash</samp>, which calculates
    an MD5 hash ❶. We then start the decryption ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">$Data</samp>
    parameter that we pass to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordEncryptionKeyRC4</samp>
    function is the value extracted from the fixed-attribute buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The function constructs a long binary string containing the first 16 bytes of
    the encrypted data (an *initialization vector*, used to randomize the encrypted
    data), along with two fixed strings and the system key ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The binary string is then hashed using the MD5 algorithm to generate a key for
    the RC4 encryption, which we use to decrypt the remaining 32 bytes of the encrypted
    data ❹. The first 16 decrypted bytes are the PEK, and the second 16 bytes are
    an MD5 hash used to verify that the decryption was correct. We check the hash
    value ❺ to make sure we’ve successfully decrypted the PEK. If the hash value is
    not correct, we’ll throw an exception to indicate the failure.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 10-26](chapter10.xhtml#Lis10-26), we define the functions for decrypting
    the PEK using AES.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-26: Decrypting the password encryption key using AES'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a function to decrypt an AES buffer with a specified key
    and initialization vector (IV) ❶. The decryption process uses AES in cipher block
    chaining (CBC) mode with PKCS7 padding. I recommend looking up how these modes
    function, but their exact details are unimportant for this discussion; just be
    aware that they must be set correctly or the decryption process will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Now we define the password decryption function. The key used for AES is the
    system key ❷, with the IV being the first 16 bytes of data after a short header
    ❸ and the encrypted data immediately following. The length of the data to decrypt
    is stored as a value in the header.
  prefs: []
  type: TYPE_NORMAL
- en: As with RC4, the encrypted data contains an encrypted hash value we can use
    to verify that the decryption succeeded. We decrypt the value ❹ and then generate
    the SHA256 hash of the PEK to verify it ❺. If the decryption and verification
    succeeded, we now have a decrypted PEK.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 10-27](chapter10.xhtml#Lis10-27), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordEncryptionKey</samp>
    function to decrypt the password key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-27: Testing the password encryption key decryption'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the actual value generated should look different on different systems.
    Also note that the PEK is always 16 bytes in size, regardless of the encryption
    algorithm used to store it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypting a Password Hash</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have the PEK, we can decrypt the password hashes we extracted from
    the user object in [Listing 10-22](chapter10.xhtml#Lis10-22). [Listing 10-28](chapter10.xhtml#Lis10-28)
    defines the function to decrypt the password hash.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-28: Decrypting a password hash'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordHash</samp>
    function takes as arguments the PEK we decrypted, the encrypted hash data, the
    RID of the user, and the type of hash. LM hashes have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, while NT hashes
    have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The hash data stores the type of encryption; as with the PEK, the supported
    encryption algorithms are RC4 and AES128\. Note that it’s possible for the PEK
    to be encrypted with RC4 and the password hash with AES, or vice versa. Allowing
    a mix of encryption types lets systems migrate old hash values from RC4 to AES
    when a user changes their password.
  prefs: []
  type: TYPE_NORMAL
- en: We call the algorithm-specific decryption function to decrypt the hash. Note
    that only the RC4 decryption function needs us to pass it the RID and type of
    hash; the AES128 decryption function doesn’t require those two values.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement the RC4 hash decryption first, in [Listing 10-29](chapter10.xhtml#Lis10-29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-29: Decrypting a password hash using RC4'
  prefs: []
  type: TYPE_NORMAL
- en: We first check the length of the data ❶. If it’s less than 20 bytes in size,
    we assume the hash isn’t present. For example, the LM hash is not stored by default
    on modern versions of Windows, so attempting to decrypt that hash will return
    an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming there is a hash to decrypt, we then need an IV string based on the
    type of hash being decrypted ❷. In addition to LM and NT hashes, the LSA can decrypt
    a few other hash types, such as the password history, which stores previous password
    hashes to prevent users from changing back to an old password.
  prefs: []
  type: TYPE_NORMAL
- en: We build a key by concatenating the PEK, the RID in its byte form, and the IV
    string and using it to generate an MD5 hash ❸. We then use this new key to finally
    decrypt the password hash ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting the password using AES is simpler than with RC4, as you can see in
    [Listing 10-30](chapter10.xhtml#Lis10-30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-30: Decrypting a password hash using AES'
  prefs: []
  type: TYPE_NORMAL
- en: The password contains the data length, which we use to determine if we need
    to return an empty buffer ❶. We can then extract the IV ❷ and the encrypted value
    from the buffer and decrypt the value using the PEK ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-31](chapter10.xhtml#Lis10-31) decrypts the LM and NT hashes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-31: Decrypting the LM and NT hashes'
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this example there is no LM hash, so the decryption process returns
    an empty array ❶. However, the NT hash decrypts to a 16-byte value ❷.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Deobfuscating the Password
    Hash</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We now have a decrypted password hash, but there is one final step we need to
    perform to retrieve the original hash. The password hash is still encrypted with
    the Data Encryption Standard (DES) algorithm. DES was the original obfuscation
    mechanism for hashes in the original version of NT before the introduction of
    the system key. All this RC4 and AES decryption merely got us back to where we
    started.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to generate the DES keys to decrypt the hash value ([Listing 10-32](chapter10.xhtml#Lis10-32)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-32: Generating the DES keys for the RID'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in decrypting the hash is to generate two 64-bit DES keys based
    on the value of the RID. In [Listing 10-32](chapter10.xhtml#Lis10-32), we unpack
    the RID into two 56-bit arrays as the base for the two keys. We then expand each
    56-bit array to 64 bits by taking each 7 bits of the array and calculating a parity
    bit for each byte. The parity bit is set in the least significant bit of each
    byte, to ensure that each byte has an odd number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: With the two keys, we can decrypt the hash fully. First we’ll need a few functions,
    which we define in [Listing 10-33](chapter10.xhtml#Lis10-33).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-33: Decrypting password hashes using DES'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a simple DES decryption function. The algorithm uses DES
    in electronic code book (ECB) mode with no padding. We then define a function
    to decrypt the hash. The first 8-byte block is decrypted with the first key, and
    the second with the second key. Following that, we concatenate the decrypted hash
    into a single 16-byte result.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can decrypt the password hash and compare it against the real value,
    as shown in [Listing 10-34](chapter10.xhtml#Lis10-34).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-34: Verifying the NT hash'
  prefs: []
  type: TYPE_NORMAL
- en: If the hash was correctly decrypted, we should expect it to match the MD4 hash
    of the user’s password. In this case, the user’s password was set to *adminpwd*
    (I know, not strong). The decrypted NT hash and the generated hash match exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at the SECURITY database, which stores the LSA policy. We won’t
    spend much time on this database, as we can directly extract most of its information
    using the domain policy remote service described earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting the SECURITY
    Database</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The LSA policy is stored in the SECURITY database registry key, which is located
    at *REGISTRY\MACHINE\SECURITY*. As with the SAM database registry key, only the
    *SYSTEM* user can access the key directly, but we can use the mapped drive provider
    from [Listing 10-21](chapter10.xhtml#Lis10-21) to inspect its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-35](chapter10.xhtml#Lis10-35) shows a few levels of the SECURITY
    database registry key. Run this command as an administrator.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-35: Listing the contents of the SECURITY database registry key'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss only a few of these registry keys. The *Cache* key ❶ contains
    a list of cached domain credentials that can be used to authenticate a user even
    if access to the domain controller is lost. We’ll cover the use of this key in
    [Chapter 12](chapter12.xhtml), when we discuss interactive authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The *SAM* key ❷ is a link to the full SAM database registry key whose contents
    we showed in [Listing 10-21](chapter10.xhtml#Lis10-21). It exists here for convenience.
    The *Policy\Accounts* key ❸ is used to store the account objects for the policy.
    The *Policy* key also contains other system policies and configuration; for example,
    *PolAdtEv* ❹ and *PolAdtLg* ❺ contain configurations related to the system’s audit
    policy, which we analyzed in [Chapter 9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The security descriptor that secures the policy object is found in the *Policy\SecDesc*
    key ❻. Each securable object in the policy has a similar key to persist the security
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *Policy\Secrets* key ❼ is used to store secret objects. We dig
    further into the children of the *Secrets* key in [Listing 10-36](chapter10.xhtml#Lis10-36).
    You’ll need to run these commands as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-36: Enumerating the children of the <samp class="SANS_Futura_Std_Book_11">SECURITY\Policy\Secrets</samp>
    key'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-36](chapter10.xhtml#Lis10-36) lists the subkeys of the *Secrets*
    key ❶. The name of each subkey is the string used when opening the secret via
    the domain policy remote service. For example, we can see the *DPAPI_SYSTEM* secret
    we accessed in [Listing 10-17](chapter10.xhtml#Lis10-17) in the output.'
  prefs: []
  type: TYPE_NORMAL
- en: When we inspect the values of that key ❷, we find its current and old values
    and timestamps, as well as the security descriptor for the secret object. The
    secret’s contents are stored as the default value in the key, so we can display
    it as hex ❸. You might notice that the value of the secret isn’t the same as the
    one we dumped via the domain policy remote service. As with the user object data,
    the LSA will try to obfuscate values in the registry to prevent trivial disclosure
    of the contents. The system key is used, but with a different algorithm; I won’t
    dig further into the details of this.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some examples to illustrate how you can use the various commands
    you saw in this chapter for security research or systems analysis purposes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RID Cycling</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In “Name Lookup and Mapping” on page 323, I mentioned an attack called RID cycling
    that uses the domain policy remote service to find the users and groups present
    on a computer without having access to the SAM remote service. In [Listing 10-37](chapter10.xhtml#Lis10-37),
    we perform the attack using some of the commands introduced in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-37: A simple RID cycling implementation'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the function to perform the RID cycling attack. We need four
    parameters ❶: the server that we want to enumerate, the domain in the server to
    enumerate, and minimum and maximum RID values to check. The lookup process can
    request only 1,000 SIDs at a time, so we set a default range within that limit,
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1499</samp>
    inclusive, which should cover the range of RIDs used for user accounts and groups.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we open the policy object and request <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access ❷. We need to look up the SID for the domain by using its simple name ❸.
    With the domain SID, we can create relative SIDs for each RID we want to brute-force
    and look up their names ❹. If the returned object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NameUse</samp>
    property is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Unknown</samp>,
    then the SID didn’t map to a username ❺. By checking this property, we can filter
    out invalid users from our enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we test this function on another system on our local domain network
    ❻. You need to be able to authenticate to the server to perform the attack. On
    a domain-joined system, this should be a given. However, if your machine is a
    stand-alone system, the attack might fail without authentication credentials.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forcing a User‘s
    Password Change</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the discussion of user objects in the SAM database, I mentioned that if a
    caller is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access on a user object they can force a change of the user’s password. [Listing
    10-38](chapter10.xhtml#Lis10-38) shows how to do this using the commands described
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-38: Force-changing a user’s password via the SAM remote service'
  prefs: []
  type: TYPE_NORMAL
- en: We first define a helper function that opens a user object on a specified server.
    We open the user domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    parameter and explicitly request the <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access right, which will generate an access denied error if it’s not granted.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a function that sets the password. We’ll read the password from
    the console, as it needs to be in the secure string format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Expired</samp>
    parameter marks the password as needing to be changed the next time the user authenticates.
    After reading the password from the console, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPassword</samp>
    function on the user object.
  prefs: []
  type: TYPE_NORMAL
- en: We can test the password setting function by running the script in [Listing
    10-39](chapter10.xhtml#Lis10-39) as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-39: Setting a user’s password on the current computer'
  prefs: []
  type: TYPE_NORMAL
- en: To be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access, you need to be an administrator on the target machine. In this case, we’re
    running as an administrator locally. If you want to change a remote user’s password,
    however, you’ll need to authenticate as an administrator on the remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting All Local
    User Hashes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In “Accessing the SAM Database Through the Registry” on page 325, we defined
    functions to decrypt a user’s password hash from the SAM database. To use those
    functions to decrypt the passwords for all local users automatically, run [Listing
    10-40](chapter10.xhtml#Lis10-40) as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-40: Decrypting the password hashes of all local users'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a function to decrypt a single password hash from a user’s
    registry key ❶. We select which hash to extract based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">LmHash</samp>
    parameter, which changes the index and the type for the RC4 key. We then call
    this function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-UserHashes</samp>
    function ❷, which extracts other information, such as the name of the user, and
    builds a custom object.
  prefs: []
  type: TYPE_NORMAL
- en: To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-UserHashes</samp>
    function, we first decrypt the password encryption key ❸, then enumerate the user
    accounts in the registry and pipe them through it ❹. We can see in the output
    that only two users have NT password hashes, and no user has an LM hash configured.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We started this chapter with a discussion of Windows domain authentication.
    We went through the various levels of complexity, starting with a local domain
    on a stand-alone computer and moving through a networked domain and a forest.
    Each level of complexity has an associated configuration that can be accessed
    to determine what users and/or groups are available within an authentication domain.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we examined various built-in PowerShell commands you can use
    to inspect the authentication configuration on the local system. For example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> command
    will list all registered users, as well as whether they’re enabled or not. We
    also saw how to add new users and groups.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the LSA policy, which is used to configure various security
    properties (such as the audit policy described in [Chapter 9](chapter9.xhtml)),
    what privileges a user is assigned, and what types of authentication the user
    can perform.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored how to access the configuration internally, whether locally
    or on a remote system, using the SAM remote service and domain policy service
    network protocols. As you saw, what we normally consider a group is referred to
    as an alias internally.
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter with a deep dive into how the authentication configuration
    is stored inside the registry and how you can perform a basic inspection of it.
    We also looked at an example of how to extract a user’s hashed password from the
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a similar look at how the authentication configuration
    is stored in an Active Directory configuration, which is significantly more complex
    than the local configuration case.
  prefs: []
  type: TYPE_NORMAL
