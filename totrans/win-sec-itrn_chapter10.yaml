- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    AUTHENTICATION</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    身份验证</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: Before you can interact with a Windows system, you need to complete its complex
    authentication process, which converts a set of credentials, such as a username
    and a password, into a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object that represents the user’s identity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你与 Windows 系统交互之前，你需要完成其复杂的身份验证过程，该过程将一组凭证（如用户名和密码）转换为一个表示用户身份的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象。
- en: Authentication is too big a topic to cover in a single chapter; therefore, I’ve
    split it into three parts. This chapter and the next one will provide an overview
    of Windows authentication, how the operating system stores a user’s configuration,
    and how to inspect that configuration. In the chapters that follow, we’ll discuss
    *interactive authentication*, the mechanism used to interact directly with a Windows
    system, such as via the GUI. The book’s final chapters cover *network authentication*,
    a type of authentication that allows users who are not physically connected to
    a system to supply credentials and generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object that represents their identity. For example, if you connect to a Windows
    system using its file-sharing network connection, you’ll use network authentication
    under the hood to provide the identity needed to access file shares.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是一个过于庞大的话题，无法在一章内全面讲解；因此，我将其分为三部分。本章和下一章将概述 Windows 身份验证、操作系统如何存储用户配置，以及如何检查这些配置。在接下来的章节中，我们将讨论
    *交互式身份验证*，即与 Windows 系统直接交互的机制，如通过图形用户界面（GUI）。本书的最后几章将介绍 *网络身份验证*，这是一种允许未物理连接到系统的用户提供凭证并生成一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> 对象来表示其身份的身份验证类型。例如，如果你通过文件共享网络连接到
    Windows 系统，你将在后台使用网络身份验证来提供访问文件共享所需的身份。
- en: We’ll begin this chapter with an overview of domain authentication. Then we’ll
    take a deep dive into how the authentication configuration is stored locally,
    as well as how we can access that configuration using PowerShell. We’ll finish
    with an overview of how Windows stores the local configuration internally and
    how you can use your knowledge of it to extract a user’s hashed password.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从域身份验证概述开始。接着，我们将深入探讨身份验证配置如何存储在本地，以及如何使用 PowerShell 访问这些配置。最后，我们将概述 Windows
    如何在内部存储本地配置，并介绍如何利用这些知识提取用户的哈希密码。
- en: To make the most of these authentication chapters, I recommend setting up domain
    network virtual machines, as described in [Appendix A](appendix-A.xhtml). You
    can still run many of the examples without setting up the domain network, but
    any command that requires a network domain won’t function without it. Also note
    that the actual output of certain commands might change depending on how you set
    up the virtual machines, but the general concepts should stay the same.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大程度地利用这些身份验证章节，我建议按照 [附录 A](appendix-A.xhtml) 中的描述设置域网络虚拟机。你仍然可以在没有设置域网络的情况下运行许多示例，但任何需要网络域的命令在没有设置的情况下是无法工作的。还需注意，根据虚拟机的设置，某些命令的实际输出可能会有所不同，但一般概念应该保持不变。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Domain Authentication</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">域身份验证</samp>
- en: For the purposes of authentication, Windows sorts its users and groups into
    domains. A *domain* provides a policy for how users and groups can access resources;
    it also provides storage for configuration information such as passwords. The
    architecture of Windows domains is complex enough to require its own book. However,
    you should familiarize yourself with some basic concepts before we dig deep into
    the authentication configuration.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在身份验证过程中，Windows 将其用户和组划分为域。*域* 提供了用户和组如何访问资源的策略；它还提供了用于存储配置信息（如密码）的存储空间。Windows
    域的架构足够复杂，足以需要一本专门的书来讲解。然而，在我们深入探讨身份验证配置之前，你应该先了解一些基本概念。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Authentication</samp>
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">本地身份验证</samp>
- en: The simplest domain in Windows lives on a stand-alone computer, as shown in
    [Figure 10-1](chapter10.xhtml#fig10-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中最简单的域存在于独立计算机上，如 [图 10-1](chapter10.xhtml#fig10-1) 所示。
- en: '![](../images/Figure10-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: A local domain
    on a stand-alone computer</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-1：独立计算机上的本地域</samp>
- en: 'The users and groups on the computer can access only local resources. A local
    domain has a *local policy* that defines the application and security configuration
    on the computer. The domain is assigned the same name as the computer: *GRAPHITE*,
    in this example. The local domain is the only type you’ll be able to inspect if
    you don’t have an enterprise network configured.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机上的用户和组只能访问本地资源。一个本地域有一个*本地策略*，定义了计算机上的应用程序和安全配置。本地域被分配与计算机相同的名称：本例中为*GRAPHITE*。如果没有配置企业网络，本地域是你唯一能够检查的类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enterprise Network
    Domains</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">企业网络域</samp>
- en: '[Figure 10-2](chapter10.xhtml#fig10-2) shows the next level of complexity,
    an enterprise network domain.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-2](chapter10.xhtml#fig10-2) 显示了更高层次的复杂性，即企业网络域。'
- en: '![](../images/Figure10-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: A single enterprise
    network domain</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-2：单一企业网络域</samp>
- en: Instead of requiring each individual workstation or server to maintain its own
    users and groups, an enterprise network domain maintains these centrally on a
    *domain controller*. It stores the user configuration in a database on the domain
    controller called *Active Directory*. When a user wants to authenticate to the
    domain, the computer passes the authentication request to the domain controller,
    which knows how to use the user configuration to verify the request. We’ll cover
    exactly how domain authentication requests are handled in [Chapters 12](chapter12.xhtml)
    and [14](chapter14.xhtml), when we discuss interactive authentication and Kerberos.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 企业网络域通过一个*域控制器*集中管理所有工作站或服务器的用户和组，而不是让每个工作站或服务器自己维护这些信息。它将用户配置存储在域控制器上的一个名为*Active
    Directory*的数据库中。当用户想要对域进行认证时，计算机会将认证请求传递给域控制器，域控制器知道如何使用用户配置来验证该请求。我们将在[第12章](chapter12.xhtml)和[第14章](chapter14.xhtml)中讨论交互式认证和Kerberos时，详细介绍域认证请求的处理过程。
- en: 'Multiple domain controllers can manage a single domain; the domain controllers
    use a special replication protocol to duplicate the configuration so that they’re
    always up to date. Having multiple domain controllers ensures redundancy: if one
    domain controller fails, another can provide authentication services to the computers
    and users in the domain.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 多个域控制器可以管理一个域；域控制器使用一种特殊的复制协议来复制配置，以确保它们始终保持最新。拥有多个域控制器可以确保冗余：如果一个域控制器发生故障，另一个可以为域中的计算机和用户提供认证服务。
- en: Each domain controller also maintains a *group policy*, which computers in the
    network can query to automatically configure themselves using a common domain
    policy. This group policy can override the existing local policy and security
    configuration, making it easier to manage a large enterprise network. Each computer
    has a special user account that allows them to authenticate to the domain. This
    allows the computer to access the group policy configuration without a domain
    user being authenticated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个域控制器还维护一个*组策略*，网络中的计算机可以查询该策略，以便使用公共域策略自动配置自身。该组策略可以覆盖现有的本地策略和安全配置，从而更容易管理大型企业网络。每台计算机都有一个特殊的用户帐户，使其能够进行域认证。这样，计算机就能访问组策略配置，而无需域用户进行身份验证。
- en: Since Windows 2000, the name of the domain has been a DNS name; in [Figure 10-2](chapter10.xhtml#fig10-2),
    it’s *mineral.local*. For compatibility with older versions of Windows or applications
    that don’t understand DNS names, the operating system also makes a simple domain
    name available. For example, the simple name in this case might be *MINERAL*,
    although the administrator is free to select their own simple name when setting
    up the domain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自Windows 2000以来，域名已成为DNS名称；在[图10-2](chapter10.xhtml#fig10-2)中，它是*mineral.local*。为了与旧版Windows或不理解DNS名称的应用程序兼容，操作系统还提供了一个简单的域名。例如，在这种情况下，简单的名称可能是*MINERAL*，尽管管理员在设置域时可以自由选择自己的简单名称。
- en: Note that the local domain on an individual computer will still exist, even
    if there is a configured enterprise network domain. A user can always authenticate
    to their computer (the local domain) with credentials specific to that computer,
    unless an administrator disables the option by changing the local policy on the
    system. However, even though the computer itself is joined to a domain, those
    local credentials won’t work for accessing remote resources in the enterprise
    network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使配置了企业网络域，单台计算机上的本地域仍然存在。用户始终可以使用特定于该计算机的凭证对其计算机（本地域）进行身份验证，除非管理员通过更改系统上的本地策略禁用此选项。然而，即使计算机本身已加入某个域，这些本地凭证也无法用于访问企业网络中的远程资源。
- en: The local groups also determine the access granted to a domain user when they
    authenticate. For example, if a domain user is in the local *Administrators* group,
    then they’ll be an administrator for the local computer. However, that access
    won’t extend beyond that single computer. The fact that a user is a local administrator
    on one computer doesn’t mean they will get administrator access on another computer
    on the network.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本地组还决定了域用户在身份验证时获得的访问权限。例如，如果域用户属于本地*管理员*组，那么他们将成为本地计算机的管理员。然而，这种访问权限不会扩展到其他计算机。用户在一台计算机上是本地管理员，并不意味着他们可以在网络中的另一台计算机上获得管理员访问权限。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Domain Forests</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">域林</samp>
- en: 'The next level of complexity is the *domain forest*. In this context, a *forest*
    refers to a group of related domains. The domains might share a common configuration
    or organizational structure. In [Figure 10-3](chapter10.xhtml#fig10-3), three
    domains make up the forest: *mineral.local*, which acts as the forest’s root domain,
    and two child domains, *engineering.mineral.local* and *sales.mineral.local*.
    Each domain maintains its own users, computers, and group policies.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个复杂度级别是*域林*。在这个上下文中，*域林*指的是一组相关的域。这些域可能共享相同的配置或组织结构。在[图 10-3](chapter10.xhtml#fig10-3)中，三个域组成了这个域林：*mineral.local*，作为域林的根域，以及两个子域，*engineering.mineral.local*
    和 *sales.mineral.local*。每个域都维护自己的用户、计算机和组策略。
- en: '![](../images/Figure10-3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: A domain forest</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-3：域林</samp>
- en: From a security perspective, some of the most important features in a forest
    are its *trust relationships*. A domain can be configured to trust another domain’s
    users and groups. This trust can be *one-way*, meaning a domain trusts another’s
    users, but not vice versa, or it can be *bidirectional*, meaning each domain trusts
    the other’s users. For example, in [Figure 10-3](chapter10.xhtml#fig10-3), there
    is bidirectional trust between the root domain and the *engineering.mineral.local*
    domain. This means that users in either domain can freely access resources in
    the other. There is also bidirectional trust between *sales.mineral.local* and
    the root. By default, when a new domain is added to an existing forest, a bidirectional
    trust relationship is established between the parent and child domains.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，域林中的一些最重要特性是它的*信任关系*。一个域可以被配置为信任另一个域的用户和组。这个信任关系可以是*单向*的，即一个域信任另一个域的用户，但反过来则不行；也可以是*双向*的，即两个域都信任对方的用户。例如，在[图
    10-3](chapter10.xhtml#fig10-3)中，根域与*engineering.mineral.local*域之间存在双向信任关系。这意味着两个域中的用户可以自由地访问对方的资源。*sales.mineral.local*和根域之间也有双向信任关系。默认情况下，当一个新域被添加到现有域林时，父域和子域之间会建立双向信任关系。
- en: Note that there’s no explicit trust relationship between the *engineering.mineral.local*
    and *sales.mineral.local* domains. Instead, the two domains have a bidirectional
    *transitive trust* relationship; as both domains have a bidirectional trust relationship
    with their common parent, the parent allows users in engineering to access resources
    in sales, and vice versa. We’ll discuss how trust relationships are implemented
    in [Chapter 14](chapter14.xhtml).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*engineering.mineral.local*和*sales.mineral.local*之间没有显式的信任关系。相反，这两个域有一个双向*传递信任*关系；由于这两个域与它们的共同父域之间都有双向信任关系，父域允许工程域的用户访问销售域的资源，反之亦然。我们将在[第
    14 章](chapter14.xhtml)中讨论信任关系是如何实现的。
- en: The forest also contains a shared *global catalog*. This catalog is a subset
    of the information stored in all the Active Directory databases in the forest.
    It allows users in one domain or subtree to find resources in the forest without
    having to go to each domain separately.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 林中还包含一个共享的 *全局目录*。该目录是存储在林中所有 Active Directory 数据库中的信息的一个子集。它允许一个域或子树中的用户在不需要分别访问每个域的情况下查找林中的资源。
- en: You can combine multiple forests by establishing inter-forest trust relationships,
    as shown in [Figure 10-4](chapter10.xhtml#fig10-4). These trust relationships
    can also be one-way or bidirectional, and they can be established between entire
    forests or between individual domains as needed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过建立林之间的信任关系来组合多个林，如[图10-4](chapter10.xhtml#fig10-4)所示。这些信任关系也可以是单向或双向的，可以根据需要在整个林之间或在单个域之间建立。
- en: '![](../images/Figure10-4.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: Multiple forests
    with trust relationships</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-4：具有信任关系的多个林</samp>
- en: In general, inter-forest trust relationships are not transitive. So, while in
    [Figure 10-4](chapter10.xhtml#fig10-4) *vegetable.local* trusts *mineral.local*,
    it won’t automatically trust anything in the *sales.animal.local* domain even
    though there’s a bidirectional trust relationship between *sales.animal.local*
    and *sales.mineral.local*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，林之间的信任关系不是传递性的。因此，尽管在[图10-4](chapter10.xhtml#fig10-4)中，*vegetable.local*
    信任 *mineral.local*，它不会自动信任 *sales.animal.local* 域中的任何内容，即使 *sales.animal.local*
    和 *sales.mineral.local* 之间存在双向信任关系。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Managing trust relationships can be complex, especially as the numbers of
    domains and forests grow. It’s possible to inadvertently create trust relationships
    that a malicious user could exploit to compromise an enterprise network. I won’t
    discuss how to analyze these relationships to find security issues; however, the
    security tool BloodHound (*[https://<wbr>github<wbr>.com<wbr>/SpecterOps<wbr>/BloodHound](https://github.com/SpecterOps/BloodHound)*)
    can help with this.*'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*管理信任关系可能非常复杂，尤其是在域和林的数量不断增长时。可能会不小心创建出被恶意用户利用的信任关系，从而危害企业网络的安全。我不会讨论如何分析这些关系以发现安全问题；然而，安全工具
    BloodHound (*[https://<wbr>github<wbr>.com<wbr>/SpecterOps<wbr>/BloodHound](https://github.com/SpecterOps/BloodHound)*)
    可以帮助识别这些问题。*'
- en: The next few chapters will focus on the configuration of a local domain and
    a simple forest. If you want to know about more complex domain relationships,
    the Microsoft technical documentation is a good resource. For now, let’s continue
    by detailing how a local domain stores authentication configurations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个章节将重点介绍本地域和简单林的配置。如果你想了解更多复杂的域关系，微软的技术文档是一个很好的资源。现在，让我们继续详细讲解本地域如何存储身份验证配置。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Local Domain Configuration</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">本地域配置</samp>
- en: A user must authenticate to the Windows system before a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object can be created for them, and to authenticate to the system, the user must
    provide proof of their identity. This might take the form of a username and password,
    a smart card, or biometrics, such as a fingerprint.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须先进行身份验证才能在 Windows 系统中为其创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    对象，并且为了进行身份验证，用户必须提供身份的证明。这可能以用户名和密码、智能卡或生物识别信息（如指纹）的形式出现。
- en: The system must store these credentials securely so that they can be used to
    authenticate the user but are not publicly disclosed. For the local domain configuration,
    this information is maintained by the *Local Security Authority (LSA)*, which
    runs in the LSASS process. [Figure 10-5](chapter10.xhtml#fig10-5) gives an overview
    of the local domain configuration databases maintained by the LSA.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 系统必须安全地存储这些凭证，以便它们可以用来验证用户身份，但不会被公开披露。对于本地域配置，这些信息由 *本地安全机构 (LSA)* 维护，LSA 运行在
    LSASS 进程中。[图10-5](chapter10.xhtml#fig10-5) 给出了 LSA 维护的本地域配置数据库的概览。
- en: '![](../images/Figure10-5.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure10-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: Local domain configuration
    databases</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-5：本地域配置数据库</samp>
- en: 'The LSA exposes various APIs that an application such as PowerShell can call.
    These APIs access two configuration databases: the user database and the LSA policy
    database. Let’s go through what information is stored in each database and how
    they can be accessed from PowerShell.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LSA 提供了各种 API，像 PowerShell 这样的应用程序可以调用这些 API。这些 API 访问两个配置数据库：用户数据库和 LSA 策略数据库。让我们逐一了解每个数据库中存储的信息，以及如何从
    PowerShell 访问它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The User Database</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">用户数据库</samp>
- en: The *user database* stores two containers of information for the purposes of
    local authentication. One container holds local usernames, their SIDs, and passwords.
    The other holds local group names, their SIDs, and user membership. We’ll look
    at each in turn.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户数据库* 存储了两个信息容器，用于本地身份验证。一个容器保存本地用户名、它们的 SID 和密码；另一个容器保存本地组名、它们的 SID 和用户成员资格。我们将依次查看每个容器。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inspecting Local User Accounts</samp>
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">检查本地用户帐户</samp>
- en: You can inspect the local user accounts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    command, which is built into PowerShell ([Listing 10-1](chapter10.xhtml#Lis10-1)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置于 PowerShell 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    命令检查本地用户帐户（见 [清单 10-1](chapter10.xhtml#Lis10-1)）。
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: Displaying local user accounts using the Get-LocalUser command'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-1：使用 Get-LocalUser 命令显示本地用户帐户
- en: This command lists the names and SIDs of all the local users on the device,
    and indicates whether each user is enabled. If a user is not enabled, the LSA
    won’t allow the user to authenticate, even if they provide the correct password.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令列出设备上所有本地用户的名称和 SID，并指示每个用户是否启用。如果用户未启用，即使他们提供了正确的密码，LSA 也不会允许用户进行身份验证。
- en: You’ll notice that all the SIDs have a common prefix; only the last RID changes.
    This common prefix is the *machine SID*, and it’s randomly generated when Windows
    is installed. Because it’s generated randomly, each machine should have a unique
    one. You can get the machine SID by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    and specifying the name of the local computer, as shown in [Listing 10-2](chapter10.xhtml#Lis10-2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到所有的 SID 都有一个共同的前缀；只有最后的 RID 会改变。这个共同前缀就是 *机器 SID*，它是在安装 Windows 时随机生成的。由于它是随机生成的，每台机器应该有一个唯一的
    SID。你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> 命令，并指定本地计算机的名称来获取机器
    SID，正如 [清单 10-2](chapter10.xhtml#Lis10-2) 中所示。
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-2: Querying the machine SID'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-2：查询机器 SID
- en: There is no way to extract a local user’s password using a public API. In any
    case, by default, Windows doesn’t store the actual password; instead, it stores
    an MD4 hash of the password, commonly called the *NT hash*. When a user authenticates,
    they provide the password to the LSA, which hashes it using the same MD4 hash
    algorithm and compares it against the value in the user database. If they match,
    the LSA assumes that the user knew the password, and the authentication is verified.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 没有方法可以通过公开的 API 提取本地用户的密码。无论如何，默认情况下，Windows 并不存储实际的密码；相反，它存储的是密码的 MD4 哈希值，通常称为
    *NT 哈希*。当用户进行身份验证时，他们会将密码提供给 LSA，LSA 使用相同的 MD4 哈希算法对密码进行哈希处理，并与用户数据库中的值进行比较。如果匹配，LSA
    就认为用户知道密码，身份验证便通过。
- en: You might be concerned that the use of an obsolete message digest algorithm
    (MD4) for the password hash is insecure—and you’d be right. Having access to the
    NT hashes is useful, because you might be able to crack the passwords to get the
    original text versions. You can also use a technique called *pass-the-hash* to
    perform remote network authentication without needing the original password.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会担心使用过时的消息摘要算法（MD4）对密码进行哈希处理是不安全的——你是对的。获取 NT 哈希值很有用，因为你可能能够破解密码，从而获得原始的文本密码。你还可以使用一种叫做
    *pass-the-hash* 的技术，在不需要原始密码的情况下执行远程网络身份验证。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Windows used to store a separate* LAN Manager (LM) hash *along with the NT
    hash. Since Windows Vista, this is disabled by default. The LM hash is extremely
    weak; for example, the password from which the hash is derived can’t be longer
    than 14 uppercase characters. Cracking an LM hash password is significantly simpler
    than cracking an NT hash, which is also weak.*'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Windows 曾经将一个单独的* LAN Manager (LM) 哈希值 *与 NT 哈希值一起存储。自 Windows Vista 以来，这个功能默认是禁用的。LM
    哈希值极其脆弱；例如，从中派生出的密码不能超过 14 个大写字母。破解 LM 哈希密码比破解 NT 哈希密码要简单得多，后者虽然也很弱。*'
- en: You can create a new local user using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp>
    command, as demonstrated in [Listing 10-3](chapter10.xhtml#Lis10-3). You’ll need
    to provide a username and password for the user. You’ll also need to run this
    command as an administrator; otherwise, it would be easy to gain additional privileges
    on the local system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp> 命令创建一个新的本地用户，正如
    [列表 10-3](chapter10.xhtml#Lis10-3) 中所演示的那样。你需要为用户提供用户名和密码。此外，你还需要以管理员身份运行此命令；否则，容易在本地系统上获得额外的权限。
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-3: Creating a new local user'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-3：创建一个新的本地用户
- en: To create a new local user, first we must get the user’s password ❶. This password
    must be a secure string, so we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp>
    parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp>
    command. We then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp>
    command to create the user, passing it the name of the user and the secure password
    ❷. If you don’t see an error returned, the creation succeeded.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的本地用户，首先我们必须获取用户的密码 ❶。这个密码必须是安全字符串，因此我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">AsSecureString</samp>
    参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Read-Host</samp> 命令。然后，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalUser</samp> 命令来创建用户，传递用户名和安全密码
    ❷。如果没有返回错误，则表示创建成功。
- en: Now that we’ve created the user, we can query the SID that the LSA assigned
    to the new user. We do this by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    command and passing it the full name for the user, including the local computer
    name ❸. You’ll notice that the SID consists of the machine SID and the incrementing
    final RID. In this case, the next RID is <samp class="SANS_TheSansMonoCd_W5Regular_11">1003</samp>,
    but it could be anything, depending on what other users or groups have been created
    locally.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用户，可以查询 LSA 为新用户分配的 SID。我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    命令，并传递用户的完整名称，包括本地计算机名 ❸ 来实现。你会注意到，SID 由机器 SID 和递增的最终 RID 组成。在这种情况下，下一个 RID 是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1003</samp>，但它可能是任何值，这取决于其他用户或组是否已经在本地创建。
- en: 'To delete the user created in [Listing 10-3](chapter10.xhtml#Lis10-3) from
    the local system, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalUser</samp>
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要从本地系统中删除在 [列表 10-3](chapter10.xhtml#Lis10-3) 中创建的用户，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalUser</samp>
    命令：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that this command only removes the account; the deletion doesn’t guarantee
    that any resources the user might have created will be removed. For this reason,
    the LSA should never reuse a RID: that might allow a new user access to resources
    for a previous user account that was deleted.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令只会删除账户；删除操作并不能保证删除用户可能创建的任何资源。因此，LSA 不应重复使用 RID：否则，可能会允许新用户访问已删除的先前用户账户的资源。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inspecting Local Groups</samp>
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">检查本地组</samp>
- en: You can inspect local groups in a manner similar to inspecting users, by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command
    ([Listing 10-4](chapter10.xhtml#Lis10-4)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像检查用户一样检查本地组，方法是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    命令（[列表 10-4](chapter10.xhtml#Lis10-4)）。
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-4: Displaying local groups using the Get-LocalGroup command'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-4：使用 Get-LocalGroup 命令显示本地组
- en: You’ll notice that there are two types of SIDs in the list. The first group,
    *Awesome Users*, has a SID prefixed with the machine SID. This is a locally defined
    group. The rest of the groups have a different prefix. As we saw in [Chapter 5](chapter5.xhtml),
    this is the domain SID for the *BUILTIN* domain. These groups, such as *BUILTIN\Administrators*,
    are created by default along with the user database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到列表中有两种类型的SID。第一个组，*Awesome Users*，其SID前缀为机器SID。这是一个本地定义的组。其余的组有不同的前缀。正如我们在[第
    5 章](chapter5.xhtml)中看到的，这是*BUILTIN*域的域SID。这些组，如*BUILTIN\Administrators*，是与用户数据库一起默认创建的。
- en: Each local group in the user database has a list of members, which can be users
    or other groups. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroupMember</samp>
    command to get the list of group members, as shown in [Listing 10-5](chapter10.xhtml#Lis10-5).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个本地组在用户数据库中都有一个成员列表，成员可以是用户或其他组。我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroupMember</samp>命令来获取组成员列表，如[示例
    10-5](chapter10.xhtml#Lis10-5)所示。
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-5: Displaying local group members for the <samp class="SANS_Futura_Std_Book_11">Awesome
    Users</samp> group'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-5：显示<sup class="SANS_Futura_Std_Book_11">Awesome Users</sup>组的本地组成员
- en: '[Listing 10-5](chapter10.xhtml#Lis10-5) shows three columns for each member
    of the *Awesome Users* group. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp>
    column represents the type of entry (in this case, either <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp>). If a group has
    been added as an entry, all members of that group will also be members of the
    enclosing group. Therefore, this output indicates that all members of the *INTERACTIVE*
    group are also members of the *Awesome Users* group.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-5](chapter10.xhtml#Lis10-5)显示了*Awesome Users*组的每个成员的三列信息。<samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectClass</samp>列表示条目的类型（在此情况下，要么是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">User</samp>，要么是<samp class="SANS_TheSansMonoCd_W5Regular_11">Group</samp>）。如果一个组被添加为条目，该组的所有成员也将成为封闭组的成员。因此，输出结果表明，*INTERACTIVE*组的所有成员也都是*Awesome
    Users*组的成员。'
- en: '[Listing 10-6](chapter10.xhtml#Lis10-6) shows how to add a new group and a
    new group member, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalGroup</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp>
    commands. You’ll need to run these commands as an administrator.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-6](chapter10.xhtml#Lis10-6)展示了如何使用<samp class="SANS_TheSansMonoCd_W5Regular_11">New-LocalGroup</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp>命令添加一个新组和新成员。你需要以管理员身份运行这些命令。'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 10-6: Adding a new local group and group member'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-6：添加一个新的本地组和组成员
- en: We start by adding a new local group, specifying the group’s name ❶. As with
    a user, we can query for the group’s SID using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    command ❷.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个新的本地组，并指定该组的名称❶。与用户一样，我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>命令查询该组的SID❷。
- en: To add a new member to the group, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp>
    command, specifying the group and the members we want to add ❸. Querying the group
    membership shows that the user was added successfully ❹. Note that the user won’t
    be granted access to the additional group until the next time they successfully
    authenticate; that is, the group won’t be automatically added to existing tokens
    for that user.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要向该组添加新成员，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Add-LocalGroupMember</samp>命令，指定要添加的组和成员❸。查询组成员信息显示用户已成功添加❹。请注意，用户在下次成功认证之前不会被授予对附加组的访问权限；也就是说，组不会自动添加到该用户现有的令牌中。
- en: 'To remove the local group added in [Listing 10-6](chapter10.xhtml#Lis10-6),
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalGroup</samp>
    command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除[示例 10-6](chapter10.xhtml#Lis10-6)中添加的本地组，请使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-LocalGroup</samp>命令：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s all we’ll say about the user database for now. Let’s turn to the other
    database maintained by the LSA: the policy database.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用户数据库的内容就讲到这里。接下来，我们来看看LSA维护的另一个数据库：策略数据库。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The LSA Policy Database</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">LSA 策略数据库</samp>
- en: The second database the LSA maintains is the LSA policy database, which stores
    account rights and additional related information, such as the system audit policy
    we covered in [Chapter 9](chapter9.xhtml) and arbitrary secret objects used to
    protect various system services and credentials. We’ll cover the account rights
    in this section and secrets later in this chapter, when we discuss remote access
    to the LSA policy database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: LSA 维护的第二个数据库是 LSA 策略数据库，它存储了帐户权限和其他相关信息，例如我们在[第 9 章](chapter9.xhtml)中讨论的系统审计策略以及用于保护各种系统服务和凭据的任意机密对象。本节将介绍帐户权限，机密信息将在本章稍后讨论，当我们讨论如何远程访问
    LSA 策略数据库时。
- en: '*Account rights* define what privileges a user’s token will be assigned when
    they authenticate, as well as what mechanisms the user can use to authenticate
    (logon rights). Like local groups, they contain a list of member users and groups.
    We can inspect the assigned account rights using the PowerShell module’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp> command, as
    shown in [Listing 10-7](chapter10.xhtml#Lis10-7).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*帐户权限* 定义了用户身份验证时会分配给用户令牌的权限，以及用户可以使用哪些机制进行身份验证（登录权限）。像本地组一样，它们包含成员用户和组的列表。我们可以使用
    PowerShell 模块中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    命令检查已分配的帐户权限，如[清单 10-7](chapter10.xhtml#Lis10-7)所示。'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-7: Displaying the privilege account rights for the local system'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-7：显示本地系统的权限帐户权限
- en: In this case, we list only the privileges by specifying the appropriate <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value. In the output, we can
    see the name of each privilege (these are described in [Chapter 4](chapter4.xhtml)),
    as well as a column containing the users or groups that are assigned the privilege.
    You’ll need to run the command as an administrator to see the list of SIDs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们仅通过指定适当的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    值列出权限。在输出中，我们可以看到每个权限的名称（这些在[第 4 章](chapter4.xhtml)中有描述），以及包含被分配该权限的用户或组的列。你需要以管理员身份运行该命令才能看到
    SID 列表。
- en: You’ll notice that some of these entries are empty. This doesn’t necessarily
    mean that no user or group is assigned this privilege, however; for example, when
    a *SYSTEM* user token is created privileges such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    are automatically assigned, without reference to the account rights assignment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这些条目中有些是空的。但这并不一定意味着没有用户或组被分配该权限；例如，当创建*SYSTEM* 用户令牌时，权限如 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    会自动分配，而无需参考帐户权限分配。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you assign certain high-level privileges to a user (such as SeTcbPrivilege,
    which permits security controls to be bypassed), it will make the user equivalent
    to an administrator even if they’re not in the* Administrators *group. We’ll see
    a case in which this is important when we discuss token creation in [Chapter 12](chapter12.xhtml).*'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果你为用户分配某些高级权限（例如 SeTcbPrivilege，该权限允许绕过安全控制），即使该用户不在* 管理员 *组中，也会使该用户等同于管理员。我们将在讨论[第
    12 章](chapter12.xhtml)中的令牌创建时看到这种情况的重要性。*'
- en: We can list the logon account rights using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    command with a different <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    value. Run the command in [Listing 10-8](chapter10.xhtml#Lis10-8) as an administrator.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    命令，指定不同的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> 值来列出登录帐户权限。请以管理员身份运行[清单
    10-8](chapter10.xhtml#Lis10-8)中的命令。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 10-8: Displaying the logon account rights for the local system'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-8：显示本地系统的登录帐户权限
- en: Reading the names in the first column, you might think they look like privileges;
    however, they’re not. The logon rights represent the authentication roles a user
    or group can perform. Each one has both an allow and a deny form, as described
    in [Table 10-1](chapter10.xhtml#tab10-1).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读第一列中的名称，你可能会认为它们看起来像权限；然而，它们并不是。登录权限表示用户或组可以执行的身份验证角色。每个权限都有允许和拒绝的形式，如[表
    10-1](chapter10.xhtml#tab10-1)中所描述的那样。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">Account
    Logon Rights</samp>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 10-1：</samp> <samp class="SANS_Futura_Std_Book_11">帐户登录权限</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Allow right</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Deny
    right</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">允许权限</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">拒绝权限</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate for an interactive session.</samp>
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyInteractiveLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">进行交互式会话的身份验证。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate from the network.</samp>
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyNetworkLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">通过网络进行身份验证。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp> | <samp
    class="SANS_Futura_Std_Book_11">Authenticate to the local system without an interactive
    console session.</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBatchLogonRight</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyBatchLogonRight</samp> | <samp
    class="SANS_Futura_Std_Book_11">在没有交互式控制台会话的情况下对本地系统进行身份验证。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate for a service process.</samp>
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeServiceLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyServiceLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">为服务进程进行身份验证。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">Authenticate to interact with a remote
    desktop.</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDenyRemoteInteractiveLogonRight</samp>
    | <samp class="SANS_Futura_Std_Book_11">通过远程桌面进行身份验证。</samp> |'
- en: If a user or group is not assigned a logon right, they won’t be granted permission
    to authenticate in that role. For example, if a user who is not granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp> attempts
    to authenticate to the physical console, they’ll be denied access. However, if
    they are granted <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>,
    the user might still be able to connect to the Windows system over the network
    to access a file share and authenticate successfully. The deny rights are inspected
    before the allow rights, so you can allow a general group, such as *Users*, and
    then deny specific accounts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户或组没有被分配登录权限，则不会被允许在该角色中进行身份验证。例如，如果一个没有被授予 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeInteractiveLogonRight</samp>
    权限的用户尝试在物理控制台上进行身份验证，他们将被拒绝访问。然而，如果该用户被授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">SeNetworkLogonRight</samp>
    权限，用户可能仍然能够通过网络连接到 Windows 系统，以访问文件共享并成功进行身份验证。拒绝权限会在允许权限之前进行检查，因此你可以先允许一个通用组，比如
    *Users*，然后再拒绝特定账户。
- en: The PowerShell module also provides commands to modify the user rights assignment.
    You can add a SID to an account right using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp>
    command. To remove a SID, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp>
    command. We’ll see examples of how to use these commands in [Chapter 12](chapter12.xhtml).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 模块还提供了修改用户权限分配的命令。你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtAccountRight</samp>
    命令向账户权限中添加 SID。要移除 SID，请使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtAccountRight</samp>
    命令。我们将在[第12章](chapter12.xhtml)中看到如何使用这些命令的示例。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Remote LSA Services</samp>
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">远程 LSA 服务</samp>
- en: The previous section demonstrated communicating with the LSA on the local system
    and extracting information from its configuration databases in PowerShell using
    commands such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>. I
    previously described the mechanisms used to access this information as a single
    set of local APIs, but it’s actually a lot more complicated than that. [Figure
    10-6](chapter10.xhtml#fig10-6) shows how the two local domain configuration databases
    are exposed to an application such as PowerShell.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The LSA’s remote
    services and objects</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    command, which calls a Win32 API to enumerate the local users. The user database
    is stored in the *security account manager (SAM) database* and is accessed using
    the *SAM remote service*. To enumerate the list of users in the local SAM database,
    an application must first request access to a domain object. From that domain
    object, the API can query the user list, or different APIs could enumerate local
    groups or aliases instead.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the LSA policy database is stored in the SECURITY database,
    and to access it, we use the *domain policy remote service*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'While the network protocols used to access the SAM and SECURITY databases are
    different, they share a couple of common idioms:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The client initially requests a connection to the database.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once connected, the client can request access to individual objects, such as
    domains or users.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database and objects have configured security descriptors used to control
    access.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PowerShell commands interact with the local LSA, but the same network protocol
    could be used to query the LSA on another machine in an enterprise network. To
    get a better understanding of how the database access works, we need to use the
    low-level APIs to drive the protocol, as the higher-level APIs used by commands
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> hide
    much of the complexity and structure. The following sections discuss how you can
    access the databases directly to inspect their security information and configuration.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SAM Remote Service</samp>
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft documents the service used to access the SAM in the *MS-SAMR* document,
    which is available online. Luckily, however, we don’t need to reimplement this
    protocol ourselves. We can make a connection to the SAM using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamConnect</samp>
    Win32 API, which returns a handle we can use for subsequent requests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 10-9](chapter10.xhtml#Lis10-9), we make a connection to the SAM
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connect-SamServer</samp>
    command, which exposes the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamConnect</samp>
    API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表10-9](chapter10.xhtml#Lis10-9)中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Connect-SamServer</samp>命令连接到SAM，该命令公开了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SamConnect</samp> API。
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-9: Connecting to the SAM and displaying its security descriptor'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-9：连接到SAM并显示其安全描述符
- en: You can specify the name of the server containing the SAM using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServerName</samp>
    property. In this case, we use *localhost* (for clarity; specifying this value
    is redundant, as it’s the default for the command). The connection has an associated
    security descriptor that we query using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>
    command introduced in [Chapter 5](chapter5.xhtml).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ServerName</samp>属性指定包含SAM的服务器名称。在这种情况下，我们使用*localhost*（为了清晰起见；指定该值是多余的，因为它是该命令的默认值）。连接具有相关的安全描述符，我们可以使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Format-NtSecurityDescriptor</samp>命令来查询它，该命令在[第5章](chapter5.xhtml)中介绍。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In [Chapter 6](chapter6.xhtml) we discussed using the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Set-NtSecurityDescriptor</samp>
    command to modify a security descriptor. You could use this to grant other users
    access to the SAM, but doing so is not recommended; if done incorrectly, it could
    grant a low-privileged user SAM access, which could lead to an elevation of privileges
    or even a remote compromise of the Windows system.*'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在[第6章](chapter6.xhtml)中，我们讨论了使用<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Set-NtSecurityDescriptor</samp>命令修改安全描述符。你可以使用此命令授予其他用户对SAM的访问权限，但不推荐这样做；如果操作不当，可能会授予低权限用户访问SAM的权限，这可能导致权限提升或甚至远程危害Windows系统。*'
- en: 'You can request specific access rights on the connection with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>
    parameter. If it’s not specified (as was the case in [Listing 10-9](chapter10.xhtml#Lis10-9)),
    the command will request the maximum allowed access. The following are the defined
    access rights for the SAM server connection:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp>参数请求连接上的特定访问权限。如果没有指定（如[列表10-9](chapter10.xhtml#Lis10-9)中所示），则命令将请求允许的最大访问权限。以下是为SAM服务器连接定义的访问权限：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Connect  </samp>Enables connecting
    to the SAM server
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">连接</samp>启用连接到SAM服务器
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shutdown</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables
    shutting down the SAM server
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">关闭</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>启用关闭SAM服务器
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Initialize  </samp>Enables initializing
    the SAM database
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">初始化</samp>启用初始化SAM数据库
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateDomain  </samp>Enables creating
    a new domain in the SAM database
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">创建域</samp>启用在SAM数据库中创建新域
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EnumerateDomains  </samp>Enables
    enumerating domains in the SAM database
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">列举域</samp>启用列举SAM数据库中的域
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">LookupDomain  </samp>Enables looking
    up a domain’s information from the SAM database
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">查找域</samp>启用从SAM数据库中查找域的信息
- en: To connect to the SAM server, the security descriptor must grant the caller
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connect</samp> access right.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Shutdown</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Initialize</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDomain</samp> access rights
    were defined for operations no longer supported by the SAM service.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到SAM服务器，安全描述符必须授予调用者<samp class="SANS_TheSansMonoCd_W5Regular_11">连接</samp>访问权限。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">关闭</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">初始化</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">创建域</samp>访问权限已被定义用于SAM服务不再支持的操作。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The default configuration allows only users who are members of the computer’s
    local* Administrators *group to access the SAM remotely. If the caller is not
    a local administrator, access will be denied, regardless of the security descriptor
    configuration on the SAM. Windows 10 introduced this additional restriction to
    make it harder for* *malicious users to enumerate local users and groups on domain-joined
    systems or exploit weak security configurations. It does not apply to domain controllers
    or when accessing the SAM locally.*'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*默认配置仅允许计算机本地* Administrators *组的成员远程访问 SAM。如果调用者不是本地管理员，则无论 SAM 上的安全描述符配置如何，访问都将被拒绝。Windows
    10 引入了这一附加限制，以使* *恶意用户更难在加入域的系统上列举本地用户和组，或利用弱安全配置。此限制不适用于域控制器或在本地访问 SAM 时。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Domain Objects</samp>
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">域对象</samp>
- en: A *domain object* is a securable resource exposed by the SAM. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateDomains</samp>
    access right on the connection allows you to enumerate the names of the domains
    in the SAM database, while <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupDomain</samp>
    allows you to convert those names to SIDs, which are required to open a domain
    object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenDomain</samp>
    API.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*域对象*是 SAM 提供的可安全访问的资源。连接上的<samp class="SANS_TheSansMonoCd_W5Regular_11">EnumerateDomains</samp>访问权限允许您列举
    SAM 数据库中域的名称，而<samp class="SANS_TheSansMonoCd_W5Regular_11">LookupDomain</samp>允许您将这些名称转换为
    SID，SID 是使用<samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenDomain</samp>
    API 打开域对象所需的。'
- en: PowerShell implements this API in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamDomain</samp>
    command. In [Listing 10-10](chapter10.xhtml#Lis10-10), we use it to inspect the
    domain configuration in the SAM database.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 在<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamDomain</samp>命令中实现了此
    API。在[列表 10-10](chapter10.xhtml#Lis10-10)中，我们使用它来检查 SAM 数据库中的域配置。
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10-10: Enumerating and opening domains'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-10：列举并打开域
- en: We start by enumerating the domains accessible to the SAM. Because we use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp> parameter, this
    command won’t open any domain objects; it will just return the names and domain
    SIDs. We’re querying a workstation, so the first entry is the local workstation
    name, in this case *GRAPHITE*, and the local machine SID. The second is the built-in
    domain, which contains groups such as *BUILTIN\Administrators*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先列举可访问的 SAM 域。因为我们使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">InfoOnly</samp>参数，所以此命令不会打开任何域对象；它只会返回域的名称和域
    SID。我们正在查询一台工作站，所以第一项是本地工作站名称，在本例中是*GRAPHITE*，以及本地计算机的 SID。第二项是内建域，其中包含诸如*BUILTIN\Administrators*等组。
- en: Note that if the domains being enumerated are on a domain controller, the SAM
    service doesn’t query a local SAM database. Instead, the service accesses the
    user data from Active Directory. In this case, the whole domain replaces the local
    domain object; it’s not possible to directly query local users on a domain controller.
    We’ll see in [Chapter 11](chapter11.xhtml) how to access the same information
    using native network protocols for Active Directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果列举的域位于域控制器上，SAM 服务不会查询本地 SAM 数据库。相反，服务会从 Active Directory 中访问用户数据。在这种情况下，整个域会替代本地域对象；无法直接在域控制器上查询本地用户。在[第
    11 章](chapter11.xhtml)中，我们将看到如何使用 Active Directory 的本机网络协议访问相同的信息。
- en: 'We can use the same command to open a domain object directory by specifying
    its name or SID. In this case, we choose to use the name. As the domain is a securable
    object, you can specify the specific access rights with which to open the domain
    object from the following list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的命令通过指定域的名称或 SID 来打开域对象目录。在本例中，我们选择使用名称。由于域是一个可安全访问的对象，您可以从以下列表中指定用于打开域对象的特定访问权限：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPasswordParameters</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables reading password parameters
    (such as the policy)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPasswordParameters</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>启用读取密码参数（例如策略）
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePasswordParams  </samp>Enables
    writing password parameters
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePasswordParams  </samp>启用写入密码参数
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOtherParameters  </samp>Enables
    reading general domain information
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadOtherParameters  </samp>启用读取一般域信息
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOtherParameters  </samp>Enables
    writing general domain information
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteOtherParameters  </samp>启用写入一般域信息
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateUser  </samp>Enables creating
    a new user
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateUser  </samp>启用创建新用户
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateGroup  </samp>Enables creating
    a new group
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateGroup  </samp>启用创建新组
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateAlias  </samp>Enables creating
    a new alias
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateAlias  </samp>启用创建新别名
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetAliasMembership  </samp>Enables
    getting the membership of an alias
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetAliasMembership  </samp>启用获取别名的成员资格
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListAccounts  </samp>Enables enumerating
    users, groups, or aliases in the domain
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListAccounts  </samp>启用列举域中的用户、组或别名
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Lookup  </samp>Enables looking
    up names or IDs of users, groups, or aliases
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Lookup  </samp>启用查找用户、组或别名的名称或
    ID
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdministerServer</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Enables
    changing the domain configuration, such as for domain replication
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdministerServer</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>启用更改域配置，如域复制
- en: With the appropriate access, you can read or write properties of the domain
    object. For example, if you’ve been granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadPasswordParameters</samp>
    access, you can query the password policy for the domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">PasswordInformation</samp>
    property, as we did in [Listing 10-10](chapter10.xhtml#Lis10-10).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有适当的访问权限后，您可以读取或写入域对象的属性。例如，如果您被授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadPasswordParameters</samp>
    访问权限，您可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">PasswordInformation</samp>
    属性查询域的密码策略，正如我们在 [列表 10-10](chapter10.xhtml#Lis10-10) 中所做的那样。
- en: 'If you’ve been granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">ListAccounts</samp>
    access right, you can also use the domain object to enumerate three other types
    of resources: users, groups, and aliases. We’ll look at each of these in turn
    in the following sections.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您被授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ListAccounts</samp> 访问权限，您还可以使用域对象列举另外三种类型的资源：用户、组和别名。我们将在接下来的章节中依次查看这些资源。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">User Objects</samp>
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">用户对象</samp>
- en: 'A *user object* represents what you’d expect: a local user account. You can
    open a user object with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenUser</samp>
    API or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp> PowerShell
    command. [Listing 10-11](chapter10.xhtml#Lis10-11) shows how to enumerate users
    in the domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp>
    command.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户对象*表示您所期望的内容：一个本地用户帐户。您可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">SamOpenUser</samp>
    API 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp> PowerShell
    命令打开用户对象。[列表 10-11](chapter10.xhtml#Lis10-11)展示了如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamUser</samp>
    命令列举域中的用户。'
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 10-11: Enumerating users in the domain'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-11：列举域中的用户
- en: The list of usernames and SIDs returned here should match the output from [Listing
    10-1](chapter10.xhtml#Lis10-1), where we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    command. To get more information about a user, you need to open the user object
    ❶.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的用户名和 SID 列表应与 [列表 10-1](chapter10.xhtml#Lis10-1) 的输出相匹配，在那里我们使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp>
    命令。要获取有关用户的更多信息，您需要打开用户对象 ❶。
- en: One property you can query on the opened user is the list of User Account Control
    flags. These flags define various properties of the user. In this case, as we’ve
    opened the *WDAGUtilityAccount* user, we find that it has the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountDisabled</samp>
    flag set ❷. This matches the output in [Listing 10-1](chapter10.xhtml#Lis10-1),
    which had the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> value
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> for this user
    account.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查询已打开用户的一个属性，即用户账户控制标志列表。这些标志定义了用户的各种属性。在这种情况下，由于我们已经打开了 *WDAGUtilityAccount*
    用户，我们发现它已设置了 <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountDisabled</samp>
    标志 ❷。这与 [Listing 10-1](chapter10.xhtml#Lis10-1) 中的输出相符，该输出将此用户账户的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    值设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。
- en: 'As with the connection and the domain, each user object can have its own security
    descriptor configured. These can grant the following access rights:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与连接和域一样，每个用户对象都可以配置自己的安全描述符。这些可以授予以下访问权限：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGeneral  </samp>Enables reading
    general properties; for example, the username and full name properties
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGeneral  </samp>启用读取一般属性；例如，用户名和全名属性
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPreferences  </samp>Enables
    reading preferences; for example, the user’s text code page preference
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadPreferences  </samp>启用读取偏好设置；例如，用户的文本代码页偏好
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePreferences  </samp>Enables
    writing preferences; for example, the user’s text code page preference
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WritePreferences  </samp>启用写入偏好设置；例如，用户的文本代码页偏好
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadLogon  </samp>Enables reading
    the logon configuration and statistics; for example, the last logon time
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadLogon  </samp>启用读取登录配置和统计信息；例如，最后一次登录时间
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadAccount  </samp>Enables reading
    the account configuration; for example, the user account control flags
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadAccount  </samp>启用读取账户配置；例如，用户账户控制标志
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>Enables writing
    the account configuration; for example, the user account control flags
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>启用写入账户配置；例如，用户账户控制标志
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ChangePassword  </samp>Enables
    changing the user’s password
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ChangePassword  </samp>启用更改用户密码
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ForcePasswordChange  </samp>Enables
    force-changing a user’s password
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ForcePasswordChange  </samp>启用强制更改用户密码
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListGroups  </samp>Enables listing
    the user’s group memberships
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListGroups  </samp>启用列出用户的组成员身份
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGroupInformation</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Currently unused
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadGroupInformation</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>当前未使用
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteGroupInformation  </samp>Currently
    unused
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteGroupInformation  </samp>当前未使用
- en: Perhaps the most interesting of these access rights are <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>.
    The first allows the user’s password to be changed using an API like <samp class="SANS_TheSansMonoCd_W5Regular_11">SamChangePassword</samp>.
    For this to succeed, the caller must provide the old password along with the new
    password to set. If the old password doesn’t match the one that’s currently set,
    the server rejects the change request. You can see in [Listing 10-11](chapter10.xhtml#Lis10-11)
    that the *Everyone* group ❸ and the *WDAGUtilityAccount* user are granted the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp> access right.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最有趣的访问权限可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>。第一个允许通过类似
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SamChangePassword</samp> 的 API 更改用户密码。为了使更改成功，调用者必须提供旧密码以及要设置的新密码。如果旧密码与当前设置的不匹配，服务器会拒绝更改请求。你可以在
    [Listing 10-11](chapter10.xhtml#Lis10-11) 中看到，*Everyone* 组 ❸ 和 *WDAGUtilityAccount*
    用户被授予了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ChangePassword</samp> 访问权限。
- en: However, there are circumstances where an administrator might need to be able
    to change a user’s password even if they don’t know the previous password (if
    the user has forgotten it, for example). A caller who is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access on the user object can assign a new one without needing to know the old
    password. In this case the password is set using the <samp class="SANS_TheSansMonoCd_W5Regular_11">SamSetInformationUser</samp>
    API. In [Listing 10-11](chapter10.xhtml#Lis10-11), only the *Administrators* group
    is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access ❹.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在某些情况下，管理员可能需要能够更改用户的密码，即使他们不知道之前的密码（例如，如果用户忘记了密码）。获得<samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    访问权限的调用者可以在不需要知道旧密码的情况下分配新密码。在这种情况下，密码是通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">SamSetInformationUser</samp>
    API 设置的。在[列表 10-11](chapter10.xhtml#Lis10-11)中，只有*Administrators*组被授予<samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    访问权限❹。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Group Objects</samp>
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">组对象</samp>
- en: '*Group objects* configure the group membership of a user’s token when it’s
    created. We can enumerate the groups in a domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroup</samp>
    command and the members of a group using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp>,
    as shown in [Listing 10-12](chapter10.xhtml#Lis10-12).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*组对象*在创建用户令牌时配置用户的组成员身份。我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroup</samp>
    命令列举域中的组，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp>
    命令列举组的成员，如[列表 10-12](chapter10.xhtml#Lis10-12)所示。'
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 10-12: Listing domain group objects and enumerating members'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 10-12: 列出域组对象并列举成员'
- en: The output of this command might surprise you. Where are the rest of the groups
    we saw in [Listing 10-4](chapter10.xhtml#Lis10-4) as the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    command? Also, if you check that earlier output, you won’t find the *None* group,
    even though we see it returned here. What’s going on?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出可能会让你感到惊讶。我们在[列表 10-4](chapter10.xhtml#Lis10-4)中看到的其余组在哪里？另外，如果你检查之前的输出，你会发现没有*None*组，尽管我们在这里看到了它。到底发生了什么？
- en: First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    command returns groups in both the local domain and the separate *BUILTIN* domain.
    In [Listing 10-12](chapter10.xhtml#Lis10-12), we’re looking at only the local
    domain, so we wouldn’t expect to see a group such as *BUILTIN\Administrators*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> 命令返回本地域和独立的*BUILTIN*域中的组。在[列表
    10-12](chapter10.xhtml#Lis10-12)中，我们只查看本地域，因此不会看到像*BUILTIN\Administrators*这样的组。
- en: Second, the <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> group
    is hidden from view by the higher-level APIs used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    command, as it’s not really a group you’re supposed to modify. It’s managed by
    the LSA, which adds new members automatically when new users are created. If we
    list the members by opening the group ❶ and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp>
    command ❷, we see that the members are stored as the user’s relative ID along
    with group attributes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，<samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> 组在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>
    命令使用的高级 API 中被隐藏，因为它并不是你应该修改的组。它由 LSA 管理，当新用户被创建时，LSA 会自动添加新成员。如果我们通过打开该组 ❶ 并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamGroupMember</samp> 命令 ❷ 来列出成员，我们会看到成员作为用户的相对
    ID 与组属性一起存储。
- en: Note that the group doesn’t store the whole SID. This means a group can contain
    members in the same domain only, which severely limits their use. This is why
    the higher-level APIs don’t expose an easy way to manipulate them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，组并未存储完整的 SID。这意味着一个组只能包含同一域中的成员，这大大限制了它们的使用。因此，高级 API 不会暴露出一种方便的方式来操作它们。
- en: Interestingly, the default security descriptor for a domain object doesn’t grant
    anyone the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateGroup</samp> access
    right, which allows for new groups to be created. Windows really doesn’t want
    you using group objects (although, if you really wanted to, you could change the
    security descriptor manually as an administrator to allow group creation to succeed).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，域对象的默认安全描述符并没有授予任何人<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateGroup</samp>访问权限，这个权限允许创建新组。Windows确实不希望你使用组对象（不过，如果你真的想要，你可以手动作为管理员更改安全描述符，以允许组创建成功）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Alias Objects</samp>
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">别名对象</samp>
- en: The final object type is the *alias object*. These objects represent the groups
    you’re more familiar with, as they’re the underlying type returned by the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp> command. For example,
    the *BUILTIN* domain object has aliases for groups such as *BUILTIN\Administrators*,
    which is used only on the local Windows system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的对象类型是*别名对象*。这些对象代表了你更为熟悉的组，因为它们是由<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalGroup</samp>命令返回的底层类型。例如，*BUILTIN*域对象有诸如*BUILTIN\Administrators*的别名，该别名仅在本地Windows系统上使用。
- en: As [Listing 10-13](chapter10.xhtml#Lis10-13) demonstrates, we can enumerate
    the aliases in a domain with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAlias</samp>
    command and query its members with <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp>.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表10-13](chapter10.xhtml#Lis10-13)所示，我们可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAlias</samp>命令列举域中的别名，并通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp>查询其成员。
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 10-13: Listing domain alias objects and enumerating members'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-13：列出域别名对象并枚举成员
- en: In this case, the only alias in the local domain is *Awesome Users* ❶. To see
    a list of its members, we can open the alias by name ❷ and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp>
    command ❸. Note that the entire SID is stored for each member, which means that
    (unlike with groups) the members of an alias can be from different domains. This
    makes aliases much more useful as a grouping mechanism and is likely why Windows
    does its best to hide the group objects from view.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，本地域中唯一的别名是*Awesome Users* ❶。要查看其成员列表，我们可以通过名称打开该别名 ❷，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SamAliasMember</samp>命令
    ❸。请注意，每个成员都存储了完整的SID，这意味着（与组不同）别名的成员可以来自不同的域。这使得别名作为一种分组机制更加有用，也很可能是Windows尽力隐藏组对象的原因。
- en: 'Group and alias objects support the same access rights, although the raw access
    mask values differ. You can request the following types of access on both kinds
    of objects:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 组和别名对象支持相同的访问权限，尽管原始的访问掩码值有所不同。你可以在这两种对象上请求以下类型的访问权限：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AddMember  </samp>Enables adding
    a new member to the object
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AddMember  </samp>启用向对象添加新成员
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">RemoveMember  </samp>Enables removing
    a member from the object
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">RemoveMember  </samp>启用从对象中移除成员
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListMembers  </samp>Enables listing
    members of the object
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ListMembers  </samp>启用列出对象的成员
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadInformation  </samp>Enables
    reading properties of the object
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ReadInformation  </samp>启用读取对象的属性
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>Enables writing
    properties of the object
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">WriteAccount  </samp>启用写入对象的属性
- en: This concludes our discussion of the SAM remote service. Let’s now take a quick
    look at the second remote service, which allows you to access the domain policy.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本文讨论的SAM远程服务到此结束。现在让我们快速浏览第二个远程服务，它允许你访问域策略。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Domain Policy
    Remote Service</samp>
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">域策略远程服务</samp>
- en: Microsoft documents the protocol used to access the LSA policy (and thus the
    SECURITY database) in *MS-LSAD*. We can make a connection to the LSA policy using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaOpenPolicy</samp> Win32 API,
    which returns a handle for subsequent calls. PowerShell exposes this API with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPolicy</samp> command,
    as demonstrated in [Listing 10-14](chapter10.xhtml#Lis10-14).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 10-14: Opening the LSA policy, querying its security descriptor, and
    looking up a SID'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: First, we open the LSA policy on the local system. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemName</samp>
    parameter to specify the system to access if it’s not the local system. The LSA
    policy is a securable object, and we can query its security descriptor as shown
    here, assuming we have <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify one or more of the following access rights for the open policy
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access</samp> parameter
    when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaPolicy</samp>
    command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ViewLocalInformation  </samp>Enables
    viewing policy information
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ViewAuditInformation  </samp>Enables
    viewing audit information
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">GetPrivateInformation  </samp>Enables
    viewing private information
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TrustAdmin  </samp>Enables managing
    the domain trust configuration
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateAccount  </samp>Enables creating
    a new account object
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreateSecret  </samp>Enables creating
    a new secret object
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreatePrivilege  </samp>Enables
    creating a new privilege (unsupported)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetDefaultQuotaLimits  </samp>Enables
    setting default quota limits (unsupported)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetAuditRequirements  </samp>Enables
    setting the audit event configuration
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AuditLogAdmin  </samp>Enables managing
    the audit log
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ServerAdmin  </samp>Enables managing
    the server configuration
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">LookupNames  </samp>Enables looking
    up SIDs or names of accounts
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Notification  </samp>Enables receiving
    notifications of policy changes
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'With the policy object and the appropriate access rights, you can manage the
    server’s configuration. You can also look up and open the three types of objects
    in the SECURITY database shown in [Figure 10-6](chapter10.xhtml#fig10-6): accounts,
    secrets, and trusted domains. The following sections describe these objects.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Account Objects</samp>
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An *account object* is not the same as the user objects we accessed via the
    SAM remote service. An account object doesn’t need to be tied to a registered
    user account; instead, it’s used to configure the account rights we discussed
    earlier. For example, if you want to assign a specific privilege to a user account,
    you must ensure that an account object exists for the user’s SID and then add
    the privilege to that object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You can create a new account object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaCreateAccount</samp>
    API if you have <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateAccount</samp>
    access on the policy object. However, you don’t normally need to do this directly.
    Instead, you’ll typically access account objects from the LSA policy, as shown
    in [Listing 10-15](chapter10.xhtml#Lis10-15).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 10-15: Listing and opening LSA account objects'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: We first open the policy with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ViewLocalInformation</samp>
    access right ❶, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccount</samp>
    PowerShell command to enumerate the account objects ❷. You can see that the output
    lists the internal groups, not the local users we inspected earlier in the chapter,
    returning the name and SID for each.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then open an account object by its SID; for example, here we open the
    built-in user’s account object ❸. The account objects are securable and have an
    associated security descriptor that you can query. In this case, we can see in
    the formatted output that only the *Administrators* group gets full access to
    an account ❹. The only other ACE grants <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadControl</samp>
    access to *Everyone*, which prevents the rights for an account from being enumerated.
    If the security descriptor allows it, account objects can be assigned the following
    access rights:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">View  </samp>Enables viewing information
    about the account object, such as privileges and logon rights
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustPrivileges  </samp>Enables
    adjusting the assigned privileges
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustQuotas  </samp>Enables adjusting
    user quotas
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustSystemAccess  </samp>Enables
    adjusting the assigned logon rights
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: If we rerun the commands in [Listing 10-15](chapter10.xhtml#Lis10-15) as an
    administrator, we can then use the account object to enumerate privileges and
    logon rights, as in [Listing 10-16](chapter10.xhtml#Lis10-16).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 10-16: Enumerating privileges and logon rights'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'What is interesting here is that privileges and logon rights are listed in
    separate ways, even though you saw earlier that account rights were represented
    in a manner similar to privileges: using the name to identify the right to assign.
    For the account object, privileges are stored as a list of LUIDs, which is the
    same format used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object. However, the logon rights are stored as a set of bit flags in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SystemAccess</samp> property.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: This difference is due to the way Microsoft designed the account right APIs
    that are used by <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    and related commands. These APIs merge the various account rights and privileges
    into one to make it easier for a developer to write correct code. I’d recommend
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtAccountRight</samp>
    or the underlying API rather than going directly to the LSA policy to inspect
    and modify the account rights.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Secret Objects</samp>
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The LSA can maintain secret data for other services on the system, as well as
    for itself. It exposes this data through *secret objects*. To create a new secret
    object you need to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateSecret</samp>
    access right on the policy. [Listing 10-17](chapter10.xhtml#Lis10-17) shows how
    to open and inspect an existing LSA secret object. Run these commands as an administrator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 10-17: Opening and inspecting an LSA secret'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by opening the policy, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSecret</samp>
    command to open a secret by name ❶. There is no API to enumerate the stored secrets;
    you must know their names to open them. In this case, we open a secret that should
    exist on every system: the *Data Protection API (DPAPI)* master key, named *DPAPI_SYSTEM*.
    The DPAPI is used to encrypt data based on the user’s password. For it to function,
    it needs a system master key.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'As the secret is securable, we can check its security descriptor ❷, which can
    assign the following access rights:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SetValue  </samp>Enables setting
    the value of the secret
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QueryValue  </samp>Enables querying
    the value of the secret
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: If you have the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryValue</samp>
    access right, you can inspect the contents of the key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    method, as we do in [Listing 10-17](chapter10.xhtml#Lis10-17) ❸. The secret contains
    the current value and a previous value, as well as timestamps for when those values
    were set. Here, we display the current value as hex ❹. The contents of the secret’s
    value are defined by the DPAPI, which we won’t dig into further in this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Trusted Domain Objects</samp>
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final type of object in the SECURITY database is the *trusted domain object*.
    These objects describe the trust relationships between domains in a forest. Although
    the domain policy remote service was designed for use with domains prior to the
    introduction of Active Directory, it can still be used to query the trust relationships
    on a modern domain controller.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-18](chapter10.xhtml#Lis10-18) shows an example of how to open the
    policy on a domain controller and then query for the list of trusted domains.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 10-18: Enumerating trust relationships for a domain controller'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: To inspect and configure trust relationships, you should use Active Directory
    commands, not the domain policy remote service’s commands. Therefore, I won’t
    dwell on these objects any further; we’ll come back to the subject of inspecting
    trust relationships in the next chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*While trusted domains are securable objects, the security descriptors are
    not configurable through any of the remote service APIs; attempting this will
    generate an error. This is because the security is implemented by Active Directory,
    not the LSA.*'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Name Lookup and Mapping</samp>
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you’re granted <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access, the domain policy remote service will let you translate SIDs to names,
    and vice versa. For example, as shown in [Listing 10-19](chapter10.xhtml#Lis10-19),
    you can specify one or more SIDs to receive the corresponding users and domains
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaName</samp> PowerShell
    command. You can also specify a name and receive the SID using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSid</samp>.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 10-19: Looking up a SID or a name from the policy'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Before Windows 10, it was possible for an unauthenticated user to use the lookup
    APIs to enumerate users on a system, as the anonymous user was granted <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access. This was a problem because an attack calling *RID cycling* could brute-force
    valid users on the system. As you witnessed in [Listing 10-14](chapter10.xhtml#Lis10-14),
    current versions of Windows explicitly deny the <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access right. However, RID cycling remains a useful technique for authenticated
    non-administrator domain users, as non-administrators can’t use the SAM remote
    service.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to add mappings from SIDs to names, even if they’re not
    well-known SIDs or registered accounts in the SAM database. The Win32 API <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LsaManageSidNameMapping</samp> controls
    this. It’s used by the SCM (discussed in [Chapter 3](chapter3.xhtml)) to set up
    service-specific SIDs to control resource access, and you can use it yourself,
    although you’ll encounter the following restrictions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The caller needs <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled and must be on the same system as the LSA.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SID to map must be in the NT security authority.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first RID of the SID must be between <samp class="SANS_TheSansMonoCd_W5Regular_11">80</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> (inclusive of those
    values).
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must first register a domain SID before you can add a child SID in that
    domain.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaManageSidNameMapping</samp>
    API to add or remove mappings using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtSidName</samp> PowerShell
    commands. [Listing 10-20](chapter10.xhtml#Lis10-20) shows how to add SID-to-name
    mappings to the LSA as an administrator.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 10-20: Adding and removing SID-to-name mappings'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We first define the domain SID with a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">99</samp>
    ❶, then create a user SID based on the domain SID with a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>
    ❷. We’re impersonating the *SYSTEM* user, so we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    privilege, which means we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Add-NtSidName</samp>
    command with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp>
    parameter to add the mapping ❸. (Recall that you need to register the domain before
    adding the user.) We then use the policy to check the SID mappings for the LSA
    ❹. Finally, we remove the SID-to-name mappings to clean up the changes we’ve made
    ❺.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of the LSA policy. Let’s now look at how the two
    configuration databases, SAM and SECURITY, are stored locally.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The SAM and SECURITY Databases</samp>
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve seen how to access the SAM and SECURITY databases using the remote services.
    However, you’ll find it instructive to explore how these databases are stored
    locally, as registry keys. By accessing the databases directly, you can obtain
    information not exposed by the remote services, such as password hashes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*These registry keys aren’t designed to be accessed directly, so the way in
    which they store the user and policy configurations could change at any time.
    Keep in mind that the description provided in this section might no longer be
    accurate at the time you’re reading it. Also, because direct access is a common
    technique used by malicious software, it’s very possible that script code in this
    section that you attempt to run may be blocked by any antivirus product running
    on your system.*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the SAM
    Database Through the Registry</samp>
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start with the SAM database, found in the registry at *REGISTRY\MACHINE\SAM.*
    It’s secured so that only the *SYSTEM* user can read and write to its registry
    keys. You could run PowerShell as the *SYSTEM* user with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Win32ChildProcess</samp>
    command and then access the registry that way, but there is a simpler approach.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: As an administrator, we can bypass the read access check on the registry by
    enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>.
    If we create a new object manager drive provider while this privilege is enabled,
    we can inspect the SAM database registry key using the shell. Run the commands
    in [Listing 10-21](chapter10.xhtml#Lis10-21) as an administrator.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 10-21: Mapping the <samp class="SANS_Futura_Std_Book_11">MACHINE</samp>
    registry key with SeBackupPrivilege and listing the SAM database registry key'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We begin by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>.
    With the privilege enabled, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-PSDrive</samp>
    command to map a view of the *MACHINE* registry key to the *SEC:* drive. This
    enables the drive to use <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>
    to circumvent security checking.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We can list the contents of the SAM database registry key using the normal PowerShell
    commands. The two most important keys are *Account* ❶ and *Builtin* ❷. The *Account*
    key represents the local domain we accessed using the SAM remote service and contains
    the details of local users and groups. The *Builtin* key contains the local built-in
    groups; for example, *BUILTIN\Administrators*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Extracting User Configurations</samp>
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s use our access to the SAM database registry key to extract the configuration
    of a user account. [Listing 10-22](chapter10.xhtml#Lis10-22) shows how to inspect
    a user’s configuration. Run these commands as an administrator.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 10-22: Displaying data for the default administrator user'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The registry key stores user information in keys where the name is the hexadecimal
    representation of the user’s RID in the domain. For example, in [Listing 10-22](chapter10.xhtml#Lis10-22),
    we query for the *Administrator* user, which always has a RID of <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp>
    in decimal. Therefore, we know it will be stored in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">000001F4</samp>,
    which is the RID in hexadecimal ❶. You could also list the *Users* key to find
    other users.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'The key contains a small number of binary values ❷. In this example, we have
    three values: the <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp> value,
    which is a set of fixed-sized attributes for the user; <samp class="SANS_TheSansMonoCd_W5Regular_11">V</samp>,
    which is a set of variable-sized attributes; and <samp class="SANS_TheSansMonoCd_W5Regular_11">SupplementalCredentials</samp>,
    which could be used to store credentials other than the NT hash, such as online
    accounts or biometric information.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start of the variable-sized attributes value is an attribute index table.
    Each index entry has an offset, a size, and additional flags. The important user
    data is stored in these indexes:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 0    **The user object’s security descriptor ❸'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 1    **The user’s name ❹'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 13    **The user’s LM hash ❺'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**Index 14    **The user’s NT hash ❻'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The LM and NT hash values aren’t stored in plaintext; the LSA obfuscates them
    using a couple of different encryption algorithms, such as RC4 and Advanced Encryption
    Standard (AES). Let’s develop some code to extract the hash values for a user.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Extracting the System Key</samp>
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the original version of Windows NT, you needed only the SAM database registry
    key to decrypt the NT hash. In Windows 2000 and later, you need an additional
    key, the *LSA system key*, which is hidden inside the *SYSTEM* registry key. This
    key is also used as part of the obfuscation mechanism for values in the SECURITY
    database registry key.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The first step to extracting an NT hash is extracting the system key into a
    form we can use. [Listing 10-23](chapter10.xhtml#Lis10-23) shows an example.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 10-23: Extracting the obfuscated LSA system key'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The key is stored in four separate parts inside the LSA configuration key ❶.
    To add a layer of obfuscation, the parts aren’t stored as registry values; instead,
    they’re hexadecimal text strings stored in the rarely used registry key class
    name value. We can extract these values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName</samp>
    property and then convert them to bytes ❷.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: We must then permutate the boot key’s byte values using a fixed ordering to
    generate the final key ❸. We can run the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaSystemKey</samp>
    PowerShell command to display the bytes ❹. Note that the value of the key is system
    specific, so the output you see will almost certainly be different.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: One interesting thing to note is that getting the boot key doesn’t require administrator
    access. This means that an arbitrary file-read vulnerability could enable a non-administrator
    to extract the registry hive files backing the *SAM* and *SECURITY* registry keys
    and decrypt their contents (which doesn’t seem like a particularly good application
    of defense in depth).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypting the Password Encryption
    Key</samp>
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next step in the deobfuscation process is to decrypt the *password encryption
    key (PEK)* using the system key. The PEK is used to encrypt the user hash values
    we extracted in [Listing 10-22](chapter10.xhtml#Lis10-22). In [Listing 10-24](chapter10.xhtml#Lis10-24),
    we define the function to decrypt the PEK.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 10-24: Defining the Unprotect-PasswordEncryptionKey decryption function'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: First we query the registry value ❶ that contains the data associated with the
    PEK. Next, we find the encrypted PEK in the fixed-attribute registry variable
    at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0x68</samp> ❷ (remember
    that this location could change). The first 32-bit integer represents the type
    of encryption used, either RC4 or AES128\. The second 32-bit integer is the length
    of the trailing encrypted PEK. We extract the data and then call an algorithm-specific
    decryption function ❸.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the decryption functions. [Listing 10-25](chapter10.xhtml#Lis10-25)
    shows how to decrypt the password using RC4.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 10-25: Decrypting the password encryption key using RC4'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating some helper functions for the decryption process, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-MD5Hash</samp>, which calculates
    an MD5 hash ❶. We then start the decryption ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">$Data</samp>
    parameter that we pass to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordEncryptionKeyRC4</samp>
    function is the value extracted from the fixed-attribute buffer.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The function constructs a long binary string containing the first 16 bytes of
    the encrypted data (an *initialization vector*, used to randomize the encrypted
    data), along with two fixed strings and the system key ❸.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The binary string is then hashed using the MD5 algorithm to generate a key for
    the RC4 encryption, which we use to decrypt the remaining 32 bytes of the encrypted
    data ❹. The first 16 decrypted bytes are the PEK, and the second 16 bytes are
    an MD5 hash used to verify that the decryption was correct. We check the hash
    value ❺ to make sure we’ve successfully decrypted the PEK. If the hash value is
    not correct, we’ll throw an exception to indicate the failure.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 10-26](chapter10.xhtml#Lis10-26), we define the functions for decrypting
    the PEK using AES.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 10-26: Decrypting the password encryption key using AES'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a function to decrypt an AES buffer with a specified key
    and initialization vector (IV) ❶. The decryption process uses AES in cipher block
    chaining (CBC) mode with PKCS7 padding. I recommend looking up how these modes
    function, but their exact details are unimportant for this discussion; just be
    aware that they must be set correctly or the decryption process will fail.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Now we define the password decryption function. The key used for AES is the
    system key ❷, with the IV being the first 16 bytes of data after a short header
    ❸ and the encrypted data immediately following. The length of the data to decrypt
    is stored as a value in the header.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: As with RC4, the encrypted data contains an encrypted hash value we can use
    to verify that the decryption succeeded. We decrypt the value ❹ and then generate
    the SHA256 hash of the PEK to verify it ❺. If the decryption and verification
    succeeded, we now have a decrypted PEK.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 10-27](chapter10.xhtml#Lis10-27), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordEncryptionKey</samp>
    function to decrypt the password key.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 10-27: Testing the password encryption key decryption'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Again, the actual value generated should look different on different systems.
    Also note that the PEK is always 16 bytes in size, regardless of the encryption
    algorithm used to store it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypting a Password Hash</samp>
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have the PEK, we can decrypt the password hashes we extracted from
    the user object in [Listing 10-22](chapter10.xhtml#Lis10-22). [Listing 10-28](chapter10.xhtml#Lis10-28)
    defines the function to decrypt the password hash.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 10-28: Decrypting a password hash'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-PasswordHash</samp>
    function takes as arguments the PEK we decrypted, the encrypted hash data, the
    RID of the user, and the type of hash. LM hashes have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, while NT hashes
    have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The hash data stores the type of encryption; as with the PEK, the supported
    encryption algorithms are RC4 and AES128\. Note that it’s possible for the PEK
    to be encrypted with RC4 and the password hash with AES, or vice versa. Allowing
    a mix of encryption types lets systems migrate old hash values from RC4 to AES
    when a user changes their password.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We call the algorithm-specific decryption function to decrypt the hash. Note
    that only the RC4 decryption function needs us to pass it the RID and type of
    hash; the AES128 decryption function doesn’t require those two values.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement the RC4 hash decryption first, in [Listing 10-29](chapter10.xhtml#Lis10-29).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 10-29: Decrypting a password hash using RC4'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: We first check the length of the data ❶. If it’s less than 20 bytes in size,
    we assume the hash isn’t present. For example, the LM hash is not stored by default
    on modern versions of Windows, so attempting to decrypt that hash will return
    an empty array.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Assuming there is a hash to decrypt, we then need an IV string based on the
    type of hash being decrypted ❷. In addition to LM and NT hashes, the LSA can decrypt
    a few other hash types, such as the password history, which stores previous password
    hashes to prevent users from changing back to an old password.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: We build a key by concatenating the PEK, the RID in its byte form, and the IV
    string and using it to generate an MD5 hash ❸. We then use this new key to finally
    decrypt the password hash ❹.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting the password using AES is simpler than with RC4, as you can see in
    [Listing 10-30](chapter10.xhtml#Lis10-30).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 10-30: Decrypting a password hash using AES'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The password contains the data length, which we use to determine if we need
    to return an empty buffer ❶. We can then extract the IV ❷ and the encrypted value
    from the buffer and decrypt the value using the PEK ❸.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-31](chapter10.xhtml#Lis10-31) decrypts the LM and NT hashes.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 10-31: Decrypting the LM and NT hashes'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this example there is no LM hash, so the decryption process returns
    an empty array ❶. However, the NT hash decrypts to a 16-byte value ❷.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Deobfuscating the Password
    Hash</samp>
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We now have a decrypted password hash, but there is one final step we need to
    perform to retrieve the original hash. The password hash is still encrypted with
    the Data Encryption Standard (DES) algorithm. DES was the original obfuscation
    mechanism for hashes in the original version of NT before the introduction of
    the system key. All this RC4 and AES decryption merely got us back to where we
    started.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: We first need to generate the DES keys to decrypt the hash value ([Listing 10-32](chapter10.xhtml#Lis10-32)).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 10-32: Generating the DES keys for the RID'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The first step in decrypting the hash is to generate two 64-bit DES keys based
    on the value of the RID. In [Listing 10-32](chapter10.xhtml#Lis10-32), we unpack
    the RID into two 56-bit arrays as the base for the two keys. We then expand each
    56-bit array to 64 bits by taking each 7 bits of the array and calculating a parity
    bit for each byte. The parity bit is set in the least significant bit of each
    byte, to ensure that each byte has an odd number of bits.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: With the two keys, we can decrypt the hash fully. First we’ll need a few functions,
    which we define in [Listing 10-33](chapter10.xhtml#Lis10-33).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 10-33: Decrypting password hashes using DES'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a simple DES decryption function. The algorithm uses DES
    in electronic code book (ECB) mode with no padding. We then define a function
    to decrypt the hash. The first 8-byte block is decrypted with the first key, and
    the second with the second key. Following that, we concatenate the decrypted hash
    into a single 16-byte result.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can decrypt the password hash and compare it against the real value,
    as shown in [Listing 10-34](chapter10.xhtml#Lis10-34).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 10-34: Verifying the NT hash'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: If the hash was correctly decrypted, we should expect it to match the MD4 hash
    of the user’s password. In this case, the user’s password was set to *adminpwd*
    (I know, not strong). The decrypted NT hash and the generated hash match exactly.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at the SECURITY database, which stores the LSA policy. We won’t
    spend much time on this database, as we can directly extract most of its information
    using the domain policy remote service described earlier in the chapter.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inspecting the SECURITY
    Database</samp>
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The LSA policy is stored in the SECURITY database registry key, which is located
    at *REGISTRY\MACHINE\SECURITY*. As with the SAM database registry key, only the
    *SYSTEM* user can access the key directly, but we can use the mapped drive provider
    from [Listing 10-21](chapter10.xhtml#Lis10-21) to inspect its contents.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-35](chapter10.xhtml#Lis10-35) shows a few levels of the SECURITY
    database registry key. Run this command as an administrator.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 10-35: Listing the contents of the SECURITY database registry key'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss only a few of these registry keys. The *Cache* key ❶ contains
    a list of cached domain credentials that can be used to authenticate a user even
    if access to the domain controller is lost. We’ll cover the use of this key in
    [Chapter 12](chapter12.xhtml), when we discuss interactive authentication.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The *SAM* key ❷ is a link to the full SAM database registry key whose contents
    we showed in [Listing 10-21](chapter10.xhtml#Lis10-21). It exists here for convenience.
    The *Policy\Accounts* key ❸ is used to store the account objects for the policy.
    The *Policy* key also contains other system policies and configuration; for example,
    *PolAdtEv* ❹ and *PolAdtLg* ❺ contain configurations related to the system’s audit
    policy, which we analyzed in [Chapter 9](chapter9.xhtml).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The security descriptor that secures the policy object is found in the *Policy\SecDesc*
    key ❻. Each securable object in the policy has a similar key to persist the security
    descriptor.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *Policy\Secrets* key ❼ is used to store secret objects. We dig
    further into the children of the *Secrets* key in [Listing 10-36](chapter10.xhtml#Lis10-36).
    You’ll need to run these commands as an administrator.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 10-36: Enumerating the children of the <samp class="SANS_Futura_Std_Book_11">SECURITY\Policy\Secrets</samp>
    key'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-36](chapter10.xhtml#Lis10-36) lists the subkeys of the *Secrets*
    key ❶. The name of each subkey is the string used when opening the secret via
    the domain policy remote service. For example, we can see the *DPAPI_SYSTEM* secret
    we accessed in [Listing 10-17](chapter10.xhtml#Lis10-17) in the output.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: When we inspect the values of that key ❷, we find its current and old values
    and timestamps, as well as the security descriptor for the secret object. The
    secret’s contents are stored as the default value in the key, so we can display
    it as hex ❸. You might notice that the value of the secret isn’t the same as the
    one we dumped via the domain policy remote service. As with the user object data,
    the LSA will try to obfuscate values in the registry to prevent trivial disclosure
    of the contents. The system key is used, but with a different algorithm; I won’t
    dig further into the details of this.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some examples to illustrate how you can use the various commands
    you saw in this chapter for security research or systems analysis purposes.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RID Cycling</samp>
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In “Name Lookup and Mapping” on page 323, I mentioned an attack called RID cycling
    that uses the domain policy remote service to find the users and groups present
    on a computer without having access to the SAM remote service. In [Listing 10-37](chapter10.xhtml#Lis10-37),
    we perform the attack using some of the commands introduced in this chapter.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 10-37: A simple RID cycling implementation'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the function to perform the RID cycling attack. We need four
    parameters ❶: the server that we want to enumerate, the domain in the server to
    enumerate, and minimum and maximum RID values to check. The lookup process can
    request only 1,000 SIDs at a time, so we set a default range within that limit,
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">500</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">1499</samp>
    inclusive, which should cover the range of RIDs used for user accounts and groups.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Next, we open the policy object and request <samp class="SANS_TheSansMonoCd_W5Regular_11">LookupNames</samp>
    access ❷. We need to look up the SID for the domain by using its simple name ❸.
    With the domain SID, we can create relative SIDs for each RID we want to brute-force
    and look up their names ❹. If the returned object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NameUse</samp>
    property is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Unknown</samp>,
    then the SID didn’t map to a username ❺. By checking this property, we can filter
    out invalid users from our enumeration.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we test this function on another system on our local domain network
    ❻. You need to be able to authenticate to the server to perform the attack. On
    a domain-joined system, this should be a given. However, if your machine is a
    stand-alone system, the attack might fail without authentication credentials.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forcing a User‘s
    Password Change</samp>
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the discussion of user objects in the SAM database, I mentioned that if a
    caller is granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access on a user object they can force a change of the user’s password. [Listing
    10-38](chapter10.xhtml#Lis10-38) shows how to do this using the commands described
    in this chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 10-38: Force-changing a user’s password via the SAM remote service'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: We first define a helper function that opens a user object on a specified server.
    We open the user domain using the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    parameter and explicitly request the <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access right, which will generate an access denied error if it’s not granted.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We then define a function that sets the password. We’ll read the password from
    the console, as it needs to be in the secure string format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Expired</samp>
    parameter marks the password as needing to be changed the next time the user authenticates.
    After reading the password from the console, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SetPassword</samp>
    function on the user object.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: We can test the password setting function by running the script in [Listing
    10-39](chapter10.xhtml#Lis10-39) as an administrator.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 10-39: Setting a user’s password on the current computer'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: To be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">ForcePasswordChange</samp>
    access, you need to be an administrator on the target machine. In this case, we’re
    running as an administrator locally. If you want to change a remote user’s password,
    however, you’ll need to authenticate as an administrator on the remote computer.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting All Local
    User Hashes</samp>
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In “Accessing the SAM Database Through the Registry” on page 325, we defined
    functions to decrypt a user’s password hash from the SAM database. To use those
    functions to decrypt the passwords for all local users automatically, run [Listing
    10-40](chapter10.xhtml#Lis10-40) as an administrator.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 10-40: Decrypting the password hashes of all local users'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a function to decrypt a single password hash from a user’s
    registry key ❶. We select which hash to extract based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">LmHash</samp>
    parameter, which changes the index and the type for the RC4 key. We then call
    this function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-UserHashes</samp>
    function ❷, which extracts other information, such as the name of the user, and
    builds a custom object.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-UserHashes</samp>
    function, we first decrypt the password encryption key ❸, then enumerate the user
    accounts in the registry and pipe them through it ❹. We can see in the output
    that only two users have NT password hashes, and no user has an LM hash configured.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We started this chapter with a discussion of Windows domain authentication.
    We went through the various levels of complexity, starting with a local domain
    on a stand-alone computer and moving through a networked domain and a forest.
    Each level of complexity has an associated configuration that can be accessed
    to determine what users and/or groups are available within an authentication domain.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we examined various built-in PowerShell commands you can use
    to inspect the authentication configuration on the local system. For example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LocalUser</samp> command
    will list all registered users, as well as whether they’re enabled or not. We
    also saw how to add new users and groups.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the LSA policy, which is used to configure various security
    properties (such as the audit policy described in [Chapter 9](chapter9.xhtml)),
    what privileges a user is assigned, and what types of authentication the user
    can perform.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored how to access the configuration internally, whether locally
    or on a remote system, using the SAM remote service and domain policy service
    network protocols. As you saw, what we normally consider a group is referred to
    as an alias internally.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter with a deep dive into how the authentication configuration
    is stored inside the registry and how you can perform a basic inspection of it.
    We also looked at an example of how to extract a user’s hashed password from the
    registry.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a similar look at how the authentication configuration
    is stored in an Active Directory configuration, which is significantly more complex
    than the local configuration case.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
