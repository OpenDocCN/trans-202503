<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_95"/><strong><span class="big">10</span><br/>SERVER-SIDE REQUEST FORGERY</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">A <em>server-side request forgery (SSRF)</em> vulnerability allows an attacker to make a server perform unintended network requests. Like a cross-site request forgery (CSRF) vulnerability, an SSRF abuses another system to perform malicious actions. While a CSRF exploits another user, an SSRF exploits a targeted application server. As with CSRFs, SSRF vulnerabilities can vary in impact and execution methods. However, just because you can make a targeted server send requests to other arbitrary servers doesn’t mean the targeted application is vulnerable. The application may intentionally allow this behavior. For this reason, it’s important to understand how to demonstrate impact when you’ve found a potential SSRF.</p>&#13;
<h3 class="h3" id="ch10lev1sec1"><span epub:type="pagebreak" id="page_96"/><strong>Demonstrating the Impact of Server-Side Request Forgery</strong></h3>&#13;
<p class="noindent">Depending on how a website is organized, a server vulnerable to SSRF might make an HTTP request to an internal network or to external addresses. The vulnerable server’s ability to make requests determines what you can do with the SSRF.</p>&#13;
<p class="indent">Some larger websites have firewalls that prohibit external internet traffic from accessing internal servers: for example, the website will have a limited number of publicly facing servers that receive HTTP requests from visitors and send requests on to other servers that are publicly inaccessible. A common example is a database server, which is often inaccessible to the internet. When you’re logging into a site that communicates with a database server, you might submit a username and password through a regular web form. The website would receive your HTTP request and perform its own request to the database server using your credentials. Then the database server would respond to the web application server, and the web application server would relay the information to you. During this process, you’re often not aware that the remote database server exists, and you should have no direct access to the database.</p>&#13;
<p class="indent">Vulnerable servers that allow attacker control of requests to internal servers could expose private information. For example, if an SSRF existed in the preceding database example, it might allow an attacker to send requests to the database server and retrieve information they shouldn’t have access to. SSRF vulnerabilities provide attackers access to a broader network to target.</p>&#13;
<p class="indent">Suppose you find an SSRF, but the vulnerable site doesn’t have internal servers or those servers aren’t accessible via the vulnerability. In that case, check whether you can perform requests to arbitrary external sites from the vulnerable server. If you can exploit the target server to communicate with a server you control, you can use the requested information from it to learn more about the software the target application is using. You might also be able to control the response to it.</p>&#13;
<p class="indent">For example, you might be able to convert external requests to internal requests if the vulnerable server follows redirects, a trick Justin Kennedy pointed out to me. In some cases, a site won’t allow access to internal IPs but will contact external sites. If so, you can return an HTTP response with a status code of 301, 302, 303, or 307, which are types of redirects. Because you control the response, you can point the redirection to an internal IP address to test whether the server will follow the 301 response and make an HTTP request to its internal network.</p>&#13;
<p class="indent">Alternatively, you could use the response from your server to test for other vulnerabilities, such as SQLi or XSS, as discussed in “<a href="ch10.xhtml#ch10lev1sec4">Attacking Users with SSRF Responses</a>” on <a href="ch10.xhtml#page_98">page 98</a>. The success of this depends on how the targeted application is using the response from the forged request but it often pays to be creative in these situations.</p>&#13;
<p class="indent">The least impactful situation is when an SSRF vulnerability only allows you to communicate with a limited number of external websites. In those cases, you might take advantage of an incorrectly configured blacklist. For instance, suppose a website can communicate externally <span epub:type="pagebreak" id="page_97"/>with <em>www.&lt;example&gt;.com</em> but only validates that the URL provided ends in <em>&lt;example&gt;.com</em>. An attacker could register <em>attacker&lt;example&gt;.com</em>, allowing the attacker to control a response to the target site.</p>&#13;
<h3 class="h3" id="ch10lev1sec2"><strong>Invoking GET vs. POST Requests</strong></h3>&#13;
<p class="noindent">After you verify that you can submit an SSRF, confirm whether you can invoke a <span class="literal">GET</span> or <span class="literal">POST</span> HTTP method to exploit the site. HTTP <span class="literal">POST</span> requests can be more significant if an attacker can control the <span class="literal">POST</span> parameters; <span class="literal">POST</span> requests often invoke state-changing behavior, such as creating user accounts, invoking system commands, or executing arbitrary code depending on what other applications the vulnerable server can communicate with. HTTP <span class="literal">GET</span> requests, on the other hand, are often associated with exfiltrating data. Because <span class="literal">POST</span> request SSRFs can be complex and depend on the system, in this chapter we’ll focus on bugs that use <span class="literal">GET</span> requests. To learn more about <span class="literal">POST</span> request–based SSRF, read Orange Tsai’s presentation slides from Black Hat 2017 at <em><a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf">https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf</a></em>.</p>&#13;
<h3 class="h3" id="ch10lev1sec3"><strong>Performing Blind SSRFs</strong></h3>&#13;
<p class="noindent">After confirming where and how you can make a request, consider whether you can access the response of a request. When you can’t access a response, you’ve found a <em>blind SSRF</em>. For example, an attacker might have access to an internal network through SSRF but be unable to read HTTP responses to the internal server requests. So, they’ll need to find an alternative means of extracting information, usually by using timing or the Domain Name System (DNS).</p>&#13;
<p class="indent">In some blind SSRFs, response times can reveal information about the servers being interacted with. One way of exploiting response times is to <em>port scan</em> inaccessible servers. <em>Ports</em> pass information to and from a server. You scan ports on a server by sending a request and seeing whether they respond. For example, you can try to exploit an SSRF on an internal network by port scanning internal servers. By doing so, you might determine whether the server is open, closed, or filtered based on whether a response from a known port (like port 80 or 443) returns in 1 second or 10 seconds. <em>Filtered ports</em> are like a communication black hole. They don’t reply to requests, so you’ll never know whether they’re open or closed, and the request will time out. In contrast, a quick reply might mean the server is open and accepting communication or is closed and not accepting communication. When you’re exploiting SSRF to port scan, try to connect to common ports, such as 22 (used for SSH), 80 (HTTP), 443 (HTTPS), 8080 (alternate HTTP), and 8443 (alternate HTTPS). You’ll be able to confirm whether responses differ and deduce information from those differences.</p>&#13;
<p class="indent">DNS is a map for the internet. You can try to invoke DNS requests using internal systems and control the address of the request, including the subdomain. If you’re successful, you might be able to smuggle information <span epub:type="pagebreak" id="page_98"/>from blind SSRF vulnerabilities. To exploit a blind SSRF in this way, you append the smuggled information as a subdomain to your own domain. The targeted server then performs a DNS lookup to your site for that subdomain. For example, let’s say you find a blind SSRF and can execute limited commands on a server but can’t read any responses. If you can invoke DNS lookups while controlling the lookup domain, you can add the SSRF output to a subdomain and use the command <span class="literal">whoami</span>. This technique is commonly referred to as <em>out-of-band (OOB) exfiltration</em>. When you use the <span class="literal">whoami</span> command on the subdomain, the vulnerable website sends a DNS request to your server. Your server receives a DNS lookup for <em>data.&lt;yourdomain&gt;.com</em>, where <em>data</em> is the output from the vulnerable server’s <span class="literal">whoami</span> command. Because URLs can only include alphanumeric characters, you’ll need to encode the data using base32 encoding.</p>&#13;
<h3 class="h3" id="ch10lev1sec4"><strong>Attacking Users with SSRF Responses</strong></h3>&#13;
<p class="noindent">When you can’t target internal systems, you can instead try to exploit SSRFs that impact users or the application itself. If your SSRF isn’t blind, one way of doing so is to return malicious responses to the SSRF request, such as cross-site scripting (XSS) or SQL injection (SQLi) payloads, which execute on the vulnerable site. Stored XSS payloads are especially significant if other users regularly access them, because you can exploit these payloads to attack the users. For example, suppose <em>www.&lt;example&gt;.com/picture?url=</em> accepted a URL to fetch an image for your account profile in the URL parameter. You could submit a URL to your own site that returns an HTML page with a XSS payload. So the full URL would be <em>www.&lt;example&gt;.com/picture?url=&lt;attacker&gt;.com/xss</em>. If <em>www.&lt;example&gt;.com</em> saved the payload’s HTML and rendered it as the profile image, the site would have a stored XSS vulnerability. But if the site rendered the HTML payload and didn’t save it, you could still test whether the site prevented CSRF for that action. If it didn’t, you could share the URL <em>www.&lt;example&gt;.com/picture?url=&lt;attacker&gt;.com/xss</em> with a target. If the target visited the link, the XSS would fire as a result of the SSRF and make a request to your site.</p>&#13;
<p class="indent">When you’re looking for SSRF vulnerabilities, keep an eye out for opportunities to submit a URL or IP address as part of some site functionality. Then consider how you could leverage that behavior to either communicate with internal systems or combine it with some other type of malicious behavior.</p>&#13;
<h3 class="h3" id="ch10lev1sec5"><strong>ESEA SSRF and Querying AWS Metadata</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://play.esea.net/global/media_preview.php?url=/">https://play.esea.net/global/media_preview.php?url=/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/">http://buer.haus/2016/04/18/esea-server-side-request-forgery-and-querying-aws-meta-data/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> April 11, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $1,000</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_99"/>In some cases, you can exploit and demonstrate the impact of an SSRF in multiple ways. E-Sports Entertainment Association (ESEA), a competitive video gaming community, opened a self-run bug bounty program in 2016. Immediately after ESEA launched the program, Brett Buerhaus used <em>Google dorking</em> to quickly search for URLs ending in the <em>.php</em> file extension. Google dorking uses Google search keywords to specify where a search is performed and the type of information looked for. Buerhaus used the query <em>site:<a href="https://play.esea.net/">https://play.esea.net/</a> ext:php</em>, which tells Google to return results only for the site <em><a href="https://play.esea.net/">https://play.esea.net/</a></em> when a file ends in <em>.php</em>. Older site designs serve web pages that end with <em>.php</em> and can indicate a page is using outdated functionality, making it a good place to look for vulnerabilities. When Buerhaus ran the search, he received the URL <em><a href="https://play.esea.net/global/media_preview.php?url=">https://play.esea.net/global/media_preview.php?url=</a></em> as part of the results.</p>&#13;
<p class="indent">This result is notable because of the parameter <span class="literal">url=</span>. The parameter indicates ESEA could be rendering content from external sites defined by the URL parameter. When you’re looking for SSRF, the URL parameter is a red flag. To begin testing, Buerhaus inserted his own domain into the parameter to create the URL <em><a href="https://play.esea.net/global/media_preview.php?url=http://ziot.org">https://play.esea.net/global/media_preview.php?url=http://ziot.org</a></em>. He received an error message that ESEA was expecting the URL to return an image. So he tried the URL <em><a href="https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png">https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png</a></em> and was successful.</p>&#13;
<p class="indent">Validating file extensions is a common approach to secure functionality where users can control parameters that make server-side requests. ESEA was limiting the URL rendering to images, but that didn’t mean it was validating URLs properly. Buerhaus added a null byte (<em>%00</em>) to the URL to start his testing. In programming languages in which the programmer needs to manage memory manually, a null byte terminates strings. Depending on how a site implements its functionality, adding a null byte might cause the site to end the URL prematurely. If ESEA was vulnerable, instead of making a request to <em>https://play.esea.net/global/media_preview.php?url=http://ziot.org%00/1.png</em>, the site would make the request to <em><a href="https://play.esea.net/global/media_preview.php?url=http://ziot.org">https://play.esea.net/global/media_preview.php?url=http://ziot.org</a></em>. But Buerhaus found that adding a null byte didn’t work.</p>&#13;
<p class="indent">Next, he tried adding additional forward slashes, which divide parts of a URL. Input after multiple forward slashes is often ignored because multiple slashes don’t conform to a URL’s standard structure. Instead of making a request to <em><a href="https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png">https://play.esea.net/global/media_preview.php?url=http://ziot.org///1.png</a></em>, Buerhaus hoped the site would make a request to <em><a href="https://play.esea.net/global/media_preview.php?url=http://ziot.org">https://play.esea.net/global/media_preview.php?url=http://ziot.org</a></em>. This test also failed.</p>&#13;
<p class="indent">In his final attempt, Buerhaus changed the <em>1.png</em> in his URL from part of the URL to a parameter by converting the forward slash to a question mark. So instead of <em><a href="https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png">https://play.esea.net/global/media_preview.php?url=http://ziot.org/1.png</a></em>, he submitted <em><a href="https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png">https://play.esea.net/global/media_preview.php?url=http://ziot.org?1.png</a></em>. The first URL submits the request to his site looking for <em>/1.png</em>. But the second URL causes the request to be made to the site home page <em><a href="http://ziot.org">http://ziot.org</a></em> with <em>1.png</em> as a parameter in the request. As a result, ESEA rendered Buerhaus’s <em><a href="http://ziot.org">http://ziot.org</a></em> web page.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>Buerhaus had confirmed that he could make external HTTP requests and the site would render the response—a promising start. But invoking requests to any server might be an acceptable risk to companies if the server doesn’t disclose information or the website doesn’t do anything with the HTTP response. To escalate the severity of the SSRF, Buerhaus returned an XSS payload in his server’s response, as described in “<a href="ch10.xhtml#ch10lev1sec4">Attacking Users with SSRF Responses</a>” on <a href="ch10.xhtml#page_98">page 98</a>.</p>&#13;
<p class="indent">He shared the vulnerability with Ben Sadeghipour to see if they could escalate it. Sadeghipour suggested submitting <em>http://169.254.169.254/latest/meta-data/hostname</em>. This is an IP address that Amazon Web Services (AWS) provides for sites it hosts. If an AWS server sends an HTTP request to this URL, AWS returns metadata about the server. Usually, this feature helps with internal automation and scripting. But the endpoint can also be used to access private information. Depending on the site’s AWS configuration, the endpoint <em>http://169.254.169.254/latest/meta-data/iam/security-credentials/</em> returns the Identify Access Manager (IAM) security credentials for the server performing the request. Because AWS security credentials are difficult to configure, it’s not uncommon for accounts to have more permissions than required. If you can access these credentials, you can use the AWS command line to control any service the user has access to. ESEA was in fact hosted on AWS, and the internal host name of the server was returned to Buerhaus. At this point, he stopped and reported the vulnerability.</p>&#13;
<h4 class="h4" id="ch10lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Google dorking can save you time when you’re looking for vulnerabilities that require URLs set up in a specific way. If you use the tool to look for SSRF vulnerabilities, watch out for target URLs that appear to be interacting with external sites. In this case, the site was exposed by the URL parameter <span class="literal">url=</span>. When you find an SSRF, think big. Buerhaus could have reported the SSRF using the XSS payload, but that wouldn’t have been nearly as impactful as accessing the site’s AWS metadata.</p>&#13;
<h3 class="h3" id="ch10lev1sec6"><strong>Google Internal DNS SSRF</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://toolbox.googleapps.com/">https://toolbox.googleapps.com/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/">https://www.rcesecurity.com/2017/03/ok-google-give-me-all-your-internal-dns-information/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> January 2017</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Undisclosed</p>&#13;
<p class="noindent">Sometimes sites are meant to perform HTTP requests to external sites only. When you find sites with this functionality, check whether you can abuse it to access internal networks.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_101"/>Google provides the site <em><a href="https://toolbox.googleapps.com">https://toolbox.googleapps.com</a></em> to help users debug issues they’re having with Google’s G Suite services. That service’s DNS tool caught Julien Ahrens’s (<em><a href="http://www.rcesecurity.com">www.rcesecurity.com</a></em>) attention because it allowed users to perform HTTP requests.</p>&#13;
<p class="indent">Google’s DNS tools include dig, which acts just like the Unix <span class="literal">dig</span> command and allows users to query domain name servers for a site’s DNS information. DNS information maps an IP address to a readable domain, such as <em>www.&lt;example&gt;.com</em>. At the time of Ahrens’s finding, Google included two input fields: one for the URL to map to an IP address and the other for the domain name server, as shown in <a href="ch10.xhtml#ch10fig01">Figure 10-1</a>.</p>&#13;
<div class="image"><a id="ch10fig01"/><img alt="image" src="../images/10fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 10-1: An example query to the Google dig tool</em></p>&#13;
<p class="indent">Ahrens noticed the Name server field in particular because it allows users to specify an IP address to point the DNS query to. This significant discovery suggested that users could send DNS queries to any IP address.</p>&#13;
<p class="indent">Some IP addresses are reserved for internal use. They’re discoverable by internal DNS queries but shouldn’t be accessible through the internet. These reserved IP ranges include:</p>&#13;
<ul>&#13;
<li class="noindent">10.0.0.0 to 10.255.255.255</li>&#13;
<li class="noindent">100.64.0.0 to 100.127.255.255</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_102"/>127.0.0.0 to 127.255.255.255</li>&#13;
<li class="noindent">172.16.0.0 to 172.31.255.255</li>&#13;
<li class="noindent">192.0.0.0 to 192.0.0.255</li>&#13;
<li class="noindent">198.18.0.0 to 198.19.255.255</li>&#13;
</ul>&#13;
<p class="indent">In addition, some IP addresses are reserved for specific purposes.</p>&#13;
<p class="indent">To begin testing the Name server field, Ahrens submitted his site as the server to look up and used the IP address 127.0.0.1 as the Name server. IP address 127.0.0.1 is commonly referred to as the <em>localhost</em>, and a server uses it to refer to itself. In this case, localhost is the Google server executing the dig command. Ahrens’s test resulted in the error “Server did not respond.” The error implies that the tool was trying to connect to its own port 53 (the port that responds to DNS lookups) for information about Ahrens’s site, <em><a href="http://rcesecurity.com">rcesecurity.com</a></em>. The wording “did not respond” is crucial because it implies that the server allows internal connections, whereas wording like “permission denied” would not. This red flag signaled Ahrens to keep testing.</p>&#13;
<p class="indent">Next, Ahrens sent the HTTP request to the Burp Intruder tool so he could begin enumerating internal IP addresses in the 10.<em>x</em>.<em>x</em>.<em>x</em> range. After a couple of minutes, he received a response from one internal 10. IP address (he purposely did not disclose which) with an empty A record, which is a type of record that DNS servers return. Although the A record was empty, it was for Ahrens’s website:</p>&#13;
<p class="programs">id 60520<br/>&#13;
opcode QUERY<br/>&#13;
rcode REFUSED<br/>&#13;
flags QR RD RA<br/>&#13;
;QUESTION<br/>&#13;
www.rcesecurity.com IN A<br/>&#13;
;ANSWER<br/>&#13;
;AUTHORITY<br/>&#13;
;ADDITIONAL</p>&#13;
<p class="indent">Ahrens had found a DNS server with internal access that would respond to him. An internal DNS server usually doesn’t know about external websites, which explains the empty A record. But the server should know how to map to internal addresses.</p>&#13;
<p class="indent">To demonstrate the impact of the vulnerability, Ahrens had to retrieve information about Google’s internal network because information about an internal network shouldn’t be publicly accessible. A quick Google search revealed that Google used the subdomain <em><a href="http://corp.google.com">corp.google.com</a></em> as the base for its internal sites. So Ahrens began brute-forcing subdomains from <em><a href="http://corp.google.com">corp.google.com</a></em>, eventually revealing the domain <em>ad.corp.google.com</em>. Submitting this subdomain to the dig tool and requesting A records for the internal IP address Ahrens had found earlier returned Google’s private DNS information, which was far from empty:</p>&#13;
<p class="programs">id 54403<br/>&#13;
opcode QUERY<br/>&#13;
<span epub:type="pagebreak" id="page_103"/>rcode NOERROR<br/>&#13;
flags QR RD RA<br/>&#13;
;QUESTION<br/>&#13;
ad.corp.google.com IN A<br/>&#13;
;ANSWER<br/>&#13;
ad.corp.google.com. 58 IN A 100.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 172.REDACTED<br/>&#13;
ad.corp.google.com. 58 IN A 100.REDACTED<br/>&#13;
;AUTHORITY<br/>&#13;
;ADDITIONAL</p>&#13;
<p class="indent">Note the references to the internal IP addresses <span class="literal">100.REDACTED</span> and <span class="literal">172.REDACTED</span>. In comparison, the public DNS lookup for <em>ad.corp.google.com</em> returns the following record, which doesn’t include any information about the private IP addresses that Ahrens discovered:</p>&#13;
<p class="programs">dig A ad.corp.google.com @8.8.8.8<br/>&#13;
; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; A ad.corp.google.com @8.8.8.8<br/>&#13;
;; global options: +cmd<br/>&#13;
;; Got answer:<br/>&#13;
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 5981<br/>&#13;
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0<br/>&#13;
;; QUESTION SECTION:<br/>&#13;
;ad.corp.google.com.    IN  A<br/>&#13;
;; AUTHORITY SECTION:<br/>&#13;
corp.google.com.  59  IN  SOA ns3.google.com. dns-admin.google.com. 147615698<br/>&#13;
900 900 1800 60<br/>&#13;
;; Query time: 28 msec<br/>&#13;
;; SERVER: 8.8.8.8#53(8.8.8.8)<br/>&#13;
;; WHEN: Wed Feb 15 23:56:05 2017<br/>&#13;
;; MSG SIZE  rcvd: 86</p>&#13;
<p class="indent">Ahrens also requested the Name servers for <em>ad.corp.google.com</em> using Google’s DNS tools, which returned the following:</p>&#13;
<p class="programs">id 34583<br/>&#13;
opcode QUERY<br/>&#13;
rcode NOERROR<br/>&#13;
flags QR RD RA<br/>&#13;
;QUESTION<br/>&#13;
ad.corp.google.com IN NS<br/>&#13;
;ANSWER<br/>&#13;
ad.corp.google.com. 1904 IN NS hot-dcREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS hot-dcREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS cbf-dcREDACTED<br/>&#13;
<span epub:type="pagebreak" id="page_104"/>ad.corp.google.com. 1904 IN NS vmgwsREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS hot-dcREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS vmgwsREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS cbf-dcREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS twd-dcREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS cbf-dcREDACTED<br/>&#13;
ad.corp.google.com. 1904 IN NS twd-dcREDACTED<br/>&#13;
;AUTHORITY<br/>&#13;
;ADDITIONAL</p>&#13;
<p class="indent">In addition, Ahrens discovered that at least one internal domain was publicly accessible to the internet: a Minecraft server at <em>minecraft.corp.google.com</em>.</p>&#13;
<h4 class="h4" id="ch10lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Be on the lookout for websites that include functionality to make external HTTP requests. When you find them, try pointing the request internally using the private network IP address 127.0.0.1 or the IP ranges listed in the example. If you discover internal sites, try to access them from an external source to demonstrate greater impact. Most likely, they’re only meant to be internally accessible.</p>&#13;
<h3 class="h3" id="ch10lev1sec7"><strong>Internal Port Scanning Using Webhooks</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Easy</p>&#13;
<p class="hang"><strong>URL:</strong> N/A</p>&#13;
<p class="hang"><strong>Source:</strong> N/A</p>&#13;
<p class="hang"><strong>Date reported:</strong> October 2017</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Undisclosed</p>&#13;
<p class="noindent"><em>Webhooks</em> allow users to ask one site to send a request to another remote site when certain actions occur. For example, an ecommerce site might allow users to set up a webhook that sends purchase information to a remote site every time a user submits an order. Webhooks that let the user define the URL of the remote site provide an opportunity for SSRFs. But the impact of any SSRFs might be limited because you can’t always control the request or access the response.</p>&#13;
<p class="indent">While testing a site in October 2017, I noticed I could create custom webhooks. So I submitted the webhook URL as <em>http://localhost</em> to see whether the server would communicate with itself. The site said this URL wasn’t permitted, so I also tried <em>http://127.0.0.1</em>, which also returned an error message. Undeterred, I tried referencing 127.0.0.1 in other ways. The website <em><a href="https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/">https://www.psyon.org/tools/ip_address_converter.php?ip=127.0.0.1/</a></em> lists several alternative IP addresses, including 127.0.1, 127.1, and many others. Both appeared to work.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>After submitting my report, I realized the severity of my finding was too low to warrant a bounty. All I had demonstrated was the ability to bypass the site’s localhost check. To be eligible for a reward, I had to demonstrate that I could compromise the site’s infrastructure or extract information.</p>&#13;
<p class="indent">The site also used a feature called web integrations, which allows users to import remote content to the site. By creating a custom integration, I could provide a remote URL that returns an XML structure for the site to parse and render for my account.</p>&#13;
<p class="indent">To start, I submitted 127.0.0.1 and hoped the site might disclose information about the response. Instead, the site rendered the error 500 “Unable to connect” in place of valid content. This error looked promising because the site was disclosing information about the response. Next, I checked whether I could communicate with ports on the server. I went back to the integration configuration and submitted 127.0.0.1:443, which is the IP address to access and the server port separated by a colon. I wanted to see whether the site could communicate on port 443. Again, I received the error 500 “Unable to connect.” I also received the same error for port 8080. Then I tried port 22, which connects over SSH. This time the error was 503, “Could not retrieve all headers.”</p>&#13;
<p class="indent">Bingo. The “Could not retrieve all headers” response was sending HTTP traffic to a port expecting the SSH protocol. This response differs from a 500 response because it confirms that a connection can be made. I resubmitted my report to demonstrate that I could use web integrations to port scan the company’s internal server because responses were different for open/closed and filtered ports.</p>&#13;
<h4 class="h4" id="ch10lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">If you can submit a URL to create webhooks or intentionally import remote content, try to define specific ports. Minor changes in how a server responds to different ports can reveal whether a port is open or closed or filtered. In addition to differences in the messages the server returns, ports might reveal whether they’re open or closed or filtered by how long it takes the server to respond to the request.</p>&#13;
<h3 class="h3" id="ch10lev1sec8"><strong>Summary</strong></h3>&#13;
<p class="noindent">SSRFs occur when an attacker can leverage a server to perform unintended network requests. But not all requests are exploitable. For example, the fact that a site allows you to make a request to a remote or local server doesn’t mean it’s significant. Identifying the ability to make an unintended request is just the first step in identifying these bugs. The key to reporting them is to demonstrate the full impact of their behavior. In each example in this chapter, the sites allowed HTTP requests to be made. But they didn’t adequately protect their own infrastructure from malicious users.<span epub:type="pagebreak" id="page_106"/></p>&#13;
</body></html>