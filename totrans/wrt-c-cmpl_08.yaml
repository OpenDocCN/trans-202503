- en: '![](../images/pg130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-15.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">COMPOUND
    STATEMENTS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll implement compound statements. Compound statements serve
    two important purposes. As you saw in the two previous chapters, they group together
    other statements and declarations into a single unit that can appear in a larger
    construct, like an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement.
    More interestingly, they also delineate the different *scopes* within a function.
    A variable’s scope is the part of the program where that variable can be used;
    when you declare a variable inside a compound statement, its scope extends only
    to the end of that statement.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll spend a little time in this chapter extending the parser so we can group
    block items together, but our main task will be extending the variable resolution
    pass to keep track of each variable’s scope. We’ll barely change the TACKY generation
    stage, and we won’t touch the lexer or the assembly generation stage at all. Before
    starting on the parser, I’ll give a quick overview of how scoping works in C and
    define some terms that I’ll use later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Scoop on Scopes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A language construct that can contain declarations, and that determines the
    scope of those declarations, is called a *block*. Compound statements and function
    bodies are both blocks. So are loops, which we’ll implement in [Chapter 8](chapter8.xhtml).
    (Technically, <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements
    are too, but that doesn’t matter for our implementation.) A local variable’s scope
    begins at the point where that variable is declared. That means a variable’s scope
    can begin in the middle of a block. Its scope extends until the end of the block
    in which it was declared. For example, in the program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>’s scope
    begins right before its initializer ❶, and extends until the very end of the function
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: A compound statement can appear either on its own or inside another statement.
    In [Listing 7-1](chapter7.xhtml#list7-1), we use a compound statement as the body
    of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Using a compound
    statement as an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement body</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>’s
    scope runs from ❶ to the end of the compound statement ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you enter a new block, you can still use variables from the outer scope,
    as this code fragment illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Although <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is declared
    in the outer scope, we can refer to it when we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    in the inner scope. We therefore initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. But let’s see what
    happens in [Listing 7-2](chapter7.xhtml#list7-2), where we declare another variable
    named <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> inside the inner
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Declaring two
    variables with the same name but different scopes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, when we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    two different variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    are in scope: the one declared in the outer scope ❶ and the one declared in the
    inner scope ❷. In cases like this, we always use the variable declared in the
    innermost scope. As a result, we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. Even though the outer
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is still in scope, we can’t
    access it; it’s *hidden* (or *shadowed*) by the inner one.'
  prefs: []
  type: TYPE_NORMAL
- en: Being hidden is different from being out of scope, because a hidden variable
    can become visible again later in the program. [Listing 7-3](chapter7.xhtml#list7-3),
    which is almost identical to [Listing 7-2](chapter7.xhtml#list7-2), illustrates
    this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: A hidden variable
    becoming visible again</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous example, the first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    ❶ is hidden by the second declaration ❷. But the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement ❸ comes after the end of the compound statement. At that point, the
    second <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is no longer in
    scope, so the first one is visible again. We’ll therefore use the first <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we switched the order of the two statements in the inner block in [Listing
    7-2](chapter7.xhtml#list7-2)? Then we’d have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now when we declare <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> isn’t in scope
    yet, so it doesn’t hide the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> will refer to the first
    declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, so we’ll
    initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can have many layers of nested scopes, as [Listing 7-4](chapter7.xhtml#list7-4)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: Multiple nested
    scopes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we declare three variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with three different scopes. We declare the first <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    at ❶ and the second at ❷. We assign the value <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    to the second <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> at ❸ and
    return it at ❺, so the whole program returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    The third variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    declared at ❹, is never used. We never reach the final <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement at ❻, but if we did, it would return <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    the value of the very first variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    that was declared back at ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We need to handle two error cases related to variable scope. (We covered both
    of these briefly in [Chapter 5](chapter5.xhtml), but detecting them is a bit more
    complicated in programs with multiple scopes.) First, it’s illegal to use a variable
    name if no variable with that name is in scope. [Listing 7-5](chapter7.xhtml#list7-5)
    illustrates this error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Using an undeclared
    variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we declare two different variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    The scope of the first declaration starts at ❶ and ends at ❷. The scope of the
    second declaration starts at ❹ and extends to the end of the function ❺. Neither
    of these declarations is in scope at ❸. It’s an error to use the variable name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> at that point, because
    that name doesn’t refer to anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you can’t have multiple declarations of the same variable name with
    the same scope. We say that two variables have the same scope if their scopes
    end at exactly the same point; that is, if they’re declared in the same block.
    For example, this code fragment is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    is illegal because it has the same scope as the first declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the scoping rules you need to implement, let’s start
    on the parser.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A list of statements and declarations wrapped in braces can be either a function
    body or a compound statement. Let’s define a <samp class="SANS_TheSansMonoCd_W5Regular_11">block</samp>
    AST node to represent both constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that this AST node doesn’t represent <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and won’t represent loops once we implement them in [Chapter 8](chapter8.xhtml),
    even though they’re technically also blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    node to represent compound statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll change the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    node to use <samp class="SANS_TheSansMonoCd_W5Regular_11">block</samp> too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 7-6](chapter7.xhtml#list7-6) gives the new AST definition with these
    changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: The abstract syntax
    tree with compound statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-7](chapter7.xhtml#list7-7) shows the corresponding changes to the
    grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: The grammar with
    compound statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">"{"</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"}"</samp> in the definition of
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><block></samp> are literal braces,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and} indicate repetition.
    You can parse the updated grammar using the recursive descent techniques you’re
    already familiar with. When you’re parsing a <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    symbol, a <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>token will tell
    you that you’ve hit a compound statement, just like the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    keyword signals the beginning of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement and <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> signals
    the start of a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variable Resolution</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll update the variable resolution pass to follow the scoping rules we
    talked about at the start of the chapter. Any local variables that share the same
    name in the original program will receive different names during this pass. In
    later passes, we won’t have to think about scopes at all; because every variable
    will have a unique name, we can convert each variable in the AST to a TACKY variable,
    then a pseudoregister, and finally a memory address, exactly as we’ve done in
    earlier chapters, without worrying about which object each name refers to.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resolving Variables
    in Multiple Scopes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, let’s take another look at the program from [Listing 7-4](chapter7.xhtml#list7-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 7-8](chapter7.xhtml#list7-8) shows how this program looks after variable
    resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: The program from
    [Listing 7-4](chapter7.xhtml#list7-4) after variable resolution</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now every variable has a different name. These new names make explicit which
    variable we’re using at every point. For example, it’s now clear that the variable
    declared at the start of the function (which we’ve renamed to <samp class="SANS_TheSansMonoCd_W5Regular_11">x0</samp>)
    is used only once, at the very end.
  prefs: []
  type: TYPE_NORMAL
- en: Our basic approach to variable resolution is the same as in earlier chapters.
    We’ll traverse the AST, maintaining a map from user-defined names to generated
    names as we go. But now our new scoping rules will dictate how we update this
    map. [Table 7-1](chapter7.xhtml#tab7-1) shows how the variable map will look at
    each point in [Listing 7-4](chapter7.xhtml#list7-4).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Variable Map Throughout [Listing 7-4](chapter7.xhtml#list7-4)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp> | <samp
    class="SANS_Futura_Std_Book_11">(empty map)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> → <samp class="SANS_TheSansMonoCd_W5Regular_11">x0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> → <samp class="SANS_TheSansMonoCd_W5Regular_11">x1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> → <samp class="SANS_TheSansMonoCd_W5Regular_11">x2</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> → <samp class="SANS_TheSansMonoCd_W5Regular_11">x1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> → <samp class="SANS_TheSansMonoCd_W5Regular_11">x0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The state of the variable map changes in two cases. First, when a new variable
    is declared, we add it to the map, overwriting any existing variable with the
    same name. Second, when we exit a block, we revert to the same variable map we
    had before entering that block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first case is already familiar: whenever we encounter a variable declaration,
    we’ll add a map entry. To handle the second case, we’ll make a copy of the variable
    map whenever we enter a new block. As we process that block, we’ll add new entries
    to that copy of the map, leaving the variable map for the outer scope unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic idea of how this pass will work, let’s walk through
    the pseudocode.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Variable
    Resolution Pseudocode</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let’s process declarations. In earlier chapters, the compiler would
    fail if it ever saw two declarations of the same variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But now things are a little more complicated. It’s legal to reuse the same
    variable name in multiple declarations. However, it’s illegal to declare the same
    variable name more than once *in the same block*. To enforce this rule, we’ll
    track two facts about each entry in the variable map: its new autogenerated name
    and whether it was declared in the current block. [Listing 7-9](chapter7.xhtml#list7-9)
    gives the updated pseudocode to handle a declaration. Changes from the previous
    version of this pseudocode, in [Listing 5-9](chapter5.xhtml#list5-9), are bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Resolving a variable
    declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a function that can process block items in order (I’ll call this
    <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_block</samp> in later pseudocode
    listings). You’ve already written this code to process function bodies; now you
    just need to refactor it so you can reuse it to process compound statements too.
    Remember that changes you make while processing one block item (specifically,
    a declaration) must be visible when you process later block items.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also update <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>
    to handle compound statements. [Listing 7-10](chapter7.xhtml#list7-10) gives the
    updated pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>,
    with changes from the previous version in [Listing 5-10](chapter5.xhtml#list5-10)
    bolded. The important detail here is that we’ll pass a *copy* of the variable
    map when we traverse the compound statement, so any declarations we process inside
    the compound statement won’t be visible outside of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Resolving compound
    statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_variable_map</samp>.
    This should create a copy of the variable map with the <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_block</samp>
    flag set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> for every
    entry. That way, we won’t throw an error when we process declarations in the inner
    scope that hide declarations from the outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve made those changes, your variable resolution pass will be able
    to handle nested scopes!  ### <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is extending the TACKY generation stage to handle compound statements.
    It’s pretty straightforward: to convert a compound statement to TACKY, just convert
    each block item inside it to TACKY. Basically, you should handle compound statements
    exactly like you’re already handling function bodies. You don’t need to touch
    later compiler stages at all; once you have TACKY generation working, you’re done
    with the chapter!'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you implemented a new kind of statement by extending just a
    few stages in your compiler. You wrote a more sophisticated variable resolution
    pass that correctly resolves variables in multiple scopes, dramatically expanding
    the set of programs you can compile. Next, you’ll implement loops, <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>
    statements, and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>
    statements. The work you did in this chapter will be especially important when
    you add support for <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops,
    since a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop contains
    two distinct scopes.
  prefs: []
  type: TYPE_NORMAL
