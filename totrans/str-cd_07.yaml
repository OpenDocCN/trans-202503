- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SNOBOL
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SNOBOL is a text pattern matching language developed in the 1960s. Modern programmers
    might find its syntax quaint, and maybe even a tad frustrating, but I suspect
    the power of the language will shine through in the end as we explore its features,
    some of which are still with us in modern languages like Python.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL, like Forth, is a denizen of the later Paleozoic. SNOBOL and Forth are
    of similar vintage, but they are extremely different. Forth is minimal and low
    level. SNOBOL is abstract and surprisingly powerful, though quirky.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore SNOBOL, specifically SNOBOL4, the latest dialect
    of the language. SNOBOL is known for its pattern matching and string processing
    abilities, but it is a general-purpose language. As we’ll see, SNOBOL’s data handling
    facilities are surprisingly sophisticated and include an atypical level of flexibility.
    As Michael Shafto put it in 1982, “SNOBOL4 is the Alice’s Restaurant of programming
    languages: you can get anything you want” (see “Artificial Intelligence Programming
    in SNOBOL4,” available on this book’s GitHub site).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore SNOBOL by reviewing the structure of the language and the interesting
    abilities it provides. We’ll walk through its features, look at examples, and
    finish by building a simple machine learning classifier to link our explorations
    with the hopes of at least some computer scientists from the 1980s. As before,
    we’ll end with some closing thoughts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install SNOBOL, download it from *[http://ftp.ultimate.com/snobol4/](http://ftp.ultimate.com/snobol4/)*
    by grabbing *snobol4-2.3.1.tar.gz*, or any later version you see on that site.
    Save the file in a subdirectory called *SNOBOL*. Once you have the file, expand
    it and build the SNOBOL executable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The commands above generate a lot of output. Some are from the C compiler, including
    a few warnings we can safely ignore. The rest are from SNOBOL test scripts. When
    all is said and done, if you see a message about sending timing info to `timing@snobol4.org`,
    you’ll know that SNOBOL was successfully built and is running correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Origins and Philosophy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SNOBOL (“StriNg Oriented and symBOlic Language”) was developed during the 1960s
    at AT&T Bell Laboratories by David Farber, Ralph Griswold, and Ivan Polonsky.
    The name *SNOBOL* is a backronym, meaning the developers began with the acronym
    they wanted and worked backward to ensure they got it.
  prefs: []
  type: TYPE_NORMAL
- en: According to Farber, the original name for the language was “Symbolic EXpression
    Interpreter,” or SEXI. In the 1960s, running a computer program meant walking
    to the machine room with a stack of punch cards. Typically, the program name and
    username were marked on the deck. So Farber handed the young woman running the
    programs a stack labeled “SEXI Farber.” She read the name and laughingly said,
    “That’s what you think.” Clearly, a new name was needed. After much frustration,
    someone complained that they didn’t have a snowball’s chance in hell of coming
    up with a name; thus “SNOBOL” was born. The spelling pays homage to other similarly
    named languages of the time like COBOL and ALGOL. (Farber posted this story to
    his Interesting-People mailing list in December 2008.)
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL’s claim to fame is its powerful pattern-matching abilities. Current programming
    languages often rely on regular expressions, which have a separate history from
    SNOBOL, but SNOBOL’s matching skills were perfectly suited to the sort of highly
    structured data processing that was the focus of most computer mainframe use at
    the time. We’ll explore pattern matching throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL’s philosophy might best be summed up as “all the world’s a string.” Strings
    are almost everything in SNOBOL. Data in the 1960s was typically textual, like
    records with fixed sizes and fields. SNOBOL’s pattern matching made processing
    such data (relatively) straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Even though SNOBOL manipulated structured text data, it did not itself make
    use of structured programming. Thus, there are no `for` or `while` loops in SNOBOL.
    For that matter, SNOBOL lacks even basic `if-then` constructs. The only way to
    control program flow is by using what amounts to a `goto` statement. However,
    in SNOBOL, gotos are rather flexible. One of SNOBOL’s unique concepts is that
    every line of code either succeeds or fails and where the program goes next depends
    on that fact. We’ll see this in action as we work through the examples. In SNOBOL,
    failure is definitely an option. In fact, it’s a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL is dynamically typed and able to create new variables and data structures
    on the fly. SNOBOL can even create new code on the fly, though we won’t be so
    ambitious here. SNOBOL supports powerful arrays and tables, the latter of which
    are much like Python dictionaries. User-defined data structures are also available.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn SNOBOL is to use SNOBOL. It really must be seen to be
    believed. So without further ado, let’s take a walk in the snow.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll begin by learning how to get SNOBOL to do basic things like print “Hello,
    world!” Once we’ve figured that out, we’ll move to variables and user-defined
    data types. Next come arrays and tables, SNOBOL’s intrinsic data structures. Patterns
    follow, though some pattern use will already have snuck in. Patterns are the traditional
    reason for using SNOBOL, and are perhaps the one part of the language that best
    distinguishes it from most other languages.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL allows user-defined functions. We’ll see how to define them and learn
    why the process is, to be blunt, ugly. Then we’ll close with disk files and command
    line arguments. We’ll learn how to control a SNOBOL program’s flow as we work
    through the examples, as that’s the best way to learn it. All the files mentioned
    in the following sections are in the *examples* directory under *SNOBOL*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running SNOBOL***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SNOBOL runs interactively if started without a filename. This mode is available
    for quick calculations and testing ideas, but SNOBOL was meant to run code from
    a file or, originally, a stack of punch cards.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-1](ch05.xhtml#ch05list1) gets us started with *hello.sno*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: A SNOBOL greeting*'
  prefs: []
  type: TYPE_NORMAL
- en: This short program already has much to say about SNOBOL. First, comment lines
    begin with an asterisk (`*`). However, unlike in other languages, the asterisk
    *must* be in column 1\. Either the entire line is a comment, or none of it is.
  prefs: []
  type: TYPE_NORMAL
- en: To print something in SNOBOL, we assign it to the special variable `output`.
    SNOBOL is not case sensitive, so `output` and `OUTPUT` are treated the same. The
    thing assigned to `output` is a string or something SNOBOL will implicitly convert
    into a string, like a number.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation is such a common operation in SNOBOL that space is used as the
    operator. So the first `output` statement in [Listing 5-1](ch05.xhtml#ch05list1)
    assigns a string enclosed in single quotes while the second concatenates two strings
    together. Note the use of double quotes. Like Python, SNOBOL allows both kinds.
    As you can see from the next line, SNOBOL implicitly converts numbers, which may
    be integers or floating point, into strings. Lastly, to output a blank line, assign
    nothing. Assigning nothing is also the SNOBOL way of removing things from a string.
    We’ll see that in action when using patterns.
  prefs: []
  type: TYPE_NORMAL
- en: All SNOBOL programs end with `end`. Note that `end` is in column 1 and all the
    `output` statements are indented. SNOBOL doesn’t care how far statements are indented,
    only that they don’t begin in column 1\. The only things allowed in column 1 are
    `*` for comments, `+` for line continuation (which is seldom used now), and labels,
    including `end`.
  prefs: []
  type: TYPE_NORMAL
- en: You can run *hello.sno* like you’d run a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output of [Listing 5-1](ch05.xhtml#ch05list1) implies that SNOBOL always
    prints the string assigned to `output` on a line. There is no easy way to output
    a partial line followed by more text before ending the line. SNOBOL is line oriented,
    both for output and input. Thus, it is up to the programmer to build the entire
    line first before assigning it to `output`.
  prefs: []
  type: TYPE_NORMAL
- en: Now run [Listing 5-2](ch05.xhtml#ch05list2), *hello2.sno*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-2: Hello, hello, hello*'
  prefs: []
  type: TYPE_NORMAL
- en: When you get bored, use CTRL-C to interrupt the program. This is our first SNOBOL
    loop. In SNOBOL, every line has the opportunity to execute a goto. The first part
    of the line, in column 1, is a label, `loop`. Labels are the targets SNOBOL uses
    when the goto portion of a line is executed. Labels, and other identifiers, must
    start with a letter. After that, letters, numbers, and underscores are allowed.
    Note that labels are global. That is, they must be unique across the entire program.
    Also, SNOBOL lines get rather lengthy and full of spaces, so we’ll remove extra
    spaces present in the source code files to save space in the text.
  prefs: []
  type: TYPE_NORMAL
- en: The goto portion of a SNOBOL line comes at the end. The number of spaces before
    the goto can vary, but no code comes after the goto. The colon (`:`) begins the
    goto. Target labels are enclosed in parentheses. We’ll encounter more sophisticated
    gotos as we proceed. Note that if there is no goto, control proceeds to the next
    line of code as in most programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: One more item is worth noting here. The goto in [Listing 5-2](ch05.xhtml#ch05list2)
    always executes whether the line succeeds or fails. Granted, this line will never
    fail, but we’ll see other lines that do and that indeed must fail. It’s part of
    how the language works. Forgetting to distinguish between success and failure
    and using a goto that always executes can lead to strange behavior. Of course,
    the potential dangers of `goto` statements are well known—see Edsger Dijkstra’s
    famous 1968 paper “Go To Statement Considered Harmful” (*[https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf)*).
    However, with SNOBOL, it’s all we have to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-3](ch05.xhtml#ch05list3) introduces a few new SNOBOL concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-3: A bit of interaction*'
  prefs: []
  type: TYPE_NORMAL
- en: The first new concept is showing how to get input from the keyboard by referencing
    `input`; it returns a string that is assigned to the variable `name`. Notice that
    the variable `name` was not declared. Like Python, SNOBOL is dynamically typed,
    meaning that variables are created on demand and can hold whatever data is assigned
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: The next line needs parsing. It’s an assignment to `output`, so it will ultimately
    print something on the screen. We see a constant string followed by `name`. There
    is space between them, so we expect the two to become a string using the name
    entered by the user. But what’s this `differ` thing? And the goto section is new,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the goto. It’s `:f(again)`. The colon begins the goto. The
    `f` stands for failure. If the line fails, goto `again`, the line that asks for
    the user’s name. Okay, this seems reasonable; if the user’s input isn’t valid,
    ask again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `differ` part: `differ` is a SNOBOL predicate. Like all predicates,
    its purpose is to determine whether something is true or false. However, unlike
    in any other programming language I’ve ever encountered, SNOBOL predicates don’t
    return true or false. If the predicate is false, the function *fails*, and if
    any portion of a SNOBOL line fails, the entire line fails. If a line fails and
    there is a goto for a failure condition, that goto is then executed. So if `differ`
    fails, the line fails, and flow continues with the line labeled `again`.'
  prefs: []
  type: TYPE_NORMAL
- en: Truth in SNOBOL is the null string. I’m sure there’s a deep, philosophical implication
    to truth being null and empty, but we’ll stick with computer programming and avoid
    the headache. SNOBOL predicates that are true return the null string. So `differ`
    takes two objects and asks if they are not the same. Here the objects are whatever
    was assigned to `name` and SNOBOL’s constant for an empty string, `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line, then, is checking to see if the user pressed ENTER without typing
    anything. If so, `differ` fails and program flow returns to `again`. If the user
    enters some text, `differ` succeeds and returns the empty string, which, because
    it’s separated from the string constant by a space, is concatenated with the string
    and the name. Concatenating a null string doesn’t change anything. It’s like adding
    zero. So the line succeeds and `output` is assigned. The trick of using a predicate
    that concatenates a null string to a line is a common one in SNOBOL. However,
    the predicate doesn’t need to be used that way; it can be on a line by itself.
    For example, the following code works just as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the `differ` is false, it fails, and the loop happens. If `differ` is true,
    the null string has no effect and the `output` proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: We have figured out how to print strings and get user input and store it in
    a variable. We were also introduced to the overall structure of a SNOBOL program
    and learned a bit about gotos. Let’s continue our exploration by concentrating
    on variables and data types.
  prefs: []
  type: TYPE_NORMAL
- en: '***Variables and Data Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we’ve already seen, SNOBOL variables are created on demand and can hold any
    value. Strings, integers, and floats are SNOBOL’s primitive data types. In this
    section, we’ll work with these primitives and then go beyond them to create custom
    data types. This is the SNOBOL equivalent of structures in other languages like
    C.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integers and Floats**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 5-4](ch05.xhtml#ch05list4) presents *temperature.sno*, a simple menu-driven
    program to convert between Fahrenheit and Celsius temperatures.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-4: Temperature conversion*'
  prefs: []
  type: TYPE_NORMAL
- en: The menu asks for the type of conversion or `q` to quit. The variable `menu`
    holds the user’s selection. Next comes a new predicate, `ident`. As you likely
    surmised from the name, `ident` is the opposite of `differ`; it’s true when the
    arguments are identical. Notice that `menu` is compared to the string constant
    `'2'` and not just 2\. This is one place where SNOBOL’s permissive automatic string
    conversion is not applied. The value returned by `input` is always a string, so
    we must use a string with `ident`. If we did use 2 and not `'2'`, there would
    be no error, but the predicate would fail, and because there is no fail goto defined,
    SNOBOL would proceed to the next line instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `ident` line shows us a new form of goto, `:s(CtoF)`. The `s` means success,
    and tells SNOBOL where to go if the line does not fail. In this case, not failing
    means the user selected option two. Thus, the program jumps to the label `CtoF`
    to convert Celsius to Fahrenheit. Likewise, the following line jumps to the end
    if the user entered a `q`. If the user entered neither `2` nor `q`, execution
    falls through to the code marked `F to C`.
  prefs: []
  type: TYPE_NORMAL
- en: The conversions ask the user for a temperature, perform the proper conversion,
    report the result, and then jump back to `menu`. The conversions also do something
    subtle behind the scenes. The requested temperature is assigned to either `F`
    or `C`, which are then used in the conversion equation. In this case, SNOBOL does
    automatically convert the input to a number. Unless the user explicitly enters
    a decimal point or uses scientific notation, the resulting number is an integer;
    otherwise, it’s a float. This means the programmer is responsible for ensuring
    that expressions perform the proper conversion as to type. To make the input an
    integer, multiply by 1\. To make the input a float, multiply by 1.0 or use the
    `convert` function, which shows up later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There is more to notice in [Listing 5-4](ch05.xhtml#ch05list4). Look carefully
    at how we’ve written the conversion formulas. First, we use decimal points to
    force floating-point computation. Without them, the division operation would use
    integer math, though the expected promotion from integer to float happens if there
    is a float in the expression. However, be careful because each subexpression needs
    a float as well. In that case, `(9 / 5) * 100.0 + 32.0` would be `132` rather
    than `212` because the fraction is pure integer math returning 1 instead of 1.8.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are spaces around each of the operators in the conversions.
    These are not just for readability; SNOBOL requires them. Forgetting a space before
    or after an operator is an error, as SNOBOL will happily point out to you. Lastly,
    SNOBOL lacks the format specifiers found in languages like C and Python. SNOBOL
    expects the programmer to convert the number to a string with appropriate spacing
    and justification to format output. You’re on your own when formatting output
    in SNOBOL.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-4](ch05.xhtml#ch05list4) implemented a simple menu by checking the
    user’s input with `ident`. SNOBOL also allows *computed gotos*. A computed goto
    uses an expression to determine the target label. [Listing 5-5](ch05.xhtml#ch05list5)
    shows *menu.sno*, which implements a simple menu with a computed goto.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-5: Using a computed goto*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu loop asks the user to select an entrée, then outputs the name of the
    selected entrée. Not a particularly useful program, but it does have one interesting
    feature: `($(''menu'' menu))`.'
  prefs: []
  type: TYPE_NORMAL
- en: The label matching the string formed by the expression inside `$(...)` is the
    goto’s target. The `$(...)` syntax is a form of indirection that tells SNOBOL
    to build the target label on the fly using the expression inside the parentheses.
    The expression is `'menu' menu`, which concatenates the word *menu* with the user’s
    number. Naturally, an actual application would validate the user’s input first.
  prefs: []
  type: TYPE_NORMAL
- en: Jumping to the proper label updates `order` and the desired entrée is displayed
    before jumping back to `loop`. If the user selects option four, the program jumps
    to label `menu4`, which falls through to `end` to exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Indirection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider the following sequence of SNOBOL instructions from an interactive session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first line assigns `123` to `a`. The second uses the *name operator* (`.`)
    to assign the name of `a` to `b`. In SNOBOL, the name of a variable is similar
    to the address of a variable in languages like C. The third line sets `c` to the
    string `'a'`. Then come a series of `output` statements.
  prefs: []
  type: TYPE_NORMAL
- en: The first displays `a` returning `123`, as expected. The second outputs `b`,
    which returns the name of `a`, `A`. SNOBOL is case insensitive, so the name of
    a variable is shown in all caps. The third `output` prints the string `'a'`, again,
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The last three `output` statements are more interesting. They all use indirect
    references (`$`) to output not the value of the variable, but the value of the
    variable whose name is in the first variable. The variable `b` was assigned to
    the name of `a`, meaning it is the string `'A'`. So the indirect reference looks
    to `b` to get the string `'A'` and then looks for a variable called `A`, finds
    it, and returns *its* value. So the output of `$b` is `123`, the value of `a`.
    Using a string with the variable name works as well, which is why the output of
    `$c` is also the value of `a`. Lastly, the name operator and indirect reference
    are inverses of each other, so `$.a` means “name of `a` indirectly referenced
    back to `a`,” resulting in the value of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-6](ch05.xhtml#ch05list6) shows another indirection example, that
    of the file *indirect.sno*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-6: Another indirection example*'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the listing before reading further to see if you can guess what
    the output will be. Notice that the `output` statements use string concatenation
    to output two variables on one line with a single space between them. Read on
    when ready to see what SNOBOL says the output should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'SNOBOL reports the following as the output of [Listing 5-6](ch05.xhtml#ch05list6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line of [Listing 5-6](ch05.xhtml#ch05list6) shouldn’t be mysterious.
    It’s normal variable output; `cosa1` and `cosa2` are the literal strings `'thing1'`
    and `'thing2'`.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, the second output line is a bit of a surprise. The code assigns
    variables `thing1` and `thing2` to `output`, but those variables are not explicitly
    defined in the code. The lines that create them are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: where the indirect reference is used to assign not to `cosa1` and `cosa2`, but
    to the variables created by the current value of `cosa1` and `cosa2`, which are
    `'thing1'` and `'thing2'`. Therefore, `thing1` equals `'mea1'` and `thing2` equals
    `'mea2'`.
  prefs: []
  type: TYPE_NORMAL
- en: The next pair of lines in [Listing 5-6](ch05.xhtml#ch05list6) are similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To create two new variables, `mea1` and `mea2` assigned `'kitu1'` and `'kitu2'`,
    respectively. This explains why the third line of output is `kitu1 kitu2`. The
    indirect reference on `thing1`, containing `'mea1'`, returns the value of `mea1`,
    which is `'kitu1'`, and likewise for `thing2`. Because they were created by assigning
    to `$thing1` and `$thing2`, the next output line makes sense, too.
  prefs: []
  type: TYPE_NORMAL
- en: The final assignment uses indirection twice on `cosa1`. The first indirection,
    that is, the rightmost `$`, returns `thing1`. The second indirection on `thing1`
    returns `mea1`’s value, which is `'kitu1'`. The same is true for `$$cosa2`.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL’s indirection and dynamic creation of variables during runtime are quite
    powerful and equally confusing if not used carefully. For the curious, *cosa*
    means “thing” in Spanish. Likewise, *mea* is Hawaiian for “thing” and *kitu* is
    Swahili for, you guessed it, “thing.”
  prefs: []
  type: TYPE_NORMAL
- en: '**User-Defined Data Types**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: User-defined data types are created with the function `data`, which accepts
    a *string* as its argument. The string defines the name of the new type and the
    names of the elements of the type. SNOBOL creates a function to generate new instances
    of the type and functions with the names of the type elements. The latter functions
    are used to access elements of the type when it is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines a new data type, `complex`, which has two elements `real`
    and `imag`. We can use this data type to hold a complex number. A complex number
    has two parts: a real part and an imaginary part. The real part is a floating-point
    number corresponding to a number on the number line. The imaginary part is also
    a floating-point number which is multiplied, conceptually, by the square root
    of *–*1\. The square root of *–*1 doesn’t exist. No number multiplied by itself
    is negative, so it’s “imaginary.” Even though complex numbers don’t correspond
    to anything in the physical world, their properties are such that they make certain
    calculations vastly simpler. For our purposes, all we care about is that this
    new complex data type has two elements. Notice that the definition of `complex`
    is given as a string. Because of this, SNOBOL can create new data types on the
    fly at runtime, perhaps in response to user input or data read from a file. Also,
    and this is important, the data type string *must not* contain spaces. Thus, `''complex(real,imag)''`
    works, but `''complex(real, imag)''` generates an error.'
  prefs: []
  type: TYPE_NORMAL
- en: After defining `complex`, we immediately create two instances of it, `a` and
    `b`. To create an instance, use the name of the data type and supply a value for
    all the elements. Next are four `output` statements, the first two of which use
    `a` and `b`. In this case, SNOBOL prints the name of the data type, `COMPLEX`.
  prefs: []
  type: TYPE_NORMAL
- en: The final two `output` statements use the `real` and `imag` functions SNOBOL
    created for us when `complex` was defined. We’ll learn how to create user-defined
    functions below. Here, SNOBOL does us a favor by making functions automatically.
    The functions return the respective elements of the `complex` variables passed
    to them. We’ll revisit the `complex` data type when we explore user-defined functions
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arrays and Tables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SNOBOL supports multidimensional arrays with flexible indexing. Array elements
    are not typed and any data can be stored in an array element, including another
    array. This means SNOBOL supports nested arrays—arrays within arrays. Few languages
    have such flexibility with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL also supports associative arrays—or, to use modern terminology, dictionaries—though
    in SNOBOL they are called *tables*, a collection of key-value pairs. Like arrays,
    tables are not restricted in terms of the data they contain. However, unlike arrays,
    tables are not fixed in size and may grow as needed to accommodate more entries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: SNOBOL arrays are created with the `array` function. The function’s argument
    determines the number of dimensions, the range of the indices for each dimension,
    and a default value for each element. Let’s examine different arrays to understand
    how they are defined and accessed. There are many small examples, so each will
    be presented as a code snippet and the resulting value of the element accessed.
    Most of the examples are in *array.sno*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following declarations create different versions of the array `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first is a 1D array with 10 elements indexed from [1, 10]. Like FORTRAN,
    SNOBOL indexes arrays from 1 unless told otherwise. The second is also a 10-element
    vector with indices in [0, 9]. Notice that the array specification is a string.
    This is required to specify nonstandard index ranges. The third line defines a
    3D array. The indices of the first dimension are in [0, 7]. The second dimension
    uses the defaults, [1, 20]. Lastly, the third dimension uses *–*1, 0, and 1 as
    indices. The final line defines a 2D array with indices in [1, 128], specified
    as a string, with each element initialized to 0.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL manages memory independently, meaning that this sequence of array declarations
    is allowed as a sequence of SNOBOL statements. Each new array declaration destroys
    the previous, automatically freeing its memory. If you try allocating a large
    array and get the `Insufficient storage to continue` error, the `-d` command line
    option tells SNOBOL to reserve more memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the argument `10m` allocates 10MB worth of *descriptors*, each of which
    uses 16 bytes. On my system, `-d 300m` took about 15 seconds to initiate an interactive
    session and used about 4.8GB of system memory. The price paid for SNOBOL’s array
    flexibility is speed and memory use compared to standard fixed-data type arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a SNOBOL array in action ([Listing 5-7](ch05.xhtml#ch05list7)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-7: A 1D array*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-7](ch05.xhtml#ch05list7) defines a 1D array of 10 elements with
    indices in [0, 9]. The next three lines assign the array’s elements, first to
    a string, then a float, and lastly, an integer. The next line assigns `A[3]` to
    an array of six elements with indices in [1, 6]. This is a nested array because
    it is part of the larger 10-element array, `A`. To assign elements of the nested
    array requires first selecting the nested array with `A[3]` and then selecting
    the desired element of the nested array, here the first: `A[3][1] = ''nested''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The five `output` statements display the assigned values. There is something
    new here, the `convert` function, which changes a variable’s type. The `output`
    statement is concatenating a string with the value of the array element. However,
    `A[3]` is not something automatically converted into a string. Therefore, `convert`
    is used to represent it as a string. The first argument to `convert` is the object
    to be converted and the second argument is a string naming the target type, in
    this case a string. We’ll use `convert` again later to change between arrays and
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider [Listing 5-8](ch05.xhtml#ch05list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-8: A 2D array*'
  prefs: []
  type: TYPE_NORMAL
- en: The array `B` is 2D with both indices in [1, 128] and all elements are initialized
    to 0\. Assignments follow using both indices. Note that SNOBOL has no limit on
    the number of dimensions an array may use. Element `B[12,45]` has been assigned
    a nested 11×11 array. The assignment to `B[12,45]<5,6>` seems unusual, but it
    isn’t. SNOBOL allows `<` and `>` in place of square brackets for indexing arrays.
    Consider them a relic of the 1960s.
  prefs: []
  type: TYPE_NORMAL
- en: The following two lines define the complex data type we saw above and then use
    it to store a complex number in `B[12,45][1,2]`. The `output` statement displays
    the complex number using the `real` and `imag` functions to extract the real and
    imaginary parts before piecing them together as `3+0.141592i`, which is the usual
    way imaginary numbers are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some languages, like Python, use `j` in place of `i` to indicate a complex
    number. Engineers do this because `i` usually refers to electric current in their
    world. Mathematicians prefer `i` because electric current doesn’t exist in *their*
    world.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now consider [Listing 5-9](ch05.xhtml#ch05list9) with two blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-9: Array references and copying*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first block defines `A` and sets `A[0]` to the string `''xyzzy''`. Next,
    it creates `D` by assigning `A`, after which it immediately sets `D[0]` to `12345`.
    The question is: what does the following `output` statement display? The answer
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is because simple assignment of an array does not copy it; it only makes
    `D` refer to the same object as `A`. This behavior is typical of most programming
    languages. As arrays might occupy a significant portion of memory, it is best
    to copy them only when essential.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the second code block of [Listing 5-9](ch05.xhtml#ch05list9). It
    restores the original value of `A[0]` and creates `E` using the `copy` function
    before assigning `E[0]` the string `'plugh'`. Then come two `output` statements.
    We might guess the output at this point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `copy` function duplicated `A`, so updating `E[0]` did not alter the original
    array. However, be aware that `copy` makes only *shallow* copies. In a shallow
    copy, nested arrays are not copied, only referenced.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tables**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: SNOBOL tables are like Python dictionaries. They associate a key with a value,
    which can also be any type of data. A few examples should suffice to illustrate
    their use (see [Listing 5-10](ch05.xhtml#ch05list10)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-10: Using a table*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-10](ch05.xhtml#ch05list10) shows almost all that is needed to understand
    a table. It first defines the now familiar `complex` data type, followed by a
    table, `t`. Four assignments to `t` follow, each with a different data type as
    the key. The four `output` statements produce'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This might not match your expectations, as there is no `three` in the output.
    To recover the value for a key, the key used must match exactly. The key for `three`
    was `complex(2,3)`. That’s a perfectly valid key, but passing another instance
    of `complex(2,3)` will not find its value because the two do not evaluate to the
    same object in memory. Using `c` as a key does allow `four` to be recovered because
    `c` references the same data structure in memory. The last lesson from [Listing
    5-10](ch05.xhtml#ch05list10) is that referencing a key that doesn’t exist returns
    `null` but is not an error. To check whether a key is in the table, use the `ne`
    predicate to check the value returned against `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The `table` declaration accepts up to two arguments. The first is the table’s
    initial size, the number of entries for which memory has already been allocated.
    Tables are dynamic, meaning they grow as needed. The second argument is the number
    of entries to grow by whenever the table must grow. If no arguments are given,
    `table()` is equivalent to `table(10,10)`. If you know the table will be large
    but mostly fixed when established, use a large first argument and a smaller second
    argument. Conversely, if you don’t know how large the table will be but expect
    that many entries will be added, use a small initial size and a larger second
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-11](ch05.xhtml#ch05list11) defines a table with initial room for
    100 entries, `z`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-11: Another table example*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first four assignments to `z` are straightforward, though recalling the
    value of *π* to eight decimals so it can be used as a key to remember the string
    `''pi''` is admittedly rather silly. The example gets worse. We define an array,
    `a` ➊, and assign the table, `z`, to its seventh element ➋. Then, in the next
    line, we put `a` in the table ➌. We’ve have an odd situation: the table we just
    placed `a` into is referenced by `a` itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The `output` statements generate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We get the integer `2`, the array `a`, the name `pi` from its floating-point
    value to eight decimals, and then the final output, also `pi`. The final output
    was generated by ➍. Because `a` is in `z`, and `z` is in `a`, we can use an arbitrary
    number of pairs of references, first `[a]` to return the array followed by `[7]`
    to get `z` from the array, to finally arrive again at `z` and recover `pi`. Of
    course, this is a ludicrous thing to do, but SNOBOL doesn’t judge.
  prefs: []
  type: TYPE_NORMAL
- en: How can we know what keys a SNOBOL table has? In Python, we can use the `keys`
    method. In SNOBOL, we convert the table to an array to get at the keys. Likewise,
    we can convert a properly structured array into a table. [Listing 5-12](ch05.xhtml#ch05list12)
    illustrates an example of each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-12: Converting tables to arrays and arrays to tables*'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a table ➊ and add three entries. Next, we call `convert` to
    change the table into an array, `x`. The array has *n* × 2 dimensions if there
    are *n* entries in the table. The first column is the key and the second column
    is the value. The keys and values are printed using a simple loop ➌. Notice that
    the loop ends when accessing the array fails because the index, `i`, is too large.
    In SNOBOL, you code for failure.
  prefs: []
  type: TYPE_NORMAL
- en: To go the other way and convert an array into a table, consider ➍. A 2D array
    is created with the first column as the key and the second column as the value.
    Another call to `convert` makes the properly structured array a table ➎.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL arrays and tables are flexible and more advanced than many other languages
    of the time.
  prefs: []
  type: TYPE_NORMAL
- en: And now for something completely different.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Blizzard of Patterns***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll introduce patterns, though a thorough understanding of
    patterns is beyond what we can hope to cover in a single chapter. There are two
    types of pattern statements in SNOBOL. The first applies a pattern to a string.
    The second applies a pattern to a string and updates the portion of the string
    that matched the pattern. We’ll learn about patterns in B. F. Skinner fashion,
    a little bit at a time, with examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**A First Example**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider [Listing 5-13](ch05.xhtml#ch05list13), which presents a simple program
    accepting lines of text from the user until the string `'hello'` appears in one
    of the lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-13: A simple pattern example*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the program calls `input` to return a string. The second string,
    which at first might appear to be concatenated because of the space, is a pattern,
    with the pattern matching a constant string. If the text returned by `input` has
    `'hello'` anywhere within it, the pattern match succeeds. If not, it fails, and
    the goto for failure asks the user for another string.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-13](ch05.xhtml#ch05list13) is an example of the first type of pattern
    matching statement: a *text pattern*. In a pattern, success or failure of the
    match decides what happens next; however, as we’ll see, a pattern can generate
    new variables that hold pieces of the matched pattern. This means that many pattern
    matching statements are assigning data even if they don’t have explicit gotos.'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern matches only an explicit string of characters. If we want to check
    for other options, we use alternation, `|` (with spaces!). Therefore, to accept
    either `'hello'` or `'aloha'`, use `'hello' | 'aloha'` as the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, SNOBOL has many bits and pieces for matching various patterns.
    The ones we’ll examine are `len`, `span`, `pos`, `any`, and `break`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Matching and Updating Strings**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The second pattern statement matches a pattern and updates the text matched
    with new text. See [Listing 5-14](ch05.xhtml#ch05list14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-14: Matching and updating a string*'
  prefs: []
  type: TYPE_NORMAL
- en: The output of this program is `how now blue giraffe?`, where `color` matched
    to change `brown` to `blue`, and `animal` matched to change `cow` to `giraffe`.
    If the match fails, the string is not updated. Note that a match succeeds when
    the first success happens. Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: produces `The black bear approached the brown car`. To update all matches, use
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This example loops for as long as the pattern `'brown'` is found, replacing
    it with `'black'` each time. The output is now `The black bear approached the
    black car`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extracting Information from a String**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What if we want to extract the matched text? When used in a pattern, the name
    operator (`.`) extracts the matched text to a variable. See [Listing 5-15](ch05.xhtml#ch05list15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-15: Capturing the matched text*'
  prefs: []
  type: TYPE_NORMAL
- en: Several new things are happening in [Listing 5-15](ch05.xhtml#ch05list15), so
    let’s go through it carefully. Structurally, the program consists of four pattern
    definitions, which are the variables ending in `pat`. This is followed by a piece
    of example text with a first name, last name, and address. Our goal is to break
    this text apart into its individual fields. The pattern matching line comes next,
    followed by an `output` statement to print the data in a new format.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain what’s happening, line by line. First, we define `dpat` ➊. This
    is a pattern to match one or more instances of a comma, colon, or space. That’s
    what `span` does; it matches the longest possible sequence consisting of nothing
    but the characters in its argument.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes `lpat` ➋. This pattern matches characters up to, but not including,
    the first occurrence of a comma or colon. That’s what `break` does. If the string
    is `abcde:f`, then `break(',:')` matches the string `abcde`, but not the colon.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` is next to the name operator, followed by `last`, with the entire
    expression surrounded by parentheses. The expression matches characters up to,
    but not including, the first comma or colon, and stores them in the variable `last`.
    Looking at line ➎ makes it clear that `lpat` matches the last name.
  prefs: []
  type: TYPE_NORMAL
- en: However, ➋ has a `dpat` hanging at the end. It’s there to match the comma or
    colon that ended the `break`. As SNOBOL attempts to match a pattern, internally,
    it’s moving a *cursor* over the string, character by character, forward and sometimes
    backward to try other options. When the `break` of `lpat` matches, the cursor
    is looking at the comma or colon that ended the `break`. So we use `dpat` to skip
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `fpat` ➌ is nearly identical to ➋; however, the matched text
    is stored in `first`. That is, `fpat` matches the first name. As before, a `dpat`
    at the end of the pattern consumes the comma or colon that ended the `*break*`.
  prefs: []
  type: TYPE_NORMAL
- en: The internal cursor has now matched the last name and first name. The remaining
    pattern, `apat`, uses the special pattern, `rem`, to match the remainder of the
    line and assign it to `address` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: To test the patterns, we define `text` to be a string with a last name, first
    name, and address using a comma and a colon as delimiters along with some extra
    spaces ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we apply the patterns to `text` ➏. Notice that, at first glance, ➏ is
    just a sequence of four variables in a row. However, SNOBOL knows to parse this
    as a string followed by a pattern. The string is `text`; therefore, the remaining
    variables form the pattern. The overall pattern is built by concatenating `lpat`,
    `fpat`, and `apat`. We might, for clarity, put parentheses around the three pattern
    variables. If we wanted to concatenate two or more text strings and then apply
    a pattern, the parentheses would be placed around those variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When ➏ executes, the last name, first name, and address are extracted. To prove
    this, ➐ dumps the same information rearranged to be first name, then last name,
    followed by the address. Notice that `address` is passed to `trim`, the SNOBOL
    function to remove trailing spaces from a string. The output of [Listing 5-15](ch05.xhtml#ch05list15)
    is `''Julius Caesar, address: 1313 Mockingbird Ln''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**More Elaborate Pattern Matching**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at three more quick pattern matching examples. The first two manipulate
    a file of dates. The last one updates Lewis Carroll’s *Alice’s Adventures in Wonderland*
    to give “Bob” a chance to put himself in the story.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-16](ch05.xhtml#ch05list16) maps numeric dates in North American
    format (month, day, year) to European-style dates (day, month, year).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-16: Manipulating dates with patterns, take one*'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern, `pat`, uses `len` to match the specified number of characters,
    regardless of what they are. The first two characters are assigned to `month`,
    followed by a slash or dash; then the next two characters are put in `day`, followed
    by another slash or dash and a four-character year.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-15](ch05.xhtml#ch05list15) is in the file *dates.sno*. There is
    another file in the same directory called *dates.txt* that contains a set of numeric
    dates. For example, the first few lines of the file are'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: with some dates using slashes and some using dashes. A few even use a mix. [Listing
    5-15](ch05.xhtml#ch05list15) uses a `loop` to read the file, line by line. Each
    line is read with `input` using command line redirection and placed into `text`.
    If there is nothing left to read, the `input` command fails and SNOBOL jumps to
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: If the read succeeds, the pattern is applied to `text`, but this time in the
    form `string pattern = update`, where the text matched by `pattern` is replaced
    by the text in `update`. Here, the replacement text is constructed from the day,
    month, and year matched by `pat`, using slashes between elements ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that ➋ has a goto for failure. If the pattern doesn’t match, the input
    string is not a valid date format, so the program jumps to `bad` to output `unknown
    format` before jumping back to the loop to process the next input. If the pattern
    match doesn’t fail, `text` has been updated so it’s `output` before jumping to
    `loop` to read the next date.
  prefs: []
  type: TYPE_NORMAL
- en: Run *dates.sno* with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: to produce
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The final `unknown format` line corresponds to an input of `AVCDe-224*`, which
    is clearly not a valid date.
  prefs: []
  type: TYPE_NORMAL
- en: The next example uses `dates.txt`, but produces full dates instead of numeric
    dates. See [Listing 5-17](ch05.xhtml#ch05list17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-17: Manipulating dates with patterns, take two*'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern, `pat`, is the same as in [Listing 5-16](ch05.xhtml#ch05list16).
    Additionally, we define `m`, an array holding the names of the months.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code runs in the same way as [Listing 5-16](ch05.xhtml#ch05list16) but
    outputs a full date using the number of the month as the index into the array
    of names. Also, notice that both `day` and `year` are multiplied by 1\. The text
    matched is a string. To output the day and year without leading 0s, as there are
    a few three-digit years in `dates.txt`, we convert the strings to integers. [Listing
    5-17](ch05.xhtml#ch05list17) is in the file *dates2.sno*. Run it to produce this
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For our final pattern example, with apologies to Lewis Carroll, we’ll update
    the first part of *Alice’s Adventures in Wonderland* to be *Bob’s Adventures in
    Wonderland.* The text we’ll work with is in the file *alice.txt*, and consists
    of the beginning part of [Chapter 1](ch01.xhtml#ch01).
  prefs: []
  type: TYPE_NORMAL
- en: The code we need is in *alice.sno* and [Listing 5-18](ch05.xhtml#ch05list18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-18: Making Bob’s Adventures in Wonderland*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-18](ch05.xhtml#ch05list18) begins by defining two patterns, `p`
    and `s`. The first uses alternation to match nothing (`null`) or `any` single
    character that is a space, period, comma, question mark, exclamation point, or
    right parenthesis. The second pattern uses `pos` to match cursor position zero,
    that is, the beginning of a line, a space, or a left parenthesis.'
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the program is a loop from `input` to `output` via `loop`.
    Between the input and the output there are seven lines, `s0` through `s6`. Each
    of these lines is a loop (notice the success gotos) and has a similar format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first part is the text read from the input file, `text`. The rest of the
    line up to the equals sign is a pattern. The pattern looks for a match to a word,
    such as the name `'Alice'`, storing the character before the word in `a` and the
    character after in `c`.
  prefs: []
  type: TYPE_NORMAL
- en: The matched text, if any, is replaced by the same leading and trailing character
    with the matched word updated. Thus, “Alice” is replaced with “Bob,” “her” is
    replaced with “his,” and so on. Recall that a match is successful after the first
    one is found, so if there are multiple occurrences of “Alice” in the line, only
    the first will be replaced with “Bob.” So we must loop until the match fails to
    replace all occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: After all seven patterns are tested and matched as much as possible, the updated
    `text` is `output` and the loop begins again until there is no input left.
  prefs: []
  type: TYPE_NORMAL
- en: The first paragraph of *alice.txt* is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The same paragraph after the “Bob” conversion is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The conversion isn’t foolproof, but that isn’t SNOBOL’s fault. There are cases
    in English where the word “her” should be changed to “his” and cases where it
    should become “him.” The code of [Listing 5-18](ch05.xhtml#ch05list18) knows nothing
    of the context, so it always uses “his.”
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to discover concerning SNOBOL patterns. An excellent place
    to learn more is [Chapter 2](ch02.xhtml#ch02) of Griswold, Poage, and Polonsky’s
    *The SNOBOL4 Programming Language* (Prentice Hall, 1971). Versions of the second
    edition are floating around the internet if you care to take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to SNOBOL’s user-defined functions, perhaps the least elegant
    part of the language (aside from relying solely on goto for flow control).
  prefs: []
  type: TYPE_NORMAL
- en: '***Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SNOBOL would be a weak language indeed if it had no facility for users to define
    functions. Thankfully, it does, though the syntax is a bit strange. In this section,
    we’ll learn how to define and use functions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll jump right in with [Listing 5-19](ch05.xhtml#ch05list19). This program,
    in the file *poly.sno*, defines a function to implement arbitrary polynomials
    of the form
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *a**x*² + *b**x* + *c*'
  prefs: []
  type: TYPE_NORMAL
- en: which we use to output (*x*, *y*) pairs for plotting the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-19: A user-defined function*'
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL functions begin with a `define` statement ➊. There are a couple of important
    things to notice about ➊. First, the function declaration is a string. It begins
    with the name of the function (`poly`), followed by an opening parenthesis, the
    list of arguments, and a closing parenthesis. If the function uses local variables,
    they are listed next, separated by commas, as part of the string. Note that the
    string portion of the `define` statement *must not* include spaces. No spaces
    between the arguments, no spaces in the list of local variables, no spaces anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to notice is that the `define` statement ends with a goto (`epoly`).
    This label must jump to just beyond the end of the function’s body, that is, it
    must not include any code that is part of the function. The function’s body is
    the code between the `define` statement and the ending label, which here is `epoly`.
  prefs: []
  type: TYPE_NORMAL
- en: The function body begins with a label matching the function’s name, which is
    `poly` in this case. The body of the function is free to use the arguments, any
    local variables, and any global variables. The value returned by the function
    is assigned to a variable of the same name, as is sometimes done in other programming
    languages. In [Listing 5-19](ch05.xhtml#ch05list19), the variable `poly` is assigned
    the value of the quadratic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exit the function, SNOBOL defines two special goto labels: `return` and
    `freturn`. Use the former if the function was successful and the latter if not.
    The function `poly` always succeeds, so we use `return` to exit.'
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL allows recursion, as shown in [Listing 5-20](ch05.xhtml#ch05list20),
    which implements the factorial function. The factorial of an integer, *n*, is
    *n*! = *n*(*n –* 1)(*n –* 2)*…* 1\. For example, 5! = 5 × 4 × 3 × 2 × 1 = 120.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think about the factorial of *n* is that it’s *n* times the factorial
    of *n –* 1, which is itself *n –* 1 times the factorial of *n –* 2, and so on
    down to 1\. That’s the recursive version. In Python, we might write this process
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: where `fact` calls itself to solve the simpler problem. All recursive functions
    need a base case, something that stops the recursion. In this case, it’s checking
    if *n* is less than 1\. This catches the edge case of 0! = 1.
  prefs: []
  type: TYPE_NORMAL
- en: Translating the recursive formula into SNOBOL leads to [Listing 5-20](ch05.xhtml#ch05list20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-20: A recursive factorial function*'
  prefs: []
  type: TYPE_NORMAL
- en: The definition accepts *n*. The first line of the body implements the base case.
    If *n* > 0, then `eq(n,0)` fails, so `fact` is not assigned and the next line
    is executed. If *n* = 0, `eq(n,0)` succeeds, so we return from the function via
    `s(return)`.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of `fact` implements the recursion. It assigns `fact` to `n`
    times whatever `fact(n - 1)` returns and then it returns via `(return)`.
  prefs: []
  type: TYPE_NORMAL
- en: The main code asks the user for a number and returns the factorial. Run it and
    enter integers in [0,20]. Beyond 20, integers overflow; however, if you enter
    a floating-point number, you can estimate larger factorials. Also, notice the
    use of `convert` to force `n` to be an integer for display purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a function to swap the value of two variables. This should be easy.
    Our first attempt is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: which defines `swap`. The value of `x` is kept in `t`, then `y` is assigned
    to `x` and `t` is assigned to `y`, followed by a return. The main body of the
    program sets *a* = 3 and *b* = 5, outputs their values, calls `swap`, and then
    outputs them again. Running the code produces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is clearly incorrect. The values haven’t changed. Why? The algorithm in
    `swap` is correct, so why didn’t the values change?
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL passes simple variables by *value*, meaning the value of `a` is assigned
    to `x`. So when `x` is updated in the body of `swap`, `a` is not affected. To
    update the variables, we need to pass the data by *reference* so `x` is really
    a synonym for `a`. After that, updates to `x` will affect `a`. Note that SNOBOL
    passes arrays and tables by reference.
  prefs: []
  type: TYPE_NORMAL
- en: The code above is wrong. I don’t want you to use it. However, the code in [Listing
    5-21](ch05.xhtml#ch05list21) does work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-21: Passing variables by reference*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on `swap`. It looks much like the wrong version, but it uses the
    indirection operator (`$`) before each argument, `$x`. Recall that indirection
    means “not this variable, but the variable named by this variable.” Think of indirection
    as dereferencing a pointer in other languages. The `swap` function is now working
    directly with names passed to it rather than copies of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: The main body of [Listing 5-21](ch05.xhtml#ch05list21) will clarify. The first
    call to `swap` passes `a` and `b` ➊. The second call uses the name operator to
    pass the names of `a` and `b` ➋. The last call passes the literal strings `'a'`
    and `'b'`.
  prefs: []
  type: TYPE_NORMAL
- en: Running [Listing 5-21](ch05.xhtml#ch05list21) produces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first output line shows us the original values of `a` and `b`. The second
    output line shows the effect of ➊ in [Listing 5-21](ch05.xhtml#ch05list21). There
    is no effect. The variables are unchanged because we passed their values rather
    than their names, so the indirection operator failed.
  prefs: []
  type: TYPE_NORMAL
- en: The third output line shows the effect of ➋. Now `swap` is working. The name
    operator passed the strings `'a'` and `'b'`, which the indirection operator can
    interpret to mean that `a` and `b` are swapped.
  prefs: []
  type: TYPE_NORMAL
- en: The final output line shows the effect of ➌. Here we pass the literal strings
    naming `a` and `b`. This is really what the name operator is doing, so `swap`
    works and swaps `a` and `b` again to restore them to their original values.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, SNOBOL passes simple variables by value, requiring the use of indirection
    to update them. However, arrays and tables are always passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: We know how to set up SNOBOL programs and how to create custom functions and
    data types. Now, let’s take a quick look at disk files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Input and Output***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve seen `input` and `output` many times already. In this section, we’ll see
    how they work with disk files.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-22](ch05.xhtml#ch05list22) presents code to make an uppercase copy
    of a text file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-22: Uppercasing a disk file*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot here, so let’s walk through the code line by line. First, open
    the source text file by supplying arguments to `input`. The first argument is
    not the name of the file. Instead, it’s the name of a variable SNOBOL associates
    with the file. It’s what we use to read data from the file, so let’s call it `read`.
    The next argument is a unit number. This is a throwback to old-style programming
    where unit numbers were associated with operating system devices. The unit number
    needs to be unique for each open file. Use numbers of at least 10 or higher. Think
    of the unit number as a file reference.
  prefs: []
  type: TYPE_NORMAL
- en: After the unit number comes the maximum line length. Input lines longer than
    this are truncated. Remember, this is a text file, and SNOBOL works with lines
    of text. The final argument is the name of the disk file. We’re using `host(2,2)`,
    which is specific to our version of SNOBOL. This is a link to the actual operating
    system. The first argument, `2`, refers to command line arguments. The second
    number refers to items on the command line. The second item is the first argument
    after the script name. Therefore, `host(2,2)` gives us the name of the first file.
  prefs: []
  type: TYPE_NORMAL
- en: To open the output file, we use `output`. As with `input`, the first argument
    is the name of a variable to which we will assign the output. We use unit `11`
    for output. The third argument is `'W'` to write a text file. Use `'A'` to append
    a file. The last argument is the name of the output file, here `host(2,3)`, which
    uses the second argument passed to the SNOBOL program.
  prefs: []
  type: TYPE_NORMAL
- en: The files are now open, so let’s read lines from the input, uppercase them,
    and write them to the output. At ➊ we use `read`, tied to the input file, to get
    a line in `text`. If the read fails, the input file is exhausted, so we jump to
    `close`. Otherwise, proceed to apply the intrinsic `replace` to the text to uppercase
    the line; `replace` updates all occurrences of characters in the second argument
    by the corresponding character in the third argument. To save typing, we use the
    predefined strings of lowercase and uppercase letters. SNOBOL variables beginning
    with `&` are system-supplied variables. The output of this line uppercases `text`.
  prefs: []
  type: TYPE_NORMAL
- en: To dump the text to the output file, assign it to `write`, which is the variable
    associated with the output file ➋. After dumping the newly uppercased text, we
    jump back to `loop` to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to close the input and output files before using `endfile` to
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-22](ch05.xhtml#ch05list22) is in the file *uppercase.sno*. Let’s
    run it on the *Alice’s Adventures in Wonderland* text to uppercase it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The file *uppercase.txt* now contains `ALICE` in all caps.
  prefs: []
  type: TYPE_NORMAL
- en: The example above worked with a text file. SNOBOL can also work with binary
    data. Let’s write a simple file copy program to read and write binary data. [Listing
    5-23](ch05.xhtml#ch05list23) shows *copy.sno*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-23: Copying a file*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-23](ch05.xhtml#ch05list23) is quite similar to [Listing 5-22](ch05.xhtml#ch05list22),
    but the input and output files are opened in binary mode. For `input`, where before
    we supplied the maximum line length, we now have `''B,4096''`. This specifies
    binary mode, meaning no line endings are interpreted, and a buffer of 4096 bytes.
    This means the source file will be read in 4096-byte chunks, or fewer if there
    aren’t at least 4096 bytes left to read. For output, use `''B''` to indicate binary
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: The loop, in this case, is a one-liner ➊. Read a 4096-byte chunk of the input
    and immediately assign it to `write` to write it to the output file. When `read`
    fails, jump to close the files. Otherwise, jump back to this same line of code
    to continue the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test *copy.sno*, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This should copy the given *src.png* image to *dst.png*. The image is of a young
    raccoon and is taken from the open source SciPy toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Machine Learning with SNOBOL**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s work through a little SNOBOL project to implement a simple machine learning
    classifier. Modern artificial intelligence is far removed from what computer scientists
    had in mind back when SNOBOL was new. Machine learning existed then, but the term
    “artificial intelligence” was not used to describe it for the most part.
  prefs: []
  type: TYPE_NORMAL
- en: '*Artificial intelligence* now most often refers to that part of machine learning
    known as deep learning, that is, advanced neural networks, often with millions
    to billions of connections between the nodes (neurons). SNOBOL is not a good choice
    for such models. However, classical machine learning includes basic algorithms
    that are sometimes quite straightforward to implement and that sometimes perform
    quite well despite their simplicity.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the goal of this section is to build a complete SNOBOL application
    to classify datasets using a simple machine learning technique—a *nearest neighbor*
    classifier.
  prefs: []
  type: TYPE_NORMAL
- en: '***Machine Learning 101***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Machine learning maps feature vectors to class labels. A *feature vector* is
    a collection of numeric values called *features*; that’s our input. We take this
    input and try to assign it a *class label*, that is, a category or class. For
    example, one of the datasets we’ll work with relates to iris flowers. This dataset
    is perhaps the oldest in machine learning and one of the easiest to work with.
    It consists of 150 measurements of three different species of iris flowers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four measurements per flower: two measuring the petal length and
    width and two measuring the sepal length in width. These four measurements are
    the features and the three different species are the classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning models must be trained so they can place an unknown sample
    into the correct class. *Training* involves learning the parameters of the model
    using a training set, a collection of feature vectors (*x*) and corresponding
    class labels (*y*). This is what the iris dataset gives us. The training set has
    50 examples of each class, that is, each species of flower. We’ll use 100 of these
    150 examples to train the classifier and the remaining 50 to test the model to
    see how well it learned to distinguish between iris species.
  prefs: []
  type: TYPE_NORMAL
- en: We hope that when given a set of features for a new flower the trained model
    will be able to place the new flower into the correct class (in other words, correctly
    identify the species). The nearest neighbor classifier treats the feature vector
    as a point in a multidimensional space, in this case a 4D space for the iris dataset,
    as there are four features per sample. The idea is to find the training set sample
    whose feature vector is the closest to the feature vector of the unknown input
    and then assign the unknown input to the training sample class. In this case,
    closest means the training sample with the smallest *distance* to the unknown
    input.
  prefs: []
  type: TYPE_NORMAL
- en: There are many concept words in the paragraphs above, so let’s make sure we
    know what they mean. Once we do, the operation of the classifier will become apparent
    or even obvious. [Table 5-1](ch05.xhtml#ch05tab1) presents a brief machine learning
    glossary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** A Brief Machine Learning Glossary'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Term** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Feature | A measurement or characteristic of the data |'
  prefs: []
  type: TYPE_TB
- en: '| Feature vector | A collection of features describing an instance |'
  prefs: []
  type: TYPE_TB
- en: '| Class | The label, or group, the instance belongs to |'
  prefs: []
  type: TYPE_TB
- en: '| Model | A means for mapping feature vectors to class labels |'
  prefs: []
  type: TYPE_TB
- en: '| Training | Using known feature vectors to teach the model |'
  prefs: []
  type: TYPE_TB
- en: '| Distance | The straight-line distance between two points |'
  prefs: []
  type: TYPE_TB
- en: 'All machine learning models implement two phases: training and inference. During
    training, the training set, that is, the collection of feature vectors and their
    known class labels, is used to adjust the model’s parameters to the task at hand.
    Once trained, the model can be used for inference to assign class labels to new,
    unknown feature vectors. For the nearest neighbor classifier, training is so trivial
    as to be nonexistent: we use the training set as it is, as there are no parameters
    to learn.'
  prefs: []
  type: TYPE_NORMAL
- en: To classify feature vectors, we scan through the training set to calculate the
    distance between the unknown feature vector and each of the training samples to
    find the closest training sample. We use that training sample’s class label as
    the class label for the unknown feature vector.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a new set of measurements for an iris flower but don’t
    know its species, the nearest neighbor classifier searches the list of training
    set feature vectors for the sample closest to the unknown feature vector. It then
    declares the unknown input to be of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: The word *distance* has been mentioned a few times now. Let’s put a formula
    to the word, so we have a way to measure the distance between two feature vectors.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of distances, but the one we’ll use here is the *Euclidean
    distance*, which is a generalization of the Pythagorean theorem. For example,
    in 4D, the distance between two points, (*x*[0], *y*[0], *a*[0], *b*[0]) and (*x*[1],
    *y*[1], *a*[1], *b*[1]), is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we have 3D feature vectors, the distance between two points, (*x*[0], *y*[0],
    *z*[0]) and (*x*[1], *y*[1], *z*[1]), is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For *n*-dimensional feature vectors, the distance is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for two feature vectors, *x* and *y*. In the equation above, *i* is an index
    into the components of the vector. When we implement the Euclidean distance in
    code, *i* will be an index into an array.
  prefs: []
  type: TYPE_NORMAL
- en: The training set and the Euclidean distance are all we need to implement the
    nearest neighbor classifier, but how will we know if it’s working? For that, we
    need test data. This is another dataset like the training set, but one that wasn’t
    used to train the model.
  prefs: []
  type: TYPE_NORMAL
- en: We know the feature vectors and the correct class label for the test set. We’ll
    run each test set feature vector through the model, comparing the classifier’s
    predicted label with the correct class label. There are many ways to characterize
    the performance of a machine learning model, but in this case, all we need to
    measure is the model’s accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A classifier that randomly guesses class labels will only be correct, on average,
    one time in *c*, where *c* is the number of classes in the dataset. There are
    three classes for the iris flowers, so we’d expect, if guessing, to be correct
    one time out of three, or about 33 percent of the time, meaning the accuracy is
    0.3333\. A perfect classifier makes no mistakes and has an accuracy of 1.0 or
    100 percent.
  prefs: []
  type: TYPE_NORMAL
- en: We now have enough background to get started. We have a model and we know how
    to train it and test it. Let’s write some code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing the Classifier***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement the classifier. Here’s our plan of attack:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the training and test datasets into SNOBOL arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each test sample, assign the class label of the closest training set sample.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the assigned labels to the known test labels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Report the classifier’s accuracy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code that follows is in the file *classify.sno*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading the Data**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This book’s GitHub site contains several datasets. Let’s walk through an example
    using the iris dataset. We’ll classify the others later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iris dataset is in four text files in the *datasets* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first two contain training data and the associated class labels. The second
    two hold test data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the training datafile begins with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: with the associated class labels
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: meaning the first feature vector is a class 1 instance, whereas the second feature
    vector is an instance of class 0, and so on. The test dataset files are structured
    similarly.
  prefs: []
  type: TYPE_NORMAL
- en: We need SNOBOL code to load these text files. We’ll develop generic code, a
    SNOBOL function to load any datafile arranged such that each row represents a
    sample and each column represents a feature. Most machine learning datasets are
    structured this way.
  prefs: []
  type: TYPE_NORMAL
- en: The iris training data results in a 2D array with 100 rows and four columns
    because there are four features per sample and 100 samples in the training set.
    The training labels will become a 2D array as well, with 100 rows and one column.
    This simplifies the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-24](ch05.xhtml#ch05list24) shows a function to load datafiles. It’s
    the most complex piece of code we need to develop, so it’s best to start with
    the worst, knowing that things will get easier later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-24: Loading a datafile*'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts the name of the text file to load ➊. Notice the list of
    local variables. This prevents hard-to-detect errors whereby the function might
    alter a global variable. The function itself consists of two loops. The first
    loop, from label `loadfile` through label `load_l00`, reads a line of text from
    the input file and parses it to count the number of features per sample. When
    the program reaches label `load_l00`, the number of rows in the file is in `r`
    and the number of columns is in `c`.
  prefs: []
  type: TYPE_NORMAL
- en: To extract a number from the current line, we do two things. First, we add a
    blank space to the input line (see label `load_l02`). Next, we perform a pattern
    match and update (see label `load_l03`). The pattern ➋ uses `break` to match all
    text up to the first blank, storing it in `v`, and then matches any number of
    blanks with `span`. The net effect of `pat` is to grab the text representing a
    feature value and end with the cursor at the beginning of the next feature. Label
    `load_l03` assigns nothing to the matched text, thereby removing it from `text`.
    This process repeats, with `c` incremented until the line is empty and the match
    fails to cause a jump to label `load_l01` to increment `r` and advance to the
    next line of the input file. When the input file is exhausted, control moves to
    label `load_l00` to close the file.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the first loop is to learn the file’s dimensionality; it’s in
    `r` and `c`. The return value of the function is defined as an array of the appropriate
    size ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The input file is opened a second time, and the same read process happens again.
    This time, each matched feature value in `v` is placed into the array as a floating-point
    number ➍. When the input file is again empty, the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating the Distance**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Classifying an unknown sample requires computing the distance between pairs
    of feature vectors. The code to do this is in `dist`. See [Listing 5-25](ch05.xhtml#ch05list25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-25: Calculating the Euclidean distance*'
  prefs: []
  type: TYPE_NORMAL
- en: The arguments to `dist` are the two datasets, `x` and `y`, which are 2D, and
    the rows to work with, `i` and `j`. The distance is the sum of the differences
    of each feature for the given rows. These are the columns of the arrays that we
    index with `k`.
  prefs: []
  type: TYPE_NORMAL
- en: The label `dist_l00` does all the work. It adds the square of the difference
    between the *k*th columns of `x` and `y` for the given rows to the existing sum.
    The loop fails when `k` exceeds the array’s bounds. The return value is the square
    root of this sum (the label `dist_l01`).
  prefs: []
  type: TYPE_NORMAL
- en: Some readers might be a bit confused by [Listing 5-25](ch05.xhtml#ch05list25),
    as `sum` is updated without being initialized. There is no error. SNOBOL treats
    undefined variables as null and adding a number to null returns the number, so
    there is no need to initialize `sum` explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Nearest Training Sample**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need to find the training sample that is closest to a given test sample.
    For that, we use the function `nearest`. See [Listing 5-26](ch05.xhtml#ch05list26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-26: Finding the nearest training sample*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-26](ch05.xhtml#ch05list26) actually defines two functions, `nearest`
    and `samples` (which is used by `nearest`). Let’s start with `samples`. It returns
    the number of rows in a 2D array. Given how we organize the data, that’s a sample,
    a feature vector.'
  prefs: []
  type: TYPE_NORMAL
- en: The `samples` function defines a pattern (`pat`), matching text up to the first
    comma and storing it in the function name (`samples`). It then applies this pattern
    to whatever is returned by the SNOBOL `prototype` function. This function returns
    a string specifying the dimensionality of an array. Recall that arrays are declared
    using a string to specify the number and size of the dimensions. Our arrays are
    2D, so `prototype` returns a string like `'100,4'`. The pattern extracts the first
    number. We won’t use it, but *classify.sno* also defines `features`, which is
    a function to return the number of features, the second number returned by `prototype`.
    Do take a look.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm for `nearest` scans through the training data, calculating the
    distance between the current training sample and the specified test sample. If
    that distance is smaller than the smallest found so far, it keeps track of the
    distance and the training sample’s class label. When the algorithm completes its
    pass through the training data, it returns the class label of the smallest distance;
    `nearest` classifies a given test set sample.
  prefs: []
  type: TYPE_NORMAL
- en: The long list of parameters to `nearest` passes the training set, both data
    (`xtrn`) and labels (`ytrn`), along with the test set data and labels, and `idx`,
    which is the current test set sample to classify.
  prefs: []
  type: TYPE_NORMAL
- en: The loop over the training set tracks `md`, which is the smallest distance found
    so far, storing the associated class label in `nearest`, the function value. The
    loop ends when `le(i,s)` fails where `i` is the row index and `s` is the number
    of samples in the training set. If `lt(d,md)` succeeds, the algorithm updates
    `md` and `nearest`.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Main Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The sections above describe the functions implementing each phase of the classification
    task. The main code, at the bottom of *classify.sno*, pulls these pieces together
    (see [Listing 5-27](ch05.xhtml#ch05list27)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-27: Putting the classifier together*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-27](ch05.xhtml#ch05list27) first loads the training and test data.
    The feature vectors are in `x_train` and `x_test`, respectively. The associated
    class labels are in `y_train` and `y_test`. The filenames are passed on the command
    line, after *classify.sno*, with the training data and labels first, followed
    by test data and labels.'
  prefs: []
  type: TYPE_NORMAL
- en: The following code is a loop that runs through each test sample. The call to
    `nearest` returns the assigned class label for test sample `i`. If the classification
    is correct, it increments the number correct counter, `nc` ➊. Note that the SNOBOL
    construct of using the `eq` predicate in the same update statement. If the classification
    is wrong, `eq` fails, and the rest of the statement is skipped. There is no failure
    label, so execution continues with the next line. When all test samples have been
    classified, the overall accuracy is displayed before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is complete. Now the million-dollar question: does it work?
    Let’s see.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Classifier***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s run *classify.sno* against the examples in the *datasets* directory. These
    datasets can be found on the UCI Machine Learning Repository website (*[https://archive.ics.uci.edu/ml/index.php](https://archive.ics.uci.edu/ml/index.php)*).
    I downloaded the datasets and processed them to be in the form expected by *classify.sno*.
    The full dataset was randomly partitioned into training and test datasets using
    an 80/20 split. Feature vectors are in the “data” files, with the class labels,
    matching line for line, in the “labels” files.
  prefs: []
  type: TYPE_NORMAL
- en: The available datasets include those shown in [Table 5-2](ch05.xhtml#ch05tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Available Datasets'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dataset** | **Features** | **Classes** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| banknote | 4 | 2 | Real or counterfeit notes |'
  prefs: []
  type: TYPE_TB
- en: '| cancer | 10 | 2 | Breast cancer histology slide features |'
  prefs: []
  type: TYPE_TB
- en: '| ecoli | 7 | 8 | Characterizing *E. coli* bacteria |'
  prefs: []
  type: TYPE_TB
- en: '| haberman | 3 | 2 | Five year breast cancer survival |'
  prefs: []
  type: TYPE_TB
- en: '| iris | 4 | 3 | Types of irises |'
  prefs: []
  type: TYPE_TB
- en: '| seeds | 7 | 3 | Types of seeds |'
  prefs: []
  type: TYPE_TB
- en: '| wine | 13 | 3 | Wine origin |'
  prefs: []
  type: TYPE_TB
- en: 'Let start with the irises. To run the classifier, use the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The output begins with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: and ends with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There are 50 test samples and the assigned and actual class labels are displayed
    for each sample. If the classifier made a mistake, the output is followed by `**`
    to mark it.
  prefs: []
  type: TYPE_NORMAL
- en: The overall accuracy was 96 percent, with only two mistakes. For such a simple
    classifier, this is not too shabby. Note that both errors were confusing between
    class 1 and class 2\. For the iris dataset, class 0 is easily distinguished from
    the other two, but class 1 and class 2 are relatively similar, so they are more
    likely to be confused.
  prefs: []
  type: TYPE_NORMAL
- en: Run the other example datasets in the same way. [Table 5-3](ch05.xhtml#ch05tab3)
    shows the statistics, including the accuracy, number correctly classified, number
    tested, and the size of the training set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-3:** Nearest Neighbor Classifier Accuracies by Dataset'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dataset** | **Accuracy (%)** | **Correct** | **Test** | **Train** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| banknote | 100.0 | 275 | 275 | 1097 |'
  prefs: []
  type: TYPE_TB
- en: '| cancer | 94.2 | 129 | 137 | 546 |'
  prefs: []
  type: TYPE_TB
- en: '| ecoli | 86.8 | 59 | 68 | 268 |'
  prefs: []
  type: TYPE_TB
- en: '| haberman | 67.2 | 41 | 61 | 245 |'
  prefs: []
  type: TYPE_TB
- en: '| iris | 96.0 | 48 | 50 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| seeds | 92.9 | 39 | 42 | 168 |'
  prefs: []
  type: TYPE_TB
- en: '| wine | 83.3 | 30 | 36 | 142 |'
  prefs: []
  type: TYPE_TB
- en: The results range from perfection (banknotes) to a low of 67 percent (haberman).
    However, all things considered, this simple classifier performed quite well on
    these datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another name for the nearest neighbor classifier: 1-nearest neighbor,
    where the *1* means only the nearest training sample is considered. This classifier
    can be generalized to consider the *k*-nearest neighbors where *k* > 1 and is
    odd. For a *k*-nearest neighbor classifier, the *k*-nearest neighbors are located.
    The assigned class is the result of voting among the *k*-nearest neighbors. In
    the event of a tie, select one of the neighbors at random. Although nearest neighbor
    classifiers are seldom used, *k*-nearest neighbor classifiers are still an active
    research area in machine learning. I leave it as an exercise for the reader to
    convert *classify.sno* into a *k*-nearest neighbor classifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The world of machine learning offers much more than the tiny bit we’ve explored
    here. Witness the rapidly expanding world of deep learning, which has already
    greatly affected our daily lives and will continue to do so for years to come.
    If your interest has been piqued, please take a look at my deep learning books*
    Practical Deep Learning: A Python-Based Introduction (2021) *and* Math for Deep
    Learning: What You Need to Know to Understand Neural Networks *(2021). Both are
    available from No Starch Press.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What should we make of SNOBOL? I’ll admit, I like the language. The flexibility
    of its arrays and the table data structure are surprisingly “modern.” I also like
    its pattern-matching abilities, dynamic data typing, and automatic memory management.
  prefs: []
  type: TYPE_NORMAL
- en: But SNOBOL’s complete lack of structured programming abilities hurts. The only
    way to directly control program flow is with a goto. There are no structured control
    statements like `for` or `while`.
  prefs: []
  type: TYPE_NORMAL
- en: Forth gets a bad rap for being a write-only programming language, but Forth
    uses structured programming, which is not even an option in SNOBOL. Using the
    success or failure of a statement as an essential element of program flow control
    is novel and intellectually engaging, but it ultimately makes working with the
    language difficult. However, I suspect much of that difficulty would fade with
    practice. The fact that SNOBOL labels are global is especially painful. Even some
    assemblers for old 8-bit microprocessors support local labels, something that
    would greatly benefit SNOBOL.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, SNOBOL had a reputation for being slow. Thus, a simple timing
    test comparing SNOBOL and Python seems in order.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-28](ch05.xhtml#ch05list28) shows two equivalent programs to initialize
    a 1,000,000-element array/list 20 times, first in Python and then in SNOBOL.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-28: Comparing SNOBOL and Python*'
  prefs: []
  type: TYPE_NORMAL
- en: The median runtime on my machine over 10 runs each is 2.363 seconds for Python
    and 3.548 seconds for SNOBOL. So yes, SNOBOL is slower, but not dramatically so.
    Note that to run the SNOBOL code, use -d 1m on the command line to reserve enough
    memory for the array.
  prefs: []
  type: TYPE_NORMAL
- en: In what ways does SNOBOL help us expand our conception of what it means to code?
    Several come to mind. SNOBOL uses global labels and is unstructured. This requires
    programmers to think clearly about the *entire* scope of the project, or at least
    to implement a disciplined approach to coding, one that is not enforced by the
    language itself as in other, newer programming languages. Without a global conception
    of the program, label confusion or spaghetti code is inevitable. Thus, clarity
    of thought is essential.
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL’s robust pattern matching and string update abilities enable a novel
    approach to string manipulation. As a result, some of the burden incumbent on
    the programmer regarding string manipulation in languages like C++, Python, or
    Java is alleviated. This means thinking in terms of strings and their evolution
    becomes a new paradigm for implementing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, SNOBOL requires thinking in terms of statement success *and* statement
    failure. Typically, coding is for success, as we don’t want failures to happen.
    Error control in SNOBOL is fine grained, which is both helpful and perhaps a bit
    dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, SNOBOL is a surprisingly “modern” programming language. In many
    ways, it was well ahead of its time. SNOBOL itself evolved into Icon, also by
    Griswold, which uses structured programming constructs. Icon never caught on,
    but readers who are so inclined can learn more at *[https://www2.cs.arizona.edu/icon/](https://www2.cs.arizona.edu/icon/)*.
    Regardless, SNOBOL is worth a bit of continued effort on our part. Indeed, we’ll
    see SNOBOL again in [Chapter 10](ch10.xhtml#ch10) when we use it to implement
    Brainfuck.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced us to SNOBOL, a quirky pattern matching programming
    language from the 1960s. We worked through the language from its overall structure
    to specifics of its key features, with numerous examples. We learned about its
    unique approach to flow control and saw a tiny portion of its powerful text pattern
    matching abilities.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a simple machine learning classifier in SNOBOL as an exercise
    and saw that it performed well against some small-scale machine learning datasets.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter by discussing the language, what we liked about it, and
    what we were less enthused about. Our ultimate conclusion was that SNOBOL well
    deserves of a place at our table as a novel language that can help us learn to
    think differently about coding.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s leave SNOBOL, with its successes and failures, and jump forward to the
    latter Mesozoic so we can experience the awe and mystery of CLIPS, a language
    designed for expert system development.
  prefs: []
  type: TYPE_NORMAL
