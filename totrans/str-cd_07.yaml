- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: SNOBOL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: SNOBOL is a text pattern matching language developed in the 1960s. Modern programmers
    might find its syntax quaint, and maybe even a tad frustrating, but I suspect
    the power of the language will shine through in the end as we explore its features,
    some of which are still with us in modern languages like Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 是一种文本模式匹配语言，开发于 1960 年代。现代程序员可能会觉得它的语法有些过时，甚至可能略感沮丧，但我怀疑随着我们探索其特性，语言的强大力量最终会展现出来，其中一些特性至今仍出现在现代语言中，如
    Python。
- en: SNOBOL, like Forth, is a denizen of the later Paleozoic. SNOBOL and Forth are
    of similar vintage, but they are extremely different. Forth is minimal and low
    level. SNOBOL is abstract and surprisingly powerful, though quirky.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL，像 Forth 一样，是晚期古生代的产物。SNOBOL 和 Forth 同样属于同一时代，但它们非常不同。Forth 是极简的低级语言，而
    SNOBOL 是抽象的，且出奇地强大，尽管有些怪异。
- en: 'In this chapter, we’ll explore SNOBOL, specifically SNOBOL4, the latest dialect
    of the language. SNOBOL is known for its pattern matching and string processing
    abilities, but it is a general-purpose language. As we’ll see, SNOBOL’s data handling
    facilities are surprisingly sophisticated and include an atypical level of flexibility.
    As Michael Shafto put it in 1982, “SNOBOL4 is the Alice’s Restaurant of programming
    languages: you can get anything you want” (see “Artificial Intelligence Programming
    in SNOBOL4,” available on this book’s GitHub site).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 SNOBOL，特别是 SNOBOL4，这是该语言的最新方言。SNOBOL 以其模式匹配和字符串处理能力而闻名，但它也是一种通用语言。正如我们将看到的，SNOBOL
    的数据处理功能出奇地复杂，且具有非同寻常的灵活性。正如迈克尔·沙夫托在 1982 年所说：“SNOBOL4 是编程语言中的 Alice's Restaurant：你想要的任何东西都可以得到”（参见《SNOBOL4
    中的人工智能编程》，该书的 GitHub 网站上可用）。
- en: Let’s explore SNOBOL by reviewing the structure of the language and the interesting
    abilities it provides. We’ll walk through its features, look at examples, and
    finish by building a simple machine learning classifier to link our explorations
    with the hopes of at least some computer scientists from the 1980s. As before,
    we’ll end with some closing thoughts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回顾语言的结构和它所提供的有趣能力来探索 SNOBOL。我们将逐步介绍其特性，查看示例，最后通过构建一个简单的机器学习分类器来将我们的探索与
    1980 年代的计算机科学家们的希望相连接。像以前一样，我们将以一些总结性思考结束。
- en: '**Installation**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装**'
- en: 'To install SNOBOL, download it from *[http://ftp.ultimate.com/snobol4/](http://ftp.ultimate.com/snobol4/)*
    by grabbing *snobol4-2.3.1.tar.gz*, or any later version you see on that site.
    Save the file in a subdirectory called *SNOBOL*. Once you have the file, expand
    it and build the SNOBOL executable as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 SNOBOL，请从 *[http://ftp.ultimate.com/snobol4/](http://ftp.ultimate.com/snobol4/)*
    下载 *snobol4-2.3.1.tar.gz*，或者从该网站上下载任何更新的版本。将文件保存在名为 *SNOBOL* 的子目录中。下载文件后，解压并按照以下步骤构建
    SNOBOL 可执行文件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The commands above generate a lot of output. Some are from the C compiler, including
    a few warnings we can safely ignore. The rest are from SNOBOL test scripts. When
    all is said and done, if you see a message about sending timing info to `timing@snobol4.org`,
    you’ll know that SNOBOL was successfully built and is running correctly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会生成大量输出。其中一些来自 C 编译器，包括一些我们可以安全忽略的警告。其余的来自 SNOBOL 测试脚本。最终，如果你看到一条关于将时间信息发送到
    `timing@snobol4.org` 的消息，就意味着 SNOBOL 已成功构建并且运行正常。
- en: '**Origins and Philosophy**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**起源与哲学**'
- en: SNOBOL (“StriNg Oriented and symBOlic Language”) was developed during the 1960s
    at AT&T Bell Laboratories by David Farber, Ralph Griswold, and Ivan Polonsky.
    The name *SNOBOL* is a backronym, meaning the developers began with the acronym
    they wanted and worked backward to ensure they got it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL（“StriNg Oriented and symBOlic Language”）是由大卫·法伯、拉尔夫·格里斯沃尔德和伊万·波隆斯基在 1960
    年代于 AT&T 贝尔实验室开发的。*SNOBOL* 这个名字是一个回文首字母缩略词，意味着开发人员从他们想要的首字母缩略词开始，然后倒推确保达成目标。
- en: According to Farber, the original name for the language was “Symbolic EXpression
    Interpreter,” or SEXI. In the 1960s, running a computer program meant walking
    to the machine room with a stack of punch cards. Typically, the program name and
    username were marked on the deck. So Farber handed the young woman running the
    programs a stack labeled “SEXI Farber.” She read the name and laughingly said,
    “That’s what you think.” Clearly, a new name was needed. After much frustration,
    someone complained that they didn’t have a snowball’s chance in hell of coming
    up with a name; thus “SNOBOL” was born. The spelling pays homage to other similarly
    named languages of the time like COBOL and ALGOL. (Farber posted this story to
    his Interesting-People mailing list in December 2008.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Farber 的说法，这种语言的最初名字是“符号表达式解释器”（Symbolic EXpression Interpreter），简称 SEXI。在
    1960 年代，运行一个计算机程序意味着带着一堆打孔卡走到机器房。通常，程序名称和用户名会标记在卡片组上。所以 Farber 把一堆标有“SEXI Farber”的卡片交给了那个年轻的女性程序员，她读了这个名字后，笑着说：“你是这么想的。”显然，需要一个新名字。在经历了很多挫折之后，有人抱怨他们根本不可能想到一个名字；于是“SNOBOL”就诞生了。这个拼写方式向当时其他类似命名的语言如
    COBOL 和 ALGOL 致敬。（Farber 于 2008 年 12 月在他的 Interesting-People 邮件列表中发布了这个故事。）
- en: SNOBOL’s claim to fame is its powerful pattern-matching abilities. Current programming
    languages often rely on regular expressions, which have a separate history from
    SNOBOL, but SNOBOL’s matching skills were perfectly suited to the sort of highly
    structured data processing that was the focus of most computer mainframe use at
    the time. We’ll explore pattern matching throughout the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 的名声来自于其强大的模式匹配能力。当前的编程语言通常依赖于正则表达式，这与 SNOBOL 有着不同的历史背景，但 SNOBOL 的匹配技能非常适合当时计算机主机使用中处理高度结构化数据的需求。我们将在本章中探讨模式匹配。
- en: SNOBOL’s philosophy might best be summed up as “all the world’s a string.” Strings
    are almost everything in SNOBOL. Data in the 1960s was typically textual, like
    records with fixed sizes and fields. SNOBOL’s pattern matching made processing
    such data (relatively) straightforward.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 的哲学可以用一句话总结：“整个世界都是一个字符串。”字符串几乎是 SNOBOL 中的一切。1960 年代的数据通常是文本型的，比如具有固定大小和字段的记录。SNOBOL
    的模式匹配使得处理这类数据（相对而言）变得简单。
- en: Even though SNOBOL manipulated structured text data, it did not itself make
    use of structured programming. Thus, there are no `for` or `while` loops in SNOBOL.
    For that matter, SNOBOL lacks even basic `if-then` constructs. The only way to
    control program flow is by using what amounts to a `goto` statement. However,
    in SNOBOL, gotos are rather flexible. One of SNOBOL’s unique concepts is that
    every line of code either succeeds or fails and where the program goes next depends
    on that fact. We’ll see this in action as we work through the examples. In SNOBOL,
    failure is definitely an option. In fact, it’s a requirement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 SNOBOL 操作的是结构化的文本数据，但它本身并没有使用结构化编程。因此，SNOBOL 中没有 `for` 或 `while` 循环。更进一步，SNOBOL
    甚至没有基本的 `if-then` 结构。控制程序流的唯一方法是使用类似 `goto` 的语句。然而，在 SNOBOL 中，`goto` 语句非常灵活。SNOBOL
    的一个独特概念是，每行代码要么成功，要么失败，程序接下来会去哪里取决于这一点。我们将在接下来的示例中看到这一点。在 SNOBOL 中，失败绝对是一个选项。事实上，它是一个必要条件。
- en: SNOBOL is dynamically typed and able to create new variables and data structures
    on the fly. SNOBOL can even create new code on the fly, though we won’t be so
    ambitious here. SNOBOL supports powerful arrays and tables, the latter of which
    are much like Python dictionaries. User-defined data structures are also available.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 是动态类型的，能够即时创建新变量和数据结构。SNOBOL 甚至可以即时创建新代码，尽管我们在这里不会如此雄心勃勃。SNOBOL 支持强大的数组和表格，后者与
    Python 字典类似。也可以使用用户定义的数据结构。
- en: The best way to learn SNOBOL is to use SNOBOL. It really must be seen to be
    believed. So without further ado, let’s take a walk in the snow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 SNOBOL 最好的方法就是使用 SNOBOL。你真得亲眼看过才会相信。所以，不再拖延，让我们走进这场雪中漫步吧。
- en: '**The Language**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**语言**'
- en: We’ll begin by learning how to get SNOBOL to do basic things like print “Hello,
    world!” Once we’ve figured that out, we’ll move to variables and user-defined
    data types. Next come arrays and tables, SNOBOL’s intrinsic data structures. Patterns
    follow, though some pattern use will already have snuck in. Patterns are the traditional
    reason for using SNOBOL, and are perhaps the one part of the language that best
    distinguishes it from most other languages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从学习如何让SNOBOL做一些基本的事情开始，例如打印“Hello, world!” 一旦我们弄明白这一点，我们将继续学习变量和用户定义的数据类型。接下来是数组和表格，这是SNOBOL的内建数据结构。然后是模式，尽管一些模式的使用可能已经悄悄出现在之前的内容中。模式是使用SNOBOL的传统原因，或许也是最能将SNOBOL与大多数其他语言区分开的语言特性。
- en: SNOBOL allows user-defined functions. We’ll see how to define them and learn
    why the process is, to be blunt, ugly. Then we’ll close with disk files and command
    line arguments. We’ll learn how to control a SNOBOL program’s flow as we work
    through the examples, as that’s the best way to learn it. All the files mentioned
    in the following sections are in the *examples* directory under *SNOBOL*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL允许用户定义函数。我们将看到如何定义它们，并学习为什么这个过程，直言不讳地说，非常繁琐。然后我们将结束于磁盘文件和命令行参数的学习。通过操作示例，我们将学会如何控制SNOBOL程序的流程，因为这是学习它的最佳方式。以下章节中提到的所有文件都位于*examples*目录下的*SNOBOL*文件夹中。
- en: '***Running SNOBOL***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行SNOBOL***'
- en: SNOBOL runs interactively if started without a filename. This mode is available
    for quick calculations and testing ideas, but SNOBOL was meant to run code from
    a file or, originally, a stack of punch cards.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供文件名启动，SNOBOL将以交互模式运行。此模式适用于快速计算和测试想法，但SNOBOL本应从文件中运行代码，或最初是从打孔卡堆栈中运行代码。
- en: '[Listing 5-1](ch05.xhtml#ch05list1) gets us started with *hello.sno*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](ch05.xhtml#ch05list1)为我们展示了如何开始使用*hello.sno*。'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-1: A SNOBOL greeting*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-1：一个SNOBOL问候程序*'
- en: This short program already has much to say about SNOBOL. First, comment lines
    begin with an asterisk (`*`). However, unlike in other languages, the asterisk
    *must* be in column 1\. Either the entire line is a comment, or none of it is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的程序已经向我们介绍了SNOBOL。首先，注释行以星号（`*`）开始。然而，与其他语言不同，星号*必须*位于第1列。整个行要么是注释，要么都不是注释。
- en: To print something in SNOBOL, we assign it to the special variable `output`.
    SNOBOL is not case sensitive, so `output` and `OUTPUT` are treated the same. The
    thing assigned to `output` is a string or something SNOBOL will implicitly convert
    into a string, like a number.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNOBOL中打印内容，我们将其赋值给特殊变量`output`。SNOBOL不区分大小写，因此`output`和`OUTPUT`是等同的。赋给`output`的内容是一个字符串，或者是SNOBOL会隐式转换成字符串的内容，如数字。
- en: Concatenation is such a common operation in SNOBOL that space is used as the
    operator. So the first `output` statement in [Listing 5-1](ch05.xhtml#ch05list1)
    assigns a string enclosed in single quotes while the second concatenates two strings
    together. Note the use of double quotes. Like Python, SNOBOL allows both kinds.
    As you can see from the next line, SNOBOL implicitly converts numbers, which may
    be integers or floating point, into strings. Lastly, to output a blank line, assign
    nothing. Assigning nothing is also the SNOBOL way of removing things from a string.
    We’ll see that in action when using patterns.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接是SNOBOL中非常常见的操作，因此空格被用作运算符。因此，[示例 5-1](ch05.xhtml#ch05list1)中的第一个`output`语句分配了一个用单引号括起来的字符串，而第二个则将两个字符串连接在一起。请注意双引号的使用。像Python一样，SNOBOL允许两种类型的引号。正如从下一行可以看到的，SNOBOL会隐式地将数字（无论是整数还是浮点数）转换为字符串。最后，要输出一个空行，只需赋值为空。赋值为空也是SNOBOL移除字符串中内容的方式。我们将在使用模式时看到这一点。
- en: All SNOBOL programs end with `end`. Note that `end` is in column 1 and all the
    `output` statements are indented. SNOBOL doesn’t care how far statements are indented,
    only that they don’t begin in column 1\. The only things allowed in column 1 are
    `*` for comments, `+` for line continuation (which is seldom used now), and labels,
    including `end`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有SNOBOL程序都以`end`结尾。请注意，`end`位于第1列，所有的`output`语句都需要缩进。SNOBOL不关心语句缩进的多少，只要语句不在第1列开始即可。第1列仅允许包含`*`用于注释，`+`用于行续接（现在很少使用）和标签，包括`end`。
- en: You can run *hello.sno* like you’d run a Python script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像运行Python脚本一样运行*hello.sno*。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should give you the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你以下输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output of [Listing 5-1](ch05.xhtml#ch05list1) implies that SNOBOL always
    prints the string assigned to `output` on a line. There is no easy way to output
    a partial line followed by more text before ending the line. SNOBOL is line oriented,
    both for output and input. Thus, it is up to the programmer to build the entire
    line first before assigning it to `output`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-1](ch05.xhtml#ch05list1)的输出表明，SNOBOL总是打印分配给`output`的字符串。没有简单的方法可以在一行上输出部分内容，然后在结束行之前继续输出更多文本。SNOBOL是基于行的，无论是输出还是输入。因此，程序员必须先构建完整的行，然后将其赋值给`output`。'
- en: Now run [Listing 5-2](ch05.xhtml#ch05list2), *hello2.sno*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行[清单 5-2](ch05.xhtml#ch05list2)，*hello2.sno*。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-2: Hello, hello, hello*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：你好，你好，你好*'
- en: When you get bored, use CTRL-C to interrupt the program. This is our first SNOBOL
    loop. In SNOBOL, every line has the opportunity to execute a goto. The first part
    of the line, in column 1, is a label, `loop`. Labels are the targets SNOBOL uses
    when the goto portion of a line is executed. Labels, and other identifiers, must
    start with a letter. After that, letters, numbers, and underscores are allowed.
    Note that labels are global. That is, they must be unique across the entire program.
    Also, SNOBOL lines get rather lengthy and full of spaces, so we’ll remove extra
    spaces present in the source code files to save space in the text.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你感到无聊时，使用CTRL-C中断程序。这是我们的第一个SNOBOL循环。在SNOBOL中，每一行都有机会执行一个goto。行的第一部分，在第一列，是一个标签`loop`。标签是SNOBOL在执行行的goto部分时使用的目标。标签和其他标识符必须以字母开头。之后，可以使用字母、数字和下划线。请注意，标签是全局的。也就是说，它们必须在整个程序中唯一。此外，SNOBOL行通常较长且包含许多空格，因此我们会去掉源代码文件中的多余空格，以节省文本中的空间。
- en: The goto portion of a SNOBOL line comes at the end. The number of spaces before
    the goto can vary, but no code comes after the goto. The colon (`:`) begins the
    goto. Target labels are enclosed in parentheses. We’ll encounter more sophisticated
    gotos as we proceed. Note that if there is no goto, control proceeds to the next
    line of code as in most programming languages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL行中的goto部分位于行尾。goto前面的空格数量可以变化，但goto后面没有其他代码。冒号（`:`）开始goto。目标标签被括号括起来。随着我们继续前进，我们会遇到更复杂的goto语句。请注意，如果没有goto，控制将按照大多数编程语言的方式继续执行下一行代码。
- en: One more item is worth noting here. The goto in [Listing 5-2](ch05.xhtml#ch05list2)
    always executes whether the line succeeds or fails. Granted, this line will never
    fail, but we’ll see other lines that do and that indeed must fail. It’s part of
    how the language works. Forgetting to distinguish between success and failure
    and using a goto that always executes can lead to strange behavior. Of course,
    the potential dangers of `goto` statements are well known—see Edsger Dijkstra’s
    famous 1968 paper “Go To Statement Considered Harmful” (*[https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf)*).
    However, with SNOBOL, it’s all we have to work with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一点值得注意。在[清单 5-2](ch05.xhtml#ch05list2)中，goto无论行是否成功都会执行。虽然这行代码永远不会失败，但我们会看到其他会失败并且必须失败的行。这是语言工作方式的一部分。如果忘记区分成功与失败，并使用一个始终执行的goto，可能会导致奇怪的行为。当然，`goto`语句的潜在危险早已为人们所熟知——参见Edsger
    Dijkstra 1968年发表的著名论文《Go To语句被认为有害》（*[https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf)*）。然而，在SNOBOL中，这是我们唯一能使用的工具。
- en: '[Listing 5-3](ch05.xhtml#ch05list3) introduces a few new SNOBOL concepts.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-3](ch05.xhtml#ch05list3)引入了一些新的SNOBOL概念。'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-3: A bit of interaction*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：一点交互*'
- en: The first new concept is showing how to get input from the keyboard by referencing
    `input`; it returns a string that is assigned to the variable `name`. Notice that
    the variable `name` was not declared. Like Python, SNOBOL is dynamically typed,
    meaning that variables are created on demand and can hold whatever data is assigned
    to them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新概念是如何通过引用`input`从键盘获取输入；它返回一个字符串并将其赋值给变量`name`。请注意，变量`name`并没有声明。像Python一样，SNOBOL是动态类型的，这意味着变量是在需要时创建的，并可以存储任何被赋值的数据。
- en: The next line needs parsing. It’s an assignment to `output`, so it will ultimately
    print something on the screen. We see a constant string followed by `name`. There
    is space between them, so we expect the two to become a string using the name
    entered by the user. But what’s this `differ` thing? And the goto section is new,
    too.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行需要解析。这是对`output`的赋值，因此它最终会在屏幕上打印某些内容。我们看到一个常量字符串，后面跟着`name`。它们之间有空格，所以我们预计这两个将结合成一个字符串，使用用户输入的名称。但这个`differ`是什么？goto部分也很新颖。
- en: Let’s start with the goto. It’s `:f(again)`. The colon begins the goto. The
    `f` stands for failure. If the line fails, goto `again`, the line that asks for
    the user’s name. Okay, this seems reasonable; if the user’s input isn’t valid,
    ask again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从goto开始。它是`:f(again)`。冒号表示开始一个goto。`f`代表失败。如果这一行失败，程序跳转到`again`，也就是请求用户输入名字的那一行。好吧，这看起来很合理；如果用户的输入无效，就再问一次。
- en: 'Now for the `differ` part: `differ` is a SNOBOL predicate. Like all predicates,
    its purpose is to determine whether something is true or false. However, unlike
    in any other programming language I’ve ever encountered, SNOBOL predicates don’t
    return true or false. If the predicate is false, the function *fails*, and if
    any portion of a SNOBOL line fails, the entire line fails. If a line fails and
    there is a goto for a failure condition, that goto is then executed. So if `differ`
    fails, the line fails, and flow continues with the line labeled `again`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`differ`部分：`differ`是一个SNOBOL谓词。像所有谓词一样，它的目的是确定某事是否为真或假。然而，不像我遇到过的任何其他编程语言，SNOBOL谓词不会返回真或假。如果谓词为假，函数*失败*，而如果SNOBOL中的任何一行失败，则整行都会失败。如果一行失败并且有goto语句处理失败条件，则会执行该goto。所以如果`differ`失败，这一行就会失败，程序流会继续到标记为`again`的行。
- en: Truth in SNOBOL is the null string. I’m sure there’s a deep, philosophical implication
    to truth being null and empty, but we’ll stick with computer programming and avoid
    the headache. SNOBOL predicates that are true return the null string. So `differ`
    takes two objects and asks if they are not the same. Here the objects are whatever
    was assigned to `name` and SNOBOL’s constant for an empty string, `null`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在SNOBOL中，真值是空字符串。我相信，真值为空和空的深刻哲学含义肯定有很多，但我们还是专注于计算机编程，避免头痛。SNOBOL中为真的谓词返回空字符串。所以，`differ`接受两个对象并检查它们是否不同。在这里，两个对象是分配给`name`的内容和SNOBOL表示空字符串的常量`null`。
- en: 'This line, then, is checking to see if the user pressed ENTER without typing
    anything. If so, `differ` fails and program flow returns to `again`. If the user
    enters some text, `differ` succeeds and returns the empty string, which, because
    it’s separated from the string constant by a space, is concatenated with the string
    and the name. Concatenating a null string doesn’t change anything. It’s like adding
    zero. So the line succeeds and `output` is assigned. The trick of using a predicate
    that concatenates a null string to a line is a common one in SNOBOL. However,
    the predicate doesn’t need to be used that way; it can be on a line by itself.
    For example, the following code works just as well:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是在检查用户是否按下了ENTER键而没有输入任何内容。如果是这样，`differ`失败，程序流将返回到`again`。如果用户输入了一些文本，`differ`成功并返回空字符串，因为空字符串与常量字符串之间有一个空格，所以会与字符串和名称连接起来。连接一个空字符串不会改变任何东西，就像加零一样。因此，这一行成功，`output`被赋值。使用一个将空字符串连接到一行的谓词是SNOBOL中常见的技巧。然而，谓词不一定非要以这种方式使用，它也可以单独出现在一行中。例如，以下代码同样有效：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the `differ` is false, it fails, and the loop happens. If `differ` is true,
    the null string has no effect and the `output` proceeds.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`differ`为假，它会失败，循环会发生。如果`differ`为真，空字符串不会产生任何影响，`output`会继续。
- en: We have figured out how to print strings and get user input and store it in
    a variable. We were also introduced to the overall structure of a SNOBOL program
    and learned a bit about gotos. Let’s continue our exploration by concentrating
    on variables and data types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经弄清楚了如何打印字符串，获取用户输入并将其存储在变量中。我们还了解了SNOBOL程序的整体结构，并学习了一些关于goto的知识。让我们继续探索，集中关注变量和数据类型。
- en: '***Variables and Data Types***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变量和数据类型***'
- en: As we’ve already seen, SNOBOL variables are created on demand and can hold any
    value. Strings, integers, and floats are SNOBOL’s primitive data types. In this
    section, we’ll work with these primitives and then go beyond them to create custom
    data types. This is the SNOBOL equivalent of structures in other languages like
    C.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，SNOBOL变量是按需创建的，可以保存任何值。字符串、整数和浮点数是SNOBOL的基本数据类型。在这一部分，我们将使用这些基本数据类型，然后进一步创建自定义数据类型。这是SNOBOL中类似于其他语言（如C语言）结构体的概念。
- en: '**Integers and Floats**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数和浮点数**'
- en: '[Listing 5-4](ch05.xhtml#ch05list4) presents *temperature.sno*, a simple menu-driven
    program to convert between Fahrenheit and Celsius temperatures.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[列出5-4](ch05.xhtml#ch05list4)展示了*temperature.sno*，这是一个简单的菜单驱动程序，用于在华氏温度和摄氏温度之间进行转换。'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-4: Temperature conversion*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出5-4：温度转换*'
- en: The menu asks for the type of conversion or `q` to quit. The variable `menu`
    holds the user’s selection. Next comes a new predicate, `ident`. As you likely
    surmised from the name, `ident` is the opposite of `differ`; it’s true when the
    arguments are identical. Notice that `menu` is compared to the string constant
    `'2'` and not just 2\. This is one place where SNOBOL’s permissive automatic string
    conversion is not applied. The value returned by `input` is always a string, so
    we must use a string with `ident`. If we did use 2 and not `'2'`, there would
    be no error, but the predicate would fail, and because there is no fail goto defined,
    SNOBOL would proceed to the next line instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单会询问转换类型或输入 `q` 退出。变量 `menu` 保存用户的选择。接下来是一个新的谓词 `ident`。正如你从名字中可能推测的那样，`ident`
    是 `differ` 的反义词；当参数相同时它为真。注意，`menu` 是与字符串常量 `'2'` 进行比较，而不仅仅是 2。这是 SNOBOL 的一种地方性特性，不应用
    SNOBOL 的自动字符串转换。`input` 返回的值始终是一个字符串，因此我们必须在 `ident` 中使用字符串。如果我们使用 2 而不是 `'2'`，不会报错，但谓词会失败，因为没有定义失败的
    goto，SNOBOL 将继续执行下一行。
- en: The `ident` line shows us a new form of goto, `:s(CtoF)`. The `s` means success,
    and tells SNOBOL where to go if the line does not fail. In this case, not failing
    means the user selected option two. Thus, the program jumps to the label `CtoF`
    to convert Celsius to Fahrenheit. Likewise, the following line jumps to the end
    if the user entered a `q`. If the user entered neither `2` nor `q`, execution
    falls through to the code marked `F to C`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ident` 行展示了一个新的 goto 形式，`:s(CtoF)`。`s` 表示成功，告诉 SNOBOL 如果该行没有失败则跳转到哪里。在这种情况下，不失败意味着用户选择了选项二。因此，程序跳转到标签
    `CtoF` 进行摄氏度转华氏度的转换。同样，接下来的行如果用户输入了 `q`，则跳转到末尾。如果用户既没有输入 `2` 也没有输入 `q`，执行将继续到标记为
    `F to C` 的代码。'
- en: The conversions ask the user for a temperature, perform the proper conversion,
    report the result, and then jump back to `menu`. The conversions also do something
    subtle behind the scenes. The requested temperature is assigned to either `F`
    or `C`, which are then used in the conversion equation. In this case, SNOBOL does
    automatically convert the input to a number. Unless the user explicitly enters
    a decimal point or uses scientific notation, the resulting number is an integer;
    otherwise, it’s a float. This means the programmer is responsible for ensuring
    that expressions perform the proper conversion as to type. To make the input an
    integer, multiply by 1\. To make the input a float, multiply by 1.0 or use the
    `convert` function, which shows up later in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 转换程序会要求用户输入一个温度，进行相应的转换，报告结果，然后跳转回 `menu`。转换背后还做了一些细微的工作。请求的温度被赋值给 `F` 或 `C`，然后用于转换公式。在这种情况下，SNOBOL
    会自动将输入转换为数字。除非用户明确输入小数点或使用科学计数法，否则结果是一个整数；否则，它就是一个浮点数。这意味着程序员有责任确保表达式执行正确的类型转换。为了将输入转换为整数，可以乘以
    1。为了将输入转换为浮点数，可以乘以 1.0 或使用后面本章会提到的 `convert` 函数。
- en: There is more to notice in [Listing 5-4](ch05.xhtml#ch05list4). Look carefully
    at how we’ve written the conversion formulas. First, we use decimal points to
    force floating-point computation. Without them, the division operation would use
    integer math, though the expected promotion from integer to float happens if there
    is a float in the expression. However, be careful because each subexpression needs
    a float as well. In that case, `(9 / 5) * 100.0 + 32.0` would be `132` rather
    than `212` because the fraction is pure integer math returning 1 instead of 1.8.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 5-4](ch05.xhtml#ch05list4)中有更多需要注意的地方。仔细观察我们编写的转换公式。首先，我们使用小数点来强制进行浮点数计算。如果没有小数点，除法操作将使用整数数学，尽管如果表达式中有浮点数，整数到浮点数的提升会发生。然而，要小心，因为每个子表达式也需要一个浮点数。在这种情况下，`(9
    / 5) * 100.0 + 32.0` 将会是 `132` 而不是 `212`，因为分数是纯整数数学，返回 1 而不是 1.8。
- en: Notice that there are spaces around each of the operators in the conversions.
    These are not just for readability; SNOBOL requires them. Forgetting a space before
    or after an operator is an error, as SNOBOL will happily point out to you. Lastly,
    SNOBOL lacks the format specifiers found in languages like C and Python. SNOBOL
    expects the programmer to convert the number to a string with appropriate spacing
    and justification to format output. You’re on your own when formatting output
    in SNOBOL.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，转换中的每个运算符周围都有空格。这不仅仅是为了提高可读性；SNOBOL 需要这些空格。如果忘记在运算符前后加上空格，将会出错，SNOBOL 会很高兴地指出这一点。最后，SNOBOL
    缺乏像 C 和 Python 语言中那样的格式说明符。SNOBOL 期望程序员将数字转换为带有适当间距和对齐的字符串，以格式化输出。在 SNOBOL 中格式化输出时，你将完全依赖自己的能力。
- en: '[Listing 5-4](ch05.xhtml#ch05list4) implemented a simple menu by checking the
    user’s input with `ident`. SNOBOL also allows *computed gotos*. A computed goto
    uses an expression to determine the target label. [Listing 5-5](ch05.xhtml#ch05list5)
    shows *menu.sno*, which implements a simple menu with a computed goto.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-4](ch05.xhtml#ch05list4)通过使用`ident`检查用户输入实现了一个简单的菜单。SNOBOL还支持*计算的goto*。计算的goto使用一个表达式来确定目标标签。[列表
    5-5](ch05.xhtml#ch05list5)展示了*menu.sno*，它实现了一个带有计算goto的简单菜单。'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-5: Using a computed goto*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：使用计算的goto*'
- en: 'The menu loop asks the user to select an entrée, then outputs the name of the
    selected entrée. Not a particularly useful program, but it does have one interesting
    feature: `($(''menu'' menu))`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单循环会询问用户选择主菜，然后输出所选主菜的名称。这个程序并不特别有用，但它确实有一个有趣的特性：`($('menu' menu))`。
- en: The label matching the string formed by the expression inside `$(...)` is the
    goto’s target. The `$(...)` syntax is a form of indirection that tells SNOBOL
    to build the target label on the fly using the expression inside the parentheses.
    The expression is `'menu' menu`, which concatenates the word *menu* with the user’s
    number. Naturally, an actual application would validate the user’s input first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与`$(...)`内表达式匹配的标签是goto语句的目标。`$(...)`语法是一种间接引用，告诉SNOBOL动态地构建目标标签，使用括号内的表达式。表达式是`'menu'
    menu`，它将单词*menu*与用户输入的数字连接起来。当然，实际应用中首先需要验证用户的输入。
- en: Jumping to the proper label updates `order` and the desired entrée is displayed
    before jumping back to `loop`. If the user selects option four, the program jumps
    to label `menu4`, which falls through to `end` to exit the program.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到正确的标签更新`order`，并显示所需的主菜，之后跳回到`loop`。如果用户选择了选项四，程序会跳转到标签`menu4`，然后继续执行到`end`标签以退出程序。
- en: '**Indirection**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**间接引用**'
- en: Consider the following sequence of SNOBOL instructions from an interactive session.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下一段来自交互式会话的SNOBOL指令序列。
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line assigns `123` to `a`. The second uses the *name operator* (`.`)
    to assign the name of `a` to `b`. In SNOBOL, the name of a variable is similar
    to the address of a variable in languages like C. The third line sets `c` to the
    string `'a'`. Then come a series of `output` statements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`123`赋值给`a`。第二行使用*名称操作符*（`.`）将`a`的名称赋值给`b`。在SNOBOL中，变量的名称类似于C语言等语言中变量的地址。第三行将`c`设置为字符串`'a'`。接下来是一系列的`output`语句。
- en: The first displays `a` returning `123`, as expected. The second outputs `b`,
    which returns the name of `a`, `A`. SNOBOL is case insensitive, so the name of
    a variable is shown in all caps. The third `output` prints the string `'a'`, again,
    as expected.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出`a`，返回`123`，符合预期。第二个输出`b`，返回`a`的名称`A`。SNOBOL是大小写不敏感的，因此变量的名称以大写显示。第三个`output`输出字符串`'a'`，再次符合预期。
- en: The last three `output` statements are more interesting. They all use indirect
    references (`$`) to output not the value of the variable, but the value of the
    variable whose name is in the first variable. The variable `b` was assigned to
    the name of `a`, meaning it is the string `'A'`. So the indirect reference looks
    to `b` to get the string `'A'` and then looks for a variable called `A`, finds
    it, and returns *its* value. So the output of `$b` is `123`, the value of `a`.
    Using a string with the variable name works as well, which is why the output of
    `$c` is also the value of `a`. Lastly, the name operator and indirect reference
    are inverses of each other, so `$.a` means “name of `a` indirectly referenced
    back to `a`,” resulting in the value of `a`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个`output`语句更为有趣。它们都使用间接引用（`$`）输出的不是变量的值，而是第一个变量中名称所指向的变量的值。变量`b`被赋值为`a`的名称，这意味着它是字符串`'A'`。因此，间接引用会查找`b`，得到字符串`'A'`，然后寻找名为`A`的变量，找到后返回*它*的值。因此，`$b`的输出是`123`，即`a`的值。使用包含变量名的字符串同样有效，这就是为什么`$c`的输出也是`a`的值。最后，名称操作符和间接引用是互为逆运算的，因此`$.a`意味着“间接引用回`a`的`a`的名称”，最终得到`a`的值。
- en: '[Listing 5-6](ch05.xhtml#ch05list6) shows another indirection example, that
    of the file *indirect.sno*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-6](ch05.xhtml#ch05list6)展示了另一个间接引用的例子，即文件*indirect.sno*。'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-6: Another indirection example*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：另一个间接引用例子*'
- en: Take a look at the listing before reading further to see if you can guess what
    the output will be. Notice that the `output` statements use string concatenation
    to output two variables on one line with a single space between them. Read on
    when ready to see what SNOBOL says the output should be.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，先看看清单，看看你能否猜到输出是什么。请注意，`output` 语句使用字符串连接将两个变量输出到同一行，并且它们之间有一个空格。当准备好时继续阅读，看看
    SNOBOL 会怎么说输出应该是什么。
- en: 'SNOBOL reports the following as the output of [Listing 5-6](ch05.xhtml#ch05list6):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 报告如下内容作为 [清单 5-6](ch05.xhtml#ch05list6) 的输出：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of [Listing 5-6](ch05.xhtml#ch05list6) shouldn’t be mysterious.
    It’s normal variable output; `cosa1` and `cosa2` are the literal strings `'thing1'`
    and `'thing2'`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-6](ch05.xhtml#ch05list6)的第一行不应是神秘的。它是正常的变量输出；`cosa1` 和 `cosa2` 是字面字符串
    `''thing1''` 和 `''thing2''`。'
- en: At first glance, the second output line is a bit of a surprise. The code assigns
    variables `thing1` and `thing2` to `output`, but those variables are not explicitly
    defined in the code. The lines that create them are
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，第二行输出有些让人吃惊。代码将变量 `thing1` 和 `thing2` 赋值给 `output`，但这些变量在代码中并未显式定义。创建它们的代码行是
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: where the indirect reference is used to assign not to `cosa1` and `cosa2`, but
    to the variables created by the current value of `cosa1` and `cosa2`, which are
    `'thing1'` and `'thing2'`. Therefore, `thing1` equals `'mea1'` and `thing2` equals
    `'mea2'`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，间接引用用来将值赋给的不是 `cosa1` 和 `cosa2`，而是由当前 `cosa1` 和 `cosa2` 的值创建的变量，即 `'thing1'`
    和 `'thing2'`。因此，`thing1` 等于 `'mea1'`，`thing2` 等于 `'mea2'`。
- en: The next pair of lines in [Listing 5-6](ch05.xhtml#ch05list6) are similar.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-6](ch05.xhtml#ch05list6) 中的下一对行是类似的。'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To create two new variables, `mea1` and `mea2` assigned `'kitu1'` and `'kitu2'`,
    respectively. This explains why the third line of output is `kitu1 kitu2`. The
    indirect reference on `thing1`, containing `'mea1'`, returns the value of `mea1`,
    which is `'kitu1'`, and likewise for `thing2`. Because they were created by assigning
    to `$thing1` and `$thing2`, the next output line makes sense, too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个新变量 `mea1` 和 `mea2`，分别赋值为 `'kitu1'` 和 `'kitu2'`。这也解释了为什么第三行输出是 `kitu1 kitu2`。对
    `thing1` 的间接引用包含 `'mea1'`，返回 `mea1` 的值，即 `'kitu1'`，同理 `thing2` 也是如此。因为它们是通过赋值给
    `$thing1` 和 `$thing2` 创建的，所以下一行输出也能解释得通。
- en: The final assignment uses indirection twice on `cosa1`. The first indirection,
    that is, the rightmost `$`, returns `thing1`. The second indirection on `thing1`
    returns `mea1`’s value, which is `'kitu1'`. The same is true for `$$cosa2`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的赋值操作对 `cosa1` 使用了两次间接引用。第一次间接引用，即最右侧的 `$`，返回 `thing1`。第二次对 `thing1` 的间接引用返回
    `mea1` 的值，即 `'kitu1'`。对 `$$cosa2` 也同理。
- en: SNOBOL’s indirection and dynamic creation of variables during runtime are quite
    powerful and equally confusing if not used carefully. For the curious, *cosa*
    means “thing” in Spanish. Likewise, *mea* is Hawaiian for “thing” and *kitu* is
    Swahili for, you guessed it, “thing.”
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 在运行时的间接引用和动态变量创建功能非常强大，但如果使用不当也容易令人困惑。对于好奇的人，*cosa* 在西班牙语中是“事物”的意思。同样，*mea*
    在夏威夷语中是“事物”，*kitu* 在斯瓦希里语中是，没错，“事物”。
- en: '**User-Defined Data Types**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户定义的数据类型**'
- en: User-defined data types are created with the function `data`, which accepts
    a *string* as its argument. The string defines the name of the new type and the
    names of the elements of the type. SNOBOL creates a function to generate new instances
    of the type and functions with the names of the type elements. The latter functions
    are used to access elements of the type when it is used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的数据类型是通过函数 `data` 创建的，该函数接受一个 *字符串* 作为参数。这个字符串定义了新类型的名称以及类型元素的名称。SNOBOL
    创建一个函数来生成该类型的新实例，并为类型元素创建函数。后者函数用于在使用该类型时访问元素。
- en: 'For example, consider the following instructions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下指令：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first line defines a new data type, `complex`, which has two elements `real`
    and `imag`. We can use this data type to hold a complex number. A complex number
    has two parts: a real part and an imaginary part. The real part is a floating-point
    number corresponding to a number on the number line. The imaginary part is also
    a floating-point number which is multiplied, conceptually, by the square root
    of *–*1\. The square root of *–*1 doesn’t exist. No number multiplied by itself
    is negative, so it’s “imaginary.” Even though complex numbers don’t correspond
    to anything in the physical world, their properties are such that they make certain
    calculations vastly simpler. For our purposes, all we care about is that this
    new complex data type has two elements. Notice that the definition of `complex`
    is given as a string. Because of this, SNOBOL can create new data types on the
    fly at runtime, perhaps in response to user input or data read from a file. Also,
    and this is important, the data type string *must not* contain spaces. Thus, `''complex(real,imag)''`
    works, but `''complex(real, imag)''` generates an error.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: After defining `complex`, we immediately create two instances of it, `a` and
    `b`. To create an instance, use the name of the data type and supply a value for
    all the elements. Next are four `output` statements, the first two of which use
    `a` and `b`. In this case, SNOBOL prints the name of the data type, `COMPLEX`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The final two `output` statements use the `real` and `imag` functions SNOBOL
    created for us when `complex` was defined. We’ll learn how to create user-defined
    functions below. Here, SNOBOL does us a favor by making functions automatically.
    The functions return the respective elements of the `complex` variables passed
    to them. We’ll revisit the `complex` data type when we explore user-defined functions
    below.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '***Arrays and Tables***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SNOBOL supports multidimensional arrays with flexible indexing. Array elements
    are not typed and any data can be stored in an array element, including another
    array. This means SNOBOL supports nested arrays—arrays within arrays. Few languages
    have such flexibility with arrays.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL also supports associative arrays—or, to use modern terminology, dictionaries—though
    in SNOBOL they are called *tables*, a collection of key-value pairs. Like arrays,
    tables are not restricted in terms of the data they contain. However, unlike arrays,
    tables are not fixed in size and may grow as needed to accommodate more entries.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrays**'
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: SNOBOL arrays are created with the `array` function. The function’s argument
    determines the number of dimensions, the range of the indices for each dimension,
    and a default value for each element. Let’s examine different arrays to understand
    how they are defined and accessed. There are many small examples, so each will
    be presented as a code snippet and the resulting value of the element accessed.
    Most of the examples are in *array.sno*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The following declarations create different versions of the array `A`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明创建了不同版本的数组 `A`：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first is a 1D array with 10 elements indexed from [1, 10]. Like FORTRAN,
    SNOBOL indexes arrays from 1 unless told otherwise. The second is also a 10-element
    vector with indices in [0, 9]. Notice that the array specification is a string.
    This is required to specify nonstandard index ranges. The third line defines a
    3D array. The indices of the first dimension are in [0, 7]. The second dimension
    uses the defaults, [1, 20]. Lastly, the third dimension uses *–*1, 0, and 1 as
    indices. The final line defines a 2D array with indices in [1, 128], specified
    as a string, with each element initialized to 0.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个包含 10 个元素的 1D 数组，索引范围从 [1, 10]。与 FORTRAN 类似，SNOBOL 默认将数组索引从 1 开始，除非另有说明。第二个也是一个包含
    10 个元素的数组，索引范围为 [0, 9]。注意，数组的规格是一个字符串，这对于指定非标准的索引范围是必要的。第三行定义了一个 3D 数组。第一个维度的索引范围为
    [0, 7]，第二个维度使用默认值 [1, 20]。最后，第三个维度使用 *–*1、0 和 1 作为索引。最后一行定义了一个 2D 数组，索引范围为 [1,
    128]，它被指定为字符串格式，每个元素初始化为 0。
- en: SNOBOL manages memory independently, meaning that this sequence of array declarations
    is allowed as a sequence of SNOBOL statements. Each new array declaration destroys
    the previous, automatically freeing its memory. If you try allocating a large
    array and get the `Insufficient storage to continue` error, the `-d` command line
    option tells SNOBOL to reserve more memory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 独立管理内存，这意味着这一系列数组声明作为 SNOBOL 语句的序列是允许的。每个新的数组声明都会销毁前一个声明，自动释放其内存。如果尝试分配一个大数组并出现
    `Insufficient storage to continue` 错误，可以使用 `-d` 命令行选项来告诉 SNOBOL 保留更多内存。
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the argument `10m` allocates 10MB worth of *descriptors*, each of which
    uses 16 bytes. On my system, `-d 300m` took about 15 seconds to initiate an interactive
    session and used about 4.8GB of system memory. The price paid for SNOBOL’s array
    flexibility is speed and memory use compared to standard fixed-data type arrays.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数 `10m` 分配了 10MB 的 *描述符*，每个描述符使用 16 字节。在我的系统上，`-d 300m` 大约花费了 15 秒来启动交互式会话，并使用了大约
    4.8GB 的系统内存。SNOBOL 数组的灵活性带来了速度和内存使用上的代价，相较于标准的固定数据类型数组。
- en: Let’s see a SNOBOL array in action ([Listing 5-7](ch05.xhtml#ch05list7)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 SNOBOL 数组的实际应用 ([列表 5-7](ch05.xhtml#ch05list7))。
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-7: A 1D array*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：一个 1D 数组*'
- en: '[Listing 5-7](ch05.xhtml#ch05list7) defines a 1D array of 10 elements with
    indices in [0, 9]. The next three lines assign the array’s elements, first to
    a string, then a float, and lastly, an integer. The next line assigns `A[3]` to
    an array of six elements with indices in [1, 6]. This is a nested array because
    it is part of the larger 10-element array, `A`. To assign elements of the nested
    array requires first selecting the nested array with `A[3]` and then selecting
    the desired element of the nested array, here the first: `A[3][1] = ''nested''`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-7](ch05.xhtml#ch05list7) 定义了一个包含 10 个元素的 1D 数组，索引范围为 [0, 9]。接下来的三行将数组的元素依次赋值为字符串、浮点数和整数。接下来一行将
    `A[3]` 赋值为一个包含 6 个元素的数组，索引范围为 [1, 6]。这是一个嵌套数组，因为它是更大 10 元素数组 `A` 的一部分。要为嵌套数组赋值，首先需要通过
    `A[3]` 选择嵌套数组，然后选择嵌套数组中需要的元素，这里是第一个：`A[3][1] = ''nested''`。'
- en: The five `output` statements display the assigned values. There is something
    new here, the `convert` function, which changes a variable’s type. The `output`
    statement is concatenating a string with the value of the array element. However,
    `A[3]` is not something automatically converted into a string. Therefore, `convert`
    is used to represent it as a string. The first argument to `convert` is the object
    to be converted and the second argument is a string naming the target type, in
    this case a string. We’ll use `convert` again later to change between arrays and
    tables.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 五个 `output` 语句展示了被赋值的内容。这里有一个新概念，即 `convert` 函数，它用于改变变量的类型。`output` 语句将一个字符串与数组元素的值连接在一起。然而，`A[3]`
    并不是一个自动转换为字符串的内容。因此，使用 `convert` 将其表示为字符串。`convert` 的第一个参数是要转换的对象，第二个参数是一个字符串，指定目标类型，这里是字符串。稍后我们将再次使用
    `convert` 来在数组和表格之间转换。
- en: Now consider [Listing 5-8](ch05.xhtml#ch05list8).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请看一下 [列表 5-8](ch05.xhtml#ch05list8)。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-8: A 2D array*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：一个 2D 数组*'
- en: The array `B` is 2D with both indices in [1, 128] and all elements are initialized
    to 0\. Assignments follow using both indices. Note that SNOBOL has no limit on
    the number of dimensions an array may use. Element `B[12,45]` has been assigned
    a nested 11×11 array. The assignment to `B[12,45]<5,6>` seems unusual, but it
    isn’t. SNOBOL allows `<` and `>` in place of square brackets for indexing arrays.
    Consider them a relic of the 1960s.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The following two lines define the complex data type we saw above and then use
    it to store a complex number in `B[12,45][1,2]`. The `output` statement displays
    the complex number using the `real` and `imag` functions to extract the real and
    imaginary parts before piecing them together as `3+0.141592i`, which is the usual
    way imaginary numbers are displayed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*Some languages, like Python, use `j` in place of `i` to indicate a complex
    number. Engineers do this because `i` usually refers to electric current in their
    world. Mathematicians prefer `i` because electric current doesn’t exist in *their*
    world.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Now consider [Listing 5-9](ch05.xhtml#ch05list9) with two blocks of code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-9: Array references and copying*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The first block defines `A` and sets `A[0]` to the string `''xyzzy''`. Next,
    it creates `D` by assigning `A`, after which it immediately sets `D[0]` to `12345`.
    The question is: what does the following `output` statement display? The answer
    is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because simple assignment of an array does not copy it; it only makes
    `D` refer to the same object as `A`. This behavior is typical of most programming
    languages. As arrays might occupy a significant portion of memory, it is best
    to copy them only when essential.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the second code block of [Listing 5-9](ch05.xhtml#ch05list9). It
    restores the original value of `A[0]` and creates `E` using the `copy` function
    before assigning `E[0]` the string `'plugh'`. Then come two `output` statements.
    We might guess the output at this point.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `copy` function duplicated `A`, so updating `E[0]` did not alter the original
    array. However, be aware that `copy` makes only *shallow* copies. In a shallow
    copy, nested arrays are not copied, only referenced.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Tables**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: SNOBOL tables are like Python dictionaries. They associate a key with a value,
    which can also be any type of data. A few examples should suffice to illustrate
    their use (see [Listing 5-10](ch05.xhtml#ch05list10)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-10: Using a table*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-10](ch05.xhtml#ch05list10) shows almost all that is needed to understand
    a table. It first defines the now familiar `complex` data type, followed by a
    table, `t`. Four assignments to `t` follow, each with a different data type as
    the key. The four `output` statements produce'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This might not match your expectations, as there is no `three` in the output.
    To recover the value for a key, the key used must match exactly. The key for `three`
    was `complex(2,3)`. That’s a perfectly valid key, but passing another instance
    of `complex(2,3)` will not find its value because the two do not evaluate to the
    same object in memory. Using `c` as a key does allow `four` to be recovered because
    `c` references the same data structure in memory. The last lesson from [Listing
    5-10](ch05.xhtml#ch05list10) is that referencing a key that doesn’t exist returns
    `null` but is not an error. To check whether a key is in the table, use the `ne`
    predicate to check the value returned against `null`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与您的预期不符，因为输出中没有 `three`。要恢复一个键的值，必须使用完全匹配的键。`three` 的键是 `complex(2,3)`。这是一个完全有效的键，但传入另一个
    `complex(2,3)` 实例将找不到其值，因为这两个对象在内存中的评估结果并不相同。使用 `c` 作为键可以恢复 `four`，因为 `c` 引用了内存中的相同数据结构。来自[列表
    5-10](ch05.xhtml#ch05list10)的最后一课是，引用一个不存在的键会返回 `null`，但并不算错误。要检查某个键是否在表格中，可以使用
    `ne` 谓词来检查返回的值是否与 `null` 相等。
- en: The `table` declaration accepts up to two arguments. The first is the table’s
    initial size, the number of entries for which memory has already been allocated.
    Tables are dynamic, meaning they grow as needed. The second argument is the number
    of entries to grow by whenever the table must grow. If no arguments are given,
    `table()` is equivalent to `table(10,10)`. If you know the table will be large
    but mostly fixed when established, use a large first argument and a smaller second
    argument. Conversely, if you don’t know how large the table will be but expect
    that many entries will be added, use a small initial size and a larger second
    argument.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`table` 声明接受最多两个参数。第一个是表格的初始大小，即已经分配内存的条目数量。表格是动态的，意味着它会根据需要增长。第二个参数是每当表格需要增长时增加的条目数。如果没有给定参数，`table()`
    等同于 `table(10,10)`。如果您知道表格在建立时会很大，但大部分是固定的，可以使用一个较大的第一个参数和一个较小的第二个参数。相反，如果您不知道表格的大小，但预计会添加许多条目，可以使用一个较小的初始大小和一个较大的第二个参数。'
- en: '[Listing 5-11](ch05.xhtml#ch05list11) defines a table with initial room for
    100 entries, `z`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-11](ch05.xhtml#ch05list11) 定义了一个初始容量为 100 条目的表格 `z`。'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-11: Another table example*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：另一个表格示例*'
- en: 'The first four assignments to `z` are straightforward, though recalling the
    value of *π* to eight decimals so it can be used as a key to remember the string
    `''pi''` is admittedly rather silly. The example gets worse. We define an array,
    `a` ➊, and assign the table, `z`, to its seventh element ➋. Then, in the next
    line, we put `a` in the table ➌. We’ve have an odd situation: the table we just
    placed `a` into is referenced by `a` itself.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `z` 的前四次赋值很简单，尽管为了记住字符串 `'pi'`，要回想 *π* 的八位小数并将其用作键，确实显得有些愚蠢。这个例子变得更糟。我们定义了一个数组
    `a` ➊，并将表格 `z` 赋值给其第七个元素 ➋。然后，在下一行中，我们将 `a` 放入表格 ➌。我们遇到了一个奇怪的情况：我们刚刚放入 `a` 的表格现在又被
    `a` 自身引用。
- en: The `output` statements generate
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`output` 语句生成'
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We get the integer `2`, the array `a`, the name `pi` from its floating-point
    value to eight decimals, and then the final output, also `pi`. The final output
    was generated by ➍. Because `a` is in `z`, and `z` is in `a`, we can use an arbitrary
    number of pairs of references, first `[a]` to return the array followed by `[7]`
    to get `z` from the array, to finally arrive again at `z` and recover `pi`. Of
    course, this is a ludicrous thing to do, but SNOBOL doesn’t judge.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了整数 `2`、数组 `a`、浮点值到八位小数的名字 `pi`，然后是最终的输出，也是 `pi`。最终的输出是由 ➍ 生成的。因为 `a` 在
    `z` 中，而 `z` 又在 `a` 中，我们可以使用任意数量的引用对，首先是 `[a]` 返回数组，再加上 `[7]` 从数组中获取 `z`，最后再次到达
    `z` 并恢复 `pi`。当然，这是个荒谬的做法，但 SNOBOL 不会评判。
- en: How can we know what keys a SNOBOL table has? In Python, we can use the `keys`
    method. In SNOBOL, we convert the table to an array to get at the keys. Likewise,
    we can convert a properly structured array into a table. [Listing 5-12](ch05.xhtml#ch05list12)
    illustrates an example of each.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道 SNOBOL 表格中有哪些键？在 Python 中，我们可以使用 `keys` 方法。在 SNOBOL 中，我们将表格转换为数组以获取键。同样，我们也可以将正确结构的数组转换为表格。[列表
    5-12](ch05.xhtml#ch05list12) 展示了每种情况的示例。
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-12: Converting tables to arrays and arrays to tables*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12：将表格转换为数组，并将数组转换为表格*'
- en: We first create a table ➊ and add three entries. Next, we call `convert` to
    change the table into an array, `x`. The array has *n* × 2 dimensions if there
    are *n* entries in the table. The first column is the key and the second column
    is the value. The keys and values are printed using a simple loop ➌. Notice that
    the loop ends when accessing the array fails because the index, `i`, is too large.
    In SNOBOL, you code for failure.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: To go the other way and convert an array into a table, consider ➍. A 2D array
    is created with the first column as the key and the second column as the value.
    Another call to `convert` makes the properly structured array a table ➎.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL arrays and tables are flexible and more advanced than many other languages
    of the time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: And now for something completely different.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '***A Blizzard of Patterns***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll introduce patterns, though a thorough understanding of
    patterns is beyond what we can hope to cover in a single chapter. There are two
    types of pattern statements in SNOBOL. The first applies a pattern to a string.
    The second applies a pattern to a string and updates the portion of the string
    that matched the pattern. We’ll learn about patterns in B. F. Skinner fashion,
    a little bit at a time, with examples.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**A First Example**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider [Listing 5-13](ch05.xhtml#ch05list13), which presents a simple program
    accepting lines of text from the user until the string `'hello'` appears in one
    of the lines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 5-13: A simple pattern example*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the program calls `input` to return a string. The second string,
    which at first might appear to be concatenated because of the space, is a pattern,
    with the pattern matching a constant string. If the text returned by `input` has
    `'hello'` anywhere within it, the pattern match succeeds. If not, it fails, and
    the goto for failure asks the user for another string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-13](ch05.xhtml#ch05list13) is an example of the first type of pattern
    matching statement: a *text pattern*. In a pattern, success or failure of the
    match decides what happens next; however, as we’ll see, a pattern can generate
    new variables that hold pieces of the matched pattern. This means that many pattern
    matching statements are assigning data even if they don’t have explicit gotos.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The pattern matches only an explicit string of characters. If we want to check
    for other options, we use alternation, `|` (with spaces!). Therefore, to accept
    either `'hello'` or `'aloha'`, use `'hello' | 'aloha'` as the pattern.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, SNOBOL has many bits and pieces for matching various patterns.
    The ones we’ll examine are `len`, `span`, `pos`, `any`, and `break`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Matching and Updating Strings**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The second pattern statement matches a pattern and updates the text matched
    with new text. See [Listing 5-14](ch05.xhtml#ch05list14).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-14: Matching and updating a string*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The output of this program is `how now blue giraffe?`, where `color` matched
    to change `brown` to `blue`, and `animal` matched to change `cow` to `giraffe`.
    If the match fails, the string is not updated. Note that a match succeeds when
    the first success happens. Therefore,
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: produces `The black bear approached the brown car`. To update all matches, use
    a loop.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example loops for as long as the pattern `'brown'` is found, replacing
    it with `'black'` each time. The output is now `The black bear approached the
    black car`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Extracting Information from a String**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What if we want to extract the matched text? When used in a pattern, the name
    operator (`.`) extracts the matched text to a variable. See [Listing 5-15](ch05.xhtml#ch05list15).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-15: Capturing the matched text*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Several new things are happening in [Listing 5-15](ch05.xhtml#ch05list15), so
    let’s go through it carefully. Structurally, the program consists of four pattern
    definitions, which are the variables ending in `pat`. This is followed by a piece
    of example text with a first name, last name, and address. Our goal is to break
    this text apart into its individual fields. The pattern matching line comes next,
    followed by an `output` statement to print the data in a new format.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain what’s happening, line by line. First, we define `dpat` ➊. This
    is a pattern to match one or more instances of a comma, colon, or space. That’s
    what `span` does; it matches the longest possible sequence consisting of nothing
    but the characters in its argument.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Next comes `lpat` ➋. This pattern matches characters up to, but not including,
    the first occurrence of a comma or colon. That’s what `break` does. If the string
    is `abcde:f`, then `break(',:')` matches the string `abcde`, but not the colon.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `break` is next to the name operator, followed by `last`, with the entire
    expression surrounded by parentheses. The expression matches characters up to,
    but not including, the first comma or colon, and stores them in the variable `last`.
    Looking at line ➎ makes it clear that `lpat` matches the last name.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: However, ➋ has a `dpat` hanging at the end. It’s there to match the comma or
    colon that ended the `break`. As SNOBOL attempts to match a pattern, internally,
    it’s moving a *cursor* over the string, character by character, forward and sometimes
    backward to try other options. When the `break` of `lpat` matches, the cursor
    is looking at the comma or colon that ended the `break`. So we use `dpat` to skip
    it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `fpat` ➌ is nearly identical to ➋; however, the matched text
    is stored in `first`. That is, `fpat` matches the first name. As before, a `dpat`
    at the end of the pattern consumes the comma or colon that ended the `*break*`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The internal cursor has now matched the last name and first name. The remaining
    pattern, `apat`, uses the special pattern, `rem`, to match the remainder of the
    line and assign it to `address` ➍.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: To test the patterns, we define `text` to be a string with a last name, first
    name, and address using a comma and a colon as delimiters along with some extra
    spaces ➎.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we apply the patterns to `text` ➏. Notice that, at first glance, ➏ is
    just a sequence of four variables in a row. However, SNOBOL knows to parse this
    as a string followed by a pattern. The string is `text`; therefore, the remaining
    variables form the pattern. The overall pattern is built by concatenating `lpat`,
    `fpat`, and `apat`. We might, for clarity, put parentheses around the three pattern
    variables. If we wanted to concatenate two or more text strings and then apply
    a pattern, the parentheses would be placed around those variables.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'When ➏ executes, the last name, first name, and address are extracted. To prove
    this, ➐ dumps the same information rearranged to be first name, then last name,
    followed by the address. Notice that `address` is passed to `trim`, the SNOBOL
    function to remove trailing spaces from a string. The output of [Listing 5-15](ch05.xhtml#ch05list15)
    is `''Julius Caesar, address: 1313 Mockingbird Ln''`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**More Elaborate Pattern Matching**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at three more quick pattern matching examples. The first two manipulate
    a file of dates. The last one updates Lewis Carroll’s *Alice’s Adventures in Wonderland*
    to give “Bob” a chance to put himself in the story.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-16](ch05.xhtml#ch05list16) maps numeric dates in North American
    format (month, day, year) to European-style dates (day, month, year).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 5-16: Manipulating dates with patterns, take one*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The pattern, `pat`, uses `len` to match the specified number of characters,
    regardless of what they are. The first two characters are assigned to `month`,
    followed by a slash or dash; then the next two characters are put in `day`, followed
    by another slash or dash and a four-character year.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-15](ch05.xhtml#ch05list15) is in the file *dates.sno*. There is
    another file in the same directory called *dates.txt* that contains a set of numeric
    dates. For example, the first few lines of the file are'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: with some dates using slashes and some using dashes. A few even use a mix. [Listing
    5-15](ch05.xhtml#ch05list15) uses a `loop` to read the file, line by line. Each
    line is read with `input` using command line redirection and placed into `text`.
    If there is nothing left to read, the `input` command fails and SNOBOL jumps to
    the end.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If the read succeeds, the pattern is applied to `text`, but this time in the
    form `string pattern = update`, where the text matched by `pattern` is replaced
    by the text in `update`. Here, the replacement text is constructed from the day,
    month, and year matched by `pat`, using slashes between elements ➋.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Notice that ➋ has a goto for failure. If the pattern doesn’t match, the input
    string is not a valid date format, so the program jumps to `bad` to output `unknown
    format` before jumping back to the loop to process the next input. If the pattern
    match doesn’t fail, `text` has been updated so it’s `output` before jumping to
    `loop` to read the next date.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Run *dates.sno* with
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: to produce
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The final `unknown format` line corresponds to an input of `AVCDe-224*`, which
    is clearly not a valid date.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The next example uses `dates.txt`, but produces full dates instead of numeric
    dates. See [Listing 5-17](ch05.xhtml#ch05list17).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 5-17: Manipulating dates with patterns, take two*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The pattern, `pat`, is the same as in [Listing 5-16](ch05.xhtml#ch05list16).
    Additionally, we define `m`, an array holding the names of the months.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The code runs in the same way as [Listing 5-16](ch05.xhtml#ch05list16) but
    outputs a full date using the number of the month as the index into the array
    of names. Also, notice that both `day` and `year` are multiplied by 1\. The text
    matched is a string. To output the day and year without leading 0s, as there are
    a few three-digit years in `dates.txt`, we convert the strings to integers. [Listing
    5-17](ch05.xhtml#ch05list17) is in the file *dates2.sno*. Run it to produce this
    output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For our final pattern example, with apologies to Lewis Carroll, we’ll update
    the first part of *Alice’s Adventures in Wonderland* to be *Bob’s Adventures in
    Wonderland.* The text we’ll work with is in the file *alice.txt*, and consists
    of the beginning part of [Chapter 1](ch01.xhtml#ch01).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The code we need is in *alice.sno* and [Listing 5-18](ch05.xhtml#ch05list18).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 5-18: Making Bob’s Adventures in Wonderland*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-18](ch05.xhtml#ch05list18) begins by defining two patterns, `p`
    and `s`. The first uses alternation to match nothing (`null`) or `any` single
    character that is a space, period, comma, question mark, exclamation point, or
    right parenthesis. The second pattern uses `pos` to match cursor position zero,
    that is, the beginning of a line, a space, or a left parenthesis.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the program is a loop from `input` to `output` via `loop`.
    Between the input and the output there are seven lines, `s0` through `s6`. Each
    of these lines is a loop (notice the success gotos) and has a similar format.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first part is the text read from the input file, `text`. The rest of the
    line up to the equals sign is a pattern. The pattern looks for a match to a word,
    such as the name `'Alice'`, storing the character before the word in `a` and the
    character after in `c`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The matched text, if any, is replaced by the same leading and trailing character
    with the matched word updated. Thus, “Alice” is replaced with “Bob,” “her” is
    replaced with “his,” and so on. Recall that a match is successful after the first
    one is found, so if there are multiple occurrences of “Alice” in the line, only
    the first will be replaced with “Bob.” So we must loop until the match fails to
    replace all occurrences.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: After all seven patterns are tested and matched as much as possible, the updated
    `text` is `output` and the loop begins again until there is no input left.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The first paragraph of *alice.txt* is
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The same paragraph after the “Bob” conversion is
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The conversion isn’t foolproof, but that isn’t SNOBOL’s fault. There are cases
    in English where the word “her” should be changed to “his” and cases where it
    should become “him.” The code of [Listing 5-18](ch05.xhtml#ch05list18) knows nothing
    of the context, so it always uses “his.”
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to discover concerning SNOBOL patterns. An excellent place
    to learn more is [Chapter 2](ch02.xhtml#ch02) of Griswold, Poage, and Polonsky’s
    *The SNOBOL4 Programming Language* (Prentice Hall, 1971). Versions of the second
    edition are floating around the internet if you care to take a look.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to SNOBOL’s user-defined functions, perhaps the least elegant
    part of the language (aside from relying solely on goto for flow control).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '***Functions***'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SNOBOL would be a weak language indeed if it had no facility for users to define
    functions. Thankfully, it does, though the syntax is a bit strange. In this section,
    we’ll learn how to define and use functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We’ll jump right in with [Listing 5-19](ch05.xhtml#ch05list19). This program,
    in the file *poly.sno*, defines a function to implement arbitrary polynomials
    of the form
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *a**x*² + *b**x* + *c*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: which we use to output (*x*, *y*) pairs for plotting the function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 5-19: A user-defined function*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL functions begin with a `define` statement ➊. There are a couple of important
    things to notice about ➊. First, the function declaration is a string. It begins
    with the name of the function (`poly`), followed by an opening parenthesis, the
    list of arguments, and a closing parenthesis. If the function uses local variables,
    they are listed next, separated by commas, as part of the string. Note that the
    string portion of the `define` statement *must not* include spaces. No spaces
    between the arguments, no spaces in the list of local variables, no spaces anywhere.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to notice is that the `define` statement ends with a goto (`epoly`).
    This label must jump to just beyond the end of the function’s body, that is, it
    must not include any code that is part of the function. The function’s body is
    the code between the `define` statement and the ending label, which here is `epoly`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The function body begins with a label matching the function’s name, which is
    `poly` in this case. The body of the function is free to use the arguments, any
    local variables, and any global variables. The value returned by the function
    is assigned to a variable of the same name, as is sometimes done in other programming
    languages. In [Listing 5-19](ch05.xhtml#ch05list19), the variable `poly` is assigned
    the value of the quadratic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'To exit the function, SNOBOL defines two special goto labels: `return` and
    `freturn`. Use the former if the function was successful and the latter if not.
    The function `poly` always succeeds, so we use `return` to exit.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL allows recursion, as shown in [Listing 5-20](ch05.xhtml#ch05list20),
    which implements the factorial function. The factorial of an integer, *n*, is
    *n*! = *n*(*n –* 1)(*n –* 2)*…* 1\. For example, 5! = 5 × 4 × 3 × 2 × 1 = 120.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think about the factorial of *n* is that it’s *n* times the factorial
    of *n –* 1, which is itself *n –* 1 times the factorial of *n –* 2, and so on
    down to 1\. That’s the recursive version. In Python, we might write this process
    as
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: where `fact` calls itself to solve the simpler problem. All recursive functions
    need a base case, something that stops the recursion. In this case, it’s checking
    if *n* is less than 1\. This catches the edge case of 0! = 1.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Translating the recursive formula into SNOBOL leads to [Listing 5-20](ch05.xhtml#ch05list20).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 5-20: A recursive factorial function*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The definition accepts *n*. The first line of the body implements the base case.
    If *n* > 0, then `eq(n,0)` fails, so `fact` is not assigned and the next line
    is executed. If *n* = 0, `eq(n,0)` succeeds, so we return from the function via
    `s(return)`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The second line of `fact` implements the recursion. It assigns `fact` to `n`
    times whatever `fact(n - 1)` returns and then it returns via `(return)`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The main code asks the user for a number and returns the factorial. Run it and
    enter integers in [0,20]. Beyond 20, integers overflow; however, if you enter
    a floating-point number, you can estimate larger factorials. Also, notice the
    use of `convert` to force `n` to be an integer for display purposes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a function to swap the value of two variables. This should be easy.
    Our first attempt is
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: which defines `swap`. The value of `x` is kept in `t`, then `y` is assigned
    to `x` and `t` is assigned to `y`, followed by a return. The main body of the
    program sets *a* = 3 and *b* = 5, outputs their values, calls `swap`, and then
    outputs them again. Running the code produces
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is clearly incorrect. The values haven’t changed. Why? The algorithm in
    `swap` is correct, so why didn’t the values change?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL passes simple variables by *value*, meaning the value of `a` is assigned
    to `x`. So when `x` is updated in the body of `swap`, `a` is not affected. To
    update the variables, we need to pass the data by *reference* so `x` is really
    a synonym for `a`. After that, updates to `x` will affect `a`. Note that SNOBOL
    passes arrays and tables by reference.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The code above is wrong. I don’t want you to use it. However, the code in [Listing
    5-21](ch05.xhtml#ch05list21) does work correctly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 5-21: Passing variables by reference*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on `swap`. It looks much like the wrong version, but it uses the
    indirection operator (`$`) before each argument, `$x`. Recall that indirection
    means “not this variable, but the variable named by this variable.” Think of indirection
    as dereferencing a pointer in other languages. The `swap` function is now working
    directly with names passed to it rather than copies of the variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The main body of [Listing 5-21](ch05.xhtml#ch05list21) will clarify. The first
    call to `swap` passes `a` and `b` ➊. The second call uses the name operator to
    pass the names of `a` and `b` ➋. The last call passes the literal strings `'a'`
    and `'b'`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Running [Listing 5-21](ch05.xhtml#ch05list21) produces
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first output line shows us the original values of `a` and `b`. The second
    output line shows the effect of ➊ in [Listing 5-21](ch05.xhtml#ch05list21). There
    is no effect. The variables are unchanged because we passed their values rather
    than their names, so the indirection operator failed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The third output line shows the effect of ➋. Now `swap` is working. The name
    operator passed the strings `'a'` and `'b'`, which the indirection operator can
    interpret to mean that `a` and `b` are swapped.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The final output line shows the effect of ➌. Here we pass the literal strings
    naming `a` and `b`. This is really what the name operator is doing, so `swap`
    works and swaps `a` and `b` again to restore them to their original values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, SNOBOL passes simple variables by value, requiring the use of indirection
    to update them. However, arrays and tables are always passed by reference.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We know how to set up SNOBOL programs and how to create custom functions and
    data types. Now, let’s take a quick look at disk files.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '***Input and Output***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve seen `input` and `output` many times already. In this section, we’ll see
    how they work with disk files.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-22](ch05.xhtml#ch05list22) presents code to make an uppercase copy
    of a text file.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Listing 5-22: Uppercasing a disk file*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot here, so let’s walk through the code line by line. First, open
    the source text file by supplying arguments to `input`. The first argument is
    not the name of the file. Instead, it’s the name of a variable SNOBOL associates
    with the file. It’s what we use to read data from the file, so let’s call it `read`.
    The next argument is a unit number. This is a throwback to old-style programming
    where unit numbers were associated with operating system devices. The unit number
    needs to be unique for each open file. Use numbers of at least 10 or higher. Think
    of the unit number as a file reference.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: After the unit number comes the maximum line length. Input lines longer than
    this are truncated. Remember, this is a text file, and SNOBOL works with lines
    of text. The final argument is the name of the disk file. We’re using `host(2,2)`,
    which is specific to our version of SNOBOL. This is a link to the actual operating
    system. The first argument, `2`, refers to command line arguments. The second
    number refers to items on the command line. The second item is the first argument
    after the script name. Therefore, `host(2,2)` gives us the name of the first file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: To open the output file, we use `output`. As with `input`, the first argument
    is the name of a variable to which we will assign the output. We use unit `11`
    for output. The third argument is `'W'` to write a text file. Use `'A'` to append
    a file. The last argument is the name of the output file, here `host(2,3)`, which
    uses the second argument passed to the SNOBOL program.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The files are now open, so let’s read lines from the input, uppercase them,
    and write them to the output. At ➊ we use `read`, tied to the input file, to get
    a line in `text`. If the read fails, the input file is exhausted, so we jump to
    `close`. Otherwise, proceed to apply the intrinsic `replace` to the text to uppercase
    the line; `replace` updates all occurrences of characters in the second argument
    by the corresponding character in the third argument. To save typing, we use the
    predefined strings of lowercase and uppercase letters. SNOBOL variables beginning
    with `&` are system-supplied variables. The output of this line uppercases `text`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: To dump the text to the output file, assign it to `write`, which is the variable
    associated with the output file ➋. After dumping the newly uppercased text, we
    jump back to `loop` to continue.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to close the input and output files before using `endfile` to
    exit.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-22](ch05.xhtml#ch05list22) is in the file *uppercase.sno*. Let’s
    run it on the *Alice’s Adventures in Wonderland* text to uppercase it.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The file *uppercase.txt* now contains `ALICE` in all caps.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The example above worked with a text file. SNOBOL can also work with binary
    data. Let’s write a simple file copy program to read and write binary data. [Listing
    5-23](ch05.xhtml#ch05list23) shows *copy.sno*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 5-23: Copying a file*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-23](ch05.xhtml#ch05list23) is quite similar to [Listing 5-22](ch05.xhtml#ch05list22),
    but the input and output files are opened in binary mode. For `input`, where before
    we supplied the maximum line length, we now have `''B,4096''`. This specifies
    binary mode, meaning no line endings are interpreted, and a buffer of 4096 bytes.
    This means the source file will be read in 4096-byte chunks, or fewer if there
    aren’t at least 4096 bytes left to read. For output, use `''B''` to indicate binary
    mode.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The loop, in this case, is a one-liner ➊. Read a 4096-byte chunk of the input
    and immediately assign it to `write` to write it to the output file. When `read`
    fails, jump to close the files. Otherwise, jump back to this same line of code
    to continue the loop.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'To test *copy.sno*, try the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This should copy the given *src.png* image to *dst.png*. The image is of a young
    raccoon and is taken from the open source SciPy toolkit.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Machine Learning with SNOBOL**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s work through a little SNOBOL project to implement a simple machine learning
    classifier. Modern artificial intelligence is far removed from what computer scientists
    had in mind back when SNOBOL was new. Machine learning existed then, but the term
    “artificial intelligence” was not used to describe it for the most part.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '*Artificial intelligence* now most often refers to that part of machine learning
    known as deep learning, that is, advanced neural networks, often with millions
    to billions of connections between the nodes (neurons). SNOBOL is not a good choice
    for such models. However, classical machine learning includes basic algorithms
    that are sometimes quite straightforward to implement and that sometimes perform
    quite well despite their simplicity.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the goal of this section is to build a complete SNOBOL application
    to classify datasets using a simple machine learning technique—a *nearest neighbor*
    classifier.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '***Machine Learning 101***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Machine learning maps feature vectors to class labels. A *feature vector* is
    a collection of numeric values called *features*; that’s our input. We take this
    input and try to assign it a *class label*, that is, a category or class. For
    example, one of the datasets we’ll work with relates to iris flowers. This dataset
    is perhaps the oldest in machine learning and one of the easiest to work with.
    It consists of 150 measurements of three different species of iris flowers.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four measurements per flower: two measuring the petal length and
    width and two measuring the sepal length in width. These four measurements are
    the features and the three different species are the classes.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning models must be trained so they can place an unknown sample
    into the correct class. *Training* involves learning the parameters of the model
    using a training set, a collection of feature vectors (*x*) and corresponding
    class labels (*y*). This is what the iris dataset gives us. The training set has
    50 examples of each class, that is, each species of flower. We’ll use 100 of these
    150 examples to train the classifier and the remaining 50 to test the model to
    see how well it learned to distinguish between iris species.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We hope that when given a set of features for a new flower the trained model
    will be able to place the new flower into the correct class (in other words, correctly
    identify the species). The nearest neighbor classifier treats the feature vector
    as a point in a multidimensional space, in this case a 4D space for the iris dataset,
    as there are four features per sample. The idea is to find the training set sample
    whose feature vector is the closest to the feature vector of the unknown input
    and then assign the unknown input to the training sample class. In this case,
    closest means the training sample with the smallest *distance* to the unknown
    input.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: There are many concept words in the paragraphs above, so let’s make sure we
    know what they mean. Once we do, the operation of the classifier will become apparent
    or even obvious. [Table 5-1](ch05.xhtml#ch05tab1) presents a brief machine learning
    glossary.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** A Brief Machine Learning Glossary'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '| **Term** | **Meaning** |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| Feature | A measurement or characteristic of the data |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| Feature vector | A collection of features describing an instance |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| Class | The label, or group, the instance belongs to |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| Model | A means for mapping feature vectors to class labels |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| Training | Using known feature vectors to teach the model |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| Distance | The straight-line distance between two points |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: 'All machine learning models implement two phases: training and inference. During
    training, the training set, that is, the collection of feature vectors and their
    known class labels, is used to adjust the model’s parameters to the task at hand.
    Once trained, the model can be used for inference to assign class labels to new,
    unknown feature vectors. For the nearest neighbor classifier, training is so trivial
    as to be nonexistent: we use the training set as it is, as there are no parameters
    to learn.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: To classify feature vectors, we scan through the training set to calculate the
    distance between the unknown feature vector and each of the training samples to
    find the closest training sample. We use that training sample’s class label as
    the class label for the unknown feature vector.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a new set of measurements for an iris flower but don’t
    know its species, the nearest neighbor classifier searches the list of training
    set feature vectors for the sample closest to the unknown feature vector. It then
    declares the unknown input to be of the same class.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The word *distance* has been mentioned a few times now. Let’s put a formula
    to the word, so we have a way to measure the distance between two feature vectors.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of distances, but the one we’ll use here is the *Euclidean
    distance*, which is a generalization of the Pythagorean theorem. For example,
    in 4D, the distance between two points, (*x*[0], *y*[0], *a*[0], *b*[0]) and (*x*[1],
    *y*[1], *a*[1], *b*[1]), is
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-01.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: If we have 3D feature vectors, the distance between two points, (*x*[0], *y*[0],
    *z*[0]) and (*x*[1], *y*[1], *z*[1]), is
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-02.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: For *n*-dimensional feature vectors, the distance is
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-03.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: for two feature vectors, *x* and *y*. In the equation above, *i* is an index
    into the components of the vector. When we implement the Euclidean distance in
    code, *i* will be an index into an array.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The training set and the Euclidean distance are all we need to implement the
    nearest neighbor classifier, but how will we know if it’s working? For that, we
    need test data. This is another dataset like the training set, but one that wasn’t
    used to train the model.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We know the feature vectors and the correct class label for the test set. We’ll
    run each test set feature vector through the model, comparing the classifier’s
    predicted label with the correct class label. There are many ways to characterize
    the performance of a machine learning model, but in this case, all we need to
    measure is the model’s accuracy.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0153-04.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: A classifier that randomly guesses class labels will only be correct, on average,
    one time in *c*, where *c* is the number of classes in the dataset. There are
    three classes for the iris flowers, so we’d expect, if guessing, to be correct
    one time out of three, or about 33 percent of the time, meaning the accuracy is
    0.3333\. A perfect classifier makes no mistakes and has an accuracy of 1.0 or
    100 percent.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We now have enough background to get started. We have a model and we know how
    to train it and test it. Let’s write some code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing the Classifier***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement the classifier. Here’s our plan of attack:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Load the training and test datasets into SNOBOL arrays.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each test sample, assign the class label of the closest training set sample.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the assigned labels to the known test labels.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Report the classifier’s accuracy.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code that follows is in the file *classify.sno*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading the Data**'
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This book’s GitHub site contains several datasets. Let’s walk through an example
    using the iris dataset. We’ll classify the others later.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The iris dataset is in four text files in the *datasets* directory:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first two contain training data and the associated class labels. The second
    two hold test data.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: For example, the training datafile begins with
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: with the associated class labels
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: meaning the first feature vector is a class 1 instance, whereas the second feature
    vector is an instance of class 0, and so on. The test dataset files are structured
    similarly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: We need SNOBOL code to load these text files. We’ll develop generic code, a
    SNOBOL function to load any datafile arranged such that each row represents a
    sample and each column represents a feature. Most machine learning datasets are
    structured this way.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The iris training data results in a 2D array with 100 rows and four columns
    because there are four features per sample and 100 samples in the training set.
    The training labels will become a 2D array as well, with 100 rows and one column.
    This simplifies the implementation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-24](ch05.xhtml#ch05list24) shows a function to load datafiles. It’s
    the most complex piece of code we need to develop, so it’s best to start with
    the worst, knowing that things will get easier later.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 5-24: Loading a datafile*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts the name of the text file to load ➊. Notice the list of
    local variables. This prevents hard-to-detect errors whereby the function might
    alter a global variable. The function itself consists of two loops. The first
    loop, from label `loadfile` through label `load_l00`, reads a line of text from
    the input file and parses it to count the number of features per sample. When
    the program reaches label `load_l00`, the number of rows in the file is in `r`
    and the number of columns is in `c`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: To extract a number from the current line, we do two things. First, we add a
    blank space to the input line (see label `load_l02`). Next, we perform a pattern
    match and update (see label `load_l03`). The pattern ➋ uses `break` to match all
    text up to the first blank, storing it in `v`, and then matches any number of
    blanks with `span`. The net effect of `pat` is to grab the text representing a
    feature value and end with the cursor at the beginning of the next feature. Label
    `load_l03` assigns nothing to the matched text, thereby removing it from `text`.
    This process repeats, with `c` incremented until the line is empty and the match
    fails to cause a jump to label `load_l01` to increment `r` and advance to the
    next line of the input file. When the input file is exhausted, control moves to
    label `load_l00` to close the file.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the first loop is to learn the file’s dimensionality; it’s in
    `r` and `c`. The return value of the function is defined as an array of the appropriate
    size ➌.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The input file is opened a second time, and the same read process happens again.
    This time, each matched feature value in `v` is placed into the array as a floating-point
    number ➍. When the input file is again empty, the function returns.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating the Distance**'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Classifying an unknown sample requires computing the distance between pairs
    of feature vectors. The code to do this is in `dist`. See [Listing 5-25](ch05.xhtml#ch05list25).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 5-25: Calculating the Euclidean distance*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The arguments to `dist` are the two datasets, `x` and `y`, which are 2D, and
    the rows to work with, `i` and `j`. The distance is the sum of the differences
    of each feature for the given rows. These are the columns of the arrays that we
    index with `k`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The label `dist_l00` does all the work. It adds the square of the difference
    between the *k*th columns of `x` and `y` for the given rows to the existing sum.
    The loop fails when `k` exceeds the array’s bounds. The return value is the square
    root of this sum (the label `dist_l01`).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Some readers might be a bit confused by [Listing 5-25](ch05.xhtml#ch05list25),
    as `sum` is updated without being initialized. There is no error. SNOBOL treats
    undefined variables as null and adding a number to null returns the number, so
    there is no need to initialize `sum` explicitly.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Nearest Training Sample**'
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need to find the training sample that is closest to a given test sample.
    For that, we use the function `nearest`. See [Listing 5-26](ch05.xhtml#ch05list26).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 5-26: Finding the nearest training sample*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-26](ch05.xhtml#ch05list26) actually defines two functions, `nearest`
    and `samples` (which is used by `nearest`). Let’s start with `samples`. It returns
    the number of rows in a 2D array. Given how we organize the data, that’s a sample,
    a feature vector.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The `samples` function defines a pattern (`pat`), matching text up to the first
    comma and storing it in the function name (`samples`). It then applies this pattern
    to whatever is returned by the SNOBOL `prototype` function. This function returns
    a string specifying the dimensionality of an array. Recall that arrays are declared
    using a string to specify the number and size of the dimensions. Our arrays are
    2D, so `prototype` returns a string like `'100,4'`. The pattern extracts the first
    number. We won’t use it, but *classify.sno* also defines `features`, which is
    a function to return the number of features, the second number returned by `prototype`.
    Do take a look.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm for `nearest` scans through the training data, calculating the
    distance between the current training sample and the specified test sample. If
    that distance is smaller than the smallest found so far, it keeps track of the
    distance and the training sample’s class label. When the algorithm completes its
    pass through the training data, it returns the class label of the smallest distance;
    `nearest` classifies a given test set sample.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The long list of parameters to `nearest` passes the training set, both data
    (`xtrn`) and labels (`ytrn`), along with the test set data and labels, and `idx`,
    which is the current test set sample to classify.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: The loop over the training set tracks `md`, which is the smallest distance found
    so far, storing the associated class label in `nearest`, the function value. The
    loop ends when `le(i,s)` fails where `i` is the row index and `s` is the number
    of samples in the training set. If `lt(d,md)` succeeds, the algorithm updates
    `md` and `nearest`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '**The Main Code**'
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The sections above describe the functions implementing each phase of the classification
    task. The main code, at the bottom of *classify.sno*, pulls these pieces together
    (see [Listing 5-27](ch05.xhtml#ch05list27)).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 5-27: Putting the classifier together*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-27](ch05.xhtml#ch05list27) first loads the training and test data.
    The feature vectors are in `x_train` and `x_test`, respectively. The associated
    class labels are in `y_train` and `y_test`. The filenames are passed on the command
    line, after *classify.sno*, with the training data and labels first, followed
    by test data and labels.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The following code is a loop that runs through each test sample. The call to
    `nearest` returns the assigned class label for test sample `i`. If the classification
    is correct, it increments the number correct counter, `nc` ➊. Note that the SNOBOL
    construct of using the `eq` predicate in the same update statement. If the classification
    is wrong, `eq` fails, and the rest of the statement is skipped. There is no failure
    label, so execution continues with the next line. When all test samples have been
    classified, the overall accuracy is displayed before exiting.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is complete. Now the million-dollar question: does it work?
    Let’s see.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Classifier***'
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s run *classify.sno* against the examples in the *datasets* directory. These
    datasets can be found on the UCI Machine Learning Repository website (*[https://archive.ics.uci.edu/ml/index.php](https://archive.ics.uci.edu/ml/index.php)*).
    I downloaded the datasets and processed them to be in the form expected by *classify.sno*.
    The full dataset was randomly partitioned into training and test datasets using
    an 80/20 split. Feature vectors are in the “data” files, with the class labels,
    matching line for line, in the “labels” files.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: The available datasets include those shown in [Table 5-2](ch05.xhtml#ch05tab2).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Available Datasets'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dataset** | **Features** | **Classes** | **Description** |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| banknote | 4 | 2 | Real or counterfeit notes |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| cancer | 10 | 2 | Breast cancer histology slide features |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| ecoli | 7 | 8 | Characterizing *E. coli* bacteria |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| haberman | 3 | 2 | Five year breast cancer survival |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| iris | 4 | 3 | Types of irises |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| seeds | 7 | 3 | Types of seeds |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| wine | 13 | 3 | Wine origin |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: 'Let start with the irises. To run the classifier, use the following command
    line:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The output begins with
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: and ends with
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There are 50 test samples and the assigned and actual class labels are displayed
    for each sample. If the classifier made a mistake, the output is followed by `**`
    to mark it.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: The overall accuracy was 96 percent, with only two mistakes. For such a simple
    classifier, this is not too shabby. Note that both errors were confusing between
    class 1 and class 2\. For the iris dataset, class 0 is easily distinguished from
    the other two, but class 1 and class 2 are relatively similar, so they are more
    likely to be confused.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Run the other example datasets in the same way. [Table 5-3](ch05.xhtml#ch05tab3)
    shows the statistics, including the accuracy, number correctly classified, number
    tested, and the size of the training set.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-3:** Nearest Neighbor Classifier Accuracies by Dataset'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dataset** | **Accuracy (%)** | **Correct** | **Test** | **Train** |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| banknote | 100.0 | 275 | 275 | 1097 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| cancer | 94.2 | 129 | 137 | 546 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| ecoli | 86.8 | 59 | 68 | 268 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| haberman | 67.2 | 41 | 61 | 245 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| iris | 96.0 | 48 | 50 | 100 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| seeds | 92.9 | 39 | 42 | 168 |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| wine | 83.3 | 30 | 36 | 142 |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: The results range from perfection (banknotes) to a low of 67 percent (haberman).
    However, all things considered, this simple classifier performed quite well on
    these datasets.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another name for the nearest neighbor classifier: 1-nearest neighbor,
    where the *1* means only the nearest training sample is considered. This classifier
    can be generalized to consider the *k*-nearest neighbors where *k* > 1 and is
    odd. For a *k*-nearest neighbor classifier, the *k*-nearest neighbors are located.
    The assigned class is the result of voting among the *k*-nearest neighbors. In
    the event of a tie, select one of the neighbors at random. Although nearest neighbor
    classifiers are seldom used, *k*-nearest neighbor classifiers are still an active
    research area in machine learning. I leave it as an exercise for the reader to
    convert *classify.sno* into a *k*-nearest neighbor classifier.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '*The world of machine learning offers much more than the tiny bit we’ve explored
    here. Witness the rapidly expanding world of deep learning, which has already
    greatly affected our daily lives and will continue to do so for years to come.
    If your interest has been piqued, please take a look at my deep learning books*
    Practical Deep Learning: A Python-Based Introduction (2021) *and* Math for Deep
    Learning: What You Need to Know to Understand Neural Networks *(2021). Both are
    available from No Starch Press.*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What should we make of SNOBOL? I’ll admit, I like the language. The flexibility
    of its arrays and the table data structure are surprisingly “modern.” I also like
    its pattern-matching abilities, dynamic data typing, and automatic memory management.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: But SNOBOL’s complete lack of structured programming abilities hurts. The only
    way to directly control program flow is with a goto. There are no structured control
    statements like `for` or `while`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Forth gets a bad rap for being a write-only programming language, but Forth
    uses structured programming, which is not even an option in SNOBOL. Using the
    success or failure of a statement as an essential element of program flow control
    is novel and intellectually engaging, but it ultimately makes working with the
    language difficult. However, I suspect much of that difficulty would fade with
    practice. The fact that SNOBOL labels are global is especially painful. Even some
    assemblers for old 8-bit microprocessors support local labels, something that
    would greatly benefit SNOBOL.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Historically, SNOBOL had a reputation for being slow. Thus, a simple timing
    test comparing SNOBOL and Python seems in order.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-28](ch05.xhtml#ch05list28) shows two equivalent programs to initialize
    a 1,000,000-element array/list 20 times, first in Python and then in SNOBOL.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Listing 5-28: Comparing SNOBOL and Python*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: The median runtime on my machine over 10 runs each is 2.363 seconds for Python
    and 3.548 seconds for SNOBOL. So yes, SNOBOL is slower, but not dramatically so.
    Note that to run the SNOBOL code, use -d 1m on the command line to reserve enough
    memory for the array.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: In what ways does SNOBOL help us expand our conception of what it means to code?
    Several come to mind. SNOBOL uses global labels and is unstructured. This requires
    programmers to think clearly about the *entire* scope of the project, or at least
    to implement a disciplined approach to coding, one that is not enforced by the
    language itself as in other, newer programming languages. Without a global conception
    of the program, label confusion or spaghetti code is inevitable. Thus, clarity
    of thought is essential.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: SNOBOL’s robust pattern matching and string update abilities enable a novel
    approach to string manipulation. As a result, some of the burden incumbent on
    the programmer regarding string manipulation in languages like C++, Python, or
    Java is alleviated. This means thinking in terms of strings and their evolution
    becomes a new paradigm for implementing algorithms.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, SNOBOL requires thinking in terms of statement success *and* statement
    failure. Typically, coding is for success, as we don’t want failures to happen.
    Error control in SNOBOL is fine grained, which is both helpful and perhaps a bit
    dangerous.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: All in all, SNOBOL is a surprisingly “modern” programming language. In many
    ways, it was well ahead of its time. SNOBOL itself evolved into Icon, also by
    Griswold, which uses structured programming constructs. Icon never caught on,
    but readers who are so inclined can learn more at *[https://www2.cs.arizona.edu/icon/](https://www2.cs.arizona.edu/icon/)*.
    Regardless, SNOBOL is worth a bit of continued effort on our part. Indeed, we’ll
    see SNOBOL again in [Chapter 10](ch10.xhtml#ch10) when we use it to implement
    Brainfuck.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced us to SNOBOL, a quirky pattern matching programming
    language from the 1960s. We worked through the language from its overall structure
    to specifics of its key features, with numerous examples. We learned about its
    unique approach to flow control and saw a tiny portion of its powerful text pattern
    matching abilities.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a simple machine learning classifier in SNOBOL as an exercise
    and saw that it performed well against some small-scale machine learning datasets.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter by discussing the language, what we liked about it, and
    what we were less enthused about. Our ultimate conclusion was that SNOBOL well
    deserves of a place at our table as a novel language that can help us learn to
    think differently about coding.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Let’s leave SNOBOL, with its successes and failures, and jump forward to the
    latter Mesozoic so we can experience the awe and mystery of CLIPS, a language
    designed for expert system development.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
