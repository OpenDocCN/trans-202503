- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: COMPUTER ANATOMY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算机解剖学**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: You learned about the properties of bits and ways of using them to represent
    things in [Chapter 1](ch01.xhtml#ch01). In [Chapters 2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03),
    you learned why we use bits and how they’re implemented in hardware. You also
    learned about a number of basic building blocks and how they could be combined
    into more complex configurations. In this chapter, you’ll learn how those building
    blocks can be combined into a circuit that can manipulate bits. That circuit is
    called a *computer*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 1 章](ch01.xhtml#ch01)中了解了比特的属性以及如何使用它们来表示事物。在[第 2 章](ch02.xhtml#ch02)和[第
    3 章](ch03.xhtml#ch03)中，你了解了为什么使用比特以及它们如何在硬件中实现。你还学习了许多基本的构建块，以及如何将它们组合成更复杂的配置。在本章中，你将学习如何将这些构建块组合成一个能够操作比特的电路。这个电路就是*计算机*。
- en: There are many ways of constructing a computer. The one we’ll build in this
    chapter was chosen for ease of explanation, not because it’s the best possible
    design. And although simple computers work, a lot of additional complexity is
    required to make them work *well*. This chapter sticks to the simple computer;
    the next two chapters cover some of the extra complications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 构建计算机有很多种方式。我们在本章中将要构建的计算机是为了便于讲解而选择的，并不是因为它是最好的设计。尽管简单的计算机可以工作，但要使它们工作得*好*，需要加入许多额外的复杂性。本章专注于简单的计算机；接下来的两章将介绍一些额外的复杂性。
- en: There are three big pieces in a modern computer. These are the *memory*, the
    *input and output (I/O)*, and the *central processing unit (CPU)*. This section
    covers how these pieces relate to each other. [Chapter 3](ch03.xhtml#ch03) introduced
    memory, and [Chapter 5](ch05.xhtml#ch05) covers computers and memory in more detail.
    I/O is the subject of [Chapter 6](ch06.xhtml#ch06). The CPU lives in what I’m
    calling “City Center” in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机有三个主要组成部分。这些是*内存*、*输入输出（I/O）*和*中央处理单元（CPU）*。本节将介绍这些部分如何相互关联。[第 3 章](ch03.xhtml#ch03)介绍了内存，[第
    5 章](ch05.xhtml#ch05)将更详细地讨论计算机和内存。I/O 是[第 6 章](ch06.xhtml#ch06)的主题。CPU 则位于本章所称的“城市中心”。
- en: '**Memory**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内存**'
- en: Computers need someplace to keep the bits that they’re manipulating. That place
    is memory, as you learned in [Chapter 3](ch03.xhtml#ch03). Now it’s time to find
    out how computers use it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机需要一个地方来存储它们正在操作的比特。这地方就是内存，正如你在[第 3 章](ch03.xhtml#ch03)中所学的。现在是时候了解计算机如何使用内存了。
- en: Memory is like a long street full of houses. Each house is exactly the same
    size and has room for a certain number of bits. Building codes have pretty much
    settled on 1 byte per house. And just like on a real street, each house has an
    *address*, which is just a number. If you have 64 MiB of memory in your computer,
    that’s 64 × 1,024 × 1,024 = 67,108,864 bytes (or 536,870,912 bits). The bytes
    have addresses from 0 to 67,108,863\. This numbering makes sense, unlike the numbering
    on many real streets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 内存就像是一条长长的街道，街道上有许多房子。每栋房子的大小完全相同，都有足够的空间来存放一定数量的比特。建筑规范大多已经确定每栋房子存储 1 字节。就像现实中的街道一样，每栋房子都有一个*地址*，也就是一个数字。如果你的计算机有
    64 MiB 的内存，那么就是 64 × 1,024 × 1,024 = 67,108,864 字节（或 536,870,912 比特）。这些字节的地址从
    0 到 67,108,863。这个编号方式是合理的，不像许多现实街道的编号那样混乱。
- en: It’s pretty common to refer to a memory *location*, which is just memory at
    a particular address, such as 3 Memory Lane (see [Figure 4-1](ch04.xhtml#ch04fig01)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会提到*位置*，即某个特定地址的内存，比如“3 Memory Lane”（参见[图 4-1](ch04.xhtml#ch04fig01)）。
- en: '![Image](../images/04fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig01.jpg)'
- en: '*Figure 4-1: Memory Lane*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1: Memory Lane*'
- en: Just because the basic unit of memory is a byte doesn’t mean we always look
    at it that way. For example, 32-bit computers usually organize their memory in
    4-byte chunks, while 64-bit computers usually organize their memory in 8-byte
    chunks. Why does that matter? It’s like having a four- or eight-lane highway instead
    of a one-lane road. More lanes can handle more traffic because more bits can get
    on the data bus. When we address memory, we need to know what we’re addressing.
    Addressing long words is different from addressing bytes because there are 4 bytes
    to a long word on a 32-bit computer, and 8 bytes to a long word on a 64-bit computer.
    In [Figure 4-2](ch04.xhtml#ch04fig02), for example, long-word address 1 contains
    byte addresses 4, 5, 6, and 7.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为内存的基本单位是字节，并不意味着我们总是以这种方式来看待它。例如，32位计算机通常以4字节为一个单元来组织内存，而64位计算机通常以8字节为一个单元来组织内存。为什么这很重要？这就像有四车道或八车道的高速公路，而不是单车道的道路。更多的车道能处理更多的交通，因为更多的比特可以进入数据总线。当我们寻址内存时，我们需要知道自己在寻址什么。寻址长字与寻址字节不同，因为在32位计算机中，1个长字包含4个字节，而在64位计算机中，1个长字包含8个字节。例如，在[图4-2](ch04.xhtml#ch04fig02)中，长字地址1包含字节地址4、5、6和7。
- en: Another way to look at it is that the street in a 32-bit computer contains fourplexes,
    not single houses, and each fourplex contains two duplexes. That means we can
    address an individual unit, a duplex, or a whole building.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看法是，在32位计算机中，街道上包含的是四连体住宅，而不是单独的房子，每个四连体住宅包含两个双拼住宅。这意味着我们可以单独寻址一个单元、一个双拼住宅或整个建筑。
- en: '![Image](../images/04fig02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig02.jpg)'
- en: '*Figure 4-2: Memory highway*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：内存高速公路*'
- en: 'You may have noticed that each building straddles the highway such that each
    byte has its own assigned lane, and a long word takes up the whole road. Bits
    commute to and from City Center on a bus that has four seats, one for each byte.
    The doors are set up so that there’s one seat for each lane. On most modern computers,
    the bus stops only at one building on each trip from City Center. This means we
    can’t do things like form a long word from bytes 5, 6, 7, and 8, because that
    would mean that the bus would have to make two trips: one to building 0 and one
    to building 1\. Older computers contained a complicated loading dock that allowed
    this, but planners noticed that it wasn’t all that useful and so they cut it out
    of the budget on newer models. Trying to get into two buildings at the same time,
    as shown in [Figure 4-3](ch04.xhtml#ch04fig03), is called a *nonaligned access*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每栋建筑都跨越了高速公路，每个字节都有自己分配的车道，而一个长字占据了整条路。比特通过一辆有四个座位的巴士往返于市中心，每个字节一个座位。门口的设置是每条车道都有一个座位。在大多数现代计算机中，巴士在从市中心出发时每次只停靠一个建筑物。这意味着我们不能像从字节5、6、7和8形成一个长字那样操作，因为那样巴士必须进行两次旅行：一次去建筑0，一次去建筑1。较早的计算机有一个复杂的装载码头，允许这样做，但规划者注意到这并不那么有用，因此在新型号中将其从预算中削减掉了。试图同时进入两个建筑物，如[图4-3](ch04.xhtml#ch04fig03)所示，被称为*非对齐访问*。
- en: '![Image](../images/04fig03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig03.jpg)'
- en: '*Figure 4-3: Aligned and nonaligned accesses*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：对齐与非对齐访问*'
- en: There are lots of different kinds of memory, as we saw in the previous chapter.
    Each has a different *price/performance ratio*. For example, SRAM is fast and
    expensive, like the highways near where the politicians live. Disk is cheap and
    slow—the dirt road of memory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在上一章中有很多不同种类的内存。每种内存都有不同的*性价比*。例如，SRAM速度快且昂贵，就像政治家居住附近的高速公路。磁盘便宜且速度慢——内存中的土路。
- en: Who gets to sit in which seat when commuting on the bus? Does byte 0 or byte
    3 get to sit in the leftmost seat when a long word heads into town? It depends
    on the processor you’re using, because designers have made them both ways. Both
    work, so it’s pretty much a theological debate. In fact, the term *endian*—based
    on the royal edicts in Lilliput and Blefuscu in Jonathan Swift’s *Gulliver’s Travels*
    regarding which was the proper end on which to crack open a soft-boiled egg—is
    used to describe the difference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 谁能坐在哪个座位上乘坐巴士通勤？当一个长字进入城市时，字节0还是字节3能坐在最左边的座位上？这取决于你使用的处理器，因为设计师有两种方式来设计它们。两者都能工作，所以这基本上是一个神学辩论。事实上，*字节序*一词——源于乔纳森·斯威夫特的《格列佛游记》中关于如何正确打开软煮蛋的皇家法令——用来描述这一差异。
- en: Byte 0 goes into the rightmost seat in little-endian machines like Intel processors.
    Byte 0 goes into the leftmost seat in big-endian machines like Motorola processors.
    [Figure 4-4](ch04.xhtml#ch04fig04) compares the two arrangements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在小端机器中，如英特尔处理器，字节 0 放入最右侧的座位。在大端机器中，如摩托罗拉处理器，字节 0 放入最左侧的座位。[图 4-4](ch04.xhtml#ch04fig04)
    比较了这两种存储方式。
- en: '![Image](../images/04fig04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig04.jpg)'
- en: '*Figure 4-4: Big- and little-endian arrangements*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：大端和小端存储方式*'
- en: Endianness is something to keep in mind when you’re transferring information
    from one device to another, because you don’t want to inadvertently shuffle the
    data. A notable instance of this occurred when the UNIX operating system was ported
    from the PDP-11 to an IBM Series/1 computer. A program that was supposed to print
    out “Unix” printed out “nUxi” instead, as the bytes in the 16-bit words got swapped.
    This was sufficiently humorous that the term *nuxi syndrome* was coined to refer
    to byte-ordering problems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在从一个设备向另一个设备传输信息时，字节序是需要注意的，因为你不希望无意中打乱数据。一个著名的例子发生在 UNIX 操作系统从 PDP-11 移植到 IBM
    Series/1 计算机时。一个原本应该打印“Unix”的程序，却打印出了“nUxi”，因为 16 位字中的字节顺序被交换了。这个问题非常幽默，以至于“nuxi
    综合症”这个术语被创造出来，用来指代字节顺序问题。
- en: '**Input and Output**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**输入和输出**'
- en: A computer that couldn’t communicate with the outside world wouldn’t be very
    useful. We need some way to get things in and out of the computer. This is called
    *I/O* for *input/output*. Things that connect to the I/O are called *I/O devices*.
    Since they’re on the periphery of the computer, they’re also often called *peripheral
    devices* or just *peripherals*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一台无法与外界通信的计算机是没什么用的。我们需要某种方式将信息输入和输出到计算机中。这被称为 *I/O*（输入/输出）。与 I/O 连接的设备被称为 *I/O
    设备*。由于它们位于计算机的外围，它们也常被称为 *外围设备* 或简称 *外设*。
- en: Computers used to have a separate I/O avenue, as shown in [Figure 4-5](ch04.xhtml#ch04fig05),
    that was similar to Memory Lane. This made sense when computers were physically
    huge, because they weren’t squeezed into small packages with a limited number
    of electrical connections. Also, Memory Lane wasn’t very long, so it didn’t make
    sense to limit the number of addresses just to support I/O.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机过去有一个独立的 I/O 通道，如[图 4-5](ch04.xhtml#ch04fig05)所示，类似于内存通道。当计算机体积庞大时，这种设计是合理的，因为那时计算机并不像现在这样被压缩进有限连接数的小型包装中。此外，内存通道的长度不长，因此没必要仅为了支持
    I/O 限制地址的数量。
- en: '![Image](../images/04fig05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig05.jpg)'
- en: '*Figure 4-5: Separate memory and I/O buses*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：独立的内存和I/O总线*'
- en: Memory Lane is much longer now that 32- and 64-bit computers are common. It’s
    so long that there aren’t houses at every address; many empty lots are available.
    In other words, there are addresses that have no memory associated with them.
    As a result, it now makes more sense to set aside a portion of Memory Lane for
    I/O devices. It’s like the industrial district on the edge of town. Also, as more
    circuitry is crammed into a package that has a limited number of connections,
    it just makes sense for I/O to be on the same bus as memory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 32 位和 64 位计算机已经普及，内存通道（Memory Lane）变得更长了。它如此之长，以至于每个地址并没有对应一座“房子”；许多空地可供使用。换句话说，有些地址没有与之关联的内存。因此，现在更合理的做法是将
    Memory Lane 的一部分留给 I/O 设备。这就像城镇边缘的工业区。此外，随着更多电路被压缩到一个有限连接数的封装中，I/O 和内存放在同一个总线中显得更为合理。
- en: Many computers are designed with standard input/output *slots* so that I/O devices
    can be connected in a uniform manner. This is done sort of like how property was
    distributed in the Old West; the unincorporated territory is partitioned into
    a set of land grants, as shown in [Figure 4-6](ch04.xhtml#ch04fig06). Each slot
    holder gets the use of all addresses up to its borders. Often there is a specific
    address in each slot that contains some sort of identifier so that City Center
    can conduct a census to determine who’s living in each slot.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机设计了标准的输入/输出 *插槽*，以便 I/O 设备可以以统一的方式连接。这就像旧西部的财产分配一样；未并入的领土被划分为一系列土地赠予，如[图
    4-6](ch04.xhtml#ch04fig06)所示。每个插槽的拥有者可以使用直到其边界的所有地址。通常，每个插槽中都有一个特定的地址，里面包含某种标识符，这样
    City Center 就能进行人口普查，确定每个插槽中的“住户”。
- en: '![Image](../images/04fig06.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig06.jpg)'
- en: '*Figure 4-6: Shared memory and I/O bus*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：共享内存和 I/O 总线*'
- en: We often use a shipping metaphor and say that things are hooked up to *I/O ports*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常用运输的比喻，说某些东西被连接到 *I/O 端口*。
- en: '**The Central Processing Unit**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**中央处理单元**'
- en: The *central processing unit (CPU)* is the part of the computer that does the
    actual computing. It lives at City Center in our analogy. Everything else is the
    supporting cast. The CPU is made up of many distinct pieces that we’ll learn about
    in this section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*中央处理单元（CPU）* 是计算机中执行实际计算的部分。它就像我们类比中的城市中心。其他部分则是支持角色。CPU 由多个独立的部分组成，我们将在本节中学习这些部分。'
- en: '***Arithmetic and Logic Unit***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***算术与逻辑单元***'
- en: The *arithmetic logic unit (ALU)* is one of the main pieces of a CPU. It’s the
    part that knows how to do arithmetic, Boolean algebra, and other operations. [Figure
    4-7](ch04.xhtml#ch04fig07) shows a simple diagram of an ALU.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*算术逻辑单元（ALU）*是 CPU 的主要组成部分之一。它负责进行算术运算、布尔代数和其他操作。[图4-7](ch04.xhtml#ch04fig07)展示了
    ALU 的简图。'
- en: '![Image](../images/04fig07.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig07.jpg)'
- en: '*Figure 4-7: A sample ALU*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：样例 ALU*'
- en: The *operands* are just bits that may represent numbers. The operation code,
    or *opcode*, is a number that tells the ALU what *operator* to apply to the operands.
    The *result*, of course, is what we get when we apply the operator to the operands.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作数*只是表示数字的位。操作码，或称*opcode*，是告诉 ALU 应该对操作数应用哪个*运算符*的数字。*结果*，当然，就是我们在应用运算符于操作数后得到的结果。'
- en: The *condition codes* contain extra information about the result. They are usually
    stored in a *condition code register*. A register, which we saw back in [Chapter
    3](ch03.xhtml#ch03), is just a special piece of memory that’s on a different street
    from the rest of the memory—the street with the expensive, custom homes. A typical
    condition code register is shown in [Figure 4-8](ch04.xhtml#ch04fig08). The numbers
    on top of the boxes are the bit numbers, which is a convenient way to refer to
    them. Note that some of the bits are not used; this is not unusual.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件码*包含关于结果的额外信息。它们通常存储在*条件码寄存器*中。我们在[第3章](ch03.xhtml#ch03)中看到的寄存器，就是一种特殊的内存，它位于内存的不同“街道”上——那条有着昂贵定制住宅的街道。一个典型的条件码寄存器如[图4-8](ch04.xhtml#ch04fig08)所示。盒子上方的数字是位号，这是便于引用它们的一种方式。请注意，有些位没有使用；这并不罕见。'
- en: '![Image](../images/04fig08.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig08.jpg)'
- en: '*Figure 4-8: A condition code register*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-8：条件码寄存器*'
- en: The *N* is set to 1 if the result of the last operation is a negative number.
    The *Z* bit is set to 1 if the result of the last operation is 0\. The *O* bit
    is set to 1 if the result of the last operation created an overflow or underflow.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* 位如果上次操作的结果是负数则置为 1。*Z* 位如果上次操作的结果是 0，则置为 1。*O* 位如果上次操作的结果发生溢出或下溢，则置为 1。'
- en: '[Table 4-1](ch04.xhtml#ch04tab01) shows what an ALU might do.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4-1](ch04.xhtml#ch04tab01) 展示了 ALU 可能执行的操作。'
- en: '**Table 4-1:** Sample ALU Opcodes'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-1：** 样例 ALU 操作码'
- en: '| **Opcode** | **Mnemonic** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **操作码** | **助记符** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0000` | clr | Ignore the operands; make each bit of the result 0 (clear).
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `0000` | clr | 忽略操作数；将结果的每一位设为 0（清零）。 |'
- en: '| `0001` | set | Ignore the operands; make each bit of the result 1. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `0001` | set | 忽略操作数；将结果的每一位设为 1。 |'
- en: '| `0010` | not | Ignore B; turn 0s from A to 1s and vice versa. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `0010` | not | 忽略 B；将 A 的 0 转为 1，1 转为 0。 |'
- en: '| `0011` | neg | Ignore B; the result is the two’s complement of A, –A. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `0011` | neg | 忽略 B；结果是 A 的二补数，即 -A。 |'
- en: '| `0100` | shl | Shift A left by the low 4 bits of B (see next section). |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `0100` | shl | 将 A 左移 B 的低 4 位（见下一节）。 |'
- en: '| `0101` | shr | Shift A right by the low 4 bits of B (see next section). |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `0101` | shr | 将 A 右移 B 的低 4 位（见下一节）。 |'
- en: '| `0110` |  | Unused. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `0110` |  | 未使用。 |'
- en: '| `0111` |  | Unused. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `0111` |  | 未使用。 |'
- en: '| `1000` | load | Pass operand B to the result. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `1000` | load | 将操作数 B 传递给结果。 |'
- en: '| `1001` | and | The result is A AND B for each bit in the operands. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `1001` | 和 | 对每一位操作数，结果是 A 与 B 的按位与。 |'
- en: '| `1010` | or | The result is A OR B for each bit in the operands. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `1010` | or | 结果是 A 或 B 的按位或。 |'
- en: '| `1011` | xor | The result is A XOR B for each bit in the operands. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `1011` | xor | 结果是 A 与 B 的按位异或。 |'
- en: '| `1100` | add | The result is A + B. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `1100` | add | 结果是 A + B。 |'
- en: '| `1101` | sub | The result is A – B. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `1101` | sub | 结果是 A - B。 |'
- en: '| `1110` | cmp | Set condition codes based on B – A (compare). |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `1110` | cmp | 根据 B - A （比较）设置条件码。 |'
- en: '| `1111` |  | Unused. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `1111` |  | 未使用。 |'
- en: The ALU may appear mysterious, but it’s really just some logic gates feeding
    a selector, which you’ve seen before. [Figure 4-9](ch04.xhtml#ch04fig09) shows
    the general design of an ALU, omitting some of the more complicated functions
    for the sake of simplicity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ALU可能看起来神秘，但它其实就是一些逻辑门连接到一个选择器，这些你之前见过。[图4-9](ch04.xhtml#ch04fig09)展示了ALU的总体设计，为了简化，省略了一些更复杂的功能。
- en: '![Image](../images/04fig09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig09.jpg)'
- en: '*Figure 4-9: ALU partial internals*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-9：ALU部分内部结构*'
- en: '***Shiftiness***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移位性***'
- en: You may have noticed the shift operations in [Table 4-1](ch04.xhtml#ch04tab01).
    A left shift moves every bit left one position, throwing away the leftmost bit
    and moving a 0 into the vacated rightmost position. If we left-shift 01101001
    (105[10]) by 1, we’ll get 11010010 (210[10]). This is pretty handy because left-shifting
    a number one position multiplies it by 2.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到[表4-1](ch04.xhtml#ch04tab01)中的移位操作。左移将每一位向左移动一位，丢弃最左边的位，并将0移动到空出来的最右边位置。如果我们将01101001（105[10]）左移1位，我们将得到11010010（210[10]）。这是非常方便的，因为将一个数左移一位实际上是乘以2。
- en: A right shift moves every bit right one position, throwing away the rightmost
    bit and moving a 0 into the vacated leftmost position. If we right-shift 01101001
    (105[10]) by 1, we’ll get 00110100 (52[10]). This divides a number by 2, throwing
    away the remainder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 右移将每一位向右移动一位，丢弃最右边的位，并将0移动到空出来的最左边位置。如果我们将01101001（105[10]）右移1位，我们将得到00110100（52[10]）。这相当于将一个数除以2，丢弃余数。
- en: The value of the MSB (most significant bit) lost when left-shifting or the LSB
    (least significant bit) when right-shifting is often needed, so it’s saved in
    the condition code register. Let’s make believe that our CPU saves it in the *O*
    bit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行左移时，丢失的最高有效位（MSB）或右移时丢失的最低有效位（LSB）通常是需要保存的，因此它会被保存在条件码寄存器中。我们假装我们的CPU将它保存在*O*位中。
- en: You might have noticed that everything in the ALU looks like it can be implemented
    in combinatorial logic except these shift instructions. You can build *shift registers*
    out of flip-flops where the contents are shifted one bit position per clock.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，ALU中的所有内容看起来都可以通过组合逻辑实现，除了这些移位指令。你可以通过触发器构建*移位寄存器*，其中内容每个时钟周期向右或向左移动一位。
- en: A sequential shift register (shown in [Figure 4-10](ch04.xhtml#ch04fig10)) is
    slow because it takes one clock per bit in the worst case.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序移位寄存器（如[图4-10](ch04.xhtml#ch04fig10)所示）较慢，因为在最坏的情况下，每一位需要一个时钟周期。
- en: '![Image](../images/04fig10.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig10.jpg)'
- en: '*Figure 4-10: A sequential shift register*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-10：一个顺序移位寄存器*'
- en: We can solve this by constructing a *barrel shifter* entirely out of combinatorial
    logic using one of our logic building blocks, the selector (refer back to [Figure
    2-47](ch02.xhtml#ch02fig47)). To build an 8-bit shifter, we would need eight of
    the 8:1 selectors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用我们的逻辑构建模块——选择器（请参考[图2-47](ch02.xhtml#ch02fig47)）来完全用组合逻辑构建一个*桶形移位器*。要构建一个8位移位器，我们需要八个8:1选择器。
- en: There is one selector for each bit, as shown in [Figure 4-11](ch04.xhtml#ch04fig11).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每一位都有一个选择器，如[图4-11](ch04.xhtml#ch04fig11)所示。
- en: '![Image](../images/04fig11.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig11.jpg)'
- en: '*Figure 4-11: A combinatorial barrel shifter*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-11：一个组合式桶形移位器*'
- en: The amount of right shift is provided on S[0-2]. You can see that with no shift
    (000 for S), input bit 0 (I[0]) gets passed to output bit 0 (O[0]), I[1] to O[1],
    and so on. When S is 001, the outputs are shifted right by one because that’s
    the way the inputs are wired up to the selector. When S is 010, the outputs are
    shifted right by two, and so on. In other words, we have all eight possibilities
    wired and just select the one we want.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 右移的位数由S[0-2]提供。你可以看到，在没有移位（S为000）的情况下，输入位0（I[0]）被传递到输出位0（O[0]），输入位1（I[1]）到输出位1（O[1]），以此类推。当S为001时，输出会向右移动一位，因为输入是通过选择器接线的。当S为010时，输出会向右移动两位，依此类推。换句话说，我们已经将所有八种可能性接线，只需要选择我们想要的那个。
- en: You may wonder why I keep showing these logic diagrams as if they’re built out
    of old 7400 series parts. Functions such as gates, multiplexors, demultiplexors,
    adders, latches, and so on are available as predefined components in integrated
    circuit design systems. They’re used just like the old components, except instead
    of sticking lots of the 7400 series parts I mentioned in [Chapter 2](ch02.xhtml#ch02)
    onto a circuit board, we now assemble similar components into a single chip using
    design software.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我一直在展示这些逻辑图，好像它们是由旧的7400系列元件构建的。像门、复用器、解复用器、加法器、锁存器等功能在集成电路设计系统中作为预定义组件提供。它们的使用方式与旧元件相似，不同之处在于，我们现在使用设计软件将类似的组件组装成一个单一的芯片，而不是像在[第2章](ch02.xhtml#ch02)中提到的那样将许多7400系列元件贴在电路板上。
- en: You may have noticed the absence of multiplication and division operations in
    our simple ALU. That’s because they’re much more complicated and don’t really
    show us anything we haven’t already seen. You know that multiplication can be
    performed by repeated addition; that’s the sequential version. You can also build
    a combinatorial multiplier by cascading barrel shifters and adders, keeping in
    mind that a left shift multiplies a number by 2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们简单的算术逻辑单元（ALU）中缺少乘法和除法操作。这是因为它们要复杂得多，而且并没有给我们展示什么我们还没有见过的东西。你知道乘法可以通过重复加法来实现；那是顺序版本。你还可以通过级联桶移位器和加法器来构建一个组合型乘法器，同时记住左移操作会将数字乘以2。
- en: Shifters are a key element for the implementation of floating-point arithmetic;
    the exponents are used to shift the mantissas to line up the binary points so
    that they can be added together, subtracted, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 移位器是实现浮点运算的关键元素；指数用于将尾数移位，以对齐二进制点，从而使得它们可以相加、相减，等等。
- en: '***Execution Unit***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行单元***'
- en: The *execution unit* of a computer, also known as the *control unit*, is the
    boss. The ALU isn’t much use by itself, after all—something has to tell it what
    to do. The execution unit grabs opcodes and operands from the right places in
    memory, tells the ALU what operations to perform, and puts the results back in
    memory. Hopefully, it does all that in an order that serves some useful purpose.
    (By the way, we’re using the “to perform” definition of *execute*. No bits are
    actually killed.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的*执行单元*，也叫*控制单元*，是总指挥。毕竟，仅有算术逻辑单元（ALU）本身并没有太大用处——必须有一个东西来告诉它该做什么。执行单元从内存中的正确位置获取操作码和操作数，告诉ALU执行哪些操作，并将结果放回内存中。希望它能以某种有用的顺序完成这些操作。（顺便说一句，我们这里使用的是“执行”作为*执行*的定义。并没有实际消耗任何位。）
- en: How might the execution unit do this? We give it a list of instructions, things
    like “add the number in location 10 to the number in location 12 and put the result
    in location 14.” Where does the execution unit find these instructions? In memory!
    The technical name for what we have here is a *stored-program computer*. It has
    its genesis in work by English wizard Alan Turing (1912–1954).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行单元怎么做到这一点呢？我们给它一份指令清单，比如“将位置10中的数字加到位置12中的数字，并将结果放到位置14中。”执行单元从哪里找到这些指令呢？从内存中！我们所拥有的技术名称是*存储程序计算机*。它源自英国天才艾伦·图灵（1912–1954）的研究。
- en: That’s right, we have yet another way of looking at bits and interpreting them.
    *Instructions* are bit patterns that tell the computer what to do. The bit patterns
    are part of the design of a particular CPU. They’re not some general standard,
    like numbers, so an Intel Core i7 CPU would likely have a different bit pattern
    for the `inc A` instruction than an ARM Cortex-A CPU.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，我们有另一种查看和解释位的方式。*指令*是告诉计算机该做什么的位模式。这些位模式是特定CPU设计的一部分。它们不是某种通用标准，就像数字一样，所以英特尔Core
    i7 CPU的`inc A`指令的位模式可能与ARM Cortex-A CPU的位模式不同。
- en: How does the execution unit know where to look for an instruction in memory?
    It uses a *program counter* (often abbreviated *PC*), which is sort of like a
    mail carrier, or like a big arrow labeled “You are here.” Shown in [Figure 4-12](ch04.xhtml#ch04fig12),
    the program counter is another register, one of those pieces of memory on the
    special side street. It’s constructed from a counter (see “[Counters](ch03.xhtml#ch03lev2sec6)”
    on [page 77](ch03.xhtml#page_77)) instead of a vanilla register (see “[Registers](ch03.xhtml#ch03lev2sec7)”
    on [page 78](ch03.xhtml#page_78)). You can view the counter as a register with
    additional counting functionality.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 执行单元如何知道去哪里找内存中的指令呢？它使用*程序计数器*（通常缩写为*PC*），这就像一个邮递员，或者像一个标有“你在这里”的大箭头。如[图4-12](ch04.xhtml#ch04fig12)所示，程序计数器是另一个寄存器，是位于特殊内存“旁路”上的一部分。它由计数器（参见[计数器](ch03.xhtml#ch03lev2sec6)在[第77页](ch03.xhtml#page_77)）构成，而不是普通的寄存器（参见[寄存器](ch03.xhtml#ch03lev2sec7)在[第78页](ch03.xhtml#page_78)）。你可以将计数器视为一个带有附加计数功能的寄存器。
- en: '![Image](../images/04fig12.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig12.jpg)'
- en: '*Figure 4-12: A program counter*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-12：程序计数器*'
- en: The program counter contains a memory address. In other words, it points at,
    or *references*, a location in memory. The execution unit fetches an instruction
    from the location referenced by the program counter. There are special instructions
    that change the value of the program counter, which we’ll see shortly. Unless
    we’re executing one of these, the program counter is *incremented* (that is, the
    size of one instruction is added to it) after the instruction is executed so that
    the next instruction will come from the next memory location. Note that CPUs have
    some initial program counter value, usually 0, when the power is turned on. The
    counter we saw in [Figure 3-17](ch03.xhtml#ch03fig17) has inputs to support all
    these functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 程序计数器包含一个内存地址。换句话说，它指向或*引用*内存中的某个位置。执行单元从程序计数器引用的位置取出一条指令。有一些特殊的指令可以改变程序计数器的值，我们稍后会看到。除非我们正在执行这些特殊指令，否则程序计数器在指令执行后会被*递增*（也就是加上一个指令的大小），这样下一条指令就会从下一个内存位置取出。请注意，CPU在开机时会有一个初始的程序计数器值，通常是0。[图3-17](ch03.xhtml#ch03fig17)中的计数器支持所有这些功能。
- en: It all works kind of like a treasure hunt. The computer goes to a certain place
    in memory and finds a note. It reads that note, which tells it to do something,
    and then goes someplace else to get the next note, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切有点像寻宝游戏。计算机到达内存中的某个位置，找到一张便条。它读取便条，按照便条上写的去做，然后去其他地方拿到下一张便条，依此类推。
- en: '**Instruction Set**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**指令集**'
- en: The notes that computers find in memory during their treasure hunt are called
    *instructions*. This section goes into what those instructions contain.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在内存中进行寻宝时找到的笔记叫做*指令*。本节将深入探讨这些指令的内容。
- en: '***Instructions***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指令***'
- en: To see what sort of instructions might we find in a CPU, and how we choose bit
    patterns for them, our example assumes a computer with 16-bit-wide instructions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看我们在CPU中可能找到什么样的指令，以及我们如何选择它们的比特模式，我们的示例假设计算机的指令宽度为16位。
- en: Let’s try dividing our instruction into four fields—the opcode plus addresses
    for two operands and result—as shown in [Figure 4-13](ch04.xhtml#ch04fig13).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将指令分成四个字段——操作码，加上两个操作数和结果的地址——如[图4-13](ch04.xhtml#ch04fig13)所示。
- en: '![Image](../images/04fig13.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig13.jpg)'
- en: '*Figure 4-13: Three-address instruction layout*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-13：三地址指令布局*'
- en: This may seem like a good idea, but it doesn’t work very well. Why? Because
    we only have room for 4 bits of address for each of the operands and the result.
    It’s kind of hard to address a useful amount of memory when you have only 16 addresses.
    We could make the instruction bigger, but even if we went to 64-bit-wide instructions,
    we’d have only 20 bits of address, which would reach only a mebibyte of memory.
    Modern machines have gibibytes of memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是个不错的主意，但实际上并不好用。为什么呢？因为我们每个操作数和结果只有4位地址空间。当只有16个地址时，想要访问大量内存是很困难的。我们可以把指令做得更大，但即便我们使用64位宽的指令，也只有20位地址，这样只能访问到1
    MiB的内存，而现代计算机的内存是GiB级别的。
- en: Another approach would be to duplicate the DRAM addressing trick we saw in [Figure
    3-23](ch03.xhtml#ch03fig23). We could have an *address extension register* and
    load it with the high-order address bits using a separate instruction. This technique
    was used by Intel to allow its 32-bit machines to access more than 4-GiB of memory.
    Intel called it PAE, for *physical address extension*. Of course, it takes extra
    time to load this register, and lots of register loads are required if we need
    memory on both sides of the boundary created by this approach.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是重复我们在[图 3-23](ch03.xhtml#ch03fig23)中看到的 DRAM 地址技巧。我们可以有一个*地址扩展寄存器*，并使用单独的指令将高位地址位加载到该寄存器中。英特尔使用此技术，使其
    32 位计算机能够访问超过 4 GiB 的内存。英特尔称其为 PAE，即*物理地址扩展*。当然，加载此寄存器需要额外的时间，如果我们需要在此方法所创建的边界两侧都访问内存，还需要大量的寄存器加载。
- en: 'There’s an even more important reason why the three-address format doesn’t
    work well, though: it counts on some magic, nonexistent form of memory that allows
    three different locations to be addressed at the same time. All three memory blocks
    in [Figure 4-14](ch04.xhtml#ch04fig14) are the same memory device; there aren’t
    three address buses and three data buses.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，三地址格式无法正常工作有一个更重要的原因：它依赖于某种神奇的、不存在的内存形式，允许同时访问三个不同的位置。图[4-14](ch04.xhtml#ch04fig14)中的所有三个内存块都是相同的内存设备；并没有三个地址总线和三个数据总线。
- en: '![Image](../images/04fig14.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig14.jpg)'
- en: '*Figure 4-14: Unworkable computer architecture*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-14：无法实现的计算机架构*'
- en: 'We could make this work by having one register hold the contents of operand
    A and another hold the contents of operand B. The hardware would need to do the
    following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过让一个寄存器保存操作数 A 的内容，另一个寄存器保存操作数 B 的内容来使其工作。硬件需要执行以下操作：
- en: Load the instruction from memory using the address in the program counter.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用程序计数器中的地址从内存加载指令。
- en: Load the operand A register using the address from the operand A portion of
    the instruction.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令中操作数 A 部分的地址加载操作数 A 寄存器。
- en: Load the operand B register using the address from the operand B portion of
    the instruction.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令中操作数 B 部分的地址加载操作数 B 寄存器。
- en: Store the result in memory using the address from the result portion of the
    instruction.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令结果部分的地址将结果存储在内存中。
- en: That’s a lot of complicated hardware. If each of these steps took a clock cycle,
    then it would take four cycles just to get something done. We should take a hint
    from the fact that we can access only one memory location at a time and design
    our instruction set accordingly. More address bits would be available if we tried
    to address only one thing at a time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要许多复杂的硬件。如果这些步骤每个都需要一个时钟周期，那么光是完成一项操作就需要四个周期。我们应该从只能一次访问一个内存位置的事实中获取提示，并相应地设计我们的指令集。如果我们只试图一次只访问一项内容，那么可以使用更多的地址位。
- en: We can do that by adding another house to the register street. We’ll call this
    register the *accumulator*, or *A* register for short, and it will hold the result
    from the ALU. Rather than doing an operation between two memory locations, we’ll
    do it between one memory location and the accumulator. Of course, we’ll have to
    add a *store* instruction that stores the contents of the accumulator in a memory
    location. So now we can lay out our instructions as shown in [Figure 4-15](ch04.xhtml#ch04fig15).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向寄存器街道添加另一个“房子”来做到这一点。我们称这个寄存器为*累加器*，简称*A*寄存器，它将保存来自 ALU 的结果。我们不再在两个内存位置之间执行操作，而是在一个内存位置和累加器之间执行操作。当然，我们还需要添加一个*存储*指令，将累加器的内容存储到内存位置中。现在，我们可以按照[图
    4-15](ch04.xhtml#ch04fig15)所示来布局我们的指令。
- en: '![Image](../images/04fig15.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig15.jpg)'
- en: '*Figure 4-15: Single-address instruction layout*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-15：单地址指令布局*'
- en: 'This gets us more address bits, but it takes more instructions to get things
    done. We used to be able to have an instruction that said:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们获得了更多的地址位，但需要更多的指令才能完成操作。我们曾经能够有一条指令，它说：
- en: '*C* = *A* + *B*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* = *A* + *B*'
- en: 'But now we need three instructions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们需要三条指令：
- en: Accumulator = *A*
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器 = *A*
- en: Accumulator = Accumulator + *B*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器 = 累加器 + *B*
- en: '*C* = Accumulator'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* = 累加器'
- en: 'You might notice that we just replaced one instruction with three, effectively
    making the instruction bigger and contradicting ourselves. That’s true for this
    simple case, but it’s not true in general. Let’s say we needed to calculate this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我们只是用三条指令替换了一条指令，实际上使得指令变得更大，这与我们之前的做法相矛盾。这对于这个简单的情况来说是正确的，但在一般情况下并不成立。假设我们需要计算这个：
- en: '*D* = *A* + *B* + *C*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*D* = *A* + *B* + *C*'
- en: 'We couldn’t do that in a single instruction even if it could access three addresses
    because now we need four. We’d have to do it like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使可以访问三个地址，我们也无法通过单条指令实现这一点，因为现在我们需要四个地址。我们得像这样做：
- en: Intermediate = *A* + *B*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 中间值 = *A* + *B*
- en: '*D* = Intermediate + *C*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*D* = 中间值 + *C*'
- en: Sticking with 12 bits of address, we’d need 40-bit instructions to handle three
    address plus the opcode. And we’d need two of these instructions for a total of
    80 bits to calculate *D*. Using the single-address version of the instructions
    requires four instructions for a total of 64 bits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设使用12位地址，我们需要40位的指令来处理三个地址加操作码。为了计算 *D*，我们需要两个这样的指令，总共80位。而使用单地址版本的指令需要四条指令，总共64位。
- en: Accumulator = *A*
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器 = *A*
- en: Accumulator = Accumulator + *B*
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器 = 累加器 + *B*
- en: Accumulator = Accumulator + *C*
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器 = 累加器 + *C*
- en: '*D* = Accumulator'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*D* = 累加器'
- en: '***Addressing Modes***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寻址模式***'
- en: Using an accumulator managed to get us 12 address bits, and although being able
    to address 4,096 bytes is much better than 16, it’s still not enough. This way
    of addressing memory is known as *direct addressing*, which just means that the
    address is the one given in the instruction.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用累加器使我们能够使用12位地址，虽然能够寻址4,096字节比16字节好多了，但仍然不够。这种寻址方式被称为*直接寻址*，意味着地址就是指令中给定的地址。
- en: We can address more memory by adding *indirect addressing*. With indirect addressing,
    we get the address from the memory location contained in the instruction, rather
    than directly from the instruction itself. For example, let’s say memory location
    12 contains the value 4,321, and memory location 4,321 contains 345\. If we used
    direct addressing, loading from location 12 would get 4,321, while indirect addressing
    would get 345, the contents of location 4,321.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增加*间接寻址*来寻址更多的内存。在间接寻址中，我们从指令中包含的内存位置获取地址，而不是直接从指令本身获取地址。例如，假设内存位置12包含值4321，而内存位置4321包含值345。如果使用直接寻址，从位置12加载会得到4321，而使用间接寻址会得到345，即位置4321的内容。
- en: This is all fine for dealing with memory, but sometimes we just need to get
    constant numbers. For example, if we need to count to 10, we need some way of
    loading that number. We can do this with yet another addressing mode, called *immediate
    mode addressing*. Here the address is just treated as a number, so, using the
    previous example, loading 12 in immediate mode would get 12\. [Figure 4-16](ch04.xhtml#ch04fig16)
    compares these addressing modes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于处理内存来说没问题，但有时我们只是需要获取常数值。例如，如果我们需要计数到10，我们需要某种方式加载这个数字。我们可以通过另一种寻址模式来实现，叫做*立即寻址模式*。在这种模式下，地址仅被视为一个数字，因此，使用前面的例子，立即寻址模式加载12将得到12。[图4-16](ch04.xhtml#ch04fig16)对比了这些寻址模式。
- en: '![Image](../images/04fig16.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig16.jpg)'
- en: '*Figure 4-16: Addressing modes*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-16：寻址模式*'
- en: Clearly, direct addressing is slower than immediate addressing as it takes a
    second memory access. Indirect is slower still as it takes a third memory access.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，直接寻址比立即寻址要慢，因为它需要第二次内存访问。间接寻址则更慢，因为它需要第三次内存访问。
- en: '***Condition Code Instructions***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***条件码指令***'
- en: There are still a few things missing from our CPU, such as instructions that
    work with the condition codes. We’ve seen that these codes are set by addition,
    subtraction, and comparison. But we need some way of setting them to known values
    and some way of looking at the values. We can do that by adding a `cca` instruction
    that copies the contents of the condition code register to the accumulator and
    an `acc` instruction that copies the contents of the accumulator to the condition
    code register.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CPU仍然缺少一些东西，比如能处理条件码的指令。我们已经看到，这些条件码是通过加法、减法和比较来设置的。但我们需要一种方法将它们设置为已知值，并且还需要一种方法查看这些值。我们可以通过增加一个`cca`指令来实现，它将条件码寄存器的内容复制到累加器中，另外还可以使用`acc`指令将累加器的内容复制到条件码寄存器。
- en: '***Branching***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分支***'
- en: Now we have instructions that can do all sorts of things, but all we can do
    is execute a list of them from start to finish. That’s not all that useful. We’d
    really like to have programs that can make decisions and select portions of code
    to execute. Those would take instructions that let us change the value of the
    program counter. These are called *branch* instructions, and they cause the program
    counter to be loaded with a new address. By itself, that’s not any more useful
    than just being able to execute a list of instructions. But branch instructions
    don’t always branch; they look at the condition codes and branch only if the conditions
    are met. Otherwise, the program counter is incremented normally, and the instruction
    following the branch instruction is executed next. Branch instructions need a
    few bits to hold the condition, as shown in [Table 4-2](ch04.xhtml#ch04tab02).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以做各种事情的指令，但我们能做的只是从头到尾执行它们的列表。这并不太有用。我们真正希望的是能够编写可以做出决策并选择要执行的代码片段的程序。为了实现这一点，我们需要一些能改变程序计数器值的指令。这些被称为*分支*指令，它们会将程序计数器加载到一个新的地址。仅仅如此，它并不比能够执行一个指令列表更有用。但分支指令并不总是进行跳转；它们会查看条件码，只有满足条件时才会跳转。否则，程序计数器会正常递增，接着执行分支指令后的下一条指令。分支指令需要几个比特位来存储条件，如[表
    4-2](ch04.xhtml#ch04tab02)所示。
- en: '**Table 4-2:** Branch Instruction Conditions'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2：** 分支指令条件'
- en: '| **Code** | **Mnemonic** | **Description** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **助记符** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `000` | bra | Branch always. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `000` | bra | 始终跳转。 |'
- en: '| `001` | bov | Branch if the O (overflow) condition code bit is set. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `001` | bov | 如果 O（溢出）条件码位被设置，则跳转。 |'
- en: '| `010` | beq | Branch if the Z (zero) condition code bit is set. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `010` | beq | 如果 Z（零）条件码位被设置，则跳转。 |'
- en: '| `011` | bne | Branch if the Z condition code bit is not set. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `011` | bne | 如果 Z 条件码位未被设置，则跳转。 |'
- en: '| `100` | blt | Branch if N (negative) is set and Z is clear. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `100` | blt | 如果 N（负值）被设置且 Z 为清零，则跳转。 |'
- en: '| `101` | ble | Branch if N or Z is set. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `101` | ble | 如果 N 或 Z 被设置，则跳转。 |'
- en: '| `110` | bgt | Branch if N is clear and Z is clear. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `110` | bgt | 如果 N 为清零且 Z 为清零，则跳转。 |'
- en: '| `111` | bge | Branch if N is clear or Z is set. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `111` | bge | 如果 N 为清零或 Z 被设置，则跳转。 |'
- en: 'Sometimes we need to explicitly change the contents of the program counter.
    We have two special instructions to help with this: `pca`, which copies the current
    program counter value to the accumulator, and `apc`, which copies the contents
    of the accumulator to the program counter.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要显式地改变程序计数器的内容。我们有两个特殊的指令来帮助实现这一点：`pca`，它将当前的程序计数器值复制到累加器中，以及`apc`，它将累加器的内容复制到程序计数器中。
- en: '***Final Instruction Set***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最终指令集***'
- en: Let’s integrate all these features into our instruction set, as shown in [Figure
    4-17](ch04.xhtml#ch04fig17).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些功能整合到我们的指令集中，如[图 4-17](ch04.xhtml#ch04fig17)所示。
- en: '![Image](../images/04fig17.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig17.jpg)'
- en: '*Figure 4-17: The final instruction layout*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-17：最终的指令布局*'
- en: We have three *addressing modes*, which means that we need 2 bits in order to
    select the mode. The unused fourth-bit combination is used for operations that
    don’t involve memory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种*寻址模式*，这意味着我们需要 2 位来选择模式。未使用的第四位组合用于不涉及内存的操作。
- en: The addressing mode and opcode decode into instructions, as you can see in [Table
    4-3](ch04.xhtml#ch04tab03). Note that the branch conditions are merged into the
    opcodes. The opcodes for addressing mode 3 are used for operations that involve
    only the accumulator. A side effect of the complete implementation is that the
    opcodes don’t exactly match the ALU that we saw in [Table 4-1](ch04.xhtml#ch04tab01).
    This is not unusual and requires some additional logic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 寻址模式和操作码解码成指令，正如你在[表 4-3](ch04.xhtml#ch04tab03)中看到的那样。请注意，分支条件已经并入到操作码中。寻址模式
    3 的操作码用于仅涉及累加器的操作。完整实现的一个副作用是，操作码并不完全与我们在[表 4-1](ch04.xhtml#ch04tab01)中看到的 ALU
    匹配。这并不罕见，并且需要一些额外的逻辑。
- en: '**Table 4-3:** Addressing Modes and Opcodes'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3：** 寻址模式和操作码'
- en: '| **Opcode** | **Addressing mode** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **操作码** | **寻址模式** |'
- en: '| --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Direct (00)** | **Indirect (01)** | **Immediate (10)** | **None (11)**
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **直接寻址 (00)** | **间接寻址 (01)** | **立即数 (10)** | **无 (11)** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0000` | load | load | load |  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `0000` | load | load | load |  |'
- en: '| `0001` | and | and | and | set |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `0001` | and | and | and | set |'
- en: '| `0010` | or | or | ore | not |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `0010` | or | or | ore | not |'
- en: '| `0011` | xor | xor | xor | neg |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `0011` | xor | xor | xor | neg |'
- en: '| `0100` | add | add | add | shl |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `0100` | add | add | add | shl |'
- en: '| `0101` | sub | sub | sub | shr |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `0101` | sub | sub | sub | shr |'
- en: '| `0110` | cmp | cmp | cmp | acc |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `0110` | cmp | cmp | cmp | acc |'
- en: '| `0111` | store | store |  | cca |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `0111` | store | store |  | cca |'
- en: '| `1000` | bra | bra | bra | apc |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `1000` | bra | bra | bra | apc |'
- en: '| `1001` | bov | bov | bov | pca |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `1001` | bov | bov | bov | pca |'
- en: '| `1010` | beq | beq | beq |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `1010` | beq | beq | beq |  |'
- en: '| `1011` | bne | bne | bne |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `1011` | bne | bne | bne |  |'
- en: '| `1100` | blt | blt | blt |  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `1100` | blt | blt | blt |  |'
- en: '| `1101` | ble | bge | ble |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `1101` | ble | bge | ble |  |'
- en: '| `1110` | bgt | bgt | bgt |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `1110` | bgt | bgt | bgt |  |'
- en: '| `1111` | bge | bge | bge |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `1111` | bge | bge | bge |  |'
- en: The shift-left and shift-right instructions put some of the otherwise unused
    bits to use as a count of the number of positions to shift, as shown in [Figure
    4-18](ch04.xhtml#ch04fig18).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 左移和右移指令将一些原本未使用的位用作位移次数的计数器，如[图4-18](ch04.xhtml#ch04fig18)所示。
- en: '![Image](../images/04fig18.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig18.jpg)'
- en: '*Figure 4-18: Shift instruction layout*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-18：移位指令布局*'
- en: Now we can actually instruct the computer to do something by writing a *program*,
    which is just a list of instructions that carry out some task. We’ll compute all
    Fibonacci (Italian mathematician, 1175–1250) numbers up to 200\. Fibonacci numbers
    are pretty cool; the number of petals on flowers, for example, are Fibonacci numbers.
    The first two Fibonacci numbers are 0 and 1\. We get the next one by adding them
    together. We keep adding the new number to the previous one to get the sequence,
    which is 0, 1, 1, 2, 3, 5, 8, 13, and so on. The process looks like [Figure 4-19](ch04.xhtml#ch04fig19).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过编写一个*程序*来实际指示计算机执行某些任务，程序只是一个执行某些任务的指令列表。我们将计算所有小于200的斐波那契（意大利数学家，1175–1250）数。斐波那契数非常有趣；例如，花朵的花瓣数就是斐波那契数。前两个斐波那契数是0和1。通过将它们相加，我们得到下一个数。我们不断地将新数加到前一个数中，以得到序列，即0、1、1、2、3、5、8、13，依此类推。该过程如[图4-19](ch04.xhtml#ch04fig19)所示。
- en: '![Image](../images/04fig19.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig19.jpg)'
- en: '*Figure 4-19: Flowchart for Fibonacci sequence program*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-19：斐波那契数列程序的流程图*'
- en: The short program shown in [Table 4-4](ch04.xhtml#ch04tab04) implements this
    process. The Instruction column is divided into fields as per [Figure 4-17](ch04.xhtml#ch04fig17).
    The addresses in the comments are decimal numbers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4-4](ch04.xhtml#ch04tab04)中显示的简短程序实现了这一过程。指令列根据[图4-17](ch04.xhtml#ch04fig17)被分为多个字段。注释中的地址是十进制数。'
- en: '**Table 4-4:** Machine Language Program to Compute Fibonacci Sequence'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-4：计算斐波那契数列的机器语言程序**'
- en: '| **Address** | **Instruction** | **Description** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **指令** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0000` | `10 0000 0000000000` | Clear the accumulator (load 0 immediate).
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `0000` | `10 0000 0000000000` | 清空累加器（立即加载0）。 |'
- en: '| `0001` | `00 0111 0001100100` | Store the accumulator (0) in memory location
    100. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `0001` | `00 0111 0001100100` | 将累加器（0）存储在内存位置100。 |'
- en: '| `0010` | `10 0000 0000000001` | Load 1 into the accumulator (load 1 immediate).
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `0010` | `10 0000 0000000001` | 将1加载到累加器中（立即加载1）。 |'
- en: '| `0011` | `00 0111 0001100101` | Store the accumulator (1) in memory location
    101. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `0011` | `00 0111 0001100101` | 将累加器（1）存储在内存位置101。 |'
- en: '| `0100` | `00 0000 0001100100` | Load the accumulator from memory location
    100. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `0100` | `00 0000 0001100100` | 从内存位置100加载累加器。 |'
- en: '| `0101` | `10 0100 0001100101` | Add the contents of memory location 101 to
    the accumulator. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `0101` | `10 0100 0001100101` | 将内存位置101的内容加到累加器中。 |'
- en: '| `0110` | `00 0111 0001100110` | Store the accumulator in memory location
    102. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `0110` | `00 0111 0001100110` | 将累加器存储在内存位置102。 |'
- en: '| `0111` | `00 0000 0001100101` | Load the accumulator from memory location
    101. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `0111` | `00 0000 0001100101` | 从内存位置101加载累加器。 |'
- en: '| `1000` | `00 0111 0001100100` | Store it in memory location 100. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `1000` | `00 0111 0001100100` | 将其存储在内存位置100。 |'
- en: '| `1001` | `00 0000 0001100110` | Load the accumulator from memory location
    102. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `1001` | `00 0000 0001100110` | 从内存位置102加载累加器。 |'
- en: '| `1010` | `00 0111 0001100101` | Store it in memory location 101. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `1010` | `00 0111 0001100101` | 将其存储在内存位置101。 |'
- en: '| `1011` | `10 0110 0011001000` | Compare the contents of the accumulator to
    the number 200. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `1011` | `10 0110 0011001000` | 将累加器的内容与数字200进行比较。 |'
- en: '| `1100` | `00 0111 0000000100` | Do another number if the last one was less
    than 200 by branching to address 4 (0100). |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `1100` | `00 0111 0000000100` | 如果上一个数小于200，则通过跳转到地址4（0100）执行另一个数字。 |'
- en: '**The Final Design**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最终设计**'
- en: Let’s put all the pieces that we’ve seen so far together into an actual computer.
    We’ll need a few pieces of “glue” to make it all work.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把到目前为止看到的所有部分组合成一个实际的计算机。我们需要一些“粘合剂”来使这一切工作起来。
- en: '***The Instruction Register***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指令寄存器***'
- en: You might be fooled into thinking that the computer just executes the Fibonacci
    program one instruction at a time. But more is happening behind the scenes. What
    does it take to execute an instruction? There’s a *state machine* doing the two-step,
    shown in [Figure 4-20](ch04.xhtml#ch04fig20).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被误导，以为计算机只是逐条执行斐波那契程序。然而，背后发生的事情比这复杂。执行一条指令需要什么？有一个*状态机*在做这两步操作，如[图 4-20](ch04.xhtml#ch04fig20)所示。
- en: '![Image](../images/04fig20.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig20.jpg)'
- en: '*Figure 4-20: The fetch-execute cycle*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-20：获取-执行周期*'
- en: The first thing that we have to do is to fetch an instruction from memory. Once
    we have that instruction, then we can worry about executing it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从内存中获取一条指令。一旦我们得到了这条指令，就可以开始执行它。
- en: Executing instructions usually involves accessing memory. That means we need
    someplace to keep the instruction handy while we’re using memory for some other
    task. In [Figure 4-21](ch04.xhtml#ch04fig21), we add an *instruction register*
    to our CPU to hold the current instruction.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行指令通常涉及访问内存。这意味着我们需要一个地方来保存当前指令，以便在使用内存执行其他任务时可以随时使用。在[图 4-21](ch04.xhtml#ch04fig21)中，我们向CPU添加了一个*指令寄存器*来保存当前指令。
- en: '![Image](../images/04fig21.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig21.jpg)'
- en: '*Figure 4-21: Adding an instruction register*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-21：添加指令寄存器*'
- en: '***Data Paths and Control Signals***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据路径和控制信号***'
- en: 'Here comes the complicated part. We need a way to feed the contents of the
    program counter to the memory address bus and a way to feed the memory data into
    the instruction register. We can do a similar exercise to determine all the different
    connections required to implement everything in our instruction set as detailed
    in [Table 4-4](ch04.xhtml#ch04tab04). We end up with [Figure 4-22](ch04.xhtml#ch04fig22),
    which probably seems confusing. But it’s really just things we’ve seen before:
    some registers, some selectors, the ALU, and a tri-state buffer.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是复杂的部分。我们需要一种方法将程序计数器的内容传输到内存地址总线，并且将内存数据传输到指令寄存器。我们可以做类似的操作，确定所有不同的连接，来实现我们指令集中的每一项，如[表
    4-4](ch04.xhtml#ch04tab04)所详细描述的那样。最终我们得到了[图 4-22](ch04.xhtml#ch04fig22)，看起来可能很复杂。但其实这只是我们之前看到的一些东西：一些寄存器，一些选择器，算术逻辑单元（ALU）和一个三态缓冲器。
- en: Although this looks pretty complicated, it’s just like a road map. And it’s
    way simpler than a real city map. The address selector is just a three-way intersection,
    and the data selector is a four-way. There are connections hanging off of the
    address bus and data bus for things like the I/O devices that we’ll discuss in
    [Chapter 6](ch06.xhtml#ch06).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来相当复杂，但其实就像一张路线图。比起真实的城市地图，它要简单得多。地址选择器就像一个三路交叉口，而数据选择器是一个四路交叉口。地址总线和数据总线上的连接会涉及一些设备，如我们将在[第6章](ch06.xhtml#ch06)中讨论的I/O设备。
- en: '![Image](../images/04fig22.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig22.jpg)'
- en: '*Figure 4-22: Data paths and control signals*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-22：数据路径和控制信号*'
- en: The only new part is the *indirect address register*. We need that because we
    need somewhere to hold indirect addresses fetched from memory, similar to how
    the instruction register holds instructions fetched from memory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新部分是*间接地址寄存器*。我们需要这个寄存器，因为我们需要一个地方来存储从内存中获取的间接地址，类似于指令寄存器存储从内存中获取的指令。
- en: For simplicity, [Figure 4-22](ch04.xhtml#ch04fig22) omits the system clock that
    goes to all of the registers and memory. In the simple register case, just assume
    the register is loaded on the next clock if enabled. Likewise, the program counter
    and memory do what their control signals tell them to do on each clock. All the
    other components, such as the selectors, are purely combinatorial and don’t use
    the clock.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，[图 4-22](ch04.xhtml#ch04fig22)省略了所有寄存器和内存的系统时钟。在简单的寄存器情况下，只需假设寄存器在下一个时钟周期被加载（如果已启用）。同样，程序计数器和内存会按照它们的控制信号在每个时钟周期执行任务。所有其他组件，如选择器，都是纯组合逻辑，并不使用时钟。
- en: '***Traffic Control***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流量控制***'
- en: Now that you’re familiar with all the inputs and outputs, it’s time to build
    our traffic control unit. Let’s look at a couple of examples of how it needs to
    behave.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了所有的输入和输出，接下来是时候构建我们的流量控制单元了。让我们看几个例子，了解它需要如何工作。
- en: 'Fetching is common to all instructions. The following signals are involved:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 获取操作是所有指令的共同操作。以下信号会涉及到：
- en: The `address source` must be set to select the program counter.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地址源`必须设置为选择程序计数器。'
- en: The memory must be enabled, and the read-write signal `r/w` must be set to read
    (1).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须启用内存，并且读写信号`r/w`必须设置为读取（1）。
- en: The instruction register must be enabled.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须启用指令寄存器。
- en: For our next example, we’ll store the contents of the accumulator at the memory
    address pointed to by the address contained in the instruction—in other words,
    using indirect addressing. Fetching works as before.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个示例，我们将把累加器的内容存储到指令中包含的地址所指向的内存地址——换句话说，使用间接寻址。获取过程与之前相同。
- en: 'Get the indirect address from memory:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存中获取间接地址：
- en: The `address source` must be set to select the instruction register, which gets
    us the address portion of the instruction.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须设置`address source`以选择指令寄存器，这样我们就可以得到指令的地址部分。
- en: Memory is enabled, and `r/w` is set to read (1).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用内存，并将`r/w`设置为读取（1）。
- en: The indirect address register is enabled.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用间接地址寄存器。
- en: 'Store the accumulator in that address:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将累加器存储到该地址：
- en: The `address source` must be set to select the indirect address register.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须设置`address source`以选择间接地址寄存器。
- en: The data bus `enable` must be set.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须设置数据总线`enable`。
- en: Memory is enabled and `r/w` is set to write (0).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用内存并将`r/w`设置为写入（0）。
- en: The program counter is incremented.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序计数器递增。
- en: Since multiple steps are involved in fetching and executing instructions, we
    need a counter to track them. The counter contents plus the opcode and mode portions
    of the instruction are all we need to generate all the control signals. We need
    2 bits of counter because three states are needed to execute our most complicated
    instructions, as illustrated in [Figure 4-23](ch04.xhtml#ch04fig23).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于获取和执行指令涉及多个步骤，我们需要一个计数器来跟踪它们。计数器的内容加上指令的操作码和模式部分，就是我们生成所有控制信号所需的内容。我们需要2位计数器，因为执行我们最复杂的指令需要三种状态，如[图4-23](ch04.xhtml#ch04fig23)所示。
- en: '![Image](../images/04fig23.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig23.jpg)'
- en: '*Figure 4-23: Random logic traffic control*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-23：随机逻辑交通控制*'
- en: This is a big box full of what’s called *random logic*. All the logic diagrams
    we’ve seen so far follow some regular pattern. Functional blocks, such as selectors
    and registers, are assembled from simpler blocks in a clear manner. Sometimes,
    such as when we’re implementing our traffic control unit, we have a set of inputs
    that must be mapped to a set of outputs to accomplish a task that has no regularity.
    The schematic looks like a rat’s nest of connections—hence the descriptor “random.”
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个充满所谓*随机逻辑*的大盒子。到目前为止，我们看到的所有逻辑图都遵循某种规律模式。功能模块，如选择器和寄存器，是由简单模块以清晰的方式组装而成的。有时，比如在实现交通控制单元时，我们有一组输入必须映射到一组输出，以完成一个没有规律的任务。电路图看起来像是老鼠窝般的连接——因此称之为“随机”。
- en: But there’s another way we could implement our traffic control unit. Instead
    of random logic, we could use a hunk of memory. The address would be formed from
    the counter outputs plus the opcode and mode portions of the instruction, as shown
    in [Figure 4-24](ch04.xhtml#ch04fig24).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以通过另一种方式实现我们的交通控制单元。与随机逻辑不同，我们可以使用一块内存。地址将由计数器输出加上指令的操作码和模式部分组成，如[图4-24](ch04.xhtml#ch04fig24)所示。
- en: '![Image](../images/04fig24.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig24.jpg)'
- en: '*Figure 4-24: Memory-based traffic control*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-24：基于内存的交通控制*'
- en: Each 19-bit memory word is laid out as shown in [Figure 4-25](ch04.xhtml#ch04fig25).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每个19位的存储字如[图4-25](ch04.xhtml#ch04fig25)所示布局。
- en: '![Image](../images/04fig25.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig25.jpg)'
- en: '*Figure 4-25: The layout of a microcode word*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-25：微代码字的布局*'
- en: This might strike you as somewhat strange. On the one hand, it’s just another
    state machine implemented using memory instead of random logic. On the other,
    it sure looks like a simple computer. Both interpretations are correct. It is
    a state machine because computers are state machines. But it is also a computer
    because it’s programmable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你觉得有点奇怪。一方面，它只不过是另一种状态机，使用内存而不是随机逻辑实现。另一方面，它看起来确实像一台简单的计算机。这两种解释都是正确的。它是一个状态机，因为计算机本身就是状态机。但它也是一台计算机，因为它是可编程的。
- en: This type of implementation is called *microcoded*, and the contents of memory
    are called *microcode*. Yes, we’re using a small computer as part of the implementation
    of our larger one.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式称为*微编码*，内存的内容称为*微代码*。是的，我们正在使用一个小型计算机作为我们大型计算机实现的一部分。
- en: Let’s look at the portion of the *microinstructions*, shown in [Figure 4-26](ch04.xhtml#ch04fig26),
    that implement the examples we’ve discussed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在[图4-26](ch04.xhtml#ch04fig26)中显示的*微指令*部分，这些微指令实现了我们之前讨论的示例。
- en: '![Image](../images/04fig26.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig26.jpg)'
- en: '*Figure 4-26: Microcode example*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-26：微代码示例*'
- en: As you might expect, it’s hard to avoid abusing a good idea. There are machines
    that have a *nanocoded* block that implements a *microcoded* block that implements
    the instruction set.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所料，很难避免滥用一个好的想法。有些机器拥有*纳米编码*区块，它实现了一个*微编码*区块，再由该区块实现指令集。
- en: Using ROM for the microcode memory makes a certain amount of sense, because
    otherwise we’d need to keep a copy of the microcode somewhere else and we’d require
    additional hardware to load the microcode. However, there are situations where
    RAM, or a mix of ROM and RAM, is justified. Some Intel CPUs have writable microcode
    that can be patched to fix bugs. A few machines, such as the HP-2100 series, had
    a *writable control store*, which was microcode RAM that could be used to extend
    the basic instruction set.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ROM作为微码存储器是有一定道理的，因为如果不使用ROM，我们就需要在其他地方保留一份微码副本，并且需要额外的硬件来加载微码。然而，在某些情况下，RAM或ROM和RAM的混合使用是合理的。一些Intel
    CPU具有可写的微码，可以通过修补程序来修复错误。一些机器，比如HP-2100系列，拥有*可写控制存储器*，它是可以用来扩展基本指令集的微码RAM。
- en: Machines that have writable microcode today rarely permit users to modify it
    for several reasons. Manufacturers don’t want users to rely on microcode they
    themselves write for their applications because once users become dependent on
    it, manufacturers have difficulty making changes. Also, buggy microcode can damage
    the machine—for example, it could turn on both the memory *enable* and data bus
    *enable* at the same time in our CPU, connecting together totem-pole outputs in
    a way that might burn out the transistors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拥有可写微码的机器很少允许用户修改它，原因有几个。制造商不希望用户依赖他们自己为应用程序编写的微码，因为一旦用户依赖它，制造商就很难进行更改。此外，错误的微码可能会损坏机器——例如，它可能会同时打开内存*使能*和数据总线*使能*，这样就会将输出引脚连接在一起，可能会烧毁晶体管。
- en: '**RISC vs. CISC Instruction Sets**'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**RISC与CISC指令集**'
- en: Designers used to create instructions for computers that seemed to be useful
    but that resulted in some pretty complicated machines. In the 1980s, American
    computer scientists David Patterson at Berkeley and John Hennessey at Stanford
    did statistical analyses of programs and discovered that many of the complicated
    instructions were rarely used. They pioneered the design of machines that contained
    only the instructions that accounted for most of a program’s time; less used instructions
    were eliminated and replaced by combinations of other instructions. These were
    called *RISC* machines, for *reduced instruction set computers*. Older designs
    were called *CISC* machines, for *complicated instruction set computers*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师曾经为计算机创建看似有用的指令，但这些指令导致了相当复杂的机器。在1980年代，美国计算机科学家David Patterson（伯克利大学）和John
    Hennessey（斯坦福大学）对程序进行了统计分析，发现许多复杂的指令很少使用。他们开创了只包含大多数程序时间所需指令的机器设计；使用较少的指令被删除，并由其他指令的组合替代。这些被称为*RISC*机器，即*精简指令集计算机*。较早的设计则被称为*CISC*机器，即*复杂指令集计算机*。
- en: 'One of the hallmarks of RISC machines is that they have a *load-store architecture*.
    This means there are two categories of instructions: one for accessing memory
    and one for everything else.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: RISC机器的一个显著特点是它们采用*加载-存储架构*。这意味着有两类指令：一种用于访问内存，另一种用于其他所有操作。
- en: Of course, computer use has changed over time. Patterson and Hennessey’s original
    statistics were done before computers were commonly used for things like audio
    and video. Statistics on newer programs are prompting designers to add new instructions
    to RISC machines. Today’s RISC machines are actually more complicated than the
    CISC machines of yore.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，计算机的使用随着时间的推移发生了变化。Patterson和Hennessey的最初统计数据是在计算机广泛用于音频和视频等任务之前进行的。对新程序的统计数据促使设计者为RISC机器添加新指令。今天的RISC机器实际上比过去的CISC机器更复杂。
- en: One of the CISC machines that had a big impact was the PDP-11 from Digital Equipment
    Corporation. This machine had eight general-purpose registers instead of the single
    accumulator we used in our example. These registers could be used for indirect
    addressing. In addition, *autoincrement* and *autodecrement* modes were supported.
    These modes enabled the values in the registers to be incremented or decremented
    before or after use. This allowed for some very efficient programs. For example,
    let’s say we want to copy *n* bytes of memory starting at a source address to
    memory starting at a destination address. We can put the source address in register
    0, the destination in register 1, and the count in register 2\. We’ll skip the
    actual bits here because there’s no real need to learn the PDP-11 instruction
    set. [Table 4-5](ch04.xhtml#ch04tab05) shows what these instructions do.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一款对计算机架构影响深远的CISC机器是来自数字设备公司的PDP-11。这台机器有八个通用寄存器，而不是我们在示例中使用的单一累加器。这些寄存器可以用于间接寻址。此外，还支持*自动递增*和*自动递减*模式。这些模式允许在使用前或使用后对寄存器中的值进行递增或递减操作，从而实现非常高效的程序。例如，假设我们想将从源地址开始的*n*字节内存复制到从目标地址开始的内存中。我们可以将源地址放入寄存器0，目标地址放入寄存器1，计数放入寄存器2。我们将跳过实际的位操作，因为学习PDP-11指令集并非必要。[表4-5](ch04.xhtml#ch04tab05)展示了这些指令的功能。
- en: '**Table 4-5:** PDP-11 Copy Memory Program'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-5：** PDP-11 复制内存程序'
- en: '| **Address** | **Description** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **描述** |'
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Copy the contents of the memory location whose address is in register
    0 to the memory location whose address is in register 1, then add 1 to each register.
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 将寄存器0中地址指向的内存位置的内容复制到寄存器1中地址指向的内存位置，然后将每个寄存器的值加1。 |'
- en: '| 1 | Subtract 1 from the contents of register 2 and then compare the result
    to 0. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 从寄存器2的内容中减去1，然后将结果与0进行比较。 |'
- en: '| 2 | Branch to location 0 if the result was not 0. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 如果结果不为0，则跳转到位置0。 |'
- en: Why should we care about this? The C programming language, a follow-on to B
    (which was a follow-on to BCPL), was developed on the PDP-11\. C’s use of *pointers*,
    a higher-level abstraction of indirect addressing, combined with features from
    B such as the autoincrement and autodecrement operators, mapped well to the PDP-11
    architecture. C became very influential and has affected the design of many other
    languages, including C++, Java, and JavaScript.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该关注这个？C编程语言是B语言的后继（B语言又是BCPL的后继），它是在PDP-11上开发的。C语言使用的*指针*是间接寻址的高级抽象，与B语言的特性，如自动递增和自动递减运算符，结合得很好，适配了PDP-11架构。C语言影响深远，对许多其他编程语言的设计产生了影响，包括C++、Java和JavaScript。
- en: '**Graphics Processing Units**'
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图形处理单元**'
- en: You’ve probably heard about *graphics processing units*, or GPUs. These are
    mostly outside the scope of this book but are worth a quick mention.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过*图形处理单元*，即GPU。它们大多超出了本书的范围，但值得简要提及。
- en: Graphics is a massive paint-by-numbers exercise. It’s not uncommon to have 8
    million color spots to paint and need to paint them 60 times per second if you
    want video to work well. That works out to around a half-billion memory accesses
    per second.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图形处理是一项庞大的按数字涂色的任务。如果你希望视频效果良好，通常需要涂上800万种颜色点，并且每秒涂60次。这意味着每秒大约要进行五亿次内存访问。
- en: 'Graphics is specialized work and doesn’t require all the features of a general-purpose
    CPU. And it’s something that parallelizes nicely: painting multiple spots at a
    time can improve performance.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图形处理是专业化的工作，不需要通用CPU的所有功能。而且它是一项能够很好地并行化的任务：同时绘制多个点可以提高性能。
- en: Two features distinguish GPUs. First, they have large numbers of simple processors.
    Second, they have much wider memory buses than CPUs, which means they can access
    memory much faster. GPUs have a fire hose instead of a garden hose.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: GPU有两个显著特征。首先，它们拥有大量简单的处理器。其次，它们的内存总线比CPU宽得多，这意味着它们可以更快速地访问内存。GPU就像喷火管，而不是花园水管。
- en: GPUs have acquired more general-purpose features over time. Work has been done
    to make them programmable using variants of standard programming languages, and
    they are now used for certain classes of applications that can take advantage
    of their architectures. GPUs were in short supply when this book was written because
    they were all being snapped up for Bitcoin mining.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，图形处理单元（GPU）获得了更多的通用功能。为了使其可编程，已进行了一些工作，将它们与标准编程语言的变种结合使用，现在它们已被用于某些可以充分利用其架构的应用程序。写这本书时GPU短缺，因为它们都被抢购用于比特币挖矿。
- en: '**Summary**'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we’ve created an actual computer using the building blocks
    introduced in previous chapters. Though simple, the machine we designed in this
    chapter could actually be built and programmed. It’s missing some elements found
    in real computers, however, such as stacks and memory management hardware. We’ll
    learn about those in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用前几章介绍的基本构件创建了一个实际的计算机。尽管简单，但我们在本章设计的机器实际上是可以构建和编程的。它缺少一些真实计算机中存在的元素，比如堆栈和内存管理硬件。我们将在[第5章](ch05.xhtml#ch05)中学习这些内容。
