- en: Chapter 10. Show Me the Data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章 数据展示
- en: 'Virtually every application written today requires robust mechanisms to both
    access and manipulate data. While the full gamut of data access technologies across
    the .NET Framework is available to you in F#, this chapter focuses on two specific
    areas: query expressions and type providers.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个今天编写的应用程序都需要强大的机制来访问和操作数据。尽管.NET框架中的各种数据访问技术都可以在F#中使用，本章重点介绍两个特定领域：查询表达式和类型提供程序。
- en: Query Expressions
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询表达式
- en: When LINQ was added to .NET, it revolutionized the way we access data by providing
    a unified syntax for querying data from disparate data sources. Upon LINQ’s introduction,
    C# and Visual Basic were extended to include the *query syntax*, a SQL-like syntax
    with context-sensitive keywords that were really syntactic sugar over several
    language features, such as extension methods and lambda expressions. In this regard,
    F# was a little late to the party because, prior to F# 3.0, the only way to use
    LINQ in F# was to directly call the LINQ extension methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当LINQ被添加到.NET中时，它彻底改变了我们访问数据的方式，通过提供统一的语法来查询来自不同数据源的数据。在LINQ引入后，C#和Visual Basic被扩展，加入了*查询语法*，这是一种类似SQL的语法，包含上下文敏感的关键字，实际上是对多个语言特性（如扩展方法和lambda表达式）的语法糖。从这个角度来看，F#有些姗姗来迟，因为在F#
    3.0之前，使用LINQ的唯一方式是直接调用LINQ扩展方法。
- en: 'Despite their foundations in functional programming, using the LINQ methods
    directly has a highly object-oriented feel due to their fluent interface; sequences
    are passed to methods that return new sequences and the methods are typically
    chained with dot notation. Consider the following query, which uses the LINQ extension
    methods directly against an F# list to filter out odd numbers, and then sorts
    the results in descending order (remember to open the `System.Linq` namespace):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们基于函数式编程，但直接使用LINQ方法由于其流畅接口，具有非常强的面向对象特征；序列被传递给方法，这些方法返回新的序列，且方法通常通过点符号进行链式调用。考虑以下查询，它直接对F#列表使用LINQ扩展方法，筛选出奇数，并按降序对结果进行排序（记得打开`System.Linq`命名空间）：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, chaining the method calls in this manner is much more object-oriented
    than functional. *Query expressions*, introduced with F# 3.0, changed that by
    providing a convenient SQL-like syntax that resembles the query syntax from C#
    and Visual Basic. They really are LINQ for F#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，以这种方式链式调用方法比函数式编程更具面向对象的特性。*查询表达式*，在F# 3.0中引入，通过提供类似SQL的语法，改变了这一点，这种语法类似于C#和Visual
    Basic中的查询语法。它们实际上就是F#的LINQ。
- en: 'Query expressions take the form of `query { ... }`. Inside the braces we identify
    a series of operations we want to apply to a sequence, thereby forming a query.
    For instance, we could rewrite the previous query as a query expression like this
    (explicitly opening `System.Linq` isn’t required for query expressions):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式的形式是`query { ... }`。在花括号内，我们可以识别一系列我们希望应用于序列的操作，从而形成一个查询。例如，我们可以将之前的查询重写为这样的查询表达式（对于查询表达式，不需要显式地打开`System.Linq`）：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, filtering and sorting the list looks and feels more functional. Instead
    of chaining method calls directly, we’re expressing the query in a more idiomatic
    manner that uses expression composition and function calls. Because query expressions
    are a wrapper around the LINQ technologies, you can use them with any sequence.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，过滤和排序列表看起来和感觉上更具函数式编程的特点。我们不再直接链式调用方法，而是以更惯用的方式表达查询，使用表达式组合和函数调用。由于查询表达式是LINQ技术的包装器，因此你可以在任何序列上使用它们。
- en: Given this simple example, one could argue that the `Seq` and `List` module
    functions could be used to similar effect, and in many cases, that’s true. For
    instance, we could easily replace the `where` operator with a call to `Seq.filter`.
    Likewise, we can often sort using `Seq.sortBy` instead of the `sortBy` operator.
    What’s not immediately apparent is that by being built upon LINQ, query expressions
    can offer additional optimizations, such as generating a `WHERE` clause in a SQL
    query to prevent retrieving a large data set from a database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个简单的例子，有人可能会认为`Seq`和`List`模块函数可以达到类似的效果，在许多情况下，确实如此。例如，我们可以轻松地将`where`运算符替换为`Seq.filter`函数的调用。同样，我们也可以常常使用`Seq.sortBy`来代替`sortBy`运算符。一个不那么显而易见的事实是，由于查询表达式是建立在LINQ之上的，它们可以提供额外的优化，比如在SQL查询中生成`WHERE`子句，以防止从数据库中检索大量数据集。
- en: In the interest of simplicity, unless otherwise noted, each query expression
    example in this chapter will use the types and collections defined in the following
    `QuerySource` module.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，除非另有说明，本章中的每个查询表达式示例将使用以下`QuerySource`模块中定义的类型和集合。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There’s nothing particularly interesting about the `QuerySource` module, but
    the types and collections defined here sufficiently represent a basic data model
    we can query in a variety of ways. The `film` and `actor` types also include overrides
    of `ToString` to simplify the query output.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuerySource`模块本身并没有特别有趣的地方，但这里定义的类型和集合足以代表我们可以以多种方式查询的基本数据模型。`film`和`actor`类型还包括了`ToString`的重写，以简化查询输出。'
- en: Basic Querying
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本查询
- en: In their most basic form, query expressions consist of an enumerable `for` loop
    and a projection. The enumerable `for` loop defines a name for items in a source
    sequence. The projection identifies the data that will be returned by the query.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，查询表达式由一个可枚举的`for`循环和一个投影组成。可枚举的`for`循环为源序列中的项定义一个名称。投影标识查询返回的数据。
- en: 'One of the most common projection operators is `select`, which equates to LINQ’s
    `Select` method and defines the structure of each item in the resulting sequence
    (much like `Seq.map`). At their most basic, `select` operations simply project
    each data item directly, like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的投影操作符之一是`select`，它等同于LINQ的`Select`方法，并定义结果序列中每个项的结构（类似于`Seq.map`）。最基本的情况下，`select`操作只是直接投影每个数据项，像这样：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'which results in:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`select` operations aren’t limited to projecting only the source data item;
    they can also transform the source sequence to project more complex types like
    tuples, records, or classes. For instance, to project a tuple containing the film’s
    name and its release year, you could write:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`操作不仅限于仅投影源数据项；它们还可以转换源序列，投影更复杂的类型，如元组、记录或类。例如，要投影一个包含电影名称及其上映年份的元组，可以这样写：'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'which gives:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In these simple examples, we’ve explicitly included a `select` operation to
    transform the source sequence. As query complexity grows, projecting the raw,
    nontransformed data items is often implied, so the `select` operation can often
    be safely omitted. In the interest of space, I’ll generally project results with
    `ToString`, but I encourage you to experiment with different projections to familiarize
    yourself with the query behavior.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些简单的示例中，我们显式地包含了`select`操作来转换源序列。随着查询复杂性的增加，通常隐含地投影原始的、未变换的数据项，因此`select`操作通常可以安全地省略。为了节省空间，我通常会用`ToString`投影结果，但我鼓励你尝试不同的投影方式，以熟悉查询行为。
- en: Filtering Data
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据过滤
- en: 'Queries often involve specifying some criteria to filter out unwanted data.
    There are two primary approaches to filtering with query expressions: predicate-based
    filters and distinct item filters.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查询通常涉及指定某些条件来筛选掉不需要的数据。过滤数据有两种主要方法：基于谓词的过滤器和不同项过滤器。
- en: Predicate-Based Filters
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于谓词的过滤器
- en: '*Predicate-based filters* allow you to filter data by specifying the criteria
    that each item in the source sequence must satisfy in order to be included in
    the projected sequence. To create a predicate-based filter, simply include F#’s
    equivalent of LINQ’s `Where` method, the `where` operator, followed by a Boolean
    expression (often called a *predicate*) in your query. (Note that parentheses
    are typically required around the expression.) For example, to select only the
    films released in 1984, you could write this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于谓词的过滤器*允许你通过指定每个源序列项必须满足的条件来过滤数据，从而将其包含在投影序列中。要创建一个基于谓词的过滤器，只需在查询中包含F#等效于LINQ的`Where`方法——`where`操作符，后跟一个布尔表达式（通常称为*谓词*）。(注意，表达式通常需要加上括号。)例如，要仅选择1984年上映的电影，可以写成这样：'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'to get:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 获取：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When composing predicate-based filters, you must be aware of the source sequence’s
    underlying type. For the simple examples you’ve seen so far it hasn’t been an
    issue, but in many cases, particularly when you are working with `IQueryable<'T>`
    instances, you might have to deal with null values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写基于谓词的过滤器时，必须注意源序列的底层类型。对于到目前为止看到的简单示例，这并不是问题，但在许多情况下，特别是当你处理`IQueryable<'T>`实例时，可能需要处理空值。
- en: 'Null values can pose a problem in query expressions because the standard comparison
    operators don’t handle them. For example, if you were to query for all films that
    grossed no more than $40 million using the standard equality operator like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 空值可能在查询表达式中造成问题，因为标准比较操作符无法处理它们。例如，如果你使用标准的等于操作符查询所有总票房不超过 4000 万美元的电影，像这样：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'you’d receive the following error because `gross` is defined as `Nullable<float>`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会收到以下错误，因为 `gross` 被定义为 `Nullable<float>`：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To work around this limitation, you need to use the nullable operators defined
    in the `Microsoft.FSharp.Linq.NullableOperators` module. These operators look
    like the standard operators except that they begin with a question mark (`?`)
    when the left operand is `Nullable<_>`, end with a question mark when the right
    operand is `Nullable<_>`, or are surrounded by question marks when both operands
    are `Nullable<_>`. [Table 10-1](ch10.html#nullable_operators "Table 10-1. Nullable
    Operators") lists each of the nullable operators.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个限制，你需要使用 `Microsoft.FSharp.Linq.NullableOperators` 模块中定义的可空操作符。这些操作符与标准操作符类似，只不过当左操作数是
    `Nullable<_>` 时，它们以问号 (`?`) 开头；当右操作数是 `Nullable<_>` 时，它们以问号结尾；或者当两个操作数都是 `Nullable<_>`
    时，它们被问号包围。[表 10-1](ch10.html#nullable_operators "表 10-1. 可空操作符") 列出了每个可空操作符。
- en: Table 10-1. Nullable Operators
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1. 可空操作符
- en: '| Operator | Left Side Nullable | Right Side Nullable | Both Sides Nullable
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 左侧可空 | 右侧可空 | 双侧可空 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Equality | `?=` | `=?` | `?=?` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 等于 | `?=` | `=?` | `?=?` |'
- en: '| Inequality | `?<>` | `<>?` | `?<>?` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 不等式 | `?<>` | `<>?` | `?<>?` |'
- en: '| Greater than | `?>` | `>?` | `?>?` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | `?>` | `>?` | `?>?` |'
- en: '| Greater than or equal | `?>=` | `>=?` | `?>=?` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 大于或等于 | `?>=` | `>=?` | `?>=?` |'
- en: '| Less than | `?<` | `<?` | `?<?` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | `?<` | `<?` | `?<?` |'
- en: '| Less than or equal | `?<=` | `<=?` | `?<=?` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 小于或等于 | `?<=` | `<=?` | `?<=?` |'
- en: '| Addition | `?+` | `+?` | `?+?` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `?+` | `+?` | `?+?` |'
- en: '| Subtraction | `?-` | `-?` | `?-?` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | `?-` | `-?` | `?-?` |'
- en: '| Multiplication | `?*` | `*?` | `?*?` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `?*` | `*?` | `?*?` |'
- en: '| Division | `?/` | `/?` | `?/?` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | `?/` | `/?` | `?/?` |'
- en: '| Modulus | `?%` | `%?` | `?%?` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 取模 | `?%` | `%?` | `?%?` |'
- en: 'Now we can rewrite the previous query using the appropriate nullable operator
    like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用适当的可空操作符重写之前的查询，像这样：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'to get:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 获取：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the query resulted in two matches despite the underlying sequence
    containing some null values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，尽管底层序列包含一些空值，查询仍然返回了两个匹配项。
- en: 'It’s possible to chain multiple predicates together with Boolean operators.
    For instance, to get only the films released in 1987 that grossed no more than
    $40 million, you could write:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用布尔操作符将多个谓词连接在一起。例如，为了只获取 1987 年发布且总票房不超过 4000 万美元的电影，你可以这样写：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'which gives:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 得到：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Distinct-Item Filters
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不同项筛选器
- en: Query expressions can produce a sequence containing only the distinct values
    from the underlying sequence by filtering out duplicates. To achieve this, you
    need only include the `distinct` operator in your query.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式可以通过筛选重复项，仅生成底层序列中独特值的序列。为了实现这一点，你只需要在查询中包含 `distinct` 操作符。
- en: 'The `distinct` operator corresponds to LINQ’s `Distinct` method, but unlike
    in C# or VB, query expressions allow you to include it directly within the query
    rather than as a separate method call. For example, to query for distinct release
    years, you could write this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct` 操作符对应于 LINQ 的 `Distinct` 方法，但与 C# 或 VB 不同，查询表达式允许你直接在查询中包含它，而不是作为单独的方法调用。例如，要查询不同的发行年份，你可以写：'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we’ve projected the distinct release years to a new sequence:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将不同的发行年份投影到一个新的序列中：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Accessing Individual Items
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问单个项目
- en: It’s quite common for a sequence to contain multiple items when you really care
    about only one in particular. Query expressions include several operators for
    accessing the first item, the last item, or arbitrary items from a sequence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个序列中包含多个项目是很常见的，但你实际上只关心其中的一个项目。查询表达式包括多个操作符，用于访问序列中的第一个项目、最后一个项目或任意项目。
- en: Getting the First or Last Item
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取第一个或最后一个项目
- en: To get the first item from a sequence, you can use the `head` or `headOrDefault`
    operators. These operators respectively correspond to the parameterless overloads
    of the `First` and `FirstOrDefault` LINQ methods but use the more functional nomenclature
    of “head” to identify the first item (just like with F# lists). The difference
    between `head` and `headOrDefault` is that `head` raises an exception when the
    source sequence is empty, whereas `headOrDefault` returns `Unchecked.defaultof<_>`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要从序列中获取第一个项目，可以使用`head`或`headOrDefault`操作符。这些操作符分别对应于LINQ中`First`和`FirstOrDefault`方法的无参重载，但使用更具函数式编程风格的“head”来标识第一个项目（就像在F#列表中一样）。`head`和`headOrDefault`的区别在于，`head`在源序列为空时会抛出异常，而`headOrDefault`则返回`Unchecked.defaultof<_>`。
- en: 'To get the first item from a sequence, simply project a sequence to one of
    the head operators like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要从序列中获取第一个项目，只需像这样将序列投影到其中一个头操作符：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, the result is:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果是：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similarly, you can get the last item in a sequence using either the `last` or
    `lastOrDefault` operators. These operators behave the same way as their head counterparts
    in that `last` raises an exception when the sequence is empty, whereas `lastOrDefault`
    does not. Depending on the underlying sequence type, getting the last item may
    require enumerating the entire sequence, so exercise some care because the operation
    could be expensive or time consuming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以使用`last`或`lastOrDefault`操作符获取序列中的最后一个项目。这些操作符的行为与它们的头操作符相同，`last`在序列为空时会抛出异常，而`lastOrDefault`则不会。根据底层序列类型，获取最后一个项目可能需要遍历整个序列，因此要小心，因为该操作可能会很昂贵或耗时。
- en: Getting an Arbitrary Item
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取任意项目
- en: 'When you want to get a specific item by its index you can use the `nth` operator,
    which is equivalent to LINQ’s `ElementAt` method. For instance, to get the third
    element from the `films` sequence, you could structure a query like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想通过索引获取特定项目时，可以使用`nth`操作符，它相当于LINQ中的`ElementAt`方法。例如，要从`films`序列中获取第三个元素，你可以这样构造查询：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the result is:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果是：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although the `nth` operator is useful when you already know the index, it’s
    more common to want the first item that matches some criteria. In those cases,
    you’ll want to use the `find` operator instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`nth`操作符在你已经知道索引的情况下非常有用，但更常见的是想要获取第一个符合某些条件的项目。在这些情况下，你会希望使用`find`操作符。
- en: 'The `find` operator is equivalent to calling LINQ’s `First` method with a predicate.
    It is also similar to the `where` operator except that it returns only a single
    item instead of a new sequence. For example, to get the first film listed for
    1987, you could write:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`操作符相当于调用LINQ的`First`方法并传入一个谓词。它也类似于`where`操作符，不同之处在于，它只返回单一的项目，而不是返回一个新的序列。例如，要获取1987年列出的第一部电影，你可以这样写：'
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Executing this query will give you:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此查询将给你：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `find` operator is useful for locating the first item that matches some
    criteria, but it doesn’t guarantee that the first match is the only match. When
    you want to return a single value but also need to be certain that a query result
    contains one and only one item (such as when you are finding an item by a key
    value), you can use the `exactlyOne` operator, which corresponds to the parameterless
    overload of LINQ’s `Single` method. For example, to get a film by its `id` while
    enforcing uniqueness, you could write:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`操作符对于查找第一个符合某些条件的项目非常有用，但它不能保证第一个匹配项是唯一匹配项。当你想返回一个单一的值，但又需要确保查询结果只包含一个项目（例如，当你通过键值查找项目时），你可以使用`exactlyOne`操作符，它对应于LINQ中`Single`方法的无参重载。例如，要根据`id`获取一部电影并确保唯一性，你可以这样写：'
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, the query yields:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，查询返回：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the source sequence doesn’t contain exactly one item, the `exactlyOne`
    operator raises an exception. Should you want a default value when the source
    sequence is empty, you can use the `exactlyOneOrDefault` operator instead. Be
    warned, though, that if the source sequence includes more than one item, `exactlyOneOrDefault`
    will still raise an exception.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当源序列不包含正好一个项目时，`exactlyOne`操作符会抛出异常。如果你希望在源序列为空时使用默认值，可以改用`exactlyOneOrDefault`操作符。但请注意，如果源序列包含多个项目，`exactlyOneOrDefault`仍然会抛出异常。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Query expression syntax does not include operators equivalent to the predicate-based
    overload of Single or SingleOrDefault.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询表达式语法不包括等同于基于谓词的`Single`或`SingleOrDefault`重载的操作符。*'
- en: Sorting Results
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序结果
- en: Query expressions make sorting data easy, and, in some ways, they are more flexible
    than the sorting functions in the various collection modules. The sorting operators
    allow you to sort in ascending or descending order on both nullable and non-nullable
    values. You can even sort by multiple values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式使得排序数据变得容易，而且在某些方面，比各种集合模块中的排序函数更加灵活。这些排序操作符允许你对可空值和非可空值进行升序或降序排序，甚至可以按多个值排序。
- en: Sorting in Ascending Order
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按升序排序
- en: Sorting a sequence in ascending order requires either the `sortBy` or `sortByNullable`
    operators. Both of these operators are built upon LINQ’s
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按升序排序一个序列需要使用`sortBy`或`sortByNullable`操作符。这两个操作符都基于LINQ的
- en: '`OrderBy` method. Internally, these methods differ only by the generic constraints
    applied to their arguments. As their names imply, the `sortBy` operator is used
    with non-nullable values, whereas `sortByNullable` is used with `Nullable<_>`
    values.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderBy`方法。内部而言，这些方法的差异仅在于对其参数应用的泛型约束。正如它们的名字所暗示的那样，`sortBy`操作符用于非可空值，而`sortByNullable`用于`Nullable<_>`值。'
- en: 'With both of these operators, you need to specify the value on which to sort.
    For example, to sort the films by name, you could write:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个操作符时，你需要指定排序的值。例如，要按名称排序电影，你可以这样写：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This returns the following sequence:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下序列：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Sorting in Descending Order
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 降序排序
- en: To sort a sequence in descending order, you use either the `sortByDescending`
    or `sortByNullableDescending` operators. These operators are based on LINQ’s `OrderByDescending`
    method and, like their ascending counterparts, internally differ only by the generic
    constraints applied to their parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要按降序排序一个序列，你可以使用`sortByDescending`或`sortByNullableDescending`操作符。这些操作符基于LINQ的`OrderByDescending`方法，和它们的升序对应物一样，内部的区别仅在于对其参数应用的泛型约束。
- en: 'To sort the `films` sequence in descending order by name, you could write:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要按名称降序排序`films`序列，你可以这样写：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'which returns:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sorting by Multiple Values
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按多个值排序
- en: To sort on multiple values, first sort with one of the `sortBy` or `sortByDescending`
    operators and then supply subsequent sort values with one of the `thenBy` operators.
    As with the primary sort operators, there are variations of `thenBy` that allow
    you to sort in ascending or descending order using both nullable and non-nullable
    values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要按多个值排序，首先使用`sortBy`或`sortByDescending`操作符进行排序，然后用其中一个`thenBy`操作符提供后续排序值。和主要的排序操作符一样，`thenBy`也有变体，允许你在使用可空值和非可空值时进行升序或降序排序。
- en: 'The four `thenBy` variations, which can appear only after one of the `sortBy`
    variations, are:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 四个`thenBy`变体只能在某个`sortBy`变体之后出现，它们是：
- en: '`thenBy`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenBy`'
- en: '`thenByNullable`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenByNullable`'
- en: '`thenByDescending`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenByDescending`'
- en: '`thenByNullableDescending`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenByNullableDescending`'
- en: 'These operators are based upon LINQ’s `ThenBy` and `ThenByDescending` methods.
    To see these in action, let’s sort the `films` sequence by `releaseYear` and then
    in descending order by `gross`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符基于LINQ的`ThenBy`和`ThenByDescending`方法。要查看它们的实际应用，假设我们先按`releaseYear`排序`films`序列，再按`gross`降序排序：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This query results in the following sorted sequence:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询结果如下排序序列：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can chain additional `thenBy` operators to create even more complex sorting
    scenarios.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以链式调用更多`thenBy`操作符，来创建更复杂的排序场景。
- en: Grouping
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组
- en: Another common query operation is grouping. Query expressions provide two operators,
    both based on LINQ’s `GroupBy` method, to do just that. Both operators produce
    an intermediate sequence of `IGrouping<_,_>` instances that you refer to later
    in your query.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的查询操作是分组。查询表达式提供了两个操作符，均基于LINQ的`GroupBy`方法，用于执行此操作。两个操作符都会生成一个中间序列，该序列包含`IGrouping<_,_>`实例，你可以在查询的后续部分引用它。
- en: 'The first operator, `groupBy`, lets you specify the key value by which the
    items in the source sequence will be grouped. Each `IGrouping<_,_>` produced by
    `groupBy` includes the key value and a child sequence containing any items from
    the source sequence that matches the key. For example, to group the films by release
    year, you could write:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作符`groupBy`允许你指定一个键值，按照该键值对源序列中的项目进行分组。每个由`groupBy`生成的`IGrouping<_,_>`都包含键值和一个子序列，该子序列包含所有与键匹配的源序列中的项目。例如，要按上映年份分组电影，你可以这样写：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This query produces the result (formatted and abbreviated for readability):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询生成的结果（为易读性起见，已格式化并简化）：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It isn’t always necessary to include the full source item in the resulting
    `IGrouping<_,_>` like the `groupBy` operator does. Instead, you can use the `groupValBy`
    operator to specify what to include, be it a single value from the source or some
    other transformation. Unlike the other operators we’ve seen so far, `groupValBy`
    takes two arguments: the value to include in the result, and the key value.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是需要像`groupBy`运算符那样在结果的`IGrouping<_,_>`中包含完整的源项。相反，您可以使用`groupValBy`运算符来指定要包含的内容，无论是源中的单个值还是其他转换。与我们迄今为止看到的其他运算符不同，`groupValBy`接受两个参数：要包含在结果中的值和键值。
- en: 'To demonstrate the `groupValBy` operator, let’s group the films by `releaseYear`
    again, but this time we’ll include a tuple of the film `name` and its `gross`
    earnings:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`groupValBy`运算符，让我们再次按`releaseYear`对电影进行分组，但这次我们将包含一个包含电影`name`和其`gross`收入的元组：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This gives us:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, instead of the full film instance, the resulting groupings include only
    the data we explicitly requested.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果分组中只包含我们显式请求的数据，而不是完整的电影实例。
- en: Paginating
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分页
- en: Query expressions allow you to easily paginate a sequence. Think about your
    typical search results page, where items are partitioned into some number of items
    (say, 10) per page. Rather than having to manage placeholders that identify which
    partition a user should see, you can use query expressions, which provide the
    `skip`, `skipWhile`, `take`, and `takeWhile` operators to help you get to the
    correct partition in the query itself. Each of these operators shares its name
    with its underlying LINQ method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式允许您轻松地对序列进行分页。想象一下典型的搜索结果页面，其中项目按每页若干个（例如，10个）进行分割。与其管理标识用户应该查看哪个分区的占位符，您可以使用查询表达式，它提供了`skip`、`skipWhile`、`take`和`takeWhile`运算符，帮助您直接在查询中获取正确的分区。这些运算符中的每一个都与其底层的LINQ方法同名。
- en: 'The `skip` and `take` operators both accept an integer indicating how many
    items to bypass or include, respectively. For example, you could compose a function
    to get a particular page, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`和`take`运算符都接受一个整数，表示要跳过或包含的项目数。例如，您可以编写一个函数来获取特定的页面，像这样：'
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, getting a particular page is only a matter of invoking the `getFilmPage`
    function. For instance, to get the first page of three items, you would write:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取特定页面只需调用`getFilmPage`函数。例如，要获取包含三项的第一页，您可以这样写：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'which yields:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Likewise, you would get the second result page as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以通过以下方式获取第二页结果：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'which gives us:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It’s okay to specify more items than are present in the sequence. If the end
    of the sequence is reached, the `skip` and `take` operators return what has been
    selected so far and no exceptions are thrown.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 指定比序列中实际存在更多的项目是可以的。如果到达序列的末尾，`skip`和`take`运算符会返回到目前为止已选择的项目，并且不会抛出任何异常。
- en: 'The `skipWhile` and `takeWhile` operators are very similar to `skip` and `take`
    except that instead of working against a known number of items, they skip or take
    items as long as a condition is met. This is useful for paging over a variable
    number of items according to some criteria. For example, the following function
    returns the films released in a given year:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipWhile`和`takeWhile`运算符与`skip`和`take`非常相似，不同之处在于它们不是针对已知数量的项目进行操作，而是根据条件跳过或选择项目。这对于根据某些标准分页处理可变数量的项目非常有用。例如，以下函数返回给定年份上映的电影：'
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Invoking this function with a year will generate a sequence containing zero
    or more items. For instance, invoking it with 1984 returns:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数并传入一个年份将生成一个包含零个或多个项目的序列。例如，调用它并传入1984将返回：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: whereas invoking it with 1986 returns no items because the source sequence doesn’t
    include any films released in 1986.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 而调用1986时将返回空项，因为源序列中没有1986年上映的电影。
- en: If you’re wondering whether this simple example of paging by `releaseYear` could
    be simplified with a single `where` operator, it can. This example simply demonstrates
    `takeWhile`’s effect. `where` and `takeWhile` serve similar purposes, but distinguishing
    between them is important, particularly for more complex predicates. The difference
    between the two operators is that `takeWhile` stops looking as soon as it finds
    something that doesn’t match, but `where` does not.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道是否可以通过单个`where`运算符简化这个按`releaseYear`分页的简单示例，答案是可以。这个示例只是展示了`takeWhile`的效果。`where`和`takeWhile`的作用类似，但区分它们非常重要，特别是在面对更复杂的谓词时。两者的区别在于，`takeWhile`在找到不匹配的项时会立即停止，而`where`则不会。
- en: Aggregating Data
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据聚合
- en: As often as we need to present or otherwise work with tabular data, sometimes
    what we’re really after is an aggregated view of the data. Aggregations such as
    counting the number of items in a sequence, totaling some values, or finding an
    average are all commonly sought-after values that can be exposed through built-in
    query operators.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常需要展示或以其他方式处理表格数据，有时我们真正需要的是数据的聚合视图。诸如计算序列中项数、求和或寻找平均值等聚合操作，都是常见的需求，可以通过内置的查询操作符来实现。
- en: Counting the items in a sequence is easy; simply project the sequence to the
    `count` operator.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算序列中的项数很简单；只需将序列映射到`count`操作符。
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Evaluating this query tells us that five items are present in the `films` sequence.
    Be warned, though, that counting the items in a sequence can be an expensive operation;
    it typically requires enumerating the entire sequence, which could have a negative
    impact on performance. That said, the `Count` method on which this operator is
    based is smart enough to short-circuit some sequences (like arrays). If you’re
    counting items only to determine whether the sequence contains any data, you should
    instead consider using the `exists` operator, discussed in [Detecting Items](ch10.html#detecting_items
    "Detecting Items").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 评估此查询告诉我们`films`序列中包含五个项。然而，请注意，计算序列中的项数可能是一个昂贵的操作；它通常需要枚举整个序列，这可能会对性能产生负面影响。尽管如此，基于此操作符的`Count`方法足够智能，可以跳过某些序列（如数组）。如果你仅仅是为了判断序列是否包含数据而计算项数，你应该考虑使用`exists`操作符，详见[检测项](ch10.html#detecting_items
    "Detecting Items")。
- en: The remaining aggregation operators allow you to easily perform mathematical
    aggregations against a sequence according to a selector. The operators—`minBy`,
    `maxBy`, `sumBy`, and `averageBy`—allow you to calculate the minimum value, maximum
    value, total, or average for the values, respectively. Internally, the `minBy`
    and `maxBy` operators use LINQ’s `Min` and `Max` methods, respectively, but `sumBy`
    and `averageBy` provide their own implementations and are completely independent
    of LINQ.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的聚合操作符使你可以根据选择器轻松地对序列执行数学聚合。这些操作符——`minBy`、`maxBy`、`sumBy`和`averageBy`——分别允许你计算最小值、最大值、总和或平均值。在内部，`minBy`和`maxBy`操作符分别使用LINQ的`Min`和`Max`方法，但`sumBy`和`averageBy`提供了自己的实现，并且完全独立于LINQ。
- en: Each of these four operators also have nullable counterparts that work against
    nullable values much like the sorting operators introduced in [Sorting Results](ch10.html#sorting_results
    "Sorting Results"). To demonstrate, we’ll query the `films` sequence using the
    nullable forms.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个操作符中的每一个也都有其对应的可空操作符，能够处理可空值，类似于[排序结果](ch10.html#sorting_results "Sorting
    Results")中介绍的排序操作符。为了演示，我们将使用可空形式查询`films`序列。
- en: 'To find the highest grossing film, we could write:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到票房最高的电影，我们可以写：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As expected, running this query returns `59735548.0`. Replacing `maxByNullable`
    with `minByNullable` returns `38122105.0`, and `sumByNullable` returns `136257653.0`.
    The `averageByNullable` operator doesn’t behave quite as you might expect, however.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，运行此查询返回`59735548.0`。将`maxByNullable`替换为`minByNullable`返回`38122105.0`，而`sumByNullable`返回`136257653.0`。然而，`averageByNullable`操作符的行为并不像你可能预期的那样。
- en: Averaging the gross earnings using `averageByNullable` results in `27251530.6`.
    What happens is that although the operator skips null values during the summation
    phase, it divides the sum by the count of items in the sequence regardless of
    how many null items were skipped. This means that the null values are effectively
    treated as zero, which may or may not be desirable. Later in this chapter, we’ll
    look at how to define a new query operator that truly ignores null values when
    calculating an average.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`averageByNullable`计算总收入的平均值为`27251530.6`。发生的情况是，尽管操作符在求和阶段跳过了空值，但它仍然将总和除以序列中的项数，而不管跳过了多少空项。这意味着空值实际上被当作零处理，这可能是可取的，也可能不可取。本章稍后我们将探讨如何定义一个新的查询操作符，在计算平均值时真正忽略空值。
- en: Detecting Items
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测项
- en: Thus far, we’ve explored the many ways you can structure query expressions to
    transform, filter, sort, group, and aggregate sequences. Sometimes, though, you
    don’t really care to obtain specific items from a sequence but rather want to
    inspect a sequence to determine whether it contains data that matches some criterion.
    Instead of returning a new sequence or a specific item, the operators discussed
    in this section return a Boolean value indicating whether the sequence contains
    the desired data. Like the `distinct` operator, these operators are part of the
    query expression itself, which is another feature that distinguishes F#’s query
    expressions from query syntax in C# and Visual Basic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探索了多种方式来构造查询表达式，以便转换、过滤、排序、分组和聚合序列。然而，有时你并不关心从序列中获取特定项，而是希望检查序列是否包含符合某些标准的数据。与返回新序列或特定项不同，本节讨论的运算符返回一个布尔值，指示序列是否包含所需的数据。像`distinct`运算符一样，这些运算符是查询表达式的一部分，这是F#查询表达式与C#和Visual
    Basic查询语法的另一个区别。
- en: 'When you want to see if a known item is contained within a sequence, you use
    the `contains` operator. Built upon LINQ’s `Contains` method, the `contains` operator
    accepts the item you are looking for as its argument. For instance, if we want
    to detect whether *Kindergarten Cop* is present in the `films` collection, we
    could write:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想查看一个已知的项是否包含在一个序列中时，你可以使用`contains`运算符。`contains`运算符基于LINQ的`Contains`方法，接受你要查找的项作为其参数。例如，如果我们想检测*幼儿园警探*是否存在于`films`集合中，可以这样写：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Invoking this query will inform you that *Kindergarten Cop* is not present
    in the collection (much to my relief). As you can see, though, the `contains`
    operator is really suitable only when you already have a reference to an item
    that may already be part of the collection. If you know only part of the value
    you’re looking for, such as the name of the film, you can revise the query to
    project each name and pass the name you’re looking for to `contains`, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此查询会告诉你*幼儿园警探*不在集合中（让我松了口气）。然而，如你所见，`contains`运算符实际上只适用于当你已经有对可能已经是集合一部分的项的引用时。如果你只知道你正在寻找的部分值，例如电影名称，你可以修改查询，投影每个名称并将你要查找的名称传递给`contains`，像这样：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Projecting the values like this, however, isn’t particularly efficient because
    it involves enumerating the entire sequence prior to locating the specified item.
    Instead, you can turn to another operator, `exists`, which is based on LINQ’s
    `Any` method. The `exists` operator is like `where` except that it stops enumerating
    the sequence and returns `true` or `false` as soon as an item that matches its
    predicate is found. For example, the previous query could be expressed with `exists`
    like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像这样投影值并不是特别高效，因为它涉及在找到指定项之前对整个序列进行枚举。相反，你可以使用另一个运算符`exists`，它基于LINQ的`Any`方法。`exists`运算符类似于`where`，只是它在找到符合谓词的项时就停止枚举序列，并返回`true`或`false`。例如，之前的查询可以用`exists`这样表达：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Of course, the predicate supplied to `exists` doesn’t have to look for a specific
    item. We can easily determine if any films grossed at least $50 million with the
    following query:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，传递给`exists`的谓词不必查找特定项。我们可以很容易地通过以下查询来判断是否有任何电影的票房至少达到5000万美元：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Because *Predator* grossed nearly $60 million, the previous query returns `true`.
    If you want to check whether every item in a sequence satisfies some condition,
    you can use the `all` operator. Based on LINQ’s `All` method, the `all` operator
    enumerates the sequence and returns `true` when each item matches the predicate.
    When an item that doesn’t match the predicate is encountered, enumeration stops
    and `all` returns `false`. For example, to see if every film grossed at least
    $50 million, you could construct a query like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*掠食者*的票房接近6000万美元，所以之前的查询返回`true`。如果你想检查序列中的每个项是否满足某个条件，可以使用`all`运算符。基于LINQ的`All`方法，`all`运算符枚举序列，当每个项都符合谓词时返回`true`。如果遇到一个不符合谓词的项，枚举停止，`all`返回`false`。例如，若要检查每部电影的票房是否至少达到5000万美元，你可以构建如下查询：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In our `films` collection, only one item satisfies the condition; therefore,
    the query returns `false`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`films`集合中，只有一项满足条件，因此查询返回`false`。
- en: Joining Multiple Data Sources
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联接多个数据源
- en: Querying data from a single sequence is useful, but data is often spread across
    multiple sources. Query expressions carry forward LINQ’s join capabilities, which
    allow you to query data from multiple sources within a single expression. Joins
    in query expressions resemble enumerable `for` loops in that they include an iteration
    identifier and the source sequence but begin with the appropriate `join` operator
    and also include join criteria.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个序列查询数据是有用的，但数据通常分布在多个源中。查询表达式继承了LINQ的连接功能，它允许你在单个表达式中查询来自多个源的数据。查询表达式中的连接类似于可枚举的`for`循环，它们包括一个迭代标识符和源序列，但以适当的`join`操作符开始，并且还包括连接条件。
- en: The first type of join, the *inner join*, uses the `join` operator to correlate
    values from one sequence with values in a second sequence. Internally, the `join`
    operator uses LINQ’s `Join` method to work its magic. Once the sequences are joined,
    values from both sequences can be referenced by subsequent operators like `where`
    or `select`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种连接类型，*内连接*，使用`join`操作符将一个序列中的值与第二个序列中的值进行关联。在内部，`join`操作符使用LINQ的`Join`方法来实现其功能。一旦序列连接完成，来自两个序列的值可以通过后续操作符（如`where`或`select`）进行引用。
- en: 'Until now, all of the queries we’ve written have used only the `films` collection.
    Recall that when we created the `QuerySource` module at the beginning of the chapter,
    we also defined two other collections: `actors` and `filmActors`. Together, the
    `films`, `actors`, and `filmActors` collections model a many-to-many relationship
    between `films` and `actors`, with `filmActors` serving as the junction table.
    We can use the `join` operator to bring these three collections together in a
    single query like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们编写的所有查询只使用了`films`集合。回想一下，在我们在本章开始时创建`QuerySource`模块时，我们还定义了另外两个集合：`actors`和`filmActors`。这三个集合（`films`、`actors`和`filmActors`）一起建模了`films`与`actors`之间的多对多关系，其中`filmActors`作为连接表。我们可以使用`join`操作符将这三个集合结合在一个查询中，如下所示：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Joining multiple sequences together merely requires us to include a join expression
    for each sequence and identify the relationship between them through their members
    and an equality operator. Invoking this query results in the following sequence
    (truncated per FSI):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个序列连接在一起，只需要为每个序列包含一个连接表达式，并通过它们的成员及等式操作符确定它们之间的关系。调用这个查询将产生以下序列（根据FSI进行了截断）：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: F# exposes LINQ’s `GroupJoin` function through the `groupJoin` operator. This
    lets you join two sequences, but instead of selecting items that satisfy the join
    criterion individually, you project each item that satisfies the join criterion
    into another sequence you can subsequently reference within your query. You can
    use this intermediate sequence to create a hierarchical data structure that resembles
    the `IGrouping<_,_>` instances created by the `groupBy` operator.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: F#通过`groupJoin`操作符公开了LINQ的`GroupJoin`功能。这允许你连接两个序列，但与选择满足连接条件的单个项不同，它将满足连接条件的每个项投影到另一个可以在查询中后续引用的序列中。你可以使用这个中间序列来创建一个层次化的数据结构，这类似于`groupBy`操作符创建的`IGrouping<_,_>`实例。
- en: 'Consider the following query, which creates a hierarchy where each actor is
    grouped by the films in which he or she appears:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下查询，它创建了一个层次结构，其中每个演员根据他或她出演的电影进行分组：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we use the `groupJoin` operator to create an intermediate sequence named
    `junction`. Inside the projected tuple, we have a nested query where we join `actors`
    to `junction` and project individual actor names. This results in the following
    sequence, which I’ve formatted for readability:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`groupJoin`操作符创建了一个名为`junction`的中间序列。在投影的元组内，我们有一个嵌套查询，在这个查询中，我们将`actors`与`junction`连接并投影出各个演员的名字。这将产生以下序列，我已为可读性格式化：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, the outer query (the `films` part) returns a single sequence
    of tuples. Nested within each item is another sequence containing the actors associated
    with that film. What isn’t apparent from these truncated results is that when
    none of the items in the joined sequence satisfies the join criterion (as is the
    case for *Conan the Destroyer*), the sequence created by the `groupJoin` operation
    is empty.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，外部查询（`films`部分）返回一个包含元组的单一序列。每个项内部都有一个包含与该电影相关的演员的序列。从这些截断的结果中无法看出的是，当连接的序列中的项没有满足连接条件时（例如*毁灭者
    Conan*），`groupJoin`操作创建的序列将为空。
- en: 'If you prefer to flatten the results of a `groupJoin` rather than return them
    as a hierarchy, you can follow the `groupJoin` operation with another enumerable
    `for` loop, using the junction sequence as the loop source. Here, the previous
    query is restructured to return each actor inline with the film:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢将`groupJoin`的结果展平，而不是返回层次结构，你可以在`groupJoin`操作后跟一个可枚举的`for`循环，使用连接序列作为循环源。在这里，之前的查询被重构为将每个演员与电影同行返回：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result of this query is the same as for an inner join, so I won’t repeat
    the output here. In most cases, you’d want to use the `join` operator to forego
    the overhead associated with creating the intermediate junction sequence, but
    there is one place where using a `groupJoin` like this makes sense: left outer
    joins.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的结果与内连接的结果相同，因此我在这里不会重复输出。在大多数情况下，你会希望使用`join`操作符，避免创建中间连接序列的开销，但在某些情况下，使用`groupJoin`这样的操作是有意义的：左外连接。
- en: By default, if no items satisfy the join criterion in a group join, the result
    is an empty sequence. However, if you use the `DefaultIfEmpty` method with the
    resulting sequence, you’ll get a new sequence containing a single item that’s
    the default value for the underlying type. To perform a left outer join in your
    query, you can use the `groupJoin` operator as we did in the previous query but
    include a call to `DefaultIfEmpty` in your enumerable `for` loop—for example,
    `j.DefaultIfEmpty()`. Alternatively, you can use the `leftOuterJoin` operator
    to achieve the same result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果在`groupJoin`中没有任何项满足连接条件，结果是一个空序列。然而，如果你在结果序列上使用`DefaultIfEmpty`方法，你会得到一个新序列，包含一个单一项，该项是基础类型的默认值。为了在查询中执行左外连接，你可以像在之前的查询中一样使用`groupJoin`操作符，但在可枚举的`for`循环中包括对`DefaultIfEmpty`的调用——例如，`j.DefaultIfEmpty()`。或者，你可以使用`leftOuterJoin`操作符来实现相同的结果。
- en: 'Unfortunately, left outer joins are one area where the dissonance between F#
    and the rest of the .NET Framework can cause a lot of misery. But this is really
    a problem only when you’re working with the core F# types. Consider the following
    query:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，左外连接是F#和其他.NET框架之间不一致的一个领域，这可能会导致很多麻烦。但这实际上只有在你使用核心F#类型时才会成为问题。考虑以下查询：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When this query enumerates (via `Seq.iter`), it raises a `NullReferenceException`
    as soon as it tries to join in the actors for *Conan the Barbarian*. Because there
    are no entries for that film in the `filmActors` sequence, the call to `DefaultIfEmpty`
    in the left outer join causes the sole entry in `junction` to be `null`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个查询枚举（通过`Seq.iter`）时，它会抛出`NullReferenceException`，一旦尝试连接*《野蛮人柯南》*的演员信息。因为在`filmActors`序列中没有该电影的条目，所以左外连接中的`DefaultIfEmpty`调用导致`junction`中的唯一条目为`null`。
- en: Wait, what? Null? Isn’t `filmActor` a record type? How can it possibly be `null`
    if `null` isn’t a valid value for record types? The answer lies in the fact that
    by calling into .NET Framework methods we’ve left the confines of the F# sandbox.
    `null` may not be valid for record types in F#, but the Common Language Runtime
    has no notion of a record type; all it knows are value and reference types and,
    from its perspective, a record type is just a reference type. Therefore, `null`
    is a valid value. Unfortunately, because our code is all in F# and the F# compiler
    enforces the value constraints around the record type, we can’t handle the null
    value with pattern matching or `if...then` expressions. We can’t even use the
    `AllowNullLiteral` attribute on the type because the compiler doesn’t allow that
    either.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么？`null`？`filmActor`不是一个记录类型吗？如果`null`对于记录类型来说不是有效值，那它怎么可能是`null`呢？答案在于，通过调用.NET框架的方法，我们已经脱离了F#的沙箱。`null`在F#中对于记录类型可能不是有效的，但公共语言运行时（CLR）并没有记录类型的概念；它只知道值类型和引用类型，从它的角度来看，记录类型只是引用类型。因此，`null`是一个有效值。不幸的是，因为我们的代码完全是在F#中，并且F#编译器强制执行记录类型的值约束，我们无法通过模式匹配或`if...then`表达式来处理`null`值。我们甚至不能使用`AllowNullLiteral`属性，因为编译器也不允许那样做。
- en: 'Working around this issue is a bit of a pain. We can start by splitting the
    query into two parts: one that joins `actors` to `filmActors` and another that
    joins in `films`, like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有点麻烦。我们可以先将查询分成两部分：一部分连接`actors`到`filmActors`，另一部分连接`films`，像这样：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is a good start, but we’ll still get a `NullReferenceException` with the
    Tuple pattern match in the enumerable `for` loop for `junction` because F# doesn’t
    allow `null` for tuples either. There is yet another workaround we can use: an
    upcast to `obj`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的开始，但在枚举类型的`for`循环中，针对`junction`的元组模式匹配仍然会引发`NullReferenceException`，因为F#也不允许元组值为`null`。不过，我们可以使用另一种解决方法：将其强制转换为`obj`类型。
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`null` may not be a valid value for a tuple, but it certainly is for `obj`.
    By explicitly upcasting to `obj`, we can use pattern matching to detect the null
    value and return the appropriate tuple instead of raising the exception.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`可能不是元组的有效值，但对于`obj`却是。通过显式地将其上转换为`obj`，我们可以使用模式匹配来检测`null`值，并返回适当的元组，而不是抛出异常。'
- en: Extending Query Expressions
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展查询表达式
- en: 'As you’ve seen in the previous sections, query expressions provide an easy
    and expressive way to work with data. Query expressions also offer another benefit
    that really sets them apart from query syntax in C# and Visual Basic: They’re
    fully extensible. In this section, I’ll show a few additional operators. We’ll
    start by plugging a hole in the built-in operators by defining operators that
    expose the parameterized overloads of `Single` and `SingleOrDefault`. We’ll then
    move on to a more complex example that allows us to calculate an average by disregarding
    all null values.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的章节中所看到的，查询表达式提供了一种简便且富有表现力的方式来处理数据。查询表达式还提供了一个真正将其与C#和Visual Basic中的查询语法区分开的好处：它们是完全可扩展的。在本节中，我将展示几个额外的运算符。我们将首先通过定义暴露`Single`和`SingleOrDefault`参数化重载的运算符，填补内置运算符的空白。接下来，我们将进入一个更复杂的示例，允许我们在忽略所有`null`值的情况下计算平均值。
- en: 'Example: ExactlyOneWhen'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：ExactlyOneWhen
- en: Recall from [Getting an Arbitrary Item](ch10.html#getting_an_arbitrary_item
    "Getting an Arbitrary Item") that the `exactlyOne` and `exactlyOneOrDefault` operators
    expose the parameterless versions of LINQ’s `Single` and `SingleByDefault` operators,
    but no such operators exist for the overloads that accept a predicate. We can
    easily define our own operators to expose these methods by leveraging the power
    of F# type extensions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[获取任意项](ch10.html#getting_an_arbitrary_item "获取任意项")，`exactlyOne`和`exactlyOneOrDefault`运算符暴露了LINQ的`Single`和`SingleOrDefault`无参数版本，但对于接受谓词的重载版本，并没有类似的运算符。我们可以通过利用F#类型扩展的强大功能，轻松定义我们自己的运算符来暴露这些方法。
- en: To create the custom operators, we need to extend the `QueryBuilder` class found
    within the `Microsoft.FSharp.Linq` namespace. This class defines the methods that
    ultimately serve as the query operators. Fundamentally, the type extension we’ll
    define is no different than any other type extension; we need only to include
    a few attributes so the compiler knows how the functions should behave within
    a query expression.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建自定义运算符，我们需要扩展位于`Microsoft.FSharp.Linq`命名空间中的`QueryBuilder`类。这个类定义了最终作为查询运算符的方法。从根本上讲，我们定义的类型扩展与任何其他类型扩展没有区别；我们只需要包含一些属性，以便编译器知道这些函数在查询表达式中的行为。
- en: 'Here is the code listing in full:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码列表：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This snippet defines two extension methods on the `QueryBuilder` class: `exactlyOneWhen`
    and `exactlyOneOrDefaultWhen`. Because these are so similar, we’ll just focus
    on the `exactlyOneWhen` operator. The first item of interest is the `CustomOperation`
    attribute ① applied to the method itself. This attribute indicates that the method
    should be available within a query expression and the operator name.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段在`QueryBuilder`类上定义了两个扩展方法：`exactlyOneWhen`和`exactlyOneOrDefaultWhen`。由于它们非常相似，我们将重点关注`exactlyOneWhen`运算符。第一个需要关注的项是应用于方法本身的`CustomOperation`属性①。该属性表明该方法应该在查询表达式和运算符名称中可用。
- en: Next, the method’s `this` identifier is two underscore characters ② to be consistent
    with the other operator definitions. The `source` parameter at ③, annotated as
    `QuerySource<'T, 'Q>`, identifies the sequence the operator will work against.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，方法的`this`标识符是两个下划线字符②，以保持与其他运算符定义的一致性。位于③处的`source`参数，标注为`QuerySource<'T,
    'Q>`，标识了运算符将作用的序列。
- en: Immediately following `source` is the `selector` parameter ④. This parameter
    is a function that will be applied against every item in `source` to determine
    whether it should be selected. The `ProjectionParameter` attribute applied to
    `selector` instructs the compiler that the function is implied to accept `'T`
    (as inferred from `source`) so that you can write the selector function as if
    you were working directly with an instance; that is, if you’re querying the `films`
    collection and have used `f` as your iteration identifier, you could write `f.id
    = 4`. Without `ProjectionParameter`, you’d have to use the full lambda syntax
    (or a formal function) instead of just the expression.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟在`source`后面的是`selector`参数④。该参数是一个函数，将应用于`source`中的每个项，以确定它是否应该被选中。应用于`selector`的`ProjectionParameter`属性指示编译器该函数被推断为接受`'T`（从`source`推断出来），这样你就可以像直接操作实例一样编写选择器函数；也就是说，如果你正在查询`films`集合，并且使用`f`作为迭代标识符，你可以写`f.id
    = 4`。如果没有`ProjectionParameter`，你就必须使用完整的lambda语法（或正式函数），而不仅仅是这个表达式。
- en: 'With the new operators defined, we can now write queries that use them. For
    instance, to use the `exactlyOneWhen` operator to find a film by `id`, you would
    write:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了新的运算符后，我们现在可以编写使用这些运算符的查询。例如，要使用`exactlyOneWhen`运算符通过`id`查找电影，你可以写：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, with these operators you no longer need to include the `where`
    operator to filter the results before checking that the sequence contains only
    a single item.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用这些运算符后，你不再需要在检查序列是否只包含一个项目之前，先使用`where`运算符来过滤结果。
- en: 'Example: AverageByNotNull'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：AverageByNotNull
- en: 'For a more complex example of a custom operator, let’s provide an alternative
    to the `averageByNullable` operator we used in [Aggregating Data](ch10.html#aggregating_data
    "Aggregating Data") to compute the average gross earnings for our films. The calculation
    resulted in the average being reported as `27251530.6` because the two null values
    were excluded from the sum but the divisor was still five. If you wanted to truly
    ignore the null values and divide the total by three, the `averageByNullable`
    operator wouldn’t help you, but you could define a custom operator like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更复杂的自定义运算符示例，让我们提供一个替代方案，代替在[聚合数据](ch10.html#aggregating_data "Aggregating
    Data")中使用的`averageByNullable`运算符来计算电影的平均总票房。计算结果显示平均值为`27251530.6`，因为两个空值从总和中被排除，但除数仍然是五。如果你希望真正忽略空值并将总和除以三，`averageByNullable`运算符无法帮助你，但你可以定义一个像这样的自定义运算符：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Notice that the `AverageByNotNull` method incorporates many of the same principles
    as `exactlyOneWhen` and `exactlyOneOrDefaultWhen`; that is, they each involve
    the `CustomOperation` and `ProjectionParameter` attributes. Where `AverageByNotNull`
    differs is that it’s defined as inline to ensure that the generic parameters can
    be resolved. Because they’re so similar, I’ve based the signature and generic
    constraints for `AverageByNotNull` largely upon that of the `averageByNullable`
    operator, although I’ve simplified it a bit for demonstration purposes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`AverageByNotNull`方法结合了与`exactlyOneWhen`和`exactlyOneOrDefaultWhen`相同的许多原则；也就是说，它们都涉及`CustomOperation`和`ProjectionParameter`属性。`AverageByNotNull`与其他方法的不同之处在于，它被定义为内联方法，以确保泛型参数能够得到解决。由于它们非常相似，我为`AverageByNotNull`的方法签名和泛型约束基本上基于`averageByNullable`运算符，尽管我稍微简化了它以便演示。
- en: 'Now that we’ve defined the `averageByNotNull` operator, we can include it in
    a query like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`averageByNotNull`运算符，可以像这样将其包含在查询中：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Invoking this query returns `45419217.67`, a stark contrast from `27251530.6`
    as returned by `averageByNullable`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此查询会返回`45419217.67`，与通过`averageByNullable`返回的`27251530.6`形成鲜明对比。
- en: Type Providers
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提供者
- en: Along with query expressions, the other “killer feature” of F# 3.0 is type providers.
    *Type providers* were developed to abstract away creation of the types, properties,
    and methods necessary to work with external data because this process is often
    tedious, error prone, and difficult to maintain.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询表达式，F# 3.0的另一个“杀手级功能”是类型提供者。*类型提供者*的开发目的是抽象化外部数据工作所需的类型、属性和方法的创建过程，因为这个过程通常既繁琐、容易出错，又难以维护。
- en: Many type providers can be likened to traditional object-relational mapping
    (ORM) tools like NHibernate or Entity Framework, although their scope is potentially
    much greater. ORM tools typically require a great deal of configuration to be
    used effectively. Although there are tools that simplify this process for many
    of the more popular ORM technologies, they still require plenty of maintenance.
    ORM-like type providers aim to remove this overhead by automating type generation
    as part of the compilation process.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型提供者可以类比为传统的对象关系映射（ORM）工具，如 NHibernate 或 Entity Framework，尽管它们的范围可能更广。ORM
    工具通常需要大量的配置才能有效使用。尽管有一些工具简化了许多流行 ORM 技术的配置过程，但它们仍然需要大量的维护。类 ORM 的类型提供者旨在通过将类型生成作为编译过程的一部分来消除这种开销。
- en: The other primary use for type providers is to simplify otherwise complex interfaces.
    Consider how cumbersome and error-prone something like matching strings with regular
    expressions can be. Regular expression syntax is confusing enough on its own,
    but getting named captures from the match collection requires using string keys
    to identify the values you’re trying to access. A regular expression type provider
    can simplify the interface by generating types that correspond to the named captures
    in the regular expression.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者的另一个主要用途是简化其他复杂的接口。考虑一下像使用正则表达式匹配字符串这样的繁琐且容易出错的操作。正则表达式的语法本身就足够令人困惑，但从匹配集合中获取命名捕获还需要使用字符串键来识别你要访问的值。正则表达式类型提供者可以通过生成与正则表达式中的命名捕获对应的类型来简化接口。
- en: 'Regardless of which need type providers satisfy, they all offer three primary
    benefits:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 无论提供者满足哪种需求类型，它们都提供三种主要的好处：
- en: Making data-centric exploratory programming more accessible by eliminating the
    need to manually create mappings and type definitions
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消除手动创建映射和类型定义的需求，使数据中心的探索性编程更易于访问
- en: Eliminating the administrative burden of manually maintaining mappings or other
    type definitions
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除手动维护映射或其他类型定义的行政负担
- en: Reducing the likelihood of errors caused by undetected changes to the underlying
    data structure
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低因未检测到底层数据结构变化而引起错误的可能性
- en: A full discussion of type providers goes well beyond the scope of this book.
    Instead, this section is intended to introduce many of the type providers that
    are available to you either as part of the core F# distribution or through some
    popular third-party libraries. After you’ve seen what’s available, we’ll discuss
    how to initialize and use a few type providers to easily get the data you care
    about.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者的详细讨论超出了本书的范围。本节旨在介绍许多可以使用的类型提供者，这些提供者要么是 F# 核心分发的一部分，要么是通过一些流行的第三方库提供的。在你了解了可用的类型提供者后，我们将讨论如何初始化和使用一些类型提供者，轻松获取你关心的数据。
- en: Available Type Providers
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用的类型提供者
- en: F# 3.0 includes several type providers out of the box. [Table 10-2](ch10.html#built-in_type_providers
    "Table 10-2. Built-in Type Providers") lists the built-in providers and a brief
    description of each.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: F# 3.0 默认包含多个类型提供者。[表 10-2](ch10.html#built-in_type_providers "表 10-2. 内置类型提供者")
    列出了内置提供者及其简要描述。
- en: Table 10-2. Built-in Type Providers
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-2. 内置类型提供者
- en: '| Provider | Description |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 提供者 | 描述 |'
- en: '| --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DbmlFile` | Provides the types that correspond to a SQL Server database
    as described in a Database Markup Language file (*.dbml*) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `DbmlFile` | 提供与数据库标记语言文件（*.dbml*）描述的 SQL Server 数据库对应的类型 |'
- en: '| `EdmxFile` | Provides the types that correspond to a database as described
    by a LINQ-to-Entities mapping file (*.edmx*) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `EdmxFile` | 提供与 LINQ-to-Entities 映射文件（*.edmx*）描述的数据库对应的类型 |'
- en: '| `ODataService` | Provides the types that correspond to those returned by
    an OData service |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `ODataService` | 提供与 OData 服务返回的类型对应的类型 |'
- en: '| `SqlDataProvider` | Provides the types that correspond to a SQL Server database
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `SqlDataProvider` | 提供与 SQL Server 数据库对应的类型 |'
- en: '| `SqlEntityProvider` | Provides the types that correspond to a database according
    to a LINQ-to-Entities mapping |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `SqlEntityProvider` | 提供与通过 LINQ-to-Entities 映射对应的数据库类型 |'
- en: '| `WsdlService` | Provides the types that correspond to those returned by a
    WSDL-based web service |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `WsdlService` | 提供与 WSDL 基础的 Web 服务返回的类型对应的类型 |'
- en: The list of built-in type providers is pretty sparse and is focused on database
    or database-like sources. Even so, what’s provided covers a fairly large number
    of use cases. Should your data fall outside of the cases covered by the built-in
    types, you can define custom type providers, but doing so is outside the scope
    of this book.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的类型提供程序列表非常简单，主要集中在数据库或类似数据库的数据源上。即便如此，提供的内容覆盖了相当多的用例。如果你的数据超出了内置类型所覆盖的范围，你可以定义自定义的类型提供程序，但这超出了本书的讨论范围。
- en: 'Before you start down the path of building your own type providers, you should
    see if there are any third-party providers that will meet your needs. At the time
    of this writing, several popular libraries include a number of useful type providers,
    most notably: `FSharpx` and `FSharp.Data`. [Table 10-3](ch10.html#some_available_third-party_type_provider
    "Table 10-3. Some Available Third-Party Type Providers") lists several of the
    type providers in each library to give you an idea of what’s readily available
    and the diversity of uses for type providers. This list is not meant to be exhaustive;
    there are definitely other libraries available.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始构建自己的类型提供程序之前，应该先看看是否有第三方提供程序可以满足你的需求。在撰写本文时，几个流行的库包含了许多有用的类型提供程序，最著名的包括：`FSharpx`和`FSharp.Data`。[表10-3](ch10.html#some_available_third-party_type_provider
    "表10-3. 一些可用的第三方类型提供程序")列出了每个库中的几个类型提供程序，让你了解哪些类型提供程序是现成的，以及它们在不同场景中的应用。这个列表并不详尽无遗；肯定还有其他可用的库。
- en: Table 10-3. Some Available Third-Party Type Providers
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-3. 一些可用的第三方类型提供程序
- en: '| Provider | Description | FSharpx | FSharp.Data |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 提供程序 | 描述 | FSharpx | FSharp.Data |'
- en: '| --- | --- | --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `AppSettingsProvider` | Provides types that correspond to the nodes in the
    AppSettings section of a configuration file | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `AppSettingsProvider` | 提供与配置文件中AppSettings部分的节点对应的类型 | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
- en: '| `CsvProvider` | Provides types that allow for easy parsing of comma-separated
    value (CSV) files |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `CsvProvider` | 提供可以轻松解析逗号分隔值（CSV）文件的类型 |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
- en: '| `ExcelProvider` | Provides the types necessary for working with an Excel
    workbook | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg) |   |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `ExcelProvider` | 提供与Excel工作簿交互所需的类型 | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
- en: '| `FileSystemProvider` | Provides the types necessary for working with the
    filesystem | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg) |   |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `FileSystemProvider` | 提供与文件系统交互所需的类型 | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
- en: '| `JsonProvider` | Provides types that represent a JavaScript Object Notation
    (JSON) document |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `JsonProvider` | 提供表示JavaScript对象表示法（JSON）文档的类型 |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
- en: '| `RegexProvider` | Provides types that allow for inspecting regular expression
    matches | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg) |   |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `RegexProvider` | 提供可以检查正则表达式匹配的类型 | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
- en: '| `XamlProvider` | Provides types that allow for easy XAML parsing | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `XamlProvider` | 提供可以轻松解析XAML的类型 | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
- en: '| `XmlProvider` | Provides types that represent an XML document |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `XmlProvider` | 提供表示XML文档的类型 |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
- en: Using Type Providers
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型提供程序
- en: 'Regardless of which type provider you need, initializing one always follows
    the same basic pattern:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你需要哪种类型的提供程序，初始化时始终遵循相同的基本模式：
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding syntax, *name* is the name by which you’ll access the provider’s
    capabilities, *providerName* identifies the provider type itself, and *parameters*
    are the provider-specific arguments that control the provider’s behavior. Parameters
    will typically include things like a connection string or the path to the data
    source, but ultimately each type provider is responsible for defining the parameters
    it accepts.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语法中，*name* 是你用来访问提供程序功能的名称，*providerName* 标识提供程序类型本身，*parameters* 是控制提供程序行为的特定参数。参数通常包括连接字符串或数据源路径等内容，但最终每个类型提供程序都负责定义它所接受的参数。
- en: The first time a provider is used within Visual Studio, you’ll be presented
    with a security dialog like the one pictured in [Figure 10-1](ch10.html#type_provider_security_dialog
    "Figure 10-1. Type Provider Security dialog").
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中第一次使用提供程序时，您将看到一个安全对话框，如[图10-1](ch10.html#type_provider_security_dialog
    "图10-1. 类型提供程序安全对话框")所示：
- en: '![Type Provider Security dialog](httpatomoreillycomsourcenostarchimages1981224.png.jpg)Figure 10-1. Type
    Provider Security dialog'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![类型提供程序安全对话框](httpatomoreillycomsourcenostarchimages1981224.png.jpg)图10-1.
    类型提供程序安全对话框'
- en: As the dialog indicates, type providers can connect to remote data sources and
    execute custom code for build and IntelliSense features. Once you’ve enabled or
    disabled a type provider, you won’t be prompted again. If you want to change your
    selection at a later time, you can find a listing of type providers under F# Tools
    in the Visual Studio Options dialog.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如对话框所示，类型提供程序可以连接到远程数据源并执行自定义代码，以实现构建和智能感知功能。一旦启用或禁用了类型提供程序，系统将不再提示您。如果以后想更改选择，您可以在Visual
    Studio选项对话框中的F#工具下找到类型提供程序的列表。
- en: 'Example: Accessing an OData Service'
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：访问OData服务
- en: 'This first example uses the `ODataService` type provider to query the publicly
    available Northwind sample OData service from *[http://www.odata.org/](http://www.odata.org/)*.
    To start, we need to reference two assemblies:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个示例使用`ODataService`类型提供程序从*[http://www.odata.org/](http://www.odata.org/)*查询公开可用的Northwind示例OData服务。首先，我们需要引用两个程序集：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The first assembly includes several Windows Communication Foundation (WCF)
    classes required by the `ODataService` provider. Though we don’t use the WCF types
    directly within this example, failure to add the reference will result in compilation
    errors. The second assembly contains the provider itself. With these assemblies
    referenced, we can now open the namespace that contains the `ODataService` provider:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个程序集包含了`ODataService`提供程序所需的几个Windows通信基础（WCF）类。虽然我们在这个示例中并没有直接使用WCF类型，但如果没有添加引用，会导致编译错误。第二个程序集包含了提供程序本身。添加了这些程序集引用后，我们现在可以打开包含`ODataService`提供程序的命名空间：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we include a type definition that references the appropriate type provider
    along with the address to the Northwind service:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包含一个类型定义，引用了适当的类型提供程序以及指向Northwind服务的地址：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `ODataService` provider takes the supplied address, appends `$metadata`,
    and then proceeds to construct and import the types described by the service.
    In order to do anything with the service, we need to obtain a data context via
    the provider type like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`ODataService`提供程序接受提供的地址，附加`$metadata`，然后构造并导入服务描述的类型。为了与服务进行交互，我们需要通过提供程序类型获取数据上下文，如下所示：'
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: With the data context established, we now have everything we need to query the
    data. Here we’ll use a query expression to get some invoice information from the
    Northwind service.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立数据上下文后，我们现在拥有了查询数据所需的一切。这里我们将使用查询表达式从Northwind服务中获取一些发票信息。
- en: '[PRE66]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There’s nothing out of the ordinary with the preceding query; it uses standard
    query operators to select `OrderDate`, `CustomerName`, and `ProductName` from
    the five most recently shipped invoices. What *is* exceptional is that with no
    more effort than pointing the type provider at the OData service, we have a full
    type hierarchy that models the types exposed by the service.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询没有什么特别的地方；它使用标准查询操作符选择了`OrderDate`、`CustomerName`和`ProductName`，从五个最近发货的发票中提取数据。*特殊*之处在于，凭借指向OData服务的类型提供程序，我们得到了一个完整的类型层次结构，模拟了服务暴露的类型。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Not all of the standard query operators are supported by every data source.
    For example, join is not supported by OData, so including it in a query with two
    OData sources will result in an error.*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*并不是所有的标准查询操作符都被每个数据源支持。例如，OData不支持连接操作，因此在包含两个OData数据源的查询中使用连接操作会导致错误。*'
- en: 'Although we’ve defined the `invoices` binding, the query execution is deferred
    until we actually enumerate the sequence. For simplicity, we can do so by piping
    the sequence to `Seq.iter`, which we’ll use to print each item like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经定义了`invoices`绑定，但查询执行会推迟，直到我们真正枚举序列。为了简便起见，我们可以通过将序列传递给`Seq.iter`来执行此操作，像这样打印每个项目：
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Invoking the preceding code printed the following items when I ran it, but
    your results may differ if the source data changes:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码时，我运行它时打印出了以下项目，但如果源数据发生变化，您的结果可能会不同：
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So far, the `ODataService` provider has been a black box; as long as you give
    it a valid address, it usually just works and you don’t have to think about how.
    This is particularly great when you’re doing exploratory coding, but it can be
    frustrating when the provider isn’t returning what you expect. Fortunately, there
    are a couple of events you can subscribe to in order to gain some insight into
    what the provider is doing: `SendingRequest` and `ReadingEntity`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`ODataService`提供程序一直是一个黑盒；只要你提供一个有效的地址，它通常就能正常工作，你不必考虑它是如何工作的。当你进行探索性编程时，这特别有用，但当提供程序没有返回你预期的结果时，它可能会让人感到沮丧。幸运的是，你可以订阅一些事件，以便深入了解提供程序正在做什么：`SendingRequest`和`ReadingEntity`。
- en: The `SendingRequest` event occurs whenever the provider creates a new `HttpWebRequest`,
    whereas `ReadingEntity` occurs after data has been read into an entity. For the
    purposes of this discussion, we’ll focus on `SendingRequest` because it can show
    exactly what is being requested and help you refine your queries.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendingRequest`事件在提供程序创建新的`HttpWebRequest`时发生，而`ReadingEntity`事件则在数据读取到实体中后发生。为了讨论的目的，我们将重点关注`SendingRequest`，因为它可以精确显示正在请求的内容，并帮助你优化查询。'
- en: 'Probably the most helpful thing to do with `SendingRequest` is interrogate
    the `RequestUri` property of the `WebRequest` object that’s associated with the
    `SendingRequestEventArgs`. `RequestUri` includes the full address of the OData
    request, so once you have it, you can paste it into a browser (or other diagnostic
    utility such as Fiddler) and refine it. One easy way to get the URI is to simply
    print it to the console like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SendingRequest`时最有帮助的事情之一是查询与`SendingRequestEventArgs`关联的`WebRequest`对象的`RequestUri`属性。`RequestUri`包含OData请求的完整地址，因此一旦获取该地址，你可以将其粘贴到浏览器（或其他诊断工具，如Fiddler）中进行调整。获取URI的一个简单方法是直接将其打印到控制台，如下所示：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So long as the preceding snippet is executed before the query is enumerated,
    the URI will be printed ahead of the results. In the case of the query described
    in this section, the printed URI is: `http://services.odata.org/V3/ Northwind/Northwind.svc/Invoices()?$orderby=ShippedDate%20desc&$top=5&$select=
    OrderDate, CustomerName, ProductName`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 只要在查询枚举之前执行前面的代码片段，URI将在结果之前打印出来。在本节描述的查询中，打印的URI是：`http://services.odata.org/V3/
    Northwind/Northwind.svc/Invoices()?$orderby=ShippedDate%20desc&$top=5&$select=
    OrderDate, CustomerName, ProductName`。
- en: 'For your convenience, the entire example from this section, including the subscription
    to `SendingRequest`, is reproduced in its entirety here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，本节中的整个示例，包括对`SendingRequest`的订阅，已在此完整呈现：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Example: Parsing a String with RegexProvider'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：使用RegexProvider解析字符串
- en: For this example, we’ll look at how the `RegexProvider` from the FSharpx project
    can generate types that correspond to a regular expression, providing you with
    a remarkable degree of safety when working with matches. To use this provider,
    you’ll need to obtain the `FSharpx.TypeProviders.Regex` package from NuGet or
    download the source from GitHub (*[https://github.com/fsharp/fsharpx/](https://github.com/fsharp/fsharpx/)*).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看`FSharpx`项目中的`RegexProvider`如何生成与正则表达式对应的类型，在处理匹配项时为你提供显著的安全性。要使用这个提供程序，你需要从NuGet获取`FSharpx.TypeProviders.Regex`包，或者从GitHub下载源代码（*[https://github.com/fsharp/fsharpx/](https://github.com/fsharp/fsharpx/)*）。
- en: 'As with the `ODataProvider` example, we’ll start by referencing some assemblies
    and opening some namespaces:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ODataProvider`示例一样，我们将首先引用一些程序集并打开一些命名空间：
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Because I created this script as part of a project that included the `FSharp.TypeProviders.Regex`
    package from NuGet, I simply referenced the package directly via a relative path;
    the path to the assembly may be different on your machine depending on how you
    obtained the assembly and its version.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我创建此脚本时使用了包含来自NuGet的`FSharp.TypeProviders.Regex`包的项目，因此我只是通过相对路径直接引用了该包；程序集的路径在你的机器上可能有所不同，具体取决于你如何获取该程序集及其版本。
- en: With the assemblies referenced and the common namespaces opened, we can now
    create the type provider. Creating a `RegexProvider` is similar to creating the
    `ODataService` except that, instead of a URI, `RegexProvider` takes a regular
    expression pattern. For this example, we’ll create the `RegexProvider` with a
    simple pattern that matches hexadecimal RGB values. (The space before the verbatim
    string is significant. Without the space, the compiler would try to interpret
    the string as a quoted expression, which is definitely not what we want.)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 引用程序集并打开常用命名空间后，我们现在可以创建类型提供程序。创建 `RegexProvider` 类似于创建 `ODataService`，不同之处在于，`RegexProvider`
    不是使用 URI，而是使用正则表达式模式。对于这个例子，我们将创建一个 `RegexProvider`，使用一个简单的模式来匹配十六进制的 RGB 值。（这里在原始字符串之前的空格很重要。如果没有空格，编译器会尝试将字符串解释为一个带引号的表达式，这显然不是我们想要的。）
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `RegexProvider` works a bit differently than the `ODataService` in that
    it’s not really intended for use as a query source. Instead, we’ll write a function
    that uses the type provider to convert a hexadecimal string into a standard .NET
    `Color` instance if it matches the regular expression pattern.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegexProvider` 的工作方式与 `ODataService` 有些不同，因为它并非真正作为查询源使用。相反，我们将编写一个函数，利用类型提供程序将十六进制字符串转换为标准的
    .NET `Color` 实例，前提是它符合正则表达式模式。'
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, we push the supplied `color` string into the `Match`
    method of a new instance of the `colorRegex`①. The value returned by `Match` is
    similar to the `Match` object returned when we’re using regular expressions directly
    (through the `Regex` class in `System.Text.RegularExpressions`), but as you can
    see at ②, ③, and ④, it also includes named properties that match the named groups
    defined within the source regular expression! This means that you don’t have to
    fumble with magic strings to access the individual named captures!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将提供的 `color` 字符串传递给 `colorRegex` 的新实例中的 `Match` 方法①。`Match` 返回的值类似于我们直接使用正则表达式时返回的
    `Match` 对象（通过 `System.Text.RegularExpressions` 中的 `Regex` 类），但正如你在 ②、③ 和 ④ 中看到的，它还包括与源正则表达式中定义的命名组匹配的命名属性！这意味着你不必再为访问单个命名捕获而苦苦挣扎，避免了使用神奇字符串！
- en: 'To test this, we merely need to pass some strings to the `convertToRgbColor`
    function. Here we invoke the function for each string in a list:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行测试，我们只需要将一些字符串传递给 `convertToRgbColor` 函数。在这里，我们对列表中的每个字符串调用该函数：
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Evaluating this code should result in the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 评估此代码应该得到以下结果：
- en: '[PRE75]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, the first string didn’t match the color pattern so it was not
    converted, whereas the remaining three items were converted and written accordingly.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第一个字符串没有匹配颜色模式，因此没有被转换，而其余三个项目则被转换并相应地写入。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: With the addition of query expressions and type providers in F# 3.0, F# took
    massive strides toward being an even better language for data-intensive development
    work.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 F# 3.0 中查询表达式和类型提供程序的增加，F# 在成为一个更适合数据密集型开发工作的语言方面迈出了巨大步伐。
- en: Query expressions bring the power of LINQ to the language with an idiomatic
    flair. With them, you can easily compose complex queries for analyzing and presenting
    data from a variety of data sources. Furthermore, the extensible nature of query
    expressions makes them well suited for more complex needs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式以一种惯用的方式将 LINQ 的强大功能带入语言中。借助它们，您可以轻松地组合复杂的查询，以分析和展示来自各种数据源的数据。此外，查询表达式的可扩展性使其非常适合更复杂的需求。
- en: Type providers further expand upon F#’s already rich data experience by abstracting
    away the details of creating types that map to different data sources. They greatly
    improve a developer’s ability to perform exploratory programming in data-centric
    scenarios because the developer doesn’t need to be as concerned about how to access
    the data. Finally, type providers can add an extra degree of safety to the code
    by detecting changes to the underlying data structures as part of the build process.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供程序通过抽象出与不同数据源映射的类型创建细节，进一步扩展了 F# 已经丰富的数据体验。它们极大地提升了开发者在数据中心场景中进行探索性编程的能力，因为开发者无需过多关注如何访问数据。最后，类型提供程序可以通过在构建过程中检测底层数据结构的变化，为代码添加额外的安全性。
