- en: Chapter 10. Show Me the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Virtually every application written today requires robust mechanisms to both
    access and manipulate data. While the full gamut of data access technologies across
    the .NET Framework is available to you in F#, this chapter focuses on two specific
    areas: query expressions and type providers.'
  prefs: []
  type: TYPE_NORMAL
- en: Query Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When LINQ was added to .NET, it revolutionized the way we access data by providing
    a unified syntax for querying data from disparate data sources. Upon LINQ’s introduction,
    C# and Visual Basic were extended to include the *query syntax*, a SQL-like syntax
    with context-sensitive keywords that were really syntactic sugar over several
    language features, such as extension methods and lambda expressions. In this regard,
    F# was a little late to the party because, prior to F# 3.0, the only way to use
    LINQ in F# was to directly call the LINQ extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite their foundations in functional programming, using the LINQ methods
    directly has a highly object-oriented feel due to their fluent interface; sequences
    are passed to methods that return new sequences and the methods are typically
    chained with dot notation. Consider the following query, which uses the LINQ extension
    methods directly against an F# list to filter out odd numbers, and then sorts
    the results in descending order (remember to open the `System.Linq` namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, chaining the method calls in this manner is much more object-oriented
    than functional. *Query expressions*, introduced with F# 3.0, changed that by
    providing a convenient SQL-like syntax that resembles the query syntax from C#
    and Visual Basic. They really are LINQ for F#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Query expressions take the form of `query { ... }`. Inside the braces we identify
    a series of operations we want to apply to a sequence, thereby forming a query.
    For instance, we could rewrite the previous query as a query expression like this
    (explicitly opening `System.Linq` isn’t required for query expressions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, filtering and sorting the list looks and feels more functional. Instead
    of chaining method calls directly, we’re expressing the query in a more idiomatic
    manner that uses expression composition and function calls. Because query expressions
    are a wrapper around the LINQ technologies, you can use them with any sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Given this simple example, one could argue that the `Seq` and `List` module
    functions could be used to similar effect, and in many cases, that’s true. For
    instance, we could easily replace the `where` operator with a call to `Seq.filter`.
    Likewise, we can often sort using `Seq.sortBy` instead of the `sortBy` operator.
    What’s not immediately apparent is that by being built upon LINQ, query expressions
    can offer additional optimizations, such as generating a `WHERE` clause in a SQL
    query to prevent retrieving a large data set from a database.
  prefs: []
  type: TYPE_NORMAL
- en: In the interest of simplicity, unless otherwise noted, each query expression
    example in this chapter will use the types and collections defined in the following
    `QuerySource` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing particularly interesting about the `QuerySource` module, but
    the types and collections defined here sufficiently represent a basic data model
    we can query in a variety of ways. The `film` and `actor` types also include overrides
    of `ToString` to simplify the query output.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Querying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In their most basic form, query expressions consist of an enumerable `for` loop
    and a projection. The enumerable `for` loop defines a name for items in a source
    sequence. The projection identifies the data that will be returned by the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common projection operators is `select`, which equates to LINQ’s
    `Select` method and defines the structure of each item in the resulting sequence
    (much like `Seq.map`). At their most basic, `select` operations simply project
    each data item directly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'which results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`select` operations aren’t limited to projecting only the source data item;
    they can also transform the source sequence to project more complex types like
    tuples, records, or classes. For instance, to project a tuple containing the film’s
    name and its release year, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'which gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In these simple examples, we’ve explicitly included a `select` operation to
    transform the source sequence. As query complexity grows, projecting the raw,
    nontransformed data items is often implied, so the `select` operation can often
    be safely omitted. In the interest of space, I’ll generally project results with
    `ToString`, but I encourage you to experiment with different projections to familiarize
    yourself with the query behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Queries often involve specifying some criteria to filter out unwanted data.
    There are two primary approaches to filtering with query expressions: predicate-based
    filters and distinct item filters.'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate-Based Filters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Predicate-based filters* allow you to filter data by specifying the criteria
    that each item in the source sequence must satisfy in order to be included in
    the projected sequence. To create a predicate-based filter, simply include F#’s
    equivalent of LINQ’s `Where` method, the `where` operator, followed by a Boolean
    expression (often called a *predicate*) in your query. (Note that parentheses
    are typically required around the expression.) For example, to select only the
    films released in 1984, you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When composing predicate-based filters, you must be aware of the source sequence’s
    underlying type. For the simple examples you’ve seen so far it hasn’t been an
    issue, but in many cases, particularly when you are working with `IQueryable<'T>`
    instances, you might have to deal with null values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Null values can pose a problem in query expressions because the standard comparison
    operators don’t handle them. For example, if you were to query for all films that
    grossed no more than $40 million using the standard equality operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'you’d receive the following error because `gross` is defined as `Nullable<float>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To work around this limitation, you need to use the nullable operators defined
    in the `Microsoft.FSharp.Linq.NullableOperators` module. These operators look
    like the standard operators except that they begin with a question mark (`?`)
    when the left operand is `Nullable<_>`, end with a question mark when the right
    operand is `Nullable<_>`, or are surrounded by question marks when both operands
    are `Nullable<_>`. [Table 10-1](ch10.html#nullable_operators "Table 10-1. Nullable
    Operators") lists each of the nullable operators.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1. Nullable Operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Left Side Nullable | Right Side Nullable | Both Sides Nullable
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Equality | `?=` | `=?` | `?=?` |'
  prefs: []
  type: TYPE_TB
- en: '| Inequality | `?<>` | `<>?` | `?<>?` |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than | `?>` | `>?` | `?>?` |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than or equal | `?>=` | `>=?` | `?>=?` |'
  prefs: []
  type: TYPE_TB
- en: '| Less than | `?<` | `<?` | `?<?` |'
  prefs: []
  type: TYPE_TB
- en: '| Less than or equal | `?<=` | `<=?` | `?<=?` |'
  prefs: []
  type: TYPE_TB
- en: '| Addition | `?+` | `+?` | `?+?` |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | `?-` | `-?` | `?-?` |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | `?*` | `*?` | `?*?` |'
  prefs: []
  type: TYPE_TB
- en: '| Division | `?/` | `/?` | `?/?` |'
  prefs: []
  type: TYPE_TB
- en: '| Modulus | `?%` | `%?` | `?%?` |'
  prefs: []
  type: TYPE_TB
- en: 'Now we can rewrite the previous query using the appropriate nullable operator
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the query resulted in two matches despite the underlying sequence
    containing some null values.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to chain multiple predicates together with Boolean operators.
    For instance, to get only the films released in 1987 that grossed no more than
    $40 million, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'which gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Distinct-Item Filters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Query expressions can produce a sequence containing only the distinct values
    from the underlying sequence by filtering out duplicates. To achieve this, you
    need only include the `distinct` operator in your query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `distinct` operator corresponds to LINQ’s `Distinct` method, but unlike
    in C# or VB, query expressions allow you to include it directly within the query
    rather than as a separate method call. For example, to query for distinct release
    years, you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve projected the distinct release years to a new sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Accessing Individual Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s quite common for a sequence to contain multiple items when you really care
    about only one in particular. Query expressions include several operators for
    accessing the first item, the last item, or arbitrary items from a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the First or Last Item
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get the first item from a sequence, you can use the `head` or `headOrDefault`
    operators. These operators respectively correspond to the parameterless overloads
    of the `First` and `FirstOrDefault` LINQ methods but use the more functional nomenclature
    of “head” to identify the first item (just like with F# lists). The difference
    between `head` and `headOrDefault` is that `head` raises an exception when the
    source sequence is empty, whereas `headOrDefault` returns `Unchecked.defaultof<_>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the first item from a sequence, simply project a sequence to one of
    the head operators like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can get the last item in a sequence using either the `last` or
    `lastOrDefault` operators. These operators behave the same way as their head counterparts
    in that `last` raises an exception when the sequence is empty, whereas `lastOrDefault`
    does not. Depending on the underlying sequence type, getting the last item may
    require enumerating the entire sequence, so exercise some care because the operation
    could be expensive or time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an Arbitrary Item
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you want to get a specific item by its index you can use the `nth` operator,
    which is equivalent to LINQ’s `ElementAt` method. For instance, to get the third
    element from the `films` sequence, you could structure a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Although the `nth` operator is useful when you already know the index, it’s
    more common to want the first item that matches some criteria. In those cases,
    you’ll want to use the `find` operator instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find` operator is equivalent to calling LINQ’s `First` method with a predicate.
    It is also similar to the `where` operator except that it returns only a single
    item instead of a new sequence. For example, to get the first film listed for
    1987, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this query will give you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` operator is useful for locating the first item that matches some
    criteria, but it doesn’t guarantee that the first match is the only match. When
    you want to return a single value but also need to be certain that a query result
    contains one and only one item (such as when you are finding an item by a key
    value), you can use the `exactlyOne` operator, which corresponds to the parameterless
    overload of LINQ’s `Single` method. For example, to get a film by its `id` while
    enforcing uniqueness, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the query yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the source sequence doesn’t contain exactly one item, the `exactlyOne`
    operator raises an exception. Should you want a default value when the source
    sequence is empty, you can use the `exactlyOneOrDefault` operator instead. Be
    warned, though, that if the source sequence includes more than one item, `exactlyOneOrDefault`
    will still raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Query expression syntax does not include operators equivalent to the predicate-based
    overload of Single or SingleOrDefault.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Query expressions make sorting data easy, and, in some ways, they are more flexible
    than the sorting functions in the various collection modules. The sorting operators
    allow you to sort in ascending or descending order on both nullable and non-nullable
    values. You can even sort by multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting in Ascending Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sorting a sequence in ascending order requires either the `sortBy` or `sortByNullable`
    operators. Both of these operators are built upon LINQ’s
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderBy` method. Internally, these methods differ only by the generic constraints
    applied to their arguments. As their names imply, the `sortBy` operator is used
    with non-nullable values, whereas `sortByNullable` is used with `Nullable<_>`
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With both of these operators, you need to specify the value on which to sort.
    For example, to sort the films by name, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Sorting in Descending Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To sort a sequence in descending order, you use either the `sortByDescending`
    or `sortByNullableDescending` operators. These operators are based on LINQ’s `OrderByDescending`
    method and, like their ascending counterparts, internally differ only by the generic
    constraints applied to their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort the `films` sequence in descending order by name, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'which returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Sorting by Multiple Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To sort on multiple values, first sort with one of the `sortBy` or `sortByDescending`
    operators and then supply subsequent sort values with one of the `thenBy` operators.
    As with the primary sort operators, there are variations of `thenBy` that allow
    you to sort in ascending or descending order using both nullable and non-nullable
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four `thenBy` variations, which can appear only after one of the `sortBy`
    variations, are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thenBy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenByNullable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenByDescending`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenByNullableDescending`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These operators are based upon LINQ’s `ThenBy` and `ThenByDescending` methods.
    To see these in action, let’s sort the `films` sequence by `releaseYear` and then
    in descending order by `gross`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This query results in the following sorted sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can chain additional `thenBy` operators to create even more complex sorting
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common query operation is grouping. Query expressions provide two operators,
    both based on LINQ’s `GroupBy` method, to do just that. Both operators produce
    an intermediate sequence of `IGrouping<_,_>` instances that you refer to later
    in your query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first operator, `groupBy`, lets you specify the key value by which the
    items in the source sequence will be grouped. Each `IGrouping<_,_>` produced by
    `groupBy` includes the key value and a child sequence containing any items from
    the source sequence that matches the key. For example, to group the films by release
    year, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This query produces the result (formatted and abbreviated for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It isn’t always necessary to include the full source item in the resulting
    `IGrouping<_,_>` like the `groupBy` operator does. Instead, you can use the `groupValBy`
    operator to specify what to include, be it a single value from the source or some
    other transformation. Unlike the other operators we’ve seen so far, `groupValBy`
    takes two arguments: the value to include in the result, and the key value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the `groupValBy` operator, let’s group the films by `releaseYear`
    again, but this time we’ll include a tuple of the film `name` and its `gross`
    earnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of the full film instance, the resulting groupings include only
    the data we explicitly requested.
  prefs: []
  type: TYPE_NORMAL
- en: Paginating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Query expressions allow you to easily paginate a sequence. Think about your
    typical search results page, where items are partitioned into some number of items
    (say, 10) per page. Rather than having to manage placeholders that identify which
    partition a user should see, you can use query expressions, which provide the
    `skip`, `skipWhile`, `take`, and `takeWhile` operators to help you get to the
    correct partition in the query itself. Each of these operators shares its name
    with its underlying LINQ method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `skip` and `take` operators both accept an integer indicating how many
    items to bypass or include, respectively. For example, you could compose a function
    to get a particular page, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, getting a particular page is only a matter of invoking the `getFilmPage`
    function. For instance, to get the first page of three items, you would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'which yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, you would get the second result page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'which gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It’s okay to specify more items than are present in the sequence. If the end
    of the sequence is reached, the `skip` and `take` operators return what has been
    selected so far and no exceptions are thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `skipWhile` and `takeWhile` operators are very similar to `skip` and `take`
    except that instead of working against a known number of items, they skip or take
    items as long as a condition is met. This is useful for paging over a variable
    number of items according to some criteria. For example, the following function
    returns the films released in a given year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking this function with a year will generate a sequence containing zero
    or more items. For instance, invoking it with 1984 returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: whereas invoking it with 1986 returns no items because the source sequence doesn’t
    include any films released in 1986.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering whether this simple example of paging by `releaseYear` could
    be simplified with a single `where` operator, it can. This example simply demonstrates
    `takeWhile`’s effect. `where` and `takeWhile` serve similar purposes, but distinguishing
    between them is important, particularly for more complex predicates. The difference
    between the two operators is that `takeWhile` stops looking as soon as it finds
    something that doesn’t match, but `where` does not.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As often as we need to present or otherwise work with tabular data, sometimes
    what we’re really after is an aggregated view of the data. Aggregations such as
    counting the number of items in a sequence, totaling some values, or finding an
    average are all commonly sought-after values that can be exposed through built-in
    query operators.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the items in a sequence is easy; simply project the sequence to the
    `count` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating this query tells us that five items are present in the `films` sequence.
    Be warned, though, that counting the items in a sequence can be an expensive operation;
    it typically requires enumerating the entire sequence, which could have a negative
    impact on performance. That said, the `Count` method on which this operator is
    based is smart enough to short-circuit some sequences (like arrays). If you’re
    counting items only to determine whether the sequence contains any data, you should
    instead consider using the `exists` operator, discussed in [Detecting Items](ch10.html#detecting_items
    "Detecting Items").
  prefs: []
  type: TYPE_NORMAL
- en: The remaining aggregation operators allow you to easily perform mathematical
    aggregations against a sequence according to a selector. The operators—`minBy`,
    `maxBy`, `sumBy`, and `averageBy`—allow you to calculate the minimum value, maximum
    value, total, or average for the values, respectively. Internally, the `minBy`
    and `maxBy` operators use LINQ’s `Min` and `Max` methods, respectively, but `sumBy`
    and `averageBy` provide their own implementations and are completely independent
    of LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these four operators also have nullable counterparts that work against
    nullable values much like the sorting operators introduced in [Sorting Results](ch10.html#sorting_results
    "Sorting Results"). To demonstrate, we’ll query the `films` sequence using the
    nullable forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the highest grossing film, we could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As expected, running this query returns `59735548.0`. Replacing `maxByNullable`
    with `minByNullable` returns `38122105.0`, and `sumByNullable` returns `136257653.0`.
    The `averageByNullable` operator doesn’t behave quite as you might expect, however.
  prefs: []
  type: TYPE_NORMAL
- en: Averaging the gross earnings using `averageByNullable` results in `27251530.6`.
    What happens is that although the operator skips null values during the summation
    phase, it divides the sum by the count of items in the sequence regardless of
    how many null items were skipped. This means that the null values are effectively
    treated as zero, which may or may not be desirable. Later in this chapter, we’ll
    look at how to define a new query operator that truly ignores null values when
    calculating an average.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, we’ve explored the many ways you can structure query expressions to
    transform, filter, sort, group, and aggregate sequences. Sometimes, though, you
    don’t really care to obtain specific items from a sequence but rather want to
    inspect a sequence to determine whether it contains data that matches some criterion.
    Instead of returning a new sequence or a specific item, the operators discussed
    in this section return a Boolean value indicating whether the sequence contains
    the desired data. Like the `distinct` operator, these operators are part of the
    query expression itself, which is another feature that distinguishes F#’s query
    expressions from query syntax in C# and Visual Basic.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to see if a known item is contained within a sequence, you use
    the `contains` operator. Built upon LINQ’s `Contains` method, the `contains` operator
    accepts the item you are looking for as its argument. For instance, if we want
    to detect whether *Kindergarten Cop* is present in the `films` collection, we
    could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking this query will inform you that *Kindergarten Cop* is not present
    in the collection (much to my relief). As you can see, though, the `contains`
    operator is really suitable only when you already have a reference to an item
    that may already be part of the collection. If you know only part of the value
    you’re looking for, such as the name of the film, you can revise the query to
    project each name and pass the name you’re looking for to `contains`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Projecting the values like this, however, isn’t particularly efficient because
    it involves enumerating the entire sequence prior to locating the specified item.
    Instead, you can turn to another operator, `exists`, which is based on LINQ’s
    `Any` method. The `exists` operator is like `where` except that it stops enumerating
    the sequence and returns `true` or `false` as soon as an item that matches its
    predicate is found. For example, the previous query could be expressed with `exists`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the predicate supplied to `exists` doesn’t have to look for a specific
    item. We can easily determine if any films grossed at least $50 million with the
    following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Because *Predator* grossed nearly $60 million, the previous query returns `true`.
    If you want to check whether every item in a sequence satisfies some condition,
    you can use the `all` operator. Based on LINQ’s `All` method, the `all` operator
    enumerates the sequence and returns `true` when each item matches the predicate.
    When an item that doesn’t match the predicate is encountered, enumeration stops
    and `all` returns `false`. For example, to see if every film grossed at least
    $50 million, you could construct a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In our `films` collection, only one item satisfies the condition; therefore,
    the query returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Joining Multiple Data Sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Querying data from a single sequence is useful, but data is often spread across
    multiple sources. Query expressions carry forward LINQ’s join capabilities, which
    allow you to query data from multiple sources within a single expression. Joins
    in query expressions resemble enumerable `for` loops in that they include an iteration
    identifier and the source sequence but begin with the appropriate `join` operator
    and also include join criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The first type of join, the *inner join*, uses the `join` operator to correlate
    values from one sequence with values in a second sequence. Internally, the `join`
    operator uses LINQ’s `Join` method to work its magic. Once the sequences are joined,
    values from both sequences can be referenced by subsequent operators like `where`
    or `select`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, all of the queries we’ve written have used only the `films` collection.
    Recall that when we created the `QuerySource` module at the beginning of the chapter,
    we also defined two other collections: `actors` and `filmActors`. Together, the
    `films`, `actors`, and `filmActors` collections model a many-to-many relationship
    between `films` and `actors`, with `filmActors` serving as the junction table.
    We can use the `join` operator to bring these three collections together in a
    single query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Joining multiple sequences together merely requires us to include a join expression
    for each sequence and identify the relationship between them through their members
    and an equality operator. Invoking this query results in the following sequence
    (truncated per FSI):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: F# exposes LINQ’s `GroupJoin` function through the `groupJoin` operator. This
    lets you join two sequences, but instead of selecting items that satisfy the join
    criterion individually, you project each item that satisfies the join criterion
    into another sequence you can subsequently reference within your query. You can
    use this intermediate sequence to create a hierarchical data structure that resembles
    the `IGrouping<_,_>` instances created by the `groupBy` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following query, which creates a hierarchy where each actor is
    grouped by the films in which he or she appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `groupJoin` operator to create an intermediate sequence named
    `junction`. Inside the projected tuple, we have a nested query where we join `actors`
    to `junction` and project individual actor names. This results in the following
    sequence, which I’ve formatted for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the outer query (the `films` part) returns a single sequence
    of tuples. Nested within each item is another sequence containing the actors associated
    with that film. What isn’t apparent from these truncated results is that when
    none of the items in the joined sequence satisfies the join criterion (as is the
    case for *Conan the Destroyer*), the sequence created by the `groupJoin` operation
    is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to flatten the results of a `groupJoin` rather than return them
    as a hierarchy, you can follow the `groupJoin` operation with another enumerable
    `for` loop, using the junction sequence as the loop source. Here, the previous
    query is restructured to return each actor inline with the film:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this query is the same as for an inner join, so I won’t repeat
    the output here. In most cases, you’d want to use the `join` operator to forego
    the overhead associated with creating the intermediate junction sequence, but
    there is one place where using a `groupJoin` like this makes sense: left outer
    joins.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, if no items satisfy the join criterion in a group join, the result
    is an empty sequence. However, if you use the `DefaultIfEmpty` method with the
    resulting sequence, you’ll get a new sequence containing a single item that’s
    the default value for the underlying type. To perform a left outer join in your
    query, you can use the `groupJoin` operator as we did in the previous query but
    include a call to `DefaultIfEmpty` in your enumerable `for` loop—for example,
    `j.DefaultIfEmpty()`. Alternatively, you can use the `leftOuterJoin` operator
    to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, left outer joins are one area where the dissonance between F#
    and the rest of the .NET Framework can cause a lot of misery. But this is really
    a problem only when you’re working with the core F# types. Consider the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When this query enumerates (via `Seq.iter`), it raises a `NullReferenceException`
    as soon as it tries to join in the actors for *Conan the Barbarian*. Because there
    are no entries for that film in the `filmActors` sequence, the call to `DefaultIfEmpty`
    in the left outer join causes the sole entry in `junction` to be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Wait, what? Null? Isn’t `filmActor` a record type? How can it possibly be `null`
    if `null` isn’t a valid value for record types? The answer lies in the fact that
    by calling into .NET Framework methods we’ve left the confines of the F# sandbox.
    `null` may not be valid for record types in F#, but the Common Language Runtime
    has no notion of a record type; all it knows are value and reference types and,
    from its perspective, a record type is just a reference type. Therefore, `null`
    is a valid value. Unfortunately, because our code is all in F# and the F# compiler
    enforces the value constraints around the record type, we can’t handle the null
    value with pattern matching or `if...then` expressions. We can’t even use the
    `AllowNullLiteral` attribute on the type because the compiler doesn’t allow that
    either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working around this issue is a bit of a pain. We can start by splitting the
    query into two parts: one that joins `actors` to `filmActors` and another that
    joins in `films`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good start, but we’ll still get a `NullReferenceException` with the
    Tuple pattern match in the enumerable `for` loop for `junction` because F# doesn’t
    allow `null` for tuples either. There is yet another workaround we can use: an
    upcast to `obj`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`null` may not be a valid value for a tuple, but it certainly is for `obj`.
    By explicitly upcasting to `obj`, we can use pattern matching to detect the null
    value and return the appropriate tuple instead of raising the exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending Query Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you’ve seen in the previous sections, query expressions provide an easy
    and expressive way to work with data. Query expressions also offer another benefit
    that really sets them apart from query syntax in C# and Visual Basic: They’re
    fully extensible. In this section, I’ll show a few additional operators. We’ll
    start by plugging a hole in the built-in operators by defining operators that
    expose the parameterized overloads of `Single` and `SingleOrDefault`. We’ll then
    move on to a more complex example that allows us to calculate an average by disregarding
    all null values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: ExactlyOneWhen'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall from [Getting an Arbitrary Item](ch10.html#getting_an_arbitrary_item
    "Getting an Arbitrary Item") that the `exactlyOne` and `exactlyOneOrDefault` operators
    expose the parameterless versions of LINQ’s `Single` and `SingleByDefault` operators,
    but no such operators exist for the overloads that accept a predicate. We can
    easily define our own operators to expose these methods by leveraging the power
    of F# type extensions.
  prefs: []
  type: TYPE_NORMAL
- en: To create the custom operators, we need to extend the `QueryBuilder` class found
    within the `Microsoft.FSharp.Linq` namespace. This class defines the methods that
    ultimately serve as the query operators. Fundamentally, the type extension we’ll
    define is no different than any other type extension; we need only to include
    a few attributes so the compiler knows how the functions should behave within
    a query expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code listing in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet defines two extension methods on the `QueryBuilder` class: `exactlyOneWhen`
    and `exactlyOneOrDefaultWhen`. Because these are so similar, we’ll just focus
    on the `exactlyOneWhen` operator. The first item of interest is the `CustomOperation`
    attribute ① applied to the method itself. This attribute indicates that the method
    should be available within a query expression and the operator name.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the method’s `this` identifier is two underscore characters ② to be consistent
    with the other operator definitions. The `source` parameter at ③, annotated as
    `QuerySource<'T, 'Q>`, identifies the sequence the operator will work against.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately following `source` is the `selector` parameter ④. This parameter
    is a function that will be applied against every item in `source` to determine
    whether it should be selected. The `ProjectionParameter` attribute applied to
    `selector` instructs the compiler that the function is implied to accept `'T`
    (as inferred from `source`) so that you can write the selector function as if
    you were working directly with an instance; that is, if you’re querying the `films`
    collection and have used `f` as your iteration identifier, you could write `f.id
    = 4`. Without `ProjectionParameter`, you’d have to use the full lambda syntax
    (or a formal function) instead of just the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new operators defined, we can now write queries that use them. For
    instance, to use the `exactlyOneWhen` operator to find a film by `id`, you would
    write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with these operators you no longer need to include the `where`
    operator to filter the results before checking that the sequence contains only
    a single item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: AverageByNotNull'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For a more complex example of a custom operator, let’s provide an alternative
    to the `averageByNullable` operator we used in [Aggregating Data](ch10.html#aggregating_data
    "Aggregating Data") to compute the average gross earnings for our films. The calculation
    resulted in the average being reported as `27251530.6` because the two null values
    were excluded from the sum but the divisor was still five. If you wanted to truly
    ignore the null values and divide the total by three, the `averageByNullable`
    operator wouldn’t help you, but you could define a custom operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `AverageByNotNull` method incorporates many of the same principles
    as `exactlyOneWhen` and `exactlyOneOrDefaultWhen`; that is, they each involve
    the `CustomOperation` and `ProjectionParameter` attributes. Where `AverageByNotNull`
    differs is that it’s defined as inline to ensure that the generic parameters can
    be resolved. Because they’re so similar, I’ve based the signature and generic
    constraints for `AverageByNotNull` largely upon that of the `averageByNullable`
    operator, although I’ve simplified it a bit for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve defined the `averageByNotNull` operator, we can include it in
    a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Invoking this query returns `45419217.67`, a stark contrast from `27251530.6`
    as returned by `averageByNullable`.
  prefs: []
  type: TYPE_NORMAL
- en: Type Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with query expressions, the other “killer feature” of F# 3.0 is type providers.
    *Type providers* were developed to abstract away creation of the types, properties,
    and methods necessary to work with external data because this process is often
    tedious, error prone, and difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Many type providers can be likened to traditional object-relational mapping
    (ORM) tools like NHibernate or Entity Framework, although their scope is potentially
    much greater. ORM tools typically require a great deal of configuration to be
    used effectively. Although there are tools that simplify this process for many
    of the more popular ORM technologies, they still require plenty of maintenance.
    ORM-like type providers aim to remove this overhead by automating type generation
    as part of the compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: The other primary use for type providers is to simplify otherwise complex interfaces.
    Consider how cumbersome and error-prone something like matching strings with regular
    expressions can be. Regular expression syntax is confusing enough on its own,
    but getting named captures from the match collection requires using string keys
    to identify the values you’re trying to access. A regular expression type provider
    can simplify the interface by generating types that correspond to the named captures
    in the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of which need type providers satisfy, they all offer three primary
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Making data-centric exploratory programming more accessible by eliminating the
    need to manually create mappings and type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminating the administrative burden of manually maintaining mappings or other
    type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the likelihood of errors caused by undetected changes to the underlying
    data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full discussion of type providers goes well beyond the scope of this book.
    Instead, this section is intended to introduce many of the type providers that
    are available to you either as part of the core F# distribution or through some
    popular third-party libraries. After you’ve seen what’s available, we’ll discuss
    how to initialize and use a few type providers to easily get the data you care
    about.
  prefs: []
  type: TYPE_NORMAL
- en: Available Type Providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F# 3.0 includes several type providers out of the box. [Table 10-2](ch10.html#built-in_type_providers
    "Table 10-2. Built-in Type Providers") lists the built-in providers and a brief
    description of each.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2. Built-in Type Providers
  prefs: []
  type: TYPE_NORMAL
- en: '| Provider | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DbmlFile` | Provides the types that correspond to a SQL Server database
    as described in a Database Markup Language file (*.dbml*) |'
  prefs: []
  type: TYPE_TB
- en: '| `EdmxFile` | Provides the types that correspond to a database as described
    by a LINQ-to-Entities mapping file (*.edmx*) |'
  prefs: []
  type: TYPE_TB
- en: '| `ODataService` | Provides the types that correspond to those returned by
    an OData service |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlDataProvider` | Provides the types that correspond to a SQL Server database
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SqlEntityProvider` | Provides the types that correspond to a database according
    to a LINQ-to-Entities mapping |'
  prefs: []
  type: TYPE_TB
- en: '| `WsdlService` | Provides the types that correspond to those returned by a
    WSDL-based web service |'
  prefs: []
  type: TYPE_TB
- en: The list of built-in type providers is pretty sparse and is focused on database
    or database-like sources. Even so, what’s provided covers a fairly large number
    of use cases. Should your data fall outside of the cases covered by the built-in
    types, you can define custom type providers, but doing so is outside the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start down the path of building your own type providers, you should
    see if there are any third-party providers that will meet your needs. At the time
    of this writing, several popular libraries include a number of useful type providers,
    most notably: `FSharpx` and `FSharp.Data`. [Table 10-3](ch10.html#some_available_third-party_type_provider
    "Table 10-3. Some Available Third-Party Type Providers") lists several of the
    type providers in each library to give you an idea of what’s readily available
    and the diversity of uses for type providers. This list is not meant to be exhaustive;
    there are definitely other libraries available.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-3. Some Available Third-Party Type Providers
  prefs: []
  type: TYPE_NORMAL
- en: '| Provider | Description | FSharpx | FSharp.Data |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AppSettingsProvider` | Provides types that correspond to the nodes in the
    AppSettings section of a configuration file | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `CsvProvider` | Provides types that allow for easy parsing of comma-separated
    value (CSV) files |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ExcelProvider` | Provides the types necessary for working with an Excel
    workbook | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `FileSystemProvider` | Provides the types necessary for working with the
    filesystem | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonProvider` | Provides types that represent a JavaScript Object Notation
    (JSON) document |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `RegexProvider` | Provides types that allow for inspecting regular expression
    matches | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `XamlProvider` | Provides types that allow for easy XAML parsing | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `XmlProvider` | Provides types that represent an XML document |   | ![](httpatomoreillycomsourcenostarchimages1981222.png.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: Using Type Providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regardless of which type provider you need, initializing one always follows
    the same basic pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding syntax, *name* is the name by which you’ll access the provider’s
    capabilities, *providerName* identifies the provider type itself, and *parameters*
    are the provider-specific arguments that control the provider’s behavior. Parameters
    will typically include things like a connection string or the path to the data
    source, but ultimately each type provider is responsible for defining the parameters
    it accepts.
  prefs: []
  type: TYPE_NORMAL
- en: The first time a provider is used within Visual Studio, you’ll be presented
    with a security dialog like the one pictured in [Figure 10-1](ch10.html#type_provider_security_dialog
    "Figure 10-1. Type Provider Security dialog").
  prefs: []
  type: TYPE_NORMAL
- en: '![Type Provider Security dialog](httpatomoreillycomsourcenostarchimages1981224.png.jpg)Figure 10-1. Type
    Provider Security dialog'
  prefs: []
  type: TYPE_NORMAL
- en: As the dialog indicates, type providers can connect to remote data sources and
    execute custom code for build and IntelliSense features. Once you’ve enabled or
    disabled a type provider, you won’t be prompted again. If you want to change your
    selection at a later time, you can find a listing of type providers under F# Tools
    in the Visual Studio Options dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Accessing an OData Service'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This first example uses the `ODataService` type provider to query the publicly
    available Northwind sample OData service from *[http://www.odata.org/](http://www.odata.org/)*.
    To start, we need to reference two assemblies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The first assembly includes several Windows Communication Foundation (WCF)
    classes required by the `ODataService` provider. Though we don’t use the WCF types
    directly within this example, failure to add the reference will result in compilation
    errors. The second assembly contains the provider itself. With these assemblies
    referenced, we can now open the namespace that contains the `ODataService` provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we include a type definition that references the appropriate type provider
    along with the address to the Northwind service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ODataService` provider takes the supplied address, appends `$metadata`,
    and then proceeds to construct and import the types described by the service.
    In order to do anything with the service, we need to obtain a data context via
    the provider type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: With the data context established, we now have everything we need to query the
    data. Here we’ll use a query expression to get some invoice information from the
    Northwind service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing out of the ordinary with the preceding query; it uses standard
    query operators to select `OrderDate`, `CustomerName`, and `ProductName` from
    the five most recently shipped invoices. What *is* exceptional is that with no
    more effort than pointing the type provider at the OData service, we have a full
    type hierarchy that models the types exposed by the service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Not all of the standard query operators are supported by every data source.
    For example, join is not supported by OData, so including it in a query with two
    OData sources will result in an error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we’ve defined the `invoices` binding, the query execution is deferred
    until we actually enumerate the sequence. For simplicity, we can do so by piping
    the sequence to `Seq.iter`, which we’ll use to print each item like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking the preceding code printed the following items when I ran it, but
    your results may differ if the source data changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the `ODataService` provider has been a black box; as long as you give
    it a valid address, it usually just works and you don’t have to think about how.
    This is particularly great when you’re doing exploratory coding, but it can be
    frustrating when the provider isn’t returning what you expect. Fortunately, there
    are a couple of events you can subscribe to in order to gain some insight into
    what the provider is doing: `SendingRequest` and `ReadingEntity`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `SendingRequest` event occurs whenever the provider creates a new `HttpWebRequest`,
    whereas `ReadingEntity` occurs after data has been read into an entity. For the
    purposes of this discussion, we’ll focus on `SendingRequest` because it can show
    exactly what is being requested and help you refine your queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the most helpful thing to do with `SendingRequest` is interrogate
    the `RequestUri` property of the `WebRequest` object that’s associated with the
    `SendingRequestEventArgs`. `RequestUri` includes the full address of the OData
    request, so once you have it, you can paste it into a browser (or other diagnostic
    utility such as Fiddler) and refine it. One easy way to get the URI is to simply
    print it to the console like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'So long as the preceding snippet is executed before the query is enumerated,
    the URI will be printed ahead of the results. In the case of the query described
    in this section, the printed URI is: `http://services.odata.org/V3/ Northwind/Northwind.svc/Invoices()?$orderby=ShippedDate%20desc&$top=5&$select=
    OrderDate, CustomerName, ProductName`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For your convenience, the entire example from this section, including the subscription
    to `SendingRequest`, is reproduced in its entirety here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Parsing a String with RegexProvider'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, we’ll look at how the `RegexProvider` from the FSharpx project
    can generate types that correspond to a regular expression, providing you with
    a remarkable degree of safety when working with matches. To use this provider,
    you’ll need to obtain the `FSharpx.TypeProviders.Regex` package from NuGet or
    download the source from GitHub (*[https://github.com/fsharp/fsharpx/](https://github.com/fsharp/fsharpx/)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `ODataProvider` example, we’ll start by referencing some assemblies
    and opening some namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Because I created this script as part of a project that included the `FSharp.TypeProviders.Regex`
    package from NuGet, I simply referenced the package directly via a relative path;
    the path to the assembly may be different on your machine depending on how you
    obtained the assembly and its version.
  prefs: []
  type: TYPE_NORMAL
- en: With the assemblies referenced and the common namespaces opened, we can now
    create the type provider. Creating a `RegexProvider` is similar to creating the
    `ODataService` except that, instead of a URI, `RegexProvider` takes a regular
    expression pattern. For this example, we’ll create the `RegexProvider` with a
    simple pattern that matches hexadecimal RGB values. (The space before the verbatim
    string is significant. Without the space, the compiler would try to interpret
    the string as a quoted expression, which is definitely not what we want.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `RegexProvider` works a bit differently than the `ODataService` in that
    it’s not really intended for use as a query source. Instead, we’ll write a function
    that uses the type provider to convert a hexadecimal string into a standard .NET
    `Color` instance if it matches the regular expression pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we push the supplied `color` string into the `Match`
    method of a new instance of the `colorRegex`①. The value returned by `Match` is
    similar to the `Match` object returned when we’re using regular expressions directly
    (through the `Regex` class in `System.Text.RegularExpressions`), but as you can
    see at ②, ③, and ④, it also includes named properties that match the named groups
    defined within the source regular expression! This means that you don’t have to
    fumble with magic strings to access the individual named captures!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, we merely need to pass some strings to the `convertToRgbColor`
    function. Here we invoke the function for each string in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluating this code should result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first string didn’t match the color pattern so it was not
    converted, whereas the remaining three items were converted and written accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the addition of query expressions and type providers in F# 3.0, F# took
    massive strides toward being an even better language for data-intensive development
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Query expressions bring the power of LINQ to the language with an idiomatic
    flair. With them, you can easily compose complex queries for analyzing and presenting
    data from a variety of data sources. Furthermore, the extensible nature of query
    expressions makes them well suited for more complex needs.
  prefs: []
  type: TYPE_NORMAL
- en: Type providers further expand upon F#’s already rich data experience by abstracting
    away the details of creating types that map to different data sources. They greatly
    improve a developer’s ability to perform exploratory programming in data-centric
    scenarios because the developer doesn’t need to be as concerned about how to access
    the data. Finally, type providers can add an extra degree of safety to the code
    by detecting changes to the underlying data structures as part of the build process.
  prefs: []
  type: TYPE_NORMAL
