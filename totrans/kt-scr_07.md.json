["```\n❶ // Import Kotlin math functions.\nimport kotlin.math.sin\nimport kotlin.math.cos\nimport kotlin.math.PI\nimport kotlin.math.sqrt\nimport kotlin.math.pow\nimport kotlin.math.abs\n\n❷ // Set global parameters.\nval v0 = 70             // m/s\nval g = 9.8             // m/s2\nval h0 = 25             // m\nval target = 400        // m\nval TOL = 1.0e-7\n\nprivate val f = :: projectile\n\n❸ // The interval [x1, x2] needs to enclose the root.\nval x1 = 10.0    // in degrees\nval x2 = 30.0    // in degrees\n\nfun main() {\n    println(\"\\n*** Firing angle for hitting a target ***\\n\")\n\n  ❹ if (f(x1) * f(x2) < 0) {\n        println(\"...Initial guesses are valid...\")\n        val root = bisection(x1, x2)\n        val rootFormatted = String.format(\"%.2f\", root)\n        println(\"The firing angle to hit the target is:\" +\n                \"\\n$rootFormatted degrees\")\n    } else {\n        println(\"\\n...Initial guesses are not valid...\\n\")\n    }\n}\n\nfun projectile(angle: Double): Double {\n  ❺ val x = angle * PI / 180.0\n    return target - (v0 * cos(x) / g) *\n            (v0 * sin(x) + sqrt((v0 * sin(x)).pow(2) + 2 * g * h0))\n}\n\nfun bisection(_x1: Double, _x2: Double): Double {\n    var x1 = _x1\n    var x2 = _x2\n  ❻ var x = (x1 + x2) / 2.0\n\n  ❼ while (abs(f(x)) >= TOL) {\n        if (f(x) * f(x2) > 0) {\n            x2 = x\n        } else x1 = x\n        x = (x1 + x2) / 2.0\n    }\n    return x\n}\n```", "```\n*** Firing angle for hitting a target ***\n\n...Initial guesses are valid...\nThe firing angle to hit the target is:\n21.91 degrees\n```", "```\n// Import JavaFX features.\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.canvas.Canvas\nimport javafx.scene.canvas.GraphicsContext\nimport javafx.scene.layout.Pane\nimport javafx.scene.paint.Color\nimport javafx.stage.Stage\n\n// Import required math functions.\nimport kotlin.math.sin\nimport kotlin.math.cos\nimport kotlin.math.tan\nimport kotlin.math.atan\nimport kotlin.math.pow\nimport kotlin.math.PI\nimport kotlin.math.sqrt\n\n// Set global parameters and variables.\nval baseWidth = 6.5  // m\nval xMaxJet = doubleArrayOf(2.25, 2.55, 2.85, 3.0)\nval yMaxJet = doubleArrayOf(1.5, 3.0, 4.25, 5.5)\nval angle = DoubleArray(4)\nval vel = DoubleArray(4)\nval g = 9.8  // m/s2\n\n// Set canvas properties.\nval xMin = -0.5\nval xMax = baseWidth + 0.5\nval yMin = -0.5\nval yMax = 6.0\nval xRange = xMax - xMin\nval yRange = yMax - yMin\nval canvasW = 700.0\nval canvasH = (canvasW/ xRange) * yRange\n```", "```\n// the primary application class\nclass ShapeOfWater : Application() {\n    override fun start(stage: Stage) {\n        val root = Pane()\n        val canvas = Canvas(canvasW, canvasH)\n        val gc = canvas.graphicsContext2D\n        gc.translate(0.0, canvas.height)\n        gc.scale(1.0, -1.0)\n        root.children.add(canvas)\n        val scene = Scene(root, canvasW, canvasH)\n        scene.fill = Color.WHITE\n        stage.title = \"Shape of Water\"\n        stage.scene = scene\n        stage.show()\n\n        // problem-specific section\ngetAngleAndVel()\n        getTrajectories(gc)\n        println(\"\\nNozzle velocities:\")\n        for (v in vel) print(String.format(\"%.2f  \", v))\n        println(\"\\nNozzle angles:\")\n        for (theta in angle)\n             print(String.format(\"%.2f  \", theta))\n    }\n}\n\nfun main() {\n    Application.launch(ShapeOfWater::class.java)\n}\n```", "```\nfun getAngleAndVel() {\n    var index = 0\n\n  ❶ xMaxJet.zip(yMaxJet) {x, y ->\n        val theta = atan(2 * y / x)\n      ❷ angle[index] = theta * 180/ PI\n        vel[index] = sqrt(2 * g * y) / sin(theta)\n index += 1\n    }\n}\n```", "```\nfun getTrajectories(gc: GraphicsContext) {\n    // Generate trajectories by iterating over time.\n    vel.zip(angle) {v, _theta ->\n        val theta = _theta * PI / 180\n      ❶ val tmax = 1.1 * v * sin(theta)/g\n        val delt = tmax/50\n\n        // Calculate trajectory coordinates.\n        var t = 0.0\n      ❷ while (t <= tmax) {\n            val x = v * cos(theta) * t\n            val y = x * tan(theta) -\n                (g / (2 * (v * cos(theta)).pow(2))) * x.pow(2)\n\n            // Draw points on canvas.\n          ❸ gc.fillOval(canvasW * (x - xMin)/ xRange,\n                        canvasH * (y - yMin)/ yRange, 3.0, 3.0)\n          ❹ gc.fillOval(\n               canvasW * ((baseWidth - x) - xMin)/ xRange,\n               canvasH * (y - yMin)/ yRange, 3.0, 3.0)\n            t += delt\n        }\n    }\n}\n```", "```\nNozzle velocities:\n6.78  8.33  9.63  10.76\nNozzle angles:\n53.13  66.97  71.46  74.74\n```", "```\n// import block\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.control.ScrollPane\nimport javafx.scene.layout.VBox\nimport javafx.scene.paint.Color\nimport javafx.scene.chart.*\nimport javafx.stage.Stage\nimport java.text.DecimalFormat\nimport kotlin.math.PI\nimport kotlin.math.sin\nimport kotlin.math.sqrt\n\n// data classes\ndata class XYChartData(val x: Double, val y: Double)\ndata class PendulumData(val theta: Double, val omega: Double,\n                         val t: Double)\n\n// problem definition and global parameters\nval theta0 = -PI/6  // angular displacement at t = 0, rad\nval omega0 = 0.0    // angular velocity at t = 0, rad/s\nval l = 0.4         // length, m\nval g = 9.81        // acceleration due to gravity, m/s2\nval n = 100         // intervals\nval gamma = 0.6     // drag coefficient\n\nclass SimplePendulum : Application() {\n    override fun start(primaryStage: Stage) {\n        val root = VBox()\n        val scroll = ScrollPane()\n scroll.content = root\n        val scene = Scene(scroll, 550.0, 600.0, Color.WHITE)\n        primaryStage.title = \"Simple Pendulum\"\n        primaryStage.scene = scene\n        primaryStage.show()\n\n        // Generate pendulum state data.\n      ❶ val state: List<PendulumData> =\n            simplePendulumWithDrag(theta0, omega0,\n                  l, g, n, gamma)\n        // Create (x, y) series for plotting.\n        val list1 = mutableListOf<XYChartData>()\n        val list2 = mutableListOf<XYChartData>()\n        val list3 = mutableListOf<XYChartData>()\n\n      ❷ for (item in state) {\n            val (theta, omega, t) = item\n            list1 += XYChartData(t, theta)  // t along x-axis\n            list2 += XYChartData(t, omega)  // t along x-axis\n            list3 += XYChartData(theta, omega)\n        }\n\n        // Call singleXYChart() to generate plots.\n        val xyChart1 =\n            singleXYChart(list1,\n                title = \"Angular Displacement over Time\",\n                xLabel = \"Time (sec)\",\n                yLabel = \"Angular displacement (rad)\")\n        val xyChart2 =\n            singleXYChart(list2,\n                title = \"Angular Velocity over Time\",\n                xLabel = \"Time (sec)\",\n                yLabel = \"Angular velocity (rad/sec)\")\n        val xyChart3 =\n            singleXYChart(list3,\n                title = \"Phase-Space Plot (omega vs. theta)\",\n                xLabel = \"Angular displacement (rad)\",\n                yLabel = \"Angular velocity (rad/sec)\",\n                sort = \"NONE\")\n\n        // Add the charts to the root (VBox) object.\n      ❸ root.children.addAll(xyChart1, xyChart2, xyChart3)\n    }\n}\n\nfun main() {\n    Application.launch(SimplePendulum::class.java)\n}\n```", "```\nfun simplePendulumWithDrag(\n        theta0 : Double,\n        omega0 : Double,\n l: Double, g: Double, n: Int,\n        gamma: Double = 0.0): List<PendulumData> {\n\n    // Set local variables, parameters, and list.\n    val alpha = g / l\n    // Calculate period for small displacement.\n  ❶ val T = 2 * PI * sqrt(l/g)\n  ❷ val dt = T / n\n    val Nmax = 4 * n\n    val df = DecimalFormat(\"##.####\")\n\n    var omegaOld: Double; var omegaNew: Double\n    var thetaOld: Double; var thetaNew: Double\n    var timeOld: Double;  var timeNew: Double\n    val pList = mutableListOf<PendulumData>()\n\n    // Initialize for t = 0.\n    thetaOld = theta0\n    omegaOld = omega0\n    timeOld = 0.0\n    pList += PendulumData(theta0, omega0, 0.0)\n\n    // Calculate and save state variables.\n  ❸ for (k in 1..Nmax) {\n        omegaNew = omegaOld –\n            (alpha * sin(thetaOld) + gamma * omegaOld) * dt\n        thetaNew = thetaOld + omegaNew * dt // Euler-Cromer\n        timeNew = timeOld + dt\n      ❹ pList += PendulumData(thetaNew, omegaNew, timeNew)\n\n      ❺ omegaOld = omegaNew\n        thetaOld = thetaNew\n        timeOld = timeNew\n    }\n\n    println(\"\\n*** Simple Pendulum Simulation ***\\n\")\n    println(\"length l: $l m\")\n    println(\"theta0: ${df.format(theta0*180/PI)} degrees\")\n    println(\"omega0: ${df.format(omega0*180/PI)} rad/sec\")\n    println(\"gamma: ${df.format(gamma)}\")\n    println(\"dt: ${df.format(dt)} sec\")\n    println(\"Nmax: $Nmax intervals\")\n    println(\"Simulation length: ${df.format(Nmax*dt)} sec\")\n\n    return pList\n}\n```", "```\nfun singleXYChart(data: List<XYChartData>,\n          title: String  = \"\",\n          xLabel: String = \"x-axis\",\n          yLabel: String = \"y-axis\",\n          sort: String = \"default\"): LineChart<Number, Number> {\n\n    // Define axes.\n    val xAxis = NumberAxis()\n    val yAxis = NumberAxis()\n    xAxis.label = xLabel\n    yAxis.label = yLabel\n\n // Create LineChart.\n    val lineChart = LineChart(xAxis, yAxis)\n    lineChart.title = title\n  ❶ lineChart.createSymbols = false\n  ❷ lineChart.isLegendVisible = false\n  ❸ if (sort == \"NONE\")\n    lineChart.axisSortingPolicy = LineChart.SortingPolicy.NONE\n\n    // Define series.\n    val series = XYChart.Series<Number, Number>()\n\n    // Populate series with data.\n  ❹ for (item in data) {\n        val (x, y) = item\n        series.data.add(XYChart.Data(x, y))\n    }\n\n    // Assign series with data to LineChart.\n    lineChart.data.add(series)\n\n    // Return LineChart object.\n    return lineChart\n}\n```", "```\n*** Simple Pendulum Simulation ***\n\nlength l: 0.4 m\ntheta0: -30 degrees\nomega0: 0 rad/sec\ngamma: 0.6\ndt: 0.0127 sec\nNmax: 400 intervals\nSimulation length: 5.075 sec\n```", "```\n// import block\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.control.ScrollPane\nimport javafx.scene.layout.VBox\nimport javafx.scene.paint.Color\nimport javafx.scene.chart.*\nimport javafx.stage.Stage\nimport java.text.DecimalFormat\nimport kotlin.math.exp\nimport kotlin.math.ln\nimport java.text.DecimalFormat\n\n// data classes\n❶ data class State(\n    val time: Double,\n    val Temp: Double\n)\n\n// problem definition and global parameters\nval coffeeT0 = 92.0      // degrees Celsius\nval coffeeV = 250.0      // mL\nval coffeeS = 4.190      // J/(gm C) - assumed same as water\nval coffeeD = 1.0        // gm/mL - assumed same as water\nval coffeeK = 0.0116     // 1/min\n\nval milkT0 = 4.0         // degrees Celsius\nval milkV = 25.0         // mL\nval milkS = 3.890        // J/(gm C)\nval milkD = 1.035        // gm/mL\n\nval T_ambient = 20.0     // degrees Celsius\nval timeMax = 25.0       // min (length of drive)\n❷ val timeStep = 0.25      // min\nval df = DecimalFormat(\"#.##\")\n\n// application class\nclass MixCoffeeAndMilk : Application() {\n    override fun start(primaryStage: Stage) {\n        val root = VBox()\n        val scroll = ScrollPane()\n        scroll.content = root\n        val scene = Scene(scroll, 550.0, 600.0, Color.WHITE)\n        primaryStage.title = \"Coffee Cooling Profile\"\n        primaryStage.scene = scene\n        primaryStage.show()\n\n        // Execute steps for coffee cooling process.\n        println(\"\\n  *** Coffee Cooling Problem ***  \\n\")\n\n        // step 1:\n      ❸ val state1 =\n            newtonCooling(T0 = coffeeT0, Ta = T_ambient,\n                          k = coffeeK,tMax = timeMax, dt = timeStep)\n        printTimeAndTemp(state1.last(), 1)\n\n // step 2:\n      ❹ val finalT1 =\n            tempAfterMixing(d1 = coffeeD, v1 = coffeeV, s1 = coffeeS,\n                            T1 = state1.last().Temp,\n                            d2 = milkD, v2 = milkV,\n                            s2 = milkS, T2 = milkT0)\n        println(\"step 2: final temp with milk: \" +\n                \"${df.format(finalT1)} degrees Celsius\\n\")\n\n        // step 3:\n      ❺ val initT2 =\n            tempAfterMixing(d1 = coffeeD, v1 = coffeeV, s1 = coffeeS,\n                            T1 = coffeeT0, d2 = milkD, v2 = milkV,\n                            s2 = milkS, T2 = milkT0)\n        println(\"step 3: initial temp with milk: \" +\n                \"${df.format(initT2)} degrees Celsius\")\n\n        // step 4:\n      ❻ val state2 =\n            newtonCooling(T0 = initT2, Ta = T_ambient, k = coffeeK,\n                          tMax = timeMax, dt = timeStep)\n        printTimeAndTemp(state2.last(), 4)\n\n        // step 5:\n      ❼ val state3 =\n            newtonCooling(T0 = finalT1, Ta = T_ambient,\n                          k = coffeeK,tMax = timeMax, dt = timeStep,\n                          start = timeMax)\n\n      ❽ val state4 =\n            newtonCooling(T0 = state2.last().Temp,\n                          Ta = T_ambient, k = coffeeK,\n                          tMax = timeMax, dt = timeStep, start = timeMax)\n\n        val states =\n            listOf(state1, state2, state3, state4)\n\n        createCoolingChart(root, states = states)\n    }\n}\n\nfun main() {\n    Application.launch(MixCoffeeAndMilk::class.java)\n}\n```", "```\nfun printTimeAndTemp(datapoint: State, step: Int) {\n    val (endTime, endTemp) = datapoint\n\n    println(\"step $step: end time: ${df.format(endTime)} minutes\")\n    println(\"step $step: end temp: ${df.format(endTemp)} \" +\n            \"degrees Celsius\")\n}\n```", "```\n *** Coffee Cooling Problem ***\n\nstep 1: end time: 25 minutes\nstep 1: end temp: 73.87 degrees Celsius\nstep 2: final temp with milk: 67.75 degrees Celsius\nstep 3: initial temp with milk: 84.29 degrees Celsius\nstep 4: end time: 25 minutes\nstep 4: end temp: 68.1 degrees Celsius\n```", "```\nfun newtonCooling(T0: Double, Ta: Double, k:Double,\n                  tMax: Double, dt: Double,\n                  start: Double = 0.0): List<State> {\n    val state = mutableListOf<State>()\n    var t = 0.0\n\n    while (t <= tMax) {\n      ❶ val temp = Ta + (T0 - Ta)*exp(-k * t)\n      ❷ state += State(t+start, temp)\n t += dt\n    }\n    return state\n}\n\nfun tempAfterMixing(\n    d1: Double, v1: Double, s1: Double, T1: Double,\n    d2: Double, v2: Double, s2: Double, T2: Double\n    ): Double {\n\n    return (d1 * v1 * s1 * T1 + d2 * v2 * s2 * T2) /\n           (d1 * v1 * s1 + d2 * v2 * s2)\n}\n```", "```\nfun createCoolingChart(root: VBox, states: List<List<State>>) {\n\n    val xyChart =\n        singleXYChart(states,\n            title = \"Temperature of Coffee over Time\",\n            xLabel = \"Time\",\n            yLabel = \"Temperature (degrees Celsius)\")\n\n   root.children.add(xyChart)\n}\n```", "```\n// animation-related tools\nimport javafx.animation.KeyFrame\nimport javafx.animation.Timeline\nimport javafx.util.Duration\n\n// graphics-related tools\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.canvas.Canvas\nimport javafx.scene.canvas.GraphicsContext\nimport javafx.scene.layout.Pane\nimport javafx.scene.paint.Color\nimport javafx.stage.Stage\n\n// math functions\nimport kotlin.math.*\n\n// data class\ndata class Star(\n    val mass: Double,\n    val size: Double,\n    var x: Double,\n    var y: Double,\n    var vx: Double,\n    var vy: Double,\n    var xOld: Double = 0.0,\n    var yOld: Double = 0.0,\n var trailCount: Int = 0,\n    val color: Color = Color.GOLD\n)\n\n// problem definition and global declarations\n// initial state of the binary system\nval stars = listOf(\n    Star(mass = 0.73606507, size = 40.0, x = -35.0, y = 0.0,\n         vx = 0.0, vy = 0.3045865, color = Color.BLACK),\n    Star(mass = 0.50121162, size = 25.0, x = 51.4, y = 0.0,\n         vx = 0.0, vy = -0.447307098, color = Color.BLACK)\n)\nval G = 4 * PI * PI\n\n// Set canvas/animation parameters.\nval canvasW = 800.0\nval canvasH = 800.0\nval durationMillis = 4.0\nval frameCountMax = 50_000\n\n// parameters related to star trails\nval TRAIL_CODE = \"YES\"\nval trails = Array(2) {ArrayList<Pair<Double,Double>>()}\nval trailMAX = 6500\nval trailSize = 2.0\nval scaleFactor = 4\n```", "```\nclass SimulateBinarySystem : Application() {\n    override fun start(stage: Stage) {\n        val root = Pane()\n        val canvas = Canvas(canvasW, canvasH)\n        val gc = canvas.graphicsContext2D\n      ❶ gc.translate((canvas.width)/2.0, (canvas.height)/2.0)\n      ❷ gc.scale(1.0, -1.0)\n        root.children.add(canvas)\n\n        val scene = Scene(root, canvasW, canvasH)\n        //scene.fill = Color.WHITE\n        stage.title = \"Binary System Simulation\"\n        stage.scene = scene\n        stage.show()\n\n        // -----------simulation block-----------\n        // Set the background and initial positions.\n      ❸ initialPositions(gc)\n\n        // Start animation.\n      ❹ val t = Timeline()\n        var frameCount = 0\n val dt = 1.0\n        val iterMax = 1\n\n      ❺ val k = KeyFrame(Duration.millis(durationMillis), {\n            for (i in 1..iterMax)\n                updateStarPositions(stars, dt)\n            drawStars(gc)\n            if (TRAIL_CODE == \"YES\")\n                updateAndDrawTrails(gc)\n            frameCount += 1\n            // Check the stopping condition.\n          ❻ if (frameCount >= frameCountMax) {\n                println(\"maximum limit for frameCount reached\")\n                t.stop()\n            }\n        })\n      ❼ t.keyFrames.add(k)\n        t.cycleCount = Timeline.INDEFINITE\n        t.play()\n    }\n}\n\nfun main() {\n    Application.launch(SimulateBinarySystem::class.java)\n}\n```", "```\nfun initialPositions(gc: GraphicsContext) {\n    drawAxes(gc)\n    stars.forEachIndexed {index, star ->\n        gc.fill = star.color\n        gc.fillOval(\n            scaleFactor * star.x - star.size/2,\n            scaleFactor * star.y - star.size/2,\n            star.size, star.size)\n\n        // Place the tracers to initial star position.\n        if (TRAIL_CODE == \"YES\") {\n            for (i in 1..trailMAX) {\n                trails[index].add(Pair(star.x, star.y))\n            }\n        }\n    }\n}\n\nfun drawAxes(gc: GraphicsContext) {\n    // Draw the x- and y-axes.\n    with(gc) {\n        setLineDashes()\n        lineWidth = 0.25\n        stroke = Color.BLACK\n        strokeLine(-canvasW/2,0.0, canvasW/2,0.0)\n        strokeLine(0.0,-canvasH/2, 0.0,canvasH/2)\n    }\n}\n```", "```\nfun updateStarPositions(stars: List<Star>, dt: Double) {\n    val rx = stars[1].x - stars[0].x\n    val ry = stars[1].y - stars[0].y\n    val r = sqrt(rx * rx + ry * ry)\n\n  ❶ val force =\n        G * stars[0].mass * stars[1].mass / (r * r)\n\n    var sign = 1\n    for (star in stars) {\n      ❷ // Update the acceleration, velocity, and position of stars.\n        val acceleration = force / star.mass\n        val ax = acceleration * rx / r\n        val ay = acceleration * ry / r\n        star.vx += sign * ax * dt\n        star.vy += sign * ay * dt\n\n      ❸ // These will be needed for updating trails.\n        star.xOld = star.x\n        star.yOld = star.y\n\n        star.x += star.vx * dt\n        star.y += star.vy * dt\n      ❹ sign = -1\n    }\n}\n```", "```\nfun drawStars(gc: GraphicsContext) {\n  ❶ gc.clearRect(-canvasW/2, -canvasH/2, canvasW, canvasH)\n  ❷ drawAxes(gc)\n\n    // Connect the centers of the stars.\n  ❸ with (gc) {\n        lineWidth = 0.5\n        stroke = Color.BLACK\n        setLineDashes(2.0,4.0,4.0,2.0)\n        strokeLine(\n            scaleFactor*stars[0].x,\n            scaleFactor*stars[0].y,\n            scaleFactor*stars[1].x,\n            scaleFactor*stars[1].y)\n    }\n\n    // Draw the stars using updated positions.\n  ❹ for (star in stars) {\n        gc.fill = star.color\n        gc.fillOval(\n            scaleFactor * star.x - star.size/2,\n            scaleFactor * star.y - star.size/2,\n            star.size, star.size)\n    }\n}\n```", "```\nfun updateAndDrawTrails(gc: GraphicsContext) {\n    // Update the trails.\n    stars.forEachIndexed {index, star ->\n      ❶ if (star.trailCount >= trailMAX) star.trailCount = 0\n      ❷ trails[index][star.trailCount] =\n                      Pair(star.xOld, star.yOld)\n        star.trailCount += 1\n    }\n\n    // Draw the trails.\n    trails.forEachIndexed {index, trail ->\n      ❸ gc.fill = stars[index].color\n      ❹ for (point in trail) {\n            gc.fillOval(\n                scaleFactor * point.first - trailSize / 2,\n                scaleFactor * point.second - trailSize / 2,\n                trailSize, trailSize\n            )\n        }\n    }\n}\n```"]