["```\nmy_hash[:key] = \"value\"\n```", "```\nsome_value = internal_hash_function(:key)\n```", "```\nsome_value % 11 = 2\n```", "```\nmy_hash[:key2] = \"value2\"\n```", "```\ninternal_hash_function(:key2) % 11 = 5\n```", "```\np my_hash[:key]\n => \"value\"\n```", "```\nsome_value = internal_hash_function(:key)\n```", "```\nsome_value % 11 = 2\n```", "```\ninternal_hash_function(:key2) % 11 = 5\n```", "```\n    require 'benchmark'\n\n 21.times do |exponent|\n\n      target_key = nil\n\n   size = 2**exponent\n      hash = {}\n   (1..size).each do |n|\n        index = rand\n     target_key = index if n > size/2 && target_key.nil?\n     hash[index] = rand\n      end\n\n      GC.disable\n\n      Benchmark.bm do |bench|\n        bench.report(\"retrieving an element\n                      from a hash with #{size} elements 10000 times\") do\n          10000.times do\n         val = hash[target_key]\n          end\n        end\n      end\n\n      GC.enable\n    end\n```", "```\nmy_hash[:key3] = \"value3\"\nmy_hash[:key4] = \"value4\"\nmy_hash[:key5] = \"value5\"\nmy_hash[:key6] = \"value6\"\n```", "```\n    static void\n    rehash(table)\n        register st_table *table;\n    {\n        register st_table_entry *ptr, *next, **new_bins;\n        int i, old_num_bins = table->num_bins, new_num_bins;\n        unsigned int hash_val;\n     new_num_bins = new_size(old_num_bins+1);\n        new_bins = (st_table_entry**)Calloc(new_num_bins,\n                                            sizeof(st_table_entry*));\n     for(i = 0; i < old_num_bins; i++) {\n            ptr = table->bins[i];\n            while (ptr != 0) {\n                next = ptr->next;\n             hash_val = ptr->hash % new_num_bins;\n             ptr->next = new_bins[hash_val];\n                new_bins[hash_val] = ptr;\n                ptr = next;\n            }\n        }\n     free(table->bins);\n        table->num_bins = new_num_bins;\n        table->bins = new_bins;\n    }\n```", "```\n    require 'benchmark'\n\n 100.times do |size|\n\n      hashes = []\n   10000.times do\n        hash = {}\n        (1..size).each do\n          hash[rand] = rand\n        end\n        hashes << hash\n      end\n\n      GC.disable\n\n      Benchmark.bm do |bench|\n        bench.report(\"adding element number #{size+1}\") do\n          10000.times do |n|\n         hashes[n][size] = rand\n          end\n        end\n      end\n\n      GC.enable\n    end\n```", "```\n    /*\n    Table of prime numbers 2^n+a, 2<=n<=30.\n    */\n    static const unsigned int primes[] = {\n   8 + 3,\n   16 + 3,\n   32 + 5,\n      64 + 3,\n      128 + 3,\n      256 + 27,\n      512 + 9,\n    --*snip*--\n```", "```\n#define ST_DEFAULT_MAX_DENSITY 5\n```", "```\nif (table->num_entries/(table->num_bins) > ST_DEFAULT_MAX_DENSITY) {\n  rehash(table);\n```", "```\nif ((table)->num_entries >\n    ST_DEFAULT_MAX_DENSITY * (table)->num_bins) {\n  rehash(table);\n```", "```\nbin_index = internal_hash_function(key) % bin_count\n```", "```\n2 = hash(:key) % 11\n```", "```\n$ **irb**\n> **\"abc\".hash**\n => 3277525029751053763\n> **\"abd\".hash**\n => 234577060685640459\n> **1.hash**\n => -3466223919964109258\n> **2.hash**\n => -2297524640777648528\n```", "```\n> **\"abc\".hash**\n => 3277525029751053763\n> **\"abd\".hash**\n => 234577060685640459\n```", "```\n    require 'benchmark'\n\n class KeyObject\n      def eql?(other)\n        super\n      end\n    end\n\n    21.times do |exponent|\n\n      target_key = nil\n\n      size = 2**exponent\n      hash = {}\n      (1..size).each do |n|\n     index = KeyObject.new\n        target_key = index if n > size/2 && target_key.nil?\n        hash[index] = rand\n      end\n\n      GC.disable\n\n      Benchmark.bm do |bench|\n        bench.report(\"retrieving an element\n                       from a hash with #{size} elements 10000 times\") do\n          10000.times do\n            val = hash[target_key]\n          end\n        end\n      end\n\n      GC.enable\n\n    end\n```", "```\n    require 'benchmark'\n\n    class KeyObject\n      def hash\n     4\n      end\n      def eql?(other)\n        super\n      end\n    end\n\n    21.times do |exponent|\n\n      target_key = nil\n\n      size = 2**exponent\n      hash = {}\n      (1..size).each do |n|\n        index = KeyObject.new\n        target_key = index if n > size/2 && target_key.nil?\n        hash[index] = rand\n      end\n\n      GC.disable\n\n      Benchmark.bm do |bench|\n        bench.report(\"retrieving an element\n                      from a hash with #{size} elements 10000 times\") do\n          10000.times do\n            val = hash[target_key]\n          end\n        end\n      end\n\n      GC.enable\n    end\n```"]