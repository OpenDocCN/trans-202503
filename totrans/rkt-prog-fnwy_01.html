<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_1"/><span class="big">1</span><br/>RACKET BASICS</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Let’s begin with an introduction to some basic concepts in Racket. In this chapter, we’ll cover some of the fundamental data types that will be used throughout the book. You’ll want to pay particular attention to the discussion of lists, which underpin much of Racket’s functionality. We’ll also cover how to assign values to variables and various ways to manipulate strings, and along the way, you’ll encounter a first look at vectors and structs. The chapter wraps up with a discussion on how to produce formatted output.</p>&#13;
<h3 class="h3" id="ch00lev1sec_1">Atomic Data</h3>&#13;
<p class="noindent"><em>Atomic data</em> is the basic building block of any programming language, and Racket is no exception. Atomic data refers to elementary data types that are typically considered to be indivisible entities; that is, numbers like <code>123</code>, strings like <code>"hello there"</code>, and identifiers such as <code>pi</code>. Numbers and strings <span epub:type="pagebreak" id="page_2"/>evaluate to themselves; if bound, identifiers evaluate to their associated value:</p>&#13;
<pre>&gt; <span class="codestrong1">123</span> &#13;
123&#13;
&#13;
&gt; <span class="codestrong1">"hello there"</span>&#13;
"hello there"&#13;
&#13;
&gt; <span class="codestrong1">pi</span>&#13;
3.141592653589793</pre>&#13;
<p class="indent">Evaluating an unbound identifier results in an error. To prevent an unbound identifier from being evaluated, you can prefix it with an apostrophe:</p>&#13;
<pre>&gt; <span class="codestrong1">alpha</span>&#13;
. . alpha: undefined;&#13;
  cannot reference an identifier before its definition&#13;
  &#13;
&gt; <span class="codestrong1">'alpha</span>&#13;
'alpha</pre>&#13;
<p class="indent">We can organize atomic data together using lists, which are covered next.</p>&#13;
<h3 class="h3" id="ch00lev1sec_2">Lists</h3>&#13;
<p class="noindent">In Racket, lists are the primary non-atomic data structures (that is, something other than a number, string, and so on). Racket relies heavily on lists because it’s a descendant of <em>Lisp</em> (short for LISt Processing). Before we get into the details, let’s look at some simple representative samples.</p>&#13;
<h4 class="h4" id="ch00lev2sec_5"><strong><em>A First Look at Lists</em></strong></h4>&#13;
<p class="noindent">Here’s how to make a list with some numbers:</p>&#13;
<pre>&gt; <span class="codestrong1">(list 1 2 3)</span></pre>&#13;
<p class="indent">Notice the syntax. Lists typically begin with an open parenthesis, <code>(</code>, followed by a list of space-separated items and end with a closed parenthesis, <code>)</code>. The first item in the list is normally an identifier that indicates how the list is to be evaluated.</p>&#13;
<p class="indent">Lists can also contain other lists.</p>&#13;
<pre>&gt; <span class="codestrong1">(list 1 (list "two" "three") 4 5)</span></pre>&#13;
<p class="noindent">which prints as</p>&#13;
<pre>'(1 ("two" "three") 4 5)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_3"/>Note the apostrophe (or tick mark) at the beginning of the last example. This is an alias for the <code>quote</code> keyword. If you want to enter a literal list (a list that is simply accepted as is), you can enter it <em>quoted</em>:</p>&#13;
<pre>&gt; <span class="codestrong1">(quote (1 ("two" "three") 4 5))</span></pre>&#13;
<p class="noindent">or</p>&#13;
<pre>&gt; <span class="codestrong1">'(1 ("two" "three") 4 5)</span></pre>&#13;
<p class="indent">Either of which print as</p>&#13;
<pre>'(1 ("two" "three") 4 5)</pre>&#13;
<p class="indent">While <code>list</code> and <code>quote</code> seem like two equivalent ways to build lists, there’s an important difference between them. The following sequence illustrates the difference.</p>&#13;
<pre>&gt; <span class="codestrong1">(quote (3 1 4 pi))</span>&#13;
'(3 1 4 pi)&#13;
&#13;
&gt; <span class="codestrong1">(list 3 1 4 pi)</span>&#13;
'(3 1 4 3.141592653589793)</pre>&#13;
<p class="indent">Notice that <code>quote</code> returns the list exactly as it was entered, but when <code>list</code> was used, the identifier <code>pi</code> was evaluated and its value was substituted in its place. In general, in a non-quoted list, <em>all</em> identifiers are evaluated and replaced by their associated values. The keyword <code>quote</code> plays an important role in macros and symbolic expression evaluation, which are advanced topics that we will not cover in this text.</p>&#13;
<p class="indent">One criticism of the Lisp family of languages is the proliferation of parentheses. To alleviate this, Racket allows either square brackets or curly brackets to be used instead. For example, it’s perfectly acceptable to write the last expression as</p>&#13;
<pre>&gt; <span class="codestrong1">'(1 ["two" "three"] 4 5)</span></pre>&#13;
<p class="noindent">or</p>&#13;
<pre>&gt; <span class="codestrong1">'(1 {"two" "three"} 4 5)</span></pre>&#13;
<h4 class="h4" id="ch00lev2sec_6"><strong><em>S-Expressions</em></strong></h4>&#13;
<p class="noindent">A list is a special case of something called an <em>s-expression</em>. An s-expression (or symbolic expression) is defined as being one of two cases:</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong>Case 1</strong> The s-expression is an atom.</p>&#13;
<p class="noindent"><strong>Case 2</strong> The s-expression is expression of the form <code>(x . y)</code> where <em>x</em> and <em>y</em> are other s-expressions.</p>&#13;
</div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_4"/>The form <code>(x . y)</code> is typically called a <em>pair</em>. This is a special syntactic form used to designate a <em>cons</em> cell, which we will have much more to say about shortly.</p>&#13;
<p class="indent">Let’s see if we can construct a few examples of s-expressions. Ah, how about <code>1</code>? Yes, it’s an atom, so it satisfies case 1. What about <code>"spud"</code>? Yep, strings are atoms, and thus <code>"spud"</code> is also an s-expression. We can combine these to make another s-expression: <code>(1 . "spud")</code>, which satisfies case 2. Since <code>(1 . "spud")</code> is an s-expression, case 2 allows us to form another s-expression as <code>((1 . "spud") . (1 . "spud"))</code>. We can see from this that s-expressions are actually tree-like structures as illustrated in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>. (Technically s-expressions form a <em>binary tree</em>, where non-leaf nodes have exactly two child nodes).</p>&#13;
<div class="image"><img alt="Image" src="../images/01fig01.jpg"/></div>&#13;
<p class="figcap" id="ch1fig1"><em>Figure 1-1: <code>((a . (2 . pi) . x))</code></em></p>&#13;
<p class="indent">In <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>, the square boxes are leaf nodes representing atoms, and the circle nodes represent pairs. We’ll see how s-expressions are used to construct lists in the next section.</p>&#13;
<h4 class="h4" id="ch00lev2sec_7"><strong><em>List Structure</em></strong></h4>&#13;
<p class="noindent">As mentioned above, a list is a special case of an s-expression. The difference is that, in a list, if we follow the rightmost elements in each pair, the final node is a special atomic node called <em>nil</em>. <a href="ch01.xhtml#ch1fig2">Figure 1-2</a> illustrates what the list ’<code>(1 2 3)</code>—which as an s-expression is <code>(1 . (2 . (3 . nil)))</code>—looks like internally.</p>&#13;
<div class="image"><img alt="Image" src="../images/01fig02.jpg"/></div>&#13;
<p class="figcap" id="ch1fig2"><em>Figure 1-2: List structure</em></p>&#13;
<p class="indent">We’ve flattened the tree to better resemble a list. We’ve also expanded each pair node (aka a <em>cons cell</em>) to show that it consists of two cells, each of which contains a pointer to another node. These pointer cells, for historical reasons, are called <em>car</em> and <em>cdr</em> respectively (the names of computer registers <span epub:type="pagebreak" id="page_5"/>used in early versions of Lisp). We can see that the last cdr cell in the list is pointing to nil. Nil is indicated in Racket by an empty list: ’<code>()</code> or <code>null</code>.</p>&#13;
<p class="indent">Cons cells can be created directly by using the <code>cons</code> function. Note that the <code>cons</code> function does not necessarily create a list. For example</p>&#13;
<pre>&gt; <span class="codestrong1">(cons 1 2)</span>&#13;
'(1 . 2)</pre>&#13;
<p class="noindent">produces a pair but <em>not</em> a list. However, if we use an empty list as our second s-expression</p>&#13;
<pre>&gt; <span class="codestrong1">(cons 1 '())</span>&#13;
'(1)</pre>&#13;
<p class="noindent">we produce a list with just one element.</p>&#13;
<p class="indent">Racket provides a couple of functions to test whether something is a list or a pair. Note in Racket <code>#t</code> means true and <code>#f</code> means false:</p>&#13;
<pre>&gt; <span class="codestrong1">(pair? (cons 1 2))</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(list? (cons 1 2))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(pair? (cons 1 '()))</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(list? (cons 1 '()))</span>&#13;
#t</pre>&#13;
<p class="indent">From this we can see that a list is always a pair, but the converse is not always true: a pair is not always a list.</p>&#13;
<p class="indent">Typically, <code>cons</code> is used to add an atomic value to the beginning of a list, like so:</p>&#13;
<pre>&gt; <span class="codestrong1">(cons 1 '(2 3))</span>&#13;
'(1 2 3)</pre>&#13;
<p class="indent">Racket provides special functions to access the components of a cons cell. The function <code>car</code> returns the item being pointed to by the car pointer, and correspondingly the <code>cdr</code> function returns the item being pointed to by the cdr pointer. In Racket the functions <code>first</code> and <code>rest</code> are similar to <code>car</code> and <code>cdr</code> but are not aliases for these functions, since they only work with lists. A few examples are given below.</p>&#13;
<pre>&gt; <span class="codestrong1">(car '(1 ("two" "three") 4 5))</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">(first '(1 ("two" "three") 4 5))</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">(cdr '(1 ("two" "three") 4 5))</span>&#13;
'(("two" "three") 4 5)&#13;
&#13;
&gt; <span class="codestrong1">(rest '(1 ("two" "three") 4 5))</span>&#13;
'(("two" "three") 4 5)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_6"/>List elements can also be accessed with the functions <code>second</code>, <code>third</code>, . . . , <code>tenth</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">(first '(1 2 3 4))</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">(second '(1 2 3 4))</span>&#13;
2&#13;
&#13;
&gt; <span class="codestrong1">(third '(1 2 3 4))</span>&#13;
3</pre>&#13;
<p class="indent">Finally, a value at any position can be extracted by using <code>list-ref</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">(list-ref '(a b c) 0)</span>&#13;
'a&#13;
&#13;
&gt; <span class="codestrong1">(list-ref '(a b c) 1)</span>&#13;
'b</pre>&#13;
<p class="indent">The <code>list-ref</code> function takes a list and the index of the value you want, with the list coming first. Notice that Racket uses <em>zero-based indexes</em>, meaning for any sequence of values, the first value has an index of 0, the second value has an index of 1, and so on.</p>&#13;
<h4 class="h4" id="ch00lev2sec_8"><strong><em>A Few Useful List Functions</em></strong></h4>&#13;
<p class="noindent">Let’s quickly go through a number of useful list functions.</p>&#13;
<h5 class="h5" id="ch00lev3sec_1"><strong>length</strong></h5>&#13;
<p class="noindent">To get the length of a list, you can use the <code>length</code> function, like so:</p>&#13;
<pre>&gt; <span class="codestrong1">(length '(1 2 3 4 5))</span>&#13;
5</pre>&#13;
<h5 class="h5" id="ch00lev3sec_2"><strong>reverse</strong></h5>&#13;
<p class="noindent">If you need the elements in a list reversed, you can use the <code>reverse</code> function.</p>&#13;
<pre>&gt; <span class="codestrong1">(reverse '(1 2 3 4 5))</span> ; reverse elements of a list&#13;
'(5 4 3 2 1)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_3"><span epub:type="pagebreak" id="page_7"/><strong>sort</strong></h5>&#13;
<p class="noindent">The <code>sort</code> function will sort a list. You can pass in <code>&lt;</code> to sort the list in ascending order:</p>&#13;
<pre>&gt; <span class="codestrong1">(sort '(1 3 6 5 7 9 2 4 8) &lt;)</span> &#13;
'(1 2 3 4 5 6 7 8 9)</pre>&#13;
<p class="indent">Or, if you pass in <code>&gt;</code>, it will sort the list in descending order:</p>&#13;
<pre>&gt; <span class="codestrong1">(sort '(1 3 6 5 7 9 2 4 8) &gt;)</span>&#13;
'(9 8 7 6 5 4 3 2 1)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_4"><strong>append</strong></h5>&#13;
<p class="noindent">To merge two lists together, you can use the <code>append</code> function:</p>&#13;
<pre>&gt; <span class="codestrong1">(append '(1 2 3) '(4 5 6))</span> &#13;
'(1 2 3 4 5 6)</pre>&#13;
<p class="indent">The <code>append</code> function can take more than two lists:</p>&#13;
<pre>&gt; <span class="codestrong1">(append '(1 2) '(3 4) '(5 6))</span> &#13;
'(1 2 3 4 5 6)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_5"><strong>range</strong></h5>&#13;
<p class="noindent">The <code>range</code> function will create a list of numbers given some specifications. You can pass a start value and an end value, as well as a step to increment:</p>&#13;
<pre>&gt; <span class="codestrong1">(range 0 10 2)</span>&#13;
'(0 2 4 6 8)</pre>&#13;
<p class="indent">Or, if you just pass an end value, it will start at 0 with a step of 1:</p>&#13;
<pre>&gt; <span class="codestrong1">(range 10)</span>&#13;
'(0 1 2 3 4 5 6 7 8 9)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_6"><strong>make-list</strong></h5>&#13;
<p class="noindent">Another way to make lists is using the <code>make-list</code> function:</p>&#13;
<pre>&gt; <span class="codestrong1">(make-list 10 'me)</span>&#13;
'(me me me me me me me me me me)</pre>&#13;
<p class="indent">As you can see, <code>make-list</code> takes a number and a value, and makes a list that contains that value repeated that number of times.</p>&#13;
<h5 class="h5" id="ch00lev3sec_7"><strong>null?</strong></h5>&#13;
<p class="noindent">To test whether a list is empty or not, you can use the <code>null?</code> function:</p>&#13;
<pre>&gt; <span class="codestrong1">(null? '())</span> ; test for empty list&#13;
#t&#13;
&gt; <span class="codestrong1">(null? '(1 2 3))</span>&#13;
#f</pre>&#13;
<h5 class="h5" id="ch00lev3sec_8"><span epub:type="pagebreak" id="page_8"/><strong>index-of</strong></h5>&#13;
<p class="noindent">If you need to search a list for a value, you can use <code>index-of</code>. It’ll return the index of the value if it appears:</p>&#13;
<pre>&gt; <span class="codestrong1">(index-of '(8 7 1 9 5 2) 9)</span>&#13;
3</pre>&#13;
<p class="indent">It’ll return <code>#f</code> if it doesn’t:</p>&#13;
<pre>&gt; <span class="codestrong1">(index-of '(8 7 1 9 5 2) 10)</span>&#13;
#f</pre>&#13;
<h5 class="h5" id="ch00lev3sec_9"><strong>member</strong></h5>&#13;
<p class="noindent">Another way to search lists is to use <code>member</code>, which tests whether a list contains an instance of a particular element. It returns the symbol <code>#f</code> if it does not, and returns the tail of the list starting with the first instance of the matching element if it does.</p>&#13;
<pre>&gt; <span class="codestrong1">(member 7 '(9 3 5 (6 2) 5 1 4))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(member 5 '(9 3 5 (6 2) 5 1 4))</span>&#13;
'(5 (6 2) 5 1 4)&#13;
&#13;
&gt; <span class="codestrong1">(member 6 '(9 3 5 (6 2) 5 1 4))</span>&#13;
#f</pre>&#13;
<p class="indent">Notice that in the last instance, even though 6 is a member of a sublist of the searched list, the <code>member</code> function still returns false. However, the following does work.</p>&#13;
<pre>&gt; <span class="codestrong1">(member '(6 2) '(9 3 5 (6 2) 5 1 4))</span>&#13;
'((6 2) 5 1 4)</pre>&#13;
<p class="indent">You’ll see later that in functional programming, you often need to determine whether an item is contained in a list. The <code>member</code> function not only finds the item (if it exists) but returns the actual value so that it can be used in further computations.</p>&#13;
<p class="indent">We’ll have much more to say about lists in the remainder of this text.</p>&#13;
<h3 class="h3" id="ch00lev1sec_3">Defines, Assigns, and Variables</h3>&#13;
<p class="noindent">Thus far, we’ve seen a few examples of a <em>function</em>, something that takes one or more input values and provides an output value (some form of data). The first element in a function-call expression is an identifier (the function name). <span epub:type="pagebreak" id="page_9"/>The remaining elements in a function form are the arguments to the function. These elements are each evaluated and then fed to the function, which performs some operation on its arguments and returns a value.</p>&#13;
<p class="indent">More specifically, a <em>form</em> or <em>expression</em> may define a function, execute a function call, or simply return a structure (normally a list), and may or may not evaluate all its arguments. Notice that <code>quote</code> is a different type of form (distinct from a function form, which evaluates its arguments) since it <em>does not</em> first evaluate its arguments. In the next section you’ll meet <code>define</code>, which is yet another type of form since it does not evaluate its first argument, but it does evaluate its second argument. We will meet many other types of forms as we progress through the text.</p>&#13;
<p class="indent">A <em>variable</em> is a placeholder for a value. In Racket, variables are specified by <em>identifiers</em> (specific sequences of characters) associated with one thing only. (We’ll have more to say about what constitutes a valid identifier shortly.) To define a variable, you use the <code>define</code> form. For example:</p>&#13;
<pre>&gt; <span class="codestrong1">(define a 123)</span>&#13;
&gt; <span class="codestrong1">a</span>&#13;
123</pre>&#13;
<p class="indent">Here <code>define</code> is said to <em>bind</em> the value <code>123</code> to the identifier <code>a</code>. Virtually anything can be bound to a variable. Here we’ll bind a list to the identifier <code>b</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">(define b '(1 2 3))</span>&#13;
&gt; <span class="codestrong1">b</span>&#13;
'(1 2 3)</pre>&#13;
<p class="indent">It’s possible to bind several variables in parallel:</p>&#13;
<pre>&gt; <span class="codestrong1">(define-values (x y z) (values 1 2 3))</span>&#13;
&#13;
&gt; <span class="codestrong1">x</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">y</span>&#13;
2&#13;
&#13;
&gt; <span class="codestrong1">z</span>&#13;
3</pre>&#13;
<p class="indent">Racket makes a distinction between <em>defining</em> a variable and <em>assigning</em> a value to a variable. Assignments are made with a <code>set!</code> expression. Typically any form which changes, or <em>mutates</em>, a value will end with an exclamation point. Attempting to assign to an identifier that hasn’t been previously defined will result in an ugly error message:</p>&#13;
<pre>&gt; <span class="codestrong1">(set! ice 9)</span>&#13;
. . set!: assignment disallowed;&#13;
  cannot set variable before its definition&#13;
  variable: ice</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_10"/>But this is okay:</p>&#13;
<pre>&gt; <span class="codestrong1">(define ice 9)</span>&#13;
&gt; <span class="codestrong1">ice</span>&#13;
9&#13;
&gt; <span class="codestrong1">(set! ice 32)</span>&#13;
32</pre>&#13;
<p class="indent">One way to think of this is that <code>define</code> sets up a location to store a value, and <code>set!</code> simply places a new value in a previously defined location.</p>&#13;
<p class="indent">When we speak of a variable <em>x</em> that is defined in Racket code, it will be typeset as <code>x</code>. If we’re simply speaking of the variable in the mathematical sense, it will be typeset in italics as <em>x</em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec_4">Symbols, Identifiers, and Keywords</h3>&#13;
<p class="noindent">Unlike most languages, Racket allows just about any string of characters to be used as an identifier. For example we can use <code>2x3</code> as an identifier:</p>&#13;
<pre>&gt; <span class="codestrong1">(define 2x3 7)</span>&#13;
&gt; <span class="codestrong1">2x3</span>&#13;
7</pre>&#13;
<p class="indent">You could conceivably define a function literally called <code>rags-&gt;riches</code> that would convert rags to riches (let me know when you get that working). All this seems quite bizarre, but it lends Racket an expressive power not found in many other computer languages. There are of course some restrictions to this, but aside from a few special characters such as parentheses, brackets, and arithmetic operators (even these are usually okay if they aren’t the first character), just about anything goes. In fact it’s common to see identifiers containing dashes, as in <code>solve-for-x</code>.</p>&#13;
<p class="indent">A <em>symbol</em> is essentially just a quoted identifier:</p>&#13;
<pre>&gt; <span class="codestrong1">'this-is-a-symbol</span>&#13;
'this-is-a-symbol</pre>&#13;
<p class="indent">They are sort of a second-rate string (more on strings below). They are typically used much like an <code>enum</code> in other programming languages where they’re used to stand for a specific value.</p>&#13;
<p class="indent">A <em>keyword</em> is an identifier prefixed with #<code>:</code>. Keywords are mainly used to identify optional arguments in function calls. Here’s an example of a function (˜<code>r</code>) that uses a keyword to output <em>π</em> as a string with two decimal places of accuracy.</p>&#13;
<pre>&gt; <span class="codestrong1">(~r pi #:precision 2)</span>&#13;
"3.14"</pre>&#13;
<p class="indent">Here we define the optional <code>precision</code> argument to specify that the value of <code>pi</code> should be rounded to two decimal places.</p>&#13;
<h3 class="h3" id="ch00lev1sec_5"><span epub:type="pagebreak" id="page_11"/>Equality</h3>&#13;
<p class="noindent">Racket defines two different kinds of equality: things that look exactly alike and things that are the same thing. Here’s the difference. Suppose we make the following two definitions.</p>&#13;
<pre>&gt; <span class="codestrong1">(define a '(1 2 3))</span>&#13;
&gt; <span class="codestrong1">(define b '(1 2 3))</span></pre>&#13;
<p class="indent">Identifiers <code>a</code> and <code>b</code> look exactly alike, and if we ask Racket if they are the same with the <code>equal?</code> predicate, it will respond that they are the same. Note a <em>predicate</em> is a function that returns a Boolean value of true or false.</p>&#13;
<pre>&gt; <span class="codestrong1">(equal? a b)</span>&#13;
#t</pre>&#13;
<p class="indent">But if we ask whether they are the same thing by using the <code>eq?</code> predicate, we get a different answer.</p>&#13;
<pre>&gt; <span class="codestrong1">(eq? a b)</span>&#13;
#f</pre>&#13;
<p class="indent">So when does <code>eq?</code> return true? Here’s an example.</p>&#13;
<pre>&gt; <span class="codestrong1">(define x '(1 2 3))</span>&#13;
&gt; <span class="codestrong1">(define y x)</span>&#13;
&gt; <span class="codestrong1">(eq? x y)</span>&#13;
#t</pre>&#13;
<p class="indent">In this case we have bound <code>x</code> to the list ’<code>(1 2 3)</code>. We then bind <code>y</code> to the same value <em>location</em> that <code>x</code> is bound to, effectively making <code>x</code> and <code>y</code> be bound to the same thing. The difference is subtle, but important. In most cases <code>equal?</code> is what you need, but there are scenarios where <code>eq?</code> is used to ensure that variables are bound to the same object and not just to things that <em>look</em> the same.</p>&#13;
<p class="indent">One other nuance of equality that must be discussed is numeric equality. In the discussion above, we were focused on structural equality. Numbers are a different animal. We’ll have much more to say about numbers in the next chapter, but we need to clarify a few things about numbers that relate to equality. Examine the following sequence:</p>&#13;
<pre>&gt; <span class="codestrong1">(define a  123)</span>&#13;
&gt; <span class="codestrong1">(define b  123)</span>&#13;
&gt; <span class="codestrong1">(eq? a b)</span>&#13;
#t</pre>&#13;
<p class="indent">Above we bound <code>a</code> and <code>b</code> to identical lists ’<code>(1 2 3)</code>, and in that case <code>eq?</code> returned false. In this case we bound <code>a</code> and <code>b</code> to the identical number <code>123</code>, and <code>eq?</code> returned true. Numbers (technically <em>fixnums</em>, that is, small integers that fit into a fixed amount of storage—typically 32 or 64 bits, depending on your computing platform) are unique in this sense. There is only one instance of every number, no matter how many different identifiers it is bound to. In <span epub:type="pagebreak" id="page_12"/>other words, each number is stored in one and only one location. Furthermore, there’s a special predicate (=) that can only be used with numbers:</p>&#13;
<pre>&gt; <span class="codestrong1">(= 123 123)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(= 123 456)</span>&#13;
#f&#13;
&#13;
(= '(1 2 3) '(1 2 3))&#13;
. . =: contract violation&#13;
  expected: number?&#13;
  given: '(1 2 3)&#13;
  argument position: 1st&#13;
  other arguments...:</pre>&#13;
<p class="indent">In this section we only cover equality in general. We’ll look at more specifics on numerical comparisons in the next chapter.</p>&#13;
<h3 class="h3" id="ch00lev1sec_6">Strings and Things</h3>&#13;
<p class="noindent">In this section, we’ll look at different ways of handling text values in Racket. We’ll begin with the simplest kind of text value.</p>&#13;
<h4 class="h4" id="ch00lev2sec_9"><strong><em>Characters</em></strong></h4>&#13;
<p class="indent">Individual text values, like single letters, are represented using a <em>character</em>, a special entity that corresponds to a <em>Unicode</em> value. For example, the letter A corresponds to the Unicode value 65. Unicode values are usually specified in hexadecimal, so the Unicode value for A is 65<sub>10</sub> = 0041<sub>16</sub>. Character values either start with #\ followed by a literal keyboard character or #\<code>u</code> followed by a Unicode value.</p>&#13;
<p class="indent">Here’s a sampling of the multiple ways to write a character using character functions. Notice the use of the comment character (<code>;</code>), which allows comments (non-compiled text) to be added to Racket code.</p>&#13;
<pre>&gt; <span class="codestrong1">#\A</span>&#13;
#\A&#13;
&#13;
&gt; <span class="codestrong1">#\u0041</span>&#13;
#\A&#13;
&#13;
&gt; <span class="codestrong1">#\</span>   ; this is a space character&#13;
#\space&#13;
&#13;
&gt; <span class="codestrong1">#\u0020</span>  ; so is this&#13;
#\space&#13;
&#13;
<span epub:type="pagebreak" id="page_13"/>&gt; <span class="codestrong1">(char-&gt;integer #\u0041)</span>&#13;
65&#13;
&#13;
&gt; <span class="codestrong1">(integer-&gt;char 65)</span>&#13;
#\A&#13;
&#13;
&gt; <span class="codestrong1">(char-alphabetic? #\a)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(char-alphabetic? #\1)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(char-numeric? #\1)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(char-numeric? #\a)</span>&#13;
#f</pre>&#13;
<p class="indent">Unicode supports a wide range of characters. Here are some examples:</p>&#13;
<pre>&gt; <span class="codestrong1">'(#\u2660 #\u2663 #\u2665 #\u2666)</span>&#13;
'(#♠ #♣ #♡ #♢)&#13;
&#13;
&gt; <span class="codestrong1">'(#\u263A #\u2639 #\u263B)</span>&#13;
'(\#☺ \#☹ \#☻)&#13;
&#13;
&gt; <span class="codestrong1">'(#\u25A1 #\u25CB #\u25C7)</span>&#13;
'(\#□ \#◯ \#◇)</pre>&#13;
<p class="indent">Most Unicode characters should print fine, but this depends to some extent on the fonts available on your computer.</p>&#13;
<h5 class="h5" id="ch00lev3sec_10"><strong>Strings</strong></h5>&#13;
<p class="noindent">A <em>string</em> typically consists of a sequence of keyboard characters surrounded by double-quote characters.</p>&#13;
<pre>&gt; <span class="codestrong1">"This is a string."</span>&#13;
"This is a string."</pre>&#13;
<p class="indent">Unicode characters can be embedded in a string, but in this case, the leading <code>#</code> is left off.</p>&#13;
<pre>&gt; <span class="codestrong1">"Happy: \u263A."</span>&#13;
"Happy: ☺."</pre>&#13;
<p class="indent">You can also use <code>string-append</code> on two strings to create a new string.</p>&#13;
<pre>&gt; <span class="codestrong1">(string-append "Luke, " "I am " "your father!")</span>&#13;
"Luke, I am your father!"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>To access a character within a string, use <code>string-ref</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-ref "abcdef" 2)</span>&#13;
#\c</pre>&#13;
<p class="indent">The position of each character in a string is numbered starting from 0, so in this example using an index of 2 actually returns the third character.</p>&#13;
<p class="indent">The strings we have seen so far are immutable. To create a mutable string, use the <code>string</code> function. This allows changing characters in the string.</p>&#13;
<pre>&gt; <span class="codestrong1">(define wishy-washy (string #\I #\  #\a #\m #\  #\m #\u #\t #\a #\b #\l #\e)&#13;
    )</span>&#13;
&gt; <span class="codestrong1">wishy-washy</span>&#13;
"I am mutable"&#13;
&#13;
&gt; <span class="codestrong1">(string-set! wishy-washy 5 #\a)</span>&#13;
&gt; <span class="codestrong1">(string-set! wishy-washy 6 #\ )</span> &#13;
&#13;
&gt; <span class="codestrong1">wishy-washy</span>&#13;
"I am a table"</pre>&#13;
<p class="indent">Note that for mutable strings we have to define the string using individual characters.</p>&#13;
<p class="indent">Another way to create a mutable string is with <code>string-copy</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(define mstr (string-copy "I am also mutable"))</span>&#13;
&gt; <span class="codestrong1">(string-set! mstr 5 #\space)</span>&#13;
&gt; <span class="codestrong1">(string-set! mstr 6 #\space)</span>&#13;
&gt; <span class="codestrong1">mstr</span>&#13;
"I am   so mutable"</pre>&#13;
<p class="indent">You can also use <code>make-string</code> to do the same thing:</p>&#13;
<pre>&gt; <span class="codestrong1">(define exes (make-string 10 #\X))</span>&#13;
&gt; <span class="codestrong1">(string-set! exes 5 #\O)</span>&#13;
&gt; <span class="codestrong1">exes</span>&#13;
"XXXXXOXXXX"</pre>&#13;
<p class="indent">Depending on what’s needed, any one of the above may be preferred. If you need to make an existing string mutable, <code>string-copy</code> is the obvious choice. If you only want a string of spaces, <code>make-string</code> is the clear winner.</p>&#13;
<h4 class="h4" id="ch00lev2sec_10"><strong><em>Useful String Functions</em></strong></h4>&#13;
<p class="noindent">There are of course a number of other useful string functions, a few of which we illustrate next.</p>&#13;
<h5 class="h5" id="ch00lev3sec_11"><span epub:type="pagebreak" id="page_15"/><strong>string-length</strong></h5>&#13;
<p class="noindent">The <code>string-length</code> function outputs the number of characters in a string (see <code>wishy-washy</code> earlier in <a href="ch01.xhtml#ch00lev2sec_10">“Strings” on page 14</a>.</p>&#13;
<pre>&gt; <span class="codestrong1">(string-length wishy-washy)</span>&#13;
12</pre>&#13;
<h5 class="h5" id="ch00lev3sec_12"><strong>substring</strong></h5>&#13;
<p class="noindent">The <code>substring</code> function extracts a substring from a given string.</p>&#13;
<pre>&gt; <span class="codestrong1">(substring wishy-washy 7 12)</span> ; characters 7-11&#13;
"table"</pre>&#13;
<h5 class="h5" id="ch00lev3sec_13"><strong>string-titlecase</strong></h5>&#13;
<p class="noindent">Use <code>string-titlecase</code> to capitalize the first character of each word in a string.</p>&#13;
<pre>&gt; <span class="codestrong1">(string-titlecase wishy-washy)</span>&#13;
"I Am A Table"</pre>&#13;
<h5 class="h5" id="ch00lev3sec_14"><strong>string-upcase</strong></h5>&#13;
<p class="noindent">To output a string in all caps, use <code>string-upcase</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-upcase "big")</span>&#13;
"BIG"</pre>&#13;
<h5 class="h5" id="ch00lev3sec_15"><strong>string-downcase</strong></h5>&#13;
<p class="noindent">Conversely, for a lowercase string, use <code>string-downcase</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-downcase "SMALL")</span>&#13;
"small"</pre>&#13;
<h5 class="h5" id="ch00lev3sec_16"><strong>string&lt;=?</strong></h5>&#13;
<p class="noindent">To perform an alphabetical comparison, use the <code>string&lt;=?</code> function:</p>&#13;
<pre>&gt; <span class="codestrong1">(string&lt;=? "big" "small")</span>  ; alphabetical comparison&#13;
#t</pre>&#13;
<h5 class="h5" id="ch00lev3sec_17"><strong>string=?</strong></h5>&#13;
<p class="noindent">The <code>string=?</code> function tests whether two strings are equal:</p>&#13;
<pre>&gt; <span class="codestrong1">(string=? "big" "small")</span>&#13;
#f</pre>&#13;
<h5 class="h5" id="ch00lev3sec_18"><span epub:type="pagebreak" id="page_16"/><strong>string-replace</strong></h5>&#13;
<p class="noindent">The <code>string-replace</code> function replaces part of a string with another string:</p>&#13;
<pre>&gt; <span class="codestrong1">(define darth-quote "Luke, I am your father!")</span>&#13;
&gt; <span class="codestrong1">(string-replace darth-quote "am" "am not")</span>&#13;
<span class="codestrong1">"Luke, I am not your father!"</span></pre>&#13;
<h5 class="h5" id="ch00lev3sec_19"><strong>string-contains?</strong></h5>&#13;
<p class="noindent">To test whether one string is contained within another, use <code>string-contains?</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-contains? darth-quote "Luke")</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(string-contains? darth-quote "Darth")</span>&#13;
#f</pre>&#13;
<h5 class="h5" id="ch00lev3sec_20"><strong>string-split</strong></h5>&#13;
<p class="noindent">The <code>string-split</code> function can be used to split a string into tokens:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-split darth-quote)</span>&#13;
'("Luke," "I" "am" "your" "father!")&#13;
&#13;
&gt; <span class="codestrong1">(string-split darth-quote ",")</span>&#13;
'("Luke" " I am your father!")</pre>&#13;
<p class="indent">Notice that the first example above uses the default version that splits on spaces whereas the second version explictly uses a comma (,).</p>&#13;
<h5 class="h5" id="ch00lev3sec_21"><strong>string-trim</strong></h5>&#13;
<p class="noindent">The <code>string-trim</code> function gets rid of any leading and/or trailing spaces:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-trim "  hello   ")</span>&#13;
"hello"&#13;
 &#13;
&gt; <span class="codestrong1">(string-trim "  hello   " #:right? #f)</span>&#13;
"hello   "&#13;
 &#13;
&gt; <span class="codestrong1">(string-trim "  hello   " #:left? #f)</span>&#13;
"  hello"</pre>&#13;
<p class="indent">Notice in the last two versions, <code>#:left?</code> or <code>#:right?</code> is used to suppress trimming the corresponding side. The final <code>#f</code> argument (the default) is used to specify that only one match is removed from each side; otherwise all initial or trailing matches are trimmed.</p>&#13;
<p class="indent">For more advanced string functionality, see <a href="ch10.xhtml#ch00lev2sec_75">“Regular Expressions” on page 279</a>.</p>&#13;
<h4 class="h4" id="ch00lev2sec_11"><strong><em>String Conversion and Formatting Functions</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_17"/>There are a number of functions that convert values to and from strings. They all have intuitive names and are illustrated below.</p>&#13;
<pre>&gt; <span class="codestrong1">(symbol-&gt;string 'FBI)</span>&#13;
"FBI"&#13;
&#13;
&gt; <span class="codestrong1">(string-&gt;symbol "FBI")</span>&#13;
'FBI&#13;
&#13;
&gt; <span class="codestrong1">(list-&gt;string '(#\x #\y #\z))</span>&#13;
"xyz"&#13;
&#13;
&gt; <span class="codestrong1">(string-&gt;list "xyz")</span>&#13;
'(#\x #\y #\z)&#13;
&#13;
&gt; <span class="codestrong1">(string-&gt;keyword "string-&gt;keyword")</span>&#13;
'#:string-&gt;keyword&#13;
&#13;
&gt; <span class="codestrong1">(keyword-&gt;string '#:keyword)</span>&#13;
"keyword"</pre>&#13;
<p class="indent">For a complete list of these, go to <a href="https://docs.racket-lang.org/reference/strings.html"><em>https://docs.racket-lang.org/reference/strings.html</em></a>.</p>&#13;
<p class="indent">A handy function to embed other values within a string is <code>format</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">(format "let ~a = ~a" "x" 2)</span>&#13;
"let x = 2"</pre>&#13;
<p class="indent">Within the format statement, ˜<code>a</code> acts as a placeholder. There should be one placeholder for each additional argument. Note that the number 2 is automatically converted to a string before it’s embedded in the output string.</p>&#13;
<p class="indent">If you want to simply convert a number to a string, use the <code>number-&gt;string</code> function:</p>&#13;
<pre>&gt; <span class="codestrong1">(number-&gt;string pi)</span>&#13;
"3.141592653589793"</pre>&#13;
<p class="noindent">Conversely:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-&gt;number "3.141592653589793")</span>&#13;
3.141592653589793</pre>&#13;
<p class="indent">Trying to get Racket to translate the value of words into numbers, however, will not work:</p>&#13;
<pre>&gt; <span class="codestrong1">(string-&gt;number "five")</span>&#13;
#f</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_18"/>For more control we can use the ˜<code>r</code> function, defined in the <em>racket/format</em> library, which has many options that can be used to convert a number to a string and control the precision and other output characteristics of the number. For example, to show <em>π</em> to four decimal places, we would use this:</p>&#13;
<pre>&gt; <span class="codestrong1">(~r pi #:precision 4)</span>&#13;
"3.1416"</pre>&#13;
<p class="indent">To show this right-justified, in a field 20 characters wide, and left padded with periods, we execute the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(~r pi #:min-width 20 #:precision 4 #:pad-string ".")</span>&#13;
"..............3.1416"</pre>&#13;
<p class="indent">Additional info on ˜<code>r</code> is available in Appendix A, which talks about number bases. There are a number of other useful tilde-prefixed string conversion functions available, such as ˜<code>a</code>, ˜<code>v</code>, and ˜<code>s</code>. We won’t go into detail here, but you can consult the Racket Documentation for details: <a href="https://docs.racket-lang.org/reference/strings.html"><em>https://docs.racket-lang.org/reference/strings.html</em></a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec_7">Vectors</h3>&#13;
<p class="noindent">Vectors bear a superficial resemblance to lists, but they are quite different. In contrast to the internal tree structure of lists, <em>vectors</em> are a sequential array of cells (much like arrays in imperative languages) that directly contain values, as illustrated in <a href="ch01.xhtml#ch1fig3">Figure 1-3</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/01fig03.jpg"/></div>&#13;
<p class="figcap" id="ch1fig3"><em>Figure 1-3: Vector structure</em></p>&#13;
<p class="indent">Vectors can be entered using the <code>vector</code> function.</p>&#13;
<pre>&gt; <span class="codestrong1">(vector 1 3 "d" 'a 2)</span>&#13;
'#(1 3 "d" a 2)</pre>&#13;
<p class="indent">Alternatively, vectors can be entered using <code>#</code> as follows (note that an unquoted <code>#</code> implies a quote):</p>&#13;
<pre>&gt; <span class="codestrong1">#(1 3 "d" a 2)</span>&#13;
'#(1 3 "d" a 2)</pre>&#13;
<p class="indent">It’s important to note that these methods are <em>not</em> equivalent. Here’s one reason why:</p>&#13;
<pre>&gt; <span class="codestrong1">(vector 1 2 pi)</span>&#13;
'#(1 2 3.141592653589793)&#13;
&#13;
&gt; <span class="codestrong1">#(1 2 pi)</span>&#13;
'#(1 2 pi)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>In the first example, just as for <code>list</code>, <code>vector</code> first evaluates its arguments before forming the vector. In the last example, like <code>quote</code>, <code>#</code> does not evaluate its arguments. More importantly, <code>#</code> is an alias for <code>vector-immutable</code>, which leads to our next topic.</p>&#13;
<h4 class="h4" id="ch00lev2sec_12"><strong><em>Accessing Vector Elements</em></strong></h4>&#13;
<p class="noindent">The function <code>vector-ref</code> is an indexing operator that returns an element of a vector. This function takes a vector as its first argument and an index as its second:</p>&#13;
<pre>&gt; <span class="codestrong1">(define v (vector 'alpha 'beta 'gamma))</span>&#13;
&gt; <span class="codestrong1">(vector-ref v 1)</span>&#13;
'beta&#13;
&#13;
&gt; <span class="codestrong1">(vector-ref v 0)</span>&#13;
'alpha</pre>&#13;
<p class="indent">To assign a value to a vector cell, <code>vector-set!</code> is used. The <code>vector-set!</code> expression takes three arguments: a vector, an index, and a value to be assigned to the indexed position in the vector.</p>&#13;
<pre>&gt; <span class="codestrong1">(vector-set! v 2 'foo)</span>&#13;
&gt; <span class="codestrong1">v</span>&#13;
'#(alpha beta foo)</pre>&#13;
<p class="indent">Let’s try this a bit differently:</p>&#13;
<pre>&gt; <span class="codestrong1">(define u #(alpha beta gamma))</span>&#13;
&gt; <span class="codestrong1">(vector-set! u 2 'foo)</span>&#13;
. . vector-set!: contract violation&#13;
  expected: (and/c vector? (not/c immutable?))&#13;
  given: '#('alpha 'beta 'gamma)&#13;
  argument position: 1st&#13;
  other arguments...:</pre>&#13;
<p class="indent">Remember that <code>#</code> is an alias for <code>vector-immutable</code>. What this means is that vectors created with <code>#</code> (or <code>vector-immutable</code>) are (drum roll . . . ) <em>immutable</em>: they cannot be changed or assigned new values. On the other hand, vectors created with <code>vector</code> are <em>mutable</em>, meaning that their cells can be modified.</p>&#13;
<p class="indent">One advantage of vectors over lists is that elements of vectors can be accessed much faster than elements of lists. This is because to access the 100th element of a list, each cell of the list must be accessed sequentially to get to the 100th element. Conversely, with vectors, the 100th element can be accessed directly, without working through earlier cells. On the other hand, lists are quite flexible and can easily be extended as well as being used to represent other data structures like trees. They are the bread and butter of Racket (and all Lisp-based languages), so much of the functionality of the language depends on the list structure. Predictably, functions are provided to easily convert from one to the other.</p>&#13;
<h4 class="h4a" id="ch00lev2sec_120"><span epub:type="pagebreak" id="page_20"/><strong><em>Useful Vector Functions</em></strong></h4>&#13;
<h5 class="h5a" id="ch00lev3sec_69"><strong>vector-length</strong></h5>&#13;
<p class="noindent">The <code>vector-length</code> function returns the number of elements in a vector:</p>&#13;
<pre>&gt; <span class="codestrong1">(vector-length #(one ringy dingy))</span>&#13;
3</pre>&#13;
<h5 class="h5" id="ch00lev3sec_22"><strong>vector-sort</strong></h5>&#13;
<p class="noindent">The <code>vector-sort</code> function sorts the elements of a vector:</p>&#13;
<pre>&gt; <span class="codestrong1">(vector-sort #(9 1 3 8 2 5 4 0 7 6 ) &lt;)</span>&#13;
'#(0 1 2 3 4 5 6 7 8 9)&#13;
&#13;
&gt; <span class="codestrong1">(vector-sort #(9 1 3 8 2 5 4 0 7 6 ) &gt;)</span>&#13;
'#(9 8 7 6 5 4 3 2 1 0)</pre>&#13;
<p class="indent">To whet your appetite for what’s to come later, <code>vector-sort</code> is a typical example of functional programming. The last argument actually evaluates a function that determines the direction of the sort.</p>&#13;
<h5 class="h5" id="ch00lev3sec_23"><strong>vector-&gt;list</strong></h5>&#13;
<p class="noindent">The <code>vector-&gt;list</code> function takes a vector and returns a list:</p>&#13;
<pre>&gt; <span class="codestrong1"> (vector-&gt;list #(one little piggy))</span>&#13;
'(one little piggy)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_24"><strong>list-&gt;vector</strong></h5>&#13;
<p class="noindent">Conversely <code>list-&gt;vector</code> takes a list and returns a vector:</p>&#13;
<pre>&gt; <span class="codestrong1">(list-&gt;vector '(two little piggies))</span>&#13;
'#(two little piggies)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_25"><strong>make-vector</strong></h5>&#13;
<p class="noindent">To create a mutable vector, use the <code>make-vector</code> form:</p>&#13;
<pre>&gt; <span class="codestrong1">(make-vector 10 'piggies)</span> ; create a mutable vector&#13;
'#(piggies piggies piggies piggies piggies piggies piggies piggies piggies&#13;
     piggies)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_26"><strong>vector-append</strong></h5>&#13;
<p class="noindent">To concatenate two vectors together, use <code>vector-append</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">(vector-append #(ten little) #(soldier boys))</span>&#13;
'#(ten little soldier boys)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_27"><span epub:type="pagebreak" id="page_21"/><strong>vector-member</strong></h5>&#13;
<p class="noindent">The <code>vector-member</code> function returns the index to where an item is located in a vector:</p>&#13;
<pre>&gt; <span class="codestrong1">(vector-member 'waldo (vector 'where 'is 'waldo '?) )</span>&#13;
2</pre>&#13;
<p class="indent">There are of course many other useful vector functions, and we will explore some of them in the chapters to come.</p>&#13;
<h3 class="h3" id="ch00lev1sec_8">Using structs</h3>&#13;
<p class="noindent">To introduce the next Racket feature, let’s build an example program. Instead of keeping your checkbook transactions in a paper bankbook, you could create an electronic version using Racket. Typically such transactions have the following components:</p>&#13;
<ul>&#13;
<li class="noindent">Transaction date</li>&#13;
<li class="noindent">Payee</li>&#13;
<li class="noindent">Check number</li>&#13;
<li class="noindent">Amount</li>&#13;
</ul>&#13;
<p class="indent">One way to keep track of these disparate pieces of information is in a Racket structure called a <code>struct</code>. A Racket <code>struct</code> is conceptually similar to a <code>struct</code> in languages such as C or C++. It’s a composite data structure that has a set of predefined fields. Before you can use a <code>struct</code>, you have to tell Racket what it looks like. For our bank transaction example, such a definition might look like this:</p>&#13;
<pre>&gt; <span class="codestrong1">(struct transaction (date payee check-number amount))</span></pre>&#13;
<p class="indent">Each of the components of a structure (<code>date</code>, <code>payee</code>, etc.) is called a <em>field</em>. Once we’ve defined our <code>transaction struct</code>, we can create one like this:</p>&#13;
<pre>&gt; <span class="codestrong1">(define trans (transaction 20170907 "John Doe" 1012 100.10))</span></pre>&#13;
<p class="indent">Racket automatically creates an <em>accessor method</em> for each of the fields in the structure. An accessor method returns the value of the field. They always begin with the name of the structure (in this case <code>transaction</code>), a hyphen, and then the name of the field.</p>&#13;
<pre>&gt; <span class="codestrong1">(transaction-date trans)</span>&#13;
20170907&#13;
&#13;
&gt; <span class="codestrong1">(transaction-payee trans)</span>&#13;
"John Doe"&#13;
&#13;
<span epub:type="pagebreak" id="page_22"/>&gt; <span class="codestrong1">(transaction-check-number trans)</span>&#13;
1012&#13;
&#13;
&gt; <span class="codestrong1">(transaction-amount trans)</span>&#13;
100.1</pre>&#13;
<p class="indent">Suppose, however, that you made a mistake and determined that the check to John Doe should have been for $100.12 instead of $100.10 and try to correct it via <code>set-transaction-amount!</code>. Note the exclamation point: this is a signal that <code>set-transaction-amount!</code> is a <em>mutator</em>, that is, a method that modifies a field value). These mutators are generated when the struct is defined and typically start with <code>set</code> and end with <code>!</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">(set-transaction-amount! trans 100.12)</span>&#13;
. . set-transaction-amount!: undefined;&#13;
  cannot reference an identifier before its definition</pre>&#13;
<p class="indent">Oops . . . Fields in a structure are immutable by default and hence do not export <em>mutators</em>. The way around this is to include the <code>#:mutable</code> keyword in the structure definition for any field that may need to be modified.</p>&#13;
<pre>&gt; <span class="codestrong1">(struct transaction &#13;
    (date payee check-number [amount #:mutable]))</span>&#13;
&gt; <span class="codestrong1">(define trans (transaction 20170907 "John Doe" 1012 100.10))</span>&#13;
&gt; <span class="codestrong1">(set-transaction-amount! trans 100.12)</span>&#13;
&gt; <span class="codestrong1">(transaction-amount trans)</span>&#13;
100.12&#13;
{</pre>&#13;
<p class="indent">If all the fields should be mutable, adding the <code>#:mutable</code> keyword after the field list will do the trick.</p>&#13;
<pre>&gt; <span class="codestrong1">(struct transaction &#13;
    (date payee check-number amount) #:mutable)</span>&#13;
&gt; <span class="codestrong1">(define trans (transaction 20170907 "John Doe" 1012 100.10))</span>&#13;
&gt; <span class="codestrong1">(set-transaction-check-number! trans 1013)</span>&#13;
&gt; <span class="codestrong1">(transaction-check-number trans)</span>&#13;
1013</pre>&#13;
<p class="indent">While the accessor methods are sufficient for getting the value of a single field, they are a bit cumbersome for seeing all the values at once. Just entering the structure name does not yield much information.</p>&#13;
<pre>&gt; <span class="codestrong1">trans</span>&#13;
#&lt;transaction&gt;</pre>&#13;
<p class="indent">To make your structure more transparent, include the <code>#:transparent</code> option in the <code>struct</code> definition.</p>&#13;
<pre>&gt; <span class="codestrong1">(struct transaction &#13;
    (date payee check-number amount) #:mutable #:transparent)</span>&#13;
&gt; <span class="codestrong1">(define trans (transaction 20170907 "John Doe" 1012 100.10))</span>&#13;
&gt; <span class="codestrong1">trans</span>&#13;
(transaction 20170907 "John Doe" 1012 100.1)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_23"/>There are additional useful options that can be applied when defining structures, but one that is of particular interest is <code>#:guard</code>. <code>#:guard</code> provides a mechanism to validate the fields when a structure is constructed. For instance, to ensure that negative check numbers are not used, we could do the following.</p>&#13;
<pre>&gt; <span class="codestrong1">(struct transaction &#13;
    (date payee check-number amount)&#13;
    #:mutable #:transparent&#13;
    #:guard (λ (date payee num amt name)&#13;
        (unless (&gt; num 0) &#13;
        (error "Not a valid check number"))&#13;
        (values date payee num amt)))</span>&#13;
              &#13;
&gt; <span class="codestrong1">(transaction 20170907 "John Doe" -1012 100.10)</span>&#13;
Not a valid check number&#13;
&#13;
&gt; <span class="codestrong1">(transaction 20170907 "John Doe" 1012 100.10)</span>&#13;
(transaction 20170907 "John Doe" 1012 100.1)</pre>&#13;
<p class="indent">Don’t panic. We haven’t covered that funny-looking symbol (<em>λ</em>, or <em>lambda</em>) yet, but you should be able to get the gist of what’s going on. The <code>#:guard</code> expression is a function that takes one parameter for each field and one additional parameter that contains the structure name. In this case we’re only testing whether the check number is greater than zero. The <code>#:guard</code> expression must return the same number of values as the number of fields in the <code>struct</code>.</p>&#13;
<p class="indent">In the previous example we simply returned the same values that were entered, but suppose we had a variable that contained the last check number called <code>last-check</code>. In this case, we could enter a 0 for the check number and use the <code>#:guard</code> expression to plug in the next available number as shown here.</p>&#13;
<pre>&gt; <span class="codestrong1">(define last-check 1000)</span>&#13;
&#13;
&gt; <span class="codestrong1">(struct transaction &#13;
    (date payee check-number amount)&#13;
    #:mutable #:transparent&#13;
    #:guard (λ (date payee num amt name)&#13;
              (cond&#13;
                [(&lt; num 0)&#13;
                   (error "Not a valid check number")]&#13;
                [(= num 0)&#13;
                   (let ([next-num (add1 last-check)])&#13;
                     (set! last-check next-num)&#13;
                     (values date payee next-num amt))]&#13;
                [else &#13;
                   (set! last-check num)&#13;
                   (values date payee num amt)])))</span>&#13;
                 &#13;
<span epub:type="pagebreak" id="page_24"/>&gt; <span class="codestrong1">(transaction 20170907 "John Doe" 0 100.10)</span>&#13;
(transaction 20170907 "John Doe" 1001 100.1)&#13;
&#13;
&gt; <span class="codestrong1">(transaction 20170907 "Jane Smith" 1013 65.25)</span>&#13;
(transaction 20170907 "Jane Smith" 1013 65.25)&#13;
&#13;
&gt; <span class="codestrong1">(transaction 20170907 "Acme Hardware" 0 39.99)</span>&#13;
(transaction 20170907 "Acme Hardware" 1014 39.99)</pre>&#13;
<p class="indent">As you can see, non-zero check numbers are stored as the last check number, but if a zero is entered for the check number, the <code>struct</code> value gets generated with the next available number, which becomes the current value for <code>last-check</code>. The <code>cond</code> statement will be explained in more detail a bit later in the book, but its use here should be fairly clear: it’s a way to check multiple cases.</p>&#13;
<h3 class="h3" id="ch00lev1sec_9">Controlling Output</h3>&#13;
<p class="noindent">In the interactions pane, DrRacket immediately displays the output resulting from evaluating any expression. It’s often desirable to have some control over how the output is presented. This is especially important when the output is being generated by some function or method. Racket provides a number of mechanisms for generating formatted output. The main forms are <code>write</code>, <code>print</code>, and <code>display</code>. Each of these works in a slightly different way. The best way to illustrate this is with examples.</p>&#13;
<h5 class="h5" id="ch00lev3sec_28"><strong>write</strong></h5>&#13;
<p class="noindent">The <code>write</code> expression outputs in such a way that the output value forms a valid value that can be used in the input:</p>&#13;
<pre>&gt; <span class="codestrong1">(write "show me the money")</span>&#13;
"show me the money"&#13;
&#13;
&gt; <span class="codestrong1">(write '(show me the money))</span>&#13;
(show me the money)&#13;
&#13;
&gt; <span class="codestrong1">(write #\A)</span>&#13;
#\A&#13;
&#13;
&gt; <span class="codestrong1">(write 1.23)</span>&#13;
1.23&#13;
&#13;
&gt; <span class="codestrong1">(write 1/2)</span>&#13;
1/2&#13;
&#13;
&gt; <span class="codestrong1">(write #(a b c))</span>&#13;
#(a b c)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_29"><span epub:type="pagebreak" id="page_25"/><strong>display</strong></h5>&#13;
<p class="noindent">The <code>display</code> expression is similar to <code>write</code>, but strings and character data types are written as raw strings and characters without any adornments such as quotation or tick marks:</p>&#13;
<pre>&gt; <span class="codestrong1">(display "show me the money")</span>&#13;
show me the money&#13;
&#13;
&gt; <span class="codestrong1">(display '(show me the money))</span>&#13;
(show me the money)&#13;
&#13;
&gt; <span class="codestrong1">(display #\A)</span>&#13;
A&#13;
&#13;
&gt; <span class="codestrong1">(display 1.23)</span>&#13;
1.23&#13;
&#13;
&gt; <span class="codestrong1">(display 1/2)</span>&#13;
1/2&#13;
&#13;
&gt; <span class="codestrong1">(display #(a b c))</span>&#13;
#(a b c)</pre>&#13;
<h5 class="h5" id="ch00lev3sec_30"><strong>print</strong></h5>&#13;
<p class="noindent">The <code>print</code> expression is also similar to <code>write</code>, but adds a bit more formatting to the output. The intent of <code>print</code> is to show an expression that would evaluate to the same value as the printed one:</p>&#13;
<pre>&gt; <span class="codestrong1">(print "show me the money")</span>&#13;
"show me the money"&#13;
&#13;
&gt; <span class="codestrong1">(print '(show me the money))</span>&#13;
'(show me the money)&#13;
&#13;
&gt; <span class="codestrong1">(print #\A)</span>&#13;
#\A&#13;
&#13;
&gt; <span class="codestrong1">(print 1.23)</span>&#13;
1.23&#13;
&#13;
&gt; <span class="codestrong1">(print 1/2)</span>&#13;
1&#13;
-&#13;
2&#13;
&#13;
&gt; <span class="codestrong1">(print #(a b c))</span>&#13;
'#(a b c)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_26"/>Notice how the rational value <code>1/2</code> is printed (more on rationals in the next chapter).</p>&#13;
<p class="indent">Each of these comes in a form that ends with <code>ln</code>. The only difference is that the ones that end with <code>ln</code> automatically print a new line at the end. Here are a couple of examples to highlight the difference.</p>&#13;
<pre>&gt; <span class="codestrong1">(print "show me ") (print "the money")</span>&#13;
"show me ""the money"&#13;
&#13;
&gt; <span class="codestrong1">(display "show me ") (display "the money")</span>&#13;
show me the money&#13;
&#13;
&gt; <span class="codestrong1">(println "show me ") (println "the money")</span>&#13;
"show me "&#13;
"the money"&#13;
&#13;
&gt; <span class="codestrong1">(displayln "show me ") (displayln "the money")</span>&#13;
show me &#13;
the money</pre>&#13;
<p class="indent">One very useful form is <code>printf</code>. The <code>printf</code> expression works much like the <code>format</code> function: it takes a format string as its first argument and any number of other values as its other argument. The format string uses ˜<code>a</code> as a placeholder. There must be one placeholder for each of the arguments after the format string. The format string is printed exactly as entered, with the exception that for each placeholder the corresponding argument is substituted. Here’s <code>printf</code> in action.</p>&#13;
<pre>&gt; <span class="codestrong1">(printf "~a + ~a = ~a" 1 2 (+ 1 2))</span>&#13;
1 + 2 = 3&#13;
&#13;
&gt; <span class="codestrong1">(printf "~a, can you hear ~a?" "Watson" "me")</span>&#13;
Watson, can you hear me?&#13;
&#13;
&gt; <span class="codestrong1">(printf "~a, can you hear ~a?" "Jeeves" "the bell")</span>&#13;
Jeeves, can you hear the bell?</pre>&#13;
<p class="indent">There are additional format specifiers (see the Racket Documentation for details), but we’ll mostly be using <code>print</code> since it gives a better visual indication of the data type of the value being output.</p>&#13;
<h3 class="h3" id="ch00lev1sec_10">Summary</h3>&#13;
<p class="noindent">In this chapter, we laid the groundwork for what’s to come. Most of the core data types have been introduced along with what are hopefully some helpful examples. By now you should be comfortable with basic Racket syntax and have a pretty good understanding of the structure of lists and how to manipulate them. The next chapter will take a detailed look at the various numeric data types provided by Racket.</p>&#13;
</body></html>