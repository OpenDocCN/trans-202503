<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_11"/><span class="big">1</span><br/>ANATOMY OF A BINARY</h2>&#13;
<p class="startpara">Binary analysis is all about analyzing binaries. But what exactly is a binary? This chapter introduces you to the general anatomy of binary formats and the binary life cycle. After reading this chapter, you’ll be ready to tackle the next two chapters on ELF and PE binaries, two of the most widely used binary formats on Linux and Windows systems.</p>&#13;
<p class="indent">Modern computers perform their computations using the binary numerical system, which expresses all numbers as strings of ones and zeros. The machine code that these systems execute is called <em>binary code</em>. Every program consists of a collection of binary code (the machine instructions) and data (variables, constants, and the like). To keep track of all the different programs on a given system, you need a way to store all the code and data belonging to each program in a single self-contained file. Because these files contain executable binary programs, they are called <em>binary executable files</em>, or simply <em>binaries</em>. Analyzing these binaries is the goal of this book.</p>&#13;
<p class="indent">Before getting into the specifics of binary formats such as ELF and PE, let’s start with a high-level overview of how executable binaries are produced from source. After that, I’ll disassemble a sample binary to give you a solid idea of the code and data contained in binary files. You’ll use what you learn here to explore ELF and PE binaries in <a href="ch02.xhtml#ch02">Chapters 2</a> and <a href="ch03.xhtml#ch03">3</a>, and you’ll build <span epub:type="pagebreak" id="page_12"/>your own binary loader to parse binaries and open them up for analysis in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<h3 class="h3" id="ch01_1">1.1 The C Compilation Process</h3>&#13;
<p class="noindent">Binaries are produced through <em>compilation</em>, which is the process of translating human-readable source code, such as C or C++, into machine code that your processor can execute.<sup><a id="ch01fn_1a" href="footnote.xhtml#ch01fn_1">1</a></sup> <a href="ch01.xhtml#ch01fig1">Figure 1-1</a> shows the steps involved in a typical compilation process for C code (the steps for C++ compilation are similar). Compiling C code involves four phases, one of which (awkwardly enough) is also called <em>compilation</em>, just like the full compilation process. The phases are <em>preprocessing</em>, <em>compilation</em>, <em>assembly</em>, and <em>linking</em>. In practice, modern compilers often merge some or all of these phases, but for demonstration purposes, I will cover them all separately.</p>&#13;
<div class="image"><a id="ch01fig1"/><img src="Images/f012-01.jpg" alt="image" width="690" height="205"/></div>&#13;
<p class="fig-caption"><em>Figure 1-1: The C compilation process</em></p>&#13;
<h4 class="h4" id="ch01_1_1"><em>1.1.1 The Preprocessing Phase</em></h4>&#13;
<p class="noindent">The compilation process starts with a number of source files that you want to compile (shown as <em>file-1.c</em> through <em>file-n.c</em> in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>). It’s possible to have just one source file, but large programs are typically composed of many files. Not only does this make the project easier to manage, but it speeds up compilation because if one file changes, you only have to recompile that file rather than all of the code.</p>&#13;
<p class="indent">C source files contain macros (denoted by <code>#define</code>) and <code>#include</code> directives. You use the <code>#include</code> directives to include <em>header files</em> (with the extension <em>.h</em>) on which the source file depends. The preprocessing phase expands any <code>#define</code> and <code>#include</code> directives in the source file so all that’s left is pure C code ready to be compiled.</p>&#13;
<p class="indent">Let’s make this more concrete by looking at an example. This example uses the <code>gcc</code> compiler, which is the default on many Linux distributions <span epub:type="pagebreak" id="page_13"/>(including Ubuntu, the operating system installed on the virtual machine). The results for other compilers, such as <code>clang</code> or Visual Studio, would be similar. As mentioned in the Introduction, I’ll compile all code examples in this book (including the current example) into x86-64 code, except where stated otherwise.</p>&#13;
<p class="indent">Suppose you want to compile a C source file, as shown in <a href="ch01.xhtml#ch01list1">Listing 1-1</a>, that prints the ubiquitous “Hello, world!” message to the screen.</p>&#13;
<p class="listing1" id="ch01list1"><em>Listing 1-1:</em> compilation_example.c</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/><br/>#define FORMAT_STRING    "%s"<br/>#define MESSAGE          "Hello, world!\n"<br/><br/>int<br/>main(int argc, char *argv[]) {<br/>  printf(FORMAT_STRING, MESSAGE);<br/>  return 0;<br/>}</pre>&#13;
<p class="indent">In a moment, you’ll see what happens with this file in the rest of the compilation process, but for now, we’ll just consider the output of the preprocessing stage. By default, <code>gcc</code> will automatically execute all compilation phases, so you have to explicitly tell it to stop after preprocessing and show you the intermediate output. For <code>gcc</code>, this can be done using the command <code>gcc -E -P</code>, where <code>-E</code> tells <code>gcc</code> to stop after preprocessing and <code>-P</code> causes the compiler to omit debugging information so that the output is a bit cleaner. <a href="ch01.xhtml#ch01list2">Listing 1-2</a> shows the output of the preprocessing stage, edited for brevity. Start the VM and follow along to see the full output of the preprocessor.</p>&#13;
<p class="listing1" id="ch01list2"><em>Listing 1-2: Output of the C preprocessor for the “Hello, world!” program</em></p>&#13;
<pre>$ <span class="codestrong1">gcc -E -P compilation_example.c</span><br/><br/>typedef long unsigned int size_t;<br/>typedef unsigned char __u_char;<br/>typedef unsigned short int __u_short;<br/>typedef unsigned int __u_int;<br/>typedef unsigned long int __u_long;<br/><br/>/* ... */<br/><br/>extern int sys_nerr;<br/>extern const char *const sys_errlist[];<br/>extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;<br/>extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;<br/>extern FILE *popen (const char *__command, const char *__modes) ;<br/>extern int pclose (FILE *__stream);<br/>extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));<br/>extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));<br/>extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;<br/>extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));<br/><br/>int<br/>main(int argc, char *argv[]) {<br/>  printf(<span class="ent">➊</span>"%s", <span class="ent">➋</span>"Hello, world!\n");<br/>  return 0;<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>The <em>stdio.h</em> header is included in its entirety, with all of its type definitions, global variables, and function prototypes “copied in” to the source file. Because this happens for every <code>#include</code> directive, preprocessor output can be quite verbose. The preprocessor also fully expands all uses of any macros you defined using <code>#define</code>. In the example, this means both arguments to <code>printf</code> (<code>FORMAT_STRING</code> <span class="ent">➊</span> and <code>MESSAGE</code> <span class="ent">➋</span>) are evaluated and replaced by the constant strings they represent.</p>&#13;
<h4 class="h4" id="ch01_1_2"><em>1.1.2 The Compilation Phase</em></h4>&#13;
<p class="noindent">After the preprocessing phase is complete, the source is ready to be compiled. The compilation phase takes the preprocessed code and translates it into assembly language. (Most compilers also perform heavy optimization in this phase, typically configurable as an <em>optimization level</em> through command line switches such as options <code>-O0</code> through <code>-O3</code> in <code>gcc</code>. As you’ll see in <a href="ch06.xhtml#ch06">Chapter 6</a>, the degree of optimization during compilation can have a profound effect on disassembly.)</p>&#13;
<p class="indent">Why does the compilation phase produce assembly language and not machine code? This design decision doesn’t seem to make sense in the context of just one language (in this case, C), but it does when you think about all the other languages out there. Some examples of popular compiled languages include C, C++, Objective-C, Common Lisp, Delphi, Go, and Haskell, to name a few. Writing a compiler that directly emits machine code for each of these languages would be an extremely demanding and time-consuming task. It’s better to instead emit assembly code (a task that is already challenging enough) and have a single dedicated assembler that can handle the final translation of assembly to machine code for every language.</p>&#13;
<p class="indent">So, the output of the compilation phase is assembly, in reasonably human-readable form, with symbolic information intact. As mentioned, <code>gcc</code> normally calls all compilation phases automatically, so to see the emitted assembly from the compilation stage, you have to tell <code>gcc</code> to stop after this stage and store the assembly files to disk. You can do this using the <code>-S</code> flag (<em>.s</em> is a conventional extension for assembly files). You also pass the option <code>-masm=intel</code> to <code>gcc</code> so that it emits assembly in Intel syntax rather than the <span epub:type="pagebreak" id="page_15"/>default AT&amp;T syntax. <a href="ch01.xhtml#ch01list3">Listing 1-3</a> shows the output of the compilation phase for the example program.<sup><a id="ch01fn_2a" href="footnote.xhtml#ch01fn_2">2</a></sup></p>&#13;
<p class="listing1" id="ch01list3"><em>Listing 1-3: Assembly generated by the compilation phase for the “Hello, world!” program</em></p>&#13;
<pre>  $ <span class="codestrong1">gcc -S -masm=intel compilation_example.c</span><br/>  $ <span class="codestrong1">cat compilation_example.s</span><br/><br/><br/>          .file    "compilation_example.c"<br/>          .intel_syntax noprefix<br/>          .section       .rodata<br/><span class="ent">➊</span> .LC0:<br/>          .string        "Hello, world!"<br/>          .text<br/>          .globl  main<br/>          .type   main, @function<br/><span class="ent">➋</span> main:<br/>  .LFB0:<br/>          .cfi_startproc<br/>          push    rbp<br/>          .cfi_def_cfa_offset 16<br/>          .cfi_offset 6, -16<br/>          mov     rbp, rsp<br/>          .cfi_def_cfa_register 6<br/>          sub      rsp, 16<br/>          mov     DWORD PTR [rbp-4], edi<br/>          mov     QWORD PTR [rbp-16], rsi<br/>          mov     edi, <span class="ent">➌</span>OFFSET FLAT:.LC0<br/>          call    puts<br/>          mov     eax, 0<br/>          leave<br/>          .cfi_def_cfa 7, 8<br/>          ret<br/>          .cfi_endproc<br/>.LFE0:<br/>          .size    main, .-main<br/>          .ident   "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609"<br/>          .section .note.GNU-stack,"",@progbits</pre>&#13;
<p class="indent">For now, I won’t go into detail about the assembly code. What’s interesting to note in <a href="ch01.xhtml#ch01list3">Listing 1-3</a> is that the assembly code is relatively easy to read because the symbols and functions have been preserved. For instance, constants and variables have symbolic names rather than just addresses (even if it’s just an automatically generated name, such as <code>LC0</code> <span class="ent">➊</span> for the nameless “Hello, world!” string), and there’s an explicit label for the <code>main</code> function <span class="ent">➋</span> <span epub:type="pagebreak" id="page_16"/>(the only function in this case). Any references to code and data are also symbolic, such as the reference to the “Hello, world!” string <span class="ent">➌</span>. You’ll have no such luxury when dealing with stripped binaries later in the book!</p>&#13;
<h4 class="h4" id="ch01_1_3"><em>1.1.3 The Assembly Phase</em></h4>&#13;
<p class="noindent">In the assembly phase, you finally get to generate some real machine code! The input of the assembly phase is the set of assembly language files generated in the compilation phase, and the output is a set of <em>object files</em>, sometimes also referred to as <em>modules</em>. Object files contain machine instructions that are in principle executable by the processor. But as I’ll explain in a minute, you need to do some more work before you have a ready-torun binary executable file. Typically, each source file corresponds to one assembly file, and each assembly file corresponds to one object file. To generate an object file, you pass the <code>-c</code> flag to <code>gcc</code>, as shown in <a href="ch01.xhtml#ch01list4">Listing 1-4</a>.</p>&#13;
<p class="listing1" id="ch01list4"><em>Listing 1-4: Generating an object file with</em> <code><em>gcc</em></code></p>&#13;
<pre>$ <span class="codestrong1">gcc -c compilation_example.c</span><br/>$ <span class="codestrong1">file compilation_example.o</span><br/>compilation_example.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</pre>&#13;
<p class="indent">You can use the <code>file</code> utility (a handy utility that I’ll return to in <a href="ch05.xhtml#ch05">Chapter 5</a>) to confirm that the produced file, <em>compilation_example.o</em>, is indeed an object file. As you can see in <a href="ch01.xhtml#ch01list4">Listing 1-4</a>, this is the case: the file shows up as an <code>ELF 64-bit LSB relocatable</code> file.</p>&#13;
<p class="indent">What exactly does this mean? The first part of the <code>file</code> output shows that the file conforms to the ELF specification for binary executables (which I’ll discuss in detail in <a href="ch02.xhtml#ch02">Chapter 2</a>). More specifically, it’s a 64-bit ELF file (since you’re compiling for x86-64 in this example), and it is <em>LSB</em>, meaning that numbers are ordered in memory with their least significant byte first. But most important, you can see that the file is <em>relocatable</em>.</p>&#13;
<p class="indent">Relocatable files don’t rely on being placed at any particular address in memory; rather, they can be moved around at will without this breaking any assumptions in the code. When you see the term <em>relocatable</em> in the <code>file</code> output, you know you’re dealing with an object file and not with an executable.<sup><a id="ch01fn_3a" href="footnote.xhtml#ch01fn_3">3</a></sup></p>&#13;
<p class="indent">Object files are compiled independently from each other, so the assembler has no way of knowing the memory addresses of other object files when assembling an object file. That’s why object files need to be relocatable; that way, you can link them together in any order to form a complete binary executable. If object files were not relocatable, this would not be possible.</p>&#13;
<p class="indent">You’ll see the contents of the object file later in this chapter, when you’re ready to disassemble a file for the first time.</p>&#13;
<h4 class="h4" id="ch01_1_4"><span epub:type="pagebreak" id="page_17"/><em>1.1.4 The Linking Phase</em></h4>&#13;
<p class="noindent">The linking phase is the final phase of the compilation process. As the name implies, this phase links together all the object files into a single binary executable. In modern systems, the linking phase sometimes incorporates an additional optimization pass, called <em>link-time optimization (LTO)</em>.<sup><a id="ch01fn_4a" href="footnote.xhtml#ch01fn_4">4</a></sup></p>&#13;
<p class="indent">Unsurprisingly, the program that performs the linking phase is called a <em>linker</em>, or <em>link editor</em>. It’s typically separate from the compiler, which usually implements all the preceding phases.</p>&#13;
<p class="indent">As I’ve already mentioned, object files are relocatable because they are compiled independently from each other, preventing the compiler from assuming that an object will end up at any particular base address. Moreover, object files may reference functions or variables in other object files or in libraries that are external to the program. Before the linking phase, the addresses at which the referenced code and data will be placed are not yet known, so the object files only contain <em>relocation symbols</em> that specify how function and variable references should eventually be resolved. In the context of linking, references that rely on a relocation symbol are called <em>symbolic references</em>. When an object file references one of its own functions or variables by absolute address, the reference will also be symbolic.</p>&#13;
<p class="indent">The linker’s job is to take all the object files belonging to a program and merge them into a single coherent executable, typically intended to be loaded at a particular memory address. Now that the arrangement of all modules in the executable is known, the linker can also resolve most symbolic references. References to libraries may or may not be completely resolved, depending on the type of library.</p>&#13;
<p class="indent">Static libraries (which on Linux typically have the extension <em>.a</em>, as shown in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a>) are merged into the binary executable, allowing any references to them to be resolved entirely. There are also dynamic (shared) libraries, which are shared in memory among all programs that run on a system. In other words, rather than copying the library into every binary that uses it, dynamic libraries are loaded into memory only once, and any binary that wants to use the library needs to use this shared copy. During the linking phase, the addresses at which dynamic libraries will reside are not yet known, so references to them cannot be resolved. Instead, the linker leaves symbolic references to these libraries even in the final executable, and these references are not resolved until the binary is actually loaded into memory to be executed.</p>&#13;
<p class="indent">Most compilers, including <code>gcc</code>, automatically call the linker at the end of the compilation process. Thus, to produce a complete binary executable, you can simply call <code>gcc</code> without any special switches, as shown in <a href="ch01.xhtml#ch01list5">Listing 1-5</a>.</p>&#13;
<p class="listing1" id="ch01list5"><em>Listing 1-5: Generating a binary executable with</em> <code><em>gcc</em></code></p>&#13;
<pre><span class="codestrong1">$ gcc compilation_example.c</span><br/><span class="codestrong1">$ file a.out</span><br/>a.out: <span class="ent">➊</span>ELF 64-bit LSB executable, x86-64, version 1 (SYSV), <span class="ent">➋</span>dynamically<br/>linked, <span class="ent">➌</span>interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32,<br/>BuildID[sha1]=d0e23ea731bce9de65619cadd58b14ecd8c015c7, <span class="ent">➍</span>not stripped<br/><span class="codestrong1">$ ./a.out</span><br/>Hello, world!</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_18"/>By default, the executable is called <em>a.out</em>, but you can override this naming by passing the <code>-o</code> switch to <code>gcc</code>, followed by a name for the output file. The <code>file</code> utility now tells you that you’re dealing with an <code>ELF 64-bit LSB executable</code> <span class="ent">➊</span>, rather than a relocatable file as you saw at the end of the assembly phase. Other important information is that the file is dynamically linked <span class="ent">➋</span>, meaning that it uses some libraries that are not merged into the executable but are instead shared among all programs running on the same system. Finally, <code>interpreter /lib64/ld-linux-x86-64.so.2</code> <span class="ent">➌</span> in the <code>file</code> output tells you which <em>dynamic linker</em> will be used to resolve the final dependencies on dynamic libraries when the executable is loaded into memory to be executed. When you run the binary (using the command <code>./a.out</code>), you can see that it produces the expected output (printing “Hello, world!” to standard output), which confirms that you have produced a working binary.</p>&#13;
<p class="indent">But what’s this bit about the binary not being “stripped” <span class="ent">➍</span>? I’ll discuss that next!</p>&#13;
<h3 class="h3" id="ch01_2">1.2 Symbols and Stripped Binaries</h3>&#13;
<p class="noindent">High-level source code, such as C code, centers around functions and variables with meaningful, human-readable names. When compiling a program, compilers emit <em>symbols</em>, which keep track of such symbolic names and record which binary code and data correspond to each symbol. For instance, function symbols provide a mapping from symbolic, high-level function names to the first address and the size of each function. This information is normally used by the linker when combining object files (for instance, to resolve function and variable references between modules) and also aids debugging.</p>&#13;
<h4 class="h4" id="ch01_2_1"><em>1.2.1 Viewing Symbolic Information</em></h4>&#13;
<p class="noindent">To give you an idea of what the symbolic information looks like, <a href="ch01.xhtml#ch01list6">Listing 1-6</a> shows some of the symbols in the example binary.</p>&#13;
<p class="listing1" id="ch01list6"><em>Listing 1-6: Symbols in the</em> <code><em>a.out</em></code> <em>binary as shown by</em> <code><em>readelf</em></code></p>&#13;
<pre>$ <span class="ent">➊</span><span class="codestrong1">readelf --syms a.out</span><br/><br/>Symbol table '.dynsym' contains 4 entries:<br/>  Num:    Value          Size Type    Bind   Vis      Ndx Name<br/>    0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br/>    1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)<br/>    2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)<br/>    3: 0000000000000000     0 NOTYPE WEAK    DEFAULT  UND __gmon_start__<br/>Symbol table '.symtab' contains 67 entries:<br/>  Num:    Value          Size Type    Bind   Vis      Ndx Name<br/>   ...<br/>   56: 0000000000601030     0 OBJECT  GLOBAL HIDDEN    25 __dso_handle<br/>   57: 00000000004005d0     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used<br/>   58: 0000000000400550   101 FUNC    GLOBAL DEFAULT   14 __libc_csu_init<br/>   59: 0000000000601040     0 NOTYPE  GLOBAL DEFAULT   26 _end<br/>   60: 0000000000400430    42 FUNC    GLOBAL DEFAULT   14 _start<br/>   61: 0000000000601038     0 NOTYPE  GLOBAL DEFAULT   26 __bss_start<br/>   62: 0000000000400526    32 FUNC    GLOBAL DEFAULT   14 <span class="ent">➋</span>main<br/>   63: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses<br/>   64: 0000000000601038     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__<br/>   65: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable<br/>   66: 00000000004003c8     0 FUNC    GLOBAL DEFAULT   11 _init</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>In <a href="ch01.xhtml#ch01list6">Listing 1-6</a>, I’ve used <code>readelf</code> to display the symbols <span class="ent">➊</span>. You’ll return to using the <code>readelf</code> utility, and interpreting all its output, in <a href="ch05.xhtml#ch05">Chapter 5</a>. For now, just note that, among many unfamiliar symbols, there’s a symbol for the <code>main</code> function <span class="ent">➋</span>. You can see that it specifies the address (<code>0x400526</code>) at which <code>main</code> will reside when the binary is loaded into memory. The output also shows the code size of <code>main</code> (32 bytes) and indicates that you’re dealing with a function symbol (type <code>FUNC</code>).</p>&#13;
<p class="indent">Symbolic information can be emitted as part of the binary (as you’ve seen just now) or in the form of a separate symbol file, and it comes in various flavors. The linker needs only basic symbols, but far more extensive information can be emitted for debugging purposes. Debugging symbols go as far as providing a full mapping between source lines and binary-level instructions, and they even describe function parameters, stack frame information, and more. For ELF binaries, debugging symbols are typically generated in the DWARF format,<sup><a id="ch01fn_5a" href="footnote.xhtml#ch01fn_5">5</a></sup> while PE binaries usually use the proprietary Microsoft Portable Debugging (PDB) format.<sup><a id="ch01fn_6a" href="footnote.xhtml#ch01fn_6">6</a></sup> DWARF information is usually embedded within the binary, while PDB comes in the form of a separate symbol file.</p>&#13;
<p class="indent">As you might imagine, symbolic information is extremely useful for binary analysis. To name just one example, having a set of well-defined function symbols at your disposal makes disassembly much easier because you can use each function symbol as a starting point for disassembly. This makes it much less likely that you’ll accidentally disassemble data as code, for instance (which would lead to bogus instructions in the disassembly output). Knowing which parts of a binary belong to which function, and what the function is called, also makes it much easier for a human reverse engineer to compartmentalize and understand what the code is doing. Even just <span epub:type="pagebreak" id="page_20"/>basic linker symbols (as opposed to more extensive debugging information) are already a tremendous help in many binary analysis applications.</p>&#13;
<p class="indent">You can parse symbols with <code>readelf</code>, as I mentioned above, or programmatically with a library like <code>libbfd</code>, as I’ll explain in <a href="ch04.xhtml#ch04">Chapter 4</a>. There are also libraries like <code>libdwarf</code> specifically designed for parsing DWARF debug symbols, but I won’t cover them in this book.</p>&#13;
<p class="indent">Unfortunately, extensive debugging information typically isn’t included in production-ready binaries, and even basic symbolic information is often stripped to reduce file sizes and prevent reverse engineering, especially in the case of malware or proprietary software. This means that as a binary analyst, you often have to deal with the far more challenging case of stripped binaries without any form of symbolic information. Throughout this book, I therefore assume as little symbolic information as feasible and focus on stripped binaries, except where noted otherwise.</p>&#13;
<h4 class="h4" id="ch01_2_2"><em>1.2.2 Another Binary Turns to the Dark Side: Stripping a Binary</em></h4>&#13;
<p class="noindent">You may remember that the example binary is not yet stripped (as shown in the output from the <code>file</code> utility in <a href="ch01.xhtml#ch01list5">Listing 1-5</a>). Apparently, the default behavior of <code>gcc</code> is not to automatically strip newly compiled binaries. In case you’re wondering how binaries with symbols end up stripped, it’s as simple as using a single command, aptly named <code>strip</code>, as shown in <a href="ch01.xhtml#ch01list7">Listing 1-7</a>.</p>&#13;
<p class="listing1" id="ch01list7"><em>Listing 1-7: Stripping an executable</em></p>&#13;
<pre>  $ <span class="ent">➊</span><span class="codestrong1">strip --strip-all a.out</span><br/>  $ <span class="codestrong1">file a.out</span><br/>  a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically<br/>  linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32,<br/>  BuildID[sha1]=d0e23ea731bce9de65619cadd58b14ecd8c015c7, <span class="ent">➋</span>stripped<br/>  $ <span class="codestrong1">readelf --syms a.out</span><br/><br/><span class="ent">➌</span> Symbol table '.dynsym' contains 4 entries:<br/>     Num:    Value          Size Type    Bind   Vis     Ndx Name<br/>       0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT UND<br/>       1: 0000000000000000     0 FUNC    GLOBAL DEFAULT UND puts@GLIBC_2.2.5 (2)<br/>       2: 0000000000000000     0 FUNC    GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2)<br/>       3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT UND __gmon_start__</pre>&#13;
<p class="indent">Just like that, the example binary is now stripped <span class="ent">➊</span>, as confirmed by the <code>file</code> output <span class="ent">➋</span>. Only a few symbols are left in the <code>.dynsym</code> symbol table <span class="ent">➌</span>. These are used to resolve dynamic dependencies (such as references to dynamic libraries) when the binary is loaded into memory, but they’re not much use when disassembling. All the other symbols, including the one for the <code>main</code> function that you saw in <a href="ch01.xhtml#ch01list6">Listing 1-6</a>, have disappeared.</p>&#13;
<h3 class="h3" id="ch01_3"><span epub:type="pagebreak" id="page_21"/>1.3 Disassembling a Binary</h3>&#13;
<p class="noindent">Now that you’ve seen how to compile a binary, let’s take a look at the contents of the object file produced in the assembly phase of compilation. After that, I’ll disassemble the main binary executable to show you how its contents differ from those of the object file. This way, you’ll get a clearer understanding of what’s in an object file and what’s added during the linking phase.</p>&#13;
<h4 class="h4" id="ch01_3_1"><em>1.3.1 Looking Inside an Object File</em></h4>&#13;
<p class="noindent">For now, I’ll use the <code>objdump</code> utility to show how to do all the disassembling (I’ll discuss other disassembly tools in <a href="ch06.xhtml#ch06">Chapter 6</a>). It’s a simple, easy-to-use disassembler included with most Linux distributions, and it’s perfect to get a quick idea of the code and data contained in a binary. <a href="ch01.xhtml#ch01list8">Listing 1-8</a> shows the disassembled version of the example object file, <em>compilation_example.o</em>.</p>&#13;
<p class="listing1" id="ch01list8"><em>Listing 1-8: Disassembling an object file</em></p>&#13;
<pre>$ <span class="ent">➊</span><span class="codestrong1">objdump -sj .rodata compilation_example.o</span><br/><br/>compilation_example.o:   file format elf64-x86-64<br/><br/>Contents of section .rodata:<br/> 0000 48656c6c 6f2c2077 6f726c64 2100    Hello, world!.<br/><br/>$ <span class="ent">➋</span><span class="codestrong1">objdump -M intel -d compilation_example.o</span><br/><br/>compilation_example.o:   file format elf64-x86-64<br/><br/>Disassembly of section .text:<br/><br/>0000000000000000 <span class="ent">➌</span>&lt;main&gt;:<br/>   0:  55                     push   rbp<br/>   1:  48 89 e5               mov    rbp,rsp<br/>   4:  48 83 ec 10            sub    rsp,0x10<br/>   8:  89 7d fc               mov    DWORD PTR [rbp-0x4],edi<br/>   b:  48 89 75 f0            mov    QWORD PTR [rbp-0x10],rsi<br/>   f:  bf 00 00 00 00         mov    edi,<span class="ent">➍</span>0x0<br/>  14:  e8 00 00 00 00       <span class="ent">➎</span>call   19 &lt;main+0x19&gt;<br/>  19:  b8 00 00 00 00         mov    eax,0x0<br/>  1e:  c9                     leave<br/>  1f:  c3                     ret</pre>&#13;
<p class="indent">If you look carefully at <a href="ch01.xhtml#ch01list8">Listing 1-8</a>, you’ll see I’ve called <code>objdump</code> twice. First, at <span class="ent">➊</span>, I tell <code>objdump</code> to show the contents of the <code>.rodata</code> section. This stands for “read-only data,” and it’s the part of the binary where all constants are stored, including the “Hello, world!” string. I’ll return to a more <span epub:type="pagebreak" id="page_22"/>detailed discussion of <code>.rodata</code> and other sections in ELF binaries in <a href="ch02.xhtml#ch02">Chapter 2</a>, which covers the ELF binary format. For now, notice that the contents of <code>.rodata</code> consist of an ASCII encoding of the string, shown on the left side of the output. On the right side, you can see the human-readable representation of those same bytes.</p>&#13;
<p class="indent">The second call to <code>objdump</code> at <span class="ent">➋</span> disassembles all the code in the object file in Intel syntax. As you can see, it contains only the code of the <code>main</code> function <span class="ent">➌</span> because that’s the only function defined in the source file. For the most part, the output conforms pretty closely to the assembly code previously produced by the compilation phase (give or take a few assembly-level macros). What’s interesting to note is that the pointer to the “Hello, world!” string (at <span class="ent">➍</span>) is set to zero. The subsequent call <span class="ent">➎</span> that should print the string to the screen using <code>puts</code> also points to a nonsensical location (offset 19, in the middle of <code>main</code>).</p>&#13;
<p class="indent">Why does the call that should reference <code>puts</code> point instead into the middle of <code>main</code>? I previously mentioned that data and code references from object files are not yet fully resolved because the compiler doesn’t know at what base address the file will eventually be loaded. That’s why the call to <code>puts</code> is not yet correctly resolved in the object file. The object file is waiting for the linker to fill in the correct value for this reference. You can confirm this by asking <code>readelf</code> to show you all the relocation symbols present in the object file, as shown in <a href="ch01.xhtml#ch01list9">Listing 1-9</a>.</p>&#13;
<p class="listing1" id="ch01list9"><em>Listing 1-9: Relocation symbols as shown by</em> <code><em>readelf</em></code></p>&#13;
<pre>   $ <span class="codestrong1">readelf --relocs compilation_example.o</span><br/><br/>   Relocation section '.rela.text' at offset 0x210 contains 2 entries:<br/>      Offset             Info         Type            Sym. Value    Sym. Name + Addend<br/><span class="ent">➊</span> <span class="gray_mark">000000000010</span>      00050000000a R_X86_64_32     0000000000000000    <span class="gray_mark">.rodata</span> + 0<br/><span class="ent">➋</span> <span class="gray_mark">000000000015</span>      000a00000002 R_X86_64_PC32   0000000000000000    <span class="gray_mark">puts</span> - 4<br/>   ...</pre>&#13;
<p class="indent">The relocation symbol at <span class="ent">➊</span> tells the linker that it should resolve the reference to the string to point to whatever address it ends up at in the <code>.rodata</code> section. Similarly, the line marked <span class="ent">➋</span> tells the linker how to resolve the call to <code>puts</code>.</p>&#13;
<p class="indent">You may notice the value 4 being subtracted from the <code>puts</code> symbol. You can ignore that for now; the way the linker computes relocations is a bit involved, and the <code>readelf</code> output can be confusing, so I’ll just gloss over the details of relocation here and focus on the bigger picture of disassembling a binary instead. I’ll provide more information about relocation symbols in <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>&#13;
<p class="indent">The leftmost column of each line in the <code>readelf</code> output (shaded) in <a href="ch01.xhtml#ch01list9">Listing 1-9</a> is the offset in the object file where the resolved reference must be filled in. If you’re paying close attention, you may have noticed that in both cases, it’s equal to the offset of the instruction that needs to be fixed, plus 1. For instance, the call to <code>puts</code> is at code offset <code>0x14</code> in the <code>objdump</code> output, but <span epub:type="pagebreak" id="page_23"/>the relocation symbol points to offset <code>0x15</code> instead. This is because you only want to overwrite the <em>operand</em> of the instruction, not the <em>opcode</em> of the instruction. It just so happens that for both instructions that need fixing up, the opcode is 1 byte long, so to point to the instruction’s operand, the relocation symbol needs to skip past the opcode byte.</p>&#13;
<h4 class="h4" id="ch01_3_2"><em>1.3.2 Examining a Complete Binary Executable</em></h4>&#13;
<p class="noindent">Now that you’ve seen the innards of an object file, it’s time to disassemble a complete binary. Let’s start with an example binary with symbols and then move on to the stripped equivalent to see the difference in disassembly output. There is a big difference between disassembling an object file and a binary executable, as you can see in the <code>objdump</code> output in <a href="ch01.xhtml#ch01list10">Listing 1-10</a>.</p>&#13;
<p class="listing1" id="ch01list10"><em>Listing 1-10: Disassembling an executable with</em> <code><em>objdump</em></code></p>&#13;
<pre>$ <span class="codestrong1">objdump -M intel -d a.out</span><br/><br/>a.out:       file format elf64-x86-64<br/><br/>Disassembly   of section <span class="ent">➊</span>.init:<br/><br/>00000000004003c8 &lt;_init&gt;:<br/>  4003c8:  48 83 ec 08             sub    rsp,0x8<br/>  4003cc:  48 8b 05 25 0c 20 00    mov    rax,QWORD PTR [rip+0x200c25]<br/>  4003d3:  48 85 c0                test   rax,rax<br/>  4003d6:  74 05                   je     4003dd &lt;_init+0x15&gt;<br/>  4003d8:  e8 43 00 00 00          call   400420 &lt;__libc_start_main@plt+0x10&gt;<br/>  4003dd:  48 83 c4 08             add    rsp,0x8<br/>  4003e1:  c3                      ret<br/><br/>Disassembly of section <span class="ent">➋</span>.plt:<br/><br/>00000000004003f0 &lt;puts@plt-0x10&gt;:<br/>  4003f0: ff 35 12 0c 20 00        push   QWORD PTR [rip+0x200c12]<br/>  4003f6: ff 25  14 0c 20 00       jmp    QWORD PTR [rip+0x200c14]<br/>  4003fc: 0f 1f  40 00             nop    DWORD PTR [rax+0x0]<br/><br/>0000000000400400 &lt;puts@plt&gt;:<br/>  400400:  ff 25 12 0c 20 00       jmp    QWORD PTR [rip+0x200c12]<br/>  400406:  68 00 00 00 00          push   0x0<br/>  40040b:  e9 e0 ff ff ff          jmp    4003f0 &lt;_init+0x28&gt;<br/><br/>...<br/><br/>Disassembly of section <span class="ent">➌</span>.text:<br/><br/>0000000000400430 &lt;_start&gt;:<br/><br/>  400430:   31 ed                  xor    ebp,ebp<br/>  400432:   49 89 d1               mov    r9,rdx<br/>  400435:   5e                     pop    rsi<br/>  400436:   48 89 e2               mov    rdx,rsp<br/>  400439:   48 83 e4 f0            and    rsp,0xfffffffffffffff0<br/>  40043d:   50                     push   rax<br/>  40043e:   54                     push   rsp<br/>  40043f:   49 c7 c0 c0 05 40 00   mov    r8,0x4005c0<br/>  400446:   48 c7 c1 50 05 40 00   mov    rcx,0x400550<br/>  40044d:   48 c7 c7 26 05 40 00   mov    rdi,0x400526<br/>  400454:   e8 b7 ff ff ff         call   400410 &lt;__libc_start_main@plt&gt;<br/>  400459:   f4                     hlt<br/>  40045a:   66 0f 1f 44 00 00      nop    WORD PTR [rax+rax*1+0x0]<br/><br/>0000000000400460 &lt;deregister_tm_clones&gt;:<br/>...<br/><br/>0000000000400526 <span class="ent">➍</span>&lt;main&gt;:<br/>  400526:  55                      push   rbp<br/>  400527:  48 89 e5                mov    rbp,rsp<br/>  40052a:  48 83 ec 10             sub    rsp,0x10<br/>  40052e:  89 7d fc                mov    DWORD PTR [rbp-0x4],edi<br/>  400531:  48 89 75 f0             mov    QWORD PTR [rbp-0x10],rsi<br/>  400535:  bf d4 05 40 00          mov    edi,0x4005d4<br/>  40053a:  e8 c1 fe ff ff          call   400400 <span class="ent">➎</span>&lt;puts@plt&gt;<br/>  40053f:  b8 00 00 00 00          mov    eax,0x0<br/>  400544:  c9                      leave<br/>  400545:  c3                      ret<br/>  400546:  66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]<br/>  40054d:  00 00 00<br/><br/>0000000000400550 &lt;__libc_csu_init&gt;:<br/>...<br/><br/>Disassembly of section .fini:<br/><br/>00000000004005c4 &lt;_fini&gt;:<br/>  4005c4:  48 83 ec 08             sub   rsp,0x8<br/>  4005c8:  48 83 c4 08             add   rsp,0x8<br/>  4005cc:  c3                      ret</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_24"/>You can see that the binary has a lot more code than the object file. It’s no longer just the <code>main</code> function or even just a single code section. There are multiple sections now, with names like <code>.init</code> <span class="ent">➊</span>, <code>.plt</code> <span class="ent">➋</span>, and <code>.text</code> <span class="ent">➌</span>. These sections all contain code serving different functions, such as program initialization or stubs for calling shared libraries.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_25"/>The <code>.text</code> section is the main code section, and it contains the <code>main</code> function <span class="ent">➍</span>. It also contains a number of other functions, such as <code>_start</code>, that are responsible for tasks such as setting up the command line arguments and runtime environment for <code>main</code> and cleaning up after <code>main</code>. These extra functions are standard functions, present in any ELF binary produced by <code>gcc</code>.</p>&#13;
<p class="indent">You can also see that the previously incomplete code and data references have now been resolved by the linker. For instance, the call to <code>puts</code> <span class="ent">➎</span> now points to the proper stub (in the <code>.plt</code> section) for the shared library that contains <code>puts</code>. (I’ll explain the workings of PLT stubs in <a href="ch02.xhtml#ch02">Chapter 2</a>.)</p>&#13;
<p class="indent">So, the full binary executable contains significantly more code (and data, though I haven’t shown it) than the corresponding object file. But so far, the output isn’t much more difficult to interpret. That changes when the binary is stripped, as shown in <a href="ch01.xhtml#ch01list11">Listing 1-11</a>, which uses <code>objdump</code> to disassemble the stripped version of the example binary.</p>&#13;
<p class="listing1" id="ch01list11"><em>Listing 1-11: Disassembling a stripped executable with</em> <code><em>objdump</em></code></p>&#13;
<pre>  $ <span class="codestrong1">objdump -M intel -d ./a.out.stripped</span><br/><br/>  ./a.out.stripped:        file format elf64-x86-64<br/><br/>  Disassembly of section <span class="ent">➊</span>.init:<br/><br/>  00000000004003c8 &lt;.init&gt;:<br/>    4003c8:  48 83 ec 08             sub    rsp,0x8<br/>    4003cc:  48 8b 05 25 0c 20 00    mov    rax,QWORD PTR [rip+0x200c25]<br/>    4003d3:  48 85 c0                test   rax,rax<br/>    4003d6:  74 05                   je     4003dd &lt;puts@plt-0x23&gt;<br/>    4003d8:  e8 43 00 00 00          call   400420 &lt;__libc_start_main@plt+0x10&gt;<br/>    4003dd:  48 83 c4 08             add    rsp,0x8<br/>    4003e1:  c3                      ret<br/><br/>  Disassembly of section <span class="ent">➋</span>.plt:<br/>  ...<br/><br/>  Disassembly of section <span class="ent">➌</span>.text:<br/><br/>  0000000000400430   &lt;.text&gt;:<br/><span class="ent">➍</span>  400430: 31 ed                     xor   ebp,ebp<br/>    400432: 49 89    d1               mov   r9,rdx<br/>    400435: 5e                        pop   rsi<br/>    400436: 48 89    e2               mov   rdx,rsp<br/>    400439: 48 83    e4 f0            and   rsp,0xfffffffffffffff0<br/>    40043d: 50                        push  rax<br/>    40043e: 54                        push  rsp<br/>    40043f: 49 c7    c0 c0 05 40 00   mov   r8,0x4005c0<br/>    400446: 48 c7    c1 50 05 40 00   mov   rcx,0x400550<br/>    40044d: 48 c7    c7 26 05 40 00   mov   rdi,0x400526<br/><span class="ent">➎</span>  400454: e8 b7 ff ff ff            call  400410 &lt;__libc_start_main@plt&gt;<br/>    400459: f4                        hlt<br/>    40045a: 66 0f 1f 44 00 00         nop   WORD PTR [rax+rax*1+0x0]<br/><span class="ent">➏</span>  400460: b8 3f 10 60 00            mov   eax,0x60103f<br/>    ...<br/>    400520: 5d                        pop   rbp<br/>    400521: e9   7a ff ff ff          jmp   4004a0 &lt;__libc_start_main@plt+0x90&gt;<br/><span class="ent">➐</span>  400526: 55                        push  rbp<br/>    400527: 48   89   e5              mov   rbp,rsp<br/>    40052a: 48   83   ec   10         sub   rsp,0x10<br/>    40052e: 89   7d   fc              mov   DWORD PTR [rbp-0x4],edi<br/>    400531: 48   89   75   f0         mov   QWORD PTR [rbp-0x10],rsi<br/>    400535: bf   d4   05   40 00      mov   edi,0x4005d4<br/>    40053a: e8   c1   fe   ff ff      call  400400 &lt;puts@plt&gt;<br/>    40053f: b8   00   00   00 00      mov   eax,0x0<br/>    400544: c9                        leave<br/><span class="ent">➑</span>  400545: c3                        ret<br/>    400546: 66   2e 0f 1f 84 00 00    nop   WORD PTR cs:[rax+rax*1+0x0]<br/>    40054d: 00   00 00<br/>    400550: 41   57                   push  r15<br/>    400552: 41   56                   push  r14<br/>    ...<br/><br/>  Disassembly of section .fini:<br/><br/>  00000000004005c4 &lt;.fini&gt;:<br/>    4005c4: 48 83 ec 08               sub   rsp,0x8<br/>    4005c8: 48 83 c4 08               add   rsp,0x8<br/>    4005cc: c3                        ret</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_26"/>The main takeaway from <a href="ch01.xhtml#ch01list11">Listing 1-11</a> is that while the different sections are still clearly distinguishable (marked <span class="ent">➊</span>, <span class="ent">➋</span>, and <span class="ent">➌</span>), the functions are not. Instead, all functions have been merged into one big blob of code. The <code>_start</code> function begins at <span class="ent">➍</span>, and <code>deregister_tm_clones</code> begins at <span class="ent">➏</span>. The <code>main</code> function starts at <span class="ent">➐</span> and ends at <span class="ent">➑</span>, but in all of these cases, there’s nothing special to indicate that the instructions at these markers represent function starts. The only exceptions are the functions in the <code>.plt</code> section, which still have their names as before (as you can see in the call to <code>__libc_start_main</code> at <span class="ent">➎</span>). Other than that, you’re on your own to try to make sense of the disassembly output.</p>&#13;
<p class="indent">Even in this simple example, things are already confusing; imagine trying to make sense of a larger binary containing hundreds of different functions all fused together! This is exactly why accurate automated function detection is so important in many areas of binary analysis, as I’ll discuss in detail in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<h3 class="h3" id="ch01_4"><span epub:type="pagebreak" id="page_27"/>1.4 Loading and Executing a Binary</h3>&#13;
<p class="noindent">Now you know how compilation works as well as how binaries look on the inside. You also learned how to statically disassemble binaries using <code>objdump</code>. If you’ve been following along, you should even have your own shiny new binary sitting on your hard drive. Now you’ll learn what happens when you load and execute a binary, which will be helpful when I discuss dynamic analysis concepts in later chapters.</p>&#13;
<p class="indent">Although the exact details vary depending on the platform and binary format, the process of loading and executing a binary typically involves a number of basic steps. <a href="ch01.xhtml#ch01fig2">Figure 1-2</a> shows how a loaded ELF binary (like the one just compiled) is represented in memory on a Linux-based platform. At a high level, loading a PE binary on Windows is quite similar.</p>&#13;
<div class="image"><a id="ch01fig2"/><img src="Images/f027-01.jpg" alt="image" width="400" height="599"/></div>&#13;
<p class="fig-caption"><em>Figure 1-2: Loading an ELF binary on a Linux-based system</em></p>&#13;
<p class="indent">Loading a binary is a complicated process that involves a lot of work by the operating system. It’s also important to note that a binary’s representation in memory does not necessarily correspond one-to-one with its on-disk representation. For instance, large regions of zero-initialized data may be collapsed in the on-disk binary (to save disk space), while all those zeros will <span epub:type="pagebreak" id="page_28"/>be expanded in memory. Some parts of the on-disk binary may be ordered differently in memory or not loaded into memory at all. Because the details depend on the binary format, I defer the topic of on-disk versus in-memory binary representations to <a href="ch02.xhtml#ch02">Chapter 2</a> (on the ELF format) and <a href="ch03.xhtml#ch03">Chapter 3</a> (on the PE format). For now, let’s stick to a high-level overview of what happens during the loading process.</p>&#13;
<p class="indent">When you decide to run a binary, the operating system starts by setting up a new process for the program to run in, including a virtual address space.<sup><a id="ch01fn_7a" href="footnote.xhtml#ch01fn_7">7</a></sup> Subsequently, the operating system maps an <em>interpreter</em> into the process’s virtual memory. This is a user space program that knows how to load the binary and perform the necessary relocations. On Linux, the interpreter is typically a shared library called <em>ld-linux.so</em>. On Windows, the interpreter functionality is implemented as part of <em>ntdll.dll</em>. After loading the interpreter, the kernel transfers control to it, and the interpreter begins its work in user space.</p>&#13;
<p class="indent">Linux ELF binaries come with a special section called <code>.interp</code> that specifies the path to the interpreter that is to be used to load the binary, as you can see with <code>readelf</code>, as shown in <a href="ch01.xhtml#ch01list12">Listing 1-12</a>.</p>&#13;
<p class="listing1" id="ch01list12"><em>Listing 1-12: Contents of the</em> <code><em>.interp</em></code> <em>section</em></p>&#13;
<pre>$ <span class="codestrong1">readelf -p .interp a.out</span><br/><br/>String dump of section '.interp':<br/>  [     0] /lib64/ld-linux-x86-64.so.2</pre>&#13;
<p class="indent">As mentioned, the interpreter loads the binary into its virtual address space (the same space in which the interpreter is loaded). It then parses the binary to find out (among other things) which dynamic libraries the binary uses. The interpreter maps these into the virtual address space (using <code>mmap</code> or an equivalent function) and then performs any necessary last-minute relocations in the binary’s code sections to fill in the correct addresses for references to the dynamic libraries. In reality, the process of resolving references to functions in dynamic libraries is often deferred until later. In other words, instead of resolving these references immediately at load time, the interpreter resolves references only when they are invoked for the first time. This is known as <em>lazy binding</em>, which I’ll explain in more detail in <a href="ch02.xhtml#ch02">Chapter 2</a>. After relocation is complete, the interpreter looks up the entry point of the binary and transfers control to it, beginning normal execution of the binary.</p>&#13;
<h3 class="h3" id="ch01_5"><span epub:type="pagebreak" id="page_29"/>1.5 Summary</h3>&#13;
<p class="noindent">Now that you’re familiar with the general anatomy and life cycle of a binary, it’s time to dive into the details of a specific binary format. Let’s start with the widespread ELF format, which is the subject of the next chapter.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch01_6">Exercises</p>&#13;
<p class="boxhead1">1. Locating Functions</p>&#13;
<p class="noindent">Write a C program that contains several functions and compile it into an assembly file, an object file, and an executable binary, respectively. Try to locate the functions you wrote in the assembly file and in the disassembled object file and executable. Can you see the correspondence between the C code and the assembly code? Finally, strip the executable and try to identify the functions again.</p>&#13;
<p class="boxhead1">2. Sections</p>&#13;
<p class="noindent">As you’ve seen, ELF binaries (and other types of binaries) are divided into sections. Some sections contain code, and others contain data. Why do you think the distinction between code and data sections exists? How do you think the loading process differs for code and data sections? Is it necessary to copy all sections into memory when a binary is loaded for execution?</p>&#13;
</div>&#13;
</div></body></html>