["```\nstruct complete_struct {\n    long member1;\n    double member2;\n};\n```", "```\nstruct empty {};\n```", "```\nstruct incomplete_struct;\n```", "```\n❶ struct s;\n\nstruct s *ptr = 0;\n\nstruct s {\n    int a;\n    int b;\n}; ❷\n\n❸ struct s x = {0,0};\n```", "```\n#include <stdio.h>\n\n❶ struct s {\n    int a;\n};\n\nint main(void) {\n    printf(\"Outer struct size: %lu\\n\", ❷ sizeof (struct s));\n\n  ❸ struct s {\n        long l;\n    };\n\n    printf(\"Inner struct size: %lu\\n\", ❹ sizeof (struct s));\n    return 0;\n}\n```", "```\n$ ./listing_18_4\nOuter struct size: 4\nInner struct size: 8\n```", "```\nint main(void) {\n\n  ❶ struct shadow {\n        int x;\n    };\n    struct shadow outer;\n    outer.x = 2;\n    {\n      ❷ struct shadow {\n            int y;\n        };\n        struct shadow inner;\n        inner.y = 3;\n      ❸ return outer.x + inner.y;\n    }\n}\n```", "```\nstruct linked_list_node ❶ {\n    int val;\n    struct linked_list_node *next;\n}; ❷\n```", "```\nstruct s {\n    int s;\n};\n```", "```\nstruct s1 {\n    int x;\n};\n\nstruct s2 {\n    int x;\n};\n```", "```\nstruct s {\n    int member;\n} x;\n```", "```\nstruct s *f(void);\n```", "```\nstruct s;\nstruct s *f(void);\n```", "```\nstruct outer {\n    struct inner {\n        int a;\n        long l;\n    } i;\n    double d;\n};\n```", "```\nstruct s var;\n`--snip--`\nlong l = var.member1;\n```", "```\nstruct s *ptr = &var;\nlong l2 = ptr->member1;\n```", "```\nstruct s foo;\nstruct s bar;\n`--snip--`\nfoo = bar;\n```", "```\nptr->member2 = 2.0;\n```", "```\nvar.member2 = 2.0;\n```", "```\nreturn_struct().member2 = 2.0;\n```", "```\nstruct s return_struct(void);\nstruct s var = return_struct();\n```", "```\nstruct example {\n    int member1;\n    double member2;\n    char array[3];\n};\n\nstruct example var = {1, 2.0, ❶ {'a', 'b', 'c'}};\n```", "```\nstruct example {\n    int member1;\n    double member2;\n    char array[3];\n};\n```", "```\nstruct_declaration = (identifier tag, member_declaration* members)\nmember_declaration = (identifier member_name, type member_type)\n```", "```\ndeclaration = `--snip--` | StructDecl(struct_declaration)\n```", "```\ntype = `--snip--` | Structure(identifier tag)\n```", "```\nexp = `--snip--`\n    | Dot(exp structure, identifier member)\n    | Arrow(exp pointer, identifier member)\n```", "```\nprogram = Program(declaration*)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\n **| StructDecl(struct_declaration)**\nvariable_declaration = (identifier name, initializer? init,\n                        type var_type, storage_class?)\nfunction_declaration = (identifier name, identifier* params, block? body,\n                        type fun_type, storage_class?)\n**struct_declaration = (identifier tag, member_declaration* members)**\n**member_declaration = (identifier member_name, type member_type)**\ninitializer = SingleInit(exp) | CompoundInit(initializer*)\ntype = Char | SChar | UChar | Int | Long | UInt | ULong | Double | Void\n     | FunType(type* params, type ret)\n     | Pointer(type referenced)\n     | Array(type element, int size)\n **| Structure(identifier tag)**\nstorage_class = Static | Extern\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(exp?)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(const)\n    | String(string)\n    | Var(identifier)\n    | Cast(type target_type, exp)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\n    | Dereference(exp)\n    | AddrOf(exp)\n    | Subscript(exp, exp)\n    | SizeOf(exp)\n    | SizeOfT(type)\n **| Dot(exp structure, identifier member)**\n **| Arrow(exp pointer, identifier member)**\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\nconst = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)\n      | ConstDouble(double) | ConstChar(int) | ConstUChar(int)\n```", "```\n<program> ::= {<declaration>}\n<declaration> ::= <variable-declaration> | <function-declaration> **| <struct-declaration>**\n<variable-declaration> ::= {<specifier>}+ <declarator> [\"=\" <initializer>] \";\"\n<function-declaration> ::= {<specifier>}+ <declarator> (<block> | \";\")\n**<struct-declaration> ::= \"struct\" <identifier>** ❶ **[\"{\" {<member-declaration>}+ \"}\"] \";\"**\n**<member-declaration> ::= {<type-specifier>}+ <declarator> \";\"**\n<declarator> ::= \"*\" <declarator> | <direct-declarator>\n<direct-declarator> ::= <simple-declarator> [<declarator-suffix>]\n<declarator-suffix> ::= <param-list> | {\"[\" <const> \"]\"}+\n<param-list> ::= \"(\" \"void\" \")\" | \"(\" <param> {\",\" <param>} \")\"\n<param> ::= {<type-specifier>}+ <declarator>\n<simple-declarator> ::= <identifier> | \"(\" <declarator> \")\"\n<type-specifier> ::= \"int\" | \"long\" | \"unsigned\" | \"signed\" | \"double\" | \"char\" | \"void\"\n                   **| \"struct\" <identifier>**\n<specifier> ::= <type-specifier> | \"static\" | \"extern\"\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<initializer> ::= <exp> | \"{\" <initializer> {\",\" <initializer>} [\",\"] \"}\"\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" [<exp>] \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= <cast-exp> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<cast-exp> ::= \"(\" <type-name> \")\" <cast-exp>\n             | <unary-exp>\n<unary-exp> ::= <unop> <cast-exp>\n              | \"sizeof\" <unary-exp>\n              | \"sizeof\" \"(\" <type-name> \")\"\n              | <postfix-exp>\n<type-name> ::= {<type-specifier>}+ [<abstract-declarator>]\n<postfix-exp> ::= <primary-exp> {**<postfix-op>}**\n**<postfix-op> ::= \"[\" <exp> \"]\"**\n **| \".\" <identifier>**\n **| \"->\" <identifier>**\n<primary-exp> ::= <const> | <identifier> | \"(\" <exp> \")\" | {<string>}+\n                | <identifier> \"(\" [<argument-list>] \")\"\n<argument-list> ::= <exp> {\",\" <exp>}\n<abstract-declarator> ::= \"*\" [<abstract-declarator>]\n                        | <direct-abstract-declarator>\n<direct-abstract-declarator> ::= \"(\" <abstract-declarator> \")\" {\"[\" <const> \"]\"}\n                               | {\"[\" <const> \"]\"}+\n<unop> ::= \"-\" | \"~\" | \"!\" | \"*\" | \"&\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<const> ::= <int> | <long> | <uint> | <ulong> | <double> | <char>\n<identifier> ::= ? An identifier token ?\n<string> ::= ? A string token ?\n<int> ::= ? An int token ?\n<char> ::= ? A char token ?\n<long> ::= ? An int or long token ?\n<uint> ::= ? An unsigned int token ?\n<ulong> ::= ? An unsigned int or unsigned long token ?\n<double> ::= ? A floating-point constant token ?\n```", "```\nstruct contains_function {\n    int foo(void);\n};\n```", "```\nresolve_type(type_specifier, structure_map):\n    match type_specifier with\n    | Structure(tag) ->\n        if tag is in structure_map:\n            unique_tag = structure_map.get(tag).new_tag\n          ❶ return Structure(unique_tag)\n        else:\n          ❷ fail(\"Specified an undeclared structure type\")\n    | Pointer(referenced_t) ->\n        resolved_t = resolve_type(referenced_t, structure_map)\n        return Pointer(resolved_t)\n    | Array(elem_t, size) -> \n        `--snip--`\n    | FunType(param_ts, ret_t) -> \n        `--snip--`\n    | t -> return t\n```", "```\nresolve_structure_declaration(decl, structure_map):\n    prev_entry = structure_map.get(decl.tag) ❶\n    if (prev_entry is null) or (not prev_entry.from_current_scope):\n        unique_tag = make_temporary()\n        structure_map.add(decl.tag, MapEntry(new_tag=unique_tag, from_current_scope=True)) ❷\n    else:\n        unique_tag = prev_entry.new_tag ❸\n    processed_members = []\n for member in decl.members:\n        processed_type = resolve_type(member.member_type, structure_map) ❹\n        processed_member = (member_name=member.member_name, member_type=processed_type)\n        processed_members.append(processed_member)\n    resolved_decl = (tag=unique_tag, members=processed_members)\n    return resolved_decl ❺\n```", "```\nstruct linked_list_node {\n    int val;\n    struct linked_list_node *next;\n};\n```", "```\nstruct_entry = StructEntry(int alignment, int size, member_entry* members)\nmember_entry = MemberEntry(identifier member_name, type member_type, int offset)\n```", "```\ntypecheck_struct_declaration(struct_decl, type_table):\n  ❶ if struct_decl.members is empty:\n        return\n  ❷ validate_struct_definition(struct_decl, type_table)\n\n    // define a member_entry for each member\n  ❸ member_entries = []\n    struct_size = 0\n    struct_alignment = 1\n    for member in struct_decl.members:\n        member_alignment = alignment(member.member_type, type_table)\n      ❹ member_offset = round_up(struct_size, member_alignment)\n      ❺ m = MemberEntry(member.member_name, member.member_type,\n                        member_offset)\n        member_entries.append(m)\n        struct_alignment = max(struct_alignment, member_alignment)\n        struct_size = member_offset + size(member.member_type, type_table)\n\n    // define a struct_entry for the whole structure\n  ❻ struct_size = round_up(struct_size, struct_alignment)\n    struct_def = StructEntry(struct_alignment, struct_size, member_entries)\n  ❼ type_table.add(struct_decl.tag, struct_def)\n```", "```\nis_scalar(t):\n    match t with\n    | Void -> return False\n    | Array(elem_t, size) -> return False\n    | FunType(param_ts, ret_t) -> return False\n **| Structure(tag) -> return False**\n    | _ -> return True\n```", "```\nis_complete(t, type_table):\n    match t with\n    | Void -> return False\n    | Structure(tag) ->\n        if tag is in type_table:\n            return True\n        else:\n            return False\n    | _ -> return True\n```", "```\n❶ struct s;\n❷ struct t {\n    struct s member;\n};\n❸ struct s {\n    int a;\n    int b;\n};\n```", "```\nalignment(t, type_table):\n    match t with\n    | Structure(tag) ->\n        struct_def = type_table.get(tag)\n        return struct_def.alignment\n    | Array(elem_t, size) ->\n        return alignment(elem_t, type_table)\n    | `--snip--`\n```", "```\nconvert_by_assignment(e, target_type):\n    if get_type(e) == target_type:\n        return e\n    if get_type(e) is arithmetic and target_type is arithmetic:\n        return convert_to(e, target_type)\n    if is_null_pointer_constant(e) and target_type is a pointer type:\n        return convert_to(e, target_type)\n    if target_type == Pointer(Void) and get_type(e) is a pointer type:\n        return convert_to(e, target_type)\n    if target_type is a pointer type and get_type(e) == Pointer(Void):\n        return convert_to(e, target_type)\n    else:\n        fail(\"Cannot convert type for assignment\")\n```", "```\nvoid take_a_struct(struct s incomplete);\n```", "```\nvoid take_a_struct(struct s incomplete) {\n    return;\n}\n```", "```\nextern struct s my_incomplete_struct;\nstruct s *ptr = &my_incomplete_struct;\n```", "```\nstruct s *another_ptr = &*ptr;\n```", "```\n(void) my_incomplete_struct;\n*ptr;\n```", "```\ntypecheck_and_convert(e, symbols, **type_table**):\n    typed_e = typecheck_exp(e, symbols, **type_table**)\n    match get_type(typed_e) with\n    | Array(elem_t, size) ->\n `--snip--`\n **| Structure(tag) ->**\n **if tag is not in type_table:**\n **fail(\"Invalid use of incomplete structure type\")**\n **return typed_e**\n    | _ -> return typed_e\n```", "```\ntypecheck_exp(e, symbols, type_table):\n    match e with\n  | `--snip--`\n    | Dot(structure, member) ->\n        typed_structure = typecheck_and_convert(structure, symbols, type_table)\n      ❶ match get_type(typed_structure) with\n        | Structure(tag) ->\n          ❷ struct_def = type_table.get(tag)\n ❸ member_def = `<find member in struct_def.members>`\n            if member_def is not found:\n                fail(\"Structure has no member with this name\")\n            member_exp = Dot(typed_structure, member)\n          ❹ return set_type(member_exp, member_def.member_type)\n        | _ -> fail(\"Tried to get member of non-structure\")\n    | Arrow(pointer, member) ->\n        `--snip--`\n```", "```\nstruct s {\n    int arr[3];\n};\n\nstruct s f(void);\n\nint main(void) {\n    int *pointer_to_array[3] = &(f().arr);\n `--snip--`\n}\n```", "```\nstruct s {\n    int arr[3];\n};\n\nstruct s f(void);\n\nint main(void) {\n    return f().arr[0];\n}\n```", "```\ntypecheck_init(target_type, init, symbols, type_table):\n    match target_type, init with\n    | Structure(tag), CompoundInit(init_list) ->\n        struct_def = type_table.get(tag) ❶\n        if length(init_list) > length(struct_def.members): ❷\n            fail(\"Too many elements in structure initializer\")\n        i = 0\n        typechecked_list = []\n        for init_elem in init_list: ❸\n            t = struct_def.members[i].member_type\n            typechecked_elem = typecheck_init(t, init_elem, symbols, type_table)\n            typechecked_list.append(typechecked_elem)\n            i += 1\n        while i < length(struct_def.members): ❹\n            t = struct_def.members[i].member_type\n            typechecked_list.append(zero_initializer(t))\n            i += 1\n        return set_type(CompoundInit(typechecked_list), target_type)\n    | `--snip--`\n```", "```\nstruct example {\n    int member1;\n    double member2;\n    char array[3];\n};\n\nstruct example var = {1, 2.0, {'a', 'b', 'c'}};\n```", "```\nInitial([IntInit(1),\n       ❶ ZeroInit(4),\n         DoubleInit(2.0),\n         CharInit(97),\n         CharInit(98),\n         CharInit(99),\n       ❷ ZeroInit(5)])\n```", "```\ncreate_static_init_list(init_type, initializer, type_table):\n    match init_type, initializer with\n    | Structure(tag), CompoundInit(init_list) ->\n      ❶ struct_def = type_table.get(tag)\n        if length(init_list) > length(struct_def.members):\n            fail(\"Too many elements in structure initializer\")\n        current_offset = 0\n        static_inits = []\n        i = 0\n        for init_elem in init_list:\n            member = struct_def.members[i]\n            if member.offset != current_offset:\n              ❷ static_inits.append(ZeroInit(member.offset - current_offset))\n          ❸ more_static_inits = create_static_init_list(member.member_type,\n                                                        init_elem,\n                                                        type_table)\n            static_inits.append_all(more_static_inits)\n            current_offset = member.offset + size(member.member_type,\n                                                  type_table)\n            i += 1\n        if struct_def.size != current_offset:\n          ❹ static_inits.append(ZeroInit(struct_def.size - current_offset))\n        return static_inits\n | Structure(tag), SingleInit(e) ->\n      ❺ fail(\"Cannot initialize static structure with scalar expression\")\n    | `--snip--`\n```", "```\nCopyFromOffset(identifier src, int offset, val dst)\n```", "```\nprogram = Program(top_level*)\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, type t, static_init* init_list)\n          | StaticConstant(identifier, type t, static_init init)\ninstruction = Return(val?)\n            | SignExtend(val src, val dst)\n            | Truncate(val src, val dst)\n            | ZeroExtend(val src, val dst)\n            | DoubleToInt(val src, val dst)\n            | DoubleToUInt(val src, val dst)\n            | IntToDouble(val src, val dst)\n            | UIntToDouble(val src, val dst)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | GetAddress(val src, val dst)\n            | Load(val src_ptr, val dst)\n            | Store(val src, val dst_ptr)\n            | AddPtr(val ptr, val index, int scale, val dst)\n | CopyToOffset(val src, identifier dst, int offset)\n            **| CopyFromOffset(identifier src, int offset, val dst)**\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, val? dst)\nval = Constant(const) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\n`<instructions for struct>`\ns = `<result of struct>`\nresult = CopyFromOffset(s, `<member offset>`)\n```", "```\n`<instructions for struct>`\ndst = `<result of struct>`\n`<instructions for right>`\nsrc = `<result of right>`\nCopyToOffset(src, dst, `<member offset>`)\n```", "```\n`<instructions for struct>`\ns = `<result of struct>`\nresult = GetAddress(s)\nresult = AddPtr(ptr=result, index=`<member offset>`, scale=1)\n```", "```\nstruct inner {\n    char c;\n    int i;\n};\n\nstruct outer {\n    int member1;\n    struct inner member2;\n};\n```", "```\nresult = CopyFromOffset(\"my_struct\", 8)\n```", "```\ninner_struct_pointer->i = 1\n```", "```\nptr = AddPtr(ptr=inner_struct_pointer, index=4, scale=1)\nStore(1, ptr)\n```", "```\n(*inner_struct_pointer).i = 1\n```", "```\nexp_result = PlainOperand(val)\n           | DereferencedPointer(val)\n **| SubObject(identifier base, int offset)**\n```", "```\nemit_tacky(e, instructions, symbols, type_table):\n    match e with\n  | `--snip--`\n    | Dot(structure, member) ->\n        struct_def = `<look up structure's type in the type table>`\n        member_offset = `<look up member offset in struct_def>`\n        inner_object = emit_tacky(structure, instructions, symbols, type_table)\n        match inner_object with\n        | PlainOperand(Var(v)) -> return SubObject(v, member_offset) ❶\n        | SubObject(base, offset) -> return SubObject(base, offset + member_offset) ❷\n        | DereferencedPointer(ptr) -> ❸\n            dst_ptr = make_tacky_variable(Pointer(get_type(e)), symbols)\n            instr = AddPtr(ptr=ptr, index=Constant(ConstLong(member_offset)),\n                           scale=1, dst=dst_ptr)\n            instructions.append(instr)\n            return DereferencedPointer(dst_ptr)\n```", "```\nemit_tacky_and_convert(e, instructions, symbols, type_table):\n    result = emit_tacky(e, instructions, symbols, type_table)\n    match result with\n    | SubObject(base, offset) ->\n        dst = make_tacky_variable(get_type(e), symbols)\n        instructions.append(CopyFromOffset(base, offset, dst))\n        return dst\n    | `--snip--`\n```", "```\nemit_tacky(e, instructions, symbols, type_table):\n    match e with\n    | `--snip--`\n    | Assignment(left, right) ->\n        lval = emit_tacky(left, instructions, symbols, type_table)\n        rval = emit_tacky_and_convert(right, instructions, symbols, type_table)\n        match lval with\n        | SubObject(base, offset) ->\n            instructions.append(CopyToOffset(rval, base, offset))\n            return PlainOperand(rval)\n        | `--snip--`\n```", "```\n | AddrOf(inner) ->\n        v = emit_tacky(inner, instructions, symbols, type_table)\n        match v with\n        | SubObject(base, offset) ->\n            dst = make_tacky_variable(get_type(e), symbols)\n            instructions.append(GetAddress(Var(base), dst))\n            instructions.append(AddPtr(ptr=dst,\n                                       index=Constant(ConstLong(offset)),\n                                     ❶ scale=1,\n                                       dst=dst))\n            return PlainOperand(dst)\n        | `--snip--`\n```", "```\ncompound_initializer_to_tacky(var_name, offset, init, instructions, symbols, type_table):\n    match init, get_type(init) with\n    | SingleInit(String(s)), Array(elem_t, size) ->     `--snip--`\n    | SingleInit(e), t ->\n        v = emit_tacky_and_convert(e, instructions, symbols, type_table)\n        instructions.append(CopyToOffset(v, var_name, offset)) ❶\n    | CompoundInit(init_list), Structure(tag) ->\n        members = type_table.get(tag).members\n        for mem_init, member in zip(init_list, members):\n            mem_offset = offset + member.offset ❷\n            compound_initializer_to_tacky(var_name, mem_offset, mem_init, instructions,\n                                          symbols, type_table)\n    | CompoundInit(init_list), Array(elem_t, size) -> \n        `--snip--`\n```", "```\nstruct twelve_bytes {\n    int i;\n    char arr[8];\n};\n```", "```\nstruct inner {\n    int i;\n    char ch2;\n};\n\nstruct nested_ints {\n    char ch1;\n struct inner nested;\n};\n```", "```\nstruct flattened_ints {\n    char c;\n    int i;\n    char a;\n};\n```", "```\nstruct large {\n    int i;\n    double d;\n    char arr[10];\n};\n```", "```\nstruct two_ints {\n    int i;\n    int i2;\n};\n\nstruct nested_double {\n    double array[1];\n};\n\nstruct two_eightbytes {\n    double d;\n    char c;\n};\n```", "```\nstruct two_eightbytes {\n    double d;\n    char c;\n};\n\nvoid pass_struct(struct two_eightbytes param);\n```", "```\nmovsd   -16(%rbp), %xmm0\nmovq    -8(%rbp), %rdi\ncall    pass_struct\n```", "```\nstruct two_longs {\n    long a;\n    long b;\n};\n\nvoid a_bunch_of_arguments(int i0, int i1, int i2, int i3, int i4,\n                          struct two_longs param, int i5);\n```", "```\na_bunch_of_arguments(0, 1, 2, 3, 4, arg, 5);\n```", "```\nmovl    $0, %edi\nmovl    $1, %esi\nmovl    $2, %edx\nmovl    $3, %ecx\nmovl    $4, %r8d\nmovl    $5, %r9d\n❶ pushq   arg+8(%rip)\npushq   arg(%rip)\ncall    a_bunch_of_arguments\n```", "```\nstruct pass_in_memory {\n    double w;\n    double x;\n    int y;\n long z;\n};\n\nvoid accept_struct(struct pass_in_memory arg);\n```", "```\npushq   -8(%rbp)\npushq   -16(%rbp)\npushq   -24(%rbp)\npushq   -32 (%rbp)\ncall    accept_struct\n```", "```\nstruct large_struct {\n    long array[3];\n};\n\nstruct large_struct return_a_struct(long i) {\n    struct large_struct callee_result = {{0, 1, i}};\n    return callee_result;\n}\n\nint main(void) {\n  ❶ struct large_struct caller_result = return_a_struct(10);\n `--snip--`\n}\n```", "```\nleaq    -24(%rbp), %rdi\nmovq    $10, %rsi\ncall    return_a_struct\n```", "```\nreturn_a_struct:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    subq    $32, %rsp\n    movq    $0, -24(%rbp)\n    movq    $1, -16(%rbp)\n    movq    %rsi, -8(%rbp)\n  ❶ movq    -24(%rbp), %r10\n    movq    %r10, (%rdi)\n    movq    -16(%rbp), %r10\n    movq    %r10, 8(%rdi)\n    movq    -8(%rbp), %r10\n    movq    %r10, 16(%rdi)\n  ❷ movq    %rdi, %rax\n `--snip--`\n```", "```\noperand = `--snip--` | Data(identifier, **int**)\n```", "```\nshlq    $8, %rax\n```", "```\nbinary_operator = `--snip--` | **Shl | ShrTwoOp**\n```", "```\nprogram = Program(top_level*)\nassembly_type = Byte | Longword | Quadword | Double | ByteArray(int size, int alignment)\ntop_level = Function(identifier name, bool global, instruction* instructions)\n          | StaticVariable(identifier name, bool global, int alignment, static_init* init_list)\n          | StaticConstant(identifier name, int alignment, static_init init)\ninstruction = Mov(assembly_type, operand src, operand dst)\n            | Movsx(assembly_type src_type, assembly_type dst_type, operand src, operand dst)\n            | MovZeroExtend(assembly_type src_type, assembly_type dst_type,\n                            operand src, operand dst)\n            | Lea(operand src, operand dst)\n            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)\n            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)\n            | Unary(unary_operator, assembly_type, operand)\n            | Binary(binary_operator, assembly_type, operand, operand)\n            | Cmp(assembly_type, operand, operand)\n            | Idiv(assembly_type, operand)\n            | Div(assembly_type, operand)\n            | Cdq(assembly_type)\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | Push(operand)\n            | Call(identifier)\n            | Ret\nunary_operator = Neg | Not | Shr\nbinary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor | **Shl | ShrTwoOp**\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier, **int**)\n        | PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)\ncond_code = E | NE | G | GE | L | LE | A | AE | B | BE\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | BP\n    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15\n```", "```\nCopy(Var(\"a\"), Var(\"b\"))\n```", "```\nMov(Quadword, PseudoMem(\"a\", 0), PseudoMem(\"b\", 0))\nMov(Quadword, PseudoMem(\"a\", 8), PseudoMem(\"b\", 8))\nMov(Longword, PseudoMem(\"a\", 16), PseudoMem(\"b\", 16))\n```", "```\nLoad(Var(\"ptr\"), Var(\"y\"))\n```", "```\nMov(Quadword, Pseudo(\"ptr\"), Reg(AX))\nMov(Longword, Memory(AX, 0), PseudoMem(\"y\", 0))\nMov(Byte, Memory(AX, 4), PseudoMem(\"y\", 4))\nMov(Byte, Memory(AX, 5), PseudoMem(\"y\", 5))\n```", "```\nCopyToOffset(src=Var(\"y\"), dst=\"z\", offset=8)\n```", "```\nMov(Longword, PseudoMem(\"y\", 0), PseudoMem(\"z\", 8))\nMov(Byte, PseudoMem(\"y\", 4), PseudoMem(\"z\", 12))\nMov(Byte, PseudoMem(\"y\", 5), PseudoMem(\"z\", 13))\n```", "```\nclass = MEMORY | SSE | INTEGER\n```", "```\nclassify_structure(StructEntry(alignment, size, members)):\n    if size > 16:\n        result = []\n        while size > 0:\n            result.append(MEMORY)\n            size -= 8\n        return result\n  ❶ scalar_types = `<flatten out list of member types>`\n  ❷ if size > 8:\n        if first and last type in scalar_types are Double:\n            return [SSE, SSE]\n        if first type in scalar_types is Double:\n            return [SSE, INTEGER]\n        if last type in scalar_types is Double:\n            return [INTEGER, SSE]\n        return [INTEGER, INTEGER]\n    else if first type in scalar_types is Double:\n      ❸ return [SSE]\n    else:\n      ❹ return [INTEGER]\n```", "```\nclassify_parameters(values, **return_in_memory**):\n    int_reg_args = []\n    double_reg_args = []\n    stack_args = []\n\n    **if return_in_memory:**\n        **int_regs_available = 5**\n    **else:**\n        **int_regs_available = 6**\n\n    for v in values:\n        operand = convert_val(v)\n        t = assembly_type_of(v)\n        typed_operand = (t, operand)\n\n        if t == Double:\n `--snip--`\n        else **if t is scalar**:\n            if length(int_reg_args) < **int_regs_available**:\n                int_reg_args.append(typed_operand)\n            else:\n                stack_args.append(typed_operand)\n\n        **else:**\n            **// v is a structure**\n            **// partition it into eightbytes by class**\n            **classes = classify_structure(**`**<struct definition for v>**`**)** ❶\n            **use_stack = True**\n            **struct_size =****t.size**\n            **if classes[0] != MEMORY:** ❷\n\n                **// make tentative assignments to registers**\n                **tentative_ints = []**\n                **tentative_doubles = []**\n                **offset = 0**\n                **for class in classes:**\n                    **operand = PseudoMem(**`**<name of v>**`**, offset)** ❸\n                    **if class == SSE:**\n                        **tentative_doubles.append(operand)**\n                    **else:**\n                        **eightbyte_type = get_eightbyte_type(offset, struct_size)** ❹\n                        **tentative_ints.append((eightbyte_type, operand))**\n                    **offset += 8**\n\n                **// finalize them if there are enough free registers**\n                **if ((length(tentative_doubles) + length(double_reg_args)) <= 8 and**\n                    **(length(tentative_ints) + length(int_reg_args)) <= int_regs_available):** ❺\n                    **double_reg_args.append_all(tentative_doubles)**\n                    **int_reg_args.append_all(tentative_ints)**\n                    **use_stack = False**\n\n            **if use_stack:**\n                **// add each eightbyte of the structure to stack_args**\n                **offset = 0**\n                **for class in classes:**\n                    **operand = PseudoMem(**`**<name of v>**`**, offset)**\n                    **eightbyte_type = get_eightbyte_type(offset, struct_size)**\n                    **stack_args.append((eightbyte_type, operand))** ❻\n                    **offset += 8**\n\n    return (int_reg_args, double_reg_args, stack_args)\n```", "```\nget_eightbyte_type(offset, struct_size):\n  ❶ bytes_from_end = struct_size - offset\n    if bytes_from_end >= 8:\n        return Quadword\n    if bytes_from_end == 4:\n        return Longword\n    if bytes_from_end == 1:\n        return Byte\n  ❷ return ByteArray(bytes_from_end, 8)\n```", "```\nclassify_return_value(retval):\n\n    t = assembly_type_of(retval)\n\n    if t == Double:\n        operand = convert_val(retval)\n      ❶ return ([], [operand], False)\n    else if t is scalar:\n        typed_operand = (t, convert_val(retval))\n      ❷ return ([typed_operand], [], False)\n    else:\n        classes = classify_structure(`<struct definition for retval>`)\n        struct_size = t.size\n        if classes[0] == MEMORY:\n            // the whole structure is returned in memory,\n            // not in registers\n          ❸ return ([], [], True)\n        else:\n            // the structure is returned in registers;\n            // partition it into eightbytes by class\n            int_retvals = []\n            double_retvals = []\n            offset = 0\n for class in classes:\n                operand = PseudoMem(`<name of retval>`, offset)\n              ❹ match class with\n                | SSE ->\n                    double_retvals.append(operand)\n                | INTEGER ->\n                    eightbyte_type = get_eightbyte_type(offset, struct_size)\n                    int_retvals.append((eightbyte_type, operand))\n                | MEMORY -> fail(\"Internal error\")\n                offset += 8\n            return (int_retvals, double_retvals, False)\n```", "```\nconvert_function_call(FunCall(fun_name, args, dst)):\n    int_registers = [DI, SI, DX, CX, R8, R9]\n    double_registers = [XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7]\n\n    **return_in_memory = False**\n    **int_dests = []**\n    **double_dests = []**\n    **reg_index = 0**\n\n    **// classify return value**\n    **if dst is not null:**\n        **int_dests, double_dests, return_in_memory = classify_return_value(dst)** ❶\n\n **if return_in_memory:**\n        **dst_operand = convert_val(dst)**\n        **emit(Lea(dst_operand, Reg(DI)))** ❷\n        **reg_index = 1**\n\n    // classify arguments\n    int_args, double_args, stack_args = classify_parameters(args, **return_in_memory**)\n\n    `--snip--`\n\n    // pass args in registers\n    for (assembly_type, assembly_arg) in int_args:\n        r = int_registers[reg_index]\n        **if assembly_type is ByteArray(size, alignment):**\n            **copy_bytes_to_reg(assembly_arg, r, size)** ❸\n        **else:**\n            emit(Mov(assembly_type, assembly_arg, Reg(r)))\n        reg_index += 1\n\n    `--snip--`\n\n    // pass args on stack\n    for (assembly_type, assembly_arg) in reverse(stack_args):\n        **if assembly_type is ByteArray(size, alignment):**\n            **emit(Binary(Sub, Quadword, Imm(8), Reg(SP)))** ❹\n            **copy_bytes(from=assembly_arg, to=Memory(SP, 0), count=size)**\n        **else** if (assembly_arg is a Reg or Imm operand\n                 or assembly_type == Quadword\n                 or assembly_type == Double):\n            emit(Push(assembly_arg))\n        else:\n            emit(Mov(assembly_type, assembly_arg, Reg(AX)))\n            emit(Push(Reg(AX)))\n\n    `--snip--`\n\n    // retrieve return value\n    **if (dst is not null) and (not return_in_memory):**\n        **int_return_registers = [AX, DX]**\n        **double_return_registers = [XMM0, XMM1]**\n\n        **// retrieve values returned in general-purpose registers**\n        **reg_index = 0**\n        **for (t, op) in int_dests:**\n           **r = int_return_registers[reg_index]**\n           **if t is ByteArray(size, alignment):**\n               **copy_bytes_from_reg(r, op, size)** ❺\n           **else:**\n               **emit(Mov(t, Reg(r), op))** ❻\n           **reg_index += 1**\n\n        **// retrieve values returned in XMM registers**\n        **reg_index = 0**\n **for op in double_dests:**\n            **r = double_return_registers[reg_index]**\n            **emit(Mov(Double, Reg(r), op))** ❼\n            **reg_index += 1**\n```", "```\nsubq    $8, %rsp\nmovb    x(%rip), (%rsp)\nmovb    x+1(%rip), 1(%rsp)\nmovb    x+2(%rip), 2(%rsp)\n```", "```\nmovb    x+2(%rip), %dil\nshlq    $8, %rdi\nmovb    x+1(%rip), %dil\nshlq    $8, %rdi\nmovb    x(%rip), %dil\n```", "```\nmovl    %edi, -4(%rbp)\n```", "```\ncopy_bytes_to_reg(src_op, dst_reg, byte_count):\n    offset = byte_count - 1\n    while offset >= 0:\n        src_byte = add_offset(src_op, offset)\n        emit(Mov(Byte, src_byte, Reg(dst_reg)))\n        if offset > 0:\n            emit(Binary(Shl, Quadword, Imm(8), Reg(dst_reg)))\n        offset -= 1\n```", "```\nmovb    %dil, -4(%rbp)\nshrq    $8, %rdi\nmovb    %dil, -3(%rbp)\nshrq    $8, %rdi\nmovb    %dil, -2(%rbp)\n```", "```\ncopy_bytes_from_reg(src_reg, dst_op, byte_count):\n    offset = 0\n    while offset < byte_count:\n        dst_byte = add_offset(dst_op, offset)\n        emit(Mov(Byte, Reg(src_reg), dst_byte))\n        if offset < byte_count - 1:\n            emit(Binary(ShrTwoOp, Quadword, Imm(8), Reg(src_reg)))\n        offset += 1\n```", "```\nset_up_parameters(parameters, **return_in_memory**):\n\n    // classify them\n    int_reg_params, double_reg_params, stack_params = classify_parameters(parameters,\n                                                                          **return_in_memory**)\n\n    // copy parameters from general-purpose registers\n    int_regs = [DI, SI, DX, CX, R8, R9]\n    reg_index = 0\n\n    **if return_in_memory:**\n        **emit(Mov(Quadword, Reg(DI), Memory(BP, -8)))**\n        **reg_index = 1**\n\n    for (param_type, param) in int_reg_params:\n        r = int_regs[reg_index]\n        **if param_type is ByteArray(size, alignment):**\n            **copy_bytes_from_reg(r, param, size)**\n        **else:**\n            emit(Mov(param_type, Reg(r), param))\n        reg_index += 1\n\n    `--snip--`\n\n    // copy parameters from the stack\n    offset = 16\n    for (param_type, param) in stack_params:\n        **if param_type is ByteArray(size, alignment):**\n            **copy_bytes(from=Memory(BP, offset), to=param, count=size)**\n        **else:**\n            emit(Mov(param_type, Memory(BP, offset), param))\n        offset += 8\n```", "```\nconvert_return_instruction(Return(retval)):\n    if retval is null:\n        emit(Ret)\n        return\n\n    int_retvals, double_retvals, return_in_memory = classify_return_value(retval)\n\n    if return_in_memory:\n        emit(Mov(Quadword, Memory(BP, -8), Reg(AX))) ❶\n        return_storage = Memory(AX, 0)\n        ret_operand = convert_val(retval)\n        t = assembly_type_of(retval)\n        copy_bytes(from=ret_operand, to=return_storage, count=t.size) ❷\n    else:\n        int_return_registers = [AX, DX]\n        double_return_registers = [XMM0, XMM1]\n\n        reg_index = 0\n        for (t, op) in int_retvals: ❸\n            r = int_return_registers[reg_index]\n            if t is ByteArray(size, alignment):\n                copy_bytes_to_reg(op, r, size)\n            else:\n                emit(Mov(t, op, Reg(r)))\n            reg_index += 1\n\n        reg_index = 0\n        for op in double_retvals: ❹\n            r = double_return_registers[reg_index]\n            emit(Mov(Double, op, Reg(r)))\n            reg_index += 1\n\n    emit(Ret)\n```", "```\nasm_symtab_entry = ObjEntry(assembly_type, bool is_static, bool is_constant)\n                 | FunEntry(bool defined, **bool return_on_stack**)\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name,\n         global,\n         params,\n         instructions)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name, global,</samp>\n  <samp class=\"SANS_Futura_Std_Book_11\">[ </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy Reg(DI) into first int param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp>\n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">   <copy Reg(SI) into second int param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n   </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy next four int</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">params/eightbytes</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">from registers></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n    Mov(Double,\n        Reg(XMM0),\n       </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><first double</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">param/eightbyte</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">),\n    Mov(Double,\n        Reg(XMM1),</samp>\n  <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">      </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><second double</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">param/eightbyte</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">),\n   </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy next six double</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">params/eightbytes</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">from registers></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">   <copy Memory(BP, 16) into first stack param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp>\n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">   <copy Memory(BP, 24) into second stack param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp>\n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">  </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy remaining</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">params/eightbytes</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">from stack></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">] +\n instructions)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name, global,\n [</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(Quadword,\n       Reg(DI),\n       Memory(BP, -8)),</samp>\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy Reg(SI) into first int param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n  </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy Reg(DX) into second int param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n  </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy next</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">three</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">int</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">params/eightbytes</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">from registers></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n   Mov(Double,\n       Reg(XMM0),\n      </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><first</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">double</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">),\n   Mov(Double,\n       Reg(XMM1),\n      </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><second double</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">param/eightbyte</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">),\n  </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy next six double</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">params/eightbytes</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">from registers></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n  </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy Memory(BP, 16) into first stack param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n  </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy Memory(BP, 24) into second stack param/eightbyte></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,\n </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy remaining</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">params/eightbytes</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">from stack></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">] +\n instructions)</samp></samp></samp></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(Quadword, Memory(BP, -8), Reg(AX))\nMov(Quadword,</samp>\n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first eightbyte of return value></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    Memory(AX, 0))\nMov(Quadword,\n   </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><second eightbyte of return value></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    Memory(AX, 8))</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy rest of return value></samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Ret</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><move integer parts of return value into RAX, RDX>\n<move double parts of return value into XMM0, XMM1></samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Ret</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Ret</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Unary(Negate, src, dst)</samp>\n<samp class=\"SANS_Futura_Std_Book_11\">(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">double</samp> <samp class=\"SANS_Futura_Std_Book_11\">negation)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(Double, src, dst)\nBinary(Xor, Double, Data(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><negative-zero></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, 0</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">), dst)</samp>\n<samp class=\"SANS_Futura_Std_Book_11\">And add a top-level constant:</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">StaticConstant(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><negative-zero></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, 16,\n               DoubleInit(-0.0))</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Copy(src, dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, src, dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src, 0),\n    PseudoMem(dst, 0))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><next chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">),\n    PseudoMem(dst,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">))</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy remaining chunks></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Load(ptr, dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, Memory(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, 0), dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    Memory(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, 0),\n    PseudoMem(dst, 0))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><next chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    Memory(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">),\n    PseudoMem(dst,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">))</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy remaining chunks></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Store(src, ptr)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, src, Memory(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, 0))</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src, 0),\n    Memory(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, 0))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><next chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">),\n    Memory(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">))</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy remaining chunks></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">CopyToOffset(src, dst,\n             offset)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">src</samp> <samp class=\"SANS_Futura_Std_Book_11\">is\nscalar</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><src type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, src, PseudoMem(dst, offset))</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src, 0),</samp>\n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">PseudoMem(dst, offset))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><next chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">),\n    PseudoMem(dst, offset +</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">))</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy remaining chunks></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">CopyFromOffset(src,\n               offset,\n               dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><dst type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, PseudoMem(src, offset), dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src, offset),\n    PseudoMem(dst, 0))\nMov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><next chunk type></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n    PseudoMem(src, offset +</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">),\n    PseudoMem(dst,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><first chunk size></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">))</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><copy remaining chunks></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">FunCall(fun_name,\n        args, dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Lea(dst, Reg(DI))</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><fix stack alignment></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><move arguments to general-purpose registers,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">starting with RSI</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">>\n<move arguments to XMM registers>\n<push arguments onto the stack></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Call(fun_name)</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><deallocate arguments/padding></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><fix stack alignment>\n<move arguments to general-purpose registers>\n<move arguments to XMM registers>\n<push arguments onto the stack></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Call(fun_name)</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><deallocate arguments/padding></samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><move integer parts of return value from RAX, RDX into dst>\n<move double parts of return value from XMM0, XMM1 into dst></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><fix stack alignment>\n<move arguments to general-purpose registers>\n<move arguments to XMM registers>\n<push arguments onto the stack></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Call(fun_name)</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><deallocate arguments/padding></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">DoubleToUInt(src, dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">unsigned\nchar</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Cvttsd2si(Longword, src, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">))\nMov(Byte, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">), dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">unsigned\nint</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Cvttsd2si(Quadword, src, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">))\nMov(Longword, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">), dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">unsigned\nlong</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Cmp(Double, Data(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><upper-bound></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, 0</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">), src)\nJmpCC(AE,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><label1></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)\nCvttsd2si(Quadword, src, dst)\nJmp(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><label2></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)\nLabel(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><label1></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)\nMov(Double, src, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><X></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">))\nBinary(Sub, Double, Data(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><upper-bound></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, 0</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">), Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><X></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">))\nCvttsd2si(Quadword, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><X></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">), dst)\nMov(Quadword, Imm(9223372036854775808), Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">))\nBinary(Add, Quadword, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><R></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">), dst)\nLabel(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><label2></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)</samp>\n<samp class=\"SANS_Futura_Std_Book_11\">And add a top-level constant:</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">StaticConstant(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><upper-bound></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, 8,\nDoubleInit(9223372036854775808.0))</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Constant(ConstDouble(double))</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Data(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><ident></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">, 0</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)</samp>\n<samp class=\"SANS_Futura_Std_Book_11\">And add a top-level constant:</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">StaticConstant(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><ident></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, 8,\n               DoubleInit(double))</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">ByteArray(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><size from type table></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,\n         </samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><alignment from type table></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">)</samp>\n```", "```\nPseudoMem(\"v\", 0)\n```", "```\nData(\"v\", 0)\n```", "```\nPseudoMem(\"v\", 10)\n```", "```\nData(\"v\", 10)\n```", "```\nx+4(%rip)\n```", "```\n$ **./test_compiler** `**/path/to/your_compiler**` **--chapter 18 --union**\n```"]