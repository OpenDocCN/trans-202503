- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**STRING DATA TYPES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串数据类型**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: After integers, character strings are probably the most commonly used data type
    in modern programs; after arrays, they’re the second most commonly used composite
    data type. A string is a sequence of objects. Most often, the term *string* describes
    a sequence of character values, but it’s also possible to have strings of integers,
    real values, Boolean values, and so on (for example, I’ve already discussed bit
    strings in this book and in *WGC1*). In this chapter, though, we’ll stick to character
    strings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数之后，字符字符串可能是现代程序中最常用的数据类型；仅次于数组，它们是第二常用的复合数据类型。字符串是对象的序列。通常，*字符串*这一术语描述的是字符值的序列，但也有可能存在由整数、实数、布尔值等组成的字符串（例如，我已经在本书和*WGC1*中讨论过位字符串）。不过在本章中，我们将专注于字符字符串。
- en: 'In general, a character string possesses two main attributes: a *length* and
    some *character data*. Character strings can also possess other attributes, such
    as the *maximum length* allowable for that particular variable or a *reference
    count* specifying how many different string variables refer to the same character
    string. We’ll look at these attributes and how programs can use them, as well
    as the various string formats and possible string operations. Specifically, this
    chapter discusses the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，字符字符串具有两个主要属性：*长度*和一些*字符数据*。字符字符串还可以具有其他属性，例如该特定变量的*最大长度*或*引用计数*，指示有多少不同的字符串变量引用相同的字符字符串。我们将研究这些属性及其程序如何使用它们，以及各种字符串格式和可能的字符串操作。具体而言，本章讨论以下主题：
- en: Character string formats including zero-terminated strings, length-prefixed
    strings, HLA strings, and 7-bit strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式，包括零终止字符串、长度前缀字符串、HLA字符串和7位字符串
- en: When to use (and when not to use) standard library string processing functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用（以及何时不使用）标准库字符串处理函数
- en: Static, pseudo-dynamic, and dynamic strings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态、伪动态和动态字符串
- en: Reference counting and strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用计数与字符串
- en: Unicode and UTF-8/UTF-16/UTF-32 character data in strings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串中的Unicode和UTF-8/UTF-16/UTF-32字符数据
- en: String manipulation consumes a fair amount of CPU time in today’s applications.
    Therefore, it’s important to understand how programming languages represent and
    operate on character strings if you want to write code that manipulates strings
    efficiently. This chapter provides the basic information you’ll need to do so.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作在当今的应用程序中消耗了相当多的CPU时间。因此，如果你想编写高效操作字符串的代码，理解编程语言如何表示和操作字符字符串是非常重要的。本章提供了你所需要的基本信息。
- en: '**10.1 Character String Formats**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.1 字符串格式**'
- en: Different languages use different data structures to represent strings. Some
    string formats use less memory, others allow faster processing, some are more
    convenient to use, some are easy for compiler writers to implement, and some provide
    additional functionality for the programmer and operating system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言使用不同的数据结构来表示字符串。一些字符串格式使用较少的内存，其他格式允许更快的处理，一些格式更方便使用，一些对编译器开发者来说更易于实现，而一些则为程序员和操作系统提供了额外的功能。
- en: 'Although their internal representations vary, all string formats have one thing
    in common: the character data. This is a sequence of 0 or more bytes (the term
    *sequence* implies that the order of the characters is important). How a program
    references this sequence of characters varies by format. In some string formats,
    the sequence of characters is kept in an array; in other string formats the program
    maintains a pointer to the sequence of characters elsewhere in memory.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的内部表示方式各不相同，但所有字符串格式有一个共同点：字符数据。这是一系列0个或多个字节（*序列*一词意味着字符的顺序是重要的）。程序如何引用这组字符的方式因格式而异。在某些字符串格式中，字符序列存储在数组中；而在其他字符串格式中，程序保持指向内存中其他位置字符序列的指针。
- en: All character string formats share the length attribute; however, they use several
    different ways to represent the length of a string. Some string formats use a
    special *sentinel character* to mark the end of the string. Other formats precede
    the character data with a numeric value that specifies the number of characters
    in the sequence. Still others encode the length as a numeric value in a variable
    that is not connected to the character sequence. Some character string formats
    use a special bit (set or cleared) to mark the end of a string. Finally, some
    string formats use a combination of these methods. How a particular string format
    determines the length of a string can have a big impact on the performance of
    the functions that manipulate those strings. It can also affect how much extra
    storage is needed to represent string data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Some string formats provide additional attributes, such as a maximum length
    and reference count values, that certain string functions can use to operate on
    string data more efficiently. These extra attributes are optional insofar as they
    aren’t strictly necessary to define a string value. They do, however, allow string
    manipulation functions to provide certain tests for correctness or to work more
    efficiently than they would otherwise.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: To help you better understand the reasoning behind the design of character strings,
    let’s look at some common string representations popularized by various languages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.1 Zero-Terminated Strings**'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Without question, *zero-terminated strings* (see [Figure 10-1](ch10.xhtml#ch10fig1))
    are probably the most common string representation in use today, because this
    is the native string format for C, C++, and several other languages. In addition,
    you’ll find zero-terminated strings used in programs written in languages that
    don’t have a specific native string format, such as assembly language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: Zero-terminated string format*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'A zero-terminated ASCII string, also called an *ASCIIz* string or a *zstring*,
    is a sequence containing zero or more 8-bit character codes and ending with a
    byte containing `0`—or, in the case of Unicode (UTF-16), a sequence containing
    zero or more 16-bit character codes and ending with a 16-bit word containing `0`.
    For UTF-32 strings, each item in the string is 32 bits (4 bytes) wide, ending
    with a 32-bit `0` value. For example, in C/C++, the ASCIIz string `"abc"` requires
    4 bytes: 1 byte for each of the three characters `a`, `b`, and `c`, followed by
    a `0` byte.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero-terminated strings have a few advantages over other string formats:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Zero-terminated strings can represent strings of any practical length with only
    1 byte of overhead (2 bytes in UTF-16, 4 in UTF-32).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the popularity of the C/C++ programming languages, high-performance string
    processing libraries are available that work well with zero-terminated strings.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero-terminated strings are easy to implement. Indeed, except for dealing with
    string literal constants, the C/C++ programming languages don’t provide native
    string support. As far as those languages are concerned, strings are just arrays
    of characters. That’s probably why C’s designers chose this format in the first
    place—so they wouldn’t have to clutter up the language with string operators.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零终止字符串易于实现。实际上，除了处理字符串字面常量外，C/C++ 编程语言并不提供本地的字符串支持。就这些语言而言，字符串只是字符数组。这也可能是 C
    的设计者最初选择这种格式的原因——这样他们就不需要用字符串操作符来混乱语言的设计。
- en: You can easily represent zero-terminated strings in any language that provides
    the ability to create an array of characters.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在任何提供创建字符数组能力的语言中轻松表示零终止字符串。
- en: 'However, zero-terminated strings also have disadvantages that mean they are
    not always the best choice for representing character string data:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，零终止字符串也有一些缺点，这意味着它们并不总是表示字符字符串数据的最佳选择：
- en: String functions often aren’t very efficient when operating on zero-terminated
    strings. Many string operations need to know the length of the string before working
    on the string data. The only reasonable way to compute the length of a zero-terminated
    string is to scan the string from the beginning to the end. The longer your strings
    are, the slower this function runs, so the zero-terminated string format isn’t
    the best choice if you need to process long strings.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作零终止字符串时，字符串函数通常效率较低。许多字符串操作需要在处理字符串数据之前知道字符串的长度。计算零终止字符串的长度的唯一合理方法是从头到尾扫描字符串。你的字符串越长，这个函数运行得就越慢，因此，如果你需要处理长字符串，零终止字符串格式不是最佳选择。
- en: Although it’s a minor problem, you cannot easily represent the character code
    `0` (such as the NUL character in ASCII and Unicode) with the zero-terminated
    string format.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这是一个小问题，但你无法轻松地使用零终止字符串格式表示字符代码`0`（例如 ASCII 和 Unicode 中的 NUL 字符）。
- en: Zero-terminated strings don’t contain any information that tells you how long
    the string can grow beyond the terminating `0` byte. Therefore, some string functions,
    like concatenation, can only extend the length of an existing string variable
    and check for overflow if the caller explicitly passes the maximum length.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零终止字符串不包含任何信息，无法告诉你字符串可以扩展到终止 `0` 字节之后的长度。因此，一些字符串函数（如拼接）只能扩展现有字符串变量的长度，并且只有在调用者显式传递最大长度时才会检查溢出。
- en: 'As noted, one nice feature of zero-terminated strings is that you can easily
    implement them using pointers and arrays of characters. Consider the following
    C/C++ statement:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，零终止字符串的一个优点是你可以通过使用指针和字符数组轻松实现它们。考虑以下 C/C++ 语句：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the code the Borland C++ v5.0 compiler generates for this statement:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Borland C++ v5.0 编译器为此语句生成的代码：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Borland C++ compiler simply emits the literal string `"Hello World"` to
    the global data segment in memory and then loads the `someCharPtrVar` variable
    with the address of the first character of this string literal in the data segment.
    From that point forward, the program can refer to the string data indirectly via
    this pointer. This is a very convenient scheme from the compiler writer’s point
    of view.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Borland C++ 编译器将字面字符串 `"Hello World"` 直接输出到内存的全局数据段，然后将 `someCharPtrVar` 变量加载为该字符串字面量在数据段中的第一个字符的地址。从那时起，程序可以通过这个指针间接引用字符串数据。从编译器编写者的角度来看，这是一种非常方便的方案。
- en: 'When using zero-terminated strings in a language like C, C++, Python, or any
    of a dozen other languages that have adopted C’s string format, you can improve
    the performance of your string-handling code sequences by keeping a few points
    in mind:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用像 C、C++、Python 或其他采用 C 字符串格式的语言时，你可以通过记住以下几点来提高字符串处理代码序列的性能：
- en: Try to use the language’s runtime library functions rather than attempting to
    code comparable functions yourself. Most compiler vendors provide highly optimized
    versions of their string functions that will probably run many times faster than
    code you would write yourself.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用语言的运行时库函数，而不是尝试自己编写类似的函数。大多数编译器供应商提供了高度优化的字符串函数版本，这些函数的运行速度可能比你自己编写的代码快得多。
- en: Once you’ve computed the length of a string by scanning the entire string, save
    that length for future use (rather than recomputing it every time you need it).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦通过扫描整个字符串计算了字符串的长度，应该将该长度保存以供将来使用（而不是每次需要时重新计算它）。
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations (after length computation) in applications using
    zero-terminated strings.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将字符串数据从一个字符串变量复制到另一个。这样做是使用零终止字符串的应用程序中最昂贵的操作之一（仅次于长度计算）。
- en: The following subsections discuss each point in turn.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将依次讨论每个要点。
- en: '**10.1.1.1 When to Use C Standard Library String Functions**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.1 何时使用 C 标准库字符串函数**'
- en: 'Some programmers are skeptical that someone else could write faster or higher-quality
    code. But when it comes to standard library functions, you should avoid the temptation
    to replace them with code of your own choosing. Unless the library code you’re
    considering is especially bad, chances are you won’t come close to duplicating
    its efficiency. This is especially true for string functions that handle zero-terminated
    strings in languages like C and C++. There are three main reasons why standard
    libraries generally perform better than code you write yourself: experience, maturity,
    and inline substitution.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员怀疑别人能写出更快或更高质量的代码。但当涉及到标准库函数时，你应该避免用自己选择的代码替代它们。除非你考虑的库代码特别差，否则你很难接近它的效率。这一点在处理像
    C 和 C++ 中的零终止字符串的字符串函数时尤其如此。标准库通常比你自己编写的代码表现得更好，有三个主要原因：经验、成熟度和内联替换。
- en: 'The typical programmer who writes compiler runtime libraries has a lot of experience
    with string-handling functions. Although in the past new compilers were often
    accompanied by notoriously inefficient libraries, over time compiler programmers
    have gained considerable experience writing those library routines and have figured
    out how to deliver well-written string-handling functions. Unless you’ve spent
    considerable time writing those same types of routines, it’s highly unlikely that
    your code will perform as well as theirs. Many compiler vendors purchase their
    standard library code from a third party that specializes in writing library code,
    so now, even if the compiler you’re using is fairly new, it may have a good library.
    Few commercial compilers today contain horribly inefficient library code. For
    the most part, only research or “hobby” compilers contain library code so bad
    that you can easily write something better. Consider a simple example—the C standard
    library `strlen()` (string length) function. Here’s a typical implementation of
    `strlen()` that an inexperienced programmer might write:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 编写编译器运行时库的典型程序员在字符串处理函数方面有着丰富的经验。尽管过去新编译器往往伴随着效率低下的库，但随着时间的推移，编译器程序员积累了相当多的经验，编写出了高效的字符串处理函数。除非你花费了大量时间编写相同类型的例程，否则你的代码不太可能与他们的代码表现得一样好。许多编译器供应商会从专门编写库代码的第三方购买标准库代码，所以即使你使用的编译器相对较新，它也可能有一个不错的库。如今，几乎没有商业编译器包含效率极低的库代码。大多数情况下，只有研究型或“爱好者”编译器才会包含那么糟糕的库代码，以至于你可以轻松编写出更好的代码。考虑一个简单的例子——C
    标准库中的 `strlen()`（字符串长度）函数。以下是一个没有经验的程序员可能会编写的典型 `strlen()` 实现：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The 80x86 machine code that Microsoft’s Visual C++ compiler generates for `myStrlen()`
    is probably what any assembly programmer would expect:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Visual C++ 编译器为 `myStrlen()` 生成的 80x86 机器代码可能是任何汇编程序员所预期的样子：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'No doubt, an experienced assembly language programmer could rearrange these
    particular instructions to speed them up a bit. Indeed, even an average 80x86
    assembly language programmer could point out that the 80x86 `scasb` instruction
    does most of the work in this code sequence. Although this code is fairly short
    and easy to understand, by no means will it run as fast as possible. An expert
    assembly language programmer might note that this loop repeats one iteration for
    each character in the string and accesses the characters in memory 1 byte at a
    time, and might improve upon it by unrolling^([1](footnotes.xhtml#ch10fn1)) the
    loop and processing more than one character per loop iteration. For example, consider
    the following HLA standard library `zstr.len()` function, which computes the length
    of a zero-terminated string by processing four characters at a time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，一位经验丰富的汇编语言程序员可以重新排列这些特定的指令，稍微加速它。事实上，即使是一个普通的80x86汇编语言程序员，也能指出80x86的`scasb`指令在这段代码序列中完成了大部分工作。尽管这段代码相当简短且易于理解，但它并不会以最快的速度运行。一位专家级的汇编语言程序员可能会注意到，这个循环每次迭代处理字符串中的一个字符，并且一次访问一个字节的字符，它可能会通过展开^([1](footnotes.xhtml#ch10fn1))循环并在每次迭代中处理多个字符来改进它。例如，考虑以下HLA标准库的`zstr.len()`函数，它通过一次处理四个字符来计算零终止字符串的长度：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though this function is much longer and more complex than the simple example
    given earlier, it runs faster because it processes four characters per loop iteration
    rather than one, which means it executes far fewer loop iterations. Also, this
    code reduces loop overhead by unrolling eight copies of the loop (that is, expanding
    eight copies of the loop body inline), which saves the execution of 87 percent
    of the loop control instructions. As a result, this code runs anywhere from two
    to six times faster than the code given earlier; the exact savings depend upon
    the length of the string.^([2](footnotes.xhtml#ch10fn2))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个函数比之前给出的简单示例更长且更复杂，但它运行得更快，因为它每次循环迭代处理四个字符，而不是一个，这意味着它执行的循环迭代次数大大减少。此外，这段代码通过展开八个循环副本（即将循环体的八个副本内联展开）来减少循环开销，这节省了87%的循环控制指令的执行。因此，这段代码的运行速度比之前的代码快两到六倍；具体的节省取决于字符串的长度。^([2](footnotes.xhtml#ch10fn2))
- en: The second reason to avoid writing your own library functions is the maturity
    of the code. Most popular optimizing compilers available today have been around
    for a while. During this time, the compiler vendors have used their routines,
    determined where the bottlenecks lie, and optimized their code. When you write
    your own version of a standard library string-handling function, you probably
    won’t have comparable time to dedicate to optimizing it—you’ve got your entire
    application to worry about. Because of project time constraints, you’ll likely
    never go back and rewrite that string function to improve its performance. Even
    if there’s a slight performance advantage to your routine now, the compiler vendor
    may very well update their library in the future, and you could take advantage
    of those improvements by simply relinking the updated code with your project.
    However, if you write the library code yourself, it will never improve unless
    you explicitly update it yourself. Most people are too busy working on new projects
    to go back and clean up their old code, so the likelihood of improving self-written
    string functions in the future is quite low.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 避免自己编写库函数的第二个原因是代码的成熟度。现今大多数流行的优化编译器已经存在了一段时间。在此期间，编译器厂商已经使用了他们的例程，找出了瓶颈所在，并对他们的代码进行了优化。当你编写自己的标准库字符串处理函数时，你可能不会有足够的时间来进行优化——你还得处理整个应用程序。由于项目的时间限制，你很可能永远不会回过头来重写那个字符串函数以提高性能。即使你现在的程序有些微的性能优势，编译器厂商将来可能会更新他们的库，而你只需将更新后的代码与项目重新链接，就能利用这些改进。然而，如果你自己编写库代码，除非你明确更新它，否则它永远不会改进。大多数人都忙于处理新项目，没有时间回去清理旧代码，所以未来改进自己编写的字符串函数的可能性非常低。
- en: 'The third reason for using standard library string functions in a language
    like C or C++ is the most important: inline expansion. Many compilers recognize
    certain standard library function names and expand them inline to efficient machine
    code in place of the function call. This inline expansion can be many times faster
    than an explicit function call, especially if the function call contains several
    parameters. As a simple example, consider the following (almost trivial) C program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C 或 C++ 这样的语言中使用标准库字符串函数的第三个原因是最重要的：内联扩展。许多编译器能够识别某些标准库函数名，并将它们内联展开为高效的机器代码，取代函数调用。这个内联扩展通常比显式的函数调用快得多，尤其是在函数调用包含多个参数的情况下。举个简单的例子，考虑以下（几乎微不足道的）C
    程序：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The corresponding 64-bit x86-64 assembly code that Visual C++ produces is quite
    interesting:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 生成的相应的 64 位 x86-64 汇编代码相当有趣：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler recognizes what’s going on and substitutes four inline instructions
    that copy the 12 bytes of the string from the literal constant in memory to the
    `localStr` variable (specifically, it copies 8 bytes using the XMM0 register and
    4 bytes using the EAX register; note that this code uses RCX to pass the address
    of `localStr` to the `printf()` function). The overhead of a call and return to
    an actual `strcpy()` function will be more expensive than this (and that’s without
    considering the work needed to copy the string data). This example demonstrates
    quite well why you should usually call standard library functions rather than
    writing your own “optimized” functions to do the same job.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器能够识别正在发生的事情，并替换为四条内联指令，将字符串的 12 个字节从内存中的字面常量复制到`localStr`变量中（具体来说，它使用 XMM0
    寄存器复制 8 个字节，使用 EAX 寄存器复制 4 个字节；注意，这段代码使用 RCX 将`localStr`的地址传递给`printf()`函数）。调用和返回一个实际的`strcpy()`函数的开销将比这个更昂贵（更不用说复制字符串数据所需的工作）。这个例子很好地演示了为什么你通常应该调用标准库函数，而不是编写你自己的“优化”函数来完成相同的工作。
- en: '**10.1.1.2 When Not to Use Standard Library Functions**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.2 何时不使用标准库函数**'
- en: Although, as you’ve seen, it’s usually better to call a standard library routine
    rather than writing your own version, there are some special situations when you
    should *not* rely on one or more library functions in the standard library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如你所见，通常调用标准库例程要比编写你自己的版本更好，但在某些特殊情况下，你**不应该**依赖标准库中的一个或多个库函数。
- en: 'Library functions work great when they perform exactly the function you need—no
    more and no less. One area where programmers get into trouble is when they misuse
    a library function and call it to do something that it wasn’t really intended
    to do, or they need only part of the functionality it provides. For example, consider
    the C standard library `strcspn()` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当库函数完全执行你需要的功能时，它们非常有效——既不多也不少。程序员容易出问题的一个地方是，他们错误地使用库函数，调用它来做一些它并不真正打算做的事，或者他们只需要它提供功能的一部分。例如，考虑
    C 标准库中的`strcspn()`函数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function returns the number of characters in the source string up to the
    first character it finds that also appears in the cset string. It’s not at all
    uncommon to see calls to this function that look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回源字符串中字符数，直到它找到一个在`cset`字符串中也出现的第一个字符为止。看到像这样的函数调用并不罕见：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The intent here is to return the number of characters in SomeString before
    the first occurrence of an `a` character in that string. That is, it attempts
    to do something like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是返回 SomeString 中第一次出现字符`a`之前的字符数。也就是说，它尝试做类似以下的事情：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Unfortunately, the call to the `strcspn()` function is probably a lot slower
    than this simple `while` loop implementation. That’s because `strcspn()` actually
    does a lot more work than search for a single character within a string. It looks
    for any character from a set of characters within the source string. The generic
    implementation of this function might be something like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，调用`strcspn()`函数可能比这个简单的`while`循环实现要慢得多。这是因为`strcspn()`实际上做了比仅仅在字符串中查找单个字符更多的工作。它会在源字符串中查找来自一组字符的任何字符。这个函数的通用实现可能像这样：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With a little analysis (and noting that we have a pair of nested loops here),
    it’s clear that this code is slower than the code given earlier, even if you pass
    in a `cset` string containing a single character. This is a classic example of
    calling a function that is more general than you need, because it searches for
    any of several termination characters rather than the special case of a single
    terminating character. When a function does exactly what you want, using the standard
    library’s version of it is a good idea. However, when it does more than you need,
    using the standard library function can be expensive, and it’s better to write
    your own version.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微分析（并注意到我们有一对嵌套循环），很明显这段代码比前面的代码慢，即使你传入一个只包含单个字符的 `cset` 字符串。这是一个经典的例子，展示了调用一个比实际需要更通用的函数，因为它会搜索多个终止字符，而不是单一终止字符的特殊情况。当一个函数完全符合你的需求时，使用标准库的版本是一个好主意。然而，当它做的事情超出你的需求时，使用标准库函数可能会非常昂贵，这时自己写一个版本会更好。
- en: '**10.1.1.3 Why to Avoid Length Recomputing Data**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.3 为什么要避免重新计算字符串长度**'
- en: 'The last example in the previous section demonstrates a common C programming
    mistake. Consider the coded fragment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的最后一个例子演示了一个常见的 C 编程错误。考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On each iteration of this loop, the code tests the loop index to see if it
    is less than the length of the `cset` string. But because the loop body does not
    modify the `cset` string (and because, presumably, this is not a multithreaded
    application with another thread modifying the `cset` string), there’s really no
    need to recompute the string length on each iteration of this loop. Look at the
    code that the Microsoft Visual C++ 32-bit compiler emits for this code fragment:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，代码都会测试循环索引，看它是否小于 `cset` 字符串的长度。但因为循环体没有修改 `cset` 字符串（并且假设这不是一个多线程应用程序，另一个线程没有修改
    `cset` 字符串），实际上没有必要在每次循环迭代中重新计算字符串长度。看一下微软 Visual C++ 32 位编译器为这段代码生成的机器代码：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Again, the machine code recalculates the string’s length on every iteration
    of the innermost `for` loop, but because the `cset` string’s length never changes,
    this is totally unnecessary. We can easily rectify this problem by rewriting the
    code fragment this way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，机器代码在每次内层 `for` 循环的迭代中重新计算字符串的长度，但由于 `cset` 字符串的长度始终不变，这完全是不必要的。我们可以通过将代码片段重写成这样，轻松地解决这个问题：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On the plus side, recent versions of Microsoft’s VC++ compiler will recognize
    this situation if you have optimizations turned on. As VC++ determines that the
    string length is a loop-invariant calculation (that is, its value does not change
    from one loop iteration to the next), VC++ will move the call to `strlen()` out
    of the loop. Unfortunately, VC++ can’t catch this in every situation. For example,
    if you call some function that VC++ doesn’t know about and you pass it the address
    of `localStr` as a (non-`const`) parameter, VC++ will have to assume that the
    string’s length could change (even if it doesn’t) and it won’t be able to move
    the `strlen()` call out of the loop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你启用了优化，微软 VC++ 编译器的最新版本会识别这种情况。因为 VC++ 确定字符串长度是一个循环不变的计算（即它的值在每次循环迭代中都不会改变），VC++
    会把对 `strlen()` 的调用移出循环。不幸的是，VC++ 并不能在所有情况下都捕捉到这一点。例如，如果你调用一个 VC++ 不知道的函数，并将 `localStr`
    的地址作为一个（非 `const`）参数传递给它，VC++ 将不得不假设字符串的长度可能会改变（即使实际上没有改变），因此它无法将 `strlen()` 的调用移出循环。
- en: 'A fair number of string operations require the string’s length before they
    can execute. Consider the `strdup()` function commonly found in many C libraries.^([3](footnotes.xhtml#ch10fn3))
    The following code is a common implementation of this function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很多字符串操作在执行之前需要知道字符串的长度。考虑 `strdup()` 函数，它在许多 C 库中常见。^([3](footnotes.xhtml#ch10fn3))
    以下代码是这个函数的常见实现：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Fundamentally, nothing is wrong with this implementation of `strdup()`. If
    you know absolutely nothing about the string object you’re passing as a parameter,
    then you must compute the string’s length so you know how much memory to allocate
    for a copy of that string. Consider, however, the following code sequence that
    calls `strdup()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，这个 `strdup()` 的实现没有错。如果你对传递的字符串对象一无所知，那么你必须计算字符串的长度，以便知道为该字符串的副本分配多少内存。然而，考虑以下调用
    `strdup()` 的代码序列：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The problem here is that you wind up calling `strlen()` twice: once for the
    explicit call to `strlen()` in this code fragment, and once for the call buried
    in the `strdup()` function. Worse, it isn’t obvious that you’re calling `strlen()`
    twice, so it’s not even clear that you’re wasting CPU cycles in this code. This
    is another example of calling a function that is more general than you need, causing
    the program to recompute the string’s length (an inefficient process). One solution
    is to provide a less general version of `strdup()`, say `strduplen()`, that lets
    you pass it the length of the string you’ve already computed. You could implement
    `strduplen()` as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是你会调用`strlen()`两次：一次是显式调用`strlen()`，另一次是在`strdup()`函数内部调用。更糟糕的是，这并不明显，因此你甚至无法察觉到你在这段代码中浪费了CPU周期。这是另一个例子，说明调用了一个比你实际需要的更通用的函数，导致程序重新计算字符串的长度（这是一种低效的过程）。一种解决方案是提供一个更不通用的版本，比如`strduplen()`，它允许你传递已经计算过的字符串长度。你可以按如下方式实现`strduplen()`：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the use of `memcpy()` rather than `strcpy()` (or, better yet, `strncpy()`).
    Again, we already know the length of the string, so there’s no need to execute
    any code looking for the `0` terminating byte (as both `strcpy()` and `strncpy()`
    will do). Of course, this function implementation assumes that the caller passes
    the correct length, but that’s a standard C assumption for most string and array
    operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`memcpy()`而不是`strcpy()`（或者更好的是`strncpy()`）。同样，我们已经知道字符串的长度，因此没有必要执行任何代码来查找终止字节`0`（这正是`strcpy()`和`strncpy()`所做的）。当然，这个函数实现假设调用者传递了正确的长度，但对于大多数字符串和数组操作来说，这是标准C语言的假设。
- en: '**10.1.1.4 Why to Avoid Copying Data**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.4 为什么要避免复制数据**'
- en: Copying strings, especially long strings, can be a time-consuming process on
    a computer. Most programs maintain string data in memory, and memory is much slower
    than the CPU (often by an order of magnitude or more). Although cache memory can
    help mitigate this problem, processing a lot of string data can eliminate other
    data from the cache and lead to thrashing problems if you don’t frequently reuse
    all the string data you move through the cache. It’s not always possible to avoid
    moving string data around, but many programs needlessly copy data, and that can
    hamper program performance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 复制字符串，尤其是长字符串，可能是一个耗时的过程。大多数程序在内存中维护字符串数据，而内存比CPU慢得多（通常慢一个数量级或更多）。尽管缓存内存可以帮助缓解这个问题，但处理大量字符串数据可能会从缓存中移除其他数据，并且如果你不经常重用所有通过缓存移动的字符串数据，就会导致缓存抖动问题。虽然并非总能避免在字符串数据之间移动，但许多程序不必要地复制数据，这会影响程序性能。
- en: A better solution is to pass around *pointers* to zero-terminated strings rather
    than copying those strings from string variable to string variable. Pointers to
    zero-terminated strings can fit in registers and don’t consume much memory when
    you use memory variables to hold them. Therefore, passing pointers has far less
    impact on cache and CPU performance than copying string data among string variables.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是传递指向零终止字符串的*指针*，而不是将这些字符串从一个字符串变量复制到另一个字符串变量。指向零终止字符串的指针可以存储在寄存器中，并且在使用内存变量来存储它们时不会占用太多内存。因此，传递指针对缓存和CPU性能的影响远远小于在字符串变量之间复制字符串数据。
- en: As you’ve seen in this section, zero-terminated string functions are generally
    less efficient than functions that manipulate other types of strings. Furthermore,
    programs that utilize zero-terminated strings tend to make mistakes, such as calling
    `strlen()` multiple times or abusing generic functions to achieve specific goals.
    Fortunately, designing and using a more efficient string format is easy enough
    in languages whose native string format is the zero-terminated string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中所看到的，零终止字符串函数通常比操作其他类型字符串的函数效率低。此外，使用零终止字符串的程序往往会出错，比如多次调用`strlen()`函数，或者滥用通用函数来实现特定的目标。幸运的是，在以零终止字符串为本地字符串格式的编程语言中，设计和使用更高效的字符串格式是相对简单的。
- en: '**10.1.2 Length-Prefixed Strings**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.1.2 长度前缀字符串**'
- en: 'A second common string format, *length-prefixed strings*, overcomes some of
    the problems with zero-terminated strings. Length-prefixed strings are common
    in languages like Pascal; they generally consist of a single byte that specifies
    the length of the string, followed by zero or more 8-bit character codes (see
    [Figure 10-2](ch10.xhtml#ch10fig2)). In a length-prefixed scheme, the string `"String"`
    would consist of 4 bytes: the length byte (`6`), followed by the characters `S`,
    `t`, `r`, `i`, `n`, and `g`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Length-prefixed string format*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Length-prefixed strings solve two of the problems associated with zeroterminated
    strings:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: NUL characters can be represented in length-prefixed strings.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String operations are more efficient.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another advantage to length-prefixed strings is that the length is usually located
    at position `0` in the string (if we view the string as an array of characters),
    so the first character of the string begins at index `1` in the array representation
    of the string. For many string functions, having a `1`-based index into the character
    data is much more convenient than a `0`-based index (which zero-terminated strings
    use).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Length-prefixed strings do suffer from their own drawbacks, the principal one
    being that they’re limited to a maximum of 255 characters in length (assuming
    a 1-byte length prefix). You can remove this limitation by using a 2- or 4-byte
    length value, but doing so increases the amount of overhead data from 1 to 2 or
    4 bytes. It also changes the starting index of the string from 1 to either 2 or
    4, eliminating the `1`-based index feature. While there are ways to overcome this
    problem, they entail even more overhead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Many string functions are much more efficient with length-prefixed strings.
    Obviously, computing the length of a string is a trivial operation—it’s just a
    memory access—but other string functions that ultimately need the string’s length
    (such as concatenation and assignment) are usually more efficient than similar
    functions for zero-terminated strings. Furthermore, you don’t have to worry about
    recomputing the string’s length every time you call a string function that is
    built into the language’s standard library.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Despite these advantages, don’t get the impression that programs using length-prefixed
    string functions are always going to be efficient. You can still waste many CPU
    cycles by needlessly copying data. As with zero-terminated strings, if you use
    only a subset of a string function’s capabilities, you can waste lots of CPU cycles
    performing unnecessary tasks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'When using length-prefixed string functions, keep the following points in mind:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Try to use the language’s runtime library functions rather than attempting to
    code comparable functions yourself. Most compiler vendors provide highly optimized
    versions of their string functions that will probably run many times faster than
    code you would write yourself.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although computing the string length when using the length-prefixed string format
    is fairly trivial, many (Pascal) compilers actually emit a function call to extract
    the length value from the string’s data. The function call and return is far more
    expensive than retrieving the length value from a variable. So, once you compute
    the string’s length, consider saving that length in a local variable if you intend
    to use that value again. Of course, if a compiler is smart enough to replace a
    call to the length function with a simple data fetch from the string’s data structure,
    this “optimization” won’t buy you much.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations in programs using length-prefixed strings. Passing
    around pointers to strings has the same benefit as for zero-terminated strings.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.1.3 Seven-Bit Strings**'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 7-bit string format is an interesting option that works for 7-bit encodings
    like ASCII. It uses the (normally unused) higher-order bit of the characters in
    the string to indicate the end of the string. All but the last character code
    in the string has its HO bit clear, and the last character in the string has its
    HO bit set (see [Figure 10-3](ch10.xhtml#ch10fig3)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Seven-bit string format*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'This 7-bit string format has several disadvantages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: You have to scan the entire string in order to determine the length of the string.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot have zero-length strings in this format.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Few languages provide literal string constants for 7-bit strings.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’re limited to a maximum of 128 character codes, although this is fine when
    you are using plain ASCII.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, the big advantage of 7-bit strings is that they don’t require any
    overhead bytes to encode the length. Assembly language (using a macro to create
    literal string constants) is probably the best language to use when dealing with
    7-bit strings. Because the benefit of 7-bit strings is that they’re compact and
    assembly language programmers tend to worry most about compactness, this is a
    good match. Here’s an HLA macro that converts a literal string constant to a 7-bit
    string:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because few languages provide support for 7-bit strings, the first suggestion
    that applied to zero-terminated and length-prefixed strings doesn’t apply to 7-bit
    strings: you’ll probably have to write your own string-handling functions. Computing
    lengths and copying data are expensive operations even with 7-bit strings, however,
    so these two suggestions still apply:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve computed the length of a string by scanning the entire string, save
    that length for future use (rather than recomputing it every time you need it).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations in programs using 7-bit strings.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.1.4 HLA Strings**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As long as you’re not too concerned about a few extra bytes of overhead per
    string, you can create a string format that combines the advantages of both length-prefixed
    and zero-terminated strings without their respective disadvantages. The High-Level
    Assembly language has done this with its native string format.^([4](footnotes.xhtml#ch10fn4))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The biggest drawback to the HLA character string format is the amount of overhead
    required for each string (which can be significant, percentage-wise, if you’re
    in a memory-constrained environment and you process many small strings). HLA strings
    contain a length prefix and a zero-terminating byte, as well as some other information,
    totaling 9 bytes of overhead per string.^([5](footnotes.xhtml#ch10fn5))
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The HLA string format uses a 4-byte length prefix, allowing character strings
    to be just over 4 billion characters long (far more than any practical application
    will use). HLA also appends a `0` byte to the character string data, so HLA strings
    are compatible with string functions that reference (but do not change the length
    of) zero-terminated strings. The remaining 4 bytes of overhead in an HLA string
    contain the maximum legal length for that string (plus a `0` terminating byte).
    Having this extra field allows HLA string functions to check for string overflow,
    if necessary. In memory, HLA strings take the form shown in [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: HLA string format*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The 4 bytes immediately before the first character of the string contain the
    current string length. The 4 bytes preceding the current string length contain
    the maximum string length. Immediately following the character data is a `0` byte.
    Finally, HLA always ensures that the string data structure’s length is a multiple
    of 4 bytes for performance reasons, so there may be up to 3 additional bytes of
    padding at the end of the object in memory. (Note that the string shown in [Figure
    10-4](ch10.xhtml#ch10fig4) requires only 1 byte of padding to ensure that the
    data structure is a multiple of 4 bytes in length.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA string variables are actually pointers that contain the byte address of
    the first character in the string. To access the length fields, you load the value
    of the string pointer into a 32-bit register, then access the length field at
    offset –4 from the register and the maximum length field at offset –8 from the
    register. Here’s an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As noted earlier, the amount of memory reserved to hold an HLA string’s character
    data (including the `0` byte) is always a multiple of 4 bytes. Therefore, it’s
    always guaranteed that you can move data from one HLA string to another by copying
    double words rather than individual bytes. This allows string copy routines to
    run up to four times faster, because you execute one-fourth the number of loop
    iterations copying a string of double words as you would copying the string a
    byte at a time. For example, here’s the highly modified version of the pertinent
    code in the HLA `str.cpy()` function that copies one string to another:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The HLA `str.cpy()` function also checks for string overflows and `NULL` pointer
    references (for clarity, that code does not appear in this example). However,
    the takeaway here is that HLA copies the strings as double words in order to improve
    performance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'One nice thing about HLA string variables is that (as read-only objects) HLA
    strings are compatible with zero-terminated strings. For example, if you have
    a function written in C or some other language that expects you to pass a zero-terminated
    string to it, you can call that function and pass an HLA string variable to it,
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only catch is that the C function must not make any changes to the string
    that would affect its length (because the C code won’t update the `Length` field
    of the HLA string). Of course, you can always call a C `strlen()` function upon
    returning to update the length field yourself, but generally, it’s best not to
    pass HLA strings to a function that modifies zero-terminated strings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The comments on length-prefixed strings generally apply to HLA strings, specifically:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Try to use the HLA standard library functions rather than attempting to code
    comparable functions yourself. While you might want to check out the library function’s
    source code (available with HLA), most of the string functions do a good job on
    generic string data.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although, in theory, you shouldn’t count on the explicit length field appearing
    in the HLA string data format, most programs simply grab the length from the 4
    bytes immediately preceding the string data, so there’s generally no need to save
    the length. Careful HLA programmers will actually call the `str.len()` function
    in the HLA standard library and simply save this value in a local variable for
    future use. However, accessing the length directly is probably safe.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations in programs using HLA strings.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.1.5 Descriptor-Based Strings**'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The string formats we’ve considered up to this point have kept the attribute
    information (that is, the lengths and terminating bytes) for a string in memory
    along with the character data. A slightly more flexible scheme is to maintain
    such information in a record structure, known as a *descriptor*, that also contains
    a pointer to the character data. Consider the following Pascal/Delphi data structure
    (see [Figure 10-5](ch10.xhtml#ch10fig5)):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Image](../images/10fig05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: String descriptors*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Note that this data structure does not hold the actual character data. Instead,
    the `strData` pointer contains the address of the first character of the string.
    The `curLength` field specifies the current length of the string. You could add
    any other fields you like to this record, such as a maximum length field, although
    a maximum length isn’t usually necessary because most string formats employing
    a descriptor are dynamic (as the next section will discuss).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: An interesting attribute of a descriptor-based string system is that the actual
    character data associated with a string could be part of a larger string. Because
    no length or terminating bytes are in the actual character data, it’s possible
    to have the character data for two strings overlap (see [Figure 10-6](ch10.xhtml#ch10fig6)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: Overlapping strings using descriptors*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This example shows two strings—`"Hello World"` and `"World"`—that overlap. This
    can save memory and make certain functions, like `substring()`, very efficient.
    Of course, when strings overlap as these do, you can’t modify the string data
    because that could wipe out part of some other string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The suggestions given for other string formats don’t apply as strongly to descriptor-based
    strings. Certainly, if standard libraries are available, you should call those
    functions because they’re probably more efficient than the ones you would write
    yourself. There is no need to save the length, because extracting the length field
    from the string’s descriptor is usually a minor task. Also, many descriptor-based
    string systems use *copy on write* (see *WGC1* and the section “Dynamic Strings”
    on [page 317](ch10.xhtml#page_317)) to reduce string copy overhead. In a string
    descriptor system, you should avoid making changes to a string, because the copy-on-write
    semantics generally require the system to make a complete copy of the string whenever
    you change a single character (something that isn’t necessary with other string
    formats).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**10.2 Static, Pseudo-Dynamic, and Dynamic Strings**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having covered the various string data formats, it’s time to consider where
    to store string data in memory. Strings can be classified according to when and
    where the system allocates storage for them. There are three categories: static
    strings, pseudo-dynamic strings, and dynamic strings.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**10.2.1 Static Strings**'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pure *static strings* are those whose maximum size a programmer chooses when
    writing the program. Pascal strings and Delphi *short strings* fall into this
    category. Arrays of characters that you use to hold zero-terminated strings in
    C/C++ also fall into this category, as do fixed-length arrays of characters. Consider
    the following declaration in Pascal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And here’s an example in C/C++:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While the program is running, there’s no way to increase the maximum sizes of
    these static strings. Nor is there any way to reduce the storage they will use;
    these string objects will consume 256 bytes at runtime, period. One advantage
    to pure static strings is that the compiler can determine their maximum length
    at compile time and implicitly pass this information to a string function so it
    can test for bounds violations at runtime.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**10.2.2 Pseudo-Dynamic Strings**'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A pseudo-dynamic string is one whose length the system sets at runtime by calling
    a memory management function like `malloc()` to allocate storage for it. However,
    once the system allocates storage for the string, the maximum length of the string
    is fixed. HLA strings generally fall into this category.^([6](footnotes.xhtml#ch10fn6))
    An HLA programmer typically calls the `stralloc()` function to allocate storage
    for a string variable, after which that particular string object has a fixed length
    that cannot change.^([7](footnotes.xhtml#ch10fn7))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**10.2.3 Dynamic Strings**'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dynamic string systems, which typically use a descriptor-based format, automatically
    allocate sufficient storage for a string object whenever you create a new string
    or otherwise do something that affects an existing string. Operations like string
    assignment and substring extraction are relatively trivial in dynamic string systems—generally
    they copy only the string descriptor data, so these operations are fast. However,
    as noted in the section “Descriptor-Based Strings” on [page 315](ch10.xhtml#page_315),
    when using strings this way, you cannot store data back into a string object,
    because it could modify data that is part of other string objects in the system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to use the copy-on-write technique. Whenever
    a string function needs to change characters in a dynamic string, the function
    first makes a copy of the string and then makes the necessary modifications to
    that copy. Research suggests that copy-on-write semantics can improve the performance
    of many typical applications, because operations like string assignment and substring
    extraction (which is just a partial string assignment) are far more common than
    the modification of character data within strings. The only drawback to this approach
    is that after several modifications to string data in memory, there may be sections
    of the string heap area that contain character data that’s no longer in use. To
    avoid a memory leak, dynamic string systems employing copy on write usually provide
    garbage collection code, which scans the string heap area looking for stale character
    data in order to recover that memory for other purposes. Unfortunately, depending
    on the algorithms in use, garbage collection can be quite slow.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '*See [Chapter 9](ch09.xhtml#ch09) for more information on memory leaks and
    garbage collection.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**10.3 Reference Counting for Strings**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the case where you have two string descriptors (or pointers) pointing
    at the same string data in memory. Clearly, you can’t deallocate the storage associated
    with one pointer while the program is still using the other pointer to access
    the same data. One common solution is to make the programmer responsible for keeping
    track of such details. Unfortunately, as applications become more complex, this
    approach often leads to dangling pointers, memory leaks, and other pointer-related
    problems in the software. A better solution is to allow the programmer to deallocate
    the storage for the character data in the string and to have the actual deallocation
    process hold off until the programmer releases the last pointer referencing that
    data. To accomplish this, a string system can use *reference counters*, which
    track the pointers and their associated data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: A reference counter is an integer that counts the number of pointers that reference
    a string’s character data in memory. Every time you assign the address of the
    string to some pointer, you increment the reference counter by 1\. Likewise, whenever
    you want to deallocate the storage associated with the character data for the
    string, you decrement the reference counter. Deallocation of the storage for the
    actual character data doesn’t happen until the reference counter decrements to
    0.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Reference counting works great when the language handles the details of string
    assignment automatically for you. If you try to implement reference counting manually,
    you must be sure to always increment the reference counter when you assign a string
    pointer to some other pointer variable. The best way to do this is to never assign
    pointers directly, but rather handle all string assignments via some function
    (or macro) call that updates the reference counters in addition to copying the
    pointer data. If your code fails to update the reference counter properly, you’ll
    wind up with dangling pointers or memory leaks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4 Delphi Strings**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although Delphi provides a “short string” format that is compatible with the
    length-prefixed strings in earlier versions of Delphi and Turbo Pascal, later
    versions of Delphi (v4.0 and later) use dynamic strings for their native string
    format. While this string format is unpublished (and, therefore, subject to change),
    indications are that Delphi’s string format is very similar to HLA’s. Delphi uses
    a zero-terminated sequence of characters with a leading string length and a reference
    counter (rather than a maximum length as HLA uses). [Figure 10-7](ch10.xhtml#ch10fig7)
    shows the layout of a Delphi string in memory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: Delphi string data format*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: As with HLA, Delphi string variables are pointers holding the address of the
    first character of the actual string data. To access the length and reference
    counter fields, the Delphi string routines use a negative offset of –4 and –8
    from the character data’s base address. However, because this string format is
    not published, applications should never access the length or reference counter
    fields directly (for example, these fields could be 64-bit values one day). Delphi
    provides a length function that extracts the string length for you, and there’s
    really no need for your applications to access the reference counter field because
    the Delphi string functions maintain it automatically.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**10.5 Using Strings in a High-Level Language**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings are a very common data type in high-level programming languages. Because
    applications often make extensive use of string data, many HLLs provide libraries
    with lots of complex string manipulation routines that hide considerable complexity
    from the programmer. Unfortunately, it’s easy to forget the amount of work involved
    in a typical string operation when you execute a statement like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In a typical Pascal implementation, this assignment statement calls a function
    that winds up copying each character from the string literal to the storage reserved
    for the aLengthPrefixedString variable. That is, this statement roughly expands
    to the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code doesn’t even include the overhead of the procedure call, return, and
    parameter passing. As noted throughout the chapter, copying string data is one
    of the more expensive operations programs commonly do. This is why many HLLs have
    switched to dynamic strings and copy-on-write semantics—string assignments are
    far more efficient when you copy only a pointer rather than all of the character
    data. This is not to suggest that copy on write is always better, but for many
    string operations—such as assignment, substring, and other operations that do
    not change the string’s character data—it can be very efficient.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Although few programming languages give you the option of choosing which string
    format you want to use, many do let you create pointers to strings, so you can
    manually support copy on write. If you’re willing to write your own string-handling
    functions, you can create some very efficient programs by avoiding the use of
    your language’s built-in string-handling capabilities. For example, the substring
    operation in C is usually handled by the `strncpy()` function and is often implemented
    like so:^([8](footnotes.xhtml#ch10fn8))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A typical “substring” operation might use `strncpy()` as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: where substring is the destination string object, fullString is the source string,
    start is the starting index of the substring to copy, and length is the length
    of the substring to copy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a descriptor-based string format in C using a `struct`, similar
    to the HLA record in “Descriptor-Based Strings” on [page 315](ch10.xhtml#page_315),
    you could do a substring operation with the following two statements in C:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code executes much faster than the `strncpy()` version.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a particular programming language won’t provide access to the underlying
    string data representation it supports, and you’ll have to live with the performance
    loss, switch languages, or write your own string-handling code in assembly language.
    Generally, though, there are alternatives to copying string data in your applications,
    such as using a string descriptor as in the example just given.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6 Unicode Character Data in Strings**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to this point, we’ve assumed that each character in a string consumes exactly
    1 byte of storage. We’ve also assumed the use of the 7-bit ASCII character set
    when discussing the character data appearing in a string. Traditionally, this
    has been the way programming languages have represented a string’s character data.
    Today, however, the ASCII character set is too limited for worldwide use, and
    several new character sets have risen in popularity, including the Unicode variants:
    UTF-8, UTF-16, UTF-32, and UTF-7\. Because these character formats can have a
    big impact on the efficiency of string functions that operate upon them, we’ll
    spend some time covering them.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.1 The Unicode Character Set**'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A few decades back, engineers at Aldus, NeXT, Sun, Apple Computer, IBM, Microsoft,
    the Research Library Group, and Xerox realized that their new computer systems
    with bitmaps and user-selectable fonts could display far more than 256 different
    characters at one time. At the time, *double-byte character sets (DBCSs)* were
    the most common solution. DBCSs had a couple of issues, however. First, as they
    were typically variable-length encodings, DBCSs required special library code;
    common character/string algorithms that depended upon fixed-length character encodings
    would not work properly with them. Second, there was no consistent standard—different
    DBCSs used the same encoding for different characters. So, wanting to avoid these
    compatibility problems, the engineers sought a different route.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The solution they came up with was the Unicode character set. The engineers
    who originally developed Unicode chose a 2-byte character size. Like DBCSs, this
    approach still required special library code (existing single-byte string functions
    would not always work with 2-byte characters), but other than changing the size
    of a character, most existing string algorithms would still work with 2-byte characters.
    The Unicode definition included all of the (known/living) character sets at the
    time, giving each character a unique encoding, to avoid the consistency problems
    that plagued differing DBCSs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The original Unicode standard used a 16-bit word to represent each character.
    Therefore, Unicode supported up to 65,536 different character codes—a huge advance
    over the 256 possible codes that are representable with an 8-bit byte. Furthermore,
    Unicode is upward compatible from ASCII. If the HO 9 bits^([9](footnotes.xhtml#ch10fn9))
    of a Unicode character’s binary representation contain `0`, then the LO 7 bits
    use the standard ASCII code. If the HO 9 bits contain some nonzero value, then
    the 16 bits form an extended character code (extended from ASCII, that is). If
    you’re wondering why so many different character codes are necessary, note that,
    at the time, certain Asian character sets contained 4,096 characters. The Unicode
    character set even provided a set of codes you could use to create an application-defined
    character set. Approximately half of the 65,536 possible character codes have
    been defined, and the remaining character encodings are reserved for future expansion.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Today, Unicode is a universal character set, long replacing ASCII and older
    DBCSs. All modern operating systems (including macOS, Windows, Linux, iOS, Android,
    and Unix), web browsers, and most modern applications provide Unicode support.
    Unicode Consortium, a nonprofit corporation, maintains the Unicode standard. By
    maintaining the standard, Unicode, Inc. (*[https://home.unicode.org](https://home.unicode.org)*),
    helps guarantee that a character you write on one system will display as you expect
    on a different system or application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.2 Unicode Code Points**'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Alas, as well thought-out as the original Unicode standard was, it couldn’t
    have anticipated the explosion in characters that would occur. Emojis, astrological
    symbols, arrows, pointers, and a wide variety of symbols introduced for the internet,
    mobile devices, and web browsers have greatly expanded the Unicode symbol repertoire
    (along with a desire to support historic, obsolete, and rare scripts). In 1996,
    systems engineers discovered that 65,536 symbols were insufficient. Rather than
    require 3 or 4 bytes for each Unicode character, those in charge of the Unicode
    definition gave up on trying to create a fixed-size representation of characters
    and allowed for opaque (and multiple) encodings of Unicode characters. Today,
    Unicode defines 1,112,064 code points, far exceeding the 2-byte capacity originally
    set aside for Unicode characters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: A Unicode *code point* is simply an integer value that Unicode associates with
    a particular character symbol; you can think of it as the Unicode equivalent of
    the ASCII code for a character. The convention for Unicode code points is to specify
    the value in hexadecimal with a `U+` prefix; for example, `U+0041` is the Unicode
    code point for the letter *A*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '*See* [https://en.wikipedia.org/wiki/Unicode#General_Category_property](https://en.wikipedia.org/wiki/Unicode#General_Category_property)
    *for more details on code points.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.3 Unicode Code Planes**'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because of its history, blocks of 65,536 characters are special in Unicode—they
    are known as a *multilingual plane*. The first multilingual plane, `U+000000`
    to `U+00FFFF`, roughly corresponds to the original 16-bit Unicode definition;
    the Unicode standard calls this the *Basic Multilingual Plane (BMP)*. Planes 1
    (`U+010000` to `U+01FFFF`), 2 (`U+020000` to `U+02FFFF`), and 14 (`U+0E0000` to
    `U+0EFFFF`) are supplementary planes. Unicode reserves planes 3 through 13 for
    future expansion and planes 15 and 16 for user-defined character sets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unicode standard defines code points in the range `U+000000` to `U+10FFFF`.
    Note that `0x10ffff` is 1,114,111, which is where most of the 1,112,064 characters
    in the Unicode character set come from; the remaining 2,048 code points are reserved
    for use as *surrogates*, which are Unicode extensions. *Unicode scalar* is another
    term you might hear; this is a value from the set of all Unicode code points *except*
    the 2,048 surrogate code points. The HO two hexadecimal digits of the six-digit
    code point value specify the multilingual plane. Why 17 planes? The reason, as
    you’ll see in a moment, is that Unicode uses special multiword entries to encode
    code points beyond `U+FFFF`. Each of the two possible extensions encodes 10 bits,
    for a total of 20 bits; 20 bits gives you 16 multilingual planes, which, plus
    the original BMP, produces 17 multilingual planes. This is also why code points
    fall in the range `U+000000` to `U+10FFFF`: it takes 21 bits to encode the 16
    multilingual planes plus the BMP.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.4 Surrogate Code Points**'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted earlier, Unicode began life as a 16-bit (2-byte) character set encoding.
    When it became apparent that 16 bits were insufficient to handle all the possible
    characters that existed at the time, an expansion was necessary. As of Unicode
    v2.0, the Unicode, Inc., organization extended the definition of Unicode to include
    multiword characters. Now Unicode uses surrogate code points (`U+D800` through
    `U+DFFF`) to encode values larger than `U+FFFF`. [Figure 10-8](ch10.xhtml#ch10fig8)
    shows the encoding.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig08.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: Surrogate code point encoding for Unicode planes 1 through 16*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Note that the two words (unit 1/high surrogate and unit 2/low surrogate) always
    appear together. The unit 1 value (with HO bits `%110110`) specifies the upper
    10 bits (`b[10]`..`b[19]`) of the Unicode scalar, and the unit 2 value (with HO
    bits `%110111`) specifies the lower 10 bits (`b[0]`..`b[9]`) of the Unicode scalar.
    Therefore, the value of bits `b[16]`..`b[19]` plus 1 specifies Unicode plane 1
    through 16\. Bits `b[0]`..`b[15]` specify the Unicode scalar value within the
    plane.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Note that surrogate codes only appear in the BMP. None of the other multilingual
    planes contain surrogate codes. Bits `b[0]`..`b[19]` extracted from the unit 1
    and 2 values always specify a Unicode scalar value (even if the values fall in
    the range `U+D800` through `U+DFFF`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.5 Glyphs, Characters, and Grapheme Clusters**'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each Unicode code point has a unique name. For example, `U+0045` has the name
    “LATIN CAPITAL LETTER A.” Note that the symbol *A* is *not* the name of the character.
    *A* is a *glyph*—a series of strokes (one horizontal and two slanted strokes)
    that a device draws in order to represent the character.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: There are many different glyphs for the single Unicode character “LATIN CAPITAL
    LETTER A.” For example, a Times Roman A and a Times Roman Italic *A* have different
    glyphs, but Unicode doesn’t differentiate between them (or between the *A* character
    in any two different fonts). The character “LATIN CAPITAL LETTER A” remains `U+0045`
    regardless of the font or style you use to draw it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'As an interesting side note, if you have access to the Swift programming language,
    you can print the name of any Unicode character using the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, what exactly is a character in Unicode? Unicode scalars are Unicode characters,
    but there’s a difference between what you’d normally call a character and the
    definition of a Unicode character (scalar). For example, is *é* one character
    or two? Consider the following Swift code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`"\u{301}"` is the Swift syntax for specifying a Unicode scalar value within
    a string; in this particular case `301` is the hexadecimal code for the *combining
    acute accent* character.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `print` statement:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: prints the character (producing `é` on the output, as we expect).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `print` statement prints the number of characters Swift determines
    are present in the string:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This prints `1` to the standard output.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The third `print` statement prints the number of elements (UTF-16 elements^([10](footnotes.xhtml#ch10fn10)))
    in the string:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This prints `2` on the standard output, because the string holds 2 words of
    UTF-16 data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: So, again, is this one character or two? Internally (assuming UTF-16 encoding),
    the computer sets aside 4 bytes of memory for this single character (two 16-bit
    Unicode scalar values).^([11](footnotes.xhtml#ch10fn11)) On the screen, however,
    the output takes only one character position and looks like a single character
    to the user. When this character appears within a text editor and the cursor is
    immediately to the right of the character, the user expects that pressing the
    backspace key will delete it. From the user’s perspective, then, this is a single
    character (as Swift reports when you print the `count` attribute of the string).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In Unicode, however, a character is largely equivalent to a code point. This
    is not what people normally think of as a character. In Unicode terminology, a
    *grapheme cluster* is what people normally call a character—it’s a sequence of
    one or more Unicode code points that combine to form a single language element
    (that is, a single character). So, when we talk about characters with respect
    to symbols that an application displays to an end user, we’re really talking about
    grapheme clusters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Grapheme clusters can make life miserable for software developers. Consider
    the following Swift code (a modification of the earlier example):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code produces the same `é` and `1` outputs from the first two `print`
    statements. The following produces `é`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: and this `print` statement produces `1`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, the third `print` statement:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: displays `3` rather than `2` (as in the original example).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: There are definitely three Unicode scalar values in this string (`U+0065`, `U+0301`,
    and `U+0301`). When printing, the operating system combines the `e` and the two
    acute accent combining characters to form the single character `é` and then outputs
    the character to the standard output device. Swift is smart enough to know that
    this combination creates a single output symbol on the display, so printing the
    result of the `count` attribute continues to output `1`. However, there are (undeniably)
    three Unicode code points in this string, so printing `utf16.count` produces `3`
    on output.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.6 Unicode Normals and Canonical Equivalence**'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Unicode character *é* actually existed on personal computers long before
    Unicode came along. It’s part of the original IBM PC character set and also part
    of the Latin-1 character set (used, for example, on old DEC terminals). As it
    turns out, Unicode uses the Latin-1 character set for the code points in the range
    `U+00A0` to `U+00FF`, and `U+00E9` just happens to correspond to the *é* character.
    Therefore, we can modify the earlier program as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And here are the outputs from this program:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Ouch! Three different strings all producing `é` but containing a different number
    of code points. Imagine how this complicates programming strings containing Unicode
    characters. For example, if you have the following three strings (Swift syntax)
    and you try to compare them, what will the result be?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To the user, all three strings look the same on the screen. However, they clearly
    contain different values. If you compare them to see if they are equal, will the
    result be `true` or `false`?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, that depends upon whose string libraries you’re using. Most current
    string libraries would return `false` if you compared these strings for equality.
    Interestingly enough, Swift will claim that `eAccent1` is equal to `eAccent2`,
    but it isn’t smart enough to report that `eAccent1` is equal to `eAccent3` or
    that `eAccent2` is equal to `eAccent3`—despite the fact that it displays the same
    symbol for all three strings. Many languages’ string libraries simply report that
    all three strings are unequal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The three Unicode/Swift strings `"\u{E9}"`, `"e\u{301}"`, and `"e\u{301}\u{301}"`
    all produce the same output on the display. Therefore, they are canonically equivalent
    according to the Unicode standard. Some string libraries won’t report any of these
    strings as being equivalent. Some, like the one accompanying Swift, will handle
    small canonical equivalences (such as `"\u{E9}" == "e\u{301}"`) but not arbitrary
    sequences that should be equivalent (probably a good balance of correctness versus
    efficiency; it can be computationally expensive to handle all the weird cases
    that won’t normally happen, such as `"e\u{301}\u{301}"`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Unicode defines *normal forms* for Unicode strings. One aspect of normal form
    is to replace canonically equivalent sequences with an equivalent sequence—for
    example, replace `"e\u{309}"` by `"\u{E9}"` or replace `"\u{E9}"` by `"e\u{309}"`
    (usually, the shorter form is preferable). Some Unicode sequences allow multiple
    combining characters. Often, the order of the combining characters is irrelevant
    to producing the desired grapheme cluster. However, it’s easier to compare two
    such strings if the combining characters are in a specified order. Normalizing
    Unicode strings may also produce results whose combining characters always appear
    in a fixed order (thereby improving efficiency of string comparisons).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.7 Unicode Encodings**'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As of Unicode v2.0, the standard supports a 21-bit character space capable of
    handling over a million characters (though most of the code points remain reserved
    for future use). Rather than use a fixed-size 3-byte (or worse, 4-byte) encoding
    to allow the larger character set, Unicode, Inc., allows different encodings—UTF-32,
    UTF-16, and UTF-8—each with its own advantages and disadvantages.^([12](footnotes.xhtml#ch10fn12))
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: UTF-32 uses 32-bit integers to hold Unicode scalars. The advantage to this scheme
    is that a 32-bit integer can represent every Unicode scalar value (which requires
    only 21 bits). Programs that require random access to characters in strings—without
    having to search for surrogate pairs—and other constant-time operations are (mostly)
    possible when using UTF-32\. The obvious drawback to UTF-32 is that each Unicode
    scalar value requires 4 bytes of storage—twice that of the original Unicode definition
    and four times that of ASCII characters. It may seem that using two or four times
    as much storage (over ASCII and the original Unicode) is a small price to pay.
    After all, modern machines have several orders of magnitude more storage than
    they did when Unicode first appeared. However, that extra storage has a huge impact
    on performance, because those additional bytes quickly consume cache storage.
    Furthermore, modern string processing libraries often operate on character strings
    8 bytes at a time (on 64-bit machines). With ASCII characters, that means a given
    string function can process up to eight characters concurrently; with UTF-32,
    that same string function can operate on only two characters concurrently. As
    a result, the UTF-32 version will run four times slower than the ASCII version.
    Ultimately, even Unicode scalar values are insufficient to represent all Unicode
    characters (that is, many Unicode characters require a sequence of Unicode scalars),
    so using UTF-32 doesn’t solve the problem.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The second encoding format the Unicode supports is UTF-16\. As the name suggests,
    UTF-16 uses 16-bit (unsigned) integers to represent Unicode values. To handle
    scalar values greater than `0xFFFF`, UTF-16 uses the surrogate pair scheme to
    represent values in the range `0x010000` to `0x10FFFF` (see “Surrogate Code Points”
    on [page 323](ch10.xhtml#page_323)). Because the vast majority of useful characters
    fit into 16 bits, most UTF-16 characters require only 2 bytes. For those rare
    cases where surrogates are necessary, UTF-16 requires 2 words (32 bits) to represent
    the character.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The last encoding, and unquestionably the most popular, is UTF-8\. The UTF-8
    encoding is forward compatible from the ASCII character set. In particular, all
    ASCII characters have a single-byte representation (their original ASCII code,
    where the HO bit of the byte containing the character contains a `0` bit). If
    the UTF-8 HO bit is `1`, then UTF-8 requires between 1 and 3 additional bytes
    to represent the Unicode code point. [Table 10-1](ch10.xhtml#ch10tab1) provides
    the UTF-8 encoding schema.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** UTF Encoding'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bytes** | **Bits for code point** | **First code point** | **Last code
    point** | **Byte 1** | **Byte 2** | **Byte 3** | **Byte 4** |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| `1` | `7` | `U+00` | `U+7F` | `0`*xxxxxxx* |  |  |  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| `2` | `11` | `U+80` | `U+7FF` | `110`*xxxxx* | `10`*xxxxxx* |  |  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| `3` | `16` | `U+800` | `U+FFFF` | `1110`*xxxx* | `10`*xxxxxx* | `10`*xxxxxx*
    |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| `4` | `21` | `U+10000` | `U+10FFFF` | `11110`*xxx* | `10`*xxxxxx* | `10`*xxxxxx*
    | `10`*xxxxxx* |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: The “xxx . . . ” bits are the Unicode code point bits. For multibyte sequences,
    Byte 1 contains the HO bits, Byte 2 contains the next HO bits (LO bits compared
    to byte 1), and so on. For example, the 2-byte sequence (`%11011111`, `%10000001`)
    corresponds to the Unicode scalar `%0000_0111_1100_0001` (`U+07C1`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 encoding is probably the most common encoding in use. Most web pages use
    it. Most C standard library string functions will operate on UTF-8 text without
    modification (although some C standard library functions can produce malformed
    UTF-8 strings if the programmer isn’t careful with them).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Different languages and operating systems use different encodings as their default.
    For example, macOS and Windows tend to use UTF-16 encoding, whereas most Unix
    systems use UTF-8\. Some variants of Python use UTF-32 as their native character
    format. By and large, though, most programming languages use UTF-8 because they
    can continue to use older ASCII-based character processing libraries to process
    UTF-8 characters. Apple’s Swift is one of the first programming languages that
    attempts to do Unicode right (though there is a huge performance hit for doing
    so).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.8 Unicode Combining Characters**'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although UTF-8 and UTF-16 encodings are much more compact than UTF-32, the CPU
    overhead and algorithmic complexities of dealing with multibyte (or multiword)
    characters sets complicates their use (introducing bugs and performance issues).
    Despite the issues of wasting memory (especially in the cache), why not simply
    define characters as 32-bit entities and be done with it? This seems like it would
    simplify string processing algorithms, improving performance and reducing the
    likelihood of defects in the code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this theory is that you cannot represent all possible grapheme
    clusters with only 21 bits (or even 32 bits) of storage. Many grapheme clusters
    consist of several concatenated Unicode code points. Here’s an example from Chris
    Eidhof and Ole Begemann’s *Advanced Swift* (CreateSpace, 2017):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Each of these Unicode grapheme clusters produces an identical character: an
    `ó` with a dot underneath the character (this is a character from the Yoruba character
    set). The character sequence (`U+1ECD`, `U+300`) is an `o` with a dot under it
    followed by a combining acute. The character sequence (`U+F2`, `U+323`) is an
    `ó` followed by a combining dot. The character sequence (`U+6F`, `U+323`, `U+300`)
    is an `o` followed by a combining dot, followed by a combining acute. Finally,
    the character sequence (`U+6F`, `U+300`, `U+323`) is an `o` followed by a combining
    acute, followed by a combining dot. All four strings produce the same output.
    Indeed, the Swift string comparisons treat all four strings as equal:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that there is not a single Unicode scalar value that will produce this
    character. You must combine at least two Unicode scalars (or as many as three)
    to produce this grapheme cluster on the output device. Even if you used UTF-32
    encoding, it would still require two (32-bit) scalars to produce this particular
    output.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Emojis present another challenge that can’t be solved using UTF-32\. Consider
    the Unicode scalar `U+1F471`. This prints an emoji of a person with blond hair.
    If we add a skin color modifier to this, we obtain (`U+1F471`, `U+1F3FF`), which
    produces a person with a dark skin tone (and blond hair). In both cases we have
    a single character displaying on the screen. The first example uses a single Unicode
    scalar value, but the second example requires two. There is no way to encode this
    with a single UTF-32 value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that certain Unicode grapheme clusters will require multiple
    scalars, no matter how many bits we assign to the scalar (it’s possible to combine
    30 or 40 scalars into a single grapheme cluster, for example). That means we’re
    stuck dealing with multiword sequences to represent a single “character” regardless
    of how hard we try to avoid it. This is why UTF-32 has never really taken off.
    It doesn’t solve the problem of random access into a string of Unicode characters.
    If you’ve got to deal with normalizing and combining Unicode scalars, it’s more
    efficient to use UTF-8 or UTF-16 encodings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Again, most languages and operating systems today support Unicode in one form
    or another (typically using UTF-8 or UTF-16 encoding). Despite the obvious problems
    with dealing with multibyte character sets, modern programs need to deal with
    Unicode strings rather than simple ASCII strings. Swift, which is almost “pure
    Unicode,” doesn’t even offer much in the way of standard ASCII character support.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**10.7 Unicode String Functions and Performance**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unicode strings have one fundamental problem: because Unicode is a multibyte
    character set, the number of bytes in a character string is not equal to the number
    of characters (or, more importantly, the number of glyphs) in the string. Unfortunately,
    the only way to determine the length of a string is to scan all bytes in the string
    (from the beginning to the end) and count those characters. In this respect, the
    performance of a Unicode string length function will be proportional to the size
    of the string, just as it is for zero-terminated strings.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Worse still, the only way to compute the index of a character position in a
    string (that is, the offset in bytes from the beginning of the string) is to scan
    from the beginning of the string and count off the desired number of characters.
    Even zero-terminated (ASCII) strings don’t suffer from this problem. In Unicode,
    functions like substring or insert/delete characters in a string can be very expensive.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The Swift standard library’s string function performance suffers as a result
    of the language’s Unicode purity. Swift programmers have to exercise caution when
    processing strings because operations that would normally be fast in C/C++ or
    other languages can be a source of performance problems in Swift’s Unicode environment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**10.8 For More Information**'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '———. *Write Great Code, Volume 1: Understanding the Machine*. 2nd ed. San Francisco:
    No Starch Press, 2020.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
