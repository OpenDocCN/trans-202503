<html><head></head><body><div class="preface" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="introduction"/>Introduction</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00001"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>What seems complex from a distance is often quite simple when you look closely enough.</em></span></p></blockquote></div><p>At first glance, learning how to use Ruby can seem fairly simple. Developers around the world find Ruby’s syntax to be graceful and straightforward. You can express algorithms in a very natural way, and then it’s just a matter of typing <code class="literal">ruby</code> at the command line and pressing <span class="smaller">enter</span>, and your Ruby script is running.</p><p>However, Ruby’s syntax is <span class="emphasis"><em>deceptively</em></span> simple; in fact, Ruby employs sophisticated ideas from complex languages like Lisp and Smalltalk. On top of this, Ruby is dynamic; using metaprogramming, Ruby programs can inspect and change themselves. Beneath this thin veneer of simplicity, Ruby is a very complex tool.</p><p>By looking very closely at Ruby—by learning how Ruby itself works internally—you’ll discover that a few important computer science concepts underpin Ruby’s many features. By studying these, you’ll gain a deeper understanding of what is happening under the hood as you use the language. In the process, you’ll learn how the team that built Ruby <span class="emphasis"><em>intends</em></span> for you to use the language.</p><p><span class="emphasis"><em>Ruby Under a Microscope</em></span> will show you what happens inside Ruby when you run a simple program. You’ll learn how Ruby understands and executes your code, and with the help of extensive diagrams, you’ll build a mental model of what Ruby does when you create an object or call a block.</p><div class="sect1" title="Who This Book Is For"><div class="titlepage"><div><div><h1 class="title"><a id="who_this_book_is_for"/>Who This Book Is For</h1></div></div></div><p><span class="emphasis"><em>Ruby Under a Microscope</em></span> is not a beginner’s guide to learning Ruby. I assume you already know how to program in Ruby and that you use it daily. There are already many great books that teach Ruby basics; the world doesn’t need another one.</p><p>Although Ruby itself is written in C, a confusing, low-level language, no C programming knowledge is required to read this book. <span class="emphasis"><em>Ruby Under a Microscope</em></span> will give you a high-level, conceptual understanding of how Ruby works without your having to understand how to program in C. Inside this book, you’ll find hundreds of diagrams that make the low-level details of Ruby’s internal implementation easy to understand.</p><div class="note" title="Note"><h3 class="title"><a id="ch00note01"/>Note</h3><p><span class="emphasis"><em>Readers familiar with C will find a few snippets of C code that give a more concrete sense of what’s going on inside Ruby. I’ll also tell you where the code derives from, making it easier for you to start studying the C code yourself. If you’re not interested in the C code details, just skip over these sections.</em></span></p></div></div><div class="sect1" title="Using Ruby to Test Itself"><div class="titlepage"><div><div><h1 class="title"><a id="using_ruby_to_test_itself"/>Using Ruby to Test Itself</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>It doesn’t matter how beautiful your theory is, it doesn’t matter how smart you are. If it doesn’t agree with experiment, it’s wrong.</p><div class="attribution"><p>—<span class="attribution">Richard Feynman</span></p></div></blockquote></div><p>Imagine that the entire world functioned like a large computer program. To explain natural phenomena or experimental results, physicists like Richard Feynman would simply consult this program. (A scientist’s dream come true!) But of course, the universe is not so simple.</p><p>Fortunately, to discover how Ruby works, all we need to do is read its internal C source code: a kind of theoretical physics that describes Ruby’s behavior. Just as Maxwell’s equations explain electricity and magnetism, Ruby’s internal C source code explains what happens when you pass an argument to a method or include a module in a class.</p><p>Like scientists, however, we need to perform experiments to be sure our hypotheses are correct. After learning about each part of Ruby’s internal implementation, we’ll perform an experiment and use Ruby to test itself! We’ll run small Ruby test scripts to see whether they produce the expected output or run as quickly or as slowly as we expect. We’ll find out if Ruby actually behaves the way theory says it should. And since these experiments are written in Ruby, you can try them yourself.</p></div><div class="sect1" title="Which Implementation of Ruby?"><div class="titlepage"><div><div><h1 class="title"><a id="which_implementation_of_rubyquestion_mar"/>Which Implementation of Ruby?</h1></div></div></div><p>Ruby was invented by Yukihiro “Matz” Matsumoto in 1993, and the original, standard version of Ruby is often known as <span class="emphasis"><em>Matz’s Ruby Interpreter (MRI)</em></span>. Most of this book will discuss how MRI works; essentially, we’ll learn how Matz implemented his own language.</p><p>Over the years many alternative implementations of Ruby have been written. Some, like RubyMotion, MacRuby, and IronRuby, were designed to run on specific platforms. Others, like Topaz and JRuby, were built using programming languages other than C. One version, Rubinius, was built using Ruby itself. And Matz himself is now working on a smaller version of Ruby called <span class="emphasis"><em>mruby</em></span>, designed to run inside another application.</p><p>I explore the Ruby implementations JRuby and Rubinius in detail in <a class="xref" href="ch10.html" title="Chapter 10. JRuby: Ruby on the JVM">Chapter 10</a>, <a class="xref" href="ch11.html" title="Chapter 11. Rubinius: Ruby Implemented with Ruby">Chapter 11</a>, and <a class="xref" href="ch12.html" title="Chapter 12. Garbage Collection in MRI, JRuby, and Rubinius">Chapter 12</a>. You’ll learn how they use different technologies and philosophies to implement the same language. As you study these alternative Rubies, you’ll gain additional perspective on MRI’s implementation.</p></div><div class="sect1" title="Overview"><div class="titlepage"><div><div><h1 class="title"><a id="overview"/>Overview</h1></div></div></div><p>In <span class="strong"><strong><a class="xref" href="ch01.html" title="Chapter 1. Tokenization and Parsing">Chapter 1</a></strong></span>, you’ll learn how Ruby parses your Ruby program. This is one of the most fascinating areas of computer science: How can a computer language be smart enough to understand the code you give it? What does this intelligence really consist of?</p><p><span class="strong"><strong><a class="xref" href="ch02.html" title="Chapter 2. Compilation">Chapter 2</a></strong></span> explains how Ruby uses a compiler to convert your program into a different language before running it.</p><p><span class="strong"><strong><a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a></strong></span> looks at the virtual machine Ruby uses to run your program. What’s inside this machine? How does it work? We’ll look deep inside this virtual machine to find out.</p><p><span class="strong"><strong><a class="xref" href="ch04.html" title="Chapter 4. Control Structures and Method Dispatch">Chapter 4</a></strong></span> continues the description of Ruby’s virtual machine, looking at how Ruby implements control structures such as <code class="literal">if...else</code> statements and <code class="literal">while...end</code> loops. It also explores how Ruby implements method calls.</p><p><span class="strong"><strong><a class="xref" href="ch05.html" title="Chapter 5. Objects and Classes">Chapter 5</a></strong></span> discusses Ruby’s implementation of objects and classes. How are objects and classes related? What would we find inside a Ruby object?</p><p><span class="strong"><strong><a class="xref" href="ch06.html" title="Chapter 6. Method Lookup and Constant Lookup">Chapter 6</a></strong></span> examines Ruby modules and their relationship to classes. You’ll learn how Ruby finds methods and constants in your Ruby code.</p><p><span class="strong"><strong><a class="xref" href="ch07.html" title="Chapter 7. The Hash Table: The Workhorse of Ruby Internals">Chapter 7</a></strong></span> explores Ruby’s implementation of hash tables. As it turns out, MRI uses hash tables for much of its internal data, not only for data you save in Ruby hash objects.</p><p><span class="strong"><strong><a class="xref" href="ch08.html" title="Chapter 8. How Ruby Borrowed a Decades-Old Idea from Lisp">Chapter 8</a></strong></span> reveals that one of Ruby’s most elegant and useful features, blocks, is based on an idea originally developed for Lisp.</p><p>In <span class="strong"><strong><a class="xref" href="ch09.html" title="Chapter 9. Metaprogramming">Chapter 9</a></strong></span> tackles one of the most difficult topics for Ruby developers. By studying how Ruby implements metaprogramming internally, you’ll learn how to use metaprogramming effectively.</p><p><span class="strong"><strong><a class="xref" href="ch10.html" title="Chapter 10. JRuby: Ruby on the JVM">Chapter 10</a></strong></span> introduces JRuby, an alternative version of Ruby implemented with Java. You’ll learn how JRuby uses the Java Virtual Machine (JVM) to run your Ruby programs faster.</p><p><span class="strong"><strong><a class="xref" href="ch11.html" title="Chapter 11. Rubinius: Ruby Implemented with Ruby">Chapter 11</a></strong></span> looks at one of the most interesting and innovative implementations of Ruby: Rubinius. You’ll learn how to locate—and modify—the Ruby code in Rubinius to see how a particular Ruby method works.</p><p><span class="strong"><strong><a class="xref" href="ch12.html" title="Chapter 12. Garbage Collection in MRI, JRuby, and Rubinius">Chapter 12</a></strong></span> concludes with a look at garbage collection (GC), one of the most mysterious and confusing topics in computer science. You’ll see how Rubinius and JRuby use very different GC algorithms from those used by MRI.</p><p>By studying all of these aspects of Ruby’s internal implementation, you’ll acquire a deeper understanding of what happens when you use Ruby’s complex feature set. Just as Antonie van Leeuwenhoek first saw microbes and cells looking through early microscopes in the 1600s, by looking inside of Ruby you’ll discover a wide array of interesting structures and algorithms. Join me on a fascinating behind-the-scenes look at what brings Ruby to life!</p></div></div></body></html>