- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory Access and Organization
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapters 1 and 2 showed you how to declare and access simple variables in an
    assembly language program. This chapter fully explains x86-64 memory access. In
    this chapter, you will learn how to efficiently organize your variable declarations
    to speed up access to their data. You’ll also learn about the x86-64 stack and
    how to manipulate data on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses several important concepts, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocation by program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x86-64 memory addressing modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indirect and scaled-indexed addressing modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data type coercion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The x86-64 stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will teach to you make efficient use of your computer’s memory
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Runtime Memory Organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A running program uses memory in many ways, depending on the data’s type. Here
    are some common data classifications you’ll find in an assembly language program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Memory values that encode machine instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Uninitialized static data**'
  prefs: []
  type: TYPE_NORMAL
- en: An area in memory that the program sets aside for uninitialized variables that
    exist the whole time the program runs; Windows will initialize this storage area
    to 0s when it loads the program into memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initialized static data**'
  prefs: []
  type: TYPE_NORMAL
- en: A section of memory that also exists the whole time the program runs. However,
    Windows loads values for all the variables appearing in this section from the
    program’s executable file so they have an initial value when the program first
    begins execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Read-only data**'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to initialized static data insofar as Windows loads initial data for
    this section of memory from the executable file. However, this section of memory
    is marked *read-only* to prevent inadvertent modification of the data. Programs
    typically store constants and other unchanging data in this section of memory
    (by the way, note that the code section is also marked read-only by the operating
    system).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Heap**'
  prefs: []
  type: TYPE_NORMAL
- en: This special section of memory is designated to hold dynamically allocated storage.
    Functions such as C’s `malloc()` and `free()` are responsible for allocating and
    deallocating storage in the heap area. “Pointer Variables and Dynamic Memory Allocation”
    in Chapter 4 discusses dynamic storage allocation in greater detail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stack**'
  prefs: []
  type: TYPE_NORMAL
- en: In this special section in memory, the program maintains local variables for
    procedures and functions, program state information, and other transient data.
    See “The Stack Segment and the push and pop Instructions” on page 134 for more
    information about the stack section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the typical sections you will find in common programs (assembly language
    or otherwise). Smaller programs won’t use all of these sections (code, stack,
    and data sections are a good minimum number). Complex programs may create additional
    sections in memory for their own purposes. Some programs may combine several of
    these sections together. For example, many programs will combine the code and
    read-only sections into the same section in memory (as the data in both sections
    gets marked as read-only). Some programs combine the uninitialized and initialized
    data sections together (*initializing* the uninitialized variables to 0). Combining
    sections is generally handled by the linker program. See the Microsoft linker
    documentation for more details on combining sections.^([1](#c03-footnote-1))
  prefs: []
  type: TYPE_NORMAL
- en: Windows tends to put different types of data into different sections (or *segments*)
    of memory. Although it is possible to reconfigure memory as you choose by running
    the linker and specifying various parameters, by default Windows loads a MASM
    program into memory by using an organization similar to that in [Figure 3-1](#figure3-1).^([2](#c03-footnote-2))
  prefs: []
  type: TYPE_NORMAL
- en: '![f03001](image_fi/501089c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: MASM typical runtime memory organization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows reserves the lowest memory addresses. Generally, your application cannot
    access data (or execute instructions) at these low addresses. One reason the operating
    system reserves this space is to help trap NULL pointer references: if you attempt
    to access memory location 0 (NULL), the operating system will generate a *general
    protection fault* (also known as a *segmentation fault*), meaning you’ve accessed
    a memory location that doesn’t contain valid data.'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining six areas in the memory map hold different types of data associated
    with your program. These sections of memory include the stack section, the heap
    section, the `.code` section, the `.data` (static) section, the `.const` section,
    and the `.data?` (storage) section. Each corresponds to a type of data you can
    create in your MASM programs. The `.code`, `.data`, `.const`, and `.data?` sections
    are described next in detail.^([3](#c03-footnote-3))
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 The .code Section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.code` section contains the machine instructions that appear in a MASM
    program. MASM translates each machine instruction you write into a sequence of
    one or more byte values. The CPU interprets these byte values as machine instructions
    during program execution.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when MASM links your program, it tells the system that your program
    can execute instructions and read data from the code segment but cannot write
    data to the code segment. The operating system will generate a general protection
    fault if you attempt to store any data into the code segment.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 The .data Section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `.data` section is where you will typically put your variables. In addition
    to declaring static variables, you can also embed lists of data into the `.data`
    declaration section. You use the same technique to embed data into your `.data`
    section that you use to embed data into the `.code` section: you use the `byte`,
    `word`, `dword`, `qword`, and so on, directives. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Values that MASM places in the `.data` memory segment by using these directives
    are written to the segment after the preceding variables. For example, the byte
    values `1`, `2`, and `3` are emitted to the `.data` section after `b`’s `0` byte.
    Because there aren’t any labels associated with these values, you do not have
    direct access to them in your program. You can use the indexed addressing modes
    to access these extra values.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, note that the `c` and `bn` variables do not have
    an (explicit) initial value. However, if you don’t provide an initial value, MASM
    will initialize the variables in the `.data` section to 0, so MASM assigns the
    NULL character (ASCII code 0) to `c` as its initial value. Likewise, MASM assigns
    false as the initial value for `bn` (assuming false is defined as `0`). Variable
    declarations in the `.data` section always consume memory, even if you haven’t
    assigned them an initial value.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.3 The .const Section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `.const` data section holds constants, tables, and other data that your
    program cannot change during execution. You create read-only objects by declaring
    them in the `.const` declaration section. The `.const` section is similar to the
    `.data` section, with three differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.const` section begins with the reserved word `.const` rather than `.data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All declarations in the `.const` section have an initializer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system does not allow you to write data to variables in a `.const` object
    while the program is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All `.const` object declarations must have an initializer because you cannot
    initialize the value under program control. For many purposes, you can treat `.const`
    objects as literal constants. However, because they are actually memory objects,
    they behave like (read-only) `.data` objects. You cannot use a `.const` object
    anywhere a literal constant is allowed; for example, you cannot use them as displacements
    in addressing modes (see “The x86-64 Addressing Modes” on page 122), and you cannot
    use them in constant expressions. In practice, you can use them anywhere that
    reading a `.data` variable is legal.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `.data` section, you may embed data values in the `.const` section
    by using the `byte`, `word`, `dword`, and so on, data declarations, though all
    declarations must be initialized. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can also declare constant values in the `.code` section. Data
    values you declare in this section are also read-only objects, as Windows write-protects
    the `.code` section. If you do place constant declarations in the `.code` section,
    you should take care to place them in a location that the program will not attempt
    to execute as code (such as after a `jmp` or `ret` instruction). Unless you’re
    manually encoding x86 machine instructions using data declarations (which would
    be rare, and done only by expert programmers), you don’t want your program to
    attempt to execute data as machine instructions; the result is usually undefined.^([4](#c03-footnote-4))
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.4 The .data? Section
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `.const` section requires that you initialize all objects you declare.
    The `.data` section lets you optionally initialize objects (or leave them uninitialized,
    in which case they have the default initial value of `0`). The `.data?` section
    lets you declare variables that are always uninitialized when the program begins
    running. The `.data?` section begins with the `.data?` reserved word and contains
    variable declarations without initializers. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Windows will initialize all `.data?` objects to 0 when it loads your program
    into memory. However, it’s probably not a good idea to depend on this implicit
    initialization. If you need an object initialized with 0, declare it in a `.data`
    section and explicitly set it to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Variables you declare in the `.data?` section may consume less disk space in
    the executable file for the program. This is because MASM writes out initial values
    for `.const` and `.data` objects to the executable file, but it may use a compact
    representation for uninitialized variables you declare in the `.data?` section;
    note, however, that this behavior is dependent on the OS version and object-module
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.5 Organization of Declaration Sections Within Your Programs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `.data`, `.const`, `.data?`, and `.code` sections may appear zero or more
    times in your program. The declaration sections may appear in any order, as the
    following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The sections may appear in an arbitrary order, and a given declaration section
    may appear more than once in your program. As noted previously, when multiple
    declaration sections of the same type (for example, the three `.data?` sections
    in the preceding example) appear in a declaration section of your program, MASM
    combines them into a single group (in any order it pleases).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.6 Memory Access and 4K Memory Management Unit Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The x86-64’s *memory* *management unit (**MMU)* divides memory into blocks
    known as *pages*.^([5](#c03-footnote-5)) The operating system is responsible for
    managing pages in memory, so application programs don’t typically worry about
    page organization. However, you should be aware of a couple of issues when working
    with pages in memory: specifically, whether the CPU even allows access to a given
    memory location and whether it is read/write or read-only (write-protected).'
  prefs: []
  type: TYPE_NORMAL
- en: Each program section appears in memory in contiguous MMU pages. That is, the
    `.const` section begins at offset 0 in an MMU page and sequentially consumes pages
    in memory for all the data appearing in that section. The next section in memory
    (perhaps `.data`) begins at offset 0 in the next MMU page following the last page
    of the previous section. If that previous section (for example, `.const`) did
    not consume an integral multiple of 4096 bytes, padding space will be present
    between the end of that section’s data to the end of its last page (to guarantee
    that the next section begins on an MMU page boundary).
  prefs: []
  type: TYPE_NORMAL
- en: Each new section starts in its own MMU page because the MMU controls access
    to memory by using page *granularity*. For example, the MMU controls whether a
    page in memory is readable/writable or read-only. For ``.const sections, you want
    the memory to be read-only. For the `.data` section, you want to allow reads and
    writes. Because the MMU can enforce these attributes only on a page-by-page basis,
    you cannot have `.data` section information in the same MMU page as a `.const`
    section.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
