<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_221"/><span class="big"><strong>10</strong></span></h2>&#13;
<h2 class="h2a">ADDING ANIMATION AND COLLISION DETECTION WITH TIMERS</h2>&#13;
<div class="image21"><img src="../images/circle.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this chapter, we’ll add timer-based animation to our BubbleDraw app to create floating, bouncing bubbles, and we’ll enhance the app with a user-friendly GUI interface. The enhanced app, called BubbleDrawGUI, will add a <span class="literal">JPanel</span> containing the GUI components shown in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>, giving the user the power to animate or pause the bubbles, change the animation speed, and clear the screen.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_222"/><img src="../images/f0222-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig1"/>Figure 10-1: The enhanced BubbleDrawGUI app features animated, bouncing, semitransparent bubbles, with a GUI interface to control the animation.</em></p>&#13;
<p class="indent">This version of the app is even more interactive and user-friendly than before, allowing the user to draw with floating, bouncy bubbles as they click and drag their mouse on the screen.</p>&#13;
<h3 class="h3"><a id="toc_lev167"/>Copying the BubbleDraw Java Project to Create BubbleDrawGUI</h3>&#13;
<p class="noindent">The new GUI app will build directly on the BubbleDraw project from <a href="ch9.xhtml#ch9">Chapter 9</a>. So, instead of creating a new Java project from scratch, we’ll copy the BubbleDraw project and paste it into the same workspace with a new name. This is a useful approach anytime you want to expand and work on a newer version of a program while keeping the previous version intact.</p>&#13;
<p class="indent">In Eclipse, right-click the <em>BubbleDraw</em> project folder in the Package Explorer pane and select <strong>Copy</strong>. Then, right-click in the Package Explorer pane and select <strong>Paste</strong>. The Copy Project pop-up window will allow you to give the copied project a new name. Enter <span class="codestrong"><span class="literal">BubbleDrawGUI</span></span> and click <strong>OK</strong>. Eclipse will create a new copy of the BubbleDraw project in the Package Explorer pane as BubbleDrawGUI.</p>&#13;
<h4 class="h4"><em><a id="toc_lev168"/>Renaming the Main Class and Java File</em></h4>&#13;
<p class="noindent">Now let’s rename the <em>BubbleDraw.java</em> file. This is the file with a <span class="literal">public static void main()</span> method that runs the application, and renaming it will help us distinguish between the new app and the old version. Inside the new <em>BubbleDrawGUI</em> project folder, right-click <em>BubbleDraw.java</em> and select <strong>Refactor</strong> <span class="ent">▸</span> <strong>Rename</strong>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_223"/><em>Refactoring</em> means restructuring your code, but not its functionality. Usually programmers refactor when they’ve thought of a better, more efficient way of getting their code to do the same thing. When the Rename Compilation Unit window pops up, enter the new name, <span class="codestrong"><span class="literal">BubbleDrawGUI</span></span>, and then click <strong>Finish</strong>. A second window may pop up, warning you that the class contains a <span class="literal">main()</span> method. You can ignore this warning and just click <strong>Finish</strong> a second time. The refactoring process will rename both the class and the Java file to BubbleDrawGUI. We’ll leave the <span class="literal">BubblePanel</span> class unchanged for now.</p>&#13;
<p class="indent">Finally, let’s modify the <span class="literal">JFrame</span> window’s title to match the new GUI version of the app. Open the <em>BubbleDrawGUI.java</em> file. Find the line that creates the <span class="literal">JFrame</span> and modify it to say <em>Your Name's</em> <span class="literal">BubbleDraw GUI App</span> as follows:</p>&#13;
<p class="pre"><span class="gray">import javax.swing.JFrame;<br/>&#13;
public class BubbleDrawGUI extends JFrame {<br/>&#13;
    public static void main(String[] args) {</span><br/>&#13;
        <span class="gray">JFrame frame = new JFrame("Your Name's BubbleDraw</span> GUI <span class="gray">App");</span></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>The first time you run an app containing multiple files, such as the BubblePanel and BubbleDrawGUI apps, you’ll need to run the file that contains the main() method. Running the main file will create configurations that enable you to run the program just by clicking the run button from then on. The BubblePanel class doesn’t contain a main() method, so we must either run</em> BubbleDrawGUI.java <em>or right-click the</em> BubbleDrawGUI <em>project folder and select <strong>Run As</strong></em> <span class="ent">▸</span> <em><strong>Java Application</strong></em>.</p>&#13;
</div>&#13;
<p class="indent">Save your file and then run it to see the new title in the title bar at the top of the window, as shown in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>.</p>&#13;
<div class="image"><img src="../images/f0223-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig2"/>Figure 10-2: The new</em> BubbleDrawGUI.java <em>file opens a window with</em> “Your Name’s <em>BubbleDraw GUI App” in the title bar.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_224"/>Now, let’s make one more change to make the bubbles look more realistic.</p>&#13;
<h4 class="h4"><em><a id="toc_lev169"/>Adding Transparency</em></h4>&#13;
<p class="noindent">Real bubbles often have a semitransparent look. Think about blowing a bubble with bubble gum: once it gets big enough, you can see through the thin surface of the bubble. We can add transparency to the bubbles in the BubbleDrawGUI app to give them a more lifelike appearance.</p>&#13;
<p class="indent">In addition to the RGB color components you learned about in <a href="ch9.xhtml#ch9">Chapter 9</a>, Java can store a fourth component in the <span class="literal">java.awt.Color</span> class. This is called the <em>alpha</em> component, and it represents how transparent or opaque a color should appear onscreen when it is drawn in front of other objects. Just like the RGB color values, the alpha component can have values from <span class="literal">0</span> to <span class="literal">255</span>. An alpha value of <span class="literal">0</span> will make the color invisible, <span class="literal">128</span> will make it look semitransparent like watercolor paint, and <span class="literal">255</span> will make it completely obscure any objects behind it.</p>&#13;
<p class="indent">Because the <span class="literal">Color</span> class’s constructor can accept the alpha value as a fourth argument (right after the RGB color values), we only need to change one line in the <em>BubblePanel.java</em> file to add transparency. Open <em>BubblePanel.java</em> under the BubbleDrawGUI project’s <em>src</em> folder and scroll to the bottom of the file where the <span class="literal">Bubble</span> class is defined:</p>&#13;
<p class="pre"><span class="gray">private class Bubble {</span><br/>&#13;
        <span class="gray">private int x;</span><br/>&#13;
        <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
            color = new Color(rand.nextInt(256),</span><br/>&#13;
                    <span class="gray">rand.nextInt(256),</span><br/>&#13;
                    <span class="gray">rand.nextInt(256),</span><br/>&#13;
                    rand.nextInt(256) <span class="gray">);</span><br/>&#13;
        <span class="gray">}</span></p>&#13;
<p class="indent">Here we change the color variable’s constructor by adding a fourth random value that can range from <span class="literal">0</span> to <span class="literal">255</span>. We do so by adding a comma at the end of the third <span class="literal">rand.nextInt(256)</span> in the <span class="literal">color</span> statement and adding a fourth <span class="literal">rand.nextInt(256)</span> before the closing parenthesis of the <span class="literal">Color()</span> constructor. Be careful to check your commas and parentheses against the code shown here, or the app won’t work.</p>&#13;
<p class="indent">Save the file and then run it. Click around the screen to draw dots that overlap slightly, as shown in <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>.</p>&#13;
<p class="indent">You’ll see now that the bubbles have not only random colors but also varying levels of transparency. Some bubbles are opaque and completely cover the screen behind them, while others are so transparent they’re barely visible. Our bubbles are more bubbly than ever! Now let’s make them float for an even more realistic appearance.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_225"/><img src="../images/f0225-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig3"/>Figure 10-3: Adding an alpha component to the color of each bubble gives them a cool, transparent appearance.</em></p>&#13;
<h3 class="h3"><a id="toc_lev170"/>Adding Animation: Bubbles Rising!</h3>&#13;
<p class="noindent"><em>Animation</em> is the illusion of movement created by showing a sequence of images on the screen. You may have created a flipbook-style animation in a notebook: each drawing was shifted slightly from the previous one, and when you flipped through the notebook, you could see the animation come to life. We’ll add this type of effect to make it look like the bubbles are floating away in the BubbleDrawGUI app.</p>&#13;
<p class="indent">To animate the bubbles, we need to draw all the bubbles on the screen, change their location slightly, and then draw the screen again a few times every second. Each screen we draw is called a <em>frame</em>. If we redraw the objects quickly enough, our eyes and brains fill in the gaps between frames, making us believe the same object has moved in a smooth path. The animation’s <em>frame rate</em>, or how quickly we redraw the screen, is usually around 30 frames per second. We’ll use a new class, <span class="literal">javax.swing.Timer</span>, which creates timers, to tell our program when to redraw the bubbles. We’ll also use an event handler to update the bubbles’ location and repaint the screen each time the timer goes off.</p>&#13;
<p class="indent">There are four steps to create the animated bubbles: adding a timer, setting the timer, preparing the animation, and starting the timer. These are the same steps you would use to add animation to a game or any other app that uses a timer in Java.</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_226"/><em><a id="toc_lev171"/>Adding a Timer</em></h4>&#13;
<p class="noindent">To add a timer to our app, we’ll need to import the <span class="literal">javax.swing.Timer</span> class. At the top of your <em>BubblePanel.java</em> file, add the following <span class="literal">import</span> statement:</p>&#13;
<p class="pre">import javax.swing.Timer;<br/>&#13;
<span class="gray">import java.awt.event.*;<br/>&#13;
import java.util.ArrayList;<br/>&#13;
import java.awt.Graphics;<br/>&#13;
import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent">Importing the <span class="literal">Timer</span> class from <span class="literal">javax.swing</span> enables us to create a <span class="literal">timer</span> object that triggers an event as often as we choose. Notice on the second line in the code snippet, we have already imported <span class="literal">java.awt.event.*</span>. This line imports all the <span class="literal">java.awt</span> event handlers, including the <span class="literal">ActionListener</span> class we’ll use to handle timer events.</p>&#13;
<p class="indent">Next, inside the <span class="literal">BubblePanel</span> class, add two variables: one named <span class="literal">timer</span> for the timer itself and an <span class="literal">int</span> named <span class="literal">delay</span> to store how many milliseconds the timer should wait before redrawing the screen:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    <span class="gray">ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    <span class="gray">int size = 25;</span><br/>&#13;
    Timer timer;<br/>&#13;
    int delay = 33;</p>&#13;
<p class="indent">Timers in Java need to know how many milliseconds, or thousandths of a second, to wait until they trigger a timer event. A millisecond is really fast, so I’ve chosen a delay of 33 milliseconds. This will cause the screen to be redrawn about 30 times per second, since 1 second = 1,000 milliseconds and 1,000 / 33 = 30 drawings per second. This is about the same rate as a cartoon on television.</p>&#13;
<h4 class="h4"><em><a id="toc_lev172"/>Setting the Timer</em></h4>&#13;
<p class="noindent">Now we’re ready to set the timer. Inside the <span class="literal">BubblePanel()</span> constructor, add the following line to initialize the timer and set it with the given delay:</p>&#13;
<p class="pre">   <span class="gray">public BubblePanel() {</span><br/>&#13;
       timer = new Timer(delay, new BubbleListener() );<br/>&#13;
       <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
       <span class="gray">setBackground(Color.<span class="codeitalic">BLACK</span>);</span><br/>&#13;
       <span class="gray">// testBubbles();</span><br/>&#13;
       <span class="gray">addMouseListener( new BubbleListener() );</span><br/>&#13;
       <span class="gray">addMouseMotionListener( new BubbleListener() );</span><br/>&#13;
       <span class="gray">addMouseWheelListener( new BubbleListener() );</span><br/>&#13;
   <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_227"/>The constructor for a new <span class="literal">Timer()</span> requires two parameters: the first is the delay in milliseconds, and the second is the event handler that will listen for timer events. A timer triggers an <span class="literal">actionPerformed()</span> event every time it goes off, similar to the <span class="literal">actionPerformed()</span> event we handle for button clicks in a GUI interface. A timer is sort of like an automatic button that “clicks” itself every few milliseconds. We’ve placed the timer first in the constructor so that we can change it in response to GUI events later.</p>&#13;
<p class="indent">To listen for timer events, we’re going to modify the <span class="literal">BubbleListener</span> class. Scroll down in <em>BubblePanel.java</em> to find the private class <span class="literal">BubbleListener</span> that we created earlier. Then add <span class="literal">implements ActionListener</span> before the opening brace for the class:</p>&#13;
<p class="pre"><span class="gray">private class BubbleListener extends MouseAdapter</span> implements ActionListener <span class="gray">{</span></p>&#13;
<p class="indent">This change allows the <span class="literal">BubbleListener</span> class to listen for <span class="literal">actionPerformed()</span> events by implementing the <span class="literal">ActionListener</span> class from <span class="literal">java.awt.event.*</span>. Implementing an event listener class is another way of handling user events. To handle these timer events, we’ll need to add an <span class="literal">actionPerformed()</span> event handler. Add the following method to the bottom of the <span class="literal">BubbleListener</span> class:</p>&#13;
<p class="pre">   <span class="gray">private class BubbleListener extends MouseAdapter implements ActionListener {</span><br/>&#13;
       <span class="gray">public void mousePressed(MouseEvent e) {</span><br/>&#13;
           <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
       }</span><br/>&#13;
       <span class="gray">public void mouseDragged(MouseEvent e) {</span><br/>&#13;
           <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
       }</span><br/>&#13;
       <span class="gray">public void mouseWheelMoved(MouseWheelEvent e) {</span><br/>&#13;
           <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
       }</span><br/>&#13;
       public void actionPerformed(ActionEvent e) {<br/>&#13;
       }<br/>&#13;
  <span class="gray">}</span></p>&#13;
<p class="indent">This new <span class="literal">actionPerformed()</span> method is where we’ll add the code that moves the bubbles and repaints the screen every time the timer goes off. We’ll add those statements next.</p>&#13;
<h4 class="h4"><em><a id="toc_lev173"/>Preparing the Animation</em></h4>&#13;
<p class="noindent">Now that we’ve added a timer and set up the <span class="literal">BubbleListener</span> to listen for timer events, we need to tell Java what to do when the timer triggers an event.</p>&#13;
<p class="indent">Every time the timer fires off an event, it’s time to draw the next image in the animated bubble sequence. First, we’ll tell the <span class="literal">actionPerformed()</span> event handler to update the bubbles and redraw the screen. Then, we’ll tell the <span class="literal">Bubble</span> class to update a bubble by moving it upward on the screen. We’ll have the program do these steps about 30 times per second.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_228"/>Inside the <span class="literal">actionPerformed()</span> method that we added to the <span class="literal">BubbleListener</span> class, add the following three lines of code to update the bubbles and repaint the screen:</p>&#13;
<p class="pre">      <span class="gray">public void actionPerformed(ActionEvent e) {</span><br/>&#13;
       <span class="ent">➊</span> for (Bubble b : bubbleList)<br/>&#13;
           <span class="ent">➋</span> b.update();<br/>&#13;
       <span class="ent">➌</span> repaint();<br/>&#13;
      <span class="gray">}</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we’re using the <span class="literal">for-each</span> version of a <span class="literal">for</span> statement to loop through each <span class="literal">Bubble</span> <span class="literal">b</span> in <span class="literal">bubbleList</span>. Remember that <span class="literal">bubbleList</span> is the <span class="literal">ArrayList</span> containing all the bubbles we’ve created by clicking and dragging the mouse on the screen.</p>&#13;
<p class="indent">As we loop through each bubble in <span class="literal">bubbleList</span>, we call a new function named <span class="literal">update()</span> <span class="ent">➋</span> on all the bubbles. Eclipse underlines this statement in red because we haven’t yet defined the <span class="literal">update()</span> method in the <span class="literal">Bubble</span> class, but we’ll do that in just a moment. The <span class="literal">update()</span> method is where we’ll change the location of the bubbles to make them look like they’re floating up toward the top of the screen.</p>&#13;
<p class="indent">At <span class="ent">➌</span>, we call the <span class="literal">repaint()</span> method to refresh the screen, clearing the drawing window and painting the bubbles in their new, updated locations. By doing this 30 times per second, we’ll achieve the animated effect we want to see.</p>&#13;
<p class="indent">Now let’s create the <span class="literal">update()</span> method to tell the <span class="literal">Bubble</span> class how to move bubbles each time the animation timer is triggered. In Java’s (x, y) coordinate system, we need to subtract from the <span class="literal">y</span> value (the top of the screen is where <span class="literal">y</span> equals <span class="literal">0</span>). So, to make the bubbles appear to move upward, we can subtract a small amount from the y-coordinate at each update.</p>&#13;
<p class="indent">Scroll down to the bottom of <em>BubblePanel.java</em> where we defined the <span class="literal">Bubble</span> class and add the <span class="literal">update()</span> method just below the <span class="literal">draw()</span> method, as shown here:</p>&#13;
<p class="pre">      <span class="gray">public void draw(Graphics canvas) {</span><br/>&#13;
          <span class="gray">canvas.setColor(color);</span><br/>&#13;
          <span class="gray">canvas.fillOval(x - size/2, y - size/2, size, size);</span><br/>&#13;
      <span class="gray">}</span><br/>&#13;
      public void update() {<br/>&#13;
          y -=5;<br/>&#13;
      }<br/>&#13;
   <span class="gray">}<br/>&#13;
}</span></p>&#13;
<p class="indent">The function to update the position of a bubble subtracts five pixels from the <span class="literal">y</span> value for that bubble. Each time a bubble is redrawn on the screen, it will be located five pixels higher than before.</p>&#13;
<p class="indent">Save your file. You only have one more step before you can run the app!</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_229"/><em><a id="toc_lev174"/>Starting the Timer</em></h4>&#13;
<p class="noindent">The final step in animating the BubbleDrawGUI app is starting the timer. Scroll up to the <span class="literal">BubblePanel()</span> constructor and add the following line:</p>&#13;
<p class="pre">   <span class="gray">public BubblePanel() {</span><br/>&#13;
       <span class="gray">timer = new Timer(delay, new BubbleListener() );</span><br/>&#13;
       <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
       addMouseWheelListener( new BubbleListener() );</span><br/>&#13;
       timer.start();<br/>&#13;
   <span class="gray">}</span></p>&#13;
<p class="indent">The <span class="literal">timer.start()</span> method will start the timer so that it will fire events every few milliseconds as specified, until the <span class="literal">timer.stop()</span> method is called or until you exit the program.</p>&#13;
<p class="indent">Save and run the program now. When you draw bubbles, they should float upward, smoothly animated by the timer event handler.</p>&#13;
<p class="indent">The mouse scroll wheel and every other feature we built in <a href="ch9.xhtml#ch9">Chapter 9</a> still work with our mesmerizing animation effect. The bubbles float in only one direction so far, but we’ve achieved the illusion of motion we were aiming for. In the next section, you’ll learn how to make the bubbles float in every direction.</p>&#13;
<h3 class="h3"><a id="toc_lev175"/>Forever Blowing Bubbles: Adding Random Speed and Direction</h3>&#13;
<p class="noindent">The <span class="literal">update()</span> function we created in the previous section changed only the y-location of each bubble, causing the bubbles to move vertically every time the screen was redrawn. In this section, we’ll make the bubbles move both vertically and horizontally at random speeds so they appear to be blowing away in every direction, as shown in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>.</p>&#13;
<div class="image"><img src="../images/f0229-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig4"/>Figure 10-4: Changing both the x- and y-locations of each bubble makes the bubbles look like they’re blowing in random directions from the mouse pointer as we drag.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_230"/>The bubble’s horizontal speed is how many pixels to the left or right it moves each frame. This is what determines the bubble’s new x-location. Similarly, the bubble’s vertical speed determines its new y-location. By just moving the bubble in the horizontal and vertical directions, we can make it move in any direction. <a href="ch10.xhtml#ch10fig5">Figure 10-5</a> shows how the horizontal speed and vertical speed combine to create the illusion that the bubble is moving diagonally.</p>&#13;
<div class="image"><img src="../images/f0230-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig5"/>Figure 10-5: Changing a bubble’s location in both the x- and y-directions quickly will make the bubble appear to move diagonally on the screen.</em></p>&#13;
<p class="indent">First, let’s add variables to store how many pixels each bubble should travel in the x- and y-directions each time the screen is redrawn. Add these two lines to the top of the <span class="literal">Bubble</span> class:</p>&#13;
<p class="pre">   <span class="gray">private class Bubble {</span><br/>&#13;
      <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
      private Color color;</span><br/>&#13;
    <span class="ent">➊</span> private int xspeed, yspeed;<br/>&#13;
    <span class="ent">➋</span> private final int MAX_SPEED = 5;</p>&#13;
<p class="indent">At <span class="ent">➊</span>, we’ve declared two integer variables: <span class="literal">xspeed</span> for the number of pixels the bubble will move horizontally each time the screen updates and <span class="literal">yspeed</span> for the number of pixels the bubble will move vertically. At <span class="ent">➋</span>, we add a <em>constant</em> called <span class="literal">MAX_SPEED</span> for the maximum number of pixels a bubble should move at one time. Constants are named values similar to variables, but constants don’t change inside a program, so we declare them as <span class="literal">final</span> to tell Java that the value of the constant is permanent. We also name constants in all uppercase as a convention so we can tell them apart from regular variables.</p>&#13;
<p class="indent">We’ll give each bubble a random <span class="literal">x</span> and <span class="literal">y</span> speed using the <span class="literal">rand.nextInt()</span> method, just as we did for the bubble’s color. Add these two lines to the <span class="literal">Bubble()</span> constructor:</p>&#13;
<p class="pre">       <span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
           <span class="gray">x = newX;</span><br/>&#13;
           <span class="gray">y = newY;</span><br/>&#13;
           <span class="gray">size = newSize;</span><br/>&#13;
           <span class="gray">color = new Color(rand.nextInt(256),</span><br/>&#13;
                   <span class="gray">rand.nextInt(256),</span><br/>&#13;
                   <span class="gray">rand.nextInt(256),</span><br/>&#13;
                   <span class="gray">rand.nextInt(256) );</span><br/>&#13;
           xspeed = rand.nextInt(MAX_SPEED * 2 + 1) - MAX_SPEED;<br/>&#13;
           yspeed = rand.nextInt(MAX_SPEED * 2 + 1) - MAX_SPEED; <br/>&#13;
      <span class="gray">}</span></p>&#13;
<p class="indent">We need the <span class="literal">x</span> and <span class="literal">y</span> speed values to allow the bubble to move in any direction, but we have only two variables for four directions (left or right, up or down). We can handle this by using both negative and positive values. <span epub:type="pagebreak" id="page_231"/>When the <span class="literal">xspeed</span> is negative, the bubble will move toward the left, and when it’s positive, the bubble will move to the right. The <span class="literal">yspeed</span> will make the bubble move upward when negative and downward when positive. To make the <span class="literal">xspeed</span> and <span class="literal">yspeed</span> ranges span negative and positive values, I’ve multiplied <span class="literal">MAX_SPEED</span> by <span class="literal">2</span> and added <span class="literal">1</span>, which is equal to <span class="literal">11</span> since <span class="literal">5 * 2 + 1 = 11</span>. This makes <span class="literal">rand.nextInt(MAX_SPEED * 2 + 1)</span> equivalent to <span class="literal">rand.nextInt(11)</span>, which will return a number between <span class="literal">0</span> and <span class="literal">10</span>. By subtracting <span class="literal">MAX_SPEED</span> from this value, you’ll get a result between <span class="literal">-5</span> and <span class="literal">+5</span> since <span class="literal">0 - 5 = -5</span>, and <span class="literal">10 - 5 = 5</span>.</p>&#13;
<p class="indent">Finally, we need to change the <span class="literal">update()</span> function to move the bubble to its new location each time the screen is redrawn. Replace the statement <span class="literal">y -= 5;</span> with the following two statements:</p>&#13;
<p class="pre">        <span class="gray">public void update() {</span><br/>&#13;
            x += xspeed;<br/>&#13;
            y += yspeed;<br/>&#13;
        <span class="gray">}</span></p>&#13;
<p class="indent">Instead of moving up five pixels every time the screen is redrawn, each bubble will move horizontally by the <span class="literal">xspeed</span> and vertically by the <span class="literal">yspeed</span> values we randomly generated for that bubble. The result is a colorful explosion of bubbles everywhere we drag the mouse!</p>&#13;
<p class="indent">Save and run the program with these changes, and you’ll see an animated effect like the one we saw in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>. The effect of moving the bubbles in the x- and y-directions over time gives each bubble the illusion of both a random speed and direction.</p>&#13;
<p class="indent">One curious behavior that you might notice is that some bubbles, such as the ones in the center of <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>, stay put. This is because we’re randomly generating numbers between <span class="literal">-5</span> and <span class="literal">+5</span> for the <span class="literal">x</span> and <span class="literal">y</span> speed, and sometimes a bubble’s <span class="literal">xspeed</span> and <span class="literal">yspeed</span> will both be <span class="literal">0</span>. When this happens, the bubble won’t move at all.</p>&#13;
<div class="image"><img src="../images/f0231-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig6"/>Figure 10-6: Because the random speed values can be 0, bubbles like the ones near the center here will stay put.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_232"/>You can avoid having stuck bubbles by checking whether both <span class="literal">xspeed</span> and <span class="literal">yspeed</span> are equal to <span class="literal">0</span> and changing one or both of them—this is Programming Challenge #1 on <a href="ch10.xhtml#page_244">page 244</a>.</p>&#13;
<p class="indent">Now that our bubbles are floating away as we draw them, there are a couple of functions we might want to add to the app: the ability to pause the animation and to clear the screen. It’s time to build a GUI interface within our animated, graphical app.</p>&#13;
<h3 class="h3"><a id="toc_lev176"/>Building a GUI for Our Animated Drawing App</h3>&#13;
<p class="noindent">The BubbleDrawGUI app is graphical, but it doesn’t have an interface like our other GUI apps. A Pause/Start button and a Clear button, shown in <a href="ch10.xhtml#ch10fig7">Figure 10-7</a>, would make it easy for the user to understand and interact with the app, so let’s add those next.</p>&#13;
<div class="image"><img src="../images/f0232-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig7"/>Figure 10-7: The Pause/Start and Clear buttons</em></p>&#13;
<h4 class="h4"><em><a id="toc_lev177"/>Setting Up the GUI Panel and Buttons</em></h4>&#13;
<p class="noindent">In the Package Explorer pane, right-click <em>BubblePanel.java</em> and select <strong>Open With</strong> <span class="ent">▸</span> <strong>WindowBuilder Editor</strong>. Click the Design tab, and you should see the GUI design view.</p>&#13;
<p class="indent">First, let’s add a <span class="literal">JPanel</span> to serve as the container for the Pause/Start and Clear buttons, as well as any other GUI components you might want to add later. In the Palette pane, under Containers, select <strong>JPanel</strong>. Then, hover your mouse over the design preview to the right and click the <span class="literal">BubblePanel</span> design preview to place a new <span class="literal">JPanel</span> onto the black background.</p>&#13;
<p class="indent">Alternatively, you can add a new <span class="literal">JPanel</span> by clicking the <strong>javax.swing.JPanel</strong> entry under the Structure pane and inside the Components pane to the left. You’ll see a very small gray <span class="literal">JPanel</span> appear at the top of the black <span class="literal">BubblePanel</span> design preview.</p>&#13;
<p class="indent">Next, let’s place the Pause/Start and Clear buttons. In the Palette pane, scroll down to the Components section, select the <strong>JButton</strong> component, and then hover and click inside the small <span class="literal">JPanel</span> we just added to place the first <span class="literal">JButton</span>. Enter <span class="codestrong"><span class="literal">Pause</span></span> as the button’s text, either directly in the GUI preview or in the Properties pane. (You’ll see why we refer to it as the <em>Pause/Start</em> button shortly.)</p>&#13;
<p class="indent">Follow the same steps for the clear button: select <strong>JButton</strong> in the Palette pane, click inside the <span class="literal">JPanel</span> to place the button, and enter <span class="codestrong"><span class="literal">Clear</span></span> for the button’s text.</p>&#13;
<p class="indent">If it’s difficult to place the buttons in the <span class="literal">JPanel</span> because it is too small, select <strong>JButton</strong> in the Palette and then click the panel in the Structure pane to the left to place each button inside the panel, as shown expanded in <a href="ch10.xhtml#ch10fig8">Figure 10-8</a>. Name the buttons <span class="literal">btnPause</span> and <span class="literal">btnClear</span> either as you place them or by changing the <span class="literal">Variable</span> property in the Properties pane.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_233"/><img src="../images/f0233-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig8"/>Figure 10-8: When building a GUI, you can select components from the Palette and add them directly to the Structure pane. Here, we’ve added btnPause and btnClear to the panel we just created.</em></p>&#13;
<p class="indent">The Structure pane is a useful way to add components to the GUI in situations like this, when we can’t see the <span class="literal">JPanel</span> well in the design preview, or when we want to change the ordering or grouping of the components in the GUI. <a href="ch10.xhtml#ch10fig9">Figure 10-9</a> shows both buttons in the finished GUI.</p>&#13;
<div class="image"><img src="../images/f0233-02.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig9"/>Figure 10-9: The Pause/Start and Clear buttons in the finished GUI</em></p>&#13;
<p class="indent">Now that we’ve added the Pause/Start and Clear buttons to the top of the drawing screen, it’s time to code the buttons’ event handlers.</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_234"/><em><a id="toc_lev178"/>Coding the Clear and Pause/Start Buttons</em></h4>&#13;
<p class="noindent">Let’s start with the Clear button. One way to clear all the bubbles from the screen would be to reset the <span class="literal">bubbleList</span> variable to a new, empty list—that way, there are no bubbles to be drawn, and the user can begin painting afresh. To implement this behavior, double-click the <strong>Clear</strong> button (remember that double-clicking a button in the Design tab will create an event listener for the button and switch you back to the Source tab) and then add the following two lines inside the braces for <span class="literal">bubbleList</span>’s action listener:</p>&#13;
<p class="pre">        <span class="gray">JButton btnClear = new JButton("Clear");</span><br/>&#13;
        <span class="gray">btnClear.addActionListener(new ActionListener() {</span><br/>&#13;
            <span class="gray">public void actionPerformed(ActionEvent arg0) {</span><br/>&#13;
             <span class="ent">➊</span> bubbleList = new ArrayList&lt;Bubble&gt;();<br/>&#13;
             <span class="ent">➋</span> repaint();<br/>&#13;
            <span class="gray">}</span><br/>&#13;
        <span class="gray">});</span><br/>&#13;
        <span class="gray">panel.add(btnClear);</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we clear the <span class="literal">bubbleList</span> variable by setting it equal to a new <span class="literal">ArrayList</span> of <span class="literal">Bubble</span> objects. This new list will be empty, so all we have to do is repaint the screen and we’ll have a clean, black background just like when we opened the app. At <span class="ent">➋</span>, we call the <span class="literal">repaint()</span> function to draw the new, empty screen.</p>&#13;
<p class="indent">Save and run the app. Then draw a few bubbles and click the <strong>Clear</strong> button to clear the screen.</p>&#13;
<p class="indent">Switch back to the Design tab and double-click the <strong>Pause/Start</strong> button to create another event listener. When the user clicks the Pause/Start button, we want to not only stop the animation by stopping the timer but also change the text on the button to <em>Start</em>. Then, when the user clicks again, we want to restart the timer to resume the animation and set the button’s text back to <em>Pause</em>.</p>&#13;
<p class="indent">Enter the following code into the <span class="literal">actionPerformed()</span> method Eclipse provided when you double-clicked the Pause/Start button.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Make sure your ActionEvent variable in the actionPerformed() method is named e, as highlighted in bold in this code.</em></p>&#13;
</div>&#13;
<p class="pre">       <span class="gray">JButton btnPause = new JButton("Pause");</span><br/>&#13;
       <span class="gray">btnPause.addActionListener(new ActionListener() {</span><br/>&#13;
           <span class="gray">public void actionPerformed(</span><span class="codestrong">ActionEvent e</span><span class="gray">) {</span><br/>&#13;
            <span class="ent">➊</span> JButton btn = (JButton)e.getSource();<br/>&#13;
            <span class="ent">➋</span> if (btn.getText().equals("Pause")) {<br/>&#13;
                <span class="ent">➌</span> timer.stop();<br/>&#13;
                <span class="ent">➍</span> btn.setText("Start");<br/>&#13;
              }<br/>&#13;
              else {<br/>&#13;
                <span class="ent">➎</span> timer.start();<br/>&#13;
                <span class="ent">➏</span> btn.setText("Pause");<br/>&#13;
              }<br/>&#13;
          <span class="gray">}</span><br/>&#13;
      <span class="gray">});</span><br/>&#13;
      <span class="gray">panel.add(btnPause);</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_235"/>At <span class="ent">➊</span>, going from right to left, we use the <span class="literal">e.getSource()</span> method to find out which button was clicked, cast it to a <span class="literal">JButton</span> variable type, and store a link to the button as <span class="literal">btn</span>. The <span class="literal">getSource()</span> method is useful for finding out whether a GUI element has been clicked or changed, especially when you’re writing event handlers for multiple elements at once. In this example, we can use <span class="literal">getSource()</span> to access the button’s properties, such as its <span class="literal">text</span> property.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we check whether the text on the button is equal to the string <span class="literal">"Pause"</span>. If so, we stop the timer <span class="ent">➌</span> to pause the animation, and then we change the text on the button to the string <span class="literal">"Start"</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">If the text on the button wasn’t <span class="literal">"Pause"</span>—in other words, if the animation was already paused and the text on the button had been changed to <span class="literal">"Start"</span> from a previous click—the event handler would go to the <span class="literal">else</span> statement instead and start the timer <span class="ent">➎</span> to resume the animation. Finally, the text on the Pause/Start button will change back to <span class="literal">"Pause"</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Save the file and run it once more. Now you can pause the animation, draw something, and then restart the animation to achieve the jaw-dropping, exploding-bubbles effect shown in <a href="ch10.xhtml#ch10fig10">Figure 10-10</a>.</p>&#13;
<div class="image"><img src="../images/f0235-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig10"/>Figure 10-10: Pause the animation, draw a shape, and then start the animation again to see your drawing explode into colorful bubbles.</em></p>&#13;
<p class="indent">The BubbleDrawGUI app is a visually stunning animated app, and the buttons give the user more control over the drawing screen. But once the animation runs, bubbles float off the edges of the screen, never to return. What if we could make the bubbles bounce around inside the window so that they stayed around a bit longer?</p>&#13;
<h3 class="h3"><a id="toc_lev179"/>Bouncing off the Walls with Collision Detection</h3>&#13;
<p class="noindent">Animation isn’t just for flipbook cartoons and screensavers. There’s another place you encounter animation all the time: computer games. Whether it’s a mobile app or the latest online or console game, animation is how game developers give the user a sense of movement and action.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_236"/>One useful game programming concept that we can add to the final version of the BubbleDrawGUI app is <em>collision detection</em>, which allows us to check whether two objects overlap, or <em>collide</em>, on the screen. You might use collision detection to tell the program what to do when a player shoots an enemy spaceship or kicks a football in a video game. In this app, we want to find out whether a bubble has reached the edge of the drawing screen so we can change the bubble’s direction, making it appear to bounce off the edge of the screen back toward the center like the bubble in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>.</p>&#13;
<div class="image"><img src="../images/f0236-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig11"/>Figure 10-11: The bubble bounces off the right edge of the window, courtesy of collision detection.</em></p>&#13;
<p class="indent">Collision detection can give virtual objects, such as our bubbles in BubbleDrawGUI, a more realistic appearance. In your favorite computer game, collision detection is what keeps your player from falling through the floor or walking through walls. These objects are imaginary—they’re all just computer graphics, so they can’t <em>actually</em> bump into one another—but collision detection creates the illusion that they are solid. So, if we give our bubbles a gentle bounce off the edges of the screen, they’ll feel more like real objects to us. Let’s see how that works.</p>&#13;
<h4 class="h4"><em><a id="toc_lev180"/>A Soft Bounce</em></h4>&#13;
<p class="noindent">First, we’ll break down how collision detection works for bubbles bouncing off the window’s edges. We already know that each bubble has a pair of x -and y-coordinates for its location and an <span class="literal">xspeed</span> and <span class="literal">yspeed</span> for the number of pixels to move horizontally and vertically from one screen refresh to the next.</p>&#13;
<p class="indent">To figure out whether a bubble has collided with the window’s edge, we need to know the x- and y-coordinates of the edges of the screen so we can compare them to the bubble’s x- and y-coordinates. The left edge of the screen is the lowest <span class="literal">x</span> value, or <span class="literal">x==0</span>. And the top of the screen is the smallest <span class="literal">y</span> value, or <span class="literal">y==0</span>. But how about the right edge and bottom of the screen?</p>&#13;
<p class="indent">Every GUI component in Java inherits a pair of methods to return the width and height of the component: <span class="literal">getWidth()</span> and <span class="literal">getHeight()</span>. Our drawing <span epub:type="pagebreak" id="page_237"/>screen for the BubbleDrawGUI app is the <span class="literal">JPanel</span> <span class="literal">BubblePanel</span>. So, if we call the <span class="literal">getWidth()</span> and <span class="literal">getHeight()</span> functions inside <span class="literal">BubblePanel</span>, the maximum <span class="literal">x</span> value is <span class="literal">getWidth()</span>, and the maximum <span class="literal">y</span> value is <span class="literal">getHeight()</span>.</p>&#13;
<p class="indent">We check whether a bubble’s <span class="literal">x</span> and <span class="literal">y</span> value has collided with an edge of the screen in the <span class="literal">Bubble</span> class’s <span class="literal">update()</span> method. You might remember that the <span class="literal">update()</span> method is also where we change each bubble’s x- and y-coordinates using <span class="literal">xspeed</span> and <span class="literal">yspeed</span> to give it the illusion of motion.</p>&#13;
<p class="indent">Let’s be more precise about what we mean by a “bounce.” Back in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>, the bubble is moving toward the right edge of the screen, where <span class="literal">x==getWidth()</span>, meaning the bubble’s <span class="literal">x</span> value is at the maximum x-coordinate, the width of the screen in pixels. To make the bubble look like it’s bouncing, we change the direction it’s moving by reversing the <span class="literal">xspeed</span>. The bubble was moving by some positive number of pixels each time it updated; after it touches the edge of the screen, we can make it move in the opposite direction by changing the sign of <span class="literal">xspeed</span>. In other words, we can make <span class="literal">xspeed</span> <em>negative</em> to make the bubble move to the left and away from the right edge of the screen after it bounces.</p>&#13;
<p class="indent">We can reverse the bubble’s horizontal speed by setting <span class="literal">xspeed = -xspeed</span>, which makes <span class="literal">xspeed</span> the opposite of itself. So, an <span class="literal">xspeed</span> of <span class="literal">3</span> pixels per frame would change to an <span class="literal">xspeed</span> of <span class="literal">-3</span> pixels per frame after the bubble collides with the right edge of the screen, reversing its direction after the bounce.</p>&#13;
<p class="indent">We can do the same with the left edge of the screen, where <span class="literal">x==0</span>. If the bubble’s <span class="literal">x</span> value allows the bubble to touch the left edge, setting <span class="literal">xspeed = -xspeed</span> flips the horizontal motion again: an <span class="literal">xspeed</span> of <span class="literal">-3</span> would become <span class="literal">-(-3)</span>, or <span class="literal">+3</span>. This will make the bubble move to the right again, away from the left edge of the screen.</p>&#13;
<p class="indent">In <em>BubblePanel.java</em>, scroll all the way down to the bottom of the file, where we defined the <span class="literal">Bubble</span> class. Find the <span class="literal">update()</span> method and add the following collision detection code for the left and right edges of the screen:</p>&#13;
<p class="pre">       <span class="gray">public void update() {</span><br/>&#13;
           <span class="gray">x += xspeed;</span><br/>&#13;
           <span class="gray">y += yspeed;</span><br/>&#13;
           if (x &lt;= 0 || x &gt;= getWidth())<br/>&#13;
               xspeed = -xspeed;<br/>&#13;
       <span class="gray">}</span></p>&#13;
<p class="indent">If the bubble’s <span class="literal">x</span> value goes below <span class="literal">0</span>, or if <span class="literal">x</span> goes past the width of the screen, the bubble must have touched either the left or right edge of the screen, so we change the <span class="literal">xspeed</span> to send the bubble bouncing in the opposite direction.</p>&#13;
<p class="indent">For the top and bottom edges, we’ll do the same thing, but this time we change the <span class="literal">yspeed</span>:</p>&#13;
<p class="pre">      <span class="gray">public void update() {</span><br/>&#13;
          <span class="gray">x += xspeed;</span><br/>&#13;
          <span class="gray">y += yspeed;</span><br/>&#13;
          <span class="gray">if (x &lt;= 0 || x &gt;= getWidth())</span><br/>&#13;
              <span class="gray">xspeed = -xspeed;</span><br/>&#13;
          if (y &lt;= 0 || y &gt;= getHeight())<br/>&#13;
              yspeed = -yspeed;<br/>&#13;
      <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_238"/>If the bubble’s <span class="literal">y</span> value goes below <span class="literal">0</span>, or past the height of the screen in pixels, we change <span class="literal">yspeed</span> to <span class="literal">-yspeed</span> to make the bubble move in the opposite direction.</p>&#13;
<p class="indent">Once you’ve made these additions to the <span class="literal">update()</span> method, save and run the file again. This time, you’ll see the bubbles you create rebound softly off all four edges. You may notice a small issue, however: the bubbles move halfway off the screen in any direction before they seem to bounce, as shown in <a href="ch10.xhtml#ch10fig12">Figure 10-12</a>.</p>&#13;
<div class="image"><img src="../images/f0238-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig12"/>Figure 10-12: Around the edge of the window there are many bubbles that are almost halfway off the screen before they rebound.</em></p>&#13;
<p class="indent">This “soft” bounce happens because we’re checking for a collision between the <em>center</em> of each bubble and the edges of the screen. Recall that we centered each bubble around the (x, y) coordinates of the user’s click in <a href="ch9.xhtml#ch9">Chapter 9</a>, so each bubble’s <span class="literal">x</span> and <span class="literal">y</span> values represent the location of the center of that bubble. To make the bubbles stay on the screen completely, we’ll need to test for collisions between the outside edge of each bubble and the edges of the drawing window.</p>&#13;
<h4 class="h4"><em><a id="toc_lev181"/>A Hard Bounce</em></h4>&#13;
<p class="noindent">To check for collisions with the edge of each bubble, we’ll have to account for the distance from the center of each bubble to the edge, which is the bubble’s radius (since each bubble is a perfect circle). The radius is the same as half of the <span class="literal">size</span> value of each bubble, or <span class="literal">size/2</span>. Modify the two <span class="literal">if</span> statements in the <span class="literal">update()</span> method to account for the size of each bubble as shown here:</p>&#13;
<p class="pre">      <span class="gray">public void update() {</span><br/>&#13;
          <span class="gray">x += xspeed;</span><br/>&#13;
          <span class="gray">y += yspeed;</span><br/>&#13;
        <span class="ent">➊</span> if (x - size/2 &lt;= 0 || x + size/2 &gt;= getWidth())<br/>&#13;
              <span class="gray">xspeed = -xspeed;</span><br/>&#13;
        <span class="ent">➋</span> if (y - size/2 &lt;= 0 || y + size/2 &gt;= getHeight())<br/>&#13;
              <span class="gray">yspeed = -yspeed;</span><br/>&#13;
      <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_239"/>At <span class="ent">➊</span>, we subtract <span class="literal">size/2</span> from <span class="literal">x</span> to see whether the left edge of the bubble has touched the left side of the screen, which will be true if <span class="literal">x - size/2</span> is less than or equal to <span class="literal">0</span>. Division is performed before subtraction. Therefore <span class="literal">size/2</span> will be evaluated first and then subtracted from <span class="literal">x</span>, so we don’t need to add parentheses around <span class="literal">size/2</span>. We also add <span class="literal">size/2</span> to <span class="literal">x</span> to see whether the right edge of the bubble is touching the right edge of the screen, which would mean <span class="literal">x + size/2</span> is greater than or equal to <span class="literal">getWidth()</span>. At <span class="ent">➋</span>, we make the same changes to check for the top edge (<span class="literal">y - size/2</span>) and bottom edge (<span class="literal">y + size/2</span>) of each bubble to see whether they are touching the top or bottom, respectively, of the drawing window.</p>&#13;
<p class="indent">Save your program and run it again. Now all the bubbles you create, big and small, bounce solidly off the edges of the window, as shown in <a href="ch10.xhtml#ch10fig13">Figure 10-13</a>.</p>&#13;
<div class="image"><img src="../images/f0239-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig13"/>Figure 10-13: Now our bubbles make a “hard” bounce against the window’s edges, for a more solid appearance.</em></p>&#13;
<p class="indent">Click the maximize button on the app’s title bar or double-click the title bar to expand the window. You’ll see that the bubbles expand to bounce off the edges of the drawing window even when the app is fullscreen. We used the <span class="literal">getWidth()</span> and <span class="literal">getHeight()</span> methods to determine the right and bottom edges, and those methods will always return the current width and height, so feel free to resize the app as you draw.</p>&#13;
<p class="indent">Now let’s make one final addition to give the user even more control via the GUI.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_240"/><a id="toc_lev182"/>Adding a Slider to Control the Animation Speed</h3>&#13;
<p class="noindent">At this point, we’ve given the user control over pausing and clearing the screen, as well as the ability to create big and small bubbles. Let’s also give them control over the animation speed by providing a slider that changes the timer’s delay, as shown in <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>.</p>&#13;
<div class="image"><img src="../images/f0240-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig14"/>Figure 10-14: Adding a slider will allow the user to speed up or slow down the animation.</em></p>&#13;
<p class="indent">First, switch back to the Design tab and add a <span class="literal">JLabel</span> and <span class="literal">JSlider</span> to the GUI control panel. Scroll down under the Palette to find the Components section and select <strong>JLabel</strong>. Click inside the small panel just before the Pause/Start button in your GUI design preview to place the label. Change the label’s text to <span class="codestrong"><span class="literal">Animation Speed:</span></span>.</p>&#13;
<p class="indent">Next, click the <strong>JSlider</strong> component on the Palette. Then click between the Animation Speed label and the Pause/Start button to place the slider, as shown in <a href="ch10.xhtml#ch10fig15">Figure 10-15</a>.</p>&#13;
<div class="image"><img src="../images/f0240-02.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig15"/>Figure 10-15: Add a label and slider to the app’s GUI control panel in the design view.</em></p>&#13;
<p class="indent">You may notice that the <span class="literal">JPanel</span> for all the GUI components grows as we add elements. If you click the panel in the Structure pane, you’ll see that the <span class="literal">Layout</span> property has the default value <span class="literal">java.awt.FlowLayout</span>. This layout expands to fit as many GUI elements as you place inside it. We used the <span class="literal">AbsoluteLayout</span> for the Hi-Lo guessing game and Secret Messages apps because we wanted to place elements in specific positions. In this drawing app, we can be more flexible, and the <span class="literal">FlowLayout</span> is perfect for adding GUI components on the fly.</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_241"/><em><a id="toc_lev183"/>Customizing the Slider</em></h4>&#13;
<p class="noindent">We’ll change a few properties to customize the slider next, so let’s figure out what we want the slider to look like. The slider should allow the user to change the animation speed easily and intuitively. In other words, if the user slides the animation speed to 0, the animation should slow down almost to a stop. If the user slides the animation speed all the way to the right, the animation should go really fast.</p>&#13;
<p class="indent">Monitors usually refresh the screen between 30 and 120 times per second, with 60 Hz (short for <em>hertz</em>, a measure of frequency per second) being the most common refresh rate. If we animate the bubbles faster than 120 times per second, your monitor likely won’t be able to show all of the individual frames in the animation. So it makes sense to set our maximum speed value on the slider to 120 frames per second.</p>&#13;
<p class="indent">The number of frames per second, abbreviated <em>fps</em>, is often a measure of the smoothness of the animation. A game that runs at 60 fps on your computer will look smoother than a game that runs at 30 fps.</p>&#13;
<p class="indent">Select the slider in your design preview. In the Properties pane in the lower left, set the range by specifying a <strong>maximum</strong> of <span class="codestrong"><span class="literal">120</span></span> and a <strong>minimum</strong> of <span class="codestrong"><span class="literal">0</span></span> (the default). To prepare the labels and tick marks, set <strong>majorTickSpacing</strong> to <span class="codestrong"><span class="literal">30</span></span>, set <strong>minorTickSpacing</strong> to <span class="codestrong"><span class="literal">5</span></span>, and select the checkboxes next to <strong>paintLabels</strong>, <strong>paintTicks</strong>, and <strong>paintTrack</strong> to make all three values <span class="literal">true</span>. Finally, change the <strong>value</strong> property to <span class="codestrong"><span class="literal">30</span></span>, the default number of frames per second. <a href="ch10.xhtml#ch10fig16">Figure 10-16</a> shows the Properties pane with all of our customized values, along with a preview of the <span class="literal">JSlider</span> after the changes.</p>&#13;
<div class="image"><img src="../images/f0241-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig16"/>Figure 10-16: The Properties pane for the Animation Speed slider with customized values (left); a preview of the slider showing the customizations (right)</em></p>&#13;
<p class="indent">The slider is labeled from 0 to 120 in increments of 30 because you checked <span class="literal">paintLabels</span> and set <span class="literal">majorTickSpacing</span> to <span class="literal">30</span>. The small tick marks show up between those values because you set <span class="literal">minorTickSpacing</span> to <span class="literal">5</span> and checked <span class="literal">paintTicks</span>. We’ve got a customized slider ready to change the animation speed, so now let’s edit the code to put the slider to work.</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_242"/><em><a id="toc_lev184"/>Implementing the Slider Event Handler</em></h4>&#13;
<p class="noindent">In the Design tab’s design preview, right-click the slider and select <strong>Add event handler</strong> <span class="ent">▸</span> <strong>change</strong> <span class="ent">▸</span> <strong>stateChanged</strong>. Eclipse will add a <span class="literal">ChangeListener</span> with a <span class="literal">stateChanged()</span> method like the one we used in the Secret Messages app’s slider implementation. The code looks like the following:</p>&#13;
<p class="pre">       JSlider slider = new JSlider();<br/>&#13;
       slider.addChangeListener(new ChangeListener() {<br/>&#13;
           public void stateChanged(ChangeEvent e) {<br/>&#13;
           }<br/>&#13;
       });</p>&#13;
<p class="indent">First, we need to declare the <span class="literal">JSlider</span> at the top of the class so that we’ll be able to access the slider’s value inside the <span class="literal">stateChanged()</span> event handler’s code. Scroll up to the top of the <span class="literal">BubblePanel</span> class and add the following line just below the <span class="literal">timer</span> and <span class="literal">delay</span> variables:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    <span class="gray">ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    <span class="gray">int size = 25;</span><br/>&#13;
    <span class="gray">Timer timer;</span><br/>&#13;
    <span class="gray">int delay = 33;</span><br/>&#13;
    JSlider slider;</p>&#13;
<p class="indent">Next, scroll back down to the slider code and remove the <span class="literal">JSlider</span> type declaration from the beginning of the first line:</p>&#13;
<p class="pre">       slider = new JSlider();  // Remove "JSlider" from beginning of line<br/>&#13;
       <span class="gray">slider.addChangeListener(new ChangeListener() {</span><br/>&#13;
           <span class="gray">public void stateChanged(ChangeEvent e) {</span><br/>&#13;
           <span class="gray">}</span><br/>&#13;
       <span class="gray">});</span></p>&#13;
<p class="indent">When the user changes the slider’s position, we want to change the speed of the animation by changing the length of delay between each timer event. To do this, we’ll need to get the speed value from the slider, convert the speed into a number of milliseconds, and then set the timer’s delay to the new value. Add the following three lines inside the braces for the <span class="literal">stateChanged()</span> method:</p>&#13;
<p class="pre">      <span class="gray">slider = new JSlider();</span><br/>&#13;
      <span class="gray">slider.addChangeListener(new ChangeListener() {</span><br/>&#13;
          <span class="gray">public void stateChanged(ChangeEvent arg0) {</span><br/>&#13;
           <span class="ent">➊</span> int speed = slider.getValue() + 1;<br/>&#13;
           <span class="ent">➋</span> int delay = 1000 / speed;<br/>&#13;
           <span class="ent">➌</span> timer.setDelay(delay);<br/>&#13;
          <span class="gray">}</span><br/>&#13;
      <span class="gray">});</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_243"/>At <span class="ent">➊</span>, we use the <span class="literal">getValue()</span> method to get the speed value from the slider and store it in an integer variable named <span class="literal">speed</span>. Notice, though, that we add 1 to the slider value here. We’re doing this to prevent a division-by-zero error at <span class="ent">➋</span>, where we divide <span class="literal">1000</span> by the <span class="literal">speed</span> to determine the number of milliseconds of delay between each frame. The slider can go all the way down to 0, but by adding 1 to its value, we prevent the delay from causing an error: <span class="literal">1000/0</span> throws a division-by-zero exception, but <span class="literal">1000/1</span> gives us a very slow 1,000 milliseconds between frames that feels like the animation is nearly stopped. This means that when the user moves the slider to 0, the animation won’t actually stop. In order to stop the animation completely, they’ll need to click the Pause/Start button instead.</p>&#13;
<p class="indent">Finally, we update the timer by setting the new delay value in milliseconds <span class="ent">➌</span>. This will slow down or speed up the animation by changing the amount of time between timer events.</p>&#13;
<p class="indent">Save the file and run it. Move the slider back and forth, and you’ll see you now have control over the speed of the animation.</p>&#13;
<p class="indent">The BubbleDrawGUI app is our most interactive, entertaining, visually engaging app so far—a graphical, animated drawing app with a GUI interface that gives the user complete control over the animation. Play around with it for a while—and congratulate yourself on a job well done!</p>&#13;
<div class="sidebar">&#13;
<p class="sidetitle"><strong>SHARE AND SHARE ALIKE</strong></p>&#13;
<p class="noindent">This would also be a great app to share with friends. To export a runnable JAR file from Eclipse, go to <strong>File <span class="ent">▸</span> Export</strong>. Then, expand the <em>Java</em> folder and click <strong>Runnable JAR file</strong>. Click <strong>Next</strong> and, under <strong>Launch configuration</strong>, click the drop-down list and choose <strong>BubbleDrawGUI – BubbleDrawGUI</strong>.</p>&#13;
<p class="indent">Under <strong>Export destination</strong>, click <strong>Browse</strong>, and then select the destination folder you’d like to save your finished app in, perhaps <em>Desktop</em>. Give your program file a name, such as <em>Bryson’s BubbleDraw.jar</em>. Click <strong>Save</strong>, then <strong>Finish</strong>.</p>&#13;
<p class="indent">Find where you saved your JAR file, run it, and share it with a friend. Even if your friend doesn’t have Eclipse, as long as they have Java installed, they’ll be able to run your BubbleDrawGUI app. Enjoy!</p>&#13;
</div>&#13;
<h3 class="h3"><a id="toc_lev185"/>What You Learned</h3>&#13;
<p class="noindentb">We built on the BubbleDraw app from <a href="ch9.xhtml#ch9">Chapter 9</a> to produce an animated GUI version with bouncing bubbles. Here are some of the skills we’ve added in this chapter:</p>&#13;
<p class="bull">• Combining a graphical app with a GUI interface</p>&#13;
<p class="bull">• Copying a project and pasting a new version in the Package Explorer in Eclipse</p>&#13;
<p class="bull"><span epub:type="pagebreak" id="page_244"/>• Renaming a class or object by refactoring</p>&#13;
<p class="bull">• Using transparency by setting the alpha component in RGBA colors</p>&#13;
<p class="bull">• Creating, setting, and starting a <span class="literal">Timer</span> object</p>&#13;
<p class="bull">• Handling <span class="literal">Timer</span> object events</p>&#13;
<p class="bull">• Creating an animation by moving graphical objects with a timer</p>&#13;
<p class="bull">• Making virtual objects bounce via collision detection</p>&#13;
<p class="bull">• Using <span class="literal">getWidth()</span> and <span class="literal">getHeight()</span> to find the edges of the window</p>&#13;
<p class="bull">• Using a slider to change a timer’s delay</p>&#13;
<p class="bull">• Varying an animation’s speed by changing the <span class="literal">delay</span> property of a timer</p>&#13;
<h3 class="h3"><a id="toc_lev186"/>Programming Challenges</h3>&#13;
<p class="noindent">Try these programming challenge exercises to review and practice what you’ve learned, as well as to expand your programming skills. Visit the book’s website at <em><a href="https://www.nostarch.com/learnjava/">https://www.nostarch.com/learnjava/</a></em> for sample solutions.</p>&#13;
<h4 class="h4"><em><a id="toc_lev187"/>#1: No Bubble Left Behind</em></h4>&#13;
<p class="noindent">One problem we noted in the chapter was that some bubbles get a random speed of <span class="literal">0</span>, causing them to seem stuck in place while the other bubbles float away. This happens when the bubble’s <span class="literal">xspeed</span> and <span class="literal">yspeed</span> are both set to <span class="literal">0</span>. For this challenge, add some code to make sure that no bubbles get a random speed of <span class="literal">0</span>. To do so, you’ll test the <span class="literal">xspeed</span> and <span class="literal">yspeed</span> values to see whether they’re both equal to <span class="literal">0</span>. If they are, all you need to do is set the two values to something else, like <span class="literal">1</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>HINT</strong></span></p>&#13;
<p class="notep"><em>Add the if statement inside the Bubble() constructor, after the xspeed and yspeed values are created.</em></p>&#13;
</div>&#13;
<p class="pre"><span class="gray">private class Bubble {</span><br/>&#13;
    <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
        public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
        <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
            xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;</span><br/>&#13;
            <span class="gray">yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;</span><br/>&#13;
            if  <span class="gray">// Add your code here</span><br/>&#13;
        <span class="gray">}</span></p>&#13;
<p class="indent">Make your changes, save and run the file, and voilà—no more stranded bubbles!</p>&#13;
<h4 class="h4"><em><a id="toc_lev188"/>#2: Flexi-Draw!</em></h4>&#13;
<p class="noindent">Because of the random speed values, the bubbles move in every direction, which is the effect we originally wanted. But what if we wanted to draw shapes and have them stay together?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_245"/>Setting the speed of every bubble to the same fixed value creates a funky, flexible, twisty effect as the objects bounce off the edges of the screen, as shown in <a href="ch10.xhtml#ch10fig17">Figure 10-17</a>.</p>&#13;
<div class="image"><img src="../images/f0245-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig17"/>Figure 10-17: Giving all bubbles the same xspeed and yspeed creates a flexible, bouncy effect that keeps shapes together as they rebound and twist off the edges of the screen.</em></p>&#13;
<p class="indent">For this challenge, create a new copy of the app so that the original version is still available. Copy and paste the BubbleDrawGUI project in the Package Explorer pane, renaming it FlexiDraw or another app name of your choice. In the <em>BubblePanel</em> file, change the <span class="literal">Bubble()</span> constructor so that instead of creating random <span class="literal">xspeed</span> and <span class="literal">yspeed</span> variables, it sets them equal to the same value, perhaps like this:</p>&#13;
<p class="pre">          xspeed = yspeed = 2;</p>&#13;
<p class="indent">This line of code makes use of an interesting feature of the assignment operator (<span class="literal">=</span>). This is called a <em>chained assignment</em>, because both <span class="literal">xspeed</span> and <span class="literal">yspeed</span> are being assigned the value of <span class="literal">2</span>, and the equal sign allows us to assign the same value to several variables in a chain sequence.</p>&#13;
<p class="indent">You can pick a higher or lower number for your speed value. The important point to note is that we’ve replaced the random speeds with a fixed starting speed and direction for every bubble. Each bubble will move right two pixels and down two pixels the first time it’s drawn, so the bubbles will form groups as you draw.</p>&#13;
<p class="indent">Save the file, right-click the <em>FlexiDraw</em> folder in the Package Explorer, and select <strong>Run As</strong> <span class="ent">▸</span> <strong>Java Application</strong>. Pause the animation to draw, and then press <strong>Start</strong> to see your shapes bend, twist, and bounce as they move around the screen! You can even draw as the animation runs for a cool spiral effect.</p>&#13;
<h4 class="h4"><em><a id="toc_lev189"/>#3: PixelDraw 2.0</em></h4>&#13;
<p class="noindent">For this challenge, you’ll reuse the PixelDraw code from <a href="ch9.xhtml#ch9">Chapter 9</a> (Programming Challenge #2 on <a href="ch9.xhtml#page_219">page 219</a>). Adding the pixelated effect to the animated drawing program will allow you to draw square pixel shapes and animate them. Combine this effect with the FlexiDraw trick from the previous challenge exercise, and you’ve got a bouncing, bending <em>Minecraft</em>-esque drawing app like the one shown in <a href="ch10.xhtml#ch10fig18">Figure 10-18</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_246"/><img src="../images/f0246-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig18"/>Figure 10-18: The PixelDraw 2.0 effect (left); the same shape after bouncing off the sides and twisting upside down and backward (right)</em></p>&#13;
<p class="indent">Pause the animation to keep the blocks in a clean, gridlike shape like the example in <a href="ch10.xhtml#ch10fig18">Figure 10-18</a>. Draw with the animation going to achieve a stacked, 3D look like the example in <a href="ch10.xhtml#ch10fig19">Figure 10-19</a>.</p>&#13;
<div class="image"><img src="../images/f0246-02.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch10fig19"/>Figure 10-19: The PixelDraw 2.0 code creates a stacked, 3D effect if you drag the mouse while the animation is running.</em></p>&#13;
<p class="indent">Here’s a hint to help with the math: to achieve the blocky style, you need to “divide” the screen into a grid based on the size of each block, and then draw a block at that grid location. This time, try changing your <span class="literal">x</span> and <span class="literal">y</span> variables at the top of the <span class="literal">Bubble()</span> constructor to something like the following:</p>&#13;
<p class="pre">           x = (newX / newSize) * newSize + newSize/2;<br/>&#13;
           y = (newY / newSize) * newSize + newSize/2;</p>&#13;
<p class="indent">The first part of the formula, <span class="literal">(newX / newSize) * newSize</span>, divides the screen into grid blocks based on <span class="literal">newSize</span>, the size of the current bubble. In <span epub:type="pagebreak" id="page_247"/>order to align the x- and y-positions with a <span class="literal">newSize</span> by <span class="literal">newSize</span> grid, we need them to be multiples of <span class="literal">newSize</span>. For the x-coordinate, we do this by dividing <span class="literal">newX</span> by <span class="literal">newSize</span>, which results in an integer without decimal points that we multiply by <span class="literal">newSize</span> to make an integer that is a multiple of <span class="literal">newSize</span>. This places the x-coordinate of the bubble at the edge of the grid block the user clicks in. For example, if <span class="literal">newSize</span> is <span class="literal">10</span>, the division and multiplication “snap” the x-coordinate to <span class="literal">10</span> by <span class="literal">10</span> gridlines by making <span class="literal">x</span> a multiple of <span class="literal">10</span>. If we stopped there, this would result in a bubble with its center at the point where the gridlines meet. Since we want the bubble to be contained within a grid block instead, the second part (<span class="literal">+ newSize/2</span>) shifts the bubble to the center of that block.</p>&#13;
<p class="indent">Finally, draw blocks instead of bubbles by changing the <span class="literal">draw()</span> method to fill rectangles instead of ovals using <span class="literal">fillRect()</span>.</p>&#13;
<p class="indent">That’s it! But you can—and should!—make additional changes to customize the new app even further and make it your own. Change the <span class="literal">JFrame</span> title in the <em>BubbleDrawGUI.java</em> file or even refactor/rename the files if you’d like. The sky’s the limit!</p>&#13;
<p class="indent">After making those changes, you’ll be able to draw beautiful, blocky, pixelized, and animated creations. Take a screenshot and tweet it to your friends. Use the hashtag #JavaTheEasyWay or tag me @brysonpayne, and I’ll retweet it to a few thousand of my friends as well!<span epub:type="pagebreak" id="page_248"/></p>&#13;
</body></html>