- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    FOUNDATIONAL CONCEPTS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">Windows基础概念</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: To understand your adversary, first you must understand the battlefield. In
    our case, the battlefield is the Windows operating system and its underlying components.
    This chapter will provide an overview of the Windows architecture and introduce
    the fundamental concepts you’ll need in order to understand the more advanced
    topics covered in later chapters of this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解你的对手，首先你必须了解战场。在我们的例子中，战场就是Windows操作系统及其底层组件。本章将概述Windows架构，并介绍你理解本书后续章节中更高级主题所需的基本概念。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Windows Architecture Overview</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Windows架构概述</samp>
- en: Windows is a complex operating system (OS) with an equally complex architecture.
    In this section, I’ll introduce some of its key concepts, and as we proceed through
    the chapter, I’ll revisit and elaborate on them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Windows是一个复杂的操作系统（OS），其架构同样复杂。在本节中，我将介绍一些关键概念，随着章节的推进，我将回顾并详细说明这些概念。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">User and Kernel
    Modes</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">用户模式与内核模式</samp>'
- en: 'The Windows architecture consists of two modes: user and kernel, which are
    the fundamental components of the OS. A *mode* is a context in which code runs
    on the system. *User mode* is what most people think of when using a computer;
    it consists of the normal, day-to-day software and processes that the user interacts
    with, such as Microsoft Office programs and web browsers. Conversely, *kernel
    mode* is reserved for the core OS functions: those responsible for important,
    low-level tasks like memory management and hardware interaction.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Windows架构由两种模式组成：用户模式和内核模式，它们是操作系统的基本组成部分。*模式*是代码在系统上运行的上下文。*用户模式*是大多数人在使用计算机时的常见模式；它包括用户与之交互的正常的、日常使用的软件和进程，如Microsoft
    Office程序和网页浏览器。相反，*内核模式*则保留给操作系统的核心功能：负责重要的低级任务，如内存管理和硬件交互。
- en: Code running in user mode can’t access or interfere with code running in kernel
    mode; this is an intentional protection mechanism to prevent misconfigured or
    malicious applications from altering the OS environment. This separation is critical
    because all code and programs that run in kernel mode share the same memory address
    space, meaning that a misbehaving program could cause an unintended crash of the
    entire OS. It also means that if a malicious program were able to execute in kernel
    mode, it could directly affect the OS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在用户模式下的代码无法访问或干扰运行在内核模式下的代码；这是一个有意的保护机制，用来防止配置错误或恶意的应用程序改变操作系统环境。这种分离非常重要，因为所有在内核模式下运行的代码和程序共享同一个内存地址空间，这意味着一个行为不当的程序可能导致整个操作系统的崩溃。它还意味着，如果恶意程序能够在内核模式下执行，它就能直接影响操作系统。
- en: '[Figure 1-1](chapter1.xhtml#fig1-1) shows the relationship between user mode
    and kernel mode.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](chapter1.xhtml#fig1-1)展示了用户模式与内核模式之间的关系。'
- en: '![](../images/fig1-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: The relationship
    between user mode and kernel mode</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：用户模式与内核模式之间的关系</samp>
- en: 'Let’s take a closer look at the concepts illustrated here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下这里展示的概念：
- en: '**Applications**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序**'
- en: These are the software and programs that a user runs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用户运行的软件和程序。
- en: '**Windows application programming interface (WinAPI)**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows应用程序编程接口（WinAPI）**'
- en: This is what applications rely on in order to function. I’ll discuss this further
    in “The Windows API” on [page 6](chapter1.xhtml#pg_6).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序运行所依赖的基础。我将在《Windows API》一节中进一步讨论这个内容，详见[第6页](chapter1.xhtml#pg_6)。
- en: '**Drivers**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**'
- en: These control various devices on the system and provide an abstraction layer
    between the devices and the programs that wish to interact with them. There are
    two kinds of drivers. *Hardware device drivers* take input/output (IO) requests
    and convert them to hardware IO requests, such as for the mouse and keyboard.
    *Nonhardware device drivers* control system components such as network interfaces
    and the filesystem. Some drivers operate in user mode and some in kernel mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制系统上的各种设备，并在设备与希望与之交互的程序之间提供抽象层。有两种类型的驱动程序。*硬件设备驱动程序*处理输入/输出（IO）请求，并将其转换为硬件IO请求，例如鼠标和键盘。*非硬件设备驱动程序*控制系统组件，如网络接口和文件系统。一些驱动程序在用户模式下运行，一些在内核模式下运行。
- en: '**Hardware abstraction layer**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件抽象层**'
- en: This provides an interface that device drivers can use to communicate with the
    underlying system hardware. It enables the kernel and higher-level applications
    to operate independently of the system hardware.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个接口，设备驱动程序可以用来与底层系统硬件通信。它使内核和高级应用程序能够独立于系统硬件运行。
- en: 'The Windows kernel itself is contained in an executable file called *ntoskrnl.exe*,
    and it’s split into two parts: the kernel and the executive layer. The *kernel*
    is responsible for fundamental functionality like task synchronization and scheduling;
    it also provides low-level hardware support, which is essential for the system
    to run efficiently. The *executive layer* contains critical system services such
    as the *Memory Manager*, which implements virtual memory functionalities (see
    “Virtual Memory” on [page 11](chapter1.xhtml#pg_11)), and the *Process Manager*,
    which handles the creation and termination of processes and threads.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 内核本身包含在一个名为*ntoskrnl.exe*的可执行文件中，并分为两部分：内核和执行层。*内核*负责基本功能，如任务同步和调度；它还提供低级硬件支持，这对于系统高效运行至关重要。*执行层*包含关键的系统服务，如*内存管理器*，它实现虚拟内存功能（见“虚拟内存”在[第11页](chapter1.xhtml#pg_11)），以及*进程管理器*，它处理进程和线程的创建和终止。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Processes and Threads</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程与线程</samp>
- en: When an application such as *Excel.exe* or *Calculator.exe* is executed, the
    Windows Portable Executable loader creates a *process* for that program; the process
    contains the original program executable and all supporting libraries and code.
    Each process is assigned its own virtual address space in memory, which is private
    and isolated to that process. This means that if a process crashes, it does not
    (or should not) affect other processes or the OS itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序如*Excel.exe*或*Calculator.exe*被执行时，Windows 可执行文件加载器为该程序创建一个*进程*；该进程包含原始的程序可执行文件以及所有支持库和代码。每个进程在内存中分配有自己的虚拟地址空间，这个空间是私有的，并且对该进程是隔离的。这意味着，如果一个进程崩溃，它不会（或者不应该）影响其他进程或操作系统本身。
- en: Each running process in Windows can host one or more threads. A *thread* is
    simply a series of instructions. The processor can run only one thread at any
    given time, however. This means that if Process B wishes to execute some code,
    it must wait for Process A’s current thread to complete. If Windows deems Process
    B to be more important, it can issue an interrupt to Process A’s current thread
    and execute Process B’s thread instead. (This is called a *context switch.*) Windows
    executes context switching so quickly and efficiently that the end user isn’t
    even aware that it’s constantly happening.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中的每个运行进程都可以托管一个或多个线程。*线程*仅仅是一系列指令。然而，处理器在任何给定时刻只能运行一个线程。这意味着，如果进程 B
    希望执行某些代码，它必须等待进程 A 当前的线程完成。如果 Windows 认为进程 B 更重要，它可以向进程 A 当前的线程发出中断，并改为执行进程 B
    的线程。（这称为*上下文切换*。）Windows 执行上下文切换非常迅速高效，以至于最终用户甚至没有察觉到它在不断发生。
- en: Windows is a multitasking OS. This means that as the processor executes instructions
    to run the system and its applications, it efficiently switches between executing
    code in user mode and in kernel mode. To do this, Windows uses *time slices*,
    which are atomic segments of time (measured in milliseconds) that are assigned
    to each thread. A thread is allowed to execute its code, but after its time slice
    expires, other threads are allowed to run. Because time slices are so small, the
    system appears to be executing multiple threads and operating multiple programs
    at the same time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 是一个多任务操作系统。这意味着，当处理器执行指令来运行系统及其应用程序时，它会高效地在用户模式和内核模式之间切换。为此，Windows
    使用*时间片*，这是一种原子性的时间段（以毫秒为单位），分配给每个线程。线程被允许执行其代码，但当时间片到期后，其他线程也能运行。由于时间片非常短，因此系统看起来像是在同时执行多个线程和多个程序。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Objects and
    Handles</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">对象与句柄</samp>'
- en: Processes and threads often interact with *objects*, which are instances of
    a certain type of resource, such as a file, another process or thread, a security
    token (for user access rights), or even a section of memory. The centralized *object
    manager* is responsible for tracking all Windows objects, sharing them among processes,
    and protecting them from unauthorized access.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程通常与*对象*进行交互，对象是某种类型资源的实例，例如文件、另一个进程或线程、安全令牌（用于用户访问权限），甚至是内存的一部分。集中管理*对象管理器*负责跟踪所有
    Windows 对象、在进程间共享它们，并保护它们免受未经授权的访问。
- en: All objects in Windows are simply data structures, typically stored in kernel
    memory. Since most applications on Windows run in user space, a process uses a
    unique identifier known as a *handle* to access an object. Each process may have
    multiple handles for various objects. Handles are managed in a process’s *handle
    table*, which contains pointers to the objects in kernel memory, as illustrated
    in [Figure 1-2](chapter1.xhtml#fig1-2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中的所有对象都是简单的数据结构，通常存储在内核内存中。由于大多数 Windows 应用程序在用户空间中运行，进程使用一个被称为*句柄*的唯一标识符来访问对象。每个进程可能有多个句柄，用于访问各种对象。句柄在进程的*句柄表*中进行管理，该表包含指向内核内存中对象的指针，如[图
    1-2](chapter1.xhtml#fig1-2)所示。
- en: '![](../images/fig1-2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A Windows process
    handle table and object structure</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-2: Windows 进程句柄表和对象结构</samp>'
- en: '*Mutual exclusions*, or *mutexes*, are a method of controlling access to objects
    to prevent potential issues like Process A and Process B both attempting to access
    and modify a file at exactly the same time, which is known as a *race condition*.
    Depending on how Windows uses this specific file, this situation could potentially
    cause data inconsistencies, or worse, crash a process or the OS. To avoid unwanted
    events such as a race condition, Process A may create a mutex object for that
    file, locking the file for its own use and preventing Process B from being able
    to access or write to the file until it is unlocked.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*互斥锁*（或*mutex*）是一种控制访问对象的方法，旨在防止像进程 A 和进程 B 尝试同时访问并修改文件的潜在问题，这种情况被称为*竞态条件*。根据
    Windows 如何使用该文件，这种情况可能导致数据不一致，甚至更糟，崩溃进程或操作系统。为了避免像竞态条件这样的意外事件，进程 A 可能会为该文件创建一个互斥对象，锁定文件以供其自身使用，并防止进程
    B 在文件解锁之前访问或写入该文件。'
- en: The program’s interaction with these objects, and with the OS itself, is managed
    by the Windows API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 程序与这些对象以及操作系统本身的交互由 Windows API 管理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Windows API</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows API</samp>
- en: The *Windows application programming interface (WinAPI)* is a shared library
    of code that is exposed to user-mode applications. When a Windows program runs,
    WinAPI invokes Windows functions that enable the program to operate as designed
    within the Windows OS.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Windows 应用程序编程接口（WinAPI）*是一个共享的代码库，向用户模式的应用程序公开。当 Windows 程序运行时，WinAPI 调用
    Windows 函数，使程序能够在 Windows 操作系统中按设计方式运行。'
- en: 'WinAPI covers nearly all the functionality that a developer could want to implement
    in their code: everything from user interface and networking capabilities to input
    devices (mouse, keyboard, and so on) to memory management. For example, if a developer
    wants to create a new window for their application, they might call the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> function. If a program
    needs access to a hard disk, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp>
    to retrieve a list of the available hard disks.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: WinAPI 涵盖了开发人员可能希望在代码中实现的几乎所有功能：从用户界面、网络功能到输入设备（鼠标、键盘等）、再到内存管理。例如，如果开发人员想为他们的应用程序创建一个新窗口，他们可能会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> 函数。如果程序需要访问硬盘，它可能会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp> 来检索可用硬盘的列表。
- en: There’s also a lower-level API called the *Windows Native API*, or simply *Native
    API*. While WinAPI is well documented and designed to be used by developers, the
    Native API is largely undocumented, at least by Microsoft.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更低级别的 API，叫做 *Windows 本地 API*，或简称 *本地 API*。虽然 WinAPI 有很好的文档并设计为开发人员使用，但本地
    API 大部分没有文档，至少在微软的官方文档中没有。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Thankfully, the reverse engineering community has gone to great lengths to
    document the Native API internals. Two great examples are the “ntinternals” project
    (*[http://undocumented.ntinternals.net](http://undocumented.ntinternals.net)*)*
    *and Geoff Chappell’s research (*[https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm](https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm)*)*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*幸运的是，逆向工程社区已经付出了巨大努力来记录本地 API 的内部实现。两个很好的例子是“ntinternals”项目（*[http://undocumented.ntinternals.net](http://undocumented.ntinternals.net)）*
    和 Geoff Chappell 的研究（*[https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm](https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm)）*。'
- en: 'The Native API is designed to be internal to the OS, but programs can call
    Native API functions directly if they so choose. In turn, Native API functions
    call into even lower-level kernel API code residing in *ntoskrnl.exe*. A call
    into the kernel is known as a *syscall* or *sysenter*. (There are minor technical
    differences between syscall and sysenter, but they both have the same objective:
    allowing user applications access to kernel services. For simplicity’s sake, I’ll
    use the term *syscall* in this book.)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 API 设计为操作系统内部使用，但程序可以直接调用本地 API 函数，前提是它们愿意这样做。反过来，本地 API 函数会调用更底层的内核 API
    代码，这些代码存在于 *ntoskrnl.exe* 中。对内核的调用被称为 *syscall* 或 *sysenter*。（syscall 和 sysenter
    之间有一些小的技术差异，但它们的目标是一样的：允许用户应用程序访问内核服务。为了简化起见，本书中我将使用 *syscall* 这个术语。）
- en: '[Figure 1-3](chapter1.xhtml#fig1-3) illustrates the interaction between WinAPI
    and the Native API.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-3](chapter1.xhtml#fig1-3) 演示了 WinAPI 与本地 API 之间的交互。'
- en: '![](../images/fig1-3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: User-mode APIs
    calling into lower-level APIs</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-3：用户模式 API 调用更低层次的 API</samp>
- en: At the top, you can see a program calling the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    which in turn calls WinAPI’s <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    function (not shown in this diagram). This is followed by a call to the Native
    API’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function. Finally, the program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function inside *ntoskrnl.exe*. This complex chain of API calls is very common
    in Windows and allows for code to be developed without the developer needing to
    understand all of the internals of Windows and the lower-level APIs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，你可以看到一个程序调用 WinAPI 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>，然后它又调用了
    WinAPI 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> 函数（该函数在此图中未显示）。接着是调用本地
    API 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    函数。最后，程序调用了 *ntoskrnl.exe* 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    函数。这一复杂的 API 调用链在 Windows 中非常常见，它允许开发人员在无需了解 Windows 和低级 API 内部实现的情况下进行代码开发。
- en: As you may have noticed, WinAPI functions often have one or more suffixes, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>. Generally speaking,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> suffix is Microsoft’s
    way of designating a newer, extended (with more features) version of an older
    function. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>
    function is the newer, extended version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix indicates
    that the function uses ANSI format inputs and outputs, while functions with a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> suffix use Unicode inputs
    and outputs. The usage of ANSI versus Unicode doesn’t matter that often, so I
    won’t be covering that topic further and I generally won’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> in the function name.
    (For example, I’ll refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>
    function as simply <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindow</samp>.)
    For <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> functions, however,
    I’ll always include the suffix.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，WinAPI函数通常有一个或多个后缀，如<samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">A</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>。一般来说，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp>后缀是微软用来标识较旧函数的更新版（功能更多的扩展版本）。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>函数是<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>的扩展版本。</sup>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>后缀表示该函数使用ANSI格式的输入和输出，而带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">W</samp>后缀的函数则使用Unicode格式的输入和输出。关于ANSI与Unicode的使用差异其实不那么常见，因此我不会进一步讨论这个话题，而且通常不会在函数名称中包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">A</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>后缀。（例如，我将直接称<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>为<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindow</samp>。）但是，对于带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp>后缀的函数，我会始终保留该后缀。
- en: Windows Native API functions typically have the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>; examples include <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwNotifyChangeKey</samp>.
    Each function in the API typically has both an <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> version. <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    functions are most often used by drivers and other lower-level system software
    but are largely interchangeable with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Windows本地API函数通常以<samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>为前缀；例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcess</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ZwNotifyChangeKey</samp>。每个API函数通常都有一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>版本和一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>版本。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>函数通常由驱动程序和其他低级系统软件使用，但与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>函数在很大程度上是可以互换的。
- en: 'You may also have noticed the filenames *kernel32.dll* and *ntdll.dll* in [Figure
    1-3](chapter1.xhtml#fig1-3). These refer to *dynamic link libraries (DLLs)*, a
    collection of resources that developers can import into their program to make
    use of existing code from Microsoft or third-party developers. While Windows programs
    can import these libraries, DLL files themselves export functions to the program
    that imported them. For example, if a developer wishes to access a hard disk on
    the Windows system, they can import the *kernel32.dll* library, which exports
    (provides) the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp>
    function they need. Some of the DLLs used often in Windows programs are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到在[图1-3](chapter1.xhtml#fig1-3)中提到的文件名*kernel32.dll*和*ntdll.dll*。它们指的是*动态链接库（DLLs）*，这些库是开发者可以导入到他们的程序中的资源集合，用来利用微软或第三方开发者现有的代码。虽然Windows程序可以导入这些库，但DLL文件本身会向导入它们的程序导出函数。例如，如果开发者希望访问Windows系统上的硬盘，他们可以导入*kernel32.dll*库，该库导出（提供）他们所需要的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp>函数。在Windows程序中经常使用的一些DLL文件如下：
- en: '***kernel32.dll ***This is one of the primary DLLs required for Windows programs
    to run, and it contains many of the fundamental user-mode functions.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***kernel32.dll ***这是Windows程序运行所需的主要DLL之一，它包含许多基本的用户模式函数。'
- en: '***user32.dll ***This DLL provides the graphical user interface (GUI) functions
    required for Windows programs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***user32.dll ***该DLL提供Windows程序所需的图形用户界面（GUI）功能。'
- en: '***Winhttp.dll ***Also known as the “Windows HTTP Interface,” this DLL provides
    internet connection functionalities to Windows programs.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***Winhttp.dll ***也称为“Windows HTTP接口”，该DLL为Windows程序提供互联网连接功能。'
- en: '***ntdll.dll ***This critical DLL contains functions for synchronization, threading,
    and other system tasks; it also communicates with the kernel.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***ntdll.dll ***该关键DLL包含用于同步、线程处理和其他系统任务的函数；它还与内核进行通信。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*If you’re analyzing code with functions exported from* kernel32.dll *(as many
    functions are), you might notice that when a process executes a* kernel32.dll
    *function, there’s an immediate jump to another DLL,* kernelbase.dll*. Introduced
    in Windows 7,* kernelbase.dll *allows for backward compatibility between older
    and newer Windows versions. Most* kernel32.dll *function calls simply jump to*
    kernelbase.dll*, which contains the function’s actual code. For example, the function
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WriteFile</samp> (exported
    from* kernel32.dll*), once invoked, will immediately jump to* kernelbase.dll*,
    where its code actually resides. For simplicity’s sake, I’ll use* kernel32.dll
    *and* kernelbase.dll *synonymously throughout this book.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你正在分析包含从*kernel32.dll*导出的函数的代码（就像许多函数一样），你可能会注意到，当一个进程执行一个*kernel32.dll*函数时，会立即跳转到另一个DLL，*kernelbase.dll*。*kernelbase.dll*是在Windows
    7中引入的，它允许在旧版和新版Windows之间保持向后兼容性。大多数*kernel32.dll*函数调用会直接跳转到*kernelbase.dll*，它包含函数的实际代码。例如，函数<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WriteFile</samp>（从*kernel32.dll*导出）一旦调用，就会立即跳转到*kernelbase.dll*，在那里执行代码。为了简化起见，我将在本书中将*kernel32.dll*和*kernelbase.dll*作为同义词使用。*'
- en: While legitimate Windows programs heavily rely on the underlying WinAPI and
    Native API to function, illegitimate software (that is, malware) also uses these
    functionalities, as you’ll see in later chapters. For now, let’s take an in-depth
    look at processes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管合法的Windows程序在很大程度上依赖底层的WinAPI和Native API来执行，但非法软件（即恶意软件）也利用这些功能，正如你将在后续章节中看到的那样。现在，让我们深入了解进程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Internals</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程内部</samp>
- en: Processes are quite complex data structures that point to additional data structures.
    This network provides the underlying information that Windows relies on to efficiently
    manage and coordinate the many processes running on a system at any point in time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是相当复杂的数据结构，它们指向其他数据结构。这个网络提供了Windows所依赖的基础信息，用于有效管理和协调系统上随时运行的众多进程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">EPROCESS Structures</samp>
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">EPROCESS结构</samp>
- en: Even though most processes exposed to the end user run in user mode, they’re
    represented in kernel address space as objects called *EPROCESS* structures. Each
    process has its own EPROCESS structure that contains pointers to elements like
    the list of handles the process has open, as well as its *Process Environment
    Block (PEB)*, which is a structure that contains vital information about the process.
    EPROCESS structures consist of a doubly linked list; that is, they form a chain
    in which each structure links to the previous and subsequent structures. EPROCESS
    structure members called *forward links (flinks)* are pointers to the next EPROCESS
    structure in the chain, while *backward links (blinks)* point to the previous
    one. [Figure 1-4](chapter1.xhtml#fig1-4) illustrates a simplified version of this
    chain.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数暴露给终端用户的进程是在用户模式下运行的，但它们在内核地址空间中作为称为*EPROCESS*结构的对象表示。每个进程都有自己的EPROCESS结构，包含指向诸如进程打开的句柄列表以及*进程环境块（PEB）*的指针，PEB是一个包含进程关键信息的结构。EPROCESS结构由一个双向链表组成；也就是说，它们形成一个链，每个结构都链接到前一个和下一个结构。EPROCESS结构成员称为*前向链接（flinks）*是指向链中下一个EPROCESS结构的指针，而*后向链接（blinks）*指向前一个结构。[图1-4](chapter1.xhtml#fig1-4)展示了这个链的简化版本。
- en: '![](../images/fig1-4.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: An EPROCESS structure’s
    doubly linked list chain</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-4：一个EPROCESS结构的双向链表链</samp>
- en: The EPROCESS structure contains many other data elements and pointers that are
    mostly outside the scope of this book. The key takeaway here is that each user-mode
    process in Windows is linked to an EPROCESS structure running in kernel mode.
    This will be important later on, when we discuss topics like direct kernel object
    manipulation (DKOM) in [Part IV](part4.xhtml).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: EPROCESS 结构包含许多其他数据元素和指针，大多数超出了本书的讨论范围。这里的关键要点是，每个 Windows 中的用户模式进程都与一个在内核模式下运行的
    EPROCESS 结构相关联。稍后我们在讨论诸如直接内核对象操作（DKOM）等主题时，这一点将变得非常重要，参见[第 IV 部分](part4.xhtml)。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Environment
    Blocks</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程环境块</samp>'
- en: The PEB memory structure contains information about a running process that the
    kernel needs to communicate with that process, as well as information for interprocess
    communication. Each running process has its own PEB that’s stored in user-mode
    address space inside that process memory. [Table 1-1](chapter1.xhtml#tab1-1) lists
    some of the important data the PEB structure contains. The offset of each structure
    member is shown for both x86 and x64 architectures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: PEB 内存结构包含有关正在运行的进程的信息，操作系统内核需要通过这些信息与该进程进行通信，还包括用于进程间通信的信息。每个正在运行的进程都有自己的 PEB，存储在该进程的用户模式地址空间中。[表
    1-1](chapter1.xhtml#tab1-1)列出了 PEB 结构中包含的一些重要数据。每个结构成员的偏移量在 x86 和 x64 架构中都有显示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">PEB
    Structure Offsets and Data</samp>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-1：</samp> <samp class="SANS_Futura_Std_Book_11">PEB
    结构偏移量和数据</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Offset
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Data</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">偏移量 (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">偏移量
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">数据</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_Futura_Std_Book_11">0x002</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    <samp class="SANS_Futura_Std_Book_11">value, which indicates whether the process
    is running under the context of a debugger. (This will be important in [Chapter
    10](chapter10.xhtml).)</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_Futura_Std_Book_11">0x002</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    <samp class="SANS_Futura_Std_Book_11">值，表示进程是否在调试器的上下文中运行。（这在[第 10 章](chapter10.xhtml)中会很重要。）</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x008</samp> | <samp class="SANS_Futura_Std_Book_11">0x10</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the base address of the process
    executable in memory.</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x008</samp> | <samp class="SANS_Futura_Std_Book_11">0x10</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储进程可执行文件在内存中的基本地址。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x00C</samp> | <samp class="SANS_Futura_Std_Book_11">0x18</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores information on the modules and
    libraries the process has loaded.</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x00C</samp> | <samp class="SANS_Futura_Std_Book_11">0x18</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储进程加载的模块和库的信息。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_Futura_Std_Book_11">0x30</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores information about the process’s
    memory heap.</samp> |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_Futura_Std_Book_11">0x30</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储有关进程内存堆的信息。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x064</samp> | <samp class="SANS_Futura_Std_Book_11">0xB8</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NumberOfProcessors</samp>
    <samp class="SANS_Futura_Std_Book_11">value, which indicates the number of processors
    the system has.</samp> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x064</samp> | <samp class="SANS_Futura_Std_Book_11">0xB8</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NumberOfProcessors</samp>
    <samp class="SANS_Futura_Std_Book_11">值，表示系统中的处理器数量。</samp> |'
- en: You don’t need to memorize all the elements of a PEB, but it’s important to
    have a basic understanding of it because I’ll be referencing it throughout the
    book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住 PEB 的所有元素，但了解其基本结构非常重要，因为我将在全书中引用它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Environment
    Blocks</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">线程环境块</samp>
- en: A *Thread Environment Block (TEB)*, sometimes referred to as the *Thread Information
    Block (TIB)*, contains information for a process’s running threads. Much like
    the PEB, it’s simply a data structure that stores critical information for each
    thread and is stored in the memory address space of the process that owns the
    thread. [Table 1-2](chapter1.xhtml#tab1-2) lists some of the most interesting
    elements in the TEB.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*线程环境块（TEB）*，有时也被称为*线程信息块（TIB）*，包含进程运行线程的信息。就像PEB一样，它只是一个数据结构，用于存储每个线程的关键信息，并存储在拥有线程的进程的内存地址空间中。[表
    1-2](chapter1.xhtml#tab1-2)列出了TEB中一些最有趣的元素。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">TEB
    Structure Offsets and Data</samp>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-2：</samp> <samp class="SANS_Futura_Std_Book_11">TEB结构偏移量和数据</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Offset
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Data</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">偏移量（x86）</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">偏移量（x64）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">数据</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x00]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x00]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the current structured exception
    handler (SEH) frame. (SEH will be covered in more detail in [Chapters 10](chapter10.xhtml)
    and [11](chapter11.xhtml).)</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x00]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x00]</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储当前的结构化异常处理程序（SEH）框架。（SEH将在[第10章](chapter10.xhtml)和[第11章](chapter11.xhtml)中详细介绍。）</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x04]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x08]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the base of the thread’s stack
    (see the next section).</samp> |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x04]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x08]</samp>
    | <samp class="SANS_Futura_Std_Book_11">指向线程堆栈的基础（见下节）。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x18]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x30]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the TEB itself.</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x18]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x30]</samp>
    | <samp class="SANS_Futura_Std_Book_11">指向TEB本身。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x20]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x40]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process
    ID (PID)</samp> <samp class="SANS_Futura_Std_Book_11">of the thread’s owning process.</samp>
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x20]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x40]</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">进程ID（PID）</samp>
    <samp class="SANS_Futura_Std_Book_11">线程所属进程的ID。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x24]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x48]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">thread
    ID (TID)</samp> <samp class="SANS_Futura_Std_Book_11">of the current thread.</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x24]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x48]</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">线程ID（TID）</samp>
    <samp class="SANS_Futura_Std_Book_11">当前线程的ID。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x30]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x60]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the PEB of the thread’s owning
    process.</samp> |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x30]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x60]</samp>
    | <samp class="SANS_Futura_Std_Book_11">指向线程所属进程的PEB。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0xE10]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x1480]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to thread-local storage (TLS) information.</samp>
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">FS:[0xE10]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x1480]</samp>
    | <samp class="SANS_Futura_Std_Book_11">指向线程本地存储（TLS）信息。</samp> |'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: Thread-local storage (TLS) *is used to store variables and other information
    across different threads. We’ll talk about how malware can abuse TLS to stealthily
    execute malicious code in [Chapter 11](chapter11.xhtml).*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本地存储（TLS）*用于存储跨线程的变量和其他信息。我们将在[第11章](chapter11.xhtml)中讨论恶意软件如何滥用TLS来悄悄执行恶意代码。*
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Stacks and Heaps</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">堆栈和堆</samp>
- en: A process can have multiple active threads, each of which has its own memory
    stack. The *stack* is where the thread stores temporary data such as variables,
    pointers, and other objects that will inevitably be destroyed once the thread
    completes execution and is terminated. Since the stack is so volatile and temporary,
    programs sometimes need a more “permanent” solution for data storage. This is
    where heaps come in.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以有多个活动线程，每个线程都有自己的内存栈。*栈*是线程存储临时数据的地方，比如变量、指针和其他在线程执行完毕并终止后会被销毁的对象。由于栈是如此易变且临时，程序有时需要一种更“永久”的数据存储解决方案。这时堆就派上了用场。
- en: A *heap* is a variably sized region of memory that a program dynamically allocates
    at runtime. Heaps are often used to store objects and data structures that are
    too large for the stack. They’re also used to store global variables and data
    that persist and can be used by multiple functions in the same program. It’s important
    to note that while the stack is largely managed by the OS, heaps are managed by
    the program itself. If a program doesn’t implement heap memory management techniques
    well, it can cause stability issues.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆*是一个在程序运行时动态分配的、大小可变的内存区域。堆通常用于存储堆栈无法容纳的较大的对象和数据结构。它们还用于存储全局变量和可以被同一程序中多个函数使用的持久数据。需要注意的是，尽管栈大多由操作系统管理，但堆是由程序本身管理的。如果程序没有很好地实现堆内存管理技术，可能会导致稳定性问题。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Virtual Memory</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">虚拟内存</samp>
- en: Each process running in Windows has a number of virtual memory regions assigned
    to it that are mapped to physical memory (or RAM). It’s important to understand
    the distinction between virtual and physical memory. *Physical memory* is the
    real, tangible hardware memory that is installed in your system. If you have a
    computer with 8GB of RAM, then you have 8GB of physical memory that all processes
    running on your system share. This poses a problem in that any process can interfere
    with any other process on the system (either inadvertently, such as in the case
    of a crash, or purposefully), with unwanted side effects. This is where virtual
    memory comes in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，每个运行中的进程都有分配的多个虚拟内存区域，这些区域映射到物理内存（或RAM）。理解虚拟内存和物理内存之间的区别是很重要的。*物理内存*是安装在系统中的实际、可触摸的硬件内存。如果你有一台8GB
    RAM的计算机，那么你就有8GB的物理内存，所有在系统中运行的进程都会共享这部分内存。这就带来了一个问题，任何进程都可能干扰到系统中的其他进程（无论是意外的，例如崩溃，还是故意的），从而产生不必要的副作用。这时虚拟内存就发挥了作用。
- en: '*Virtual memory* is a sort of barrier between physical memory and process memory
    address space. When a process is started, it’s assigned an allotment of virtual
    memory that is mapped to physical memory via the *page table*. The page table
    keeps track of where different segments of virtual memory are physically located
    in RAM. [Figure 1-5](chapter1.xhtml#fig1-5) illustrates the relationship between
    virtual memory, the page table, and physical memory.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟内存*是物理内存和进程内存地址空间之间的一种屏障。当一个进程启动时，它会分配一块虚拟内存，这块虚拟内存通过*页表*映射到物理内存。页表跟踪虚拟内存的不同段在RAM中的物理位置。[图1-5](chapter1.xhtml#fig1-5)展示了虚拟内存、页表和物理内存之间的关系。'
- en: '![](../images/fig1-5.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: Virtual memory
    mapped to physical memory via the page table</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-5：通过页表将虚拟内存映射到物理内存</samp>
- en: Each block containing an ellipsis (...) represents a memory address range, or
    region. Each region of memory is mapped to the page table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包含省略号（...）的块表示一个内存地址范围或区域。每个内存区域都映射到页表。
- en: It’s quite possible for a system to have less RAM than what is required by all
    its running processes. To help manage this, virtual memory can be *paged out*,
    meaning that it will be temporarily stored on the hard disk when unused. If a
    process requires access to that virtual memory region again, the memory can be
    read from disk and remapped to physical memory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的RAM可能不足以满足所有正在运行进程的需求。为了帮助管理这种情况，虚拟内存可以被*分页*，即当不使用时，它将暂时存储在硬盘上。如果某个进程需要再次访问该虚拟内存区域，该内存可以从磁盘读取并重新映射到物理内存。
- en: You can view the virtual memory of a process using a process analysis tool such
    as Process Hacker ([*https://<wbr>processhacker<wbr>.sourceforge<wbr>.io*](https://processhacker.sourceforge.io)).
    To do this, start a program (such as *Calculator.exe*), open Process Hacker, and
    double-click the process you wish to explore. [Figure 1-6](chapter1.xhtml#fig1-6)
    shows the Memory tab of a process in Process Hacker.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用进程分析工具（如Process Hacker）查看进程的虚拟内存（[https://<wbr>processhacker<wbr>.sourceforge<wbr>.io](https://processhacker.sourceforge.io)）。操作步骤是启动一个程序（如*Calculator.exe*），打开Process
    Hacker，并双击你想要探索的进程。[图1-6](chapter1.xhtml#fig1-6)显示了Process Hacker中一个进程的内存选项卡。
- en: '![](../images/fig1-6.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: Viewing the virtual
    memory of a process in Process Hacker</samp>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-6：在Process Hacker中查看进程的虚拟内存</samp>
- en: The Base address column contains the base memory address of each virtual memory
    region assigned to *Calculator.exe*. The Type column contains the memory type
    for each region, the Size column gives the allocation size of each region, and
    the Protection column lists the protection status of the region.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基地址列包含分配给*Calculator.exe*的每个虚拟内存区域的基内存地址。类型列包含每个区域的内存类型，大小列显示每个区域的分配大小，保护列列出了该区域的保护状态。
- en: 'Each virtual memory region is typically assigned one of three common memory
    types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟内存区域通常会分配三种常见内存类型之一：
- en: '*Image (IMG)* memory usually contains executable files or libraries that have
    been mapped into memory via the standard Windows loader mechanism (described shortly).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映像（IMG）*内存通常包含通过标准Windows加载器机制（稍后会描述）映射到内存中的可执行文件或库。'
- en: '*Mapped (MAP)* memory often contains either files that have been mapped into
    memory from the disk or other data used by the application running inside the
    process.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射（MAP）*内存通常包含从磁盘映射到内存的文件或应用程序运行过程中使用的其他数据。'
- en: '*Private (PRV)* memory is typically allocated via <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and similar memory allocation functions.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有（PRV）*内存通常通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    和类似的内存分配函数分配。'
- en: Furthermore, each memory region can be either committed or reserved. *Committed*
    regions are being actively used and have been mapped to physical memory. *Reserved*
    regions are reserved for the process but aren’t in active use and haven’t yet
    been mapped to RAM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个内存区域可以是已提交的或已保留的。*已提交*的区域正在被积极使用，并已映射到物理内存中。*已保留*的区域已为进程保留，但尚未在活动中使用，也尚未映射到RAM中。
- en: Now let’s dig into the details of how Windows executables (more specifically,
    Portable Executable files) work internally.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探讨Windows可执行文件（更具体地说，便携式可执行文件）的内部工作原理。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The PE File Format</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">PE文件格式</samp>
- en: Microsoft created the *PE (Portable Executable)* file format for executable
    files that run inside the Windows OS. The PE file format contains everything the
    Windows PE loader needs to execute the embedded code. Understanding the PE format
    is critical to understanding how malware works, so in this section we’ll look
    in depth at the structures the PE format comprises.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为在Windows操作系统中运行的可执行文件创建了*PE（便携式可执行文件）*格式。PE文件格式包含了Windows PE加载器执行嵌入代码所需的所有内容。了解PE格式对于理解恶意软件的工作原理至关重要，因此在这一部分我们将深入探讨PE格式包含的结构。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I’ll refer to both x86 and x64 PE files as PE files. In reality, however,
    x64 has its own version of the PE format called* PE32+*. Since PE32+ differs only
    slightly from its x86 equivalent, I won’t cover it separately.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*我将同时称x86和x64的PE文件为PE文件。然而，实际上x64有一个自己的PE格式版本，称为*PE32+*。由于PE32+与x86版本只有少许差异，我将不单独讨论它。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Headers and Sections</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">头部和节区</samp>
- en: 'The PE file format contains several *headers*: metadata or other information
    at the top of a file, telling the OS and other software what to do with its contents.
    The *DOS header* contains information required by MS-DOS and very early versions
    of Windows, and it mostly exists for legacy reasons. The *PE header* contains
    information used by the Windows PE loader, such as the CPU architecture the executable
    was compiled to run on and metadata like the file’s compilation timestamp. The
    PE header also includes the *optional header*, which indicates important information
    such as the PE’s base memory address (the memory address at which the PE will
    be mapped into memory), the size of the code inside the executable, and the target
    OS that the executable will run on. The “optional” header is in fact no longer
    optional in modern Windows systems.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PE 文件格式包含多个 *头部*：文件顶部的元数据或其他信息，告诉操作系统和其他软件如何处理文件内容。*DOS 头部*包含 MS-DOS 和早期版本 Windows
    所需的信息，主要是为了兼容性存在。*PE 头部*包含 Windows PE 加载器使用的信息，如可执行文件编译时的 CPU 架构和编译时间戳等元数据。PE
    头部还包括 *可选头部*，它指示重要信息，如 PE 的基址（即 PE 映射到内存时的内存地址）、可执行文件内部代码的大小，以及可执行文件将运行的目标操作系统。事实上，现代
    Windows 系统中“可选”头部不再是可选的。
- en: 'The PE file also includes the *section header*, which contains metadata related
    to each of the file’s sections (where the actual file contents are stored), such
    as the section’s size, address, and other characteristics. Finally, most PE files
    contain at least a few of the following sections:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: PE 文件还包含 *区段头部*，它包含与文件各个区段（即实际文件内容存储位置）相关的元数据，如区段的大小、地址和其他特征。最后，大多数 PE 文件至少包含以下几个区段：
- en: '| ***.text*** | The file’s main executable code |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ***.text*** | 文件的主要可执行代码 |'
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ***.rdata*** | Read-only data, such as static variables and constants |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| ***.rdata*** | 只读数据，如静态变量和常量 |'
- en: '| ***.bss*** | Uninitialized data, such as variables that haven’t been assigned
    a value yet |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| ***.bss*** | 未初始化的数据，如尚未赋值的变量 |'
- en: '| ***.data*** | Variables not embedded in the .*rdata* and *.bss* sections,
    such as global variables |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| ***.data*** | 未嵌入在 .*rdata* 和 *.bss* 区段中的变量，如全局变量 |'
- en: '| ***.rsrc*** | Assets that will be loaded by the executable at runtime, such
    as images, fonts, and other supporting files |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| ***.rsrc*** | 可执行文件在运行时将加载的资源，如图像、字体和其他支持文件 |'
- en: '| ***.idata*** | The imports address table (see the next section) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| ***.idata*** | 导入地址表（参见下一节） |'
- en: '| ***.edata*** | The exports address table (see the next section) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| ***.edata*** | 导出地址表（参见下一节） |'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Imports and Exports</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">导入与导出</samp>
- en: The *.idata* and *.edata* sections are two of the most important components
    of a PE file. The *.idata* section contains information about the functions that
    the PE file will import at runtime. Once the PE file is executed, the program
    will load the libraries and functions referenced here into memory and build its
    *import address table (IAT)*, which maps the imported Windows API functions to
    their addresses in memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*.idata* 和 *.edata* 区段是 PE 文件中最重要的两个组件之一。*.idata* 区段包含 PE 文件在运行时导入的函数信息。一旦
    PE 文件被执行，程序将加载此处引用的库和函数到内存，并构建其 *导入地址表（IAT）*，该表将导入的 Windows API 函数映射到它们在内存中的地址。'
- en: The *.edata* section contains information about the functions that the PE file
    exports to other programs, which they can then import and load into memory for
    their own use. It’s common for DLL executable files, for example, to contain a
    list of exported functions. As with imports, exports have their own table called
    the *export address table*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*.edata* 区段包含有关 PE 文件导出到其他程序的函数的信息，其他程序可以将这些函数导入并加载到内存中供自己使用。例如，DLL 可执行文件通常包含一个导出函数的列表。与导入类似，导出也有自己的表格，称为
    *导出地址表*。'
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In practice, however, both the* .edata *and* .idata *sections are often contained
    in the* .rdata *section.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，实际上，* .edata *和* .idata *区段通常包含在* .rdata *区段中。*'
- en: Now let’s take a look at the way Windows loads PE files into memory. The program
    execution process is a fundamental concept for Windows malware analysis and will
    tie together all of the concepts you’ve seen so far.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看 Windows 如何将 PE 文件加载到内存中的方式。程序执行过程是 Windows 恶意软件分析中的一个基本概念，它将把你目前所看到的所有概念联系在一起。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows PE Loading Process</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Windows PE加载过程</samp>
- en: 'When you launch an executable file like Firefox in Windows, here’s what happens:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Windows中启动一个可执行文件，比如Firefox，发生的情况如下：
- en: 1.  Windows creates a new EPROCESS data structure for the Firefox program and
    assigns a new process ID.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  Windows为Firefox程序创建一个新的EPROCESS数据结构，并分配一个新的进程ID。
- en: '2.  Windows initializes the virtual memory required for the process, creates
    the PEB structure, and loads two libraries that nearly all Windows processes require:
    *ntdll.dll* and *kernel32.dll*. It then prepares to load Firefox’s PE file by
    initializing the PE loader.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  Windows初始化所需的虚拟内存，为进程创建PEB结构，并加载几乎所有Windows进程所需的两个库：*ntdll.dll*和*kernel32.dll*。然后它准备通过初始化PE加载器来加载Firefox的PE文件。
- en: 3.  The PE loader parses the DOS, PE, and optional headers of the PE file to
    gather all information required to successfully execute the file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  PE加载器解析PE文件的DOS头、PE头和可选头，以收集成功执行文件所需的所有信息。
- en: 4.  The PE loader parses the section header to prepare for mapping these sections
    into memory. The PE loader maps each section into virtual memory within the new
    process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  PE加载器解析段头，以准备将这些段映射到内存中。PE加载器将每个段映射到新进程中的虚拟内存。
- en: 5.  The PE loader loads all libraries referenced in the imports (usually *.idata*
    or *.rdata*) section and resolves all addresses for the functions required. All
    addresses are then stored in the IAT inside the process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  PE加载器加载所有在导入（通常是*.idata*或*.rdata*）段中引用的库，并解析所有函数所需的地址。所有地址随后存储在进程中的IAT中。
- en: 6.  A new thread is created inside the current process, and the loader executes
    the first bytes of code in the executable (usually in the *.text* section).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  在当前进程中创建一个新的线程，并且加载器执行可执行文件中的首批字节（通常位于*.text*段中）。
- en: '[Figure 1-7](chapter1.xhtml#fig1-7) illustrates a PE file being loaded and
    mapped into virtual memory.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-7](chapter1.xhtml#fig1-7)展示了一个PE文件被加载并映射到虚拟内存中的过程。'
- en: '![](../images/fig1-7.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-7: Loading and mapping
    a PE file into virtual memory inside a process</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-7：在进程内部加载并映射PE文件到虚拟内存</samp>
- en: Each section in the PE file is individually mapped into memory, but it appears
    expanded in virtual memory as there are often regions of memory between each section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个PE文件中的段都被单独映射到内存中，但由于每个段之间通常有内存区域，因此它们在虚拟内存中是扩展显示的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Registry</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">注册表</samp>
- en: The final Windows concept to discuss is the *registry*, which is simply a database
    that the OS and other installed applications use to store configurations and settings.
    The registry stores data hierarchically, with several primary root keys or *hives*,
    each containing additional keys (which you can think of as directories), each
    of which in turn stores more keys or values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论的最后一个Windows概念是*注册表*，它只是一个操作系统和其他已安装应用程序用来存储配置和设置的数据库。注册表以分层结构存储数据，包含几个主要的根键或*hives*，每个根键中都包含附加的键（你可以把它们看作是目录），每个键又存储更多的键或值。
- en: '*Values* are the actual configuration for the settings. For example, the root
    key <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp> contains
    a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Control Panel</samp>,
    which itself contains a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp> contains multiple values,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">MouseSpeed</samp>, which
    stores the mouse speed configuration for the currently logged-in user. This registry
    key path can be expressed just like a file or directory path in Windows: *HKEY_CURRENT_USER\Control
    Panel\Mouse\MouseSpeed*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*值*是设置的实际配置。例如，根键<samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp>包含一个子键叫做<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Control Panel</samp>，它本身又包含一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp>的子键。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp>包含多个值，例如<samp class="SANS_TheSansMonoCd_W5Regular_11">MouseSpeed</samp>，它存储当前登录用户的鼠标速度配置。这个注册表键路径可以像Windows中的文件或目录路径一样表示：*HKEY_CURRENT_USER\Control
    Panel\Mouse\MouseSpeed*。'
- en: 'These are five of the most important hives in the registry:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是注册表中最重要的五个 hive：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_LOCAL_MACHINE (HKLM)</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_LOCAL_MACHINE (HKLM)</samp>
- en: Values specific to the system, such as low-level OS and hardware configurations,
    security policy and account settings, and settings for various software installed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于系统的值，例如操作系统和硬件配置、策略和账户设置，以及各种安装软件的设置。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_USER (</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">HKCU)</samp>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_USER (</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">HKCU)</samp>
- en: Values related to user settings and system configurations, like sound, mouse,
    keyboard, network, and printer settings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户设置和系统配置相关的值，例如声音、鼠标、键盘、网络和打印机设置。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_USERS (HKU)</samp>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_USERS (HKU)</samp>
- en: Values related to user settings for each user with an account on the system.
    Under this root key, there are several other subkeys starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp>, for example).
    Each subkey represents the identifier for a user account on the system and stores
    configuration information for each user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统中每个用户账户的用户设置相关的值。在这个根键下，有几个其他子键以 <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp>
    开头（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp>）。每个子键代表系统中某个用户账户的标识符，并存储该用户的配置信息。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_CONFIG (HKCC)</samp>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_CONFIG (HKCC)</samp>
- en: Pointers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>
    key for the hardware profile currently in use by the logged-in user. This key
    is less important for our purposes, as everything of value is stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> key.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 指向当前登录用户使用的硬件配置文件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>
    键。对于我们的目的来说，这个键不太重要，因为所有有价值的数据都存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>
    键中。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CLASSES_ROOT (HKCR)</samp>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CLASSES_ROOT (HKCR)</samp>
- en: Information related to registered applications, such as file associations, which
    map file types to the application that can process them. (For example, *.doc*
    files should open in Microsoft Word.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与注册应用程序相关的信息，例如文件关联，它将文件类型与可以处理它们的应用程序相对应。（例如，*.doc* 文件应该在 Microsoft Word 中打开。）
- en: Registry hives are stored on the hard disk as files. When Windows boots up,
    these files are loaded into memory, and the registry is built. Any changes to
    the registry after the system boots up are stored in memory and not directly on
    disk. This is why some malware is able to store malicious code and configurations
    in the registry without necessarily touching the disk.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表项以文件形式存储在硬盘上。当 Windows 启动时，这些文件会被加载到内存中，从而建立注册表。系统启动后对注册表的任何更改都会存储在内存中，而不是直接存储在硬盘上。这就是为什么一些恶意软件能够将恶意代码和配置存储在注册表中，而不一定需要访问硬盘的原因。
- en: Finally, Windows has a built-in utility called the Registry Editor (*Regedit*),
    shown in [Figure 1-8](chapter1.xhtml#fig1-8), that all malware analysts should
    be intimately familiar with.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Windows 有一个内置工具叫做注册表编辑器（*Regedit*），如[图 1-8](chapter1.xhtml#fig1-8)所示，所有恶意软件分析人员都应该非常熟悉这个工具。
- en: '![](../images/fig1-8.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-8: The Registry Editor
    tool in Windows</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-8：Windows 中的注册表编辑器工具</samp>
- en: Regedit allows you to inspect and modify each registry key and value on the
    system, which is useful for understanding how the registry works. Regedit can
    also be useful for investigating how malware may have altered this data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Regedit 允许你检查和修改系统上每个注册表项和值，这对于了解注册表如何工作非常有用。Regedit 还可以用于调查恶意软件可能如何更改这些数据。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter discussed some of the fundamental concepts, objects, and structures
    used by the Windows operating system and explored the architecture of Windows
    at a high level. We’ll return to these concepts throughout the book as we look
    at ways in which attackers can exploit some of these features to execute malicious
    code while evading defenses. In the next chapter, we’ll walk through the basics
    of the malware triage and behavioral- analysis process to lay the groundwork for
    our investigations in later chapters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 Windows 操作系统中使用的一些基本概念、对象和结构，并高层次地探索了 Windows 的架构。我们将在本书的后续部分回到这些概念，研究攻击者如何利用这些特性来执行恶意代码，同时绕过防御措施。在下一章，我们将介绍恶意软件筛查和行为分析过程的基础，为后续章节的调查奠定基础。
