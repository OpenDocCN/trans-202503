- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    FOUNDATIONAL CONCEPTS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">Windows基础概念</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: To understand your adversary, first you must understand the battlefield. In
    our case, the battlefield is the Windows operating system and its underlying components.
    This chapter will provide an overview of the Windows architecture and introduce
    the fundamental concepts you’ll need in order to understand the more advanced
    topics covered in later chapters of this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解你的对手，首先你必须了解战场。在我们的例子中，战场就是Windows操作系统及其底层组件。本章将概述Windows架构，并介绍你理解本书后续章节中更高级主题所需的基本概念。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Windows Architecture Overview</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Windows架构概述</samp>
- en: Windows is a complex operating system (OS) with an equally complex architecture.
    In this section, I’ll introduce some of its key concepts, and as we proceed through
    the chapter, I’ll revisit and elaborate on them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Windows是一个复杂的操作系统（OS），其架构同样复杂。在本节中，我将介绍一些关键概念，随着章节的推进，我将回顾并详细说明这些概念。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">User and Kernel
    Modes</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">用户模式与内核模式</samp>'
- en: 'The Windows architecture consists of two modes: user and kernel, which are
    the fundamental components of the OS. A *mode* is a context in which code runs
    on the system. *User mode* is what most people think of when using a computer;
    it consists of the normal, day-to-day software and processes that the user interacts
    with, such as Microsoft Office programs and web browsers. Conversely, *kernel
    mode* is reserved for the core OS functions: those responsible for important,
    low-level tasks like memory management and hardware interaction.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Windows架构由两种模式组成：用户模式和内核模式，它们是操作系统的基本组成部分。*模式*是代码在系统上运行的上下文。*用户模式*是大多数人在使用计算机时的常见模式；它包括用户与之交互的正常的、日常使用的软件和进程，如Microsoft
    Office程序和网页浏览器。相反，*内核模式*则保留给操作系统的核心功能：负责重要的低级任务，如内存管理和硬件交互。
- en: Code running in user mode can’t access or interfere with code running in kernel
    mode; this is an intentional protection mechanism to prevent misconfigured or
    malicious applications from altering the OS environment. This separation is critical
    because all code and programs that run in kernel mode share the same memory address
    space, meaning that a misbehaving program could cause an unintended crash of the
    entire OS. It also means that if a malicious program were able to execute in kernel
    mode, it could directly affect the OS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在用户模式下的代码无法访问或干扰运行在内核模式下的代码；这是一个有意的保护机制，用来防止配置错误或恶意的应用程序改变操作系统环境。这种分离非常重要，因为所有在内核模式下运行的代码和程序共享同一个内存地址空间，这意味着一个行为不当的程序可能导致整个操作系统的崩溃。它还意味着，如果恶意程序能够在内核模式下执行，它就能直接影响操作系统。
- en: '[Figure 1-1](chapter1.xhtml#fig1-1) shows the relationship between user mode
    and kernel mode.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](chapter1.xhtml#fig1-1)展示了用户模式与内核模式之间的关系。'
- en: '![](../images/fig1-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: The relationship
    between user mode and kernel mode</samp>'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-1：用户模式与内核模式之间的关系</samp>
- en: 'Let’s take a closer look at the concepts illustrated here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下这里展示的概念：
- en: '**Applications**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序**'
- en: These are the software and programs that a user runs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用户运行的软件和程序。
- en: '**Windows application programming interface (WinAPI)**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows应用程序编程接口（WinAPI）**'
- en: This is what applications rely on in order to function. I’ll discuss this further
    in “The Windows API” on [page 6](chapter1.xhtml#pg_6).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序运行所依赖的基础。我将在《Windows API》一节中进一步讨论这个内容，详见[第6页](chapter1.xhtml#pg_6)。
- en: '**Drivers**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**'
- en: These control various devices on the system and provide an abstraction layer
    between the devices and the programs that wish to interact with them. There are
    two kinds of drivers. *Hardware device drivers* take input/output (IO) requests
    and convert them to hardware IO requests, such as for the mouse and keyboard.
    *Nonhardware device drivers* control system components such as network interfaces
    and the filesystem. Some drivers operate in user mode and some in kernel mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制系统上的各种设备，并在设备与希望与之交互的程序之间提供抽象层。有两种类型的驱动程序。*硬件设备驱动程序*处理输入/输出（IO）请求，并将其转换为硬件IO请求，例如鼠标和键盘。*非硬件设备驱动程序*控制系统组件，如网络接口和文件系统。一些驱动程序在用户模式下运行，一些在内核模式下运行。
- en: '**Hardware abstraction layer**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件抽象层**'
- en: This provides an interface that device drivers can use to communicate with the
    underlying system hardware. It enables the kernel and higher-level applications
    to operate independently of the system hardware.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个接口，设备驱动程序可以用来与底层系统硬件通信。它使内核和高级应用程序能够独立于系统硬件运行。
- en: 'The Windows kernel itself is contained in an executable file called *ntoskrnl.exe*,
    and it’s split into two parts: the kernel and the executive layer. The *kernel*
    is responsible for fundamental functionality like task synchronization and scheduling;
    it also provides low-level hardware support, which is essential for the system
    to run efficiently. The *executive layer* contains critical system services such
    as the *Memory Manager*, which implements virtual memory functionalities (see
    “Virtual Memory” on [page 11](chapter1.xhtml#pg_11)), and the *Process Manager*,
    which handles the creation and termination of processes and threads.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 内核本身包含在一个名为*ntoskrnl.exe*的可执行文件中，并分为两部分：内核和执行层。*内核*负责基本功能，如任务同步和调度；它还提供低级硬件支持，这对于系统高效运行至关重要。*执行层*包含关键的系统服务，如*内存管理器*，它实现虚拟内存功能（见“虚拟内存”在[第11页](chapter1.xhtml#pg_11)），以及*进程管理器*，它处理进程和线程的创建和终止。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Processes and Threads</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程与线程</samp>
- en: When an application such as *Excel.exe* or *Calculator.exe* is executed, the
    Windows Portable Executable loader creates a *process* for that program; the process
    contains the original program executable and all supporting libraries and code.
    Each process is assigned its own virtual address space in memory, which is private
    and isolated to that process. This means that if a process crashes, it does not
    (or should not) affect other processes or the OS itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序如*Excel.exe*或*Calculator.exe*被执行时，Windows 可执行文件加载器为该程序创建一个*进程*；该进程包含原始的程序可执行文件以及所有支持库和代码。每个进程在内存中分配有自己的虚拟地址空间，这个空间是私有的，并且对该进程是隔离的。这意味着，如果一个进程崩溃，它不会（或者不应该）影响其他进程或操作系统本身。
- en: Each running process in Windows can host one or more threads. A *thread* is
    simply a series of instructions. The processor can run only one thread at any
    given time, however. This means that if Process B wishes to execute some code,
    it must wait for Process A’s current thread to complete. If Windows deems Process
    B to be more important, it can issue an interrupt to Process A’s current thread
    and execute Process B’s thread instead. (This is called a *context switch.*) Windows
    executes context switching so quickly and efficiently that the end user isn’t
    even aware that it’s constantly happening.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中的每个运行进程都可以托管一个或多个线程。*线程*仅仅是一系列指令。然而，处理器在任何给定时刻只能运行一个线程。这意味着，如果进程 B
    希望执行某些代码，它必须等待进程 A 当前的线程完成。如果 Windows 认为进程 B 更重要，它可以向进程 A 当前的线程发出中断，并改为执行进程 B
    的线程。（这称为*上下文切换*。）Windows 执行上下文切换非常迅速高效，以至于最终用户甚至没有察觉到它在不断发生。
- en: Windows is a multitasking OS. This means that as the processor executes instructions
    to run the system and its applications, it efficiently switches between executing
    code in user mode and in kernel mode. To do this, Windows uses *time slices*,
    which are atomic segments of time (measured in milliseconds) that are assigned
    to each thread. A thread is allowed to execute its code, but after its time slice
    expires, other threads are allowed to run. Because time slices are so small, the
    system appears to be executing multiple threads and operating multiple programs
    at the same time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Objects and
    Handles</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Processes and threads often interact with *objects*, which are instances of
    a certain type of resource, such as a file, another process or thread, a security
    token (for user access rights), or even a section of memory. The centralized *object
    manager* is responsible for tracking all Windows objects, sharing them among processes,
    and protecting them from unauthorized access.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: All objects in Windows are simply data structures, typically stored in kernel
    memory. Since most applications on Windows run in user space, a process uses a
    unique identifier known as a *handle* to access an object. Each process may have
    multiple handles for various objects. Handles are managed in a process’s *handle
    table*, which contains pointers to the objects in kernel memory, as illustrated
    in [Figure 1-2](chapter1.xhtml#fig1-2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A Windows process
    handle table and object structure</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '*Mutual exclusions*, or *mutexes*, are a method of controlling access to objects
    to prevent potential issues like Process A and Process B both attempting to access
    and modify a file at exactly the same time, which is known as a *race condition*.
    Depending on how Windows uses this specific file, this situation could potentially
    cause data inconsistencies, or worse, crash a process or the OS. To avoid unwanted
    events such as a race condition, Process A may create a mutex object for that
    file, locking the file for its own use and preventing Process B from being able
    to access or write to the file until it is unlocked.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The program’s interaction with these objects, and with the OS itself, is managed
    by the Windows API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Windows API</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Windows application programming interface (WinAPI)* is a shared library
    of code that is exposed to user-mode applications. When a Windows program runs,
    WinAPI invokes Windows functions that enable the program to operate as designed
    within the Windows OS.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'WinAPI covers nearly all the functionality that a developer could want to implement
    in their code: everything from user interface and networking capabilities to input
    devices (mouse, keyboard, and so on) to memory management. For example, if a developer
    wants to create a new window for their application, they might call the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> function. If a program
    needs access to a hard disk, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp>
    to retrieve a list of the available hard disks.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: WinAPI 涵盖了开发人员可能希望在代码中实现的几乎所有功能：从用户界面、网络功能到输入设备（鼠标、键盘等）、再到内存管理。例如，如果开发人员想为他们的应用程序创建一个新窗口，他们可能会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> 函数。如果程序需要访问硬盘，它可能会调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp> 来检索可用硬盘的列表。
- en: There’s also a lower-level API called the *Windows Native API*, or simply *Native
    API*. While WinAPI is well documented and designed to be used by developers, the
    Native API is largely undocumented, at least by Microsoft.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更低级别的 API，叫做 *Windows 本地 API*，或简称 *本地 API*。虽然 WinAPI 有很好的文档并设计为开发人员使用，但本地
    API 大部分没有文档，至少在微软的官方文档中没有。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Thankfully, the reverse engineering community has gone to great lengths to
    document the Native API internals. Two great examples are the “ntinternals” project
    (*[http://undocumented.ntinternals.net](http://undocumented.ntinternals.net)*)*
    *and Geoff Chappell’s research (*[https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm](https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm)*)*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*幸运的是，逆向工程社区已经付出了巨大努力来记录本地 API 的内部实现。两个很好的例子是“ntinternals”项目（*[http://undocumented.ntinternals.net](http://undocumented.ntinternals.net)）*
    和 Geoff Chappell 的研究（*[https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm](https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm)）*。'
- en: 'The Native API is designed to be internal to the OS, but programs can call
    Native API functions directly if they so choose. In turn, Native API functions
    call into even lower-level kernel API code residing in *ntoskrnl.exe*. A call
    into the kernel is known as a *syscall* or *sysenter*. (There are minor technical
    differences between syscall and sysenter, but they both have the same objective:
    allowing user applications access to kernel services. For simplicity’s sake, I’ll
    use the term *syscall* in this book.)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 API 设计为操作系统内部使用，但程序可以直接调用本地 API 函数，前提是它们愿意这样做。反过来，本地 API 函数会调用更底层的内核 API
    代码，这些代码存在于 *ntoskrnl.exe* 中。对内核的调用被称为 *syscall* 或 *sysenter*。（syscall 和 sysenter
    之间有一些小的技术差异，但它们的目标是一样的：允许用户应用程序访问内核服务。为了简化起见，本书中我将使用 *syscall* 这个术语。）
- en: '[Figure 1-3](chapter1.xhtml#fig1-3) illustrates the interaction between WinAPI
    and the Native API.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-3](chapter1.xhtml#fig1-3) 演示了 WinAPI 与本地 API 之间的交互。'
- en: '![](../images/fig1-3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: User-mode APIs
    calling into lower-level APIs</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-3：用户模式 API 调用更低层次的 API</samp>
- en: At the top, you can see a program calling the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    which in turn calls WinAPI’s <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    function (not shown in this diagram). This is followed by a call to the Native
    API’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function. Finally, the program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function inside *ntoskrnl.exe*. This complex chain of API calls is very common
    in Windows and allows for code to be developed without the developer needing to
    understand all of the internals of Windows and the lower-level APIs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，你可以看到一个程序调用 WinAPI 函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>，然后它又调用了
    WinAPI 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> 函数（该函数在此图中未显示）。接着是调用本地
    API 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    函数。最后，程序调用了 *ntoskrnl.exe* 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    函数。这一复杂的 API 调用链在 Windows 中非常常见，它允许开发人员在无需了解 Windows 和低级 API 内部实现的情况下进行代码开发。
- en: As you may have noticed, WinAPI functions often have one or more suffixes, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>. Generally speaking,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> suffix is Microsoft’s
    way of designating a newer, extended (with more features) version of an older
    function. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>
    function is the newer, extended version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix indicates
    that the function uses ANSI format inputs and outputs, while functions with a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> suffix use Unicode inputs
    and outputs. The usage of ANSI versus Unicode doesn’t matter that often, so I
    won’t be covering that topic further and I generally won’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> in the function name.
    (For example, I’ll refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>
    function as simply <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindow</samp>.)
    For <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> functions, however,
    I’ll always include the suffix.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Windows Native API functions typically have the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>; examples include <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwNotifyChangeKey</samp>.
    Each function in the API typically has both an <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> version. <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    functions are most often used by drivers and other lower-level system software
    but are largely interchangeable with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also have noticed the filenames *kernel32.dll* and *ntdll.dll* in [Figure
    1-3](chapter1.xhtml#fig1-3). These refer to *dynamic link libraries (DLLs)*, a
    collection of resources that developers can import into their program to make
    use of existing code from Microsoft or third-party developers. While Windows programs
    can import these libraries, DLL files themselves export functions to the program
    that imported them. For example, if a developer wishes to access a hard disk on
    the Windows system, they can import the *kernel32.dll* library, which exports
    (provides) the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp>
    function they need. Some of the DLLs used often in Windows programs are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '***kernel32.dll ***This is one of the primary DLLs required for Windows programs
    to run, and it contains many of the fundamental user-mode functions.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '***user32.dll ***This DLL provides the graphical user interface (GUI) functions
    required for Windows programs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '***Winhttp.dll ***Also known as the “Windows HTTP Interface,” this DLL provides
    internet connection functionalities to Windows programs.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '***ntdll.dll ***This critical DLL contains functions for synchronization, threading,
    and other system tasks; it also communicates with the kernel.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re analyzing code with functions exported from* kernel32.dll *(as many
    functions are), you might notice that when a process executes a* kernel32.dll
    *function, there’s an immediate jump to another DLL,* kernelbase.dll*. Introduced
    in Windows 7,* kernelbase.dll *allows for backward compatibility between older
    and newer Windows versions. Most* kernel32.dll *function calls simply jump to*
    kernelbase.dll*, which contains the function’s actual code. For example, the function
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WriteFile</samp> (exported
    from* kernel32.dll*), once invoked, will immediately jump to* kernelbase.dll*,
    where its code actually resides. For simplicity’s sake, I’ll use* kernel32.dll
    *and* kernelbase.dll *synonymously throughout this book.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: While legitimate Windows programs heavily rely on the underlying WinAPI and
    Native API to function, illegitimate software (that is, malware) also uses these
    functionalities, as you’ll see in later chapters. For now, let’s take an in-depth
    look at processes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Internals</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processes are quite complex data structures that point to additional data structures.
    This network provides the underlying information that Windows relies on to efficiently
    manage and coordinate the many processes running on a system at any point in time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">EPROCESS Structures</samp>
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though most processes exposed to the end user run in user mode, they’re
    represented in kernel address space as objects called *EPROCESS* structures. Each
    process has its own EPROCESS structure that contains pointers to elements like
    the list of handles the process has open, as well as its *Process Environment
    Block (PEB)*, which is a structure that contains vital information about the process.
    EPROCESS structures consist of a doubly linked list; that is, they form a chain
    in which each structure links to the previous and subsequent structures. EPROCESS
    structure members called *forward links (flinks)* are pointers to the next EPROCESS
    structure in the chain, while *backward links (blinks)* point to the previous
    one. [Figure 1-4](chapter1.xhtml#fig1-4) illustrates a simplified version of this
    chain.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-4.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: An EPROCESS structure’s
    doubly linked list chain</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The EPROCESS structure contains many other data elements and pointers that are
    mostly outside the scope of this book. The key takeaway here is that each user-mode
    process in Windows is linked to an EPROCESS structure running in kernel mode.
    This will be important later on, when we discuss topics like direct kernel object
    manipulation (DKOM) in [Part IV](part4.xhtml).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: EPROCESS 结构包含许多其他数据元素和指针，大多数超出了本书的讨论范围。这里的关键要点是，每个 Windows 中的用户模式进程都与一个在内核模式下运行的
    EPROCESS 结构相关联。稍后我们在讨论诸如直接内核对象操作（DKOM）等主题时，这一点将变得非常重要，参见[第 IV 部分](part4.xhtml)。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Environment
    Blocks</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">进程环境块</samp>'
- en: The PEB memory structure contains information about a running process that the
    kernel needs to communicate with that process, as well as information for interprocess
    communication. Each running process has its own PEB that’s stored in user-mode
    address space inside that process memory. [Table 1-1](chapter1.xhtml#tab1-1) lists
    some of the important data the PEB structure contains. The offset of each structure
    member is shown for both x86 and x64 architectures.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: PEB 内存结构包含有关正在运行的进程的信息，操作系统内核需要通过这些信息与该进程进行通信，还包括用于进程间通信的信息。每个正在运行的进程都有自己的 PEB，存储在该进程的用户模式地址空间中。[表
    1-1](chapter1.xhtml#tab1-1)列出了 PEB 结构中包含的一些重要数据。每个结构成员的偏移量在 x86 和 x64 架构中都有显示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">PEB
    Structure Offsets and Data</samp>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 1-1：</samp> <samp class="SANS_Futura_Std_Book_11">PEB
    结构偏移量和数据</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Offset
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Data</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">偏移量 (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">偏移量
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">数据</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_Futura_Std_Book_11">0x002</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    <samp class="SANS_Futura_Std_Book_11">value, which indicates whether the process
    is running under the context of a debugger. (This will be important in [Chapter
    10](chapter10.xhtml).)</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_Futura_Std_Book_11">0x002</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    <samp class="SANS_Futura_Std_Book_11">值，表示进程是否在调试器的上下文中运行。（这在[第 10 章](chapter10.xhtml)中会很重要。）</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x008</samp> | <samp class="SANS_Futura_Std_Book_11">0x10</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the base address of the process
    executable in memory.</samp> |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x008</samp> | <samp class="SANS_Futura_Std_Book_11">0x10</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储进程可执行文件在内存中的基本地址。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x00C</samp> | <samp class="SANS_Futura_Std_Book_11">0x18</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores information on the modules and
    libraries the process has loaded.</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x00C</samp> | <samp class="SANS_Futura_Std_Book_11">0x18</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储进程加载的模块和库的信息。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_Futura_Std_Book_11">0x30</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores information about the process’s
    memory heap.</samp> |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_Futura_Std_Book_11">0x30</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储有关进程内存堆的信息。</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">0x064</samp> | <samp class="SANS_Futura_Std_Book_11">0xB8</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NumberOfProcessors</samp>
    <samp class="SANS_Futura_Std_Book_11">value, which indicates the number of processors
    the system has.</samp> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">0x064</samp> | <samp class="SANS_Futura_Std_Book_11">0xB8</samp>
    | <samp class="SANS_Futura_Std_Book_11">存储</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NumberOfProcessors</samp>
    <samp class="SANS_Futura_Std_Book_11">值，表示系统中的处理器数量。</samp> |'
- en: You don’t need to memorize all the elements of a PEB, but it’s important to
    have a basic understanding of it because I’ll be referencing it throughout the
    book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住 PEB 的所有元素，但了解其基本结构非常重要，因为我将在全书中引用它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Environment
    Blocks</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">线程环境块</samp>
- en: A *Thread Environment Block (TEB)*, sometimes referred to as the *Thread Information
    Block (TIB)*, contains information for a process’s running threads. Much like
    the PEB, it’s simply a data structure that stores critical information for each
    thread and is stored in the memory address space of the process that owns the
    thread. [Table 1-2](chapter1.xhtml#tab1-2) lists some of the most interesting
    elements in the TEB.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">TEB
    Structure Offsets and Data</samp>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Offset
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Data</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x00]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x00]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the current structured exception
    handler (SEH) frame. (SEH will be covered in more detail in [Chapters 10](chapter10.xhtml)
    and [11](chapter11.xhtml).)</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x04]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x08]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the base of the thread’s stack
    (see the next section).</samp> |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x18]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x30]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the TEB itself.</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x20]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x40]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process
    ID (PID)</samp> <samp class="SANS_Futura_Std_Book_11">of the thread’s owning process.</samp>
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x24]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x48]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">thread
    ID (TID)</samp> <samp class="SANS_Futura_Std_Book_11">of the current thread.</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x30]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x60]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the PEB of the thread’s owning
    process.</samp> |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0xE10]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x1480]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to thread-local storage (TLS) information.</samp>
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thread-local storage (TLS) *is used to store variables and other information
    across different threads. We’ll talk about how malware can abuse TLS to stealthily
    execute malicious code in [Chapter 11](chapter11.xhtml).*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Stacks and Heaps</samp>
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A process can have multiple active threads, each of which has its own memory
    stack. The *stack* is where the thread stores temporary data such as variables,
    pointers, and other objects that will inevitably be destroyed once the thread
    completes execution and is terminated. Since the stack is so volatile and temporary,
    programs sometimes need a more “permanent” solution for data storage. This is
    where heaps come in.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: A *heap* is a variably sized region of memory that a program dynamically allocates
    at runtime. Heaps are often used to store objects and data structures that are
    too large for the stack. They’re also used to store global variables and data
    that persist and can be used by multiple functions in the same program. It’s important
    to note that while the stack is largely managed by the OS, heaps are managed by
    the program itself. If a program doesn’t implement heap memory management techniques
    well, it can cause stability issues.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Virtual Memory</samp>
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each process running in Windows has a number of virtual memory regions assigned
    to it that are mapped to physical memory (or RAM). It’s important to understand
    the distinction between virtual and physical memory. *Physical memory* is the
    real, tangible hardware memory that is installed in your system. If you have a
    computer with 8GB of RAM, then you have 8GB of physical memory that all processes
    running on your system share. This poses a problem in that any process can interfere
    with any other process on the system (either inadvertently, such as in the case
    of a crash, or purposefully), with unwanted side effects. This is where virtual
    memory comes in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '*Virtual memory* is a sort of barrier between physical memory and process memory
    address space. When a process is started, it’s assigned an allotment of virtual
    memory that is mapped to physical memory via the *page table*. The page table
    keeps track of where different segments of virtual memory are physically located
    in RAM. [Figure 1-5](chapter1.xhtml#fig1-5) illustrates the relationship between
    virtual memory, the page table, and physical memory.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-5.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: Virtual memory
    mapped to physical memory via the page table</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Each block containing an ellipsis (...) represents a memory address range, or
    region. Each region of memory is mapped to the page table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: It’s quite possible for a system to have less RAM than what is required by all
    its running processes. To help manage this, virtual memory can be *paged out*,
    meaning that it will be temporarily stored on the hard disk when unused. If a
    process requires access to that virtual memory region again, the memory can be
    read from disk and remapped to physical memory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: You can view the virtual memory of a process using a process analysis tool such
    as Process Hacker ([*https://<wbr>processhacker<wbr>.sourceforge<wbr>.io*](https://processhacker.sourceforge.io)).
    To do this, start a program (such as *Calculator.exe*), open Process Hacker, and
    double-click the process you wish to explore. [Figure 1-6](chapter1.xhtml#fig1-6)
    shows the Memory tab of a process in Process Hacker.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-6.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: Viewing the virtual
    memory of a process in Process Hacker</samp>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The Base address column contains the base memory address of each virtual memory
    region assigned to *Calculator.exe*. The Type column contains the memory type
    for each region, the Size column gives the allocation size of each region, and
    the Protection column lists the protection status of the region.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Each virtual memory region is typically assigned one of three common memory
    types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*Image (IMG)* memory usually contains executable files or libraries that have
    been mapped into memory via the standard Windows loader mechanism (described shortly).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapped (MAP)* memory often contains either files that have been mapped into
    memory from the disk or other data used by the application running inside the
    process.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Private (PRV)* memory is typically allocated via <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and similar memory allocation functions.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, each memory region can be either committed or reserved. *Committed*
    regions are being actively used and have been mapped to physical memory. *Reserved*
    regions are reserved for the process but aren’t in active use and haven’t yet
    been mapped to RAM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the details of how Windows executables (more specifically,
    Portable Executable files) work internally.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The PE File Format</samp>
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft created the *PE (Portable Executable)* file format for executable
    files that run inside the Windows OS. The PE file format contains everything the
    Windows PE loader needs to execute the embedded code. Understanding the PE format
    is critical to understanding how malware works, so in this section we’ll look
    in depth at the structures the PE format comprises.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’ll refer to both x86 and x64 PE files as PE files. In reality, however,
    x64 has its own version of the PE format called* PE32+*. Since PE32+ differs only
    slightly from its x86 equivalent, I won’t cover it separately.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Headers and Sections</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The PE file format contains several *headers*: metadata or other information
    at the top of a file, telling the OS and other software what to do with its contents.
    The *DOS header* contains information required by MS-DOS and very early versions
    of Windows, and it mostly exists for legacy reasons. The *PE header* contains
    information used by the Windows PE loader, such as the CPU architecture the executable
    was compiled to run on and metadata like the file’s compilation timestamp. The
    PE header also includes the *optional header*, which indicates important information
    such as the PE’s base memory address (the memory address at which the PE will
    be mapped into memory), the size of the code inside the executable, and the target
    OS that the executable will run on. The “optional” header is in fact no longer
    optional in modern Windows systems.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The PE file also includes the *section header*, which contains metadata related
    to each of the file’s sections (where the actual file contents are stored), such
    as the section’s size, address, and other characteristics. Finally, most PE files
    contain at least a few of the following sections:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '| ***.text*** | The file’s main executable code |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| ***.rdata*** | Read-only data, such as static variables and constants |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| ***.bss*** | Uninitialized data, such as variables that haven’t been assigned
    a value yet |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| ***.data*** | Variables not embedded in the .*rdata* and *.bss* sections,
    such as global variables |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| ***.rsrc*** | Assets that will be loaded by the executable at runtime, such
    as images, fonts, and other supporting files |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| ***.idata*** | The imports address table (see the next section) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| ***.edata*** | The exports address table (see the next section) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Imports and Exports</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *.idata* and *.edata* sections are two of the most important components
    of a PE file. The *.idata* section contains information about the functions that
    the PE file will import at runtime. Once the PE file is executed, the program
    will load the libraries and functions referenced here into memory and build its
    *import address table (IAT)*, which maps the imported Windows API functions to
    their addresses in memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The *.edata* section contains information about the functions that the PE file
    exports to other programs, which they can then import and load into memory for
    their own use. It’s common for DLL executable files, for example, to contain a
    list of exported functions. As with imports, exports have their own table called
    the *export address table*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In practice, however, both the* .edata *and* .idata *sections are often contained
    in the* .rdata *section.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the way Windows loads PE files into memory. The program
    execution process is a fundamental concept for Windows malware analysis and will
    tie together all of the concepts you’ve seen so far.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows PE Loading Process</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you launch an executable file like Firefox in Windows, here’s what happens:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Windows creates a new EPROCESS data structure for the Firefox program and
    assigns a new process ID.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Windows initializes the virtual memory required for the process, creates
    the PEB structure, and loads two libraries that nearly all Windows processes require:
    *ntdll.dll* and *kernel32.dll*. It then prepares to load Firefox’s PE file by
    initializing the PE loader.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The PE loader parses the DOS, PE, and optional headers of the PE file to
    gather all information required to successfully execute the file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The PE loader parses the section header to prepare for mapping these sections
    into memory. The PE loader maps each section into virtual memory within the new
    process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The PE loader loads all libraries referenced in the imports (usually *.idata*
    or *.rdata*) section and resolves all addresses for the functions required. All
    addresses are then stored in the IAT inside the process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 6.  A new thread is created inside the current process, and the loader executes
    the first bytes of code in the executable (usually in the *.text* section).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-7](chapter1.xhtml#fig1-7) illustrates a PE file being loaded and
    mapped into virtual memory.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-7.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-7: Loading and mapping
    a PE file into virtual memory inside a process</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Each section in the PE file is individually mapped into memory, but it appears
    expanded in virtual memory as there are often regions of memory between each section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Registry</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final Windows concept to discuss is the *registry*, which is simply a database
    that the OS and other installed applications use to store configurations and settings.
    The registry stores data hierarchically, with several primary root keys or *hives*,
    each containing additional keys (which you can think of as directories), each
    of which in turn stores more keys or values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*Values* are the actual configuration for the settings. For example, the root
    key <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp> contains
    a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Control Panel</samp>,
    which itself contains a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp> contains multiple values,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">MouseSpeed</samp>, which
    stores the mouse speed configuration for the currently logged-in user. This registry
    key path can be expressed just like a file or directory path in Windows: *HKEY_CURRENT_USER\Control
    Panel\Mouse\MouseSpeed*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'These are five of the most important hives in the registry:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_LOCAL_MACHINE (HKLM)</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Values specific to the system, such as low-level OS and hardware configurations,
    security policy and account settings, and settings for various software installed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_USER (</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">HKCU)</samp>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Values related to user settings and system configurations, like sound, mouse,
    keyboard, network, and printer settings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_USERS (HKU)</samp>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Values related to user settings for each user with an account on the system.
    Under this root key, there are several other subkeys starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp>, for example).
    Each subkey represents the identifier for a user account on the system and stores
    configuration information for each user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_CONFIG (HKCC)</samp>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Pointers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>
    key for the hardware profile currently in use by the logged-in user. This key
    is less important for our purposes, as everything of value is stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> key.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CLASSES_ROOT (HKCR)</samp>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Information related to registered applications, such as file associations, which
    map file types to the application that can process them. (For example, *.doc*
    files should open in Microsoft Word.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Registry hives are stored on the hard disk as files. When Windows boots up,
    these files are loaded into memory, and the registry is built. Any changes to
    the registry after the system boots up are stored in memory and not directly on
    disk. This is why some malware is able to store malicious code and configurations
    in the registry without necessarily touching the disk.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Windows has a built-in utility called the Registry Editor (*Regedit*),
    shown in [Figure 1-8](chapter1.xhtml#fig1-8), that all malware analysts should
    be intimately familiar with.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-8.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-8: The Registry Editor
    tool in Windows</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Regedit allows you to inspect and modify each registry key and value on the
    system, which is useful for understanding how the registry works. Regedit can
    also be useful for investigating how malware may have altered this data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter discussed some of the fundamental concepts, objects, and structures
    used by the Windows operating system and explored the architecture of Windows
    at a high level. We’ll return to these concepts throughout the book as we look
    at ways in which attackers can exploit some of these features to execute malicious
    code while evading defenses. In the next chapter, we’ll walk through the basics
    of the malware triage and behavioral- analysis process to lay the groundwork for
    our investigations in later chapters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
