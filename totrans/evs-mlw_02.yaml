- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WINDOWS
    FOUNDATIONAL CONCEPTS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To understand your adversary, first you must understand the battlefield. In
    our case, the battlefield is the Windows operating system and its underlying components.
    This chapter will provide an overview of the Windows architecture and introduce
    the fundamental concepts you’ll need in order to understand the more advanced
    topics covered in later chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Windows Architecture Overview</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows is a complex operating system (OS) with an equally complex architecture.
    In this section, I’ll introduce some of its key concepts, and as we proceed through
    the chapter, I’ll revisit and elaborate on them.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">User and Kernel
    Modes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Windows architecture consists of two modes: user and kernel, which are
    the fundamental components of the OS. A *mode* is a context in which code runs
    on the system. *User mode* is what most people think of when using a computer;
    it consists of the normal, day-to-day software and processes that the user interacts
    with, such as Microsoft Office programs and web browsers. Conversely, *kernel
    mode* is reserved for the core OS functions: those responsible for important,
    low-level tasks like memory management and hardware interaction.'
  prefs: []
  type: TYPE_NORMAL
- en: Code running in user mode can’t access or interfere with code running in kernel
    mode; this is an intentional protection mechanism to prevent misconfigured or
    malicious applications from altering the OS environment. This separation is critical
    because all code and programs that run in kernel mode share the same memory address
    space, meaning that a misbehaving program could cause an unintended crash of the
    entire OS. It also means that if a malicious program were able to execute in kernel
    mode, it could directly affect the OS.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](chapter1.xhtml#fig1-1) shows the relationship between user mode
    and kernel mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: The relationship
    between user mode and kernel mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the concepts illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applications**'
  prefs: []
  type: TYPE_NORMAL
- en: These are the software and programs that a user runs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows application programming interface (WinAPI)**'
  prefs: []
  type: TYPE_NORMAL
- en: This is what applications rely on in order to function. I’ll discuss this further
    in “The Windows API” on [page 6](chapter1.xhtml#pg_6).
  prefs: []
  type: TYPE_NORMAL
- en: '**Drivers**'
  prefs: []
  type: TYPE_NORMAL
- en: These control various devices on the system and provide an abstraction layer
    between the devices and the programs that wish to interact with them. There are
    two kinds of drivers. *Hardware device drivers* take input/output (IO) requests
    and convert them to hardware IO requests, such as for the mouse and keyboard.
    *Nonhardware device drivers* control system components such as network interfaces
    and the filesystem. Some drivers operate in user mode and some in kernel mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware abstraction layer**'
  prefs: []
  type: TYPE_NORMAL
- en: This provides an interface that device drivers can use to communicate with the
    underlying system hardware. It enables the kernel and higher-level applications
    to operate independently of the system hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Windows kernel itself is contained in an executable file called *ntoskrnl.exe*,
    and it’s split into two parts: the kernel and the executive layer. The *kernel*
    is responsible for fundamental functionality like task synchronization and scheduling;
    it also provides low-level hardware support, which is essential for the system
    to run efficiently. The *executive layer* contains critical system services such
    as the *Memory Manager*, which implements virtual memory functionalities (see
    “Virtual Memory” on [page 11](chapter1.xhtml#pg_11)), and the *Process Manager*,
    which handles the creation and termination of processes and threads.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Processes and Threads</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When an application such as *Excel.exe* or *Calculator.exe* is executed, the
    Windows Portable Executable loader creates a *process* for that program; the process
    contains the original program executable and all supporting libraries and code.
    Each process is assigned its own virtual address space in memory, which is private
    and isolated to that process. This means that if a process crashes, it does not
    (or should not) affect other processes or the OS itself.
  prefs: []
  type: TYPE_NORMAL
- en: Each running process in Windows can host one or more threads. A *thread* is
    simply a series of instructions. The processor can run only one thread at any
    given time, however. This means that if Process B wishes to execute some code,
    it must wait for Process A’s current thread to complete. If Windows deems Process
    B to be more important, it can issue an interrupt to Process A’s current thread
    and execute Process B’s thread instead. (This is called a *context switch.*) Windows
    executes context switching so quickly and efficiently that the end user isn’t
    even aware that it’s constantly happening.
  prefs: []
  type: TYPE_NORMAL
- en: Windows is a multitasking OS. This means that as the processor executes instructions
    to run the system and its applications, it efficiently switches between executing
    code in user mode and in kernel mode. To do this, Windows uses *time slices*,
    which are atomic segments of time (measured in milliseconds) that are assigned
    to each thread. A thread is allowed to execute its code, but after its time slice
    expires, other threads are allowed to run. Because time slices are so small, the
    system appears to be executing multiple threads and operating multiple programs
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Objects and
    Handles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Processes and threads often interact with *objects*, which are instances of
    a certain type of resource, such as a file, another process or thread, a security
    token (for user access rights), or even a section of memory. The centralized *object
    manager* is responsible for tracking all Windows objects, sharing them among processes,
    and protecting them from unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: All objects in Windows are simply data structures, typically stored in kernel
    memory. Since most applications on Windows run in user space, a process uses a
    unique identifier known as a *handle* to access an object. Each process may have
    multiple handles for various objects. Handles are managed in a process’s *handle
    table*, which contains pointers to the objects in kernel memory, as illustrated
    in [Figure 1-2](chapter1.xhtml#fig1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A Windows process
    handle table and object structure</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mutual exclusions*, or *mutexes*, are a method of controlling access to objects
    to prevent potential issues like Process A and Process B both attempting to access
    and modify a file at exactly the same time, which is known as a *race condition*.
    Depending on how Windows uses this specific file, this situation could potentially
    cause data inconsistencies, or worse, crash a process or the OS. To avoid unwanted
    events such as a race condition, Process A may create a mutex object for that
    file, locking the file for its own use and preventing Process B from being able
    to access or write to the file until it is unlocked.'
  prefs: []
  type: TYPE_NORMAL
- en: The program’s interaction with these objects, and with the OS itself, is managed
    by the Windows API.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Windows API</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Windows application programming interface (WinAPI)* is a shared library
    of code that is exposed to user-mode applications. When a Windows program runs,
    WinAPI invokes Windows functions that enable the program to operate as designed
    within the Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'WinAPI covers nearly all the functionality that a developer could want to implement
    in their code: everything from user interface and networking capabilities to input
    devices (mouse, keyboard, and so on) to memory management. For example, if a developer
    wants to create a new window for their application, they might call the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowEx</samp> function. If a program
    needs access to a hard disk, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp>
    to retrieve a list of the available hard disks.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a lower-level API called the *Windows Native API*, or simply *Native
    API*. While WinAPI is well documented and designed to be used by developers, the
    Native API is largely undocumented, at least by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Thankfully, the reverse engineering community has gone to great lengths to
    document the Native API internals. Two great examples are the “ntinternals” project
    (*[http://undocumented.ntinternals.net](http://undocumented.ntinternals.net)*)*
    *and Geoff Chappell’s research (*[https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm](https://www.geoffchappell.com/studies/windows/win32/ntdll/api/native.htm)*)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Native API is designed to be internal to the OS, but programs can call
    Native API functions directly if they so choose. In turn, Native API functions
    call into even lower-level kernel API code residing in *ntoskrnl.exe*. A call
    into the kernel is known as a *syscall* or *sysenter*. (There are minor technical
    differences between syscall and sysenter, but they both have the same objective:
    allowing user applications access to kernel services. For simplicity’s sake, I’ll
    use the term *syscall* in this book.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-3](chapter1.xhtml#fig1-3) illustrates the interaction between WinAPI
    and the Native API.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: User-mode APIs
    calling into lower-level APIs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At the top, you can see a program calling the WinAPI function <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>,
    which in turn calls WinAPI’s <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>
    function (not shown in this diagram). This is followed by a call to the Native
    API’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function. Finally, the program invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function inside *ntoskrnl.exe*. This complex chain of API calls is very common
    in Windows and allows for code to be developed without the developer needing to
    understand all of the internals of Windows and the lower-level APIs.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, WinAPI functions often have one or more suffixes, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>. Generally speaking,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> suffix is Microsoft’s
    way of designating a newer, extended (with more features) version of an older
    function. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>
    function is the newer, extended version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> suffix indicates
    that the function uses ANSI format inputs and outputs, while functions with a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> suffix use Unicode inputs
    and outputs. The usage of ANSI versus Unicode doesn’t matter that often, so I
    won’t be covering that topic further and I generally won’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp> in the function name.
    (For example, I’ll refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowA</samp>
    function as simply <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindow</samp>.)
    For <samp class="SANS_TheSansMonoCd_W5Regular_11">Ex</samp> functions, however,
    I’ll always include the suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Native API functions typically have the prefix <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>; examples include <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ZwNotifyChangeKey</samp>.
    Each function in the API typically has both an <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp> version. <samp class="SANS_TheSansMonoCd_W5Regular_11">Zw</samp>
    functions are most often used by drivers and other lower-level system software
    but are largely interchangeable with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also have noticed the filenames *kernel32.dll* and *ntdll.dll* in [Figure
    1-3](chapter1.xhtml#fig1-3). These refer to *dynamic link libraries (DLLs)*, a
    collection of resources that developers can import into their program to make
    use of existing code from Microsoft or third-party developers. While Windows programs
    can import these libraries, DLL files themselves export functions to the program
    that imported them. For example, if a developer wishes to access a hard disk on
    the Windows system, they can import the *kernel32.dll* library, which exports
    (provides) the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLogicalDrives</samp>
    function they need. Some of the DLLs used often in Windows programs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '***kernel32.dll ***This is one of the primary DLLs required for Windows programs
    to run, and it contains many of the fundamental user-mode functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '***user32.dll ***This DLL provides the graphical user interface (GUI) functions
    required for Windows programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Winhttp.dll ***Also known as the “Windows HTTP Interface,” this DLL provides
    internet connection functionalities to Windows programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '***ntdll.dll ***This critical DLL contains functions for synchronization, threading,
    and other system tasks; it also communicates with the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re analyzing code with functions exported from* kernel32.dll *(as many
    functions are), you might notice that when a process executes a* kernel32.dll
    *function, there’s an immediate jump to another DLL,* kernelbase.dll*. Introduced
    in Windows 7,* kernelbase.dll *allows for backward compatibility between older
    and newer Windows versions. Most* kernel32.dll *function calls simply jump to*
    kernelbase.dll*, which contains the function’s actual code. For example, the function
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WriteFile</samp> (exported
    from* kernel32.dll*), once invoked, will immediately jump to* kernelbase.dll*,
    where its code actually resides. For simplicity’s sake, I’ll use* kernel32.dll
    *and* kernelbase.dll *synonymously throughout this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: While legitimate Windows programs heavily rely on the underlying WinAPI and
    Native API to function, illegitimate software (that is, malware) also uses these
    functionalities, as you’ll see in later chapters. For now, let’s take an in-depth
    look at processes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Internals</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processes are quite complex data structures that point to additional data structures.
    This network provides the underlying information that Windows relies on to efficiently
    manage and coordinate the many processes running on a system at any point in time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">EPROCESS Structures</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though most processes exposed to the end user run in user mode, they’re
    represented in kernel address space as objects called *EPROCESS* structures. Each
    process has its own EPROCESS structure that contains pointers to elements like
    the list of handles the process has open, as well as its *Process Environment
    Block (PEB)*, which is a structure that contains vital information about the process.
    EPROCESS structures consist of a doubly linked list; that is, they form a chain
    in which each structure links to the previous and subsequent structures. EPROCESS
    structure members called *forward links (flinks)* are pointers to the next EPROCESS
    structure in the chain, while *backward links (blinks)* point to the previous
    one. [Figure 1-4](chapter1.xhtml#fig1-4) illustrates a simplified version of this
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: An EPROCESS structure’s
    doubly linked list chain</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The EPROCESS structure contains many other data elements and pointers that are
    mostly outside the scope of this book. The key takeaway here is that each user-mode
    process in Windows is linked to an EPROCESS structure running in kernel mode.
    This will be important later on, when we discuss topics like direct kernel object
    manipulation (DKOM) in [Part IV](part4.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Environment
    Blocks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The PEB memory structure contains information about a running process that the
    kernel needs to communicate with that process, as well as information for interprocess
    communication. Each running process has its own PEB that’s stored in user-mode
    address space inside that process memory. [Table 1-1](chapter1.xhtml#tab1-1) lists
    some of the important data the PEB structure contains. The offset of each structure
    member is shown for both x86 and x64 architectures.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">PEB
    Structure Offsets and Data</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Offset
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Data</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_Futura_Std_Book_11">0x002</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    <samp class="SANS_Futura_Std_Book_11">value, which indicates whether the process
    is running under the context of a debugger. (This will be important in [Chapter
    10](chapter10.xhtml).)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x008</samp> | <samp class="SANS_Futura_Std_Book_11">0x10</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the base address of the process
    executable in memory.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x00C</samp> | <samp class="SANS_Futura_Std_Book_11">0x18</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores information on the modules and
    libraries the process has loaded.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_Futura_Std_Book_11">0x30</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores information about the process’s
    memory heap.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x064</samp> | <samp class="SANS_Futura_Std_Book_11">0xB8</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NumberOfProcessors</samp>
    <samp class="SANS_Futura_Std_Book_11">value, which indicates the number of processors
    the system has.</samp> |'
  prefs: []
  type: TYPE_TB
- en: You don’t need to memorize all the elements of a PEB, but it’s important to
    have a basic understanding of it because I’ll be referencing it throughout the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Thread Environment
    Blocks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *Thread Environment Block (TEB)*, sometimes referred to as the *Thread Information
    Block (TIB)*, contains information for a process’s running threads. Much like
    the PEB, it’s simply a data structure that stores critical information for each
    thread and is stored in the memory address space of the process that owns the
    thread. [Table 1-2](chapter1.xhtml#tab1-2) lists some of the most interesting
    elements in the TEB.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">TEB
    Structure Offsets and Data</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Offset (x86)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Offset
    (x64)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Data</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x00]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x00]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the current structured exception
    handler (SEH) frame. (SEH will be covered in more detail in [Chapters 10](chapter10.xhtml)
    and [11](chapter11.xhtml).)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x04]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x08]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the base of the thread’s stack
    (see the next section).</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x18]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x30]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the TEB itself.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x20]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x40]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">process
    ID (PID)</samp> <samp class="SANS_Futura_Std_Book_11">of the thread’s owning process.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x24]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x48]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Stores the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">thread
    ID (TID)</samp> <samp class="SANS_Futura_Std_Book_11">of the current thread.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0x30]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x60]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to the PEB of the thread’s owning
    process.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">FS:[0xE10]</samp> | <samp class="SANS_Futura_Std_Book_11">GS:[0x1480]</samp>
    | <samp class="SANS_Futura_Std_Book_11">Points to thread-local storage (TLS) information.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thread-local storage (TLS) *is used to store variables and other information
    across different threads. We’ll talk about how malware can abuse TLS to stealthily
    execute malicious code in [Chapter 11](chapter11.xhtml).*
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Stacks and Heaps</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A process can have multiple active threads, each of which has its own memory
    stack. The *stack* is where the thread stores temporary data such as variables,
    pointers, and other objects that will inevitably be destroyed once the thread
    completes execution and is terminated. Since the stack is so volatile and temporary,
    programs sometimes need a more “permanent” solution for data storage. This is
    where heaps come in.
  prefs: []
  type: TYPE_NORMAL
- en: A *heap* is a variably sized region of memory that a program dynamically allocates
    at runtime. Heaps are often used to store objects and data structures that are
    too large for the stack. They’re also used to store global variables and data
    that persist and can be used by multiple functions in the same program. It’s important
    to note that while the stack is largely managed by the OS, heaps are managed by
    the program itself. If a program doesn’t implement heap memory management techniques
    well, it can cause stability issues.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Virtual Memory</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each process running in Windows has a number of virtual memory regions assigned
    to it that are mapped to physical memory (or RAM). It’s important to understand
    the distinction between virtual and physical memory. *Physical memory* is the
    real, tangible hardware memory that is installed in your system. If you have a
    computer with 8GB of RAM, then you have 8GB of physical memory that all processes
    running on your system share. This poses a problem in that any process can interfere
    with any other process on the system (either inadvertently, such as in the case
    of a crash, or purposefully), with unwanted side effects. This is where virtual
    memory comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '*Virtual memory* is a sort of barrier between physical memory and process memory
    address space. When a process is started, it’s assigned an allotment of virtual
    memory that is mapped to physical memory via the *page table*. The page table
    keeps track of where different segments of virtual memory are physically located
    in RAM. [Figure 1-5](chapter1.xhtml#fig1-5) illustrates the relationship between
    virtual memory, the page table, and physical memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: Virtual memory
    mapped to physical memory via the page table</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each block containing an ellipsis (...) represents a memory address range, or
    region. Each region of memory is mapped to the page table.
  prefs: []
  type: TYPE_NORMAL
- en: It’s quite possible for a system to have less RAM than what is required by all
    its running processes. To help manage this, virtual memory can be *paged out*,
    meaning that it will be temporarily stored on the hard disk when unused. If a
    process requires access to that virtual memory region again, the memory can be
    read from disk and remapped to physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the virtual memory of a process using a process analysis tool such
    as Process Hacker ([*https://<wbr>processhacker<wbr>.sourceforge<wbr>.io*](https://processhacker.sourceforge.io)).
    To do this, start a program (such as *Calculator.exe*), open Process Hacker, and
    double-click the process you wish to explore. [Figure 1-6](chapter1.xhtml#fig1-6)
    shows the Memory tab of a process in Process Hacker.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: Viewing the virtual
    memory of a process in Process Hacker</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Base address column contains the base memory address of each virtual memory
    region assigned to *Calculator.exe*. The Type column contains the memory type
    for each region, the Size column gives the allocation size of each region, and
    the Protection column lists the protection status of the region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each virtual memory region is typically assigned one of three common memory
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Image (IMG)* memory usually contains executable files or libraries that have
    been mapped into memory via the standard Windows loader mechanism (described shortly).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mapped (MAP)* memory often contains either files that have been mapped into
    memory from the disk or other data used by the application running inside the
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Private (PRV)* memory is typically allocated via <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    and similar memory allocation functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, each memory region can be either committed or reserved. *Committed*
    regions are being actively used and have been mapped to physical memory. *Reserved*
    regions are reserved for the process but aren’t in active use and haven’t yet
    been mapped to RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s dig into the details of how Windows executables (more specifically,
    Portable Executable files) work internally.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The PE File Format</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft created the *PE (Portable Executable)* file format for executable
    files that run inside the Windows OS. The PE file format contains everything the
    Windows PE loader needs to execute the embedded code. Understanding the PE format
    is critical to understanding how malware works, so in this section we’ll look
    in depth at the structures the PE format comprises.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’ll refer to both x86 and x64 PE files as PE files. In reality, however,
    x64 has its own version of the PE format called* PE32+*. Since PE32+ differs only
    slightly from its x86 equivalent, I won’t cover it separately.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Headers and Sections</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The PE file format contains several *headers*: metadata or other information
    at the top of a file, telling the OS and other software what to do with its contents.
    The *DOS header* contains information required by MS-DOS and very early versions
    of Windows, and it mostly exists for legacy reasons. The *PE header* contains
    information used by the Windows PE loader, such as the CPU architecture the executable
    was compiled to run on and metadata like the file’s compilation timestamp. The
    PE header also includes the *optional header*, which indicates important information
    such as the PE’s base memory address (the memory address at which the PE will
    be mapped into memory), the size of the code inside the executable, and the target
    OS that the executable will run on. The “optional” header is in fact no longer
    optional in modern Windows systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PE file also includes the *section header*, which contains metadata related
    to each of the file’s sections (where the actual file contents are stored), such
    as the section’s size, address, and other characteristics. Finally, most PE files
    contain at least a few of the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***.text*** | The file’s main executable code |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ***.rdata*** | Read-only data, such as static variables and constants |'
  prefs: []
  type: TYPE_TB
- en: '| ***.bss*** | Uninitialized data, such as variables that haven’t been assigned
    a value yet |'
  prefs: []
  type: TYPE_TB
- en: '| ***.data*** | Variables not embedded in the .*rdata* and *.bss* sections,
    such as global variables |'
  prefs: []
  type: TYPE_TB
- en: '| ***.rsrc*** | Assets that will be loaded by the executable at runtime, such
    as images, fonts, and other supporting files |'
  prefs: []
  type: TYPE_TB
- en: '| ***.idata*** | The imports address table (see the next section) |'
  prefs: []
  type: TYPE_TB
- en: '| ***.edata*** | The exports address table (see the next section) |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Imports and Exports</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *.idata* and *.edata* sections are two of the most important components
    of a PE file. The *.idata* section contains information about the functions that
    the PE file will import at runtime. Once the PE file is executed, the program
    will load the libraries and functions referenced here into memory and build its
    *import address table (IAT)*, which maps the imported Windows API functions to
    their addresses in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The *.edata* section contains information about the functions that the PE file
    exports to other programs, which they can then import and load into memory for
    their own use. It’s common for DLL executable files, for example, to contain a
    list of exported functions. As with imports, exports have their own table called
    the *export address table*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In practice, however, both the* .edata *and* .idata *sections are often contained
    in the* .rdata *section.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the way Windows loads PE files into memory. The program
    execution process is a fundamental concept for Windows malware analysis and will
    tie together all of the concepts you’ve seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Windows PE Loading Process</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you launch an executable file like Firefox in Windows, here’s what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Windows creates a new EPROCESS data structure for the Firefox program and
    assigns a new process ID.
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Windows initializes the virtual memory required for the process, creates
    the PEB structure, and loads two libraries that nearly all Windows processes require:
    *ntdll.dll* and *kernel32.dll*. It then prepares to load Firefox’s PE file by
    initializing the PE loader.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The PE loader parses the DOS, PE, and optional headers of the PE file to
    gather all information required to successfully execute the file.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The PE loader parses the section header to prepare for mapping these sections
    into memory. The PE loader maps each section into virtual memory within the new
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The PE loader loads all libraries referenced in the imports (usually *.idata*
    or *.rdata*) section and resolves all addresses for the functions required. All
    addresses are then stored in the IAT inside the process.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  A new thread is created inside the current process, and the loader executes
    the first bytes of code in the executable (usually in the *.text* section).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-7](chapter1.xhtml#fig1-7) illustrates a PE file being loaded and
    mapped into virtual memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-7: Loading and mapping
    a PE file into virtual memory inside a process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each section in the PE file is individually mapped into memory, but it appears
    expanded in virtual memory as there are often regions of memory between each section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Registry</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final Windows concept to discuss is the *registry*, which is simply a database
    that the OS and other installed applications use to store configurations and settings.
    The registry stores data hierarchically, with several primary root keys or *hives*,
    each containing additional keys (which you can think of as directories), each
    of which in turn stores more keys or values.
  prefs: []
  type: TYPE_NORMAL
- en: '*Values* are the actual configuration for the settings. For example, the root
    key <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_CURRENT_USER</samp> contains
    a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Control Panel</samp>,
    which itself contains a subkey called <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp>.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mouse</samp> contains multiple values,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">MouseSpeed</samp>, which
    stores the mouse speed configuration for the currently logged-in user. This registry
    key path can be expressed just like a file or directory path in Windows: *HKEY_CURRENT_USER\Control
    Panel\Mouse\MouseSpeed*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are five of the most important hives in the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_LOCAL_MACHINE (HKLM)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Values specific to the system, such as low-level OS and hardware configurations,
    security policy and account settings, and settings for various software installed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_USER (</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">HKCU)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Values related to user settings and system configurations, like sound, mouse,
    keyboard, network, and printer settings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_USERS (HKU)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Values related to user settings for each user with an account on the system.
    Under this root key, there are several other subkeys starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">S</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp>, for example).
    Each subkey represents the identifier for a user account on the system and stores
    configuration information for each user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CURRENT_CONFIG (HKCC)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Pointers to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp>
    key for the hardware profile currently in use by the logged-in user. This key
    is less important for our purposes, as everything of value is stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">HKEY_LOCAL_MACHINE</samp> key.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">HKEY_CLASSES_ROOT (HKCR)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Information related to registered applications, such as file associations, which
    map file types to the application that can process them. (For example, *.doc*
    files should open in Microsoft Word.)
  prefs: []
  type: TYPE_NORMAL
- en: Registry hives are stored on the hard disk as files. When Windows boots up,
    these files are loaded into memory, and the registry is built. Any changes to
    the registry after the system boots up are stored in memory and not directly on
    disk. This is why some malware is able to store malicious code and configurations
    in the registry without necessarily touching the disk.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Windows has a built-in utility called the Registry Editor (*Regedit*),
    shown in [Figure 1-8](chapter1.xhtml#fig1-8), that all malware analysts should
    be intimately familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-8: The Registry Editor
    tool in Windows</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Regedit allows you to inspect and modify each registry key and value on the
    system, which is useful for understanding how the registry works. Regedit can
    also be useful for investigating how malware may have altered this data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter discussed some of the fundamental concepts, objects, and structures
    used by the Windows operating system and explored the architecture of Windows
    at a high level. We’ll return to these concepts throughout the book as we look
    at ways in which attackers can exploit some of these features to execute malicious
    code while evading defenses. In the next chapter, we’ll walk through the basics
    of the malware triage and behavioral- analysis process to lay the groundwork for
    our investigations in later chapters.
  prefs: []
  type: TYPE_NORMAL
