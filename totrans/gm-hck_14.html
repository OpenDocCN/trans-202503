<html><head></head><body>
<h2 class="h2c" id="ch10"><span epub:type="pagebreak" id="page_203"/><span class="big1"><strong>10</strong></span><br/><strong>RESPONSIVE HACKS</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">The average gamer has a reaction time of 250 milliseconds, or a quarter of a second. Professional gamers average a fifth of a second, but some can react in a sixth of a second. These figures are based on online tests that measure players’ reaction times to singular, predictable events. In actual games, though, players must react to dozens of different events, like health loss, incoming skill shots, abilities coming off of cooldown, enemy attacks, and many others. Only very skilled gamers can maintain a fourth- or fifth-of-a-second reaction time in such dynamic environments; the only way to be faster is to be a computer.</p>&#13;
<p class="indent">In this chapter, you’ll learn how to make bots that react faster than any player. First, I’ll show you some code patterns you can incorporate into a bot to detect when certain events happen within a game. Next, you’ll learn how to make a bot that moves your character, heals, or casts spells all on its own. Once you’ve explored those fundamental techniques, I’ll help you tie them together to implement some of the most common, and most powerful, responsive hacks.</p>&#13;
<h3 class="h3" id="ch00lev1sec203"><span epub:type="pagebreak" id="page_204"/><strong>Observing Game Events</strong></h3>&#13;
<p class="noindent">Within just a few seconds of playing a game, most people can make essential observations about the game environment. You can clearly see when missiles are flying toward your character, when your health is too low, and when abilities come off of cooldown. For a bot, though, these seemingly intuitive observations are not as easy to make. The bot must detect each event by looking for changes in memory, detecting visual cues, or intercepting network traffic.</p>&#13;
<h4 class="h4" id="ch00lev1sec204"><strong><em>Monitoring Memory</em></strong></h4>&#13;
<p class="noindent">To detect simple events, such as your health bar dropping low, you can program a bot to periodically read your health from memory and compare it to some minimum acceptable value, as in <a href="ch10.xhtml#ch10exe1">Listing 10-1</a>.</p>&#13;
<p class="programs">// do this every 10 milliseconds (100 times a second)<br/>auto health = readMemory&lt;int&gt;(HEALTH_ADDRESS);<br/>if (health &lt;= 500) {<br/>    // some code to tell the bot how to react<br/>}</p>&#13;
<p class="listt"><a id="ch10exe1"/><em>Listing 10-1: An <span class="literal">if</span> statement that checks health</em></p>&#13;
<p class="indent">Given the address of your character’s health, you can check the value there as often as you need; every 10 milliseconds is typically a good rate. (Flip back to <a href="ch01.xhtml#ch01">Chapter 1</a> if you need a refresher on locating values in memory.) Once <span class="literal">health</span> drops below a certain value, you’ll want to run some reaction code to cast a healing spell or drink a potion. I’ll talk about how you can do this later in the chapter.</p>&#13;
<p class="indent">If you want your bot to have more granular information and the chance for a greater variety of responses, you can program it to react to <em>any</em> change in health, instead of only after a set threshold. To do so, change the code in <a href="ch10.xhtml#ch10exe1">Listing 10-1</a> to compare your current health to the amount you had during the previous execution, as follows:</p>&#13;
<p class="programs">// still do this every 10 milliseconds<br/>static int previousHealth = 0;<br/>auto health = readMemory&lt;int&gt;(HEALTH_ADDRESS);<br/>if (health != previousHealth) {<br/>    if (health &gt; previousHealth) {<br/>        // react to increase<br/>    } else {<br/>        // react to decrease<br/>    }<br/>    previousHealth = health;<br/>}</p>&#13;
<p class="indent">Now, this code uses a static variable called <span class="literal">previousHealth</span> to track the value of <span class="literal">health</span> on the previous iteration. If <span class="literal">previousHealth</span> and <span class="literal">health</span> differ, the bot not only reacts to the change in health but also reacts differently <span epub:type="pagebreak" id="page_205"/>to health increases and decreases. This technique is the simplest, and most common, way to react to changes in a game state. With the proper memory addresses, you can use this code pattern to observe changes in health, mana, ability cooldowns, and other critical information.</p>&#13;
<h4 class="h4" id="ch00lev1sec205"><strong><em>Detecting Visual Cues</em></strong></h4>&#13;
<p class="noindent">Health is relatively simple for a bot to check because it’s just a number, but some game elements have to be relayed to the bot differently. For example, when status ailments or buffs are affecting a character, the easiest way for you to tell is to simply look for an onscreen status indicator, and the same is true for bots.</p>&#13;
<p class="indent">When reading memory isn’t enough, you can detect certain events by hooking a game’s graphics engine and waiting for the game to render a specific model. (Refer back to “<a href="ch08.xhtml#ch00lev1sec174">Applying Jump Hooks and VF Hooks to Direct3D</a>” on <a href="ch08.xhtml#page_175">page 175</a> and “<a href="ch09.xhtml#ch00lev1sec191">Creating a Direct3D Wallhack</a>” on <a href="ch09.xhtml#page_194">page 194</a> to get refreshed on Direct3D hooks. ) When the model is drawn, you can queue up a reaction to be executed after the frame is drawn, like this:</p>&#13;
<p class="programs">// below is the drawIndexedPrimitive hook<br/>void onDrawIndexedPrimitive(...) {<br/>    if (numVertices == EVENT_VERT &amp;&amp; primCount == EVENT_PRIM) {<br/>        // react, preferably after drawing is done<br/>    }<br/>}</p>&#13;
<p class="indent">Using the same model-fingerprinting trick as the wallhack code in <a href="ch09.xhtml#ch09">Chapter 9</a>, this code detects when a specific model is drawn to the screen and reacts accordingly. This code reacts to the event every single frame, though, and that can make your game unplayable. You’ll probably want some internal cooldown to avoid spamming a reaction. In cases where the indicator model is persistently drawn (that is, not blinking), you can actually track it across frames to determine when it appears and disappears.</p>&#13;
<p class="indent">Here’s a code snippet that also handles tracking:</p>&#13;
<p class="programs">bool eventActive = false;<br/>bool eventActiveLastFrame = false;<br/>// below is the drawIndexedPrimitive hook<br/>void onDrawIndexedPrimitive(...) {<br/>    if (numVertices == EVENT_VERT &amp;&amp; primCount == EVENT_PRIM)<br/>        eventActive = true;<br/>}<br/><br/>// below is the endScene hook<br/>void onDrawFrame(...) {<br/>    if (eventActive) {<br/>        if (!eventActiveLastFrame) {<br/>            // react to event model appear<br/>        }<br/>        eventActiveLastFrame = true;<br/>    } else {<br/>        if (eventActiveLastFrame) {<br/>            // react to event model disappear<br/>        }<br/>        eventActiveLastFrame = false;<br/>    }<br/>    eventActive = false;<br/>}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>The <span class="literal">onDrawIndexedPrimitive()</span> function still checks whether a certain model was drawn, but now, two Booleans track whether the model was drawn this frame or the previous frame. Then, when the frame is completely drawn, the bot can check these variables and react to the model either appearing or disappearing.</p>&#13;
<p class="indent">This method works great for detecting visual status indicators that appear only when your character is affected by stuns, movement slows, snares, poisons, and so on. You can also use it to detect when enemies appear and disappear in MOBA and RTS games, as these games draw only enemies that are explicitly in the sight range of an allied unit or player.</p>&#13;
<h4 class="h4" id="ch00lev1sec206"><strong><em>Intercepting Network Traffic</em></strong></h4>&#13;
<p class="noindent">One of the most reliable ways to observe events is the same way the game client does: by waiting for the game server to tell you that they occurred. In this type of communication, the game server sends byte arrays called <em>packets</em> over the network to the client, using sockets. The packets are typically encrypted and contain blobs of data serialized through a proprietary format.</p>&#13;
<h5 class="h5" id="ch00lev1sec207"><strong>A Typical Packet-Parsing Function</strong></h5>&#13;
<p class="noindent">To receive and process packets, a game client does something like <a href="ch10.xhtml#ch10exe2">Listing 10-2</a> before it draws a frame.</p>&#13;
<p class="programs">void parseNextPacket() {<br/>    if (!network-&gt;packetReady()) return;<br/><br/>    auto packet = network-&gt;getPacket();<br/>    auto data = packet-&gt;decrypt();<br/>    switch (data-&gt;getType()) {<br/>        case PACKET_HEALTH_CHANGE:<br/>            onHealthChange(data-&gt;getMessage());<br/>            break;<br/>        case PACKET_MANA_CHANGE:<br/>            onManaChange(data-&gt;getMessage());<br/>            break;<br/>        // more cases for more packet types<br/>    }<br/>}</p>&#13;
<p class="listt"><a id="ch10exe2"/><em>Listing 10-2: A simplified look at how a game parses packets</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_207"/>The exact code for any particular game might look different, but the control flow is always the same: receive a packet, decrypt it, decide what kind of message it contains, and call a function that knows what to do with it. Some game hackers intercept raw network packets and replicate this functionality in their bots. This technique works, but it requires extensive knowledge of encryption, a complete understanding of how the game stores data inside a packet, the ability to man-in-the-middle the network connection, and a way to locate the decryption keys being used by the game client.</p>&#13;
<p class="indent">Hooking the functions responsible for handling the packets after they are decrypted and parsed is a much better approach; in <a href="ch10.xhtml#ch10exe2">Listing 10-2</a>, those functions are the <span class="literal">onHealthChange()</span> and <span class="literal">onManaChange()</span> functions. This method leverages the game’s inherent ability to process packets, allowing a bot to remain ignorant of the various network facilities the game uses. It also gives you discretion over which network data you intercept, as you need to hook only the handlers that meet your needs.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Intercepting entire packets can sometimes be advantageous—for example, in any game that uses Adobe AIR and communicates using RTMPS. Since RTMPS is so heavily documented, there’s no need to reverse engineer the format or encryption. <a href="ch08.xhtml#ch08">Chapter 8</a> explains how to hook RTMPS in detail.</em></p>&#13;
</div>&#13;
<p class="indent">There are a few tricks you can use to easily find the parser function and, ultimately, the <span class="literal">switch()</span> statement that dispatches packets to their handlers. The most useful method I’ve found is to place a breakpoint on the function the game uses to receive data from the network, and then analyze the flow of the application when the breakpoint is hit.</p>&#13;
<p class="indent">Let’s walk through how you might do this with OllyDbg attached to your target game. In Windows, <span class="literal">recv()</span> is the API function to receive data from a socket. From the OllyDbg command line, you can set a breakpoint on <span class="literal">recv()</span> by entering the <span class="literal">bp recv</span> command. When the breakpoint is hit, you can climb the call stack using <small>CTRL</small>-F9, the shortcut for execute until return, and F8, the shortcut for step over. This combination essentially lets the program execute until the callee has returned to the caller, allowing you to climb the call stack in tandem with the game. At each stack level, you can inspect the code of each caller until you find one that has a big <span class="literal">switch()</span> statement; this should be the packet parser.</p>&#13;
<h5 class="h5" id="ch00lev1sec208"><strong>A Trickier Parser</strong></h5>&#13;
<p class="noindent">Depending on the game’s architecture, though, finding the parser function may not be that simple. Consider a game with a parser function that looks like this:</p>&#13;
<p class="programs">packetHandlers[PACKET_HEALTH_CHANGE] = onHealthChange;<br/>packetHandlers[PACKET_MANA_CHANGE] = onManaChange;<br/><br/>void parseNextPacket()<br/>{<br/>    if (!network-&gt;packetReady()) return;<br/>    auto packet = network-&gt;getPacket();<br/>    auto data = packet-&gt;decrypt();<br/>    auto handler = packetHandlers[data-&gt;getType()];<br/>    handler-&gt;invoke(data-&gt;getMessage());<br/>}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_208"/>Since the <span class="literal">parseNextPacket()</span> function doesn’t have a <span class="literal">switch()</span> statement, there’s no obvious way to identify it in memory. Unless you pay very close attention, you’ll likely climb right past it on the call stack. When a game has a parser function like this, trying to figure out what the parser function looks like might be pointless. If you don’t see a <span class="literal">switch()</span> statement when climbing the <span class="literal">recv()</span> call stack, you’ll have to note every callee on the call stack instead.</p>&#13;
<p class="indent">Instead of climbing up the call stack from the breakpoint, you’d go to every address marked as a <span class="literal">RETURN</span> below ESP in the OllyDbg stack pane. These are the return addresses into each caller for each callee. At each return address, you’d need to find the top of the caller in OllyDbg’s disassembly pane and note the address. As a result, you’d have a list of every function call leading up to the <span class="literal">recv()</span> call.</p>&#13;
<p class="indent">Next, you’d repeat the same list-making process from breakpoints placed on a few of the game’s handler functions. You can find a handler function by monitoring memory that it will inevitably use. The handler for a health change packet, for instance, will update your health in memory. Using OllyDbg, you can set a <em>memory on write</em> breakpoint to the health address. When the breakpoint gets triggered, it means the game updated the health value from a handler function. This should work the same way for most values that are controlled by the server. The server will control any game-critical values, such as health, mana, level, items, and so on.</p>&#13;
<p class="indent">Once you’ve recorded the call stack from <span class="literal">recv()</span> and a few handler functions, you can correlate them to locate the parser function. For example, consider the three pseudo–call stacks in <a href="ch10.xhtml#ch10tab1">Table 10-1</a>.</p>&#13;
<p class="tablecap"><a id="ch10tab1"/><strong>Table 10-1:</strong> Pseudo–Call Stacks for Three Packet-Related Functions</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><span class="literal">recv()</span> stack</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><span class="literal">onHealthChange()</span> stack</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><span class="literal">onManaChange()</span> stack</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x0BADF00D</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x101E1337</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x14141414</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x40404040</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x50505050</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x60606060</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x30303030</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x30303030</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x30303030</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20202020</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20202020</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20202020</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x10101010</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x10101010</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x10101010</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">These stacks show what memory might look like during a call to <span class="literal">recv()</span> and to a game’s hypothetical <span class="literal">onHealthChange()</span> and <span class="literal">onManaChange()</span> functions. Notice that each function originates from a chain of four common function <span epub:type="pagebreak" id="page_209"/>calls (shown in boldface). The deepest common address, 0xDEADBEEF, is the address of the parser. For a better understanding of this structure, look at the call stacks laid out in a tree view, as in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>.</p>&#13;
<div class="image"><img src="../images/f10-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch10fig1"/><em>Figure 10-1: Tree view of our three call stacks</em></p>&#13;
<p class="indent">Each function’s call stack branches out from the function at 0xDEADBEEF, meaning that function is a common point of origin for all three calls. The example <span class="literal">parseNextPacket()</span> function is responsible for calling these functions, so it must be the most recent common ancestor at 0xDEADBEEF.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>These call stacks are hypothetical, and they’re simplified beyond what you’ll typically encounter. Real call stacks will probably have quite a few more function calls, and comparing them won’t be as easy.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec209"><strong>A Hybrid Parsing System</strong></h5>&#13;
<p class="noindent">A third variation of the parsing loop might be a hybrid of the previous two that uses a <span class="literal">switch()</span> statement after a function call. Here’s another hypothetical function:</p>&#13;
<p class="programs">void processNextPacket()<br/>{<br/>    if (!network-&gt;packetReady()) return;<br/>    auto packet = network-&gt;getPacket();<br/>    auto data = packet-&gt;decrypt();<br/>    dispatchPacket(data);<br/>}<br/><br/>void dispatchPacket(data)<br/>{<br/>    switch (data-&gt;getType()) {<br/>    case PACKET_HEALTH_CHANGE:<br/>        processHealthChangePacket(data-&gt;getMessage());<br/>        break;<br/>    case PACKET_MANA_CHANGE:<br/>        processManaChangePacket(data-&gt;getMessage());<br/>        break;<br/>        // more cases for more data types<br/>    }<br/>}</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>The <span class="literal">processNextPacket()</span> function fetches a new packet and calls <span class="literal">dispatchPacket()</span> to handle the data. In this case, the <span class="literal">dispatchPacket()</span> function exists in the call stack of each handler, but not in the one for the <span class="literal">recv()</span> function. Look at the hypothetical stacks in <a href="ch10.xhtml#ch10tab2">Table 10-2</a>, for example.</p>&#13;
<p class="tablecap"><a id="ch10tab2"/><strong>Table 10-2:</strong> Pseudo–Call Stacks for Three Packet-Related Functions</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><span class="literal">recv()</span> stack</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><span class="literal">onHealthChange()</span> stack</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong><span class="literal">onManaChange()</span> stack</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x0BADF00D</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x101E1337</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x14141414</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x40404040</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00ABCDEF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x00ABCDEF</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0xDEADBEEF</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x30303030</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x30303030</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x30303030</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20202020</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20202020</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x20202020</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x10101010</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x10101010</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0x10101010</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Although these three functions have the same first four addresses in their call stacks, only the two handlers have one more address in common (again shown in boldface). That’s 0x00ABCDEF, and it’s the address of the <span class="literal">dispatchPacket()</span> function. Once again, you can imagine these laid out in a tree view, as in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>.</p>&#13;
<div class="image"><img src="../images/f10-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch10fig2"/><em>Figure 10-2: Tree view of our three call stacks</em></p>&#13;
<h5 class="h5" id="ch00lev1sec210"><strong>A Parser Hack</strong></h5>&#13;
<p class="noindent">Once you’ve located the function responsible for dispatching packets to their handlers, you’ll be able to spot every handler that can be called. You <span epub:type="pagebreak" id="page_211"/>can deduce a handler’s purpose by placing a breakpoint on it and watching what values change in memory when it executes. Then, you can hook any handlers that your bot needs to react to. (Flip back to <a href="ch08.xhtml#ch08">Chapter 8</a> if you need a refresher on how you might hook these functions. )</p>&#13;
<p class="indent">Of course, there are endless ways to implement network behavior. I can’t cover them all, but seeing these three common techniques should help you understand the methodology. No matter what game you’re dealing with, a breakpoint on <span class="literal">recv()</span> should be a step in the right direction.</p>&#13;
<h3 class="h3" id="ch00lev1sec211"><strong>Performing In-Game Actions</strong></h3>&#13;
<p class="noindent">Before a bot can react to events, you have to teach it to play the game. It needs to be able to cast spells, move around, and activate items. On this front, bots aren’t much different from people: they can just be told which buttons to press. Pressing buttons is simple and suffices in many cases, but in more intricate situations, a bot may have to communicate on the network and tell the server what it’s trying to do.</p>&#13;
<p class="indent">To follow along with the examples in this section and explore on your own afterward, open the files in the <em>GameHackingExamples/Chapter10_ ResponsiveHacks/</em> folder in this book’s resource files.</p>&#13;
<h4 class="h4" id="ch00lev1sec212"><strong><em>Emulating the Keyboard</em></strong></h4>&#13;
<p class="noindent">The most common buttons you’ll press in a game are keyboard keys, and there are a couple of ways you can teach your bot to type.</p>&#13;
<h5 class="h5" id="ch00lev1sec213"><strong>The SendInput() Function</strong></h5>&#13;
<p class="noindent">One common way to emulate the keyboard is with the <span class="literal">SendInput()</span> Windows API function. This function, which sends keyboard and mouse input to the topmost window, has the following prototype:</p>&#13;
<p class="programs">UINT SendInput(UINT inputCount, LPINPUT inputs, int size);</p>&#13;
<p class="indent">The first parameter, <span class="literal">inputCount</span>, is the number of inputs being sent. For the examples in this book, I’ll always use a value of <span class="literal">1</span>. The second parameter, <span class="literal">inputs</span>, is a pointer to a structure (or an array of structures whose length matches the <span class="literal">inputCount</span> value) with the predefined type <span class="literal">INPUT</span>. The final parameter is the size of inputs in memory, as calculated with the formula <span class="literal">size</span> = <span class="literal">inputCount</span> × <span class="literal">sizeof(INPUT)</span>.</p>&#13;
<p class="indent">The <span class="literal">INPUT</span> structure tells the <span class="literal">SendInput()</span> function what type of input to send, and the following code shows how you might initialize an instance of <span class="literal">INPUT</span> to press the F1 key:</p>&#13;
<p class="programs">INPUT input = {0};<br/>input.type = INPUT_KEYBOARD;<br/>input.ki.wVk = VK_F1;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_212"/>To have your bot actually press F1, you’d need to send this input twice, like so:</p>&#13;
<p class="programs">SendInput(1, &amp;input, sizeof(input));<br/>// change input to key up<br/>input.ki.dwFlags |= KEYEVENTF_KEYUP;<br/>SendInput(1, &amp;input, sizeof(input));</p>&#13;
<p class="indent">The first call to <span class="literal">SendInput()</span> presses F1, and the second releases it. The release happens not because the input was sent twice, but because the second call was made with the <span class="literal">KEYEVENTF_KEYUP</span> flag enabled in the <span class="literal">input</span> parameter’s keyboard flags field. Since setting up <span class="literal">input</span> for even a single key is a bit messy, it’s best to wrap everything inside a function. The result looks something like <a href="ch10.xhtml#ch10exe3">Listing 10-3</a>.</p>&#13;
<p class="programs">void sendKeyWithSendInput(WORD key, bool up)<br/>{<br/>    INPUT input = {0};<br/>    input.type = INPUT_KEYBOARD;<br/>    input.ki.wVk = key;<br/>    input.ki.dwFlags = 0;<br/><br/>    if (up)<br/>        input.ki.dwFlags |= KEYEVENTF_KEYUP;<br/>    SendInput(1, &amp;input, sizeof(input));<br/>}<br/>sendKeyWithSendInput(VK_F1, false); // press<br/>sendKeyWithSendInput(VK_F1, true);  // release</p>&#13;
<p class="listt"><a id="ch10exe3"/><em>Listing 10-3: A wrapper for emulating keystrokes with <span class="literal">SendInput()</span></em></p>&#13;
<p class="indent">This function initializes <span class="literal">input</span> with the given <span class="literal">key</span>, enables the flag <span class="literal">KEYEVENTF_KEYUP</span> if <span class="literal">up</span> is set, and calls the <span class="literal">SendInput()</span> function. This means <span class="literal">sendKeyWithSendInput()</span> must be called a second time to send the key release, even though the release is always required. The function is written this way because key combinations that involve modifiers like <small>SHIFT</small>, <small>ALT</small>, or <small>CTRL</small> must be sent a bit differently; the modifier’s press must come before the key’s press, but its release must come after the key’s release.</p>&#13;
<p class="indent">The following code shows how you’d use the <span class="literal">sendKeyWithSendInput()</span> function to tell a bot to press <small>SHIFT</small>-F1:</p>&#13;
<p class="programs">sendKeyWithSendInput(VK_LSHIFT, false); // press shift<br/>sendKeyWithSendInput(VK_F1, false);     // press F1<br/>sendKeyWithSendInput(VK_F1, true);      // release F1<br/>sendKeyWithSendInput(VK_LSHIFT, true);  // release shift</p>&#13;
<p class="indent">You’d have to call <span class="literal">sendKeyWithSendInput()</span> four times, but that’s still easier than using the code without a wrapper function.</p>&#13;
<h5 class="h5" id="ch00lev1sec214"><span epub:type="pagebreak" id="page_213"/><strong>The SendMessage() Function</strong></h5>&#13;
<p class="noindent">An alternative method for sending keystrokes relies on the <span class="literal">SendMessage()</span> Windows API function. This function allows you to send input to any window, even if it’s minimized or hidden, by posting data directly to the target window’s message queue. This advantage makes it the method of choice for game hackers, because it enables users to do other things while their bot plays the game in the background. <span class="literal">SendMessage()</span> has the following prototype:</p>&#13;
<p class="programs">LRESULT SendMessage(<br/>    HWND window,<br/>    UINT message,<br/>    WPARAM wparam,<br/>    LPARAM lparam);</p>&#13;
<p class="indent">The first parameter, <span class="literal">window</span>, is a handle to the window that the input is being sent to. The second parameter, <span class="literal">message</span>, is the type of input being sent; for keyboard input, this parameter is <span class="literal">WM_KEYUP</span>, <span class="literal">WM_KEYDOWN</span>, or <span class="literal">WM_CHAR</span>. The third parameter, <span class="literal">wparam</span>, should be the key code. The final parameter, <span class="literal">lparam</span>, should be <span class="literal">0</span> when the message is <span class="literal">WM_KEYDOWN</span> and <span class="literal">1</span> otherwise.</p>&#13;
<p class="indent">Before you can use the <span class="literal">SendMessage()</span> function, you must obtain a handle to the target process’s main window. Given the title of the window, you can obtain a handle using the <span class="literal">FindWindow()</span> Windows API function, as follows:</p>&#13;
<p class="programs">auto window = FindWindowA(NULL, "Title Of Game Window");</p>&#13;
<p class="indent">With a valid window handle, making a call to <span class="literal">SendMessage()</span> looks something like this:</p>&#13;
<p class="programs">SendMessageA(window, WM_KEYDOWN, VK_F1, 0);<br/>SendMessageA(window, WM_KEYUP, VK_F1, 0);</p>&#13;
<p class="indent">The first call presses the F1 key, and the second call releases it. Keep in mind, however, that this series of calls works only for keys that don’t input text, like F1, <small>INSERT</small>, or <small>TAB</small>. To have your bot press keys that input text, you must also send a <span class="literal">WM_CHAR</span> message between the down and up messages. To type W, for instance, you’d do something like this:</p>&#13;
<p class="programs">DWORD key = (DWORD)'W';<br/>SendMessageA(window, WM_KEYDOWN, key, 0);<br/>SendMessageA(window, WM_CHAR, key, 1);<br/>SendMessageA(window, WM_KEYUP, key, 1);</p>&#13;
<p class="indent">This creates a <span class="literal">key</span> variable so the letter key to press can be changed easily. Then it follows the same steps the F1 example used, just with a <span class="literal">WM_CHAR</span> message in between.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_214"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can actually send nothing but the</em> <span class="literal"><span class="codeitalic">WM_CHAR</span></span> <em>message and get the same result, but it’s best practice to send all three messages. Game developers can easily shut down bots by patching the game to ignore</em> <span class="literal"><span class="codeitalic">WM_CHAR</span></span> <em>messages that don’t follow</em> <span class="literal"><span class="codeitalic">WM_KEYDOWN</span></span><em>, and they can even use it as a way to detect your bot and ban you.</em></p>&#13;
</div>&#13;
<p class="indent">As I showed with the <span class="literal">SendInput()</span> technique, you can create a wrapper around this functionality to make your bot code easier to work with. The wrapper looks something like this:</p>&#13;
<p class="programs">void sendKeyWithSendMessage(HWND window, WORD key, char letter)<br/>{<br/>    SendMessageA(window, WM_KEYDOWN, key, 0);<br/>    if (letter != 0)<br/>        SendMessageA(window, WM_CHAR, letter, 1);<br/>    SendMessageA(window, WM_KEYUP, key, 1);<br/>}</p>&#13;
<p class="indent">Unlike <a href="ch10.xhtml#ch10exe3">Listing 10-3</a>, this wrapper actually sends both the press and release. This is because <span class="literal">SendMessage()</span> can’t be used to send keystrokes with modifiers, so there’s never any need to insert code between the two calls.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There are multiple ways a game might check whether a modifier key is pressed, though. You might be able to send modifier keys to certain games by calling the</em> <span class="literal"><span class="codeitalic">SendMessage()</span></span> <em>function, but it depends on how those games detect modifiers.</em></p>&#13;
</div>&#13;
<p class="indent">You can use this wrapper in a similar way as the one in <a href="ch10.xhtml#ch10exe3">Listing 10-3</a>. For example, this code sends F1 followed by W:</p>&#13;
<p class="programs">sendKeyWithSendMessage(window, VK_F1, 0);<br/>sendKeyWithSendMessage(window, 'W', 'W');</p>&#13;
<p class="indent">This example, like all of the <span class="literal">SendMessage()</span> code I’ve shown so far, simply gets the job done. It can input text, but it doesn’t exactly send proper messages.</p>&#13;
<p class="indent">There are a lot of small details you have to get right if you want to send 100 percent valid messages with the <span class="literal">SendMessage()</span> function. For instance, the first 16 bits of <span class="literal">lparam</span> should store the number of times the key has been automatically repeated as a result of being held down. The next 8 bits should store the <em>scan code</em>, a key identifier that is specific to each keyboard manufacturer. The next bit, number 24, should be set only if the button is on an extended part of the keyboard, such as the number pad. The following 4 bits are undocumented, and the next bit should be set only if the <small>ALT</small> key was down when the message originated. The last 2 bits are the previous state flag and the transition state flag. The previous state flag is set only if the key was previously down, and the transition state is set only if the key was previously in the state opposite its current position (that is, if the key is now up and was previously down, or vice versa).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>Thankfully, the average game doesn’t consider most of these values. For that matter, the average piece of software doesn’t care about them either. If you have to fill all of these values with proper data to make your bot work, you’re moving in the wrong direction. There are many other ways to perform actions, the majority of which are simpler than trying to emulate the exact behavior of the operating system’s kernel-level keyboard input handler/dispatcher. In fact, there’s already a function that does that, and I’ve already talked about it: the <span class="literal">SendInput()</span> function.</p>&#13;
<p class="indent">You can also control the mouse with the <span class="literal">SendInput()</span> and <span class="literal">SendMessage()</span> functions, but I highly recommend avoiding it. Any mouse commands you send will affect, and be affected by, any legitimate mouse movements, mouse clicks, or keystrokes sent by the player. The same is true for keyboard input, but the complications are much rarer.</p>&#13;
<h4 class="h4" id="ch00lev1sec215"><strong><em>Sending Packets</em></strong></h4>&#13;
<p class="noindent">Before a game draws a frame, it checks for keyboard and mouse input. When it receives input that results in an action, such as moving around or casting a spell, it checks to make sure the action is possible and, if so, tells the game server that the action has been performed. The game code to check for events and alert the server often looks something like this:</p>&#13;
<p class="programs">void processInput() {<br/>    do {<br/>        auto input = getNextInput();<br/>        if (input.isKeyboard())<br/>            processKeyboardInput(input);<br/>        // handle other input types (e.g., mouse)<br/>    } while (!input.isEmpty());<br/>}<br/>void processKeyboardInput(input) {<br/>    if (input.isKeyPress()) {<br/>        if (input.getKey() == 'W')<br/>            step(FORWARD);<br/>        else if (input.getKey() == 'A')<br/>            step(BACKWARD);<br/>        // handle other keystrokes (e.g., 'S' and 'D')<br/>    }<br/>}<br/>void step(int direction) {<br/>    if (!map-&gt;canWalkOn(player-&gt;position))<br/>        return;<br/>    playerMovePacket packet(direction);<br/>    network-&gt;send(packet);<br/>}</p>&#13;
<p class="indent">The <span class="literal">processInput()</span> function is called every frame. The function iterates over all pending inputs and dispatches different types of inputs to their relevant handlers. In this case, when keyboard input is received, it’s dispatched <span epub:type="pagebreak" id="page_216"/>to the <span class="literal">processKeyboardInput()</span> function. This handler then checks whether the key is either W or S, and, if so, calls <span class="literal">step()</span> to move the player in the corresponding direction.</p>&#13;
<p class="indent">Since <span class="literal">step()</span> is used to perform an action, it is called an <em>actor</em> function. The invocation of an actor function is called <em>actuation</em>. You can directly call a game’s actor functions from your bot to perform an action while completely bypassing the input layer.</p>&#13;
<p class="indent">Before you can call an actor, though, you must find its address. To do this, you can attach OllyDbg to the game, open the command line, and enter <span class="literal">bp send</span>. This will place a breakpoint on the <span class="literal">send()</span> function, which is used to send data over the network. When you play the game, every time you take a step, cast a spell, pick up loot, or do anything else, your breakpoint should trigger, and you can note each function in the call stack.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The game should call</em> <span class="literal"><span class="codeitalic">send()</span></span> <em>every time you do anything while playing. Pay attention to what you did before each</em> <span class="literal"><span class="codeitalic">send()</span></span> <em>breakpoint is hit, as that will give you a rough idea of what action each call is communicating to the server, and, ultimately, what the actor you find is responsible for.</em></p>&#13;
</div>&#13;
<p class="indent">Once you have a few different call stacks, you can compare them to locate the actor functions. To see how to spot the actor functions, let’s compare the two annotated call stacks in <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>.</p>&#13;
<div class="image"><img src="../images/f10-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch10fig3"/><em>Figure 10-3: Tree view of call stacks to two actor functions</em></p>&#13;
<p class="indent">Like these two stacks, the call stacks you find should be identical at the top, sharing a couple of common functions responsible for generic network transmission. They should also be identical on the bottom, since each call to <span class="literal">send()</span> should have originated from the <span class="literal">processInput()</span> function. Each stack should have some unique functions between these identical regions, <span epub:type="pagebreak" id="page_217"/>though, and those are the actor functions you’re looking for. Typically, the function of interest is immediately beneath the common network calls. In this case, the two actors are the <span class="literal">step()</span> and <span class="literal">castSpell()</span> functions.</p>&#13;
<p class="indent">After hacking the same game for a while, you’ll learn how far up the stack the actor functions are from the <span class="literal">send()</span> call. In <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>, for example, the actors happen three calls before the <span class="literal">send()</span> call. Knowing this, you could just climb the stack in OllyDbg (<small>CTRL</small>-F9 followed by F8) three times when your <span class="literal">send()</span> breakpoint is hit and be inside the actor function that sent the data.</p>&#13;
<p class="indent">Once you’ve found an actor function, you can call it from an injected DLL. Here’s how you might call <span class="literal">step()</span> if you found it at 0xDEADBEEF:</p>&#13;
<p class="programs">typedef void _step(int direction);<br/>auto stepActor = (_step*)0xDEADBEEF;<br/><br/>stepActor(FORWARD);</p>&#13;
<p class="indent">Since the bot won’t know the actual name for this game function, the code assigns the contents of memory at 0xDEADBEEF to a conveniently named variable: <span class="literal">stepActor</span>. Then, the code just calls <span class="literal">stepActor()</span> like any other function.</p>&#13;
<p class="indent">If you’ve got the right address, function prototype, and parameters, this should work beautifully; you’ll be able to automate actions as if you have access to the game’s source code. Just make sure to call the actor functions from inside the same thread as the game, or you can run into threading issues. The best way to do this is to call the actors from a hook on a major function like Direct3D’s <span class="literal">EndScene()</span> or the Windows API’s <span class="literal">PeekMessage()</span> function, as these functions will usually be called only from the game’s main thread.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>USING THIS TO CALL _ _THISCALL</strong></p>&#13;
<p class="noindent">If you try to call an actor function that’s a nonstatic member of a class, the function will have a <span class="literal">_thiscall</span> calling convention, which means you’ll need to pass the instance of the class on the ECX register. (You can brush up on calling conventions in “<a href="ch04.xhtml#ch00lev1sec98">Function Calls</a>” on <a href="ch04.xhtml#page_94">page 94</a>.) Passing the instance is straightforward, but you’ll have to locate a pointer chain to the class instance first.</p>&#13;
<p class="indent">To find the pointer chain, you can drop a breakpoint on the actor function, grab the class instance value from ECX when the breakpoint kicks, and throw that value into a Cheat Engine pointer scan. Then, to call the function, you’d walk the pointer chain, obtain the current instance address, and use inline assembly to set up ECX and make the actual function call. This process works similarly to the way VF hook callbacks call their original counterparts, as shown in “<a href="ch08.xhtml#ch00lev1sec158">Writing a VF Table Hook</a>” on <a href="ch08.xhtml#page_156">page 156</a>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec216"><span epub:type="pagebreak" id="page_218"/><strong>Tying the Pieces Together</strong></h3>&#13;
<p class="noindent">After you’ve created frameworks for observing events and performing actions, you can tie them together to create responsive hacks. Responsive hacks come in many flavors, but there are a few common ones.</p>&#13;
<h4 class="h4" id="ch00lev1sec217"><strong><em>Making the Perfect Healer</em></strong></h4>&#13;
<p class="noindent">A favorite bot among gamers is <em>autohealing</em>, a hack that automatically uses a healing spell when the player’s health decreases drastically or drops below a certain threshold. Given a way to detect changes in health and an actor function to cast spells, an autohealer might look something like this:</p>&#13;
<p class="programs">void onHealthDecrease(int health, int delta) {<br/>    if (health &lt;= 500)     // health below 500<br/>        castHealing();<br/>    else if (delta &gt;= 400) // large drop in health<br/>        castHealing();<br/>}</p>&#13;
<p class="indent">This autohealing function is pretty simple, but it works well. More advanced autohealers might have many more levels of healing and be able to learn as they go. You’ll get working example code and an in-depth explanation of advanced autohealers in “<a href="ch11.xhtml#ch00lev1sec221">Control Theory and Game Hacking</a>” on <a href="ch11.xhtml#page_222">page 222</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec218"><strong><em>Resisting Enemy Crowd-Control Attacks</em></strong></h4>&#13;
<p class="noindent"><em>Anti-crowd-control</em> hacks detect incoming <em>crowd-control attacks</em> and automatically cast spells that reduce their effects or completely negate them. Crowd-control attacks disable players in some way, so having enemies cast them on you can be a pain.</p>&#13;
<p class="indent">Given a way to detect incoming or active crowd-control effects, such as by detecting a Direct3D model or by intercepting an incoming packet, and an actor function to cast spells, you could have a bot react instantly to such attacks like so:</p>&#13;
<p class="programs">void onIncomingCrowdControl() {<br/>    // cast a shield to block the crowd control<br/>    castSpellShield();<br/>}<br/>void onReceiveCrowdControl() {<br/>    // cleanse crowd control that has already taken effect<br/>    castCleanse();<br/>}</p>&#13;
<p class="indent">An <span class="literal">onIncomingCrowdControl()</span> function might try to stop the crowd-control spell from ever hitting you. Failing that, the bot could call an <span class="literal">onReceiveCrowdControl()</span> spell to remove the effects.</p>&#13;
<h4 class="h4" id="ch00lev1sec219"><span epub:type="pagebreak" id="page_219"/><strong><em>Avoiding Wasted Mana</em></strong></h4>&#13;
<p class="noindent"><em>Spell trainers</em> are also quite common among botters. Spell trainers wait until the player has full mana and then cast spells to increase the player’s magic level or stats. This allows players to quickly increase their magic skills, as they will never waste mana regeneration just because they have full mana.</p>&#13;
<p class="indent">Given a way to detect changes in mana and an actor function to cast spells, a bot might include the following pseudocode for a spell trainer:</p>&#13;
<p class="programs">void onManaIncrease(int mana, int delta) {<br/>    if (delta &gt;= 100) // player is using mana potions,<br/>        return;       // they must need the mana, abort<br/>    if (mana &gt;= MAX_MANA - 10) // mana is nearly full, waste some<br/>        castManaWasteSpell();<br/>}</p>&#13;
<p class="indent">This function takes the player’s mana and the increase in that player’s mana (<span class="literal">delta</span>) as parameters. If the increase in mana is above a certain amount, it assumes the player is using potions or other items to replenish mana, and it won’t cast any extra spells. Otherwise, if the player has plenty of mana, the function fires off any old spell to get the player some experience points.</p>&#13;
<p class="indent">Other common responsive hacks are <em>autoreload</em> to instantly reload ammo, <em>autododge</em> to evade incoming projectiles, and <em>autocombo</em> to instantly attack the same target as a nearby ally. Really, the only limit to the number of responsive hacks you can add to a bot is the number of events your bot can observe in the game, multiplied by the number of valid and helpful responses it can send for each event.</p>&#13;
<h3 class="h3" id="ch00lev1sec220"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">Using hooks, memory manipulation, and keyboard simulation, you can begin creating your first responsive hacks. These hacks are your entry point into gaming autonomy, but they’re only a glimpse of what’s possible. <a href="ch11.xhtml#ch11">Chapter 11</a> will be the pinnacle of your game-hacking adventure. Using everything you’ve learned so far, and building on the principles of responsive hacks, you’ll learn how to automate advanced actions and create a truly autonomous bot.</p>&#13;
<p class="indent">If you’re not feeling quite ready to go deeper, I strongly recommend reviewing the earlier material and then getting some practice in an isolated environment on your own machine. Implementing bots like this is a lot easier than you might think, and it’s an amazingly satisfying experience. Once you’re comfortable making autohealers and other basic responsive hacks, you’ll be ready to start completely automating gameplay.<span epub:type="pagebreak" id="page_220"/></p>&#13;
</body></html>