- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 1 USING JAVASCRIPT
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 使用 JavaScript
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: JavaScript has evolved and added significant functionality since its original
    1995 version. The addition of *classes* to the language aided with object-oriented
    programming so that you no longer need to work with complex prototypes. *Destructuring*
    and *spread* operators have simplified working with objects and arrays, and they
    allow you to manage multiple assignments at once. The introduction of *arrow functions*
    lets you work in a more succinct, expressive way, enhancing JavaScript’s functional
    programming capability. Finally, the concept of *modules* has simplified code
    organization and lets you partition and group your code in logical ways. This
    chapter briefly explores these
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1995年首次发布以来，JavaScript已经发展并增加了许多重要功能。*类*的引入帮助了面向对象编程，使得你不再需要与复杂的原型打交道。*解构*和*扩展*运算符简化了对象和数组的操作，并且允许你一次管理多个赋值。*箭头函数*的引入使得你能够以更简洁、更具表现力的方式工作，增强了
    JavaScript 的函数式编程能力。最后，*模块*的概念简化了代码组织，并允许你以逻辑的方式对代码进行分区和分组。本章简要探讨了这些特性
- en: modern features of the language that help you write better, shorter, more understandable
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的语言特性帮助你编写更好、更简洁、更易理解的代码。
- en: The JavaScript language isn’t the only thing that has evolved, however, so this
    chapter also will introduce some of the many tools that are now available to help
    you develop JavaScript code. Environments like Visual Studio Code with special
    fonts provide better code readability. Other tools help produce documented, well-formatted
    code, and validation utilities can detect static or type-related errors. In addition,
    many online tools exist to help deal with incompatibilities among browsers and
    servers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript 语言并不是唯一发生变化的东西，本章还将介绍一些现在可用的工具，这些工具可以帮助你开发 JavaScript 代码。像 Visual
    Studio Code 这样的环境提供了更好的代码可读性。其他工具帮助生成文档化、格式良好的代码，而验证工具可以检测静态或与类型相关的错误。此外，许多在线工具存在，帮助解决浏览器和服务器之间的不兼容问题。
- en: Modern JavaScript Features
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现代 JavaScript 特性
- en: 'We’ll start with an exploration of some modern JavaScript features that will
    simplify coding: arrow functions, classes, spreading values, destructuring, and
    modules. This list isn’t exhaustive, and we’ll look at other features in later
    chapters, including functional programming, map/reduce and similar array methods,
    functions as first-class objects, recursion, and more. We certainly can’t cover
    all of the language’s features, but here the focus is on the most important and
    newer features that are used throughout the book.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些简化编码的现代 JavaScript 特性开始探索：箭头函数、类、扩展值、解构和模块。这个列表并不全面，我们将在后续章节中探讨其他特性，包括函数式编程、map/reduce
    等数组方法、函数作为一等公民、递归等。我们当然无法覆盖语言的所有特性，但本书的重点是最重要的和较新的特性。
- en: Arrow Functions
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'JavaScript provides many ways to specify a function, such as:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了多种定义函数的方式，例如：
- en: 'Named functions, which are the most common: function alpha() {...}'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有名函数，这是最常见的：function alpha() {...}
- en: 'Nameless function expressions: const bravo = function () {...}'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无名函数表达式：const bravo = function () {...}
- en: 'Named function expressions: const charlie = function something() {...}'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有名函数表达式：const charlie = function something() {...}
- en: 'Function constructors: const delta = new Function()'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数构造器：const delta = new Function()
- en: 'Arrow functions: const echo = () => {...}'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数：const echo = () => {...}
- en: 'All of those definitions work basically the same way, but arrow functions—JavaScript’s
    new kids on the block—have these important differences:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些定义的工作原理基本相同，但箭头函数——JavaScript 新的“成员”——有这些重要的区别：
- en: They may return a value even without including a return statement.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们即使不包含 return 语句，也可能返回一个值。
- en: They cannot be used as constructors or generators.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能作为构造器或生成器使用。
- en: They don’t bind the this value.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会绑定 this 值。
- en: They don’t have an arguments object or a prototype property.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有 arguments 对象或 prototype 属性。
- en: 'In particular, the first characteristic in the previous list is used a lot
    in this book; being able to omit the return keyword will make for shorter, more
    succinct code. For example, in [Chapter 12](chapter12.xhtml), you will see the
    following function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，前面列表中的第一个特性在本书中被广泛使用；能够省略 return 关键字将使代码更简短、更简洁。例如，在[第12章](chapter12.xhtml)中，你将看到如下的函数：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Given a tree argument, this function returns 0 if the tree is empty; otherwise,
    it returns the tree object’s height attribute.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个树的参数，该函数在树为空时返回0；否则，返回树对象的高度属性。
- en: 'The following example uses return and is an equivalent (but longer) way to
    write the same function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`return`，是一种等效的（但较长的）方式来编写相同的函数：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The longer version isn’t necessary: shorter code is good.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的版本并不是必要的：简短的代码更好。
- en: 'If you use the shortened version and want to return an object, you need to
    enclose it in parentheses. Here’s another arrow function example from [Chapter
    12](chapter12.xhtml):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用简化版本并想要返回一个对象，你需要将其括在圆括号中。这里是[第12章](chapter12.xhtml)中的另一个箭头函数示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Given a key, this function returns a node (an object, in fact) with that key
    as an attribute, plus null left and right links and a height attribute set to
    1.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个键，该函数返回一个节点（实际上是一个对象），该节点以该键作为属性，并且左、右链接为null，且高度属性设置为1。
- en: 'Another common feature of the arrow function is providing default values for
    missing parameters:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的另一个常见特性是为缺失的参数提供默认值：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will see what this code does in [Chapter 12](chapter12.xhtml), but the interesting
    part is that the recursive function, if not provided with a value for s, will
    initialize it with the empty string.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第12章](chapter12.xhtml)中看到这段代码的作用，但有趣的是，如果递归函数没有提供`s`的值，它会将其初始化为空字符串。
- en: Classes
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类
- en: Although we won’t use classes much in this book, modern JavaScript has come
    far from its beginnings, and instead of having to deal with the prototype and
    adding tangled code to implement inheritance, now you can achieve inheritance
    easily. In the past you could use classes and subclasses, different constructors,
    and all of that, but implementing inheritance wasn’t easy. JavaScript classes
    now make it much more straightforward. (See *[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)*
    if you want to learn how to do inheritance in old-style JavaScript.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本书中我们不会大量使用类，但现代JavaScript已经远远超出了它的起点，现在，你不再需要处理原型和添加复杂代码来实现继承，而是可以轻松地实现继承。在过去，你可以使用类和子类、不同的构造函数等等，但实现继承并不容易。现在，JavaScript类使这一切变得更加简单。（如果你想了解如何在旧式JavaScript中做继承，请参见*[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)*。）
- en: 'Take a look at a partial, slightly modified example from [Chapter 13](chapter13.xhtml)
    that shows an actual class and how to define it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[第13章](chapter13.xhtml)中的一个部分修改过的示例，展示了一个实际的类以及如何定义它：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can either define a simple class, as is the case here ❶, or extend an existing
    one. For instance, you could have another class BinaryTree extends Tree to define
    a class based on Tree. You can define attributes outside a constructor ❷; you
    don’t need to do it inside a constructor ❸. Constructors are available if you
    need more complex object instance initialization.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个简单的类，就像这里的情况❶，或者扩展一个现有的类。例如，你可以有另一个类`BinaryTree extends Tree`来基于`Tree`定义一个类。你可以在构造函数外部定义属性❷；你不必在构造函数内部定义它❸。如果需要更复杂的对象实例初始化，构造函数是可用的。
- en: Getters ❹ and setters ❺ are other powerful features. They bind an object’s property
    to functions that are invoked whenever we try to modify or access that property.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器❹和设置器❺是其他强大的功能。它们将对象的属性绑定到函数，这些函数在我们尝试修改或访问该属性时被调用。
- en: Other features not used in this example are static properties and methods; such
    attributes aren’t part of the class instances, but rather belong to the class
    itself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中未使用的其他功能是静态属性和方法；这些属性不是类实例的一部分，而是属于类本身。
- en: NOTE
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Starting with ECMAScript 2022, JavaScript also includes* private *properties:
    fields, methods, getters, setters, and so on.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*从ECMAScript 2022开始，JavaScript还包括* 私有 *属性：字段、方法、获取器、设置器等等。*'
- en: The Spread Operator
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: The spread operator (...) allows you to, well, *spread* an array, string, or
    object into separate values in a single operation, providing some interesting
    array and object usages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符（...）允许你将数组、字符串或对象“*展开*”成单独的值，提供了一些有趣的数组和对象用法。
- en: 'Arrays are applied like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的应用如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Entering ...myArray is the same as entering 3, 1, 4, 1, 5, 9, 2, 6, so the first
    usage of ...myArray in this example produces 9 ❶, and the second provides a new
    array with exactly the same elements of myArray ❷.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`...myArray`与输入`3, 1, 4, 1, 5, 9, 2, 6`是一样的，所以这个例子中第一次使用`...myArray`产生了`9
    ❶`，第二次则提供了一个具有与`myArray`完全相同元素的新数组 ❷。
- en: 'You can also use the spread operator to build a copy of an object, which you
    can then modify independently:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用展开运算符来构建对象的副本，然后可以独立地修改它：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, newObject ❶ first gets a copy of the attributes of myObject, and
    then the year attribute is overwritten. You could do this “the old way” with many
    individual assignments, but using the spread operator allows for shorter and clearer
    code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`newObject` ❶首先获得`myObject`的属性副本，然后`year`属性被覆盖。你也可以用“旧方法”通过多个单独的赋值来完成，但使用展开运算符可以让代码更简短、更清晰。
- en: A third usage of the spread operator is for functions that need to deal with
    an undefined number of parameters. Earlier versions of JavaScript had the arguments
    array-like object to handle this situation. The arguments object is “array-like,”
    because .length is the only array property it provides. The arguments object doesn’t
    include any other properties that arrays have.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符的第三种用法是用于处理需要处理不确定数量参数的函数。早期版本的JavaScript使用`arguments`类数组对象来处理这种情况。`arguments`对象是“类数组的”，因为它唯一提供的数组属性是`.length`。`arguments`对象不包含数组的其他属性。
- en: 'For example, you could write your own Math.max() version like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以像这样编写你自己的Math.max()版本：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You could now use myMax() like you’d use Math.max(), but there’s no reason to
    reinvent that function. This example shows how you can imitate the features of
    existing functions—in this case, the ability to pass many arguments to a function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以像使用`Math.max()`一样使用`myMax()`，但没有必要重新发明这个函数。这个例子展示了如何模仿现有函数的功能——在这个例子中，即能够将多个参数传递给函数。
- en: The Destructuring Statement
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解构赋值语句
- en: 'The *destructuring* statement is related to the spread operator. It allows
    you to assign several variables at the same time, which means you can combine
    several independent assignments into one and write shorter code. For example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*解构赋值*语句与展开运算符有关。它允许你同时为多个变量赋值，这意味着你可以将多个独立的赋值操作合并为一个，从而编写更简洁的代码。例如：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, you assign "Abraham" to the first variable and "Lincoln" to the
    last variable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将`"Abraham"`赋值给第一个变量，将`"Lincoln"`赋值给最后一个变量。
- en: 'You also can mix destructuring and spreading:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以混合使用解构赋值和展开运算符：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Assign the initial elements in the array to first and last, as in the previous
    example, and assign all of the rest of the elements (the two numbers) to the years
    array. This combination lets you write code more succinctly, using a single statement,
    where previously several would have been required.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的例子一样，将数组中的初始元素赋值给`first`和`last`，并将剩余的元素（这两个数字）赋值给`years`数组。这个组合让你能够更简洁地编写代码，用一个语句代替原本需要多个语句的情况。
- en: 'In addition, you can use default values when variables on the left side have
    no corresponding values on the right:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当左侧变量没有对应的右侧值时，你可以使用默认值：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the destructuring statement assigns a default value to role
    and leaves party undefined.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，解构赋值语句为`role`指定了默认值，而`party`则保持未定义。
- en: 'You can also swap or rotate variables, which is a technique used frequently
    later in this book. Consider this line from code in [Chapter 14](chapter14.xhtml):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以交换或旋转变量，这是本书后面常用的一种技巧。考虑以下[第14章](chapter14.xhtml)中的代码：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This directly swaps the values of heap[p] and heap[i] without using an auxiliary
    variable. You also could write something like [d, e, f] = [e, f, d] to rotate
    the values of three variables, again without requiring more variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码直接交换了`heap[p]`和`heap[i]`的值，而无需使用辅助变量。你还可以像这样写`[d, e, f] = [e, f, d]`来旋转三个变量的值，同样无需更多的变量。
- en: 'Finally, another pattern that we’ll often use is to return two or more values
    at once from a function. For example, you could write a function to return two
    values in order:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们经常使用的另一种模式是一次从函数返回两个或更多的值。例如，你可以编写一个函数来按顺序返回两个值：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The other way of returning many values at once is with an object. You still
    can do that, but returning an array and using destructuring is more compact.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种一次返回多个值的方法是使用对象。你仍然可以这样做，但返回一个数组并使用解构赋值更加简洁。
- en: Modules
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块
- en: '*Modules* allow you to split code into pieces you can import when needed, providing
    a way to package functionality that is easier to understand and maintain. Each
    module should be an aggregation of related functions and classes, providing a
    set of features. A standard practice related to using modules is *high cohesion*,
    which means elements you put together should truly belong together, as unrelated
    functionalities should not be mixed in the same module. A related concept called
    *low coupling* means that distinct modules should be interdependent as little
    as possible. JavaScript lets you package functions in modules to provide a well-structured
    design, with greater readability and maintainability.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 允许您将代码拆分成可根据需要导入的部分，提供了一种更易于理解和维护的功能封装方式。每个模块应是相关函数和类的集合，提供一组功能。使用模块的标准做法之一是
    *高内聚性*，即将相关的元素放在一起，而不相关的功能不应混合在同一个模块中。一个相关的概念叫做 *低耦合*，意味着不同模块之间的依赖关系应尽可能少。JavaScript
    允许您将函数封装在模块中，从而提供结构良好的设计，具有更好的可读性和可维护性。'
- en: 'Modules come in two formats: *CommonJS modules* (an earlier format, used mostly
    in Node.js) and *ECMAScript modules* (the latest format, generally used by browsers).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模块有两种格式：*CommonJS 模块*（一种较早的格式，主要用于 Node.js）和 *ECMAScript 模块*（最新的格式，通常由浏览器使用）。
- en: '##### CommonJS Modules'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '##### CommonJS 模块'
- en: 'With CommonJS modules, write the code in the style of this (abridged) example
    from [Chapter 16](chapter16.xhtml):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CommonJS 模块时，请按照 [第16章](chapter16.xhtml) 中的（简化）示例编写代码：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The module.exports assignment at the end ❸ defines what parts of the module
    will be visible from the outside; whatever is not included ❶ ❷ won’t be accessible
    for the rest of the system. This way of writing code is well aligned with the
    *black box* software concept. Users of a module shouldn’t need to learn or even
    know about its internal details to allow for higher maintainability. As long as
    the module keeps providing the same functionality, its developers are free to
    refactor or improve it without impacting any users.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 module.exports 赋值 ❸ 定义了模块外部可见的部分；任何不包含的部分 ❶ ❷ 将无法被系统的其他部分访问。这种编写代码的方式与 *黑箱*
    软件概念高度一致。模块的使用者不需要了解其内部细节，从而可以实现更高的可维护性。只要模块保持相同的功能，开发者可以自由地重构或改进模块，而不会影响任何使用者。
- en: 'If you wanted to import a pair of the functions that the module exports, for
    example, you’d use the following code style, which employs destructuring, to specify
    what you want:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想导入模块导出的两个函数，例如，您可以使用以下代码风格，它采用解构赋值来指定您需要的内容：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This allows access (via destructuring) to the newRadixTree() and add() functions,
    out of all the functions exported by the radix_tree module. If you want to add
    something to the Radix tree, you can call add() directly; similarly, you can call
    newRadixTree() to create a new tree.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以通过解构赋值访问 radix_tree 模块导出的所有函数中的 newRadixTree() 和 add() 函数。如果您想向 Radix 树中添加内容，可以直接调用
    add()；同样，您可以调用 newRadixTree() 来创建一棵新树。
- en: 'Of course, you can also do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以这样做：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In order to add something to a tree or create a new one, you have to call RadixTree.add()
    and RadixTree.newRadixTree() instead. This usage makes for longer code, but it
    also lets you access all the functions in the radix_tree module. I prefer the
    first style that employs destructuring, because it makes clear what I am using,
    but it’s really up to you.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 若要向树中添加内容或创建新树，您必须分别调用 RadixTree.add() 和 RadixTree.newRadixTree()。这种用法虽然导致代码更长，但也让您能够访问
    radix_tree 模块中的所有功能。我更喜欢采用第一种解构赋值的风格，因为它明确了我正在使用的内容，但最终选择还是由您决定。
- en: ECMAScript Modules
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ECMAScript 模块
- en: 'The more modern ECMAScript style of defining modules also works with separate
    files, but instead of creating a module.exports object, you rewrite the module
    you just saw in the previous section as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更现代的 ECMAScript 模块定义风格也支持独立文件，但您需要将上一节中的模块重写为以下格式，而不是创建一个 module.exports 对象：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can export something directly wherever you define it ❶ ❷ or postpone doing
    so until the end ❸. Both methods work (and I don’t think anybody would really
    use *both* styles, as I did for this example), but most people prefer having all
    export statements together at the end. It’s really your choice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在定义的地方直接导出某些内容 ❶ ❷，也可以推迟到最后 ❸ 才进行导出。两种方法都可以（我认为没有人会像我在这个例子中那样同时使用*两种*风格），但大多数人更喜欢将所有导出语句集中放在最后。最终选择还是由您决定。
- en: NOTE
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can also use ECMAScript* import *and* export *statements in Node.js, but
    only if you use the .mjs extension instead of the .js extension, which is reserved
    for CommonJS modules.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以在 Node.js 中使用 ECMAScript* 的 import *和* export *语句，但前提是你使用 .mjs 扩展名，而不是保留给
    CommonJS 模块的 .js 扩展名。*'
- en: 'You can import functions from an ECMAScript module in the following way, which
    is a different usage in comparison with the CommonJS modules, although the end
    result is exactly the same:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式从 ECMAScript 模块导入函数，这与 CommonJS 模块的使用方法不同，尽管最终结果是完全一样的：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to import everything, use the following code instead; this will
    give you access to an object, including all the functions exported by the module,
    as earlier:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想导入所有内容，可以使用以下代码；这将让你访问一个对象，包括该模块导出的所有函数，就像之前一样：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All the exports you’ve seen so far are *named* exports; you can have as many
    of them as you want, and you can also have a single unnamed default export. In
    a given file, instead of defining what you want to export, as described earlier,
    you include something like this instead:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止你看到的所有导出都是*命名*导出；你可以有任意多个这样的导出，也可以有一个未命名的默认导出。在给定文件中，你不需要像之前描述的那样定义你想要导出的内容，而是包含类似这样的内容：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, in other parts of the code, you can do the following to import something:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在代码的其他部分，你可以按照以下方式导入某些内容：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can name what you imported whatever you like (whatever isn’t a good name)
    instead of using the name the module creator intended. That isn’t usual practice,
    but sometimes name conflicts arise when using modules by different authors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将导入的内容命名为你喜欢的任何名字（虽然“whatever”并不是一个好名字），而不是使用模块创建者预定的名称。虽然这不是常见的做法，但有时当使用不同作者的模块时，会出现名称冲突。
- en: Closures and Immediately Invoked Function Expressions
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 闭包和立即调用的函数表达式
- en: 'Closures and immediately invoked function expressions aren’t actually new,
    but understanding them will be useful when following the examples in this book.
    A *closure* is the combination of a function plus its encompassing scope to which
    the function has access. It allows you to have private variables, which in turn
    allows you to create the equivalent of classes and modules. For instance, consider
    the following function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包和立即调用的函数表达式其实并不新鲜，但理解它们在本书中的示例中会非常有用。*闭包* 是函数和它所能访问的作用域的结合。它允许你拥有私有变量，从而允许你创建类似类和模块的东西。例如，考虑以下函数：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The returned value (an object) will have access to the first and last variables
    in the scope of the function. For example, consider the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值（一个对象）将能够访问函数作用域中的 first 和 last 变量。例如，考虑以下情况：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Those variables aren’t accessible anywhere else. If you try to access me.first
    or me.last, you get undefined. Those variables are in the closure, but there’s
    no way to access them, because they work as private values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量在其他地方是不可访问的。如果你尝试访问 me.first 或 me.last，你将得到 undefined。这些变量在闭包中，但无法访问，因为它们作为私有值存在。
- en: Using closures also allows you to simulate modules. For that, you’ll need an
    *immediately invoked function expression (IIFE)*, pronounced “iffy,” which is
    a function defined and executed as soon as it’s defined.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包还允许你模拟模块。为此，你需要一个*立即调用的函数表达式（IIFE）*，读作 “iffy”，它是在定义后立即执行的函数。
- en: 'Say you want a module to work with taxes. Without using the new modules, you
    could work in a similar way as with the createPerson(...) function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个处理税收的模块。如果不使用新模块，你可以像使用 createPerson(...) 函数一样操作：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You create a (nameless) function and call it immediately, and the result works
    like a module. You can pass initial values to the IIFE, such as 6 percent for
    the default value-added tax (VAT). The vat variable, and others you may declare,
    are internal and cannot be accessed directly. However, the provided functions,
    addVat(...) and any others you may want, can work with all the internal variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个（没有名字的）函数并立即调用它，结果就像一个模块。你可以将初始值传递给 IIFE，例如默认的增值税（VAT）为 6%。vat 变量和你可能声明的其他变量是内部的，无法直接访问。不过，提供的函数，如
    addVat(...) 和你可能需要的其他函数，可以与所有内部变量一起工作。
- en: 'Use the IIFE-based module as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式使用基于 IIFE 的模块：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Modules can provide the same basic functionality, but you will see cases when
    you’ll want to use closures and IIFEs—for example, in [Chapter 5](chapter5.xhtml)
    where memoizing and precomputing an array of values are discussed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以提供相同的基本功能，但你会看到一些场景，其中你会想使用闭包和 IIFE——例如，在[第 5 章](chapter5.xhtml)中讨论的记忆化和预计算数组值的场景。
- en: JavaScript Development Tools
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 开发工具
- en: Let’s turn our attention to some tools to add to your arsenal to help write
    better-looking code, check for common defects, and more. You won’t use all of
    them in this book, but they are helpful and usually the first things I install
    whenever I start a new project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向一些工具，帮助你编写更美观的代码，检查常见缺陷等。这些工具在本书中并不会全部使用，但它们是非常有用的，通常是我每次开始一个新项目时都会安装的工具。
- en: Visual Studio Code
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: An integrated development environment (IDE) will help you write code quickly
    and easily. This book uses the Visual Studio Code (VSC) IDE. Other popular IDEs
    include Atom, Eclipse, Microsoft Visual Studio, NetBeans, Sublime, and Webstorm,
    and you could work with any of those as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）将帮助你更快速、轻松地编写代码。本书使用的是 Visual Studio Code（VSC）IDE。其他流行的 IDE 包括 Atom、Eclipse、Microsoft
    Visual Studio、NetBeans、Sublime 和 Webstorm，你也可以使用这些工具。
- en: Why use an IDE? Although a simple text editor, such as Notepad or vi, might
    be all you need, an IDE like VSC provides more functionality. With a text editor,
    you have to do more work yourself, constantly switching between tools and entering
    commands repeatedly. Using VSC (or any IDE) is a time-saver that allows you to
    work in an integrated fashion and with many tools in a single click.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用 IDE？尽管像 Notepad 或 vi 这样的简单文本编辑器可能已经足够，但像 VSC 这样的 IDE 提供了更多功能。使用文本编辑器时，你需要自己做更多工作，不断地在工具间切换，反复输入命令。使用
    VSC（或任何 IDE）可以节省时间，让你能够以集成的方式工作，一键访问多个工具。
- en: VSC is open source, free, and updated monthly, with new features added frequently.
    You can use it for JavaScript and many other languages. Frontend developers use
    VSC for basic configuration and recognition (“IntelliSense”) for HTML, CSS, JSON,
    and more. You can expand it via a vast catalog of extensions as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: VSC 是开源的、免费的，并且每月更新，频繁添加新功能。你可以用它来编写 JavaScript 以及其他许多语言的代码。前端开发者使用 VSC 来进行
    HTML、CSS、JSON 等的基本配置和识别（“IntelliSense”）。你还可以通过广泛的扩展目录来扩展其功能。
- en: NOTE
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Visual Studio Code, despite the similar name, is not related to Microsoft’s
    other IDE, Visual Studio. You can use Visual Studio Code in Windows, Linux, and
    macOS, because it was developed in JavaScript and packaged for the desktop using
    the Electron framework.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*Visual Studio Code，尽管名字相似，但与微软的另一个 IDE——Visual Studio 无关。你可以在 Windows、Linux
    和 macOS 上使用 Visual Studio Code，因为它是用 JavaScript 开发的，并通过 Electron 框架打包成桌面应用。*'
- en: VSC also provides good performance, integrated debugging, an integrated terminal
    (to launch processes or run commands without having to leave VSC), and integration
    with source code management (typically Git). [Figure 1-1](chapter1.xhtml#fig1-1)
    shows some of my own work in VSC with the code for this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: VSC 还提供了良好的性能、集成调试、集成终端（可以启动进程或运行命令而无需离开 VSC）以及与源代码管理（通常是 Git）的集成。[图 1-1](chapter1.xhtml#fig1-1)
    显示了我在 VSC 中的部分工作内容，包含本书的代码。
- en: '![](../images/Figure1-1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.jpg)'
- en: 'Figure 1-1: Using Visual Studio Code'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：使用 Visual Studio Code
- en: Go to *[https://code.visualstudio.com](https://code.visualstudio.com)* to download
    the proper version for your environment and follow the installation instructions.
    If you like to live on the edge, install the Insiders’ Version to gain access
    to new features, but be aware that you risk suffering from some bugs. For some
    Linux distributions, instead of downloading and installing the package yourself,
    you can use your package manager to handle installation and updating.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *[https://code.visualstudio.com](https://code.visualstudio.com)* 下载适合你环境的版本，并按照安装说明进行安装。如果你喜欢尝试新功能，可以安装
    Insiders 版本，享受最新特性，但要注意可能会遇到一些 bugs。对于某些 Linux 发行版，你可以通过包管理器处理安装和更新，而无需手动下载和安装。
- en: Fira Code Font
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Fira Code 字体
- en: A quick way to start a (possibly heated) argument among developers is to mention
    that a given font is the best one for programming. Dozens of monospaced fonts
    for programming exist, but few include *ligatures*, which is when two or more
    characters are joined together. JavaScript code is a good candidate for ligatures,
    because otherwise you need to enter common symbols (such as ≥ or ≠) as two or
    three separate characters, which just doesn’t look as good.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 引发开发者激烈争论的一种快速方法是提到某种字体是最适合编程的字体。市面上有数十种单间距编程字体，但很少有包含 *连字* 的字体，连字是指将两个或多个字符组合在一起。JavaScript
    代码是连字的理想候选者，否则你需要将常见符号（如 ≥ 或 ≠）输入为两个或三个独立的字符，这看起来就不那么美观了。
- en: NOTE
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The & character originally was a ligature of E and t to spell et, which means
    “and” in Latin. Another ligature in English is* æ *(as in* encyclopædia *or* Cæsar*)
    combining the letters a and e. Many other languages include ligatures; German
    joins two s characters together in* ß*, like in* Fußball *(football).*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*& 字符最初是 E 和 t 的连字，拼写为 et，表示拉丁语中的“和”。英语中另一个连字是* æ *(如* encyclopædia *或* Cæsar*)，将字母
    a 和 e 结合在一起。许多其他语言也包括连字；德语将两个 s 字符组合在一起形成* ß*，如在* Fußball *(足球)中。*'
- en: The Fira Code font (*[https://github.com/tonsky/FiraCode](https://github.com/tonsky/FiraCode)*)
    provides many ligatures and enhances the look of your code. [Figure 1-2](chapter1.xhtml#fig1-2)
    shows all the possible ligatures for JavaScript. Fira Code includes ligatures
    for other languages as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Fira Code 字体 (*[https://github.com/tonsky/FiraCode](https://github.com/tonsky/FiraCode)*)
    提供了许多连字，并增强了代码的显示效果。[图1-2](chapter1.xhtml#fig1-2) 展示了 JavaScript 的所有可能连字。Fira
    Code 也包括其他语言的连字。
- en: '![](../images/Figure1-2.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-2.jpg)'
- en: 'Figure 1-2: A sample of the many ligatures Fira Code font provides (cropped
    from the Fira Code website)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2：Fira Code 字体提供的众多连字样本（摘自 Fira Code 网站）
- en: After downloading and installing the font, if you are using Visual Studio Code,
    follow the instructions at *[https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions](https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions)*
    to integrate the font with the IDE.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装字体后，如果你使用 Visual Studio Code，按照 *[https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions](https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions)*
    上的说明将字体集成到 IDE 中。
- en: Prettier Formatting
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Prettier 格式化
- en: How to format source code can be another source of disagreements. Every developer
    you work with will likely have their own take on this issue, asserting that their
    standard is best. If you work with a team of developers, you may be familiar with
    the situation shown in the “How Standards Proliferate” xkcd comic ([Figure 1-3](chapter1.xhtml#fig1-3)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如何格式化源代码可能是另一个争论的源头。你与之合作的每个开发人员可能都会对这个问题有自己的看法，声称他们的标准最好。如果你与一个开发者团队合作，你可能会熟悉“标准如何蔓延”这幅xkcd漫画所展示的情况（[图1-3](chapter1.xhtml#fig1-3)）。
- en: '![](../images/Figure1-3.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-3.jpg)'
- en: 'Figure 1-3: “How Standards Proliferate” (courtesy of xkcd, [https://xkcd.com/927](https://xkcd.com/927))'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：“标准如何蔓延”（感谢 xkcd 提供，[https://xkcd.com/927](https://xkcd.com/927)）
- en: Prettier is an “opinionated” source code formatter that reformats code according
    to its own set of rules and a few parameters you can set. Prettier’s website states,
    “By far the biggest reason for adopting Prettier is to stop all the on-going debates
    over styles.” All the source code examples in this book are formatted with Prettier.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier 是一个“有观点”的源代码格式化工具，按照自己的一套规则和一些可以设置的参数来重新格式化代码。Prettier 的网站声明，“采用 Prettier
    的最大原因是停止所有关于风格的持续争论。” 本书中的所有源代码示例都使用 Prettier 格式化。
- en: Installing Prettier is simple; follow the instructions at *[https://prettier.io](https://prettier.io)*,
    and if you use Visual Studio Code, also install the Prettier extension from *[https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)*.
    Be sure to tweak VSC’s settings to enable the editor.formatOnSave option so all
    code will be reformatted upon saving. Consult the documentation on the Prettier
    website to learn more about configuring Prettier to your liking.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Prettier 非常简单；按照 *[https://prettier.io](https://prettier.io)* 上的说明进行操作。如果你使用
    Visual Studio Code，还需要从 *[https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)*
    安装 Prettier 插件。确保调整 VSC 的设置，启用 editor.formatOnSave 选项，这样所有代码在保存时都会被重新格式化。请查阅 Prettier
    网站上的文档，了解如何根据个人喜好配置 Prettier。
- en: JSDoc Documentation
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSDoc 文档
- en: Documenting your source code is development best practice. JSDoc (*[https://jsdoc.app](https://jsdoc.app)*)
    is a tool that helps you produce documentation for your code by aggregating specifically
    formatted comments. If you add comments preceding your functions, methods, classes,
    and so on, JSDoc will use them to produce documentation for your code. We don’t
    use JSDoc in this book, because the text explains the code. However, for normal
    work, using JSDoc helps developers understand all of a system’s pieces.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为源代码编写文档是开发的最佳实践。JSDoc (*[https://jsdoc.app](https://jsdoc.app)*) 是一个帮助你通过聚合特定格式的注释生成代码文档的工具。如果你在函数、方法、类等前添加注释，JSDoc
    将使用这些注释生成文档。我们在本书中不使用 JSDoc，因为文本已经解释了代码。然而，对于日常工作，使用 JSDoc 可以帮助开发者理解系统的各个部分。
- en: 'Here’s a code snippet that adds a key to a heap from [Chapter 14](chapter14.xhtml)
    to show how JSDoc produces documentation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码片段，它从 [第 14 章](chapter14.xhtml) 向堆中添加一个键，以展示 JSDoc 如何生成文档：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: JSDoc comments start with the /** combination, which is like the usual comment
    format but with one extra asterisk. The @author, @version, @param, and @return
    tags describe specific information about the code; the names are self-explanatory.
    Other tags you can use include @class, @constructor, @deprecated, @exports, @property,
    and @throws (or @exception). See *[https://jsdoc.app/index.html](https://jsdoc.app/index.html)*
    for a complete list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: JSDoc 注释以 /** 组合符号开头，类似于常规注释格式，但多了一个星号。@author、@version、@param 和 @return 标签描述了代码的特定信息；这些名称不言自明。你还可以使用的其他标签包括
    @class、@constructor、@deprecated、@exports、@property 和 @throws（或 @exception）。查看
    *[https://jsdoc.app/index.html](https://jsdoc.app/index.html)* 获取完整列表。
- en: After installing JSDoc according to the instructions at *[https://github.com/jsdoc/jsdoc](https://github.com/jsdoc/jsdoc)*,
    I processed this example file, which produced the results shown in [Figure 1-4](chapter1.xhtml#fig1-4).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *[https://github.com/jsdoc/jsdoc](https://github.com/jsdoc/jsdoc)* 中的说明安装
    JSDoc 后，我处理了这个示例文件，生成了 [图 1-4](chapter1.xhtml#fig1-4) 所示的结果。
- en: '![](../images/Figure1-4.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-4.jpg)'
- en: 'Figure 1-4: A sample documentation web page automatically generated by JSDoc'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4：由 JSDoc 自动生成的示例文档网页
- en: Of course, this is a simple example with only a single file. For a complete
    system, you would get a home page with links to every page of documentation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个只有一个文件的简单示例。对于完整的系统，你将得到一个首页，首页上有指向每个文档页面的链接。
- en: ESLint
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ESLint
- en: 'JavaScript presents many possibilities for misuse and misunderstanding. Consider
    this simple example: if you use the == operator instead of ===, you may find cases
    in which x==y and y==z, but x!=z, no matter what the transitive law may say. (Try
    x=[], y=0, and z="0".) Another tricky case is if you accidentally enter (x=y)
    instead of (x==y), which would be an assignment rather than a comparison; it’s
    not very likely you want the former.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 存在许多滥用和误解的可能性。考虑这个简单的例子：如果你使用 == 运算符而不是 ===，你可能会发现 x==y 且 y==z，但
    x!=z，无论传递法则如何（尝试 x=[]，y=0 和 z="0"）。另一个棘手的情况是，如果你不小心输入 (x=y) 而不是 (x==y)，那将是一个赋值而不是比较；这种情况不太可能是你想要的。
- en: A *linter* is a tool that analyzes code and produces warning or error messages
    about any doubtful or error-prone features you might be using. In some cases,
    a linter may even fix your code properly. You also can use linters in conjunction
    with source code versioning tools. Linters can keep you from posting code that
    doesn’t pass all checks. If you use Git, go to *[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)*
    to read about precommit hooks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Linter* 是一种分析代码并生成关于你可能使用的任何可疑或易出错特性的警告或错误信息的工具。在某些情况下，Linter 甚至可以正确地修复你的代码。你还可以将
    Linter 与源代码版本控制工具结合使用。Linter 可以防止你提交未通过所有检查的代码。如果你使用 Git，请访问 *[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)*
    阅读有关预提交钩子的内容。'
- en: ESLint works well for linting in JavaScript. It was created in 2013 and is still
    going strong. Go to *[https://www.npmjs.com/package/eslint](https://www.npmjs.com/package/eslint)*
    to download and install, and then configure it. Be sure to carefully read the
    rules at *[https://eslint.org/docs/rules/](https://eslint.org/docs/rules/)*, because
    you can set many different rules, but you shouldn’t turn them all on unless you
    want to start some linting wars.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 在 JavaScript 中进行代码检查非常有效。它创建于 2013 年，并且至今仍然非常活跃。访问 *[https://www.npmjs.com/package/eslint](https://www.npmjs.com/package/eslint)*
    下载并安装，然后进行配置。请务必仔细阅读 *[https://eslint.org/docs/rules/](https://eslint.org/docs/rules/)*
    上的规则，因为你可以设置许多不同的规则，但除非你想引发一些代码检查冲突，否则不应全部启用。
- en: Finally, don’t forget the VSC extension at *[https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)*,
    so you can see whatever errors ESLint detects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记在 *[https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)*
    获取 VSC 扩展，这样你就可以看到 ESLint 检测到的任何错误。
- en: NOTE
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*With ESLint, the* eqeqeq *rule (see* [https://eslint.org/docs/rules/eqeqeq](https://eslint.org/docs/rules/eqeqeq)*)
    would have detected the problem with the type-unsafe* == *operator and even would
    have fixed it by substituting* === *instead. In addition, the* no-cond-assign
    *rule would have warned about the unexpected assignment.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用 ESLint，* eqeqeq *规则（见* [https://eslint.org/docs/rules/eqeqeq](https://eslint.org/docs/rules/eqeqeq)*)
    会检测到类型不安全的* == *运算符的问题，并且会通过替换成* === *来自动修复。此外，* no-cond-assign *规则会对意外的赋值进行警告。*'
- en: Flow and TypeScript
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Flow 和 TypeScript
- en: For large-scale coding, consider using Flow and TypeScript, which let you add
    information about data types to JavaScript. Flow adds comments that describe what
    data types are expected for function inputs and outputs, variables, and so forth.
    TypeScript is actually is a superset of JavaScript that is transpiled into it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大规模编码，考虑使用 Flow 和 TypeScript，这些工具允许你为 JavaScript 添加数据类型信息。Flow 添加了描述函数输入和输出、变量等期望数据类型的注释。而
    TypeScript 实际上是 JavaScript 的超集，它会被转译成 JavaScript。
- en: '[Figure 1-5](chapter1.xhtml#fig1-5) (shamelessly based on an example from the
    TypeScript home page) shows the kinds of errors you can detect with type information.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-5](chapter1.xhtml#fig1-5)（毫不羞耻地借鉴了 TypeScript 首页上的例子）展示了你可以通过类型信息检测到的错误类型。'
- en: '![](../images/Figure1-5.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-5.jpg)'
- en: 'Figure 1-5: A type error in TypeScript code caught on the fly by ESLint'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5：ESLint 实时捕获的 TypeScript 代码中的类型错误
- en: In this example, I’m trying to access an attribute that doesn’t exist (user.name)
    according to the type data deduced from earlier lines of code. (Note that I’m
    using ESLint, which is why I can see the error in real time.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我尝试访问一个不存在的属性（user.name），这是根据之前代码行推导出的类型数据得出的。（注意，我使用了 ESLint，这就是为什么我能实时看到错误。）
- en: We won’t use either of these two tools in this book, but for big projects that
    involve many classes, methods, functions, types, and so on, consider adding them
    to your repertoire.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们不会使用这两个工具，但对于涉及大量类、方法、函数、类型等的大型项目，考虑将它们加入到你的工具库中。
- en: Online Feature Availability Resources
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在线功能可用性资源
- en: If you’re working server-side with the latest version of Node.js, you probably
    won’t need to worry about any specific feature being available. However, if you’re
    doing frontend work, a given function may not be available, such as Internet Explorer
    support. If that happens, you’ll need to transpile with something like Babel,
    as mentioned earlier in the chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用最新版本的 Node.js 进行服务器端开发，你可能不需要担心某些特定功能的可用性。然而，如果你在做前端开发，某些功能可能不可用，例如对
    Internet Explorer 的支持。如果发生这种情况，你需要使用像 Babel 这样的工具进行转译，正如本章之前所提到的。
- en: The Kangax website (*[https://compat-table.github.io/compat-table/es2016plus/](https://compat-table.github.io/compat-table/es2016plus/)*)
    provides information on multiple platforms, detailing whether a function is fully,
    partially, or not available. Kangax provides a listing of all the JavaScript language
    features, with examples for each, and you’ll find a table on the website that
    shows what features are available for each different JavaScript engine, such as
    features found on browsers and Node.js. Generally speaking, when you open it with
    a browser, green “Yes” boxes mean you can use the feature safely; boxes in different
    colors or text imply the feature is partially available or not available.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kangax 网站 (*[https://compat-table.github.io/compat-table/es2016plus/](https://compat-table.github.io/compat-table/es2016plus/)*)
    提供了多个平台的信息，详细说明一个功能是完全可用、部分可用，还是不可用。Kangax 列出了所有 JavaScript 语言功能，并为每个功能提供了示例。你还可以在网站上找到一张表格，展示每个不同
    JavaScript 引擎所支持的功能，如浏览器和 Node.js 上的功能。一般来说，当你使用浏览器打开时，绿色的“是”框表示你可以安全使用该功能；不同颜色或文本的框表示该功能部分可用或不可用。
- en: The *Can I Use?* website at *[https://www.caniuse.com/](https://www.caniuse.com/)*
    lets you search by function and shows the available support in different browsers.
    For instance, if you search for arrow functions, the website will tell you which
    browsers support it, since what date, and the percentage of global users with
    direct access to that feature without polyfills or transpiling.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*Can I Use?* 网站在 *[https://www.caniuse.com/](https://www.caniuse.com/)* 上可以让你按功能进行搜索，并展示不同浏览器中可用的支持情况。例如，如果你搜索箭头函数，网站会告诉你哪些浏览器支持它，支持的日期以及全球直接访问该功能的用户百分比，且无需补丁或转译。'
- en: NOTE
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you are hazy on the term polyfill, see “What Is a Polyfill” at* [https://remysharp.com/2010/10/08/what-is-a-polyfill](https://remysharp.com/2010/10/08/what-is-a-polyfill)
    *by Remy Sharp (creator of the concept). A polyfill is a way to “replicate an
    API ... if the browser doesn’t have it natively.” The MDN website often provides
    polyfills for new features, which is helpful if you need to deal with older browsers
    that don’t provide them or need details on how something works.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对“polyfill”这一术语不太清楚，请参阅 Remy Sharp（这一概念的创造者）写的* [https://remysharp.com/2010/10/08/what-is-a-polyfill](https://remysharp.com/2010/10/08/what-is-a-polyfill)
    *文章。Polyfill 是一种“如果浏览器没有原生支持某个 API，就复制该 API”的方法。MDN 网站通常为新功能提供 polyfill，这对于需要处理不支持这些功能的旧版浏览器，或需要了解某些功能如何工作的情况非常有帮助。*'
- en: '[Figure 1-6](chapter1.xhtml#fig1-6) shows information on the availability of
    arrow functions across browsers; hovering with the mouse provides more data, such
    as when the feature was first available.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-6](chapter1.xhtml#fig1-6) 显示了箭头函数在不同浏览器中的可用性信息；通过鼠标悬停可以查看更多数据，比如该功能首次可用的时间。'
- en: '![](../images/Figure1-6.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-6.jpg)'
- en: 'Figure 1-6: The Can I Use? website shows whether a given feature is available
    in browsers.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6：Can I Use? 网站展示了某个功能是否在浏览器中可用。
- en: The Can I Use? site provides information only about browsers; it doesn’t include
    server-side tools like Node.js, but you’ll likely find a need for it at some time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Can I Use? 网站仅提供有关浏览器的信息；它不包括像 Node.js 这样的服务器端工具，但你可能在某些时候需要它。
- en: '### Summary'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '### 总结'
- en: 'In this chapter, we looked at some of JavaScript’s new and important modern
    features, including spreading, destructuring, arrow functions, classes, and modules.
    We also considered some additional tools you might want to include for your development
    work, such as the VSC IDE, Fira Code font for neater screen displays, Prettier
    for source code formatting, JSDoc to generate documentation, ESLint to check for
    defects or bad practices, and Flow or TypeScript to add data type checking. Finally,
    in order to ensure that you’re not using unavailable functions, two online resources
    were presented: Kangax, and Can I Use?, both of which will help you avoid unimplemented
    or only partially implemented JavaScript features.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们回顾了 JavaScript 一些新颖且重要的现代功能，包括展开运算符、解构、箭头函数、类和模块。我们还考虑了一些你可能想在开发工作中使用的额外工具，如
    VSC IDE、用于更整洁屏幕显示的 Fira Code 字体、用于源代码格式化的 Prettier、用于生成文档的 JSDoc、用于检查缺陷或不良实践的
    ESLint，以及用于添加数据类型检查的 Flow 或 TypeScript。最后，为了确保你不使用不可用的功能，我们介绍了两个在线资源：Kangax 和
    Can I Use?，它们将帮助你避免使用未实现或仅部分实现的 JavaScript 特性。
- en: In the next chapter, we’ll go deeper into JavaScript and explore its functional
    programming aspects, providing a starting point for the examples in the rest of
    this book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入探讨 JavaScript，并探索其函数式编程方面的内容，为本书其余部分的示例提供起点。
