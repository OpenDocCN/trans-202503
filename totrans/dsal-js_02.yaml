- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 1 USING JAVASCRIPT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JavaScript has evolved and added significant functionality since its original
    1995 version. The addition of *classes* to the language aided with object-oriented
    programming so that you no longer need to work with complex prototypes. *Destructuring*
    and *spread* operators have simplified working with objects and arrays, and they
    allow you to manage multiple assignments at once. The introduction of *arrow functions*
    lets you work in a more succinct, expressive way, enhancing JavaScript’s functional
    programming capability. Finally, the concept of *modules* has simplified code
    organization and lets you partition and group your code in logical ways. This
    chapter briefly explores these
  prefs: []
  type: TYPE_NORMAL
- en: modern features of the language that help you write better, shorter, more understandable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript language isn’t the only thing that has evolved, however, so this
    chapter also will introduce some of the many tools that are now available to help
    you develop JavaScript code. Environments like Visual Studio Code with special
    fonts provide better code readability. Other tools help produce documented, well-formatted
    code, and validation utilities can detect static or type-related errors. In addition,
    many online tools exist to help deal with incompatibilities among browsers and
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Modern JavaScript Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start with an exploration of some modern JavaScript features that will
    simplify coding: arrow functions, classes, spreading values, destructuring, and
    modules. This list isn’t exhaustive, and we’ll look at other features in later
    chapters, including functional programming, map/reduce and similar array methods,
    functions as first-class objects, recursion, and more. We certainly can’t cover
    all of the language’s features, but here the focus is on the most important and
    newer features that are used throughout the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript provides many ways to specify a function, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Named functions, which are the most common: function alpha() {...}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nameless function expressions: const bravo = function () {...}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Named function expressions: const charlie = function something() {...}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function constructors: const delta = new Function()'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrow functions: const echo = () => {...}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of those definitions work basically the same way, but arrow functions—JavaScript’s
    new kids on the block—have these important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: They may return a value even without including a return statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot be used as constructors or generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don’t bind the this value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don’t have an arguments object or a prototype property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In particular, the first characteristic in the previous list is used a lot
    in this book; being able to omit the return keyword will make for shorter, more
    succinct code. For example, in [Chapter 12](chapter12.xhtml), you will see the
    following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Given a tree argument, this function returns 0 if the tree is empty; otherwise,
    it returns the tree object’s height attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses return and is an equivalent (but longer) way to
    write the same function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The longer version isn’t necessary: shorter code is good.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the shortened version and want to return an object, you need to
    enclose it in parentheses. Here’s another arrow function example from [Chapter
    12](chapter12.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Given a key, this function returns a node (an object, in fact) with that key
    as an attribute, plus null left and right links and a height attribute set to
    1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common feature of the arrow function is providing default values for
    missing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will see what this code does in [Chapter 12](chapter12.xhtml), but the interesting
    part is that the recursive function, if not provided with a value for s, will
    initialize it with the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although we won’t use classes much in this book, modern JavaScript has come
    far from its beginnings, and instead of having to deal with the prototype and
    adding tangled code to implement inheritance, now you can achieve inheritance
    easily. In the past you could use classes and subclasses, different constructors,
    and all of that, but implementing inheritance wasn’t easy. JavaScript classes
    now make it much more straightforward. (See *[https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)*
    if you want to learn how to do inheritance in old-style JavaScript.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at a partial, slightly modified example from [Chapter 13](chapter13.xhtml)
    that shows an actual class and how to define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can either define a simple class, as is the case here ❶, or extend an existing
    one. For instance, you could have another class BinaryTree extends Tree to define
    a class based on Tree. You can define attributes outside a constructor ❷; you
    don’t need to do it inside a constructor ❸. Constructors are available if you
    need more complex object instance initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Getters ❹ and setters ❺ are other powerful features. They bind an object’s property
    to functions that are invoked whenever we try to modify or access that property.
  prefs: []
  type: TYPE_NORMAL
- en: Other features not used in this example are static properties and methods; such
    attributes aren’t part of the class instances, but rather belong to the class
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Starting with ECMAScript 2022, JavaScript also includes* private *properties:
    fields, methods, getters, setters, and so on.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Spread Operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The spread operator (...) allows you to, well, *spread* an array, string, or
    object into separate values in a single operation, providing some interesting
    array and object usages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are applied like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Entering ...myArray is the same as entering 3, 1, 4, 1, 5, 9, 2, 6, so the first
    usage of ...myArray in this example produces 9 ❶, and the second provides a new
    array with exactly the same elements of myArray ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the spread operator to build a copy of an object, which you
    can then modify independently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, newObject ❶ first gets a copy of the attributes of myObject, and
    then the year attribute is overwritten. You could do this “the old way” with many
    individual assignments, but using the spread operator allows for shorter and clearer
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A third usage of the spread operator is for functions that need to deal with
    an undefined number of parameters. Earlier versions of JavaScript had the arguments
    array-like object to handle this situation. The arguments object is “array-like,”
    because .length is the only array property it provides. The arguments object doesn’t
    include any other properties that arrays have.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could write your own Math.max() version like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You could now use myMax() like you’d use Math.max(), but there’s no reason to
    reinvent that function. This example shows how you can imitate the features of
    existing functions—in this case, the ability to pass many arguments to a function.
  prefs: []
  type: TYPE_NORMAL
- en: The Destructuring Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *destructuring* statement is related to the spread operator. It allows
    you to assign several variables at the same time, which means you can combine
    several independent assignments into one and write shorter code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you assign "Abraham" to the first variable and "Lincoln" to the
    last variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also can mix destructuring and spreading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Assign the initial elements in the array to first and last, as in the previous
    example, and assign all of the rest of the elements (the two numbers) to the years
    array. This combination lets you write code more succinctly, using a single statement,
    where previously several would have been required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, you can use default values when variables on the left side have
    no corresponding values on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the destructuring statement assigns a default value to role
    and leaves party undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also swap or rotate variables, which is a technique used frequently
    later in this book. Consider this line from code in [Chapter 14](chapter14.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This directly swaps the values of heap[p] and heap[i] without using an auxiliary
    variable. You also could write something like [d, e, f] = [e, f, d] to rotate
    the values of three variables, again without requiring more variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, another pattern that we’ll often use is to return two or more values
    at once from a function. For example, you could write a function to return two
    values in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The other way of returning many values at once is with an object. You still
    can do that, but returning an array and using destructuring is more compact.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Modules* allow you to split code into pieces you can import when needed, providing
    a way to package functionality that is easier to understand and maintain. Each
    module should be an aggregation of related functions and classes, providing a
    set of features. A standard practice related to using modules is *high cohesion*,
    which means elements you put together should truly belong together, as unrelated
    functionalities should not be mixed in the same module. A related concept called
    *low coupling* means that distinct modules should be interdependent as little
    as possible. JavaScript lets you package functions in modules to provide a well-structured
    design, with greater readability and maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules come in two formats: *CommonJS modules* (an earlier format, used mostly
    in Node.js) and *ECMAScript modules* (the latest format, generally used by browsers).'
  prefs: []
  type: TYPE_NORMAL
- en: '##### CommonJS Modules'
  prefs: []
  type: TYPE_NORMAL
- en: 'With CommonJS modules, write the code in the style of this (abridged) example
    from [Chapter 16](chapter16.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The module.exports assignment at the end ❸ defines what parts of the module
    will be visible from the outside; whatever is not included ❶ ❷ won’t be accessible
    for the rest of the system. This way of writing code is well aligned with the
    *black box* software concept. Users of a module shouldn’t need to learn or even
    know about its internal details to allow for higher maintainability. As long as
    the module keeps providing the same functionality, its developers are free to
    refactor or improve it without impacting any users.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to import a pair of the functions that the module exports, for
    example, you’d use the following code style, which employs destructuring, to specify
    what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This allows access (via destructuring) to the newRadixTree() and add() functions,
    out of all the functions exported by the radix_tree module. If you want to add
    something to the Radix tree, you can call add() directly; similarly, you can call
    newRadixTree() to create a new tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In order to add something to a tree or create a new one, you have to call RadixTree.add()
    and RadixTree.newRadixTree() instead. This usage makes for longer code, but it
    also lets you access all the functions in the radix_tree module. I prefer the
    first style that employs destructuring, because it makes clear what I am using,
    but it’s really up to you.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript Modules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The more modern ECMAScript style of defining modules also works with separate
    files, but instead of creating a module.exports object, you rewrite the module
    you just saw in the previous section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can export something directly wherever you define it ❶ ❷ or postpone doing
    so until the end ❸. Both methods work (and I don’t think anybody would really
    use *both* styles, as I did for this example), but most people prefer having all
    export statements together at the end. It’s really your choice.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can also use ECMAScript* import *and* export *statements in Node.js, but
    only if you use the .mjs extension instead of the .js extension, which is reserved
    for CommonJS modules.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can import functions from an ECMAScript module in the following way, which
    is a different usage in comparison with the CommonJS modules, although the end
    result is exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to import everything, use the following code instead; this will
    give you access to an object, including all the functions exported by the module,
    as earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'All the exports you’ve seen so far are *named* exports; you can have as many
    of them as you want, and you can also have a single unnamed default export. In
    a given file, instead of defining what you want to export, as described earlier,
    you include something like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in other parts of the code, you can do the following to import something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can name what you imported whatever you like (whatever isn’t a good name)
    instead of using the name the module creator intended. That isn’t usual practice,
    but sometimes name conflicts arise when using modules by different authors.
  prefs: []
  type: TYPE_NORMAL
- en: Closures and Immediately Invoked Function Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Closures and immediately invoked function expressions aren’t actually new,
    but understanding them will be useful when following the examples in this book.
    A *closure* is the combination of a function plus its encompassing scope to which
    the function has access. It allows you to have private variables, which in turn
    allows you to create the equivalent of classes and modules. For instance, consider
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned value (an object) will have access to the first and last variables
    in the scope of the function. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Those variables aren’t accessible anywhere else. If you try to access me.first
    or me.last, you get undefined. Those variables are in the closure, but there’s
    no way to access them, because they work as private values.
  prefs: []
  type: TYPE_NORMAL
- en: Using closures also allows you to simulate modules. For that, you’ll need an
    *immediately invoked function expression (IIFE)*, pronounced “iffy,” which is
    a function defined and executed as soon as it’s defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want a module to work with taxes. Without using the new modules, you
    could work in a similar way as with the createPerson(...) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You create a (nameless) function and call it immediately, and the result works
    like a module. You can pass initial values to the IIFE, such as 6 percent for
    the default value-added tax (VAT). The vat variable, and others you may declare,
    are internal and cannot be accessed directly. However, the provided functions,
    addVat(...) and any others you may want, can work with all the internal variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the IIFE-based module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Modules can provide the same basic functionality, but you will see cases when
    you’ll want to use closures and IIFEs—for example, in [Chapter 5](chapter5.xhtml)
    where memoizing and precomputing an array of values are discussed.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Development Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s turn our attention to some tools to add to your arsenal to help write
    better-looking code, check for common defects, and more. You won’t use all of
    them in this book, but they are helpful and usually the first things I install
    whenever I start a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An integrated development environment (IDE) will help you write code quickly
    and easily. This book uses the Visual Studio Code (VSC) IDE. Other popular IDEs
    include Atom, Eclipse, Microsoft Visual Studio, NetBeans, Sublime, and Webstorm,
    and you could work with any of those as well.
  prefs: []
  type: TYPE_NORMAL
- en: Why use an IDE? Although a simple text editor, such as Notepad or vi, might
    be all you need, an IDE like VSC provides more functionality. With a text editor,
    you have to do more work yourself, constantly switching between tools and entering
    commands repeatedly. Using VSC (or any IDE) is a time-saver that allows you to
    work in an integrated fashion and with many tools in a single click.
  prefs: []
  type: TYPE_NORMAL
- en: VSC is open source, free, and updated monthly, with new features added frequently.
    You can use it for JavaScript and many other languages. Frontend developers use
    VSC for basic configuration and recognition (“IntelliSense”) for HTML, CSS, JSON,
    and more. You can expand it via a vast catalog of extensions as well.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Visual Studio Code, despite the similar name, is not related to Microsoft’s
    other IDE, Visual Studio. You can use Visual Studio Code in Windows, Linux, and
    macOS, because it was developed in JavaScript and packaged for the desktop using
    the Electron framework.*'
  prefs: []
  type: TYPE_NORMAL
- en: VSC also provides good performance, integrated debugging, an integrated terminal
    (to launch processes or run commands without having to leave VSC), and integration
    with source code management (typically Git). [Figure 1-1](chapter1.xhtml#fig1-1)
    shows some of my own work in VSC with the code for this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: Using Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: Go to *[https://code.visualstudio.com](https://code.visualstudio.com)* to download
    the proper version for your environment and follow the installation instructions.
    If you like to live on the edge, install the Insiders’ Version to gain access
    to new features, but be aware that you risk suffering from some bugs. For some
    Linux distributions, instead of downloading and installing the package yourself,
    you can use your package manager to handle installation and updating.
  prefs: []
  type: TYPE_NORMAL
- en: Fira Code Font
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A quick way to start a (possibly heated) argument among developers is to mention
    that a given font is the best one for programming. Dozens of monospaced fonts
    for programming exist, but few include *ligatures*, which is when two or more
    characters are joined together. JavaScript code is a good candidate for ligatures,
    because otherwise you need to enter common symbols (such as ≥ or ≠) as two or
    three separate characters, which just doesn’t look as good.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The & character originally was a ligature of E and t to spell et, which means
    “and” in Latin. Another ligature in English is* æ *(as in* encyclopædia *or* Cæsar*)
    combining the letters a and e. Many other languages include ligatures; German
    joins two s characters together in* ß*, like in* Fußball *(football).*'
  prefs: []
  type: TYPE_NORMAL
- en: The Fira Code font (*[https://github.com/tonsky/FiraCode](https://github.com/tonsky/FiraCode)*)
    provides many ligatures and enhances the look of your code. [Figure 1-2](chapter1.xhtml#fig1-2)
    shows all the possible ligatures for JavaScript. Fira Code includes ligatures
    for other languages as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: A sample of the many ligatures Fira Code font provides (cropped
    from the Fira Code website)'
  prefs: []
  type: TYPE_NORMAL
- en: After downloading and installing the font, if you are using Visual Studio Code,
    follow the instructions at *[https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions](https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions)*
    to integrate the font with the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Prettier Formatting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How to format source code can be another source of disagreements. Every developer
    you work with will likely have their own take on this issue, asserting that their
    standard is best. If you work with a team of developers, you may be familiar with
    the situation shown in the “How Standards Proliferate” xkcd comic ([Figure 1-3](chapter1.xhtml#fig1-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: “How Standards Proliferate” (courtesy of xkcd, [https://xkcd.com/927](https://xkcd.com/927))'
  prefs: []
  type: TYPE_NORMAL
- en: Prettier is an “opinionated” source code formatter that reformats code according
    to its own set of rules and a few parameters you can set. Prettier’s website states,
    “By far the biggest reason for adopting Prettier is to stop all the on-going debates
    over styles.” All the source code examples in this book are formatted with Prettier.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Prettier is simple; follow the instructions at *[https://prettier.io](https://prettier.io)*,
    and if you use Visual Studio Code, also install the Prettier extension from *[https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)*.
    Be sure to tweak VSC’s settings to enable the editor.formatOnSave option so all
    code will be reformatted upon saving. Consult the documentation on the Prettier
    website to learn more about configuring Prettier to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: JSDoc Documentation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Documenting your source code is development best practice. JSDoc (*[https://jsdoc.app](https://jsdoc.app)*)
    is a tool that helps you produce documentation for your code by aggregating specifically
    formatted comments. If you add comments preceding your functions, methods, classes,
    and so on, JSDoc will use them to produce documentation for your code. We don’t
    use JSDoc in this book, because the text explains the code. However, for normal
    work, using JSDoc helps developers understand all of a system’s pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a code snippet that adds a key to a heap from [Chapter 14](chapter14.xhtml)
    to show how JSDoc produces documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: JSDoc comments start with the /** combination, which is like the usual comment
    format but with one extra asterisk. The @author, @version, @param, and @return
    tags describe specific information about the code; the names are self-explanatory.
    Other tags you can use include @class, @constructor, @deprecated, @exports, @property,
    and @throws (or @exception). See *[https://jsdoc.app/index.html](https://jsdoc.app/index.html)*
    for a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: After installing JSDoc according to the instructions at *[https://github.com/jsdoc/jsdoc](https://github.com/jsdoc/jsdoc)*,
    I processed this example file, which produced the results shown in [Figure 1-4](chapter1.xhtml#fig1-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: A sample documentation web page automatically generated by JSDoc'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a simple example with only a single file. For a complete
    system, you would get a home page with links to every page of documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JavaScript presents many possibilities for misuse and misunderstanding. Consider
    this simple example: if you use the == operator instead of ===, you may find cases
    in which x==y and y==z, but x!=z, no matter what the transitive law may say. (Try
    x=[], y=0, and z="0".) Another tricky case is if you accidentally enter (x=y)
    instead of (x==y), which would be an assignment rather than a comparison; it’s
    not very likely you want the former.'
  prefs: []
  type: TYPE_NORMAL
- en: A *linter* is a tool that analyzes code and produces warning or error messages
    about any doubtful or error-prone features you might be using. In some cases,
    a linter may even fix your code properly. You also can use linters in conjunction
    with source code versioning tools. Linters can keep you from posting code that
    doesn’t pass all checks. If you use Git, go to *[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)*
    to read about precommit hooks.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint works well for linting in JavaScript. It was created in 2013 and is still
    going strong. Go to *[https://www.npmjs.com/package/eslint](https://www.npmjs.com/package/eslint)*
    to download and install, and then configure it. Be sure to carefully read the
    rules at *[https://eslint.org/docs/rules/](https://eslint.org/docs/rules/)*, because
    you can set many different rules, but you shouldn’t turn them all on unless you
    want to start some linting wars.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, don’t forget the VSC extension at *[https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)*,
    so you can see whatever errors ESLint detects.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*With ESLint, the* eqeqeq *rule (see* [https://eslint.org/docs/rules/eqeqeq](https://eslint.org/docs/rules/eqeqeq)*)
    would have detected the problem with the type-unsafe* == *operator and even would
    have fixed it by substituting* === *instead. In addition, the* no-cond-assign
    *rule would have warned about the unexpected assignment.*'
  prefs: []
  type: TYPE_NORMAL
- en: Flow and TypeScript
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For large-scale coding, consider using Flow and TypeScript, which let you add
    information about data types to JavaScript. Flow adds comments that describe what
    data types are expected for function inputs and outputs, variables, and so forth.
    TypeScript is actually is a superset of JavaScript that is transpiled into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-5](chapter1.xhtml#fig1-5) (shamelessly based on an example from the
    TypeScript home page) shows the kinds of errors you can detect with type information.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: A type error in TypeScript code caught on the fly by ESLint'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I’m trying to access an attribute that doesn’t exist (user.name)
    according to the type data deduced from earlier lines of code. (Note that I’m
    using ESLint, which is why I can see the error in real time.)
  prefs: []
  type: TYPE_NORMAL
- en: We won’t use either of these two tools in this book, but for big projects that
    involve many classes, methods, functions, types, and so on, consider adding them
    to your repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: Online Feature Availability Resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re working server-side with the latest version of Node.js, you probably
    won’t need to worry about any specific feature being available. However, if you’re
    doing frontend work, a given function may not be available, such as Internet Explorer
    support. If that happens, you’ll need to transpile with something like Babel,
    as mentioned earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Kangax website (*[https://compat-table.github.io/compat-table/es2016plus/](https://compat-table.github.io/compat-table/es2016plus/)*)
    provides information on multiple platforms, detailing whether a function is fully,
    partially, or not available. Kangax provides a listing of all the JavaScript language
    features, with examples for each, and you’ll find a table on the website that
    shows what features are available for each different JavaScript engine, such as
    features found on browsers and Node.js. Generally speaking, when you open it with
    a browser, green “Yes” boxes mean you can use the feature safely; boxes in different
    colors or text imply the feature is partially available or not available.
  prefs: []
  type: TYPE_NORMAL
- en: The *Can I Use?* website at *[https://www.caniuse.com/](https://www.caniuse.com/)*
    lets you search by function and shows the available support in different browsers.
    For instance, if you search for arrow functions, the website will tell you which
    browsers support it, since what date, and the percentage of global users with
    direct access to that feature without polyfills or transpiling.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you are hazy on the term polyfill, see “What Is a Polyfill” at* [https://remysharp.com/2010/10/08/what-is-a-polyfill](https://remysharp.com/2010/10/08/what-is-a-polyfill)
    *by Remy Sharp (creator of the concept). A polyfill is a way to “replicate an
    API ... if the browser doesn’t have it natively.” The MDN website often provides
    polyfills for new features, which is helpful if you need to deal with older browsers
    that don’t provide them or need details on how something works.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-6](chapter1.xhtml#fig1-6) shows information on the availability of
    arrow functions across browsers; hovering with the mouse provides more data, such
    as when the feature was first available.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: The Can I Use? website shows whether a given feature is available
    in browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: The Can I Use? site provides information only about browsers; it doesn’t include
    server-side tools like Node.js, but you’ll likely find a need for it at some time.
  prefs: []
  type: TYPE_NORMAL
- en: '### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at some of JavaScript’s new and important modern
    features, including spreading, destructuring, arrow functions, classes, and modules.
    We also considered some additional tools you might want to include for your development
    work, such as the VSC IDE, Fira Code font for neater screen displays, Prettier
    for source code formatting, JSDoc to generate documentation, ESLint to check for
    defects or bad practices, and Flow or TypeScript to add data type checking. Finally,
    in order to ensure that you’re not using unavailable functions, two online resources
    were presented: Kangax, and Can I Use?, both of which will help you avoid unimplemented
    or only partially implemented JavaScript features.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll go deeper into JavaScript and explore its functional
    programming aspects, providing a starting point for the examples in the rest of
    this book.
  prefs: []
  type: TYPE_NORMAL
