- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 15 EXTENDED HEAPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore some new data structures that allow extra operations
    on heaps. For example, we’ll be able to change or alter the value of a key by
    increasing or decreasing it, or produce a new heap out of two or more other heaps
    by melding or merging. These new structures are based on several concepts we’ve
    looked at in previous chapters, such as common heaps, linked (and doubly linked)
    lists, forests, and more.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll consider *skew heaps*, which are heaps implemented as binary trees,
    and *binomial heaps*, which are a new heap implementation based on a forest that
    allows you to merge heaps quickly. We’ll also study an enhanced version of heaps
    called *lazy binomial heaps* that provide better amortized performance, and finish
    by looking at *Fibonacci heaps*, which allow you to change (increase or decrease)
    a key in (amortized) constant time, and *pairing heaps*, which present an easier
    alternative with surprisingly similar performance.
  prefs: []
  type: TYPE_NORMAL
- en: Meldable and Addressable Priority Queues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First review the priority queue abstract data type (ADT) you implemented with
    binary heaps. This ADT requires three operations: add() adds a new value to the
    queue, remove() gets the highest priority from the queue, and top() shows the
    priority of the current top element of the queue. With the binary heap implementation
    that represents the heap as an array, the two first operations run in *O*(log
    *n*) time, and the third runs in *O*(1). The extra change() operation alters the
    priority of an element in the queue, and that also is *O*(log *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: If those three (or four) operations were all that were needed, you’d have a
    good enough implementation. Working with arrays and no pointers is usually quite
    fast, providing performance that is tough to beat. However, if you need specific
    enhanced times (for example, adding new values in constant time) or extra operations
    (like being able to merge two queues into one), you’ll need other solutions. Each
    structure considered in this chapter allows us to meld (or merge) two separate
    priority queues into one. This is called a *meldable priority queue (MPQ)*.
  prefs: []
  type: TYPE_NORMAL
- en: Several algorithms need to be able to meld priority queues, so allowing that
    operation enhances their performance. Imagine you’re implementing a priority queue
    for the printers in your system. If one printer goes down, you want to be able
    to reassign all of its printing jobs to another. A meldable heap would provide
    the fastest performance for such a reassignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also might want to include a second operation: changing a key value. This
    change is a specific one where the old key is replaced with a new one that should
    go higher in the heap—for instance, a lower value in a min heap for several graph
    algorithms. In fact, when working with min heaps, the operation is usually called
    decreaseKey(). Since you’re working with both max and min heaps, you’ll use the
    name changeKey() but will check to make sure the new value should be nearer the
    top of the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: For this, you need a reference to a value that you insert, and you’ll use the
    add() operation for that purpose. A heap that provides such an operation is called
    an *addressable heap*. The main focus of this chapter is on meldable heaps, but
    all of the structures here will be addressable, so we’ll consider both new operations
    together.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We considered max heaps with their highest value at the top in [Chapter 14](chapter14.xhtml).
    Since extended heaps are often used with the lowest value at the top, we’ll use
    the function* goesHigher(a,b) *to determine whether a value* a *should be higher
    than a value* b*. For max heaps, you have* a > b *(so the greater value goes to
    the top), and for min heaps, you have* a < b*. Simply changing a single line in
    the definition of this new function provides max heaps or min heaps as needed.
    All the examples in this chapter use max heaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-1](chapter15.xhtml#tab15-1) shows the operations in terms of a meldable
    priority queue ADT, starting with creating the priority queue, modifying the addition
    operation, and including merging and changing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-1: Operations on Meldable Priority Queues'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → MPQ | Create a new MPQ. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | MPQ → boolean | Determine whether the MPQ is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Add | MPQ × key → MPQ × node | Given a new key, add it to an MPQ and provide
    a reference to the new node. |'
  prefs: []
  type: TYPE_TB
- en: '| Top | MPQ → key | Given an MPQ, produce its top value. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | MPQ → MPQ × key | Given an MPQ, extract its top value and update
    the MPQ correspondingly. |'
  prefs: []
  type: TYPE_TB
- en: '| Change | MPQ × node × key → MPQ | Given an MPQ, one of its nodes, and a new
    key value, change the node’s key to the new value and update the MPQ. |'
  prefs: []
  type: TYPE_TB
- en: '| Merge | MPQ1 × MPQ2 → MPQ | Given two distinct MPQs, merge them into a single
    MPQ. |'
  prefs: []
  type: TYPE_TB
- en: Let’s now move on to a different variety of heap.
  prefs: []
  type: TYPE_NORMAL
- en: Skew Heaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 14](chapter14.xhtml), we represented binary heaps with an array,
    which has the advantage of maximum simplicity. However, with that representation,
    the best performance you can achieve when merging two heaps of sizes *m* and *n*
    is O(*m* + *n*) by using Floyd’s algorithm. (As an alternative, think of choosing
    a heap and adding all the other heaps’ values to it, which would not be optimal;
    see question 15.1.) *Skew heaps*, which are based on representing a heap as a
    self-adjusting binary tree, provide better (although amortized) performance. In
    later sections, we’ll look at even speedier data structures, but those will include
    an added degree of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Skew heaps are related to a data structure (which we don’t discuss in this
    book) called a leftist heap. Skew heaps, however, require less space, are competitive
    as to running time, and are easier to implement.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Skew heaps have one characteristic in common with the binary heaps considered
    previously: the heap property must be satisfied, so a root must be greater than
    its children—in other words, a skew heap is a *heap-ordered binary tree*. (Remember,
    we are working with max heaps; for min heaps, a root would be smaller than its
    children.) However, one important difference is that skew heaps have no structural
    constraints, so the tree can have any shape, and its height may be not logarithmic.
    [Figure 15-1](chapter15.xhtml#fig15-1) illustrates this fact. It shows a valid
    heap, but its shape is different from what we saw in [Chapter 14](chapter14.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-1: A skew heap isn’t complete as common heaps are.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the heap property and no structural constraints, a third particular
    detail is that all adding and removing operations need to use the *skew-merging*
    operation to assure good amortized performance.
  prefs: []
  type: TYPE_NORMAL
- en: Representing a Skew Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since a skew heap is a binary tree at its core, you can represent it using
    the same kind of code for binary search trees and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The goesHigher() function determines whether to have a max heap (as shown here)
    or a min heap (by changing the comparison to a < b). The following three functions
    are copies of the binary search tree code, and the final top() is simple, given
    that the heap’s top will be the tree’s root.
  prefs: []
  type: TYPE_NORMAL
- en: Merging Two Skew Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The logic for merging two skew heaps together is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. If you merge two empty heaps, the result is an empty heap.
  prefs: []
  type: TYPE_NORMAL
- en: 2. If one heap is empty and the other isn’t, the result is the nonempty heap.
  prefs: []
  type: TYPE_NORMAL
- en: 3. If both heaps are nonempty, the heap with the greater root becomes the merged
    heap, but it swaps its children and then merges its left subtree with the heap
    that has the smaller root.
  prefs: []
  type: TYPE_NORMAL
- en: The first two cases are pretty clear, so let’s consider the third, more interesting
    one. If you start with the two skew heaps shown in [Figure 15-2](chapter15.xhtml#fig15-2),
    what’s the result of merging them?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-2: Two skew heaps to be merged'
  prefs: []
  type: TYPE_NORMAL
- en: The root of the merged heap should be 60, because it’s the greater root. (Again,
    keep in mind that you’re working with max heaps.) The left subtree of the corresponding
    tree would switch sides with the right subtree, and the (now) left subtree would
    be merged with the heap with root 56\. Recursively, you’d compare 56 and 34, so
    the new root would be 56, and so on. Can you follow all the steps to the result
    shown in [Figure 15-3](chapter15.xhtml#fig15-3)? For instance, it’s easy to see
    that the old left child of the 60 key now is its right child; the 56 key also
    swapped its subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-3: The result of merging the two skew heaps'
  prefs: []
  type: TYPE_NORMAL
- en: 'Switching subtrees is what provides good amortized performance; if you merge
    without swapping, the performance is worse. (See question 15.2 for two specific
    sequences of operations that produce badly shaped structures.) The logic is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the second heap is empty, return the first one ❶. (This also covers the case
    when both heaps are empty. Can you see why?) Otherwise, if the first heap is empty
    ❷, return the second heap. If no heap is empty and the first heap has the highest
    key, produce a new heap as described earlier ❸. If the second heap has the highest
    key, just swap them around for the merge ❹. (See question 15.3 for an alternative.)
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a Skew Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How do you add a new key to a heap, if all you know is how to merge? Simply
    build a new heap with a single value and merge it to the existing heap. You’ve
    already looked at how to merge heaps, so let’s skip to the actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This just creates a single-node heap ❶ and merges it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the Top Key from a Skew Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Removing the top key from a heap is straightforward. When you remove the root,
    you’re left with two subtrees, so all you need to do is merge them to form the
    new heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the heap is empty ❶, throw an error. Otherwise, get the top key ❷ and merge
    the left and right subtrees ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Skew Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When first thinking about skew heaps and realizing how their structure could
    become quite awful (in the same way that binary trees can degenerate into linear
    shapes), it’s hard to believe that their performance can be good. However, the
    amortized time of additions, removals, and merging can be proven to be *O*(log
    *n*). [Table 15-2](chapter15.xhtml#tab15-2) shows the results; asterisks denote
    amortized values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-2: Performance of Operations for Skew Heaps'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Top | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Change | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Merge | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: The changeKey() method was added, which you can do by first removing the old
    key and then inserting the new one; both are *O*(log *n*) methods. (See question
    15.4.)
  prefs: []
  type: TYPE_NORMAL
- en: Binomial Heaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Skew heaps have amortized logarithmic performance all around, but if you go
    beyond single trees, you can do better. *Binomial heaps* are based on a forest
    of heaps, and not only do they perform well, they also are the basis for some
    enhanced variations with even better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Binomial Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start with a definition: a *binomial tree of order k*, or *BT(k)*, is a *k*-ary
    tree that is either empty or consists of a root whose children are binomial trees
    of order 0, 1, 2, . . . up to (*k* – 1). [Figure 15-4](chapter15.xhtml#fig15-4)
    shows the first five binomial trees, from BT(0) to BT(4), each consisting of a
    root and one copy of each previous binomial tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-4: The first five binomial trees'
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the trees, you may notice some mathematical properties that
    can be properly proven, but the most important ones are that BT(*k*) has exactly
    2*^k* nodes and its height is *k*. They share those two properties with full binary
    trees. (Actually, full binary trees of height *k* have 2*^(k+)*¹ – 1 nodes, but
    it’s close enough. Let it go!)
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The order of a binomial tree equals the degree of its root, so in this code,
    we’ll use degree instead of order, because that will help when we consider Fibonacci
    heaps, which don’t use the order concept but work with the root’s degree.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you count how many nodes each level has, you’ll notice another property
    that explains the name of this heap: for the trees in [Figure 15-4](chapter15.xhtml#fig15-4),
    the results are 1; 1 and 1; 1, 2, and 1; 1, 3, 3, and 1; 1, 4, 6, 4, and 1; and
    so on. These are *binomial coefficients*, as in Pascal’s triangle where each value
    is the sum of the two above it, as shown in [Figure 15-5](chapter15.xhtml#fig15-5).
    Another property of the triangle is that the sum of the numbers in a row is a
    power of 2, which also matches the size property for a BT(*k*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-5: Pascal’s triangle provides the number of values at each level
    of binomial heaps.'
  prefs: []
  type: TYPE_NORMAL
- en: You can look at these trees another way. Notice that each tree is actually built
    out of two trees of the previous order; modifying [Figure 15-4](chapter15.xhtml#fig15-4)
    a bit makes this clearer, as shown in [Figure 15-6](chapter15.xhtml#fig15-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-6: Each binomial tree actually consists of two smaller previous ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-6](chapter15.xhtml#fig15-6) shows the first four binomial trees.
    Each one (except the first) is built out of two copies of the previous tree, joined
    at a new root. If these trees also satisfy the heap order property (all nodes
    are greater than or equal to their children), they’re called *heap-ordered binomial
    trees*. With such trees, you can easily represent a heap whose size is a power
    of 2, but how do you represent other sizes of heaps?'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Defining Binomial Heaps'
  prefs: []
  type: TYPE_NORMAL
- en: A *binomial heap* is a forest of heap-ordered binomial trees. (Some textbooks
    specify that those trees must be ordered by ascending size, but we won’t apply
    that extra rule.) How will this allow us to represent any size of heaps? Binary
    numbers provide an easy answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number 22 in binary is 10110, which means that 22 = 16 + 4 + 2; thus, you
    can represent any integer number as a sum of powers of 2\. In the same way, you
    represent a heap of any size with a set of binomial trees whose sizes add up to
    whatever size you need. (You won’t have two binomial trees of the same order.
    Can you see why?) Keep in mind another property: the representation of a number
    *n* in the binary system requires log *n* bits, rounded up (we’ll use this later).'
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we represent the forest with an array of trees (you could also
    work with a list of linked trees, but that added complexity isn’t needed). Since
    binomial trees are multiway trees, you also need a way to represent them, so we’ll
    use a binary tree representation. Nodes have a down pointer (instead of left)
    to their first child and a right pointer to their next sibling. Nodes also include
    an up link to their parents, in case you want to implement the changeKey() operation.
    Finally, each node also has its degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'This representation is necessary because these algorithms require two operations:
    splitting a tree into several smaller ones and fusing two trees together, and
    those operations are fast and easy to implement with the links. For example, fusing
    two BT(2)s to build a BT(3) requires changing only two pointers (we’ll look at
    that in the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a few basic functions and then add the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A binomial heap, then, is an array ❶, and each of its elements is a binomial
    tree. The nodes have the five attributes described earlier ❷. Checking whether
    the heap is empty just requires testing the length of the array of trees ❸.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You might have wondered about using functions for binomial trees. However,
    since you aren’t actually going to use the trees for searching, you’ll use plain
    records in the code, with* key *and* degree *attributes, as well as with* up*,*
    down*, and* right *pointers. Remember that the order of a binomial tree equals
    the degree of its root; that’s why you have* degree *instead of* order*. Having
    the degree for all roots will help with Fibonacci heaps.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, write the top() procedure, using an auxiliary _findTop() function to
    go through all the roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The _findTop() function ❶ finds which tree has the greatest root; it just goes
    through the trees array looking for the greatest key. With this method, top()
    is simply a matter of checking whether the heap is empty. If so, return undefined;
    otherwise, use _findTop() to get the top value of the heap ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Value to a Binomial Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When adding a value to a heap, start by creating a binomial tree of order 0
    with just the key and add it to the heap; however, this may cause a problem if
    another binomial tree of the same order already exists. (Remember, trees of repeated
    orders aren’t allowed.) You can solve it with merging.
  prefs: []
  type: TYPE_NORMAL
- en: Assume you have two binomial trees of the same order, as shown in [Figure 15-7](chapter15.xhtml#fig15-7),
    and want to merge them into one. In general, one of the trees should become a
    subtree of the other.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-7: Merging two binomial heaps where one becomes a subtree of the
    other'
  prefs: []
  type: TYPE_NORMAL
- en: This example, however, needs further consideration because you’re not dealing
    with just any trees; you’re dealing with trees that satisfy the heap condition.
    So, what do you do in this case? Assume the two trees are as shown in [Figure
    15-8](chapter15.xhtml#fig15-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-8: Two binomial heaps to be merged'
  prefs: []
  type: TYPE_NORMAL
- en: The idea is simple. The greater root becomes the new root, and the smaller root
    becomes its child, as shown in [Figure 15-9](chapter15.xhtml#fig15-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-9: A way to merge the two trees from [Figure 15-8](chapter15.xhtml#fig15-8)'
  prefs: []
  type: TYPE_NORMAL
- en: But [Figure 15-9](chapter15.xhtml#fig15-9) doesn’t show how to actually do it.
    With the binary representation discussed earlier, both original trees would look
    like the ones shown in [Figure 15-10](chapter15.xhtml#fig15-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-10: The actual binary tree representation for the two binomial heaps'
  prefs: []
  type: TYPE_NORMAL
- en: Correspondingly, the result also follows the same scheme of “down to child,
    right to sibling,” as shown in [Figure 15-11](chapter15.xhtml#fig15-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-11: The merged binomial trees in binary tree representation'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, you can always merge two BT(*k*)s into a single BT(*k* + 1), and
    thanks to the binary representation, that procedure requires you to change only
    two links. The code for this is as follows, where low is the tree with the smaller
    root and high is the one with the greater root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s pretty straightforward. The lower tree will have the higher tree’s children
    as siblings ❶ and that node as the parent ❷ ❸, making the new root’s degree go
    up by one ❹. (You’ll use this operation repeatedly in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Now you have the means to merge two trees, but there could be an extra complication.
    In the example, what would happen if the original heap already had another BT(3)?
    In that case, you’d keep merging the original BT(3) with the new one to get a
    BT(4). And, of course, that might lead to a repeated BT(4), and so on. (You’ll
    look at the complete algorithm in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume for a moment that you already have a method to add a new tree into a
    heap by merging; then the add() method is short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You just have to create a new basic BT(0) with the key to be added ❶, which
    is an array with a single object in it, and merge it with the heap ❷. It’s basically
    the same technique used with skew heaps. The difference is how you go about merging
    the heaps.
  prefs: []
  type: TYPE_NORMAL
- en: Merging Two Binomial Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the problem of merging two heaps in terms of summing binary numbers.
    If you’re familiar with the 2048 game where you try to merge boxes together to
    reach 2048, you’ll understand the examples fairly quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Start with an easy case. Say you have a binomial heap with 22 elements (22 =
    2 + 4 + 16) and want to merge it with another binomial heap of a single element,
    as when adding a new value, as shown in [Figure 15-12](chapter15.xhtml#fig15-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-12: Merging two heaps has a lot to do with binary numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Start at (a)—the heap consists of three binomial trees of sizes 2, 4, and 16
    (corresponding to the binary representation of 22)—and represent it with an array,
    using the trees’ order as an index. The tree with 2 elements is at position 1;
    the one with 4 is at position 2, and the one with 16 is at position 4, while other
    positions remain empty (black). Match the tree to be added with the corresponding
    place in the current heap, and it’s empty, so just move it into place (this is
    the equivalent of doing 1 + 0 = 1), and you get (b). No more trees remain to be
    merged, so you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the harder case of merging two separate heaps with the resulting
    heap of size 23 (23 = 1 + 2 + 4 + 16) and another heap of size 5 (5 = 1 + 4),
    as shown in [Figure 15-13](chapter15.xhtml#fig15-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-13: Working through the merging, step by step'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start at (a), matching 1 and 1: remove the 1 from the top heap and merge it
    with the 1 at the bottom heap, which becomes a 2\. Then you arrive at (b) and
    match 2 and 2\. Again, remove the 2 from the top heap and merge it with the 2
    at the bottom, which becomes a 4\. In (c), the situation repeats: you again remove
    from the top and merge at the bottom. (The bottom values are no longer in ascending
    order—you have an 8 first and a 4 second—but that won’t impact the final result.)
    At (d), you have an easy case because there is no 8 at the top, so just put the
    8 there and remove it from the bottom. At (e), you now have a 4, and it has no
    match, so place it at the top and remove it from the bottom, getting to (f), where
    you are finished, since there are no more values to merge.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now solved the problem: merging goes on until no trees of duplicate
    order remain. Implementing the method isn’t complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, you place all the binomial trees of the heap in the merged array ❶, setting
    each tree in its place according to its order. Then, start processing all the
    trees in the second list ❷, “adding” them as described. If you don’t have a match
    in merged, just put the new tree in there ❸ and advance to the following tree
    to merge. Otherwise, when there’s a match, merge both trees. You have one case
    if the second tree has the greater root ❹ and a different case if the merged tree
    has it ❺. In both cases, place the resulting tree in the second array, emptying
    the place in merged ❻. At the end, after going through all the trees in the second
    array ❼, filter out the merged array to remove empty trees.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Value from a Binomial Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The method to remove the top value from a heap is based on breaking a binomial
    tree apart by removing its root and then melding the separated trees with the
    original heap. Assume the heap consists of two binomial trees (sizes 2 and 8)
    and remove the top value (60), as shown in [Figure 15-14](chapter15.xhtml#fig15-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-14: A heap with two binomial trees'
  prefs: []
  type: TYPE_NORMAL
- en: After removing the top value, separate its subtrees (of sizes 4, 2, and 1),
    leaving four binomial trees, as shown in [Figure 15-15](chapter15.xhtml#fig15-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-15: After you remove the 60 value, the tree becomes several heaps.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, use the same method as before to merge these four trees with an initially
    empty set of trees. The first step melds together the two 2-sized trees, as shown
    in [Figure 15-16](chapter15.xhtml#fig15-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-16: The first step of the merge'
  prefs: []
  type: TYPE_NORMAL
- en: Then, as you have two 4-sized (order 2) trees, do another merge, as shown in
    [Figure 15-17](chapter15.xhtml#fig15-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-17: The second merge finishes the job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And you’re done! The new binomial heap has one fewer element, and you managed
    that easily by splitting the tree into subtrees and using the merging code you
    had already written. The remove() method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, check whether the heap is empty ❶. Then find which tree has the greatest
    root ❷ and get its value ❸ to return it at the end. Create a newTrees array ❹
    and set up a loop ❺ to push the tree ❻ and its siblings ❼ there. After splitting
    the original tree, remove it from the heap ❽ and use the merge() function ❾ to
    merge the new trees into the rest of the original heap.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a Value in a Binomial Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some graph-oriented algorithms often need to change a value already in a heap.
    In such cases, the heap typically includes full records instead of just a priority
    and keeps an external reference to the heap node that includes the record. (We’ll
    look at such graph algorithms in [Chapter 17](chapter17.xhtml).) We won’t go into
    all of that here, but the logic remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The most common case is working with min heaps and decreasing a priority with
    a* decreaseKey() *method. If you want to work with a min heap, all you need to
    do is change the direction of the comparison in the* goesHigher() *function described
    earlier in this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already discussed how to change a value in binary heaps: after effecting
    the change, it’s simply a matter of bubbling it up or sinking it down, depending
    on the relationship with other values. In this chapter, we’ll consider only the
    logic to bubble up a key, moving toward the top of the heap, since that’s the
    case actually needed in practice. In [Figure 15-18](chapter15.xhtml#fig15-18),
    say you want to change the 4 key to 50.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-18: A key-changing example, step by step'
  prefs: []
  type: TYPE_NORMAL
- en: Change the key and compare it to the parent, unless you already are at the root,
    which means you’re finished. If you’re not at the root, if the changed key is
    smaller, you’re done; otherwise, you have to swap nodes and keep bubbling up.
    Starting at (a), change the 4 key to a 50 in (b). Now compare 50 with 22 and exchange
    the nodes (actually, it’s the pointers that are exchanged) getting to (c). A new
    comparison, 50 and 40, requires yet another exchange as in (d), but now 50 is
    smaller than its parent (60), so you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The need for a value to bubble up is the only reason we include an* up *pointer
    in the tree’s nodes. If you don’t plan to provide the* changeKey() *method, you
    can remove all instances of* up *in the code.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the implementation for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'First check whether the operation is possible: the heap shouldn’t be empty
    ❶, and the new key should go higher in the heap ❷. If everything’s okay, change
    the node’s key to the new value and call _bubbleUp() to make it climb up the heap
    ❸ if that’s needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for bubbling up is as follows, and it has the longest line of code
    in this entire book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First see whether any bubbling up is needed. If the node doesn’t have a parent,
    or if it has one but the parent’s key is higher than the node’s key, nothing’s
    required ❶. If you need to swap the node up, get a pointer to its parent ❷, and
    make all the pointer (and degree) changes we saw previously (it’s quite a long
    line ❸ but straightforward in concept). Finally, if the node again has a parent,
    use recursion to check whether it still has to bubble up more ❹. If the node doesn’t
    have a parent ❺ (meaning it got to the top of its heap), you need to fix the reference
    in the array of heaps, so instead of pointing to the old node’s parent, now it
    points to the new top. (Couldn’t we just have exchanged keys between the node
    and its parent, as with binary heaps? The answer is important; see question 15.7
    for more on this.)
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Binomial Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 15-3](chapter15.xhtml#tab15-3) summarizes the binomial heaps’ performance;
    results with an asterisk are amortized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-3: Performance of Operations for Binomial Heaps'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Top | O(log n) as seen; O(1) with a fix |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Change | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: '| Merge | O(log n) |'
  prefs: []
  type: TYPE_TB
- en: Given that a binomial heap may consist of up to log *n* heaps, getting the top
    is *O*(log *n*). If you only did additions but no removals, the amortized order
    of adding a new value would be *O*(1)—see question 15.5 for more on this—but we
    can prove that sequences of operations worsen this result to *O*(log *n*). Getting
    the top value, as implemented previously, means looking through log *n* heaps,
    but that can be enhanced to *O*(1); see question 15.6\. As for the other results,
    removing the top value means separating a heap into, at most, log *n* subtrees,
    doing an *O*(log *n*) procedure, followed by merging, which is another *O*(log
    *n*) procedure, so that’s the total order for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Binomial Heaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binomial heaps have a potential performance problem when adding values, when
    you go from *O*(1) to *O*(log *n*), which means you can think in amortized terms
    to find a solution that enhances this procedure at the possible risk of (not too
    often) costlier fixes. *Lazy binomial heaps* do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: With lazy binomial heaps, when you do additions, you don’t care about merging.
    You just let the heap have more and more trees, so add() is a trivial operation,
    running in *O*(1). Take care, however, to keep track of the greatest value, so
    top() is also *O*(1). You can fix the structure when you try to remove() a value,
    except then you process the heap to bring it back into binomial heap shape.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Lazy Binomial Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Lazy binomial heaps are binomial heaps after all, although you add an extra
    top property to keep track of the top value in the heap. The class definition
    then is quite short, as most of the methods are shared with binomial heaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, there are only two differences. A heap is now a record with two fields:
    top ❶, which will have the top value of the heap, and the trees array, which are
    the individual heaps. An empty heap has no trees ❷, so use that for detection.
    You need to update top when adding to or removing from the heap. The top() method
    ❸ is quite short: if the heap is empty, return undefined; otherwise, return the
    value of heap.top. With this implementation, you don’t need to go through the
    whole trees array to find the top, which provides enhanced performance, although
    later heap.top will need some extra maintenance work.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Value to a Lazy Binomial Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first important difference with lazy binomial heaps is that you won’t do
    any merging when adding a new key. How is this possible? First, if you want to
    know the top of the heap, you can do that without any structure. The heap.top
    attribute described earlier can be updated easily. As long as you keep adding,
    the heap just grows a tree at a time, and you’ll always know the top of the heap.
    For example, assume that a binomial heap had the structure shown in [Figure 15-19](chapter15.xhtml#fig15-19)
    at a certain moment; the triangle points to the maximum of the heap at that time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-19: Tracking the top value just needs a simple property.'
  prefs: []
  type: TYPE_NORMAL
- en: If you add three new values, the process is quite fast, as the only thing you
    do is add new trees. The diagram in [Figure 15-20](chapter15.xhtml#fig15-20) with
    several binomial trees of the same order, which wouldn’t be allowed in binomial
    heaps, shows this. Again, after each addition, update the maximum. In this example,
    one of the newly added keys was greater than the previous maximum, so you now
    have a different top of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-20: After you add values, the property needs adjustment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But removing the heap’s top is a different scenario, because then finding the
    new _heapTop is too slow: *O*(*n*). You can restructure the heap by merging trees
    together only when removing a key. Some math (which we’ll skip) shows that the
    amortized performance remains quite good.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for adding a value is similar to what you saw before, but instead
    of merging a new tree, you just add it with no further process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, create a new binomial tree with the new key ❶ and push it to the end
    of the current trees array ❷. The only extra step is possibly updating the heap’s
    top. If the array of trees is empty or if the current top is not greater than
    the newly added value ❸, reset heap.top.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Value from a Lazy Binomial Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned previously, the idea with lazy binomial heaps is to delay merging
    trees as long as possible (thus, the term *lazy*). When you remove a key, first
    merge together all the current binomial trees to get a binomial heap and then
    proceed with the removal.
  prefs: []
  type: TYPE_NORMAL
- en: You do this because although the number of trees in the heap grows slowly when
    adding values and eventually becomes high, it drops sharply after merging, and
    the balance between many fast operations and an eventual slow one ends with a
    nice amortized cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows; notice it has a few changes and additions in comparison
    to the original binomial heaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'First check whether the heap is empty ❶ and save the current top of the heap
    ❷ to return its value later ❽. Then find which tree had the top ❸ and do a loop
    to split its subtrees ❹, which you then add to the list of trees. Then remove
    the split tree ❺, merge all trees together ❻, and update heap.top ❼ to find the
    new current top. It’s not very different from binomial heaps. The way you merge
    all trees together is pretty neat: by merging an empty heap with the list of trees,
    you trigger all the necessary merges that will reduce the number of trees. Can
    you see how it works?'
  prefs: []
  type: TYPE_NORMAL
- en: Changing a Value in a Lazy Binomial Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one final method: how to change any key. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code is the same as for binomial heaps, with the addition of the single
    line to update heap.top; you did a similar calculation in remove(). The code for
    _bubbleUp() is unchanged, so it’s not repeated here.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Lazy Binomial Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The performance of lazy binomial heaps is similar to that of binomial heaps,
    but postponing merges has a positive effect in amortized terms. In particular,
    adding a value is logically faster, since you don’t do practically anything, as
    [Table 15-4](chapter15.xhtml#tab15-4) shows. Remember, asterisks denote amortized
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-4: Performance of Operations for Lazy Binomial Heaps'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Top | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Change | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Merge | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: You now have very good performance (in particular, adding a new value is faster),
    but you’ll want a better result when changing a value. Let’s look at another variant
    of binomial heaps that allows this enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci Heaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some graph algorithms use min heaps and frequently call the decreaseKey() operation,
    which we renamed to changeKey() to allow for max heaps and min heaps. In that
    situation, being able to decrease keys in a quicker fashion than the *O*(log *n*)
    performance for lazy binomial heaps becomes important. Enter *Fibonacci heaps*,
    which are quite similar to lazy binomial heaps but allow a faster algorithm to
    change a key.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Michael Fredman and Robert Tarjan described Fibonacci heaps in their paper
    “Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms” (network
    refers to graphs in this title), but Tarjan later suggested an alternative simpler
    structure called pairing heaps, which we’ll study later.*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the idea behind Fibonacci heaps? The add() and remove() methods work
    the same way as with lazy binomial heaps, but the difference appears when changing
    a key. If a key is changed and has to bubble up (in a max heap, this would happen
    if the new value was greater than before; in a min heap, if smaller), you obviously
    might need to bubble it up even to the root of its tree—that’s *O*(log *n*).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of doing any bubbling, just separate that node with its subtree and
    add it as a new tree to the heap—that’s *O*(1). However, since this process alters
    the expected shape of the binomial trees and doing it too often could lead to
    badly structured heaps, there’s a compromise. You won’t allow non-root nodes to
    lose more than one child in the described fashion. Should a node lose a second
    node (and you’ll know it because every time a node loses a child, the node will
    be marked), you’ll also separate it, which itself may lead to further separations.
    And, as with lazy binomial heaps, you’ll patch things up when a removal is done;
    you will see all of this later, but first consider how to represent the new heaps.
  prefs: []
  type: TYPE_NORMAL
- en: Representing a Fibonacci Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The structure used earlier—an array of trees where each tree is represented
    with up, right, and down links plus a degree field with the number of children—works,
    but that’s not efficient enough for the operation needed here. When changing a
    key and it bubbles up, the idea is to remove the corresponding node and its subtree,
    but can you quickly unlink it from its siblings? If you keep the siblings in a
    singly linked list, that procedure requires traversing a list with a size of up
    to *O*(log *n*), which will spoil the *O*(1) goal. So, in the same way as shown
    in [Chapter 10](chapter10.xhtml), use a doubly linked list here. But there’s more!
    When merging trees, you want to merge two lists of siblings, so make the lists
    circular, and that will complete the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-21](chapter15.xhtml#fig15-21) shows a small BT(3) and how it would
    look with all the added links in a Fibonacci heap.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-21: A binomial tree represented in Fibonacci heap style'
  prefs: []
  type: TYPE_NORMAL
- en: Showing all the up and down and left and right links makes for a cluttered diagram,
    so from now on, we’ll remove any unnecessary links. For instance, the up links
    to parents will be removed, as you can deduce those from the diagrams. We’ll also
    omit arrowheads and circular links for single node lists for clarity, but we’ll
    point out when we make those alterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up the changes, we add a left link to the nodes (so we can build the
    circular doubly linked list) and a marked boolean field, which we’ll use to mark
    a node that has lost a child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The single change is the addition of the **marked** and **left** fields; the
    rest is the same as it was for lazy binomial heaps.  #### Merging Two Fibonacci
    Trees'
  prefs: []
  type: TYPE_NORMAL
- en: When we first looked at how to merge binomial trees, the procedure was relatively
    simple. Now that siblings are in a circular doubly linked list, however, you’ll
    need to make some changes. Say you want to merge the trees shown in [Figure 15-22](chapter15.xhtml#fig15-22)
    (remember, details for subtrees that won’t be affected by the changes, as well
    as arrowheads and up links, are hidden).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-22: Two Fibonacci trees to be merged'
  prefs: []
  type: TYPE_NORMAL
- en: After merging the trees together, you get the result shown in [Figure 15-23](chapter15.xhtml#fig15-23).
    Pay particular attention to the changed links; arrowheads are included only for
    those.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-23: The result of merging the trees; only a few pointers needed to
    change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the new merging code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the tree with the higher key has no children, the logic is simple, because
    you just need to set the lower tree as its child ❸ ❹. However, if it does have
    children ❶, you need to add the lower tree’s root as a new sibling to the higher
    tree’s root’s children ❷. (Notice the four link changes.) After that, make the
    higher root point to the lower root ❸ and vice versa ❹. Then increment the higher
    root’s degree by 1 ❺ since it gained a new child and return the merged tree ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Value to a Fibonacci Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adding a new value to the Fibonacci heap isn’t very different from lazy binomial
    heaps. The only change is you need to set up the circular list of siblings (initially
    with just the node itself) for future merging operations. The following code highlights
    the needed changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Initialize the left and right pointers of the new node appropriately, so they
    form a single-node circular list. (Yes, you could write the two lines as a single
    assignment; see question 15.9.) The new tree will have marked set to false, because
    the node hasn’t yet lost any children. To check this, see the newNode() code,
    in the section “Representing a Fibonacci Heap” on page 368.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Value from a Fibonacci Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The logic for removing a value is essentially the same as for other binomial
    heaps, with minor changes. Removing the top of the heap also works the same as
    with lazy binomial trees, except beware of infinite loops when traversing the
    circular list of siblings, for example. The new lines are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To avoid infinite loops, set the rightmost link of the list to null ❶ to ensure
    that the following loop will stop. (Here, bt points to an element in the circular
    list. Traverse this list to the right, so bt.left points to what should be the
    last element to visit. If you clear the right link of bt.left, this ensures that
    the loop will stop.) The other difference is when you extract a sibling, the root
    must be a circular link by itself ❷, so you have to fix its left and right links.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a Value in a Fibonacci Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How a key change is handled is what sets Fibonacci heaps apart from the other
    types of heaps. Instead of bubbling up, you directly separate that key from the
    heap. The code is similar to what you saw before, but it has one significant change
    (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you actually change the node’s key, you *separate* it from the heap instead
    of bubbling up. To illustrate, consider the heap shown in [Figure 15-24](chapter15.xhtml#fig15-24)
    from earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-24: The previous Fibonacci heap'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the 9 key is changing to 99, as shown in [Figure 15-25](chapter15.xhtml#fig15-25).
    Since it would be bubbling up, just remove it from the heap and mark its parent
    (80).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-25: The Fibonacci heap after changing a key from 9 to 99'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing you had to do is unlink the 9 (now 99) from its siblings. If
    you now want to change the 60 to 66, you also need to change 80’s down pointer.
    You can make it point to 60’s right sibling, as shown in [Figure 15-26](chapter15.xhtml#fig15-26).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-26: Another change in the tree, and 60 becomes 66.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to do an extra step. After this separation, if 80 isn’t the root,
    since it was already marked (meaning it had already lost one child), you’d also
    have to separate it, applying exactly the same logic as earlier. The code looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Start by unmarking the node to be separated ❶. This is the *only* way a node
    can become unmarked again. You then get the parent of the node ❷, but if it has
    none (meaning the node is a root), don’t do anything. Otherwise, if the node has
    a parent ❸, start unlinking. If the changing node has no siblings ❹, just set
    the parent’s down link to null, and you’re done. But if instead the parent is
    pointing down directly to the node you are changing ❺, you must change the link
    to a sibling, so you don’t break the structure when removing the changing node.
    Now that you are sure the parent is pointing to a different sibling, you can easily
    unlink the node from the doubly linked list ❻. Then you need to reduce the parent’s
    degree by one ❼, since it will be losing a child, and push the separated subtree
    after fixing its links ❽. The last check is if you are removing a child from a
    node that was marked (meaning it had already lost another child), recursively
    separate it ❾; otherwise, just mark it ❿, and you’re finished.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Fibonacci Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Binomial heaps are formed of binomial trees, and each tree has a number of nodes
    that is a power of 2\. Before any changes (which start pruning the trees), a Fibonacci
    heap has same-sized trees, but how low can they go? [Figure 15-27](chapter15.xhtml#fig15-27)
    shows a Fibonacci heap with as many nodes removed as possible; the white nodes
    were removed, and black nodes are left.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-27: Fibonacci trees with a minimum number of nodes'
  prefs: []
  type: TYPE_NORMAL
- en: How do you remove as many nodes as possible from a tree without causing any
    cascading? Or, how do you build the next tree, out of the previous ones, all pruned
    as much as possible? The worst you can do is promote the largest subtree of every
    node. In that case, the individual trees would at least have 1, 1, 2, 3, 5, 8,
    . . . nodes. Recognize the sequence? The trees in this scheme would have at least
    as many nodes as a Fibonacci number (instead of a power of 2). This also helps
    because Fibonacci numbers are exponential in nature, implying that the algorithms’
    performance will still be logarithmic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-5](chapter15.xhtml#tab15-5) summarizes the performance of Fibonacci
    heaps; the values with an asterisk are amortized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-5: Performance of Operations for Fibonacci Heaps'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Top | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Change | O(1)* |'
  prefs: []
  type: TYPE_TB
- en: '| Merge | O(1) |'
  prefs: []
  type: TYPE_TB
- en: You can’t do better than *O*(1) for insertions, but removals possibly could
    be better than *O*(log *n*). However, in that case, you could sort a set of *n*
    values in *O*(*n*) time by inserting all of them into the heap and then removing
    them in order, but you already know you can’t have a sorting algorithm that depends
    on key-to-key comparisons run with a faster time than *O*(*n* log *n*), so you
    can’t do removals with better speed.
  prefs: []
  type: TYPE_NORMAL
- en: What you can do is use a simpler structure, with less complex algorithms. The
    last type of extended heap we’ll consider in this chapter, the pairing heap, does
    exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing Heaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *pairing heap* is a multiary data structure that satisfies the heap property.
    It basically consists of a root that has the top value of the heap and an ordered
    set of heaps, so you could call it an orchard in terms of the definitions from
    [Chapter 13](chapter13.xhtml). In more formal terms, you could say that a pairing
    heap is either an empty structure or a root element plus a (possibly empty) list
    of pairing heaps. Each individual heap is represented in the “left child, right
    sibling” style; [Figure 15-28](chapter15.xhtml#fig15-28) shows an example of a
    pairing heap.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-28: A sample pairing heap'
  prefs: []
  type: TYPE_NORMAL
- en: The root is 60 and has three subheaps with keys 22, 56, and 12\. The subheaps
    have 3, 5, and 2 elements, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Defining a Pairing Heap'
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t consider the changeKey() operation (but see question 15.4), so the
    representation is a tad simpler. Here’s the basic starting code for a pairing
    heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It’s the same code as for skew heaps, except the left pointer is named down
    and a small change was made in isEmpty().
  prefs: []
  type: TYPE_NORMAL
- en: Melding Two Pairing Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How do we meld two heaps? If one of the two heaps is empty, just return the
    other one. Otherwise, if neither heap is empty, the heap with the greatest key
    will have the other heap added (melded) to its list of subtrees. For instance,
    see what happens if you want meld the first two subheaps in [Figure 15-29](chapter15.xhtml#fig15-29)
    (this is an important example, and you’ll return to it later).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-29: Two pairing heaps to be merged'
  prefs: []
  type: TYPE_NORMAL
- en: The new root should be 56, so the first heap (the one with root 22) becomes
    a child of the second heap, producing the configuration shown in [Figure 15-30](chapter15.xhtml#fig15-30).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-30: The result of merging'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement this easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If one heap is empty ❶ ❷, the result of the merge is just the other tree. Otherwise,
    if the first heap has the highest key ❸, make the second heap its child. The last
    case is the same ❹ but in reverse, making the first heap a child of the second.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Value to a Pairing Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Adding a new value to the heap is done with the same method as for skew heaps.
    Create a new heap with only the new value in it and merge it with the current
    heap. You’ve already seen how merging works. The code is almost a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It creates a new heap ❶ with a single value in it and merges it with the current
    heap ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the Top Value from a Pairing Heap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing the top value from the heap is harder than adding a new value, and
    it requires a lot of melding. Basically, you want to remove the heap’s root and
    produce a list of subheaps, which you’ll meld in pairs from left to right and
    then meld the resulting list of heaps from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The name pairing heaps comes from the procedure described previously where
    many heaps are always merged in pairs, two by two.*'
  prefs: []
  type: TYPE_NORMAL
- en: First, take a look at how to meld several heaps together. [Figure 15-31](chapter15.xhtml#fig15-31)
    shows an example for seven heaps A through G.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-31: Melding seven heaps together, always working two at a time'
  prefs: []
  type: TYPE_NORMAL
- en: First merge A and B, and combine that with the result of merging C through G.
    The second merge starts by merging C and D, and then it merges E through G. The
    third merge merges E and F first and then waits for the merge of only G (which
    is trivially just G), so you can complete merging E through G, and then C through
    G, and finally A through G.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this seesaw from left to right and then from right to left is
    actually easy. It’s based on a recursive idea: given a list of heaps, merge the
    initial two heaps on the list to produce a first heap, apply recursion to meld
    all the others into a second heap, and finish by merging both results together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code shows two simple, one-liner cases. If you have no heaps to merge ❶,
    a null heap is returned, and if there is only one heap to merge ❷, the result
    is that heap itself. If you have several heaps ❸, merge the two first heaps, then
    recursively merge all the other heaps, and finish by merging both heaps together.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is actually an implementation of the left-to-right then right-to-left
    process described previously, so now redo the case with the seven heaps A through
    G you looked at earlier. Writing mbp() for mergeByPairs() and m() for merge(),
    it would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this auxiliary method, you can now write the remove() code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the heap is empty ❶, throw an error, because you cannot proceed with the
    removal. Otherwise, get the top value ❷, so you can return it later ❼, and proceed
    to separate the subheaps. Initialize an array for the children ❸ and set up a
    child variable ❹ to loop through all the root’s children ❺. Then push each of
    the subheaps ❻, after remembering to unlink each from its siblings. After pushing
    all children into the array, merge them by pairs as described previously and return
    the removed top ❼.
  prefs: []
  type: TYPE_NORMAL
- en: For example, assume you start again with the original pairing heap (see [Figure
    15-32](chapter15.xhtml#fig15-32)) and want to remove its root.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-32: The original pairing heap revisited'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the root leaves three heaps. Start by melding the first two, those
    with roots 22 and 56 (you saw this in the previous section), resulting in [Figure
    15-33](chapter15.xhtml#fig15-33).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-33: The pairing heap after removing its root'
  prefs: []
  type: TYPE_NORMAL
- en: The final step is melding those heaps, resulting in the situation shown in [Figure
    15-34](chapter15.xhtml#fig15-34).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-34: The separate heaps melded again into a single heap'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now consider another procedure: changing a key’s value.  #### Changing
    a Value in a Pairing Heap'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to change a key is based on what you’ve already seen. First, change
    the key in place, but if it needs bubbling up (as with binomial heaps), separate
    it from the heap (as with Fibonacci heaps). Then merge the separated heap back
    into the original heap. You’re reusing concepts and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For example, start with the heap shown in [Figure 15-35](chapter15.xhtml#fig15-35).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-35: A pairing heap just before changing a key'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to change the 40 key, for example, and changed it to any value between
    40 and 56, you’d just change the key and be done with it. However, if you change
    it to anything greater than its parent key (56), you have to split the heap and
    remerge it. This means if you want to change it to 78, after changing the key
    and splitting the heap away, you are left with the pair of heaps shown in [Figure
    15-36](chapter15.xhtml#fig15-36).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-36: Changing the 40 to a 78 splits the heap in two.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the merging function we’ve looked at previously, [Figure 15-37](chapter15.xhtml#fig15-37)
    shows the final result.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-37: Merging results in a single heap again'
  prefs: []
  type: TYPE_NORMAL
- en: If you had changed the 40 to 58 instead of 78, the result would be different
    (see [Figure 15-38](chapter15.xhtml#fig15-38)). Can you see why?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-38: An alternative result if you had changed the 40 to 58'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to code the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first two if() statements are the same ones you’ve seen before to check
    whether the change is possible. Then, actually change the node’s key ❶ and get
    a pointer to its parent ❷. If there’s a parent and the new node’s key should go
    higher ❸, then you need to act; otherwise, nothing else is needed. If the node
    was the first child of its parent ❹, separate the node from the heap by changing
    the link down from its parent to point to the node’s first sibling. Otherwise,
    if the node isn’t the first child, loop through the siblings list ❺ ❻ ❼ until
    you find the node’s previous sibling. Then unlink the node from the list ❽ ❾ and
    finish by merging the separated heap back into the original ❿. (Similar procedures
    were discussed in [Chapter 7](chapter7.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Pairing Heaps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The performance of pairing heaps is similar to that of Fibonacci heaps, as shown
    in [Table 15-6](chapter15.xhtml#tab15-6); values with an asterisk are amortized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-6: Performance of Operations for Pairing Heaps'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Top | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Top | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(log n)* |'
  prefs: []
  type: TYPE_TB
- en: '| Change | O(log n)? |'
  prefs: []
  type: TYPE_TB
- en: '| Merge | O(1) |'
  prefs: []
  type: TYPE_TB
- en: Why does changing a value have a question mark in the table? There’s still no
    consensus as to the precise amortized order of this operation. An initial estimate
    suggested it would be *O*(1), but then it was proven to be at least Ω(log log
    *n*). Further work produced an *O*(log *n*) estimate, but no definite proof has
    yet appeared. In any case, this looks worse than Fibonacci heaps, but in practice,
    the performance of pairing heaps is reported to be excellent, despite the purported
    theoretical deficiency, which is most likely a result of the simpler implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we studied binary heaps that were represented with
    an array, and in this chapter, we completed our overview of heaps, exploring several
    extended versions that are implemented with binary trees, multiway trees, or forests
    and that allow operations such as merging two heaps and changing a key in a more
    performant way. These changes not only maintained the functionality of the previous
    heaps, but they also added enhanced performance and new features, allowing us
    to use these structures for other types of problems that common heaps wouldn’t
    handle as well. This chapter presents the best example of the possibilities of
    modified (or hybrid, if you will) structures that add speed and functionality—but
    at the obvious cost, clearly, of some more complex algorithms!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**15.1  Intuitive but Worse**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have two common heaps of sizes *m* and *n* and you implement melding
    by applying the following intuitive method: successively choose all the elements
    from one heap and insert them into the other. What would be the order of this
    method?'
  prefs: []
  type: TYPE_NORMAL
- en: '**15.2  Sequential Cases**'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the shape of a skew heap if you insert keys in ascending order? What
    about in descending order?
  prefs: []
  type: TYPE_NORMAL
- en: '**15.3  No Recursion Needed**'
  prefs: []
  type: TYPE_NORMAL
- en: When merging two skew heaps and the second had the greater key, no recursion
    was actually needed; could you do the merge directly?
  prefs: []
  type: TYPE_NORMAL
- en: '**15.4  Change Needed**'
  prefs: []
  type: TYPE_NORMAL
- en: How would you implement the changeKey() function for skew heaps? Would you need
    to make some structure changes, and if so, what would they be?
  prefs: []
  type: TYPE_NORMAL
- en: '**15.5  Just Adding**'
  prefs: []
  type: TYPE_NORMAL
- en: Assume you have a binomial heap with only a BT(3) in it, so it has eight values.
    Add a new value to that node eight times and count how many merges are needed.
    What can you conclude about the amortized cost of the operation?
  prefs: []
  type: TYPE_NORMAL
- en: '**15.6  Faster Binomial Top**'
  prefs: []
  type: TYPE_NORMAL
- en: You can accelerate reaching the top of a binomial heap with means used for other
    heaps; can you figure out how to do so?
  prefs: []
  type: TYPE_NORMAL
- en: '**15.7  Easier Bubbling Up?**'
  prefs: []
  type: TYPE_NORMAL
- en: Why can’t you implement the _bubbleUp() method for binomial trees in the following
    way, similar to what you wrote for binary heaps? (The reason is easy to miss.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**15.8  Searching a Heap**'
  prefs: []
  type: TYPE_NORMAL
- en: Even if it makes little sense, can you implement a find() function for heaps?
    Be careful with Fibonacci heaps, so you don’t create an infinite loop because
    of the circular lists.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.9  Two in One**'
  prefs: []
  type: TYPE_NORMAL
- en: In a Fibonacci heap, you can make the add(), remove(), and mergeA2B() methods
    a few lines shorter by joining assignments with the same right value; can you
    see how?
  prefs: []
  type: TYPE_NORMAL
