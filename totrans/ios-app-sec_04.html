<html><head></head><body>
<h2 class="h2" id="ch03"><a id="page_27"/><strong><span class="big">3</span></strong><br/><strong>IOS APPLICATION ANATOMY</strong></h2>
<p class="noindent">To understand some of the problems iOS applications face, it’s useful to get an idea of how different types of data are stored and manipulated within an application’s private directory, where all of its configuration, assets, binaries, and documents are stored. This is where you can discover all manner of information leakage, as well as dig in to the guts of the program that you’re examining.</p>
<p class="indent">The quickest way find out what data your application stores locally on an iOS device is to check out <em>~Library/Developer/CoreSimulator/Devices</em>. Starting with Xcode 6, each combination of device type and OS version you’ve ever deployed into the Simulator application is assigned a UUID. Your particular application’s data will be stored in two places under this directory. Your application binary and assets, including <em>.nib</em> user interface files and graphic files included with the application, are in <em>&lt;device ID&gt;/data/Containers/Bundle/Application/&lt;app bundle id&gt;</em>. The more dynamic data that your application stores is in <em>~&lt;device ID&gt;/data/Containers/Data/Application/&lt;app bundle id&gt;</em>. Systemwide data such as global configurations will be stored in the remainder of the <em>&lt;device ID&gt;</em> directory.</p>
<p class="indent"><a id="page_28"/>Exploring this directory structure, which is sketched out in simplified form in <a href="ch03.html#ch3fig1">Figure 3-1</a>, also reveals which types of data are handled by OS services rather than your application.</p>
<div class="image"><img alt="image" src="graphics/f03-01.jpg"/></div>
<p class="figcap"><a id="ch3fig1"/><em>Figure 3-1: Layout of an application directory</em></p>
<p class="indent">If you’re on a jailbroken device, you can use SSH to connect to the device and explore the directory structure; I’ll talk about jailbreaking and connecting to test devices in <a href="ch06.html#ch06">Chapter 6</a>. Whether or not your device is jailbroken, you can use a tool such as iExplorer<sup><a href="footnote.html#fn17" id="fn_17">1</a></sup> to examine the directory structure of your installed applications, as shown in <a href="ch03.html#ch3fig2">Figure 3-2</a>.</p>
<p class="indent">In the rest of this chapter, I’ll cover some of the common directories and data stores used by iOS applications, as well as how to interact with them programmatically and what data can leak from them.</p>
<div class="image"><a id="page_29"/><img alt="image" src="graphics/f03-02.jpg"/></div>
<p class="figcap"><a id="ch3fig2"/><em>Figure 3-2: Examining an application bundle with iExplorer</em></p>
<h3 class="h3" id="ch03lev1sec01"><strong>Dealing with plist Files</strong></h3>
<p class="noindent">Before you start examining the directory structure, you need to know how to read some of the stuff you’ll find there. iOS stores app configuration data inside <em>property list (plist)</em> files, which hold this information in Core Foundation data types such as <code>CFArray</code>, <code>CFString</code>, and so forth. From a security standpoint, you want to examine plists for things that shouldn’t be stored in plaintext, such as credentials, and then potentially manipulate them to change the application’s behavior. For instance, you could enable a paid feature that’s disabled.</p>
<p class="indent">There are two types of plist formats: binary and XML. As you can see in the following example, the XML format is easily readable by humans.</p>
<pre>&lt;?<span class="rose">xml version</span>=<span class="red">"1.0"</span> encoding=<span class="red">"UTF-8"</span>?&gt;<br/>&lt;!<span class="rose">DOCTYPE</span> plist <span class="rose">PUBLIC</span> <span class="red">"-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/</span><br/>    <span class="red">PropertyList-1.0.dtd"</span>&gt;<br/>&lt;plist <span class="rose">version</span>=<span class="red">"1.0"</span>&gt;<br/>&lt;dict&gt;<br/>&lt;plist <span class="rose">version</span>=<span class="red">"1.0"</span>&gt;<br/>&lt;dict&gt;<br/>  &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;<br/>  &lt;string&gt;en&lt;/string&gt;<br/>  &lt;key&gt;CFBundleExecutable&lt;/key&gt;<br/>  &lt;string&gt;Test&lt;/string&gt;<br/>  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;<br/>  &lt;string&gt;com.dthiel.Test&lt;/string&gt;<br/>  &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;<br/>  &lt;string&gt;6.0&lt;/string&gt;<br/>  &lt;key&gt;CFBundleName&lt;/key&gt;<br/>  &lt;string&gt;Test&lt;/string&gt;<br/>  &lt;key&gt;CFBundlePackageType&lt;/key&gt;<br/>  &lt;string&gt;APPL&lt;/string&gt;<br/>  &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;<br/>  &lt;string&gt;1.0&lt;/string&gt;<br/>  &lt;key&gt;CFBundleSignature&lt;/key&gt;<br/>  &lt;string&gt;????&lt;/string&gt;<br/>  &lt;key&gt;CFBundleSupportedPlatforms&lt;/key&gt;<br/>  &lt;array&gt;<br/>    &lt;string&gt;iPhoneSimulator&lt;/string&gt;<br/>  &lt;/array&gt;<br/>--<span class="codeitalic">snip</span>--</pre>
<p class="indent"><a id="page_30"/>This is simply a dictionary containing hierarchical keys and values, which provides information about the app—the platforms it can run on, the code signature, and so forth (the signature is not present here because the app is deployed in the Simulator application).</p>
<p class="indent">But when examining files from the command line or working with plists programmatically, you’ll frequently encounter plists in binary format, which is not particularly human readable (or writable). You can convert these plists to XML using the <code>plutil(1)</code> command.</p>
<pre>$ plutil -convert xml1 Info.plist -o -<br/>$ plutil -convert xml1 Info.plist -o Info-xml.plist<br/>$ plutil -convert binary1 Info-xml.plist -o Info-bin.plist</pre>
<p class="indent">The first command converts a binary plist to XML and outputs it to stdout, where you can pipe it to <code>less(1)</code> or similar commands. You can also output directly to a file with <code>-o <em>filename</em></code>, as in the second command. In the third command, the <code>binary1</code> conversion type turns an XML-formatted plist to binary; but since the formats are interchangeable, you shouldn’t really need to do this.</p>
<p class="indent">To make reading and editing plists more seamless, you can also configure your text editor to automatically convert plist files so that if you need to read or write to one, you can do so smoothly from a familiar environment. For example, if you happen to use Vim, you might add a configuration like this to your <em>.vimrc</em> file:</p>
<pre>" Some quick bindings to edit binary plists<br/>command -bar PlistXML :set binary | :1,$!plutil -convert xml1 /dev/stdin -o -<br/>command -bar Plistbin :1,$!plutil -convert binary1 /dev/stdin -o -<br/><br/>fun ReadPlist()<br/>    if getline("'[") =~ "^bplist"<br/>        :PlistXML<br/>        set filetype=xml<br/>    endif<br/>endfunction<br/><br/>augroup misc<br/>    au BufWinEnter *.plist, call ReadPlist()<br/>augroup end</pre>
<p class="indent"><a id="page_31"/>This configuration will use the <code>:PlistXML</code> command to automatically convert any binary plist that you edit to XML format, allowing you to make changes in a human-readable format. Before actually writing those changes to the file, the configuration will convert the file to binary again using the <code>:Plistbin</code> command. Note that the file will still be successfully consumed by applications regardless of whether it is in binary or XML format.</p>
<p class="indent">You can view plists of either format within Xcode, as in <a href="ch03.html#ch3fig3">Figure 3-3</a>. The advantage of using Xcode is that you’ll have some additional help and dropdown menus that show you what potential values you might be able to use for the various keys. It’s good to know how to work with plists from the command line, though, because this lets you directly interact with them via SSH sessions to jailbroken devices.</p>
<div class="image"><img alt="image" src="graphics/f03-03.jpg"/></div>
<p class="figcap"><a id="ch3fig3"/><em>Figure 3-3: Viewing a plist within Xcode</em></p>
<p class="indent">See the man pages <code>plist(5)</code> and <code>plutil(1)</code> for more information about viewing and editing plists. If you’re working on a jailbroken device, you can use the <code>plutil</code> command included with Erica Sadun’s Erica Utilities<sup><a href="footnote.html#fn18" id="fn_18">2</a></sup> (available in Cydia) to work with plists locally.</p>
<h3 class="h3" id="ch03lev1sec02"><a id="page_32"/><strong>Device Directories</strong></h3>
<p class="noindent">Starting with iOS 8, Simulator platforms such as iPhone, iPad, and their variations are stored in directories named with unique identifiers. These identifiers correspond with the type of device you choose when launching the Simulator from Xcode, in combination with the requested OS version. Each of these directories has a plist file that describes the device. Here’s an example:</p>
<pre>&lt;?<span class="rose">xml version</span>=<span class="red">"1.0"</span> encoding=<span class="red">"UTF-8"</span>?&gt;<br/>&lt;!<span class="rose">DOCTYPE</span> plist <span class="rose">PUBLIC</span> <span class="red">"-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/</span><br/>    <span class="red">PropertyList-1.0.dtd"</span>&gt;<br/>&lt;plist <span class="rose">version</span>=<span class="red">"1.0"</span>&gt;<br/>&lt;dict&gt;<br/>        &lt;key&gt;UDID&lt;/key&gt;<br/>        &lt;string&gt;DF15DA82-1B06-422F-860D-84DCB6165D3C&lt;/string&gt;<br/>        &lt;key&gt;deviceType&lt;/key&gt;<br/>        &lt;string&gt;com.apple.CoreSimulator.SimDeviceType.iPad-2&lt;/string&gt;<br/>        &lt;key&gt;name&lt;/key&gt;<br/>        &lt;string&gt;iPad 2&lt;/string&gt;<br/>        &lt;key&gt;runtime&lt;/key&gt;<br/>        &lt;string&gt;com.apple.CoreSimulator.SimRuntime.iOS-8-0&lt;/string&gt;<br/>        &lt;key&gt;state&lt;/key&gt;<br/>        &lt;integer&gt;3&lt;/integer&gt;<br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</pre>
<p class="indent">In this plist file, it’s not immediately obvious which directory is for which device. To figure that out, either you can look at the <em>.default_created.plist</em> file in the <em>Devices</em> directory, or you can just grep all of the <em>device.plist</em> files, as shown in <a href="ch03.html#ch3ex1">Listing 3-1</a>.</p>
<pre>$ cd /Users/me/Library/Developer/CoreSimulator/Devices &amp;&amp; ls<br/>26E45178-F483-4CDD-A619-9C0780293DD4<br/>78CAAF2B-4C54-4519-A888-0DB84A883723<br/>A2CD467D-E110-4E38-A4D9-5C082618604A<br/>AD45A031-2412-4E83-9613-8944F8BFCE42<br/>676931A8-FDA5-4BDC-85CC-FB9E1B5368B6<br/>989328FA-57FA-430C-A71E-BE0ACF278786<br/>AA9B1492-ADFE-4375-98F1-7DB53FF1EC44<br/>DF15DA82-1B06-422F-860D-84DCB6165D3C<br/><br/>$ for dir in `ls|grep -v default`<br/>do<br/>echo $dir<br/>grep -C1 name $dir/device.plist |tail -1|sed -e 's/&lt;\/*string&gt;//g'<br/>done<br/>26E45178-F483-4CDD-A619-9C0780293DD4<br/>        iPhone 5s<br/>676931A8-FDA5-4BDC-85CC-FB9E1B5368B6<br/>        iPhone 5<br/>78CAAF2B-4C54-4519-A888-0DB84A883723<br/>        iPad Air<br/>989328FA-57FA-430C-A71E-BE0ACF278786<br/>        iPhone 4s<br/>A2CD467D-E110-4E38-A4D9-5C082618604A<br/>        iPad Retina<br/>AA9B1492-ADFE-4375-98F1-7DB53FF1EC44<br/>        Resizable iPad<br/>AD45A031-2412-4E83-9613-8944F8BFCE42<br/>        Resizable iPhone<br/>DF15DA82-1B06-422F-860D-84DCB6165D3C<br/>        iPad 2</pre>
<p class="listcap"><a id="ch3ex1"/><em>Listing 3-1: Grepping to determine which identifier maps to which model of iOS device</em></p>
<p class="indent"><a id="page_33"/>After entering the appropriate directory for the device you’ve been testing your application on, you’ll see a <em>data</em> directory that contains all of the Simulator files, including those specific to your application. Your application data is split into three main directories under <em>data/Containers</em>: <em>Bundle</em>, <em>Data</em>, and <em>Shared</em>.</p>
<h3 class="h3" id="ch03lev1sec03"><strong>The Bundle Directory</strong></h3>
<p class="noindent">The <em>Bundle</em> directory contains an <em>Applications</em> directory, which in turn contains a directory for each of the applications stored on the device, represented by that application’s bundle ID. In each application’s directory, the <em>.app</em> folder is where the application’s core binary is stored, along with image assets, localization information, and the <em>Info.plist</em> file that contains the core configuration information for your application. <em>Info.plist</em> includes the bundle identifier and main executable, along with information about your application’s UI and which device capabilities an application requires to be able to run.</p>
<p class="indent">On the filesystem, these plists are stored in either XML or binary format, with the latter being the default. You can retrieve the information in <em>Info.plist</em> programmatically by referencing dictionary attributes of <code>[NSBundle mainBundle]</code>;<sup><a href="footnote.html#fn19" id="fn_19">3</a></sup> this is commonly used for loading styling or localization information.</p>
<p class="indent"><a id="page_34"/>One thing that will potentially be of interest in the <em>Info.plist</em> file is the <code>UIRequiredDeviceCapabilities</code> entry, which looks something like this:</p>
<pre>&lt;key&gt;UIRequiredDeviceCapabilities&lt;/key&gt;<br/>&lt;dict&gt;<br/>        &lt;key&gt;armv7&lt;/key&gt;<br/>        &lt;true/&gt;<br/>        &lt;key&gt;location-services&lt;/key&gt;<br/>        &lt;true/&gt;<br/>        &lt;key&gt;sms&lt;/key&gt;<br/>        &lt;true/&gt;<br/>&lt;/dict&gt;</pre>
<p class="indent">The <code>UIRequiredDeviceCapabilities</code> entry describes which system resources an app requires. While not an enforcement mechanism, this can give you some clues as to what type of activities the application will engage in.</p>
<h3 class="h3" id="ch03lev1sec04"><strong>The Data Directory</strong></h3>
<p class="noindent">The primary area of interest in the <em>Data</em> directory is the <em>Applications</em> subdirectory. The <em>Data/Applications</em> directory contains the rest of the data an application uses to run: preferences, caches, cookies, and so on. This is also the primary location you’ll want to inspect for most types of data leakage. Now, let’s go over the various subdirectories and the types of data that they may end up holding.<sup><a href="footnote.html#fn20" id="fn_20">4</a></sup></p>
<h4 class="h4" id="ch03lev2sec01"><em><strong>The Documents and Inbox Directories</strong></em></h4>
<p class="noindent">The <em>Documents</em> directory is intended to store your nontransient application data, such as user-created content or local information allowing the app to run in offline mode. If <code>UIFileSharingEnabled</code> is set in your application’s <em>Info.plist</em> file, files here will be accessible via iTunes.</p>
<p class="indent">Data files that other applications ask your app to open are stored in your application’s <em>Documents/Inbox</em> directory. These will be invoked by the calling application using the <code>UIDocumentInteractionController</code> class.<sup><a href="footnote.html#fn21" id="fn_21">5</a></sup></p>
<p class="indent">You can only read or delete files stored in the <em>Inbox</em> directory. These files come from another application that can’t write to your app directory, so they’re put there by a higher-privileged system process. You may want to consider deleting these files periodically or giving the user the option to delete them because it will not be apparent to the user what documents are stored here and whether they contain sensitive information.</p>
<p class="indent"><a id="page_35"/>If you’re writing an application with the goal of ensuring sensitive information doesn’t remain on disk, copy documents out of the <em>Inbox</em> directory to a separate location where you can apply Data Protection and then remove those files from the <em>Inbox</em> directory.</p>
<p class="indent">It’s also worth remembering that under certain circumstances, any file your application asks to open may persist on the disk <em>forever</em>. If you attempt to open a file type that your program isn’t a handler for, then that file will be passed off to a third-party app, and who knows when the other app will delete it? It may get stored indefinitely. In other words, the cleanup of any file that you ask another app to open is beyond your control, even if you simply preview the contents using the Quick Look API. If having <em>Inbox</em> files kick around for a long time is problematic, consider giving your application the ability to view such data on its own (rather than relying on a helper) and then make sure to dispose of the files properly.</p>
<h4 class="h4" id="ch03lev2sec02"><em><strong>The Library Directory</strong></em></h4>
<p class="noindent">The <em>Library</em> directory contains the majority of your application’s files, including data cached by the application or by particular networking constructs. It will be backed up via iTunes and to iCloud, with the exception of the <em>Caches</em> directory.</p>
<h5 class="h5" id="ch03lev3sec01"><strong>The Application Support Directory</strong></h5>
<p class="noindent">The <em>Application Support</em> directory is not for storing files created or received by the user but rather for storing additional data files that will be used by your application. Examples would be additional purchased downloadable content, configuration files, high scores, and so on—as the name implies, things that support the running and operation of the application. Either these files can be deployed when the application is first installed or they can be downloaded or created by your application later.</p>
<p class="indent">By default, iTunes backs up the data in this directory to your computer and to iCloud. However, if you have privacy or security concerns about this data being stored in Apple’s cloud environment, you can explicitly disallow this by setting the <code>NSURLIsExcludedFromBackupKey</code> attribute on newly created files. I’ll discuss preventing data from syncing to iCloud further in <a href="ch10.html#ch10">Chapter 10</a>.</p>
<p class="indent">Note that Apple requires that applications back up only user data to iCloud (including documents they’ve created, configuration files, and so forth), never application data. Applications that allow application content, such as downloadable app content, to be backed up to iCloud can be rejected from the App Store.</p>
<h5 class="h5" id="ch03lev3sec02"><strong>The Caches and Snapshots Directories</strong></h5>
<p class="noindent">The <em>Caches</em> directory is similar in function to a web browser’s cache: it’s intended for data that your application will keep around for performance reasons but not for data that is crucial for the application to function. As such, this directory won’t be backed up by iTunes.</p>
<p class="indent"><a id="page_36"/>While Apple states that your application is responsible for managing the <em>Caches</em> directory, the OS does actually manipulate the directory’s contents and that of its subfolder, <em>Snapshots</em>. Always consider the contents of the <em>Caches</em> directory to be transient, and expect it to disappear between program launches. iOS will cull these cache directories automatically if the system starts running low on space, though it won’t do this while the application is running.</p>
<p class="indent">The <em>Caches</em> directory also sometimes stores web cache content in a subdirectory such as <em>Caches/com.mycompany.myapp</em>. This is one place where sensitive data can leak because iOS can cache information delivered over HTTPS for quite a long time. If the developer hasn’t made special effort to prevent data from being cached or to expire cached data quickly, you can often find some goodies in here.</p>
<p class="indent">Finally, when an application is put into the background, the OS also automatically stores screenshots of the application in the <em>Snapshots</em> subdirectory, potentially leaving sensitive information on local storage. This is done for one reason: so that the OS can use the current screen state to create the “whooshing” animation that happens when you bring an application to the foreground. Unfortunately, a side effect I frequently see in iOS applications is that the disk stores images of people’s Social Security numbers, user details, and so on. I’ll discuss mitigation strategies for this (and many other caching problems) in <a href="ch10.html#ch10">Chapter 10</a>.</p>
<h5 class="h5" id="ch03lev3sec03"><strong>The Cookies Directory</strong></h5>
<p class="noindent">The <em>Cookies</em> directory stores cookies set by the URL loading system. When you make an <code>NSURLRequest</code>, any cookies will be set according to either the default system cookie policy or one that you’ve specified. Unlike on OS X, cookies on iOS are not shared between applications; each application will have its own cookie store in this directory.</p>
<h5 class="h5" id="ch03lev3sec04"><strong>The Preferences Directory</strong></h5>
<p class="noindent">iOS stores application preferences in the <em>Preferences</em> directory, but it doesn’t allow applications to write directly to the files there. Instead, files in this directory are created, read, and manipulated by either the <code>NSUserDefaults</code> or <code>CFPreferences</code> API.</p>
<p class="indent">These APIs store application preference files in plaintext; therefore, you most definitely should <em>not</em> use them to store sensitive user information or credentials. When examining an application to see what information it’s storing locally, be sure to examine the plist files in the <em>Preferences</em> directory. You’ll sometimes find usernames and passwords, API access keys, or security controls that are not meant to be changed by users.</p>
<h5 class="h5" id="ch03lev3sec05"><a id="page_37"/><strong>The Saved Application State Directory</strong></h5>
<p class="noindent">Users expect apps to remember what they enter into text fields, which settings they’ve enabled, and so on. If a user switches to another application and then restores the original application at a later time, the application may have actually been killed by the operating system during the interval. To make it so that the UI remains consistent between program launches, recent versions of iOS store object state information in the <em>Saved Application State</em> directory by the State Preservation API.<sup><a href="footnote.html#fn22" id="fn_22">6</a></sup> Developers can tag specific parts of their UI to be included in State Preservation.</p>
<p class="indent">If you’re not careful about what you store as part of the application state, this is one place you can wind up with data leaks. I’ll discuss how to avoid those in depth in <a href="ch10.html#ch10">Chapter 10</a>.</p>
<h4 class="h4" id="ch03lev2sec03"><em><strong>The tmp Directory</strong></em></h4>
<p class="noindent">As you might surmise, <em>tmp</em> is where you store transient files. Like the <em>Caches</em> directory, the files contained in this directory may be automatically removed by the OS while your application isn’t running. The usage of this directory is fairly similar to that of the <em>Caches</em> directory; the difference is that <em>Caches</em> is meant to be used for files that might need to be retrieved again or recreated. For example, if you download certain application data from a remote server and want to keep it around for performance reasons, you’d store that in <em>Caches</em> and redownload it if it disappears. On the other hand, <em>tmp</em> is for strictly temporary files generated by the application—in other words, files that you won’t miss if they’re deleted before you can revisit them. Also, like the <em>Caches</em> directory, <em>tmp</em> is not backed up to iTunes or iCloud.</p>
<h3 class="h3" id="ch03lev1sec05"><strong>The Shared Directory</strong></h3>
<p class="noindent">The <em>Shared</em> directory is a bit of a special case. It’s for applications that share a particular app group (introduced in iOS 8 to support extensions), such as those that modify the behavior of the Today screen or keyboard. Apple requires all extensions to have a container application, which receives its own app ID. The <em>Shared</em> directory is the way that the extension and its containing app share data. For example, apps can access databases of shared user defaults by specifying a suite name during initialization of <code>NSUserDefaults</code>, like this:</p>
<pre>[[<span class="violet1">NSUserDefaults</span> <span class="violet">alloc</span>] initWithSuiteName:<span class="red">@"com.myorg.mysharedstuff"</span>];</pre>
<p class="indent">While the <em>Shared</em> directory isn’t commonly used at the time of writing, it’s prudent to check this directory when looking for any sensitive information potentially stored in preferences or other private data.</p>
<h3 class="h3" id="ch03lev1sec06"><a id="page_38"/><strong>Closing Thoughts</strong></h3>
<p class="noindent">With a basic understanding of the iOS security model, the Cocoa API, and how iOS applications are laid out, you’re now ready to move on to the fun stuff: tearing apart applications and finding their flaws. In <a href="part02.html#part02">Part II</a>, I’ll show you how to build your testing platform, debug and profile applications, and deal with testing third-party apps for which source code is available.</p>
</body></html>