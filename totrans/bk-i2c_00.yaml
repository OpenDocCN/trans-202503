- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Welcome to *The Book of I*^(*2*)*C*. This book provides the resources you need
    to design and program systems using the Inter-Integrated Circuit Bus (IIC, I2C,
    or I²C), a serial protocol for connecting various integrated circuits (ICs) together
    in computer systems. This book will teach you how to expand your embedded system
    design by adding I²C peripherals with minimal wiring and software.
  prefs: []
  type: TYPE_NORMAL
- en: To paraphrase from [https://i2c.info](https://i2c.info), I²C uses only two wires
    to easily connect devices such as microcontrollers, A/D and D/A converters, digital
    I/O, memory, and many others, together in an embedded system. Although it was
    originally developed by Philips (now NXP Semiconductors), most major IC manufacturers
    now support I²C. I²C is popular because it is ubiquitous—most CPUs destined for
    embedded systems include support for I²C—and its peripheral ICs are inexpensive.
    It is present in hobbyist systems like Arduino and Raspberry Pi, as well as in
    most professional single-board computers (SBCs) intended for use in embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: The I²C bus is especially important on hobbyist-level embedded systems employed
    by “makers” working on personal projects, which typically use a commercially available
    off-the-shelf (COTS) SBC like an Arduino Uno, Teensy 4.*x*, or Raspberry Pi as
    the brains for the system. Such SBCs generally have limited I/O capability or
    other limitations, so the addition of peripheral ICs may be necessary to realize
    a given design. The I²C bus is one of the most popular and common ways to expand
    such systems, since it’s easy, convenient, and inexpensive to use. Furthermore,
    there are hundreds of different devices available as individual ICs with a wide
    range of capabilities that connect directly to the I²C bus. Combined with a huge
    library of open source code to control these devices (especially for Arduino devices),
    it’s almost trivial to expand small systems using the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: Although higher-end custom SBCs intended for professional embedded systems often
    include many of the peripherals missing in hobbyist-grade SBCs, the I²C bus is
    still a cost-effective way to design such systems. Often, peripherals that don’t
    have high-performance requirements connect to the CPU on the SBC using the I²C
    bus.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the ubiquity of the I²C, it is difficult to work on embedded systems
    these days without at least a passing familiarity with the I²C bus. Sadly, most
    programmers are expected to figure out how to use the I²C bus on their own by
    searching the internet and piecing together design and programming information.
    This book rectifies that situation, collecting into one comprehensive book the
    resources needed to fully understand how to design and program systems using the
    I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: Expectations and Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with I²C peripherals requires some hardware and software expertise.
    In theory, an electrical engineer with no software experience could design some
    hardware and hand it off to a software engineer with no hardware experience, and
    the two of them could get something working. However, this book is not intended
    to be read by such teams. Rather, it’s meant for software engineers who aren’t
    afraid to get their hands dirty by working directly with the hardware, or for
    hardware engineers who aren’t afraid to sit down with a text editor and write
    software.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Book of I*^(*2*)*C* assumes you are capable of reading schematics and
    wiring a COTS SBC (such as an Arduino, Pi, or other commercially available SBC)
    to various peripheral devices using breadboarding or point-to-point wiring on
    prototyping boards. You should be comfortable using tools such as DVMs, oscilloscopes,
    logic analyzers, and more to examine and debug such circuits.'
  prefs: []
  type: TYPE_NORMAL
- en: This book also assumes you are familiar with the C/C++ programming language
    and are capable of creating, testing, and debugging decent-sized programs on the
    aforementioned SBCs. Although I²C code can be written in many different languages
    (including assembly language, Java, and Python), C/C++ is the universal language
    for embedded systems. Almost every COTS SBC’s development software supports using
    C/C++, so the book assumes prior knowledge of this language.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the examples in this book use the Arduino library due to its widespread
    use and simplicity. Therefore, it assumes at least a passing familiarity with
    the Arduino system. The Raspberry Pi examples obviously use the Raspberry Pi OS
    (Linux) and the Pi OS I²C library code; the book provides links to the documentation
    for those libraries as appropriate. For other systems (for example, µC/OS running
    on a NetBurner module or MBED running on an STM32 module), this book assumes no
    prior knowledge and provides either the necessary information or links to the
    associated documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The software tools for embedded system programming generally run on Windows,
    macOS, or Linux. You should be familiar with the particular system running these
    tools (for example, the C/C++ compilers) and capable of running those tools on
    your own system, including learning how to use, install, and configure those tools
    with their accompanying documentation. As necessary, this book will describe how
    to find those tools and their documentation; however, its focus is the I²C bus,
    not running C/C++ compilers and integrated development environments (IDEs), so
    it leaves you to learn more about tools on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Source Code in This Book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book contains considerable C/C++ source code that comes in one of three
    forms: code snippets, modules, and full-blown programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code snippets* are fragments of a program, provided to make a point or provide
    an example of some programming technique. They are not stand-alone, and you cannot
    compile them using a C/C++ compiler. Here is a typical example of a snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The vertical ellipses in this example denote some arbitrary code that could
    appear in their place.
  prefs: []
  type: TYPE_NORMAL
- en: '*Modules* are small C/C++ code sections that are compilable but won’t run on
    their own. Modules typically contain a function that some other program will call.
    Here is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Full-blown programs are called *listings* in this book, and I refer to them
    by listing number or filename. For example, the following example listing for
    an Arduino “blink” program is taken from the file *Listing1-1.ino*. The name indicates
    that it is the first listing in Chapter 1, and I refer to it as [Listing 1-1](#listing1-1)
    in the surrounding text, labeling the code itself with the filename in the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the *Listing1-1.ino* filename format applies only to code of my own
    making. Any other source code retains its original filename. For example, I refer
    to Chapter 16’s code from the TinyWire library as *attiny84_Periph.ino*. Certain
    non-Arduino systems (Pi OS and MBED, for example) use a standard *main.cpp* filename
    for their main programs; this book will generally place such programs in a subdirectory
    with a name such as *Listingx-x* and refer to that whole directory as the “listing.”
    Many listings in this book are sufficiently long that I’ve broken them up into
    sections with text annotation between the sections. In such instances, I will
    place a comment such as `// Listing10-1.ino (cont.)` at the beginning of each
    section to provide continuity.
  prefs: []
  type: TYPE_NORMAL
- en: All listings and modules are available in electronic form at my website [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com),
    either individually or as a ZIP file containing all the listings and other support
    information for this book, including errata, electronic chapters, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise noted, all source code appearing in this book is covered under
    the Creative Commons 4.0 license. You may freely use that code in your own projects
    as per the Creative Commons license. See [https://creativecommons.org/licenses/by/4.0](https://creativecommons.org/licenses/by/4.0)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Typography and Pedantry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computer books have a habit of abusing the English language, and this book is
    no exception. Whenever source code snippets appear in the middle of an English
    sentence, there is often a conflict between the grammar rules of the programming
    language and English. In this section, I describe my choices for differentiating
    syntactical rules in English versus programming languages, in addition to a few
    other conventions.
  prefs: []
  type: TYPE_NORMAL
- en: First, this book uses a monospace font to denote any text that appears as part
    of a program source file. This includes variable and procedure function names,
    program output, and user input to a program. Therefore, when you see something
    like `get`, you know that the book is describing an identifier in a program, not
    commanding you to get something.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few logic operations whose names also have common English meanings.
    These logic operations are AND, OR, and NOT. When using these terms as logic functions,
    this book uses all caps to help differentiate otherwise confusing English statements.
    When using these terms as English, this book uses the standard typeset font. The
    fourth logic operator, exclusive-OR (XOR), doesn’t normally appear in English
    statements, but this book still capitalizes it.
  prefs: []
  type: TYPE_NORMAL
- en: In general, I always try to define any acronym or abbreviation the first time
    I use it. If I haven’t used the term in a while, I often redefine it when I use
    it next. I’ve added a glossary where I define most of the acronyms (and other
    technical terms) appearing in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, hardcore electrical engineers will often use the term *buss* when describing
    a collection of electronic signals, especially when describing buss bars. However,
    I use the spellings *bus* and *buses* simply because they are more prevalent in
    literature discussing the I²C bus.
  prefs: []
  type: TYPE_NORMAL
- en: A Note About Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2020, several major electronics firms and other members of the Open Source
    Hardware Association (OSHWA) proposed changing the names of various SPI bus terms
    to eliminate terms that some find morally questionable. The electronics industry
    has long used the terms *master* and *slave* to describe the operating hierarchy
    of various devices in the system. There is no technical justification for these
    names; they don’t even precisely describe the relationship between devices, so
    better terms would be desirable even if other issues weren’t a factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is a book about the I²C bus, not the SPI bus, I²C is probably
    next on the list (as SparkFun notes at [https://www.sparkfun.com/spi_signal_names](https://www.sparkfun.com/spi_signal_names)).
    Though the I²C bus does not have pins using the names master or slave, the terms
    *master*, *slave*, *multimaster*, and *multislave* are common in I²C literature.
    This book substitutes the following more descriptive and less offensive terms,
    as per the OSHWA guidelines for the SPI bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Master becomes *controller**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   *Multimaster becomes *multicontroller****   *Slave becomes *peripheral****   *Multislave
    becomes *multiperipheral*****'
  prefs: []
  type: TYPE_NORMAL
- en: '**Of course, *controller* and *peripheral* have their own meanings and may
    not always correspond to an I²C bus controller or peripheral device. However,
    context within this book will make it clear which meaning I intend. Considerable
    historical documentation continues to use the terms *master* and *slave*, but
    you can simply mentally convert between *master*/*controller* and *slave*/*peripheral*.
    To avoid confusion with such historical documentation, this book uses *master*
    and *slave* only when referring to external documentation that uses those terms.'
  prefs: []
  type: TYPE_NORMAL
- en: Organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book is organized into four parts as follows, in addition to appendixes
    and online chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part I: Low-Level Protocols and Hardware**'
  prefs: []
  type: TYPE_NORMAL
- en: This part describes the signals and hardware for the I²C. Though you don’t necessarily
    need to know this information in order to design systems using the I²C bus or
    to write code to program peripherals, this knowledge is handy when debugging hardware
    and software that use the I²C bus. Part I also includes a software implementation
    of the I²C bus for those software engineers who relate more to code than electrical
    specifications, as well as a section on analyzing and debugging I²C bus transactions.
    Finally, the section concludes by discussing various real-world extensions to
    the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Part II: Hardware Implementations**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part describes several real-world implementations of the I²C bus. In particular,
    it reviews the I²C implementation of the following pieces of hardware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arduino systems (and compatibles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Teensy 3.*x* and 4.*x* SBC I²C implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Raspberry Pi, BeagleBone Black, PINE64 and ROCKPro64, Onion, and other Linux
    systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32/Nucleo-144/Nucleo-64 I²C implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NetBurner MOD54415 I²C implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part II also describes the following I²C bus implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Adafruit Feather bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SparkFun Qwiic bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Seeed Studio Grove bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part III: Programming the I²C Bus**'
  prefs: []
  type: TYPE_NORMAL
- en: This part discusses programming devices on the I²C bus. It covers various generic
    programming techniques, such as real-time OS I²C programming, as well as providing
    specific real-world programming examples for Arduino, Raspberry Pi, Teensy, MBED,
    and NetBurner. Part III also describes how to implement an I²C using bare-metal
    programming techniques—those that work at the hardware level rather than calling
    library code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Part IV: I²C Peripheral Programming Examples**'
  prefs: []
  type: TYPE_NORMAL
- en: This part provides programming examples for some common real-world I²C peripheral
    ICs, including the MCP23017 GPIO expander, ADS1115 16-bit A/D converter, MCP4725
    D/A converter, and TCA9548A I²C multiplexer. Part IV also describes how to use
    a SparkFun Atto84 module as a custom I²C peripheral.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Appendixes**'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A is a snapshot of the Adafruit I²C Address Compilation, which lists
    the addresses of hundreds of commerically available I²C peripheral ICs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Appendix B contains an overview of the online content. No matter how many pages
    I add to this book, it will be woefully incomplete. There are just too many I²C
    controllers and peripherals available. Furthermore, new peripherals will certainly
    appear after this book is published. To resolve this conundrum (and reduce the
    price you have to pay for this book), additional chapters are available online
    at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The online content will cover (among other things) the following topics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MCP4728 quad DAC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Maxim DS3502 digital potentiometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DS3231 precision real-time clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MCP9600 thermocouple amplifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I²C displays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SX1509 GPIO interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PCA9685 PCM/servo interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The INA169 and INA218 current sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MPR121 capacitive touch interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Raspberry Pi Pico SBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Espressif ESP32 (and ESP8266) SBCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glossary**'
  prefs: []
  type: TYPE_NORMAL
- en: A list of the terms and acronyms appearing in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to the online chapters, the website will contain help on constructing
    the circuitry appearing in this book and other information of interest to someone
    programming I²C peripherals. It will also contain a parts list for all the electronic
    projects appearing within this book. My goal is to continuously update this information
    as new (important) peripherals and controllers appear that utilize the I²C bus.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
