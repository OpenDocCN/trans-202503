- en: 'Chapter 29. Threads: Introduction'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第29章。线程：介绍
- en: In this and the next few chapters, we describe POSIX threads, often known as
    *Pthreads*. We won’t attempt to cover the entire Pthreads API, since it is rather
    large. Various sources of further information about threads are listed at the
    end of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及接下来的几章中，我们将介绍 POSIX 线程，通常称为*Pthreads*。我们不会尝试覆盖整个 Pthreads API，因为它相当庞大。关于线程的进一步信息来源将在本章末尾列出。
- en: These chapters mainly describe the standard behavior specified for the Pthreads
    API. In [Linux Implementations of POSIX Threads](ch33.html#linux_implementations_of_posix_threads
    "Linux Implementations of POSIX Threads"), we discuss those points where the two
    main Linux threading implementations—LinuxThreads and Native POSIX Threads Library
    (NPTL)—deviate from the standard.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节主要描述了为 Pthreads API 所规定的标准行为。在[Linux 中的 POSIX 线程实现](ch33.html#linux_implementations_of_posix_threads
    "Linux 中的 POSIX 线程实现")中，我们将讨论两个主要的 Linux 线程实现——LinuxThreads 和本地 POSIX 线程库（NPTL）——在某些方面如何偏离标准。
- en: In this chapter, we provide an overview of the operation of threads, and then
    look at how threads are created and how they terminate. We conclude with a discussion
    of some factors that may influence the choice of a multithreaded approach versus
    a multiprocess approach when designing an application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述线程的操作，然后介绍线程是如何创建的以及如何终止的。最后，我们将讨论在设计应用程序时，选择多线程方法与多进程方法的一些影响因素。
- en: Overview
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Like processes, threads are a mechanism that permits an application to perform
    multiple tasks concurrently. A single process can contain multiple threads, as
    illustrated in [Figure 29-1](ch29.html#four_threads_executing_in_a_process_open
    "Figure 29-1. Four threads executing in a process (Linux/x86-32)"). All of these
    threads are independently executing the same program, and they all share the same
    global memory, including the initialized data, uninitialized data, and heap segments.
    (A traditional UNIX process is simply a special case of a multithreaded processes;
    it is a process that contains just one thread.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程一样，线程是一种机制，允许应用程序同时执行多个任务。一个进程可以包含多个线程，如[图29-1](ch29.html#four_threads_executing_in_a_process_open
    "图29-1. 四个线程在进程中执行（Linux/x86-32）")所示。所有这些线程独立地执行相同的程序，并且它们共享相同的全局内存，包括已初始化的数据、未初始化的数据和堆区。（传统的
    UNIX 进程仅仅是多线程进程的一种特殊情况；它是一个仅包含一个线程的进程。）
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have simplified things somewhat in [Figure 29-1](ch29.html#four_threads_executing_in_a_process_open
    "Figure 29-1. Four threads executing in a process (Linux/x86-32)"). In particular,
    the location of the per-thread stacks may be intermingled with shared libraries
    and shared memory regions, depending on the order in which threads are created,
    shared libraries loaded, and shared memory regions attached. Furthermore, the
    location of the per-thread stacks can vary depending on the Linux distribution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[图29-1](ch29.html#four_threads_executing_in_a_process_open "图29-1. 四个线程在进程中执行（Linux/x86-32）")中对情况做了一定的简化。特别是，线程的每个堆栈的位置可能与共享库和共享内存区域交织在一起，具体取决于线程创建的顺序、共享库的加载顺序以及共享内存区域的附加顺序。此外，线程堆栈的位置还可能会根据
    Linux 发行版的不同而有所变化。
- en: The threads in a process can execute concurrently. On a multiprocessor system,
    multiple threads can execute in parallel. If one thread is blocked on I/O, other
    threads are still eligible to execute. (Although it sometimes useful to create
    a separate thread purely for the purpose of performing I/O, it is often preferable
    to employ one of the alternative I/O models that we describe in [Chapter 63](ch63.html
    "Chapter 63. Alternative I/O Models").)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程中的线程可以并发执行。在多处理器系统上，多个线程可以并行执行。如果一个线程在 I/O 操作上被阻塞，其他线程仍然可以执行。（虽然有时创建一个独立的线程专门执行
    I/O 操作是有用的，但通常更倾向于使用我们在[第63章](ch63.html "第63章。替代 I/O 模型")中描述的替代 I/O 模型。）
- en: '![Four threads executing in a process (Linux/x86-32)](figs/web/29-1_THREADS-A1-memory-layout.png.jpg)Figure 29-1. Four
    threads executing in a process (Linux/x86-32)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![四个线程在进程中执行（Linux/x86-32）](figs/web/29-1_THREADS-A1-memory-layout.png.jpg)图29-1.
    四个线程在进程中执行（Linux/x86-32）'
- en: 'Threads offer advantages over processes in certain applications. Consider the
    traditional UNIX approach to achieving concurrency by creating multiple processes.
    An example of this is a network server design in which a parent process accepts
    incoming connections from clients, and then uses *fork()* to create a separate
    child process to handle communication with each client (refer to [A Concurrent
    TCP *echo* Server](ch60.html#a_concurrent_tcp_echo_server "A Concurrent TCP echo
    Server")). Such a design makes it possible to serve multiple clients simultaneously.
    While this approach works well for many scenarios, it does have the following
    limitations in some applications:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，线程相较于进程提供了优势。考虑传统UNIX方法通过创建多个进程来实现并发的方式。一个例子是网络服务器设计，其中父进程接受来自客户端的连接，然后使用*fork()*创建一个单独的子进程来处理与每个客户端的通信（参考[并发TCP
    *回显*服务器](ch60.html#a_concurrent_tcp_echo_server "并发TCP回显服务器")）。这样的设计使得能够同时为多个客户端提供服务。虽然这种方法在许多场景中表现良好，但在某些应用中，它也存在以下局限：
- en: It is difficult to share information between processes. Since the parent and
    child don’t share memory (other than the read-only text segment), we must use
    some form of interprocess communication in order to exchange information between
    processes.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程之间共享信息是困难的。由于父进程和子进程不共享内存（只共享只读文本段），我们必须使用某种形式的进程间通信来交换进程间的信息。
- en: Process creation with *fork()* is relatively expensive. Even with the copy-on-write
    technique described in [Memory Semantics of *fork()*](ch24.html#memory_semantics_of_fork_open_parenthesi
    "Memory Semantics of fork()"), the need to duplicate various process attributes
    such as page tables and file descriptor tables means that a *fork()* call is still
    time-consuming.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*fork()*创建进程的开销相对较大。即使采用了[*fork()*的内存语义](ch24.html#memory_semantics_of_fork_open_parenthesi
    "fork()的内存语义")中描述的写时复制技术，仍然需要复制进程的各种属性，如页表和文件描述符表，因此*fork()*调用仍然是耗时的。
- en: 'Threads address both of these problems:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 线程解决了这两个问题：
- en: 'Sharing information between threads is easy and fast. It is just a matter of
    copying data into shared (global or heap) variables. However, in order to avoid
    the problems that can occur when multiple threads try to update the same information,
    we must employ the synchronization techniques described in [Chapter 30](ch30.html
    "Chapter 30. Threads: Thread Synchronization").'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程之间的信息共享既简单又快速。只需将数据复制到共享的（全局或堆）变量中即可。然而，为了避免多个线程试图更新相同信息时出现的问题，我们必须使用[第30章](ch30.html
    "第30章. 线程：线程同步")中描述的同步技术。
- en: Thread creation is faster than process creation—typically, ten times faster
    or better. (On Linux, threads are implemented using the *clone()* system call,
    and [Table 28-3](ch28.html#time_required_to_create_100_comma_000_pr "Table 28-3. Time
    required to create 100,000 processes using fork(), vfork(), and clone()"), in
    [Speed of Process Creation](ch28.html#speed_of_process_creation "Speed of Process
    Creation"), shows the differences in speed between *fork()* and *clone()*.) Thread
    creation is faster because many of the attributes that must be duplicated in a
    child created by *fork()* are instead shared between threads. In particular, copy-on-write
    duplication of pages of memory is not required, nor is duplication of page tables.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程创建比进程创建要快——通常快十倍或更快。（在Linux上，线程是通过*clone()*系统调用实现的，且[表28-3](ch28.html#time_required_to_create_100_comma_000_pr
    "表28-3. 使用fork()、vfork()和clone()创建100,000个进程所需的时间")，在[进程创建速度](ch28.html#speed_of_process_creation
    "进程创建速度")一节中，展示了*fork()*和*clone()*之间的速度差异。）线程创建更快，因为许多必须在通过*fork()*创建的子进程中复制的属性，在线程之间是共享的。特别是，内存页的写时复制（copy-on-write）不再需要，也不需要复制页表。
- en: 'Besides global memory, threads also share a number of other attributes (i.e.,
    these attributes are global to a process, rather than specific to a thread). These
    attributes include the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了全局内存外，线程还共享其他一些属性（即这些属性是进程级别的，而不是线程特定的）。这些属性包括：
- en: process ID and parent process ID;
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程ID和父进程ID；
- en: process group ID and session ID;
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程组ID和会话ID；
- en: controlling terminal;
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制终端；
- en: process credentials (user and group IDs);
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程凭证（用户和组ID）；
- en: open file descriptors;
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的文件描述符；
- en: record locks created using *fcntl()*;
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*fcntl()*创建的记录锁；
- en: signal dispositions;
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理方式；
- en: 'file system-related information: umask, current working directory, and root
    directory;'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件系统相关的信息：umask，当前工作目录和根目录；
- en: interval timers (*setitimer()*) and POSIX timers (*timer_create()*);
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间隔定时器 (*setitimer()*) 和 POSIX 定时器 (*timer_create()*)；
- en: System V semaphore undo (*semadj*) values ([Semaphore Undo Values](ch47.html#semaphore_undo_values
    "Semaphore Undo Values"));
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System V 信号量撤销 (*semadj*) 值 ([信号量撤销值](ch47.html#semaphore_undo_values "信号量撤销值"));
- en: resource limits;
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源限制；
- en: CPU time consumed (as returned by *times()*);
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 时间消耗（由 *times()* 返回）；
- en: resources consumed (as returned by *getrusage()*); and
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源消耗（由 *getrusage()* 返回）；以及
- en: nice value (set by *setpriority()* and *nice()*).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nice 值（由 *setpriority()* 和 *nice()* 设置）。
- en: 'Among the attributes that are distinct for each thread are the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程特有的属性包括以下内容：
- en: thread ID ([Thread IDs](ch29.html#thread_ids "Thread IDs"));
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程 ID ([线程 ID](ch29.html#thread_ids "线程 ID"));
- en: signal mask;
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号屏蔽；
- en: thread-specific data ([Thread-Specific Data](ch31.html#thread-specific_data
    "Thread-Specific Data"));
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程特定数据 ([线程特定数据](ch31.html#thread-specific_data "线程特定数据"));
- en: alternate signal stack (*sigaltstack()*);
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代信号栈 (*sigaltstack()*);
- en: the *errno* variable;
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*errno* 变量；'
- en: floating-point environment (see *fenv(3)*);
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动点环境（参见 *fenv(3)*）；
- en: realtime scheduling policy and priority ([Overview of Realtime Process Scheduling](ch35.html#overview_of_realtime_process_scheduling
    "Overview of Realtime Process Scheduling") and [Realtime Process Scheduling API](ch35.html#realtime_process_scheduling_api
    "Realtime Process Scheduling API"));
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时调度策略和优先级 ([实时进程调度概述](ch35.html#overview_of_realtime_process_scheduling "实时进程调度概述")
    和 [实时进程调度 API](ch35.html#realtime_process_scheduling_api "实时进程调度 API")）；
- en: CPU affinity (Linux-specific, described in [CPU Affinity](ch35.html#cpu_affinity
    "CPU Affinity"));
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 亲和性（Linux 特有，详见 [CPU 亲和性](ch35.html#cpu_affinity "CPU 亲和性")）；
- en: capabilities (Linux-specific, described in [Chapter 39](ch39.html "Chapter 39. Capabilities"));
    and
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能力（Linux 特有，详见 [第 39 章](ch39.html "第 39 章. 能力")）；
- en: stack (local variables and function call linkage information).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈（局部变量和函数调用链接信息）。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As can be seen from [Figure 29-1](ch29.html#four_threads_executing_in_a_process_open
    "Figure 29-1. Four threads executing in a process (Linux/x86-32)"), all of the
    per-thread stacks reside within the same virtual address space. This means that,
    given a suitable pointer, it is possible for threads to share data on each other’s
    stacks. This is occasionally useful, but it requires careful programming to handle
    the dependency that results from the fact that a local variable remains valid
    only for the lifetime of the stack frame in which it resides. (If a function returns,
    the memory region used by its stack frame may be reused by a later function call.
    If the thread terminates, a new thread may reuse the memory region used for the
    terminated thread’s stack.) Failing to correctly handle this dependency can create
    bugs that are hard to track down.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图 29-1](ch29.html#four_threads_executing_in_a_process_open "图 29-1. 在一个进程中执行的四个线程
    (Linux/x86-32)")中可以看出，所有每个线程的栈都位于相同的虚拟地址空间中。这意味着，给定合适的指针，线程可以在彼此的栈上共享数据。这在某些情况下很有用，但需要小心编程来处理由于局部变量仅在其所在的栈帧生命周期内有效所带来的依赖关系。（如果一个函数返回，则其栈帧使用的内存区域可能会被后续的函数调用重用。如果线程终止，则新线程可能会重用已终止线程的栈使用的内存区域。）未能正确处理此依赖关系可能会导致难以追踪的错误。
- en: Background Details of the Pthreads API
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pthreads API 背景详细信息
- en: In the late 1980s and early 1990s, several different threading APIs existed.
    In 1995, POSIX.1c standardized the POSIX threads API, and this standard was later
    incorporated into SUSv3.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代末和1990年代初，存在多种不同的线程 API。1995年，POSIX.1c 标准化了 POSIX 线程 API，该标准后来被纳入了 SUSv3。
- en: Several concepts apply to the Pthreads API as a whole, and we briefly introduce
    these before looking in detail at the API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个概念适用于 Pthreads API，我们在详细查看 API 之前简要介绍这些概念。
- en: Pthreads data types
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pthreads 数据类型
- en: The Pthreads API defines a number of data types, some of which are listed in
    [Table 29-1](ch29.html#pthreads_data_types-id2 "Table 29-1. Pthreads data types").
    We describe most of these data types in the following pages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Pthreads API 定义了多种数据类型，其中一些在[表 29-1](ch29.html#pthreads_data_types-id2 "表 29-1.
    Pthreads 数据类型")中列出。我们将在接下来的页面中描述这些数据类型中的大多数。
- en: Table 29-1. Pthreads data types
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表 29-1. Pthreads 数据类型
- en: '| Data type | Description |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *pthread_t* | Thread identifier |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_t* | 线程标识符 |'
- en: '| *pthread_mutex_t* | Mutex |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_mutex_t* | 互斥量 |'
- en: '| *pthread_mutexattr_t* | Mutex attributes object |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_mutexattr_t* | 互斥量属性对象 |'
- en: '| *pthread_cond_t* | Condition variable |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_cond_t* | 条件变量 |'
- en: '| *pthread_condattr_t* | Condition variable attributes object |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_condattr_t* | 条件变量属性对象 |'
- en: '| *pthread_key_t* | Key for thread-specific data |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_key_t* | 线程特定数据的键 |'
- en: '| *pthread_once_t* | One-time initialization control context |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_once_t* | 一次性初始化控制上下文 |'
- en: '| *pthread_attr_t* | Thread attributes object |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| *pthread_attr_t* | 线程属性对象 |'
- en: SUSv3 doesn’t specify how these data types should be represented, and portable
    programs should treat them as opaque data. By this, we mean that a program should
    avoid any reliance on knowledge of the structure or contents of a variable of
    one of these types. In particular, we can’t compare variables of these types using
    the C *==* operator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3没有指定这些数据类型应该如何表示，便携式程序应将其视为不透明数据。我们所说的意思是，程序应避免依赖于这些类型变量的结构或内容的知识。特别地，我们不能使用C语言的
    *==* 操作符来比较这些类型的变量。
- en: Threads and *errno*
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程和 *errno*
- en: 'In the traditional UNIX API, *errno* is a global integer variable. However,
    this doesn’t suffice for threaded programs. If a thread made a function call that
    returned an error in a global *errno* variable, then this would confuse other
    threads that might also be making function calls and checking *errno*. In other
    words, race conditions would result. Therefore, in threaded programs, each thread
    has its own *errno* value. On Linux, a thread-specific *errno* is achieved in
    a similar manner to most other UNIX implementations: *errno* is defined as a macro
    that expands into a function call returning a modifiable lvalue that is distinct
    for each thread. (Since the lvalue is modifiable, it is still possible to write
    assignment statements of the form *errno = value* in threaded programs.)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的UNIX API中，*errno* 是一个全局整型变量。然而，这对于多线程程序来说是不够的。如果一个线程调用了返回错误的函数并将错误值存储在全局
    *errno* 变量中，那么其他线程在调用函数并检查 *errno* 时会产生混淆。换句话说，竞态条件会发生。因此，在多线程程序中，每个线程都有自己的 *errno*
    值。在Linux上，线程特定的 *errno* 通过类似于大多数其他UNIX实现的方式实现：*errno* 被定义为一个宏，展开成一个函数调用，返回一个可修改的左值，这个左值对于每个线程都是不同的。（由于左值是可修改的，因此在多线程程序中，仍然可以写出像
    *errno = value* 这样的赋值语句。）
- en: To summarize, the *errno* mechanism has been adapted for threads in a manner
    that leaves error reporting unchanged from the traditional UNIX API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，*errno* 机制已经被适配到线程中，且错误报告方式与传统的UNIX API没有变化。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original POSIX.1 standard followed K&R C usage in allowing a program to
    declare *errno* as *extern int errno*. SUSv3 doesn’t permit this usage (the change
    actually occurred in 1995 in POSIX.1c). Nowadays, a program is required to declare
    *errno* by including `<errno.h>`, which enables the implementation of a per-thread
    *errno*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的POSIX.1标准沿用了K&R C的用法，允许程序声明 *errno* 为 *extern int errno*。SUSv3不允许这种用法（这一变化实际上发生在1995年，出现在POSIX.1c中）。如今，程序必须通过包含
    `<errno.h>` 来声明 *errno*，这使得每个线程拥有自己的 *errno*。
- en: Return value from Pthreads functions
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自Pthreads函数的返回值
- en: The traditional method of returning status from system calls and some library
    functions is to return 0 on success and -1 on error, with *errno* being set to
    indicate the error. The functions in the Pthreads API do things differently. All
    Pthreads functions return 0 on success or a positive value on failure. The failure
    value is one of the same values that can be placed in *errno* by traditional UNIX
    system calls.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的系统调用和一些库函数返回状态的方法是：成功时返回0，错误时返回-1，并将 *errno* 设置为指示错误的值。而Pthreads API中的函数则有所不同。所有Pthreads函数成功时返回0，失败时返回一个正值。这个失败值是传统UNIX系统调用可以将其放入
    *errno* 中的相同值之一。
- en: 'Because each reference to *errno* in a threaded program carries the overhead
    of a function call, our example programs don’t directly assign the return value
    of a Pthreads function to *errno*. Instead, we use an intermediate variable and
    employ our *errExitEN()* diagnostic function ([Common Functions and Header Files](ch03.html#common_functions_and_header_files
    "Common Functions and Header Files")), like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为线程程序中每次引用 *errno* 都会带来函数调用的开销，我们的示例程序不会直接将Pthreads函数的返回值赋给 *errno*。相反，我们使用一个中间变量并调用我们的
    *errExitEN()* 诊断函数（[常用函数和头文件](ch03.html#common_functions_and_header_files "常用函数和头文件")），如下所示：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compiling Pthreads programs
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译Pthreads程序
- en: 'On Linux, programs that use the Pthreads API must be compiled with the *cc
    -pthread* option. The effects of this option include the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，使用Pthreads API的程序必须使用 *cc -pthread* 选项进行编译。此选项的效果包括以下几点：
- en: The `_REENTRANT` preprocessor macro is defined. This causes the declarations
    of a few reentrant functions to be exposed.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了`_REENTRANT`预处理宏。这导致一些可重入函数的声明被暴露出来。
- en: The program is linked with the *libpthread* library (the equivalent of *-lpthread*).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序链接了*libpthread*库（相当于*-lpthread*）。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The precise options for compiling a multithreaded program vary across implementations
    (and compilers). Some other implementations (e.g., Tru64) also use *cc -pthread*;
    Solaris and HP-UX use *cc -mt*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编译多线程程序的精确选项在不同的实现（和编译器）之间有所不同。其他一些实现（例如，Tru64）也使用*cc -pthread*；Solaris和HP-UX使用*cc
    -mt*。
- en: Thread Creation
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程创建
- en: When a program is started, the resulting process consists of a single thread,
    called the *initial* or *main* thread. In this section, we look at how to create
    additional threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，结果进程由一个单独的线程组成，称为*初始*或*主*线程。在本节中，我们将讨论如何创建额外的线程。
- en: The *pthread_create()* function creates a new thread.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_create()*函数用于创建一个新线程。'
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回正的错误编号。
- en: The new thread commences execution by calling the function identified by *start*
    with the argument *arg* (i.e., *start(arg)*). The thread that calls *pthread_create()*
    continues execution with the next statement that follows the call. (This behavior
    is the same as the *glibc* wrapper function for the *clone()* system call described
    in Section 28.2.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 新线程通过调用由*start*标识的函数并传递参数*arg*（即，*start(arg)*）开始执行。调用*pthread_create()*的线程继续执行调用后的下一个语句。（这种行为与第28.2节中描述的*glibc*封装函数对*clone()*系统调用的行为相同。）
- en: The *arg* argument is declared as *void **, meaning that we can pass a pointer
    to any type of object to the *start* function. Typically, *arg* points to a global
    or heap variable, but it can also be specified as `NULL`. If we need to pass multiple
    arguments to *start*, then *arg* can be specified as a pointer to a structure
    containing the arguments as separate fields. With judicious casting, we can even
    specify *arg* as an *int*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*arg*参数声明为*void **，这意味着我们可以将指向任何类型对象的指针传递给*start*函数。通常，*arg*指向全局或堆变量，但也可以指定为`NULL`。如果我们需要将多个参数传递给*start*，那么*arg*可以指定为指向包含参数的结构体的指针，每个参数作为独立的字段。通过适当的类型转换，我们甚至可以将*arg*指定为一个*int*。'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Strictly speaking, the C standards don’t define the results of casting *int*
    to *void* * and vice versa. However, most C compilers permit these operations,
    and they produce the desired result; that is, *int j == (int) ((void *) j)*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，C标准并未定义将*int*转换为*void **或反之的结果。然而，大多数C编译器允许这些操作，并且它们会产生预期的结果；也就是说，*int
    j == (int) ((void *) j)*。
- en: The return value of *start* is likewise of type *void **, and it can be employed
    in the same way as the *arg* argument. We’ll see how this value is used when we
    describe the *pthread_join()* function below.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*start*的返回值同样是*void **类型，并且可以像*arg*参数一样使用。当我们描述*pthread_join()*函数时，将看到这个值的用法。'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Caution is required when using a cast integer as the return value of a thread’s
    start function. The reason for this is that `PTHREAD_CANCELED`, the value returned
    when a thread is canceled (see [Chapter 32](ch32.html "Chapter 32. Threads: Thread
    Cancellation")), is usually some implementation-defined integer value cast to
    *void **. If a thread’s start function returns the same integer value, then, to
    another thread that is doing a *pthread_join()*, it will wrongly appear that the
    thread was canceled. In an application that employs thread cancellation and chooses
    to return cast integer values from a thread’s start functions, we must ensure
    that a normally terminating thread does not return an integer whose value matches
    `PTHREAD_CANCELED` on that Pthreads implementation. A portable application would
    need to ensure that normally terminating threads don’t return integer values that
    match `PTHREAD_CANCELED` on any of the implementations on which the application
    is to run.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型转换后的整数作为线程启动函数的返回值时需要小心。原因是，`PTHREAD_CANCELED`是线程被取消时返回的值（参见[第32章](ch32.html
    "第32章. 线程：线程取消")），通常是一些实现定义的整数值，转换为*void **。如果线程的启动函数返回相同的整数值，则在另一个执行*pthread_join()*的线程中，它会错误地显示该线程已被取消。在一个使用线程取消并选择从线程启动函数返回转换整数值的应用程序中，我们必须确保正常终止的线程不会返回一个与该Pthreads实现中的`PTHREAD_CANCELED`相匹配的整数值。一个便携的应用程序需要确保正常终止的线程不会返回与任何实现中的`PTHREAD_CANCELED`相匹配的整数值。
- en: The *thread* argument points to a buffer of type *pthread_t* into which the
    unique identifier for this thread is copied before *pthread_create()* returns.
    This identifier can be used in later Pthreads calls to refer to the thread.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*thread*参数指向一个类型为*pthread_t*的缓冲区，在*pthread_create()*返回之前，将该线程的唯一标识符复制到该缓冲区中。该标识符可以在后续的Pthreads调用中用来引用该线程。'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 explicitly notes that the implementation need not initialize the buffer
    pointed to by *thread* before the new thread starts executing; that is, the new
    thread may start running before *pthread_create()* returns to its caller. If the
    new thread needs to obtain its own ID, then it must do so using *pthread_self()*
    (described in [Thread IDs](ch29.html#thread_ids "Thread IDs")).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3明确指出，在新线程开始执行之前，实现不需要初始化*thread*指向的缓冲区；也就是说，新线程可以在*pthread_create()*返回给调用者之前就开始运行。如果新线程需要获取自己的ID，则必须使用*pthread_self()*来获取（详见[线程ID](ch29.html#thread_ids
    "Thread IDs")）。
- en: The *attr* argument is a pointer to a *pthread_attr_t* object that specifies
    various attributes for the new thread. We say some more about these attributes
    in Section 29.8\. If *attr* is specified as `NULL`, then the thread is created
    with various default attributes, and this is what we’ll do in most of the example
    programs in this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*attr*参数是一个指向*pthread_attr_t*对象的指针，指定新线程的各种属性。我们将在29.8节中进一步讨论这些属性。如果*attr*指定为`NULL`，则线程将使用各种默认属性创建，这也是本书大多数示例程序的做法。'
- en: 'After a call to *pthread_create()*, a program has no guarantees about which
    thread will next be scheduled to use the CPU (on a multiprocessor system, both
    threads may simultaneously execute on different CPUs). Programs that implicitly
    rely on a particular order of scheduling are open to the same sorts of race conditions
    that we described in Section 24.4\. If we need to enforce a particular order of
    execution, we must use one of the synchronization techniques described in [Chapter 30](ch30.html
    "Chapter 30. Threads: Thread Synchronization").'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用*pthread_create()*之后，程序无法保证哪个线程会接下来被调度使用CPU（在多处理器系统上，两个线程可能同时在不同的CPU上执行）。依赖于特定调度顺序的程序可能会遇到我们在24.4节中描述的竞态条件。如果我们需要强制执行特定的执行顺序，必须使用[第30章](ch30.html
    "第30章 线程：线程同步")中描述的某种同步技术。
- en: Thread Termination
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程终止
- en: 'The execution of a thread terminates in one of the following ways:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的执行终止有以下几种方式：
- en: The thread’s start function performs a `return` specifying a return value for
    the thread.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的启动函数执行一个`return`，为线程指定一个返回值。
- en: The thread calls *pthread_exit()* (described below).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程调用*pthread_exit()*（如下所述）。
- en: The thread is canceled using *pthread_cancel()* (described in [Canceling a Thread](ch32.html#canceling_a_thread
    "Canceling a Thread")).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程通过*pthread_cancel()*被取消（详见[取消线程](ch32.html#canceling_a_thread "Canceling a
    Thread")）。
- en: Any of the threads calls *exit()*, or the main thread performs a `return` (in
    the *main()* function), which causes all threads in the process to terminate immediately.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何线程调用了*exit()*，或者主线程执行`return`（在*main()*函数中），则导致进程中的所有线程立即终止。
- en: The *pthread_exit()* function terminates the calling thread, and specifies a
    return value that can be obtained in another thread by calling *pthread_join()*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_exit()*函数终止调用线程，并指定一个返回值，其他线程可以通过调用*pthread_join()*获取该返回值。'
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling *pthread_exit()* is equivalent to performing a `return` in the thread’s
    start function, with the difference that *pthread_exit()* can be called from any
    function that has been called by the thread’s start function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*pthread_exit()*相当于在线程的启动函数中执行`return`，不同之处在于*pthread_exit()*可以从线程启动函数调用的任何函数中调用。
- en: The *retval* argument specifies the return value for the thread. The value pointed
    to by *retval* should not be located on the thread’s stack, since the contents
    of that stack become undefined on thread termination. (For example, that region
    of the process’s virtual memory might be immediately reused by the stack for a
    new thread.) The same statement applies to the value given to a return statement
    in the thread’s start function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*retval*参数指定线程的返回值。*retval*指向的值不应位于线程的栈上，因为线程终止时该栈的内容变为未定义（例如，该进程虚拟内存的那部分可能会立即被新线程的栈重新使用）。同样的声明也适用于线程启动函数中的`return`语句返回的值。'
- en: If the main thread calls *pthread_exit()* instead of calling *exit()* or performing
    a `return`, then the other threads continue to execute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主线程调用*pthread_exit()*，而不是调用*exit()*或执行`return`，则其他线程将继续执行。
- en: Thread IDs
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程 ID
- en: Each thread within a process is uniquely identified by a thread ID. This ID
    is returned to the caller of *pthread_create()*, and a thread can obtain its own
    ID using *pthread_self()*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程中的线程都有唯一的线程 ID。此 ID 会返回给 *pthread_create()* 的调用者，线程可以使用 *pthread_self()*
    获取其自身的 ID。
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns the thread ID of the calling thread
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用线程的线程 ID
- en: 'Thread IDs are useful within applications for the following reasons:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 线程 ID 在应用程序中有以下几个用途：
- en: Various Pthreads functions use thread IDs to identify the thread on which they
    are to act. Examples of such functions include *pthread_join()*, *pthread_detach()*,
    *pthread_cancel()*, and *pthread_kill()*, all of which we describe in this and
    the following chapters.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种 Pthreads 函数使用线程 ID 来标识它们要操作的线程。此类函数的示例包括 *pthread_join()*、*pthread_detach()*、*pthread_cancel()*
    和 *pthread_kill()*，我们将在本章和随后的章节中描述这些函数。
- en: In some applications, it can be useful to tag dynamic data structures with the
    ID of a particular thread. This can serve to identify the thread that created
    or “owns” a data structure, or can be used by one thread to identify a specific
    thread that should subsequently do something with that data structure.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些应用程序中，将动态数据结构标记为特定线程的 ID 可能是有用的。这可以用来标识创建或“拥有”该数据结构的线程，或者可以被一个线程用来标识一个特定的线程，随后让该线程对该数据结构执行某些操作。
- en: The *pthread_equal()* function allows us check whether two thread IDs are the
    same.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_equal()* 函数允许我们检查两个线程 ID 是否相同。'
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns nonzero value if *t1* and *t2* are equal, otherwise 0
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *t1* 和 *t2* 相同，则返回非零值，否则返回 0
- en: 'For example, to check if the ID of the calling thread matches a thread ID saved
    in the variable *tid*, we could write the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了检查调用线程的 ID 是否与保存在变量 *tid* 中的线程 ID 匹配，我们可以编写如下代码：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *pthread_equal()* function is needed because the *pthread_t* data type must
    be treated as opaque data. On Linux, *pthread_t* happens to be defined as an *unsigned
    long*, but on other implementations, it could be a pointer or a structure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用 *pthread_equal()* 函数，因为 *pthread_t* 数据类型必须作为不透明数据处理。在 Linux 中，*pthread_t*
    恰好被定义为 *unsigned long*，但在其他实现中，它可能是一个指针或结构体。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In NPTL, *pthread_t* is actually a pointer that has been cast to *unsigned long*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NPTL 中，*pthread_t* 实际上是一个已被强制转换为 *unsigned long* 的指针。
- en: 'SUSv3 doesn’t require *pthread_t* to be implemented as a scalar type; it could
    be a structure. Therefore, we can’t portably use code such as the following to
    display a thread ID (though it does work on many implementations, including Linux,
    and is sometimes useful for debugging purposes):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 并不要求将 *pthread_t* 实现为标量类型；它可以是一个结构体。因此，我们不能移植性地使用如下代码来显示线程 ID（尽管它在许多实现中有效，包括
    Linux，并且有时对调试有用）：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the Linux threading implementations, thread IDs are unique across processes.
    However, this is not necessarily the case on other implementations, and SUSv3
    explicitly notes that an application can’t portably use a thread ID to identify
    a thread in another process. SUSv3 also notes that an implementation is permitted
    to reuse a thread ID after a terminated thread has been joined with *pthread_join()*
    or after a detached thread has terminated. (We explain *pthread_join()* in the
    next section, and detached threads in Section 29.7.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 线程实现中，线程 ID 在进程间是唯一的。然而，在其他实现中情况未必如此，SUSv3 明确指出，应用程序不能便捷地使用线程 ID 来标识另一个进程中的线程。SUSv3
    还指出，实现可以在终止的线程与 *pthread_join()* 连接后或一个分离的线程终止后，重新使用该线程的 ID。（我们将在下一节解释 *pthread_join()*，并在
    29.7 节解释分离线程。）
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: POSIX thread IDs are not the same as the thread IDs returned by the Linux-specific
    *gettid()* system call. POSIX thread IDs are assigned and maintained by the threading
    implementation. The thread ID returned by *gettid()* is a number (similar to a
    process ID) that is assigned by the kernel. Although each POSIX thread has a unique
    kernel thread ID in the Linux NPTL threading implementation, an application generally
    doesn’t need to know about the kernel IDs (and won’t be portable if it depends
    on knowing them).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 线程 ID 与由 Linux 特定的 *gettid()* 系统调用返回的线程 ID 不相同。POSIX 线程 ID 是由线程实现分配和维护的。而
    *gettid()* 返回的线程 ID 是由内核分配的一个数字（类似于进程 ID）。尽管在 Linux 的 NPTL 线程实现中，每个 POSIX 线程都有一个唯一的内核线程
    ID，但应用程序通常不需要知道内核 ID（如果依赖于知道这些 ID，将无法移植）。
- en: Joining with a Terminated Thread
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与终止线程连接
- en: The *pthread_join()* function waits for the thread identified by *thread* to
    terminate. (If that thread has already terminated, *pthread_join()* returns immediately.)
    This operation is termed *joining*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_join()* 函数等待由 *thread* 标识的线程终止。（如果该线程已经终止，*pthread_join()* 会立即返回。）此操作称为
    *连接*。'
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回正的错误号。
- en: If *retval* is a non-`NULL` pointer, then it receives a copy of the terminated
    thread’s return value—that is, the value that was specified when the thread performed
    a `return` or called *pthread_exit()*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *retval* 是一个非 `NULL` 指针，则它将接收已终止线程的返回值副本——即线程在执行 `return` 或调用 *pthread_exit()*
    时指定的值。
- en: Calling *pthread_join()* for a thread ID that has been previously joined can
    lead to unpredictable behavior; for example, it might instead join with a thread
    created later that happened to reuse the same thread ID.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *pthread_join()* 来等待一个已经被等待过的线程 ID 可能会导致不可预测的行为；例如，它可能会连接到一个后来创建的线程，该线程恰好重新使用了相同的线程
    ID。
- en: If a thread is not detached (see [Detaching a Thread](ch29.html#detaching_a_thread
    "Detaching a Thread")), then we must join with it using *pthread_join()*. If we
    fail to do this, then, when the thread terminates, it produces the thread equivalent
    of a zombie process ([Orphans and Zombies](ch26.html#orphans_and_zombies "Orphans
    and Zombies")). Aside from wasting system resources, if enough thread zombies
    accumulate, we won’t be able to create additional threads.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程没有被分离（参见 [分离线程](ch29.html#detaching_a_thread "分离线程")），则我们必须通过 *pthread_join()*
    来连接该线程。如果未能这样做，则当线程终止时，它将产生与僵尸进程等效的线程（参见 [孤儿和僵尸](ch26.html#orphans_and_zombies
    "孤儿和僵尸")）。除了浪费系统资源外，如果积累了足够多的线程僵尸，我们将无法创建更多的线程。
- en: 'The task that *pthread_join()* performs for threads is similar to that performed
    by *waitpid()* for processes. However, there are some notable differences:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_join()* 对线程执行的任务类似于 *waitpid()* 对进程执行的任务。然而，也有一些显著的不同之处：'
- en: Threads are peers. Any thread in a process can use *pthread_join()* to join
    with any other thread in the process. For example, if thread A creates thread
    B, which creates thread C, then it is possible for thread A to join with thread
    C, or vice versa. This differs from the hierarchical relationship between processes.
    When a parent process creates a child using *fork()*, it is the only process that
    can *wait()* on that child. There is no such relationship between the thread that
    calls *pthread_create()* and the resulting new thread.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程是平等的。进程中的任何线程都可以使用 *pthread_join()* 来连接进程中的任何其他线程。例如，如果线程 A 创建了线程 B，线程 B 又创建了线程
    C，那么线程 A 可以连接到线程 C，反之亦然。这与进程之间的层级关系不同。当父进程通过 *fork()* 创建子进程时，只有父进程可以对该子进程调用 *wait()*。调用
    *pthread_create()* 的线程与新创建的线程之间没有这样的关系。
- en: 'There is no way of saying “join with any thread” (for processes, we can do
    this using the call *waitpid(-1, &status, options)*); nor is there a way to do
    a nonblocking join (analogous to the *waitpid()* `WNOHANG` flag). There are ways
    to achieve similar functionality using condition variables; we show an example
    in [Example Program: Joining Any Terminated Thread](ch30.html#example_program_colon_joining_any_termin
    "Example Program: Joining Any Terminated Thread").'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法说“连接到任何线程”（对于进程，我们可以通过调用 *waitpid(-1, &status, options)* 来实现）；也没有办法执行非阻塞的连接（类似于
    *waitpid()* 的 `WNOHANG` 标志）。可以通过条件变量实现类似的功能；我们在[示例程序：连接任何已终止的线程](ch30.html#example_program_colon_joining_any_termined_thread
    "示例程序：连接任何已终止的线程")中展示了一个例子。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The limitation that *pthread_join()* can join only with a specific thread ID
    is intentional. The idea is that a program should join only with the threads that
    it “knows” about. The problem with a “join with any thread” operation stems from
    the fact that there is no hierarchy of threads, so such an operation could indeed
    join with *any* thread, including one that was privately created by a library
    function. (The condition-variable technique that we show in [Example Program:
    Joining Any Terminated Thread](ch30.html#example_program_colon_joining_any_termin
    "Example Program: Joining Any Terminated Thread") allows a thread to join only
    with any other thread that it knows about.) As a consequence, the library would
    no longer be able to join with that thread in order to obtain its status, and
    it would erroneously try to join with a thread ID that had already been joined.
    In other words, a “join with any thread” operation is incompatible with modular
    program design.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*pthread_join()* 只能与特定线程 ID 连接的限制是故意设计的。其思想是，程序应该只与它“知道”的线程进行连接。所谓“与任何线程连接”的操作存在问题，因为线程没有层次结构，所以这样的操作可能会连接到
    *任何* 线程，包括由库函数私下创建的线程。（我们在 [示例程序：连接任何已终止的线程](ch30.html#example_program_colon_joining_any_termin
    "示例程序：连接任何已终止的线程") 中展示的条件变量技术，允许线程只与它已知的其他线程连接。）因此，库将无法再与该线程连接以获取其状态，并且会错误地尝试连接一个已经连接的线程
    ID。换句话说，“与任何线程连接”操作与模块化程序设计不兼容。'
- en: Example program
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 29-1](ch29.html#a_simple_program_using_pthreads "Example 29-1. A
    simple program using Pthreads") creates another thread and then joins with it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 29-1](ch29.html#a_simple_program_using_pthreads "示例 29-1. 一个使用 Pthreads
    的简单程序") 中的程序创建了一个新线程，并与之连接。'
- en: Example 29-1. A simple program using Pthreads
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 29-1. 一个使用 Pthreads 的简单程序
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run the program in [Example 29-1](ch29.html#a_simple_program_using_pthreads
    "Example 29-1. A simple program using Pthreads"), we see the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 [示例 29-1](ch29.html#a_simple_program_using_pthreads "示例 29-1. 一个使用 Pthreads
    的简单程序") 时，我们看到如下输出：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Depending on how the two threads were scheduled, the order of the first two
    lines of output might be reversed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这两个线程的调度方式，前两行输出的顺序可能会被颠倒。
- en: Detaching a Thread
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离线程
- en: By default, a thread is *joinable*, meaning that when it terminates, another
    thread can obtain its return status using *pthread_join()*. Sometimes, we don’t
    care about the thread’s return status; we simply want the system to automatically
    clean up and remove the thread when it terminates. In this case, we can mark the
    thread as *detached*, by making a call to *pthread_detach()* specifying the thread’s
    identifier in *thread*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，线程是 *可连接的*，意味着当它终止时，其他线程可以通过 *pthread_join()* 获取其返回状态。有时，我们并不关心线程的返回状态；我们只是希望系统在线程终止时自动清理并移除该线程。在这种情况下，我们可以通过调用
    *pthread_detach()* 并指定线程的标识符 *thread* 来将线程标记为 *已分离*。
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回一个正的错误号码。
- en: 'As an example of the use of *pthread_detach()*, a thread can detach itself
    using the following call:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 *pthread_detach()* 的示例，线程可以通过以下调用将自己分离：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once a thread has been detached, it is no longer possible to use *pthread_join()*
    to obtain its return status, and the thread can’t be made joinable again.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线程被分离，就无法再使用 *pthread_join()* 获取其返回状态，并且该线程无法再次变为可连接状态。
- en: Detaching a thread doesn’t make it immune to a call to *exit()* in another thread
    or a `return` in the main thread. In such an event, all threads in the process
    are immediately terminated, regardless of whether they are joinable or detached.
    To put things another way, *pthread_detach()* simply controls what happens after
    a thread terminates, not how or when it terminates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 分离线程并不会使其免疫于另一个线程调用 *exit()* 或主线程中的 `return`。在这种情况下，进程中的所有线程会立即终止，无论它们是可连接的还是已分离的。换句话说，*pthread_detach()*
    只是控制线程终止后的行为，而不是控制线程如何或何时终止。
- en: Thread Attributes
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程属性
- en: We mentioned earlier that the *pthread_create() attr* argument, whose type is
    *pthread_attr_t*, can be used to specify the attributes used in the creation of
    a new thread. We won’t go into the details of these attributes (for those details,
    see the references listed at the end of this chapter) or show the prototypes of
    the various Pthreads functions that can be used to manipulate a *pthread_attr_t*
    object. We’ll just mention that these attributes include information such as the
    location and size of the thread’s stack, the thread’s scheduling policy and priority
    (akin to the process realtime scheduling policies and priorities described in
    [Overview of Realtime Process Scheduling](ch35.html#overview_of_realtime_process_scheduling
    "Overview of Realtime Process Scheduling") and [Realtime Process Scheduling API](ch35.html#realtime_process_scheduling_api
    "Realtime Process Scheduling API")), and whether the thread is joinable or detached.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，*pthread_create() attr* 参数，其类型为 *pthread_attr_t*，可以用来指定创建新线程时使用的属性。我们不会深入讨论这些属性的细节（关于这些细节，请参见本章末尾列出的参考资料），也不会展示各种
    Pthreads 函数的原型，这些函数可用于操作 *pthread_attr_t* 对象。我们只想提到，这些属性包括信息，例如线程堆栈的位置和大小、线程的调度策略和优先级（类似于[实时进程调度概述](ch35.html#overview_of_realtime_process_scheduling
    "实时进程调度概述")和[实时进程调度 API](ch35.html#realtime_process_scheduling_api "实时进程调度 API")中描述的进程实时调度策略和优先级），以及线程是否是可连接的或是分离的。
- en: As an example of the use of thread attributes, the code shown in [Example 29-2](ch29.html#creating_a_thread_with_the_detached_attr
    "Example 29-2. Creating a thread with the detached attribute") creates a new thread
    that is made detached at the time of thread creation (rather than subsequently,
    using *pthread_detach()*). This code first initializes a thread attributes structure
    with default values, sets the attribute required to create a detached thread,
    and then creates a new thread using the thread attributes structure. Once the
    thread has been created, the attributes object is no longer needed, and so is
    destroyed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为线程属性使用的示例，[示例 29-2](ch29.html#creating_a_thread_with_the_detached_attr "示例 29-2. 创建具有分离属性的线程")
    中的代码创建了一个新的线程，并在创建时将其设置为分离状态（而不是随后通过 *pthread_detach()* 设置）。这段代码首先使用默认值初始化一个线程属性结构，设置创建分离线程所需的属性，然后使用该线程属性结构创建一个新线程。线程创建完成后，属性对象不再需要，因此被销毁。
- en: Example 29-2. Creating a thread with the detached attribute
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 29-2. 创建具有分离属性的线程
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Threads Versus Processes
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程与进程
- en: 'In this section, we briefly consider some of the factors that might influence
    our choice of whether to implement an application as a group of threads or as
    a group of processes. We begin by considering the advantages of a multithreaded
    approach:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要考虑了一些可能影响我们选择将应用程序实现为一组线程还是一组进程的因素。我们首先考虑多线程方法的优点：
- en: Sharing data between threads is easy. By contrast, sharing data between processes
    requires more work (e.g., creating a shared memory segment or using a pipe).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程之间共享数据非常容易。相比之下，进程之间共享数据需要更多的工作（例如，创建共享内存段或使用管道）。
- en: Thread creation is faster than process creation; context-switch time may be
    lower for threads than for processes.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程创建比进程创建更快；线程的上下文切换时间可能低于进程的上下文切换时间。
- en: 'Using threads can have some disadvantages compared to using processes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程相较于使用进程可能存在一些缺点：
- en: When programming with threads, we need to ensure that the functions we call
    are thread-safe or are called in a thread-safe manner. (We describe the concept
    of thread safety in Section 31.1.) Multiprocess applications don’t need to be
    concerned with this.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用线程进行编程时，我们需要确保调用的函数是线程安全的，或者以线程安全的方式调用。（我们在第 31.1 节中描述了线程安全的概念。）多进程应用程序则不需要考虑这一点。
- en: A bug in one thread (e.g., modifying memory via an incorrect pointer) can damage
    all of the threads in the process, since they share the same address space and
    other attributes. By contrast, processes are more isolated from one another.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个线程中的 bug（例如，通过错误的指针修改内存）可能会损害进程中所有线程的正常运行，因为它们共享相同的地址空间和其他属性。相比之下，进程之间相对更为隔离。
- en: Each thread is competing for use of the finite virtual address space of the
    host process. In particular, each thread’s stack and thread-specific data (or
    thread-local storage) consumes a part of the process virtual address space, which
    is consequently unavailable for other threads. Although the available virtual
    address space is large (e.g., typically 3 GB on x86-32), this factor may be a
    significant limitation for processes employing large numbers of threads or threads
    that require large amounts of memory. By contrast, separate processes can each
    employ the full range of available virtual memory (subject to the limitations
    of RAM and swap space).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程都在争夺宿主进程有限的虚拟地址空间。特别是，每个线程的栈和线程特定数据（或线程局部存储）占用了进程虚拟地址空间的一部分，因此这些空间对其他线程不可用。虽然可用的虚拟地址空间很大（例如，在x86-32架构上通常为3GB），但对于使用大量线程或需要大量内存的线程的进程来说，这个因素可能是一个显著的限制。相比之下，独立的进程可以各自使用整个可用的虚拟内存范围（受RAM和交换空间限制）。
- en: 'The following are some other points that may influence our choice of threads
    versus processes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能影响我们选择线程与进程的其他因素：
- en: Dealing with signals in a multithreaded application requires careful design.
    (As a general principle, it is usually desirable to avoid the use of signals in
    multithreaded programs.) We say more about threads and signals in Section 33.2.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程应用程序中处理信号需要小心设计。（作为一般原则，通常应该避免在多线程程序中使用信号。）我们将在第33.2节中详细讨论线程和信号。
- en: In a multithreaded application, all threads must be running the same program
    (although perhaps in different functions). In a multiprocess application, different
    processes can run different programs.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，所有线程必须运行相同的程序（尽管可能是不同的函数）。而在多进程应用程序中，不同的进程可以运行不同的程序。
- en: Aside from data, threads also share certain other information (e.g., file descriptors,
    signal dispositions, current working directory, and user and group IDs). This
    may be an advantage or a disadvantage, depending on the application.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了数据之外，线程还共享某些其他信息（例如，文件描述符、信号处理方式、当前工作目录以及用户和组ID）。这可能是一个优点，也可能是一个缺点，具体取决于应用程序。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In a multithreaded process, multiple threads are concurrently executing the
    same program. All of the threads share the same global and heap variables, but
    each thread has a private stack for local variables. The threads in a process
    also share a number of other attributes, including process ID, open file descriptors,
    signal dispositions, current working directory, and resource limits.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个多线程的进程中，多个线程并发地执行相同的程序。所有线程共享相同的全局变量和堆变量，但每个线程有一个私有栈用于局部变量。进程中的线程还共享其他一些属性，包括进程ID、打开的文件描述符、信号处理方式、当前工作目录和资源限制。
- en: The key difference between threads and processes is the easier sharing of information
    that threads provide, and this is the main reason that some application designs
    map better onto a multithread design than onto a multiprocess design. Threads
    can also provide better performance for some operations (e.g., thread creation
    is faster than process creation), but this factor is usually secondary in influencing
    the choice of threads versus processes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和进程之间的主要区别在于线程提供的信息共享更为便捷，这也是一些应用设计更适合多线程设计而不是多进程设计的主要原因。线程还可以为某些操作提供更好的性能（例如，线程创建比进程创建更快），但这个因素通常在选择线程与进程时并不是最重要的。
- en: Threads are created using *pthread_create()*. Each thread can then independently
    terminate using *pthread_exit()*. (If any thread calls *exit()*, then all threads
    immediately terminate.) Unless a thread has been marked as detached (e.g., via
    a call to *pthread_detach()*), it must be joined by another thread using *pthread_join()*,
    which returns the termination status of the joined thread.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是通过*pthread_create()*创建的。然后每个线程可以独立地通过*pthread_exit()*终止。（如果任何线程调用*exit()*，则所有线程都会立即终止。）除非线程被标记为分离状态（例如，通过调用*pthread_detach()*），否则必须由另一个线程使用*pthread_join()*进行连接，该函数返回连接线程的终止状态。
- en: Further information
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: '[Butenhof, 1996] provides an exposition of Pthreads that is both readable and
    thorough. [Robbins & Robbins, 2003] also provides good coverage of Pthreads. [Tanenbaum,
    2007] provides a more theoretical introduction to thread concepts, covering topics
    such as mutexes, critical regions, conditional variables, and deadlock detection
    and avoidance. [Vahalia, 1996] provides background on the implementation of threads.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[Butenhof, 1996] 提供了易读且全面的 Pthreads 讲解。[Robbins & Robbins, 2003] 也对 Pthreads
    进行了很好的覆盖。[Tanenbaum, 2007] 提供了一个更为理论性的线程概念介绍，涵盖了诸如互斥锁、临界区、条件变量、死锁检测与避免等主题。[Vahalia,
    1996] 提供了线程实现的背景知识。'
- en: Exercises
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'What possible outcomes might there be if a thread executes the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个线程执行以下代码，可能会出现哪些结果：
- en: '[PRE13]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Write a program to see what actually happens on Linux. If we have a variable,
    *tid*, containing a thread ID, how can a thread prevent itself from making a call,
    *pthread_join(tid, NULL)*, that is equivalent to the above statement?
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个程序，看看在 Linux 上实际发生了什么。如果我们有一个包含线程 ID 的变量 *tid*，线程如何防止自己调用 *pthread_join(tid,
    NULL)*，这个调用与上面的语句等价？
- en: Aside from the absence of error checking and various variable and structure
    declarations, what is the problem with the following program?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了缺少错误检查以及各种变量和结构声明外，下面这个程序存在哪些问题？
- en: '[PRE14]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
