- en: '![](../images/pg556.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg556.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-51.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-51.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OPTIMIZING
    TACKY PROGRAMS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">优化蹩脚的程序</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: In the first two parts of this book, you wrote a compiler that supported much
    of the C language. You made sure that the executable programs you produced were
    correct— in other words, that their behavior conformed to the C standard—but you
    didn’t worry about their performance. You didn’t try to make them run faster,
    take up less storage space, or consume less memory. In [Part III](part3.xhtml),
    you’ll focus on *optimizing* these programs—that is, making them smaller and faster
    without changing their behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前两部分，你编写了一个支持大部分 C 语言的编译器。你确保生成的可执行程序是正确的——换句话说，它们的行为符合 C 标准——但你没有考虑它们的性能。你没有尝试让它们运行得更快、占用更少的存储空间或消耗更少的内存。在[第三部分](part3.xhtml)，你将专注于*优化*这些程序——也就是说，在不改变它们行为的前提下，让它们更小、更快。
- en: 'Some compiler optimizations are *machine-independent*. This means they aren’t
    affected by the details of the target architecture, like the number of available
    registers or constraints on specific assembly instructions. A compiler typically
    performs these optimizations on an intermediate representation like TACKY before
    converting it to assembly. *Machine-dependent* optimizations, on the other hand,
    need to take the target architecture into account, so these are usually performed
    later, after the program has been converted to assembly. This chapter covers four
    widely used machine-independent optimizations: constant folding, unreachable code
    elimination, copy propagation, and dead store elimination. You’ll add a new optimization
    stage, bolded in the diagram at the start of the chapter, to apply these four
    optimizations to TACKY programs. The next chapter covers register allocation,
    a machine-dependent optimization.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器优化是*与机器无关*的。这意味着它们不受目标架构细节的影响，比如可用寄存器的数量或对特定汇编指令的限制。编译器通常在将代码转换为汇编之前，首先在像
    TACKY 这样的中间表示上执行这些优化。*与机器相关*的优化则需要考虑目标架构，因此这些优化通常在程序被转换为汇编后才执行。本章将介绍四种广泛使用的与机器无关的优化：常量折叠、不可达代码消除、复制传播和死存储消除。你将在本章开始时的图表中新增一个优化阶段，将这四种优化应用于
    TACKY 程序。下一章将介绍寄存器分配，一种与机器相关的优化。
- en: You don’t need to complete [Part II](part2.xhtml) before you start on [Part
    III](part3.xhtml). For each optimization, we’ll start with an implementation that
    doesn’t account for the language features from [Part II](part2.xhtml). Then, if
    necessary, we’ll extend it to support those features; you’ll skip this step if
    you didn’t do [Part II](part2.xhtml). We’ll need this extra step for every optimization
    except unreachable code elimination, which isn’t affected by the features from
    [Part II](part2.xhtml).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始[第三部分](part3.xhtml)之前，你不需要完成[第二部分](part2.xhtml)。对于每个优化，我们会从一个没有考虑到[第二部分](part2.xhtml)语言特性的实现开始。然后，如果需要的话，我们会扩展它以支持这些特性；如果你没有做[第二部分](part2.xhtml)，则跳过这一步。除了不可达代码消除以外，我们对每个优化都需要这一步，后者不受[第二部分](part2.xhtml)特性的影响。
- en: 'These two chapters include just a few of the optimizations you’d find in a
    production compiler, but the basic concepts we’ll cover apply to lots of other
    optimizations too. Before we get started, let’s consider a question that’s fundamental
    to every compiler optimization: How do we know our optimized code is correct?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这两章仅包括了在生产级编译器中能找到的一些优化，但我们将要讲解的基本概念同样适用于许多其他优化。在开始之前，让我们考虑一个对所有编译器优化都至关重要的问题：我们如何知道优化后的代码是正确的？
- en: <samp class="SANS_Futura_Std_Bold_B_11">Safety and Observable Behavior</samp>
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安全性和可观察行为</samp>
- en: First and foremost, compiler optimizations must be *safe*, meaning they cannot
    change the program’s semantics. (It doesn’t matter how speedy your program is
    if it doesn’t behave correctly!) In particular, an optimization must not change
    the program’s *observable behavior*, which is the behavior visible to its execution
    environment. Returning an exit status, printing a message to stdout, and writing
    to a file are all examples of observable behavior. Most of the actions that a
    program takes—like calculating values, updating local variables, and transferring
    control from one statement to another—are not visible to the execution environment,
    so they affect the program’s observable behavior only indirectly. This gives us
    lots of flexibility to transform the program. We can reorder, replace, and even
    delete code as long as the observable behavior doesn’t change.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器优化必须是*安全的*，意味着它们不能改变程序的语义。（如果程序不按预期运行，无论多快都没有意义！）特别是，优化不能改变程序的*可观察行为*，即执行环境可以看到的行为。返回退出状态、打印消息到stdout以及写入文件都是可观察行为的例子。程序采取的大多数动作——比如计算值、更新局部变量、从一个语句转移控制到另一个——对执行环境不可见，因此它们仅间接地影响程序的可观察行为。这为我们提供了很多灵活性，可以重新排序、替换甚至删除代码，只要不改变可观察行为。
- en: Let’s look at how GCC optimizes a simple C program. [Listing 19-1](chapter19.xhtml#list19-1)
    initializes three variables with the values <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>,
    then adds them up and returns the result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看GCC如何优化一个简单的C程序。[清单19-1](chapter19.xhtml#list19-1) 初始化了三个变量，分别赋值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>，然后将它们相加并返回结果。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-1: A C program that
    adds three variables</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单19-1：一个将三个变量相加的C程序</samp>
- en: 'This program will have the same observable behavior every time it runs: it
    will terminate with an exit status of <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>.
    You can run the following command to compile the program without optimizations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序每次运行时都会表现出相同的可观察行为：它将以退出状态<samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>终止。你可以运行以下命令来编译没有优化的程序：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will produce the assembly in [Listing 19-2](chapter19.xhtml#list19-2),
    or something similar.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成[清单19-2](chapter19.xhtml#list19-2)中的汇编代码，或类似的代码。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-2: The unoptimized
    assembly for [Listing 19-1](chapter19.xhtml#list19-1)</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单19-2：未经优化的[清单19-1](chapter19.xhtml#list19-1)汇编代码</samp>
- en: 'This assembly program faithfully implements [Listing 19-1](chapter19.xhtml#list19-1)’s
    source code: it initializes three locations on the stack with the values <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>; adds them up; and
    then returns the result in EAX. Now let’s compile the same source code with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp> switch to enable optimizations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编程序忠实地实现了[清单19-1](chapter19.xhtml#list19-1)的源代码：它在栈上初始化了三个位置，赋值为<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>；然后将它们相加；最后在EAX中返回结果。现在让我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-O</samp>开关编译相同的源代码，以启用优化：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will generate the assembly in [Listing 19-3](chapter19.xhtml#list19-3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成[清单19-3](chapter19.xhtml#list19-3)中的汇编代码。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-3: The optimized
    assembly for [Listing 19-1](chapter19.xhtml#list19-1)</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单19-3：优化后的[清单19-1](chapter19.xhtml#list19-1)汇编代码</samp>
- en: Instead of initializing three variables and then adding them up, this assembly
    program just returns the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>.
    [Listings 19-2](chapter19.xhtml#list19-2) and [19-3](chapter19.xhtml#list19-3)
    look quite different, but they both produce the right observable behavior.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编程序没有初始化三个变量再相加，而是直接返回常数<samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>。[清单19-2](chapter19.xhtml#list19-2)和[19-3](chapter19.xhtml#list19-3)看起来很不一样，但它们都产生了正确的可观察行为。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Four TACKY Optimizations</samp>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">四个粗劣的优化</samp>
- en: 'This section introduces the optimizations we’ll implement in this chapter:
    constant folding, unreachable code elimination, copy propagation, and dead store
    elimination. These optimizations aim to speed up our code and reduce the amount
    of space it takes up. Individually, some of them further one or both of these
    goals, while others aren’t particularly helpful on their own. The real payoff
    comes from the way they work together, because running any one of them creates
    new opportunities to apply the other three. We’ll look at these four optimizations
    in turn, then discuss how each one makes the others more effective.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump in, be aware that I’ll use minimal notation in most of this chapter’s
    TACKY listings. I’ll write copies as <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(Var("x"),
    Var("y"))</samp>, as I’ve occasionally done in earlier chapters, and I’ll take
    similar shortcuts with other instructions. For example, I’ll write binary operations
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a + b</samp> instead of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, Var("a"), Var("b"), Var("x"))</samp>
    and labels as <samp class="SANS_TheSansMonoCd_W5Regular_11">Target:</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(Target)</samp>. This notation
    lets us focus on the high-level logic of our TACKY programs, not the details of
    each TACKY instruction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *constant folding* pass evaluates constant expressions at compile time.
    For example, constant folding will replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    TACKY instruction
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Constant folding can also turn conditional jumps into unconditional jumps or
    eliminate them entirely. It will transform
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: into
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: because the program will always make this jump. It will also delete the instruction
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: because the program will never make this jump. (Deleting useless jumps is often
    considered a type of dead code elimination rather than constant folding, but we’re
    transforming conditional jumps in this pass anyway, so we might as well delete
    the useless ones too.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Constant folding helps with both speed and code size. A single arithmetic operation
    or comparison might require several assembly instructions. Some of those instructions,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, are quite slow.
    Constant folding ultimately replaces that assembly code with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unreachable Code
    Elimination</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Unreachable code elimination* removes instructions that we know will never
    run. Consider the fragment of TACKY in [Listing 19-4](chapter19.xhtml#list19-4).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-4: A fragment of
    TACKY with an unreachable instruction</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll always jump over the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_function</samp>,
    we can get rid of it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction
    is useless, since it jumps to the instruction that we’d execute next anyway. We’ll
    remove this instruction too:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we can also eliminate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    label, assuming no other instruction jumps to it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Strictly speaking, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions we
    just removed aren’t unreachable code; a running program will reach both of them,
    though they won’t have any effect. But removing unreachable code often makes jumps
    and labels useless, so this pass is a logical place to remove them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating unreachable code clearly reduces code size. It’s also pretty clear
    that removing useless jumps saves time; even a useless instruction takes some
    amount of time to execute. It turns out that removing truly unreachable instructions,
    like the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> in [Listing
    19-4](chapter19.xhtml#list19-4), can speed up the program too, by reducing memory
    pressure and freeing up space in the processor’s instruction cache.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Removing unused labels, on the other hand, won’t impact speed or code size,
    since labels don’t become machine instructions in the final executable. We’ll
    remove these labels anyway because it makes our TACKY programs a bit easier to
    read and debug and requires very little extra work.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'This pass is especially handy for cleaning up the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction we add to the end of every TACKY function. Recall that we add this
    instruction as a backstop in case the source code is missing a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. When we convert a program to TACKY, we can’t tell whether this extra
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> is necessary, so we
    end up adding it to functions that don’t need it. The unreachable code elimination
    pass removes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions that we added unnecessarily, while retaining any that we actually
    need. This is one example of a broader principle: generating inefficient code
    and optimizing it later is often easier than generating efficient code to begin
    with.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copy Propagation</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'When a program includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">dst = src</samp>, the
    *copy propagation* pass tries to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> in later instructions.
    Take the following snippet of TACKY:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst
    = src</samp> 时，*复制传播* 过程会尝试在后续指令中用 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    替代 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>。考虑以下 TACKY 代码片段：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with
    its current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 用它当前的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    替换，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令中：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Replacing a variable with a constant is a special case of copy propagation called
    *constant propagation*. In other cases, we’ll replace one variable with another.
    For instance, we can rewrite
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量替换为常量是复制传播的一个特例，称为 *常量传播*。在其他情况下，我们将用另一个变量替换一个变量。例如，我们可以重写
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Sometimes, figuring out whether it’s safe to perform copy propagation can be
    tricky. Take the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，判断是否可以安全地进行复制传播是非常棘手的。考虑以下示例：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Depending on which path we take, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s
    value will be either <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> when we reach the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. Since we don’t
    know which path we’ll take to that instruction, we can’t safely replace <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with either value. To handle
    cases like this one, we’ll need to analyze every possible path to the instruction
    we’d like to rewrite. We’ll use a technique called *data-flow analysis* to look
    at all the paths through a function and find the places where we can perform copy
    propagation safely. Data-flow analysis isn’t just useful for copy propagation;
    it’s used in lots of different compiler optimizations, including dead store elimination,
    which we’ll discuss next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所走的路径，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的值将在我们到达 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令时是 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。由于我们不知道会走哪条路径到达该指令，因此无法安全地将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 替换为任何一个值。为了处理类似的情况，我们需要分析到达我们希望重写的指令的每一条可能路径。我们将使用一种叫做
    *数据流分析* 的技术，查看函数中所有的路径，并找到可以安全执行复制传播的位置。数据流分析不仅对复制传播有用，它还被用于许多不同的编译器优化，包括死存储消除，接下来我们将讨论这个话题。
- en: Some of the copies we analyze will involve variables with static storage duration,
    which can be accessed by multiple functions (or just multiple invocations of the
    same function, in the case of local static variables). We won’t always be able
    to tell exactly when these variables are updated, so our data-flow analysis will
    need to treat them a bit differently than variables with automatic storage duration.
    If you completed [Part II](part2.xhtml), you’ll need to account for similar uncertainty
    around variables whose address is taken with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator, since they can be updated through pointers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析的某些复制操作将涉及具有静态存储持续时间的变量，这些变量可以被多个函数访问（或者在局部静态变量的情况下，仅为同一函数的多个调用）。我们并不总是能准确知道这些变量何时被更新，因此我们的数据流分析需要将它们与具有自动存储持续时间的变量区分开来。如果你完成了
    [第二部分](part2.xhtml)，你将需要考虑类似的不确定性，尤其是对于那些使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    运算符取地址的变量，因为它们可能通过指针被更新。
- en: 'Copy propagation isn’t useful by itself, but it makes our other optimizations
    more effective. When we propagate constants, we create new opportunities for constant
    folding. And we’ll sometimes replace every use of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction’s destination with its source, which makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    itself useless. We’ll remove these useless instructions in our last optimization
    pass: dead store elimination.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dead Store Elimination</samp>
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When an instruction updates a variable’s value but we never use that new value,
    the instruction is called a *dead store*. (The term *store* here refers to any
    instruction that stores a value in a variable, not the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction we introduced in [Part II](part2.xhtml).) Because dead stores don’t
    impact a program’s observable behavior, it’s safe to remove them. Let’s look at
    a simple example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has automatic
    storage duration, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> is a dead store. We don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    between this instruction and the end of the function, which is also the end of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s lifetime.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another kind of dead store:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we’ll never use the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    + b</samp>, because we’ll overwrite it first; this means <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a + b</samp> is a dead store. The dead store elimination pass will identify
    such useless instructions and remove them. The challenge is proving that an instruction
    really is a dead store; to do this, we’ll need to analyze every path through the
    function and make sure that the value it assigns to its destination is never used.
    Once again, we’ll use data-flow analysis to figure out when we can apply this
    optimization safely.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Like copy propagation, dead store elimination gets more complicated when you
    factor in objects that can be accessed by multiple functions or through pointers.
    For instance, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a global
    variable, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    in our first example is *not* a dead store; <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    might be used after the function returns. Our data-flow analysis will have to
    take this possibility into account.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">With Our Powers
    Combined …</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how the four optimizations we’ll implement in this chapter
    work together. We’ll use the TACKY program in [Listing 19-5](chapter19.xhtml#list19-5)
    as a running example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-5: An unoptimized
    TACKY program</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using all four optimizations, we can reduce this function to a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. I’ll display
    the results of each round of optimization, highlighting any changed instructions.
    Because each optimization can create more opportunities to apply the other three,
    we’ll need to run most of them several times to fully optimize this function.
    For now, we’ll decide which optimization to run at each step in an ad hoc way,
    by looking at the code and seeing which one will be most useful. We’ll use a more
    systematic approach when we actually implement our optimization pipeline.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a copy propagation pass, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4 - x</samp>:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can’t replace the second use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>, because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has more than one possible value
    at that point: it might be <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, depending on whether
    we take the conditional jump. Next, we’ll apply constant folding to evaluate <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 4 - 4</samp>:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By replacing a binary operation with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, we’ve created another opportunity for copy propagation. We can replace
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> with its value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> depends
    on a constant condition, we can run constant folding again to turn it into an
    unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This change makes <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp>
    unreachable, so we’ll run unreachable code elimination to delete it. This pass
    will also remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    instruction and <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> label,
    which have no effect once we’ve removed <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 3</samp>:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We couldn’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>
    earlier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> had two
    different values on the different paths to that instruction. We just solved that
    problem by eliminating the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 3</samp>. Now we can run copy propagation again:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we’ll run another round of constant folding:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And we’ll run copy propagation one last time:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最后一次运行复制传播：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We’ve managed to calculate this function’s return value at compile time, eliminating
    every use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> in the process. Now
    we’ll run dead store elimination to clean up the instructions that assign to these
    three variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地在编译时计算了这个函数的返回值，消除了整个过程中对<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>的使用。现在我们将运行死代码消除，清理赋值给这三个变量的指令：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we’ll run unreachable code elimination to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNot
    Zero</samp> instruction and the <samp class="SANS_TheSansMonoCd_W5Regular_11">End</samp>
    label. These are both redundant, since we just eliminated the one instruction
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> jumps
    over. This last round of optimization will reduce our function to a single instruction:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将运行不可达代码消除，移除<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNot Zero</samp>指令和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">End</samp>标签。这两者都是冗余的，因为我们刚刚移除了<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>跳过的那条指令。这轮优化将使我们的函数简化为单一指令：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example highlighted some of the ways our optimizations work together. Copy
    propagation may replace variables with constants, creating new opportunities for
    constant folding; constant folding rewrites arithmetic operations as <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions, creating new opportunities for copy propagation. Constant folding
    can replace conditional jumps with unconditional ones, making some instructions
    unreachable; eliminating unreachable code simplifies the program’s control flow,
    which promotes copy propagation. Copy propagation may make <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions redundant, which lets us remove them during dead store elimination.
    And dead store elimination can potentially remove every instruction between a
    jump and the label it jumps to, which makes the jump, and possibly the label,
    candidates for unreachable code elimination.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了我们的优化方法如何协同工作。复制传播可能会将变量替换为常量，从而为常量折叠创造新的机会；常量折叠将算术运算重写为<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令，创造了新的复制传播机会。常量折叠还可以将条件跳转替换为无条件跳转，从而使一些指令变得不可达；消除不可达代码简化了程序的控制流，这有助于复制传播。复制传播可能使<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令冗余，从而使我们能够在死代码消除过程中将其移除。死代码消除可能会移除跳转与其目标标签之间的每一条指令，这使得跳转和可能的标签成为不可达代码消除的候选项。
- en: Now we know what each optimization does and how they all work together. Next,
    we’ll add a few new command line options that will allow us to test them out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了每个优化的作用以及它们如何协同工作。接下来，我们将添加一些新的命令行选项，允许我们进行测试。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing the Optimization Passes</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">测试优化过程</samp>
- en: This chapter’s tests work differently than the tests in earlier chapters. We
    need to verify that our optimizations don’t change the program’s observable behavior
    but do simplify constant expressions and remove useless code. Our current strategy—compiling
    C programs, running them, and making sure they behave correctly—satisfies the
    first requirement but not the second. Just running a program can’t tell you whether
    the optimization phase *did* anything. To address the second point, the test script
    will inspect your compiler’s assembly output for each test program. To address
    the first point, it will also run each test program and verify its behavior, like
    in earlier chapters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的测试与早期章节的测试有所不同。我们需要验证我们的优化是否没有改变程序的可观察行为，但可以简化常量表达式并移除无用代码。我们当前的策略——编译C程序，运行它们，并确保它们行为正确——满足了第一个要求，但没有满足第二个要求。仅仅运行程序并不能告诉你优化阶段是否*做了*任何事情。为了处理第二个问题，测试脚本将检查每个测试程序的编译器汇编输出。为了处理第一个问题，它还将运行每个测试程序并验证其行为，就像在早期章节中一样。
- en: 'To support this chapter’s tests, you’ll need to add a few command line options
    to your compiler:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持本章的测试，你需要为编译器添加一些命令行选项：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> Directs your compiler
    to emit an assembly file, but not assemble or link it. Running <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-S
    /path/to/program.c</samp> should write an assembly file to */path/to/program.s*.
    (I suggested adding this option to help with debugging back in [Chapter 1](chapter1.xhtml);
    you’ll need to add it now if you haven’t already.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--fold-constants</samp> Enables
    constant folding.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--propagate-copies</samp> Enables
    copy propagation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-unreachable-code</samp> Enables
    unreachable code elimination.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-dead-stores</samp> Enables
    dead store elimination.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--optimize</samp> Enables all four
    optimizations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The options to enable optimizations should be passed to the optimization stage,
    which we’ll implement next. It should be possible to enable more than one individual
    optimization; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--fold-constants
    --propagate-copies</samp> should enable both constant folding and copy propagation,
    but not the other two optimizations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If your compiler doesn’t generate assembly exactly the way I’ve laid out in
    this book, the test script should still be able to validate your assembly output
    for this chapter’s tests, but there are a couple of caveats to keep in mind. First,
    the test script understands only AT&T assembly syntax, which is the syntax we’ve
    been using throughout the book. Second, the script doesn’t recognize every single
    assembly instruction; it only knows about the instructions we’ve used in this
    book and a handful of others that are particularly common in real-world assembly
    code. If you emit instructions that the test script doesn’t understand, some tests
    may fail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll wire up the new optimization stage, which will control when we call
    each individual optimization.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wiring Up the Optimization Stage</samp>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optimization stage will run right after we convert the program to TACKY.
    This stage will optimize each TACKY function independently, without any knowledge
    of the other functions defined in the program. For example, it won’t try to evaluate
    function calls during the constant folding pass or remove them during dead store
    elimination. (We can’t remove function calls during dead store elimination because
    we don’t know whether they have side effects. We *can* remove them during unreachable
    code elimination, though—if a function call will never execute, it doesn’t matter
    what side effects the function has.) Optimizations like these, which transform
    one function at a time, are called *intraprocedural optimizations*. Most production
    compilers also perform *interprocedural optimizations*, which transform whole
    translation units instead of individual functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Each individual optimization will take the body of a TACKY function as input
    and return a semantically equivalent function body as output. In the constant
    folding pass, we’ll represent the function body as a list of TACKY instructions,
    like we normally do. But in the other three optimization passes, we’ll represent
    each function as a *control-flow graph*. This is an intermediate representation
    that explicitly models the different execution paths through a piece of code.
    We’ll talk more about how to construct control-flow graphs and why they’re useful
    later in the chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The optimization stage will process each function by running through all of
    the enabled optimizations over and over. It will stop once it reaches a *fixed
    point*, where running them again doesn’t change the function further. [Listing
    19-6](chapter19.xhtml#list19-6) illustrates this optimization pipeline.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-6: The TACKY optimization
    pipeline</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp>
    is the list of instructions in the body of a TACKY function and <samp class="SANS_TheSansMonoCd_W5Regular_11">enabled_optimizations</samp>
    is a list of strings representing the optimizations that we enabled on the command
    line. (This would be a pretty kludgy way to store command line options in a real
    program; feel free to represent these options differently in your own code.) If
    <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp> is empty, we’ll
    just return it, since there’s nothing to optimize. Otherwise, we’ll perform constant
    folding if it’s enabled ❶.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll convert the function body from a list of instructions into a control-flow
    graph ❷. We’ll apply all the other enabled optimizations to this representation.
    Then, we’ll convert the optimized control-flow graph back to a list of instructions
    ❸, which we’ll compare to the original list ❹. If it’s different, and if we haven’t
    optimized away the entire function, we’ll go through the loop again to take advantage
    of any new optimization opportunities. If it’s the same, we can’t optimize it
    any further, so we’re done.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Using the optimization pipeline in [Listing 19-6](chapter19.xhtml#list19-6),
    we’ll never miss an optimization opportunity. Whenever one optimization changes
    the program, we’ll rerun the other three to take advantage of those changes. This
    is feasible because we’re implementing only four optimizations, and all of our
    test programs are small enough to optimize pretty quickly. Production compilers,
    which implement dozens of optimizations and compile much larger programs, don’t
    take this approach; if they did, compilation would take way too long. Instead,
    they apply a fixed sequence of optimizations just once, running each individual
    optimization in the place where it’s likely to have the biggest impact. As a result,
    they can end up missing optimization opportunities. (Finding the best order to
    run optimizations for any given program is an open research question called the
    *phase ordering problem*.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add the optimization pipeline to your compiler. For now, define
    each individual optimization as a stub that takes a list of instructions and returns
    them unchanged. You can stub out the conversions to and from control-flow graphs
    the same way. Write this plumbing code now so that you can test the individual
    optimization passes as you implement them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything is wired up, you can start on your first optimization: constant
    folding!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Constant Folding</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constant folding is the simplest optimization in this chapter. This pass iterates
    through all the instructions in a TACKY function and evaluates any instructions
    with constant source operands. First, we’ll talk briefly about how to add constant
    folding to the version of the compiler you implemented in [Part I](part1.xhtml).
    Then, we’ll discuss how to handle the types and TACKY instructions you added in
    [Part II](part2.xhtml). If you haven’t worked through [Part II](part2.xhtml) yet,
    feel free to skip the latter discussion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding
    for Part I TACKY Programs</samp>
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The constant folding pass should evaluate four of the TACKY instructions from
    [Part I](part1.xhtml): <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>. When you
    find a <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instruction
    with a constant source operand, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    instruction with two constant source operands, replace it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
    For example, you should replace'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'with:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your constant folding pass could run into two kinds of invalid expressions:
    division by zero and operations that result in integer overflow. These are both
    undefined behaviors, so it doesn’t matter how you evaluate them. However, your
    compiler can’t just fail if it encounters one of these invalid expressions, because
    the program’s behavior is undefined only if it actually reaches the invalid expression
    at runtime. For example, if a program includes division by zero in a branch that’s
    never taken, you should still be able to compile it.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: You should also evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> instructions
    with constant conditions. If the condition is met, replace the instruction with
    an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>. If
    the condition isn’t met, remove the instruction from the program. That’s all there
    is to it! If you completed only [Part I](part1.xhtml), you can skip to the test
    suite once you’ve implemented constant folding for these four instructions. If
    you completed [Part II](part2.xhtml), there are a few more instructions you’ll
    need to handle.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we added the new arithmetic types in [Part II](part2.xhtml), we also added
    type conversion instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>.
    The constant folding pass should evaluate all of these instructions when their
    source operands are constants.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction can
    perform type conversions too; we use it to convert between signed and unsigned
    integers of the same size. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction copies an unsigned constant to a signed variable, or vice versa, this
    pass should convert the constant to the correct type. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, you should
    replace
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'with:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Be careful to perform every type conversion with exactly the same semantics
    that the program would use at runtime. For example, when you convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an integer type, truncate its value toward zero; when you convert an integer
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, round to the
    nearest representable value. The good news is that you already know how to perform
    all of these type conversions at compile time, since you had to convert static
    initializers to the correct type throughout [Part II](part2.xhtml). Ideally, you’ll
    be able to reuse the code you’ve already written to perform these type conversions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to adhere to C semantics when you evaluate unsigned arithmetic
    operations. In particular, you should ensure that unsigned arithmetic wraps around,
    like it would at runtime. How you accomplish this will depend entirely on what
    language you’re writing your compiler in. Some languages support wraparound unsigned
    arithmetic as part of their standard library. In Rust, for example, methods like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_sub</samp>
    provide the same semantics as unsigned arithmetic in C. In other languages, you
    might use a third-party library for unsigned arithmetic. For example, Python doesn’t
    provide unsigned integer types, but the NumPy library does. If you don’t want
    to use an external library, or you can’t find a suitable one, it isn’t terribly
    difficult to implement wraparound unsigned arithmetic yourself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when you evaluate floating-point operations, you’ll need to use round-to-nearest,
    ties-to-even rounding and handle negative zero and infinity correctly. If you
    added support for NaN for extra credit in [Chapter 13](chapter13.xhtml), you’ll
    need to evaluate operations on NaN correctly too. This shouldn’t require any special
    effort on your part—the vast majority of programming languages use IEEE 754 semantics—but
    there’s a small chance that your implementation language handles negative zero,
    NaN, or infinity differently than C. Start with a simple implementation of constant
    folding that doesn’t try to address these edge cases; you can rely on the test
    suite to catch any problems. If you run into any cases that your implementation
    language doesn’t evaluate correctly, you have two options: either find a third-party
    library to handle them for you or evaluate them yourself as a special case.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Control-Flow Graphs</samp>
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the rest of the chapter, we’ll represent TACKY functions as control-flow
    graphs. A graph representation is a good fit for our remaining optimizations,
    which have to account for the different paths we might take through a function.
    The nodes in the control-flow graph represent sequences of straight-line code
    called *basic blocks*, except for two special nodes that represent the function’s
    entry and exit points. Each node has outgoing edges to the nodes that could execute
    immediately after it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s look at the control-flow graph for [Listing 19-7](chapter19.xhtml#list19-7).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-7: A TACKY function
    with multiple execution paths</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: This function executes a loop that repeatedly retrieves a value by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp>, then processes that
    value by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp> ever returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this function immediately
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>
    ever returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the function
    immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. [Figure
    19-1](#fig19-1) shows the corresponding control-flow graph.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-1: The control-flow
    graph for [Listing 19-7](chapter19.xhtml#list19-7) [Description](description-52.xhtml)</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a single outgoing edge from the special <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    node to block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>,
    since we’ll always execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> at the start of the function.
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> will have exactly
    one outgoing edge in every control-flow graph, since C functions have only one
    entry point.) After we execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, there are two possibilities:
    we can execute the next block in the program, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, or we can jump to block
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    has outgoing edges to both of those blocks. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> has outgoing edges to both
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction exits
    the function, so <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>
    each have a single outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Control-Flow
    Graph</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know what a control-flow graph looks like, let’s look at how to
    construct one. First, we’ll define the graph data structure. [Listing 19-8](chapter19.xhtml#list19-8)
    sketches out one possible representation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-8: One way to represent
    the control-flow graph</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Every node in the graph has a unique <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>,
    which identifies it as <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, or a numbered basic
    block. We’ll assign numeric IDs to basic blocks according to their order in the
    original TACKY function. Each basic block holds a list of TACKY instructions,
    a list of *successors* (the blocks that could execute right after it), and another
    list of *predecessors* (the blocks that could execute right before it). The entry
    and exit nodes don’t hold any instructions. <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    as the very first point in the function, has successors but no predecessors. <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, on the other hand, has predecessors
    but no successors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a way to associate both basic blocks and individual instructions
    with extra information so that you can track the results of data-flow analysis
    in the copy propagation and dead store elimination passes. The definition in [Listing
    19-8](chapter19.xhtml#list19-8) doesn’t include a way to track this information.
    You could either attach it directly to the graph or store it in a separate data
    structure. The pseudocode throughout this chapter will use <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate
    _instruction</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_instruction_annotation</samp>
    to save and look up information about individual instructions. It will use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">annotate_block</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block
    _annotation</samp> to save and look up information about basic blocks by block
    ID.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Your graph data structure might look quite different from [Listing 19-8](chapter19.xhtml#list19-8).
    For instance, you might want to represent the graph as a map from node_id to node,
    instead of a list of nodes, or track the entry and exit nodes separately from
    the nodes that represent basic blocks. You can define your control-flow graph
    in whatever way makes sense to you and suits your implementation language, as
    long as it includes all the information you’ll need.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Basic Blocks</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s see how to partition the body of a TACKY function into basic blocks.
    You can’t have any jumps into or out of the middle of a basic block. The only
    way to execute a basic block is to start at its first instruction and continue
    all the way to the end. This implies that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    can appear only as the first instruction in a block, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    or jump instruction can appear only as the last instruction. [Listing 19-9](chapter19.xhtml#list19-9)
    demonstrates how to split a list of instructions into basic blocks along these
    boundaries.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-9: Partitioning
    a list of instructions into basic blocks</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction, we start a new basic block beginning with that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    ❶. When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction or a conditional or unconditional jump, we add it to the current block,
    then start a new empty block ❷. When we encounter any other instruction, we add
    it to the current block without starting a new block ❸.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-9](chapter19.xhtml#list19-9) just partitions a function body into
    a list of lists of instructions. The next step (which I won’t provide pseudocode
    for) is to convert these lists of instructions into <samp class="SANS_TheSansMonoCd_W5Regular_11">BasicBlock</samp>
    nodes with increasing block IDs. We’ll then add these nodes to the graph, along
    with the entry and exit nodes.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Edges to the
    Control-Flow Graph</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After adding every node to the graph, we’ll add edges from each node to its
    successors, as [Listing 19-10](chapter19.xhtml#list19-10) demonstrates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-10: Adding edges
    to the control-flow graph</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_all_edges</samp> ❶ is our unfinished
    control-flow graph, which has nodes but no edges. We’ll begin by adding an edge
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> to the first basic
    block ❷. (We can assume that the function contains at least one basic block, since
    we don’t optimize empty functions.) Throughout this listing, we’ll use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp> function, which takes
    two node IDs, to add edges to the graph. Keep in mind that whenever we add an
    edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>, we must update both the
    successors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> and the
    predecessors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>. I’ve
    omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp>,
    since it will depend on how you’ve defined your control-flow graph.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add outgoing edges from the nodes that correspond to basic blocks.
    To process one of these nodes, we’ll first determine which other node will follow
    it by default if we don’t jump or return at the end of the block. If we’re processing
    the very last block, the next node will be <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
    Otherwise, it will just be whatever basic block comes next in the original TACKY
    function ❸.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We’ll figure out what edges to add by inspecting the last instruction in the
    current basic block. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, we’ll add one outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
    If it’s an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    we’ll add an edge to the block that begins with the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>.
    We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block_by_label</samp>
    helper function, which I won’t show the pseudocode for, to look up which block
    begins with a particular label. I recommend building a map from labels to block
    IDs ahead of time so that this function can just perform a map lookup.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: If a block ends with a conditional jump, we’ll add two outgoing edges. The first
    edge, which represents taking the jump, will go to the block that starts with
    the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> ❹.
    The other edge, which represents not taking the jump ❺, will go to the default
    next node, identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">next_id</samp>.
    If a block ends with any other instruction, we’ll add a single outgoing edge to
    the default next node.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting a Control-Flow
    Graph to a List of Instructions</samp>
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, you should have working code to convert a TACKY function into
    a control-flow graph. You’ll also need code to go in the other direction and convert
    a control-flow graph back to a list of instructions. This operation is much simpler:
    just sort all the basic blocks by ID, then concatenate all their instructions.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Your Control-Flow
    Graph Code Reusable</samp>
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the next chapter, we’ll build control-flow graphs of assembly programs. We’ll
    use the same algorithm to construct these graphs, but we’ll look for different
    individual control-flow instructions. For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, and conditional jump
    instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> all signal the end of
    a basic block in assembly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Once you have working code to construct control-flow graphs, you might want
    to refactor it so you can use it for assembly programs too. This is completely
    optional, but it will save you some effort in the next chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll need to generalize the <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp>
    data type so that a block can contain either TACKY or assembly instructions. Next,
    you’ll need to generalize the logic to analyze specific instructions in [Listings
    19-9](chapter19.xhtml#list19-9) and [19-10](chapter19.xhtml#list19-10). For instance,
    you could define a one-off data type to represent both assembly and TACKY instructions,
    which captures just the information you need to build the control-flow graph:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Instead of inspecting individual TACKY instructions to determine where a basic
    block ends or what its successors are, you can convert each instruction to a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> and inspect
    that. Then, when you need to build control-flow graphs for assembly programs,
    you’ll use a different helper function to convert an assembly instruction to a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> but leave
    everything else the same.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'That wraps up our discussion of control-flow graphs. We’re now ready to move
    on to our second optimization pass: unreachable code elimination.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unreachable Code Elimination</samp>
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll split up this pass into three steps, first removing basic blocks that
    will never execute, then useless jumps, and finally useless labels. The last two
    steps might leave us with empty blocks that don’t contain any instructions. Optionally,
    we can clean up after this optimization by removing these empty blocks from the
    control-flow graph.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Eliminating Unreachable
    Blocks</samp>
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To find every block that might possibly execute, we’ll traverse the control-flow
    graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    We’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>’s successor,
    then all of that node’s successors, and so on, until we run out of nodes to explore.
    If this traversal never reaches a particular basic block, we’ll know that block
    is safe to remove. Let’s try out this approach on the example from [Listing 19-4](chapter19.xhtml#list19-4),
    which we looked at when we first introduced unreachable code elimination:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We determined earlier that <samp class="SANS_TheSansMonoCd_W5Regular_11">x =
    my_function()</samp> is unreachable. Assuming this listing is the entire body
    of a TACKY function, it will have the control-flow graph shown in [Figure 19-2](#fig19-2).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-2.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-2: The control-flow
    graph for [Listing 19-4](chapter19.xhtml#list19-4) [Description](description-53.xhtml)</samp>'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Note that there’s no path from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>.
    If we traverse this graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    we’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Along the way,
    we’ll keep track of which nodes we’ve visited so far. Once we’re done, we’ll see
    that we never visited <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, so we’ll remove it. I won’t
    provide the pseudocode for exploring the graph, since it’s just an ordinary breadth-
    or depth-first graph traversal.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: When you remove a node from the graph, remember to remove its outgoing edges
    too. For example, when we remove <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> from the graph in [Figure
    19-2](#fig19-2), we should also remove it from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>’s list of predecessors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless
    Jumps</samp>
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll remove any useless jump instructions. Remember that by default,
    if a block doesn’t end with a jump or <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, control falls through to the next block from the original program
    order. We can delete a jump instruction if it targets this default next block.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at each basic block that ends with a conditional or unconditional
    jump and figure out which block would follow it by default if the jump weren’t
    taken. If this default next block is its only successor, the jump instruction
    is redundant. [Listing 19-11](chapter19.xhtml#list19-11) demonstrates this approach.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-11: Removing redundant
    jumps</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll sort the basic blocks by their position in the original TACKY function
    ❶; this is one reason we numbered the blocks when we first constructed the graph.
    Next, we’ll iterate over this sorted list of basic blocks (except the last one,
    since a jump at the very end of the function is never redundant) ❷. If a block
    ends with a jump, we’ll search for a successor other than the next block in the
    list. If we find one, we’ll keep the jump instruction. Otherwise, we’ll remove
    it ❸.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Note that the next block in the list won’t necessarily have the next consecutive
    numerical ID, since we may have deleted blocks earlier. Block 2, for example,
    might be followed by block 4\. That’s why we can’t just increment a block’s ID
    number to find its default successor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless
    Labels</samp>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing useless labels is similar to removing useless jumps. After sorting
    basic blocks by numeric ID, we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction at the start of a block if we’ll enter it only by falling through
    from the previous block, rather than jumping to it explicitly. More concretely,
    we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> at
    the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>
    if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i
    - 1]</samp>. We can also delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[0]</samp>
    if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    This transformation is safe because we just deleted redundant jump instructions;
    we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i - 1]</samp>
    won’t end with an explicit jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>.
    I won’t provide pseudocode for this step, since it would look basically the same
    as [Listing 19-11](chapter19.xhtml#list19-11).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Empty Blocks</samp>
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Eliminating unreachable jumps and labels might result in blocks with no instructions.
    If you want, you can remove them; this will shrink the graph and might speed up
    later optimization passes a bit. When you remove a block, make sure to update
    the edges in the control-flow graph accordingly. For example, if the graph has
    edges from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and you delete <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    you’ll need to add an edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Little Bit About Data-Flow Analysis</samp>
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will give a quick overview of data-flow analysis, which we’ll rely
    on in the next two optimization passes. You’ll learn what it is, when it’s useful,
    and what features all data-flow analyses have in common. This isn’t intended to
    be a complete explanation of data-flow analysis; my goal here is just to introduce
    a few key ideas and describe how they fit together, to make the specific analyses
    in later sections easier to follow.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Data-flow analysis answers questions about how values are defined and used
    throughout a function. Different data-flow analyses answer different questions.
    In the copy propagation pass, for example, we’ll implement *reaching copies analysis*.
    This answers the question: Given some instruction *i* in a TACKY function, and
    two operands <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">v</samp> that appear in that function,
    can we guarantee that <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> are equal at the point
    just before *i* executes?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We can divide all data-flow analyses into two broad categories: forward and
    backward analyses. In a *forward analysis*, information travels forward through
    the control-flow graph. Reaching copies analysis is a forward analysis. When we
    see a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>, that tells us that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    might have the same value later in the same basic block or in one of that block’s
    successors. In a *backward analysis*, the reverse is true. In the dead store elimination
    pass, we’ll implement a backward analysis called *liveness analysis*. This analysis
    tells us whether a variable’s current value will ever be used. If we see an instruction
    that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, that tells us
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> may be live earlier
    in the same basic block or in one of that block’s predecessors.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Each data-flow analysis has its own transfer function and meet operator. The
    *transfer function* calculates the analysis results within a single basic block.
    This function analyzes how individual instructions impact the results, but it
    doesn’t need to deal with multiple execution paths. The *meet operator* combines
    information from multiple paths to calculate how each basic block is impacted
    by its neighbors. We’ll use an *iterative algorithm* to drive the entire analysis.
    This algorithm calls the transfer function and meet operator on each basic block
    and keeps track of which blocks still need to be analyzed. It’s iterative because
    we may need to visit some blocks multiple times as we propagate information along
    different execution paths. This algorithm will traverse the control-flow graph,
    analyzing each basic block it visits, until it reaches a fixed point where the
    analysis results no longer change. At that point, we’ll know that every possible
    execution path is accounted for. The iterative algorithm isn’t the only way to
    solve data-flow analysis problems, but it’s the only one we’ll discuss in this
    book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: While different analyses use different transfer functions and meet operators,
    they all use essentially the same iterative algorithm. Forward and backward analyses
    use different versions of this algorithm because they propagate data in opposite
    directions. We’ll implement both versions in the next two sections.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Copy Propagation</samp>
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    appears in a function, we can sometimes replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> later in that function.
    Let’s call the instruction where we’d like to perform this substitution *i*. The
    substitution is safe when two conditions are met. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> must appear on every path from the program’s entry point to *i*. Consider
    the control-flow graph in [Figure 19-3](#fig19-3), which doesn’t meet this condition.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-3.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-3: A control-flow
    graph for a function where we cannot perform copy propagation [Description](description-54.xhtml)</samp>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In this control-flow graph, there are two paths from the start of the function
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>. Because only
    one of these paths passes through <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 2</samp>, it isn’t safe to substitute <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in this <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. In [Figure 19-4](#fig19-4), on the other hand, every path to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> passes through <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp>.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-4.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-4: A control-flow
    graph for a function where we can perform copy propagation [Description](description-55.xhtml)</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: No matter which path we take through [Figure 19-4](#fig19-4), we’ll execute
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp> before we reach the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction, so we
    can safely rewrite that instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-5](#fig19-5) shows another, slightly trickier example.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-5.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-5: Another control-flow
    graph where copy propagation is safe [Description](description-56.xhtml)</samp>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Once again, there are two different paths to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
    Both paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>,
    but they pass through different instances of this instruction that appear in different
    blocks. In <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp>;
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>. But in either case,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    will have the same value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. That means it’s still safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp>.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we rewrite instruction *i*, there’s a second condition that each path
    to *i* must satisfy: between the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> and *i*, neither <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> can be updated again.
    Consider this fragment of TACKY:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>,
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s value is no longer
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> at that point. Updating
    the variable that appeared on the right-hand side of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction causes the same problem:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Right before <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 0</samp>, we
    know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    have the same value. But after that instruction, their values will be different,
    so we can’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
    When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction’s
    source or destination is updated, we say the copy is *killed*. Once a copy is
    killed, we can’t propagate it to later points in the program.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible for <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    to appear multiple times on some path to *i*. It’s unsafe to propagate it only
    if it’s killed after the *last* time it appears. In the following example, it’s
    safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If there are multiple paths to *i*, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction we’re interested in must not be killed on any of them. Take a look
    at [Figure 19-6](#fig19-6), where <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> is killed on one path but not another.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-6.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-6: A control-flow
    graph where a reaching copy is killed along one path [Description](description-57.xhtml)</samp>'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: If we jump over <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will have the same
    value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    But if we take the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, their values will be different.
    Because we don’t know ahead of time which path the program will take, we can’t
    rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider one final edge case. Suppose that <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> is followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>,
    with no intervening kills:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Normally, updating <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> would
    kill the earlier <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    But after <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> still have the same
    value. There are multiple correct ways to handle this case. One option is to say
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp>, so only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
    reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>. In that
    case, we’d rewrite the final instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + x</samp>. This might let us remove <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> later, during dead store elimination, depending on where else <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is used. Another option is to
    simply ignore <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> during
    our analysis, on the grounds that it has no effect; it just assigns <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    the same value it already had. Then, when we’re rewriting instructions, we can
    go ahead and eliminate <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
    and rewrite the last instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = y + y</samp>. A third option is to propagate *both* copies in the final instruction,
    substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This substitution
    is safe but not particularly helpful, since it won’t help us get rid of either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. We’ll go
    with the second option and eliminate the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction appears
    on every path to instruction *i*, and it isn’t killed on any of those paths, we
    say that it *reaches* instruction *i*. At the start of the copy propagation pass,
    we’ll perform reaching copies analysis to determine which copies reach each instruction
    in the TACKY function. Then, we’ll use the results of this analysis to identify
    instructions that we can rewrite safely.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement this whole optimization for the subset of TACKY we defined in
    [Part I](part1.xhtml), then extend it to handle the new language features from
    [Part II](part2.xhtml).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reaching Copies Analysis</samp>
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To implement reaching copies analysis, we’ll define each of the elements of
    data-flow analysis that we discussed earlier: the transfer function, meet operator,
    and iterative algorithm. The transfer function and meet operator we’ll discuss
    in this section are specific to reaching copies analysis, while the iterative
    algorithm applies to every forward data-flow analysis.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp>
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The transfer function takes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions that reach the beginning of a basic block and calculates which copies
    reach each individual instruction within the block. It also calculates which copies
    reach the end of the block, just after the final instruction. The rules here are
    pretty simple. First, if *i* is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, it reaches the instruction that comes right after it. Second, if
    some <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction reaches
    *i*, it also reaches the instruction right after *i*, unless *i* kills it. Let’s
    work through an example. Suppose a basic block contains the instructions in [Listing
    19-12](chapter19.xhtml#list19-12).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-12: A basic block</samp>'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that one <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>, reaches
    the start of this basic block. This <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    will reach the first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a</samp>. Once we encounter <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a</samp>, we add it to the current set of reaching copies, so both <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    = y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> reach
    the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp>.
    Because this next instruction updates <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    it kills <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>. We therefore
    remove <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp> from the set
    of reaching copies, but we add <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 10</samp>. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp>
    kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>. We don’t add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> as a reaching copy
    because it’s not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    The final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction
    doesn’t add or remove any reaching copies. [Table 19-1](chapter19.xhtml#tab19-1)
    lists which copies reach each instruction in this basic block.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-1:</samp> <samp class="SANS_Futura_Std_Book_11">Copies
    Reaching Each Instruction in [Listing 19-12](chapter19.xhtml#list19-12)</samp>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Reaching
    copies</samp> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y}</samp> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y, x = a}</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = a, y = 10}</samp> |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">End of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: Things get a little trickier when we consider variables with static storage
    duration. As [Listing 19-13](chapter19.xhtml#list19-13) demonstrates, these variables
    can be updated in other functions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-13: A C program
    where multiple functions access the same variable with static storage duration</samp>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Our reaching copies analysis should recognize that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">update
    _var</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> kills
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static_var = 5</samp> ❶. Otherwise,
    it will incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    to return the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.
    At first glance, it might look like this problem applies only to file scope variables,
    but as [Listing 19-14](chapter19.xhtml#list19-14) illustrates, it impacts static
    local variables too.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-14: A C program
    where a function call indirectly updates a static local variable</samp>'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: When we analyze <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, we’ll
    need to know that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">indirect_update</samp>
    at ❶ can update <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>. Otherwise,
    we’ll incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to return <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of ways to solve this problem. One option is to figure out
    which function calls will update which static variables. This would make reaching
    copies analysis an interprocedural analysis, which gathers information about multiple
    functions. This approach gets complicated very quickly. Our other option is to
    assume that every function call updates every static variable. We’ll go with this
    option because it’s much simpler. Whenever we encounter a function call, we’ll
    kill any copies to or from static variables. This approach is *conservative*;
    it guarantees that we’ll never perform an unsafe optimization, but it may lead
    us to kill some reaching copies unnecessarily and miss some safe optimizations.
    In contrast, using interprocedural analysis would be a more *aggressive* approach
    because it would miss fewer optimizations. More aggressive optimization techniques
    aren’t always better; they often come at the cost of increased complexity and
    longer compilation times.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-15](chapter19.xhtml#list19-15) gives the pseudocode for the transfer
    function.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-15: The transfer
    function for reaching copies analysis</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: To process an instruction, we’ll first record the set of copies that reach the
    point just before that instruction executes ❶. (We’ll refer to this information
    later when we actually rewrite the instruction.) Then, we’ll inspect the instruction
    itself to calculate which copies reach the point just after it. In the special
    case where <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> reaches
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we won’t add or remove
    any reaching copies ❷. As we saw earlier, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> will have no effect, since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> already have the same
    value. Otherwise, we’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> by killing
    any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> ❸,
    then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> to the
    set of reaching copies ❹.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction, we’ll kill any copies to or from variables with static storage duration
    along with any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    the variable that will hold the result of the function call ❺. The two other instructions
    from [Part I](part1.xhtml) that update variables are <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>. To handle either
    of these, we’ll kill any copies to or from its destination ❻. The remaining TACKY
    instructions from [Part I](part1.xhtml), like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>,
    don’t add or kill any reaching copies. After processing every instruction, we’ll
    record which copies reach the very end of the block ❼.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp>
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll implement the meet operator, which propagates information about
    reaching copies from one block to another. This operator calculates the set of
    initial reaching copies that we’ll pass to the transfer function. Recall that
    a copy reaches some point in the program only if it appears, and isn’t killed,
    on *every* path to that point. Therefore, a copy reaches the beginning of a block
    only if it reaches the end of all of that block’s predecessors. In other words,
    we’ll just take the set intersection of the results from every predecessor. [Listing
    19-16](chapter19.xhtml#list19-16) gives the pseudocode for the meet operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-16: The meet operator
    for reaching copies analysis</samp>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The meet operator takes two arguments. The first is the block whose incoming
    copies we want to calculate. The second, <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>,
    is the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions
    that appear in the function. We initialize the set of incoming copies to this
    value ❶, because it’s the *identity element* for set intersection. That is, given
    any set of reaching copies, *S*, the intersection of *S* with <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>
    is just *S*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate over the block’s predecessors, which might include other basic
    blocks, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> node, or
    both. No copies reach the very start of a function, so if we find <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    in the list of predecessors we just return the empty set ❷. (The intersection
    of the empty set and anything else is still the empty set, so there’s no need
    to look at the block’s other predecessors.) Otherwise, we look up the set of copies
    that reach the end of each predecessor ❸, which we recorded at the end of [Listing
    19-15](chapter19.xhtml#list19-15), and take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">incoming_copies</samp>
    with each of these sets.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We have one edge case to consider. If unreachable code elimination is disabled,
    the block we’re analyzing might not have any predecessors. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp>
    on a block with no predecessors will return <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>,
    so we assume that every possible <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction reaches the start of the block. We don’t care how this ultimately
    impacts the block itself, which will never execute anyway. We *do* care how this
    impacts the block’s successors, which might be reachable. For instance, if a reachable
    block <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and unreachable block
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> both jump to block <samp
    class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, then block <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    is reachable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, our analysis is still safe. The intersection of the real results from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and the junk results from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> will always be a subset
    of the copies that actually reach <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>; this is a conservative
    approximation of the results we’d get if we enabled unreachable code elimination
    and deleted <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> entirely.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp>
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can analyze a basic block with the meet operator and transfer function once
    we know the results from the blocks that preceded it. Now we’ll tie everything
    together and analyze the entire function. There’s just one problem: control-flow
    graphs can have loops! We can’t analyze a block until we’ve analyzed all of its
    predecessors, which requires us to analyze all of their predecessors, and so on.
    Once we hit a loop, it seems like we’re stuck; we can’t analyze any of the blocks
    in the loop, because each block directly or indirectly precedes itself.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: To get unstuck, we need some way to analyze a block even if we don’t have complete
    results from all of its predecessors. The solution is to maintain a provisional
    result for every block; if we need to analyze a block before some of its predecessors,
    we can use those predecessors’ provisional results. At first, before we’ve explored
    any paths to a block, its provisional result includes every <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction in the function. Then, with each new path to the block (or rather,
    the end of the block) that we explore, we eliminate any copies that don’t appear,
    or are killed, along that path. This means a block’s provisional result always
    tells us which reaching copies appear (and aren’t killed) on *every* path to the
    end of that block that we’ve explored so far. Once we’ve explored every possible
    path, we’ll have the block’s final result.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: That’s the basic idea; now let’s put it into practice. First, we’ll annotate
    each basic block with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions in the function. As we learned earlier, this set is the identity
    element for our meet operator. Initializing every block with the identity element
    ensures that blocks we haven’t yet analyzed don’t change the result of the meet
    operator. Let’s try out this approach on the control-flow graph in [Figure 19-7](#fig19-7).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-7.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-7: A control-flow
    graph with a loop [Description](description-58.xhtml)</samp>'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'This control-flow graph contains two <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>. We’ll initially annotate
    each block with the set containing both copies. Then, we’ll analyze the blocks
    in order. We can calculate the final results for <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> in just one pass because
    its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    [Figure 19-8](#fig19-8) illustrates the annotations on each block after we’ve
    processed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-8.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-8: The provisional
    results of reaching copies analysis for [Figure 19-7](#fig19-7), after processing
    B</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I-SUB_11">0 [Description](description-59.xhtml)</samp>'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the annotation on <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> is correct: only <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 3</samp> reaches the end of that block. The other two blocks are still annotated
    with every copy. Next, we’ll apply the meet operator to see which copies reach
    the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>.
    This block has two predecessors: <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> and itself. We’ll therefore
    take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3, y = 4}</samp>, which
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>. This is the same
    result we’d get if <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> were <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>’s only predecessor. That’s
    exactly the behavior we want: because we haven’t analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> yet, it shouldn’t contribute
    to the result of the meet operator. Once we apply the transfer function to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    we’ll recognize that only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>
    reaches the end of the block. We’ll then have all the information we need to process
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    too. [Figure 19-9](#fig19-9) shows the annotations on each block after we’ve analyzed
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-9.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-9: The provisional
    results of reaching copies analysis after analyzing each basic block once [Description](description-60.xhtml)</samp>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Each block now has the correct set of reaching copies. But we don’t yet have
    the right answer for each individual instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. ([Figures 19-8](#fig19-8)
    and [19-9](#fig19-9) don’t show the annotations on individual instructions.) When
    we last analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    we assumed that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> reached
    the start of the block, which would imply that it also reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = process(y)</samp>. Now that we have more accurate information, we need to analyze
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    again. This time, the meet operator will take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 4}</samp>,
    which is the empty set. We’ll pass this result to the transfer function to recalculate
    the results for individual instructions in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. This time around, we’ll
    correctly conclude that no <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions reach <samp class="SANS_TheSansMonoCd_W5Regular_11">x = process(y)</samp>
    (or any point in the block before <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4</samp>, for that matter).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen the iterative algorithm in action, let’s implement it. [Listing
    19-17](chapter19.xhtml#list19-17) gives the pseudocode for this algorithm.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-17: The iterative
    algorithm for reaching copies analysis</samp>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: We’ll maintain a worklist of basic blocks we need to process, including blocks
    that we need to revisit after updating one of their predecessors. In the initial
    setup for this algorithm, we’ll add each basic block to the worklist ❶, since
    we need to analyze every block at least once. We’ll also initialize each block
    with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions that appear in the function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Next, we enter our main processing loop, where we’ll remove a block from the
    front of the worklist ❷, then analyze it using the meet operator and transfer
    function. If this analysis changes the block’s outgoing reaching copies, we’ll
    add all of its successors to the worklist so we can reanalyze them using those
    new results ❸. If a successor is already in the worklist, we don’t need to add
    it again. We’ll repeat this process until the worklist is empty.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-17](chapter19.xhtml#list19-17) works for any forward data-flow
    analysis. Only the transfer function, the meet operator, and the identity element
    used to initialize each basic block will vary.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rewriting TACKY Instructions</samp>
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After running reaching copies analysis, we’ll look for opportunities to rewrite,
    or even remove, each instruction in the TACKY function. To rewrite an instruction,
    we’ll check whether the copies that reach it define any of its operands. If they
    do, we’ll replace those operands with their values. If we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    and its reaching copies include <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we’ll
    remove it instead of trying to rewrite it; the instruction has no effect if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    already have the same value. [Listing 19-18](chapter19.xhtml#list19-18) demonstrates
    how to process each instruction.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-18: Rewriting an
    instruction based on the results of reaching copies analysis</samp>'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Given the set of copies that reach the current instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">replace_operand</samp>
    replaces a single TACKY operand with its value. If the operand is a constant or
    we can’t find a reaching copy that assigns to it, we just return the original
    value.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_instruction</samp>,
    we start by looking up the set of copies that reach the current instruction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">instr</samp> ❶. If <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, we’ll
    search this set, which we call <samp class="SANS_TheSansMonoCd_W5Regular_11">reaching_copies</samp>,
    for a copy from its source to its destination or vice versa ❷. If we find one,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>’s operands already
    have the same value, so we can delete it. ([Listing 19-18](chapter19.xhtml#list19-18)
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to indicate
    that we should delete the instruction; your code might indicate this differently.)
    Otherwise, we try to replace the instruction’s source operand using <samp class="SANS_TheSansMonoCd_W5Regular_11">replace
    _operand</samp> ❸. We’ll attempt to replace the source operands of other TACKY
    instructions in the same way. [Listing 19-18](chapter19.xhtml#list19-18) demonstrates
    how to rewrite the source operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>; I’ve omitted
    the remaining TACKY instructions from [Part I](part1.xhtml) because the logic
    is the same.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a complete copy propagation pass that performs reaching
    copies analysis and uses the results to optimize a TACKY function. If you skipped
    [Part II](part2.xhtml), you can move on to this section’s test suite. But if you
    completed [Part II](part2.xhtml), you still have some work to do.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make copy propagation work with the TACKY code we generate in [Part II](part2.xhtml),
    we need to solve a couple of problems. The first problem is that we sometimes
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions to
    perform type conversions. We don’t want to propagate copies between signed and
    unsigned types, because we sometimes generate different assembly code for operations
    on signed and unsigned values. If we replace a signed value with an unsigned one
    in a comparison, for example, we’ll end up generating the wrong condition code
    for that comparison. Our reaching copies analysis will treat any <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    between signed and unsigned operands like a type conversion instruction instead
    of a normal copy operation. We won’t add it as a reaching copy in the transfer
    function, and we won’t include it in the set of initial reaching copies at the
    start of the iterative algorithm.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Another solution would be to introduce separate signed and unsigned TACKY
    operators for comparisons, remainder operations, and division, so we wouldn’t
    have to check the types of operands to distinguish between these cases during
    code generation. The LLVM IR uses this approach.*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is that variables can be updated through pointers. These
    updates are difficult to analyze. If we see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(v,
    ptr)</samp>, we don’t know which object <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to, so we don’t know which copies to kill. This is similar to the issue
    we ran into with static variables, which could be updated in other functions.
    To solve this problem, we’ll find all the variables that could be accessed through
    pointers (these are called *aliased variables*). We’ll assume that every <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction updates every
    one of these variables. We’ll assume that function calls update these variables
    too, since we can declare a variable in one function and then update it through
    a pointer in a different function. Let’s use this approach to analyze [Listing
    19-19](chapter19.xhtml#list19-19).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-19: A TACKY function
    that updates variables through pointers</samp>'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll identify the aliased variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">function_with_pointers</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are aliased because they’re both used in <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instructions. (Let’s assume that none of the variables in this listing are static,
    so we don’t have to worry about whether other functions take their address.) Next,
    we’ll run reaching copies analysis. Since this whole function body is one basic
    block, we can just apply the transfer function to the entire thing. We’ll add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> to
    the set of reaching copies, as usual. Then, when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction, we’ll kill the copies to our two aliased variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. [Table 19-2](chapter19.xhtml#tab19-2)
    describes which copies will reach each instruction in this function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-2:</samp> <samp class="SANS_Futura_Std_Book_11">Copies
    Reaching Each Instruction in [Listing 19-19](chapter19.xhtml#list19-19)</samp>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Reaching
    copies</samp> |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1}</samp> |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1, y = 2}</samp> |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1 = GetAddress(x)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(10, ptr1)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2 = GetAddress(y)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z = 3}</samp> |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z
    = 3}</samp> |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(z)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">End of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: We correctly recognize that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    which means that we can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + y</samp>. We also assume that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    because our analysis isn’t smart enough to realize that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    couldn’t possibly point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
    Therefore, we won’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + y</samp>, even though it would be safe to do so. Once again, we’re making
    a conservative assumption; we’ll miss some safe optimizations, but we’ll never
    apply any that are unsafe.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Address-Taken
    Analysis</samp>
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The approach we just used to identify aliased variables is called *address-taken
    analysis*. To perform this analysis, we’ll inspect each instruction in a TACKY
    function and identify every variable that either has static storage duration or
    has its address taken by a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction. (We’ll assume that all static variables are aliased, because their
    addresses might be taken in other functions.) We’ll rerun this analysis on every
    iteration through the optimization pipeline because the results can change if
    we optimize away any <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instructions. [Listing 19-20](chapter19.xhtml#list19-20) demonstrates how it fits
    into the overall optimization pipeline we defined in [Listing 19-6](chapter19.xhtml#list19-6).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-20: Adding address-taken
    analysis to the TACKY optimization pipeline</samp>'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Address-taken analysis is just one kind of *alias analysis*, also known as *pointer
    analysis*, which tries to determine whether two pointers or variables can refer
    to the same object. Most pointer analysis algorithms are more powerful than address-taken
    analysis. For example, they could figure out that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    will never point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in
    [Listing 19-19](chapter19.xhtml#list19-19).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating the Transfer Function</samp>
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll extend the transfer function to support the new types and instructions
    we added in [Part II](part2.xhtml).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-21](chapter19.xhtml#list19-21) illustrates our new and improved
    transfer function. It reproduces [Listing 19-15](chapter19.xhtml#list19-15), with
    the changes to support additional types bolded.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-21: The transfer
    function for reaching copies analysis, with support for features from Part II</samp>'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already touched on most of the changes in this listing. Before we add
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">current_reaching_copies</samp>, we’ll
    make sure that its source and destination have the same type, or at least types
    with the same signedness. The <samp class="SANS_TheSansMonoCd_W5Regular_11">signedness</samp>
    helper function should count <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    as a signed type and all pointer types as unsigned types, so we can propagate
    copies between <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, between different
    pointer types, and between pointers and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. (The concept of signedness doesn’t apply to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    or non-scalar types. That’s fine, because we don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions to convert to or from these types. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or non-scalar
    operand, both operands will have the same type, so we won’t need to check their
    signedness.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a function call or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction, we’ll kill any copies to or from aliased variables. We’ll also account
    for the fact that a function call may not have a destination operand. Note that
    we don’t kill the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp> operand. <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    doesn’t change the value of the destination pointer itself, just the value of
    the object it points to. Finally, when we encounter any of the other instructions
    we added in [Part II](part2.xhtml)—including type conversions, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>—we’ll
    kill any copies to or from its destination. We won’t track copies to or from individual
    subobjects within structures or arrays, so <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> will kill
    reaching copies without generating any new ones.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating rewrite_instruction</samp>
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ll rewrite most of the new TACKY instructions from [Part II](part2.xhtml)
    in the same way as the instructions from [Part I](part1.xhtml), replacing any
    source operands that are defined by reaching copies. The one exception is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, which we’ll never rewrite.
    It wouldn’t make sense to apply copy propagation to <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>,
    because it uses its source operand’s address rather than its value.  ### <samp
    class="SANS_Futura_Std_Bold_B_11">Dead Store Elimination</samp>'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Our last optimization is dead store elimination. We’ll use liveness analysis,
    a backward data-flow analysis, to calculate which variables are live at every
    point in the function we’re optimizing. Then, we’ll use the results of this analysis
    to identify dead stores and eliminate them.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: A variable is *live* at a particular point if its value at that point might
    be read later in the program. Otherwise, it’s *dead*. To be more precise, a variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live at any given point
    *p* when two conditions are met. First, there must be at least one path from *p*
    to some later instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is *generated*
    by any instruction that uses it. Second, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    must not be updated on the path from *p* to that later instruction. We say that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is *killed* by any instruction
    that updates it, just like a reaching copy is killed when either of its operands
    is updated. (You’ll see the terms *generate* and *kill* in discussions of most
    data-flow analyses, not just the two in this chapter.) Consider the control-flow
    graph in [Figure 19-10](#fig19-10).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-10.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-10: A control-flow
    graph in which x is live just after it’s defined [Description](description-61.xhtml)</samp>'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: There are two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. On the path through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is never used. On the path
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is used in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is live at the point after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    because it’s generated on one of these paths. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is also live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, at the beginning of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    On the other hand, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead
    at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    and at every point in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, since there are no paths
    from those points to an instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is also dead
    at the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, since we don’t use its (uninitialized)
    value before we assign it a new value in <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp>.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the control-flow graph in [Figure 19-11](#fig19-11).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-11.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-11: A control-flow
    graph with a dead store to x [Description](description-62.xhtml)</samp>'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we have two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Both
    paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions that use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    but on both paths <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is killed
    between <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction that generates
    it. This means that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is
    dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>.
    It’s alive at just two points in this control-flow graph: right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = f()</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = g()</samp> in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: An instruction is a dead store if it assigns to a dead variable and has no other
    side effects. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    is a dead store in [Figure 19-11](#fig19-11) but not in [Figure 19-10](#fig19-10).
    Note that we care whether the variable is dead just *after* the instruction, not
    before it. In the code fragment
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live just before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> but dead after it. The
    fact that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead just
    after we update it means that this instruction is a dead store, so we can eliminate
    it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Liveness Analysis</samp>
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like every data-flow analysis, liveness analysis requires a transfer function,
    a meet operator, and an iterative algorithm. Because this is a backward-flow problem,
    the transfer function will start at the end of a basic block and work its way
    to the beginning, instead of working from start to finish like we did in reaching
    copies analysis. Similarly, the meet operator will gather information from a block’s
    successors, not its predecessors. We’ll also use a slightly different iterative
    algorithm to send data backward through the control-flow graph. Let’s take a closer
    look at each of these pieces.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp>'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The transfer function takes the set of variables that are live at the end of
    a basic block and figures out which variables are live just before each instruction.
    As we saw in [Figures 19-10](#fig19-10) and [19-11](#fig19-11), an instruction
    generates any variables that it reads and kills any variables that it updates.
    For example, to calculate the live variables before the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y * z</samp>, we would take the set of variables that are live right after the
    instruction, add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, and remove <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    If an instruction reads and writes the same variable, it generates the variable
    instead of killing it. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = x + 1</samp> generates <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply the transfer function to the basic block in [Listing 19-22](chapter19.xhtml#list19-22).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-22: A basic block</samp>'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The transfer function will start at the bottom of this basic block and work
    its way up. Let’s assume that there are no live variables at the end of the block,
    after the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction.
    (This assumption might not hold if the function deals with static variables, but
    we’ll worry about that later.) When we process the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to the set of live variables. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 3 * x</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    and generate <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. The next
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp>, generates
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This has no effect because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is already live. Finally,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    leaving no live variables at the start of the basic block. [Table 19-3](chapter19.xhtml#tab19-3)
    summarizes which variables are live just after each instruction in [Listing 19-22](chapter19.xhtml#list19-22).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-3:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Live Variables After Each Instruction in [Listing 19-22](chapter19.xhtml#list19-22)</samp>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Live
    variables</samp> |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Beginning of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3 * x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y}</samp>
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: Static variables complicate things, much like they did during reaching copies
    analysis. We don’t know how other functions will interact with any static variables
    that we encounter; they could read them, update them, or both. We’ll assume that
    every function reads every static variable. This assumption is conservative, since
    it prevents us from eliminating earlier writes to those variables. [Listing 19-23](chapter19.xhtml#list19-23)
    gives the pseudocode for the transfer function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-23: The transfer
    function for liveness analysis</samp>'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the set of variables that are live at the end of the block
    ❶, then process the list of instructions in reverse ❷. We annotate each instruction
    with the set of variables that are live just after it executes ❸; we’ll use this
    annotation later to figure out whether the instruction is a dead store. Then,
    we calculate which variables are live just before the instruction. We’ll kill
    its destination if it has one, then add every variable that it reads. [Listing
    19-23](chapter19.xhtml#list19-23) includes the pseudocode to handle the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction, which updates
    one operand and reads two others, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    instruction, which reads an operand but doesn’t update anything. It omits the
    pseudocode to handle most of the other instructions, since they follow the same
    pattern. <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> is the one
    special case; we’ll kill its destination and add its arguments, as usual, but
    we’ll add every static variable too ❹. Finally, we’ll annotate the whole block
    with the variables that are live before the first instruction ❺. The meet operator
    will use this information later.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of ways to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">all_static_variables</samp>.
    One option is to scan this TACKY function and look for static variables before
    you start the dead store elimination pass. Another option is to scan the whole
    symbol table for static variables, without worrying about which variables show
    up in which functions. There’s no harm in adding superfluous static variables
    here, since they won’t change which instructions we eventually eliminate.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp>
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The meet operator calculates which variables are live at the end of a basic
    block. To find the live variables at the end of some block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    we’ll look at all of its successors. If a variable is live at the start of at
    least one successor, it must also be live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    because there’s at least one path from the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    through that successor to an instruction that generates that variable. Basically,
    we’ll take the set union of all the live variables at the start of all the block’s
    successors.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume that every static variable is live at the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>
    node. Other functions, or other invocations of the current function, might read
    those variables. Variables with automatic storage duration are all dead at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, since they’re not accessible
    after we leave the function. The pseudocode in [Listing 19-24](chapter19.xhtml#list19-24)
    defines the meet operator.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-24: The meet operator
    for liveness analysis</samp>'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: In reaching copies analysis, we were looking for copies that appeared on *every*
    path to a point, so we used set intersection as our meet operator. In liveness
    analysis, we want to know if a variable is used on *any* path from a point, so
    we use set union instead. This is unrelated to the fact that one analysis is forward
    and the other is backward. Some forward analyses use set union because they care
    whether at least one path to a point has some property. Some backward analyses
    use set intersection because they care whether every path from a point has some
    property. Other, more complex analyses don’t use set union or intersection, and
    instead use different meet operators entirely.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp>
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we’ll implement the iterative algorithm for liveness analysis. This
    differs from the iterative algorithm in [Listing 19-17](chapter19.xhtml#list19-17)
    in a couple of ways. First, when the annotation on a block changes, we’ll add
    its predecessors, rather than its successors, to the worklist. Second, we’ll use
    a different initial block annotation. Recall that each block’s initial annotation
    should be the identity element for the meet operator. Since our meet operator
    is set union, the initial annotation is the empty set. As we analyze more paths
    from a block to later points in the program, we’ll add more live variables to
    this set.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: I won’t provide the pseudocode for the backward iterative algorithm, since it’s
    so similar to the forward algorithm we’ve already defined. But I will give you
    a couple of tips about how to implement it. First, you may want to initialize
    the worklist in postorder. (Recall that you sort the nodes of a graph in postorder
    by performing a depth-first traversal and visiting each node after you’ve visited
    its successors.) This makes the backward algorithm terminate faster, just like
    initializing the worklist in reverse postorder helps the forward algorithm terminate
    faster. This ordering means that whenever possible, you’ll visit each block only
    after you’ve visited all of its successors.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: My second tip is to make your backward iterative algorithm reusable. In the
    next chapter, we’ll implement liveness analysis again, this time for assembly
    programs. The details of the meet operator and transfer function will change,
    but the iterative algorithm won’t. Try to structure your code so that you’ll be
    able to reuse the same iterative algorithm with a different meet operator and
    transfer function; then, you’ll be able to use it to analyze assembly programs
    in the next chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Dead Stores</samp>
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After we run liveness analysis, we’ll find any dead stores in the TACKY function
    and remove them. An instruction is a dead store if its destination is dead as
    soon as we execute it, like in the following example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Liveness analysis will tell us that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>,
    making that instruction safe to delete. We’ll never delete function calls, even
    when they update dead variables, because they may have other side effects. We
    also won’t delete instructions without destinations, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>. [Listing 19-25](chapter19.xhtml#list19-25)
    demonstrates how to identify a dead store.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-25: Identifying
    a dead store</samp>'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: If you completed only [Part I](part1.xhtml), you’ve learned everything you need
    to know about dead store elimination! You can skip straight to the test suite.
    Otherwise, read on to learn how to handle the types and instructions we added
    in [Part II](part2.xhtml).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the transfer function, we’ll need to think through which live variables
    each new instruction might generate or kill. The type conversion instructions,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>,
    are straightforward. Each one generates its source operand and kills its destination,
    much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instructions we already handle.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> also follows the usual
    pattern: it generates both source operands and kills its destination.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations on pointers and aggregate types are trickier. Pointers cause
    essentially the same problem they did in reaching copies analysis: when we read
    or write through a pointer, we can’t tell which underlying object is being accessed.
    When in doubt, we should err on the conservative side and assume that a variable
    is live. Therefore, reading through a pointer should generate every aliased variable,
    but writing through a pointer shouldn’t kill any of them. We’ll take a similar
    approach to aggregate variables: reading part of an aggregate variable will generate
    it, but updating part of it won’t kill it. I won’t provide updated pseudocode
    for the transfer function; now that we’ve covered the key points, I’ll let you
    work through the remaining details on your own. The meet operator won’t change;
    in particular, static variables are still live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>,
    but other aliased variables aren’t, because their lifetimes end when the function
    returns.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s update the last step in this optimization, where we use the
    results of liveness analysis to find dead stores and eliminate them. We’ll never
    eliminate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction,
    since we don’t know whether its destination is dead. Even if every single variable
    in the current function is dead, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    might still have a visible side effect. For instance, it could update an object
    defined in a different function, like in the following example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction,
    there are no live variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">update_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">through _pointer</samp>. But that instruction
    clearly isn’t a dead store; it updates an object that our analysis didn’t track
    but that will likely be read later in the program.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The usual logic for spotting dead stores applies to all the other instructions
    from [Part II](part2.xhtml), including <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you implemented four important compiler optimizations: constant
    folding, unreachable code elimination, copy propagation, and dead store elimination.
    You learned how these optimizations work together to transform the TACKY representation
    of a program, resulting in smaller, faster, simpler assembly code than your compiler
    produced before. You also learned how to construct a control-flow graph and perform
    data-flow analysis. These techniques are fundamental to many different optimizations,
    not just the ones we covered in this chapter. If you ever want to implement more
    TACKY optimizations on your own, you’ll be well prepared.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll write a register allocator. You’ll use a graph coloring
    algorithm to map pseudoregisters to hardware registers, and you’ll learn how to
    spill a register when graph coloring fails and you run out of registers. You’ll
    also use a technique called register coalescing to clean up many of the unnecessary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions in your
    assembly code. By the end of the chapter, your assembly programs still won’t look
    quite like what a production compiler would generate, but they’ll be a lot closer.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section lists the resources I referred to while writing this chapter, organized
    by topic.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '**Security implications of compiler optimizations**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: “Dead Store Elimination (Still) Considered Harmful” by Zhaomo Yang et al. surveys
    the different ways programmers try to avoid unwanted dead store elimination and
    the limits of each approach (*[https://<wbr>www<wbr>.usenix<wbr>.org<wbr>/system<wbr>/files<wbr>/conference<wbr>/usenixsecurity17<wbr>/sec17<wbr>-yang<wbr>.pdf](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf)*).
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “The Correctness-Security Gap in Compiler Optimization” by Vijay D’Silva, Mathias
    Payer, and Dawn Song looks at the security impact of a few different compiler
    optimizations and formalizes some of the security properties that optimizations
    should preserve (*[https://<wbr>ieeexplore<wbr>.ieee<wbr>.org<wbr>/stamp<wbr>/stamp<wbr>.jsp<wbr>?tp<wbr>=&arnumber<wbr>=7163211](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7163211)*).
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-flow analysis**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](chapter9.xhtml) of *Compilers: Principles, Techniques, and Tools*,
    2nd edition, by Alfred V. Aho et al. (Addison-Wesley, 2006) defines data-flow
    analysis more rigorously than I did here. It also proves that the iterative algorithm
    is correct and terminates in a reasonable amount of time and discusses the use
    of reverse postorder traversal (which it calls *depth-first ordering*) in this
    algorithm.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paul Hilfinger’s lecture slides from CS164 at UC Berkeley give an example-heavy
    overview of the same material (*[https://<wbr>inst<wbr>.eecs<wbr>.berkeley<wbr>.edu<wbr>/~cs164<wbr>/sp11<wbr>/lectures<wbr>/lecture37<wbr>-2x2<wbr>.pdf](https://inst.eecs.berkeley.edu/~cs164/sp11/lectures/lecture37-2x2.pdf)*).
    I found the explanation of liveness analysis in these slides particularly helpful.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eli Bendersky’s blog post “Directed Graph Traversal, Orderings and Applications
    to Data-Flow Analysis” describes how to sort graphs in postorder and reverse postorder
    to speed up data-flow analysis (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2015<wbr>/directed<wbr>-graph<wbr>-traversal<wbr>-orderings<wbr>-and<wbr>-applications<wbr>-to<wbr>-data<wbr>-flow<wbr>-analysis](https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis)*).
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy propagation**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Every discussion of reaching copies analysis seems to formulate it slightly
    differently. The version in this chapter draws on Jeffrey Ullman’s lecture notes
    on *Compilers: Principles, Techniques, and Tools* (*[http://<wbr>infolab<wbr>.stanford<wbr>.edu<wbr>/~ullman<wbr>/dragon<wbr>/slides3<wbr>.pdf](http://infolab.stanford.edu/~ullman/dragon/slides3.pdf)*
    and *[http://<wbr>infolab<wbr>.stanford<wbr>.edu<wbr>/~ullman<wbr>/dragon<wbr>/slides4<wbr>.pdf](http://infolab.stanford.edu/~ullman/dragon/slides4.pdf)*).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ve borrowed the idea of deleting redundant copies from LLVM’s low-level copy
    propagation pass (*[https://<wbr>llvm<wbr>.org<wbr>/doxygen<wbr>/MachineCopyPropagation<wbr>_8cpp<wbr>_source<wbr>.html](https://llvm.org/doxygen/MachineCopyPropagation_8cpp_source.html)*).
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alias analysis**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: You can find a quick overview of alias analysis algorithms in Phillip Gibbons’s
    lecture slides from his Carnegie Mellon course on compiler optimizations (*[https://<wbr>www<wbr>.cs<wbr>.cmu<wbr>.edu<wbr>/afs<wbr>/cs<wbr>/academic<wbr>/class<wbr>/15745<wbr>-s16<wbr>/www<wbr>/lectures<wbr>/L16<wbr>-Pointer<wbr>-Analysis<wbr>.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L16-Pointer-Analysis.pdf)*).
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
