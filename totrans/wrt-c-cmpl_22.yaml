- en: '![](../images/pg556.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg556.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-51.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-51.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OPTIMIZING
    TACKY PROGRAMS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">优化蹩脚的程序</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: In the first two parts of this book, you wrote a compiler that supported much
    of the C language. You made sure that the executable programs you produced were
    correct— in other words, that their behavior conformed to the C standard—but you
    didn’t worry about their performance. You didn’t try to make them run faster,
    take up less storage space, or consume less memory. In [Part III](part3.xhtml),
    you’ll focus on *optimizing* these programs—that is, making them smaller and faster
    without changing their behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前两部分，你编写了一个支持大部分 C 语言的编译器。你确保生成的可执行程序是正确的——换句话说，它们的行为符合 C 标准——但你没有考虑它们的性能。你没有尝试让它们运行得更快、占用更少的存储空间或消耗更少的内存。在[第三部分](part3.xhtml)，你将专注于*优化*这些程序——也就是说，在不改变它们行为的前提下，让它们更小、更快。
- en: 'Some compiler optimizations are *machine-independent*. This means they aren’t
    affected by the details of the target architecture, like the number of available
    registers or constraints on specific assembly instructions. A compiler typically
    performs these optimizations on an intermediate representation like TACKY before
    converting it to assembly. *Machine-dependent* optimizations, on the other hand,
    need to take the target architecture into account, so these are usually performed
    later, after the program has been converted to assembly. This chapter covers four
    widely used machine-independent optimizations: constant folding, unreachable code
    elimination, copy propagation, and dead store elimination. You’ll add a new optimization
    stage, bolded in the diagram at the start of the chapter, to apply these four
    optimizations to TACKY programs. The next chapter covers register allocation,
    a machine-dependent optimization.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器优化是*与机器无关*的。这意味着它们不受目标架构细节的影响，比如可用寄存器的数量或对特定汇编指令的限制。编译器通常在将代码转换为汇编之前，首先在像
    TACKY 这样的中间表示上执行这些优化。*与机器相关*的优化则需要考虑目标架构，因此这些优化通常在程序被转换为汇编后才执行。本章将介绍四种广泛使用的与机器无关的优化：常量折叠、不可达代码消除、复制传播和死存储消除。你将在本章开始时的图表中新增一个优化阶段，将这四种优化应用于
    TACKY 程序。下一章将介绍寄存器分配，一种与机器相关的优化。
- en: You don’t need to complete [Part II](part2.xhtml) before you start on [Part
    III](part3.xhtml). For each optimization, we’ll start with an implementation that
    doesn’t account for the language features from [Part II](part2.xhtml). Then, if
    necessary, we’ll extend it to support those features; you’ll skip this step if
    you didn’t do [Part II](part2.xhtml). We’ll need this extra step for every optimization
    except unreachable code elimination, which isn’t affected by the features from
    [Part II](part2.xhtml).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始[第三部分](part3.xhtml)之前，你不需要完成[第二部分](part2.xhtml)。对于每个优化，我们会从一个没有考虑到[第二部分](part2.xhtml)语言特性的实现开始。然后，如果需要的话，我们会扩展它以支持这些特性；如果你没有做[第二部分](part2.xhtml)，则跳过这一步。除了不可达代码消除以外，我们对每个优化都需要这一步，后者不受[第二部分](part2.xhtml)特性的影响。
- en: 'These two chapters include just a few of the optimizations you’d find in a
    production compiler, but the basic concepts we’ll cover apply to lots of other
    optimizations too. Before we get started, let’s consider a question that’s fundamental
    to every compiler optimization: How do we know our optimized code is correct?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这两章仅包括了在生产级编译器中能找到的一些优化，但我们将要讲解的基本概念同样适用于许多其他优化。在开始之前，让我们考虑一个对所有编译器优化都至关重要的问题：我们如何知道优化后的代码是正确的？
- en: <samp class="SANS_Futura_Std_Bold_B_11">Safety and Observable Behavior</samp>
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安全性和可观察行为</samp>
- en: First and foremost, compiler optimizations must be *safe*, meaning they cannot
    change the program’s semantics. (It doesn’t matter how speedy your program is
    if it doesn’t behave correctly!) In particular, an optimization must not change
    the program’s *observable behavior*, which is the behavior visible to its execution
    environment. Returning an exit status, printing a message to stdout, and writing
    to a file are all examples of observable behavior. Most of the actions that a
    program takes—like calculating values, updating local variables, and transferring
    control from one statement to another—are not visible to the execution environment,
    so they affect the program’s observable behavior only indirectly. This gives us
    lots of flexibility to transform the program. We can reorder, replace, and even
    delete code as long as the observable behavior doesn’t change.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器优化必须是*安全的*，意味着它们不能改变程序的语义。（如果程序不按预期运行，无论多快都没有意义！）特别是，优化不能改变程序的*可观察行为*，即执行环境可以看到的行为。返回退出状态、打印消息到stdout以及写入文件都是可观察行为的例子。程序采取的大多数动作——比如计算值、更新局部变量、从一个语句转移控制到另一个——对执行环境不可见，因此它们仅间接地影响程序的可观察行为。这为我们提供了很多灵活性，可以重新排序、替换甚至删除代码，只要不改变可观察行为。
- en: Let’s look at how GCC optimizes a simple C program. [Listing 19-1](chapter19.xhtml#list19-1)
    initializes three variables with the values <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>,
    then adds them up and returns the result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看GCC如何优化一个简单的C程序。[清单19-1](chapter19.xhtml#list19-1) 初始化了三个变量，分别赋值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>，然后将它们相加并返回结果。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-1: A C program that
    adds three variables</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单19-1：一个将三个变量相加的C程序</samp>
- en: 'This program will have the same observable behavior every time it runs: it
    will terminate with an exit status of <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>.
    You can run the following command to compile the program without optimizations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序每次运行时都会表现出相同的可观察行为：它将以退出状态<samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>终止。你可以运行以下命令来编译没有优化的程序：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will produce the assembly in [Listing 19-2](chapter19.xhtml#list19-2),
    or something similar.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成[清单19-2](chapter19.xhtml#list19-2)中的汇编代码，或类似的代码。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-2: The unoptimized
    assembly for [Listing 19-1](chapter19.xhtml#list19-1)</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单19-2：未经优化的[清单19-1](chapter19.xhtml#list19-1)汇编代码</samp>
- en: 'This assembly program faithfully implements [Listing 19-1](chapter19.xhtml#list19-1)’s
    source code: it initializes three locations on the stack with the values <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>; adds them up; and
    then returns the result in EAX. Now let’s compile the same source code with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp> switch to enable optimizations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编程序忠实地实现了[清单19-1](chapter19.xhtml#list19-1)的源代码：它在栈上初始化了三个位置，赋值为<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>；然后将它们相加；最后在EAX中返回结果。现在让我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-O</samp>开关编译相同的源代码，以启用优化：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will generate the assembly in [Listing 19-3](chapter19.xhtml#list19-3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成[清单19-3](chapter19.xhtml#list19-3)中的汇编代码。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-3: The optimized
    assembly for [Listing 19-1](chapter19.xhtml#list19-1)</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单19-3：优化后的[清单19-1](chapter19.xhtml#list19-1)汇编代码</samp>
- en: Instead of initializing three variables and then adding them up, this assembly
    program just returns the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>.
    [Listings 19-2](chapter19.xhtml#list19-2) and [19-3](chapter19.xhtml#list19-3)
    look quite different, but they both produce the right observable behavior.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编程序没有初始化三个变量再相加，而是直接返回常数<samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>。[清单19-2](chapter19.xhtml#list19-2)和[19-3](chapter19.xhtml#list19-3)看起来很不一样，但它们都产生了正确的可观察行为。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Four TACKY Optimizations</samp>
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">四个粗劣的优化</samp>
- en: 'This section introduces the optimizations we’ll implement in this chapter:
    constant folding, unreachable code elimination, copy propagation, and dead store
    elimination. These optimizations aim to speed up our code and reduce the amount
    of space it takes up. Individually, some of them further one or both of these
    goals, while others aren’t particularly helpful on their own. The real payoff
    comes from the way they work together, because running any one of them creates
    new opportunities to apply the other three. We’ll look at these four optimizations
    in turn, then discuss how each one makes the others more effective.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了我们将在本章中实现的优化：常量折叠、不可达代码删除、拷贝传播和死存储删除。这些优化旨在加速代码并减少其占用的空间。单独来看，它们中的一些在实现这两个目标上有所帮助，而其他的则单独作用不大。真正的收获来自于它们的协同工作，因为运行其中任何一个优化都能创造出应用其他三个优化的机会。我们将依次查看这四种优化，然后讨论每种优化如何使其他优化更加有效。
- en: Before we jump in, be aware that I’ll use minimal notation in most of this chapter’s
    TACKY listings. I’ll write copies as <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(Var("x"),
    Var("y"))</samp>, as I’ve occasionally done in earlier chapters, and I’ll take
    similar shortcuts with other instructions. For example, I’ll write binary operations
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a + b</samp> instead of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, Var("a"), Var("b"), Var("x"))</samp>
    and labels as <samp class="SANS_TheSansMonoCd_W5Regular_11">Target:</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(Target)</samp>. This notation
    lets us focus on the high-level logic of our TACKY programs, not the details of
    each TACKY instruction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，需要注意的是，我在本章的大多数 TACKY 列表中将使用简化的符号。我会将拷贝写成 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp>，而不是像早期章节中那样写成 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(Var("x"),
    Var("y"))</samp>，并且对其他指令也会采取类似的简化方式。例如，我会将二元操作写成 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a + b</samp>，而不是写成 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add,
    Var("a"), Var("b"), Var("x"))</samp>，并且将标签写作 <samp class="SANS_TheSansMonoCd_W5Regular_11">Target:</samp>，而不是写成
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(Target)</samp>。这种符号可以让我们集中精力关注
    TACKY 程序的高层逻辑，而不是每个 TACKY 指令的细节。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">常量折叠</samp>
- en: The *constant folding* pass evaluates constant expressions at compile time.
    For example, constant folding will replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    TACKY instruction
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量折叠*步骤会在编译时计算常量表达式。例如，常量折叠会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    TACKY 指令替换为'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Constant folding can also turn conditional jumps into unconditional jumps or
    eliminate them entirely. It will transform
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 常量折叠还可以将条件跳转转化为无条件跳转，或者完全消除它们。它会将
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: into
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 进入
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: because the program will always make this jump. It will also delete the instruction
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为程序总是会执行这个跳转。它也会删除这条指令。
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: because the program will never make this jump. (Deleting useless jumps is often
    considered a type of dead code elimination rather than constant folding, but we’re
    transforming conditional jumps in this pass anyway, so we might as well delete
    the useless ones too.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为程序永远不会执行这个跳转。（删除无用的跳转通常被认为是一种死代码删除，而不是常量折叠，但由于我们在这个步骤中会转换条件跳转，因此我们也可以顺便删除那些无用的跳转。）
- en: Constant folding helps with both speed and code size. A single arithmetic operation
    or comparison might require several assembly instructions. Some of those instructions,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, are quite slow.
    Constant folding ultimately replaces that assembly code with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 常量折叠同时有助于提高速度和减小代码体积。一个单独的算术操作或比较可能需要几条汇编指令。其中一些指令，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>，非常慢。常量折叠最终会将这些汇编代码替换为一条
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unreachable Code
    Elimination</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不可达代码删除</samp>
- en: '*Unreachable code elimination* removes instructions that we know will never
    run. Consider the fragment of TACKY in [Listing 19-4](chapter19.xhtml#list19-4).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可达代码删除*会移除我们知道永远不会执行的指令。考虑 [Listing 19-4](chapter19.xhtml#list19-4) 中的 TACKY
    片段。'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-4: A fragment of
    TACKY with an unreachable instruction</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 19-4：包含无法访问指令的 TACKY 片段</samp>
- en: 'Since we’ll always jump over the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_function</samp>,
    we can get rid of it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们总是跳过对<samp class="SANS_TheSansMonoCd_W5Regular_11">my_function</samp>的调用，我们可以将其移除：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction
    is useless, since it jumps to the instruction that we’d execute next anyway. We’ll
    remove this instruction too:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，<samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> 指令变得无用了，因为它跳转到我们接下来无论如何都会执行的指令。我们也会移除这条指令：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we can also eliminate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    label, assuming no other instruction jumps to it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以移除 <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> 标签，前提是没有其他指令跳转到它：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Strictly speaking, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions we
    just removed aren’t unreachable code; a running program will reach both of them,
    though they won’t have any effect. But removing unreachable code often makes jumps
    and labels useless, so this pass is a logical place to remove them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们刚刚移除的<samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>指令并不是无法访问的代码；正在运行的程序会到达这两条指令，尽管它们没有任何效果。但移除无法访问的代码通常会让跳转和标签变得无用，因此这是移除它们的一个合乎逻辑的步骤。
- en: Eliminating unreachable code clearly reduces code size. It’s also pretty clear
    that removing useless jumps saves time; even a useless instruction takes some
    amount of time to execute. It turns out that removing truly unreachable instructions,
    like the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> in [Listing
    19-4](chapter19.xhtml#list19-4), can speed up the program too, by reducing memory
    pressure and freeing up space in the processor’s instruction cache.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 消除无法访问的代码显然可以减少代码的大小。同样也很清楚，移除无用的跳转可以节省时间；即便是无用的指令，也需要一些时间来执行。事实证明，移除真正无法访问的指令，如[列表
    19-4](chapter19.xhtml#list19-4)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>，也能通过减轻内存压力并释放处理器指令缓存中的空间，提升程序速度。
- en: Removing unused labels, on the other hand, won’t impact speed or code size,
    since labels don’t become machine instructions in the final executable. We’ll
    remove these labels anyway because it makes our TACKY programs a bit easier to
    read and debug and requires very little extra work.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，移除未使用的标签不会影响速度或代码大小，因为标签在最终的可执行文件中并不会变成机器指令。我们还是会移除这些标签，因为这样可以让我们的 TACKY
    程序更容易阅读和调试，并且几乎不需要额外的工作量。
- en: 'This pass is especially handy for cleaning up the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction we add to the end of every TACKY function. Recall that we add this
    instruction as a backstop in case the source code is missing a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. When we convert a program to TACKY, we can’t tell whether this extra
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> is necessary, so we
    end up adding it to functions that don’t need it. The unreachable code elimination
    pass removes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions that we added unnecessarily, while retaining any that we actually
    need. This is one example of a broader principle: generating inefficient code
    and optimizing it later is often easier than generating efficient code to begin
    with.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤对于清理我们添加到每个 TACKY 函数末尾的额外<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令尤其有用。回想一下，我们添加这条指令是为了防止源代码中缺少
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句的情况。当我们将程序转换为 TACKY
    时，我们无法判断这条额外的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 是否必要，因此最终我们会把它添加到不需要的函数中。无法访问的代码消除步骤会移除所有我们不必要添加的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令，同时保留我们实际需要的指令。这是一个更广泛原则的例子：生成低效代码并在之后优化它，通常比一开始就生成高效代码要容易。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copy Propagation</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">复制传播</samp>'
- en: 'When a program includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">dst = src</samp>, the
    *copy propagation* pass tries to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> in later instructions.
    Take the following snippet of TACKY:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst
    = src</samp> 时，*复制传播* 过程会尝试在后续指令中用 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    替代 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>。考虑以下 TACKY 代码片段：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with
    its current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 用它当前的值 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    替换，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令中：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Replacing a variable with a constant is a special case of copy propagation called
    *constant propagation*. In other cases, we’ll replace one variable with another.
    For instance, we can rewrite
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量替换为常量是复制传播的一个特例，称为 *常量传播*。在其他情况下，我们将用另一个变量替换一个变量。例如，我们可以重写
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Sometimes, figuring out whether it’s safe to perform copy propagation can be
    tricky. Take the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，判断是否可以安全地进行复制传播是非常棘手的。考虑以下示例：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Depending on which path we take, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s
    value will be either <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> when we reach the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. Since we don’t
    know which path we’ll take to that instruction, we can’t safely replace <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with either value. To handle
    cases like this one, we’ll need to analyze every possible path to the instruction
    we’d like to rewrite. We’ll use a technique called *data-flow analysis* to look
    at all the paths through a function and find the places where we can perform copy
    propagation safely. Data-flow analysis isn’t just useful for copy propagation;
    it’s used in lots of different compiler optimizations, including dead store elimination,
    which we’ll discuss next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所走的路径，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的值将在我们到达 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令时是 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。由于我们不知道会走哪条路径到达该指令，因此无法安全地将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 替换为任何一个值。为了处理类似的情况，我们需要分析到达我们希望重写的指令的每一条可能路径。我们将使用一种叫做
    *数据流分析* 的技术，查看函数中所有的路径，并找到可以安全执行复制传播的位置。数据流分析不仅对复制传播有用，它还被用于许多不同的编译器优化，包括死存储消除，接下来我们将讨论这个话题。
- en: Some of the copies we analyze will involve variables with static storage duration,
    which can be accessed by multiple functions (or just multiple invocations of the
    same function, in the case of local static variables). We won’t always be able
    to tell exactly when these variables are updated, so our data-flow analysis will
    need to treat them a bit differently than variables with automatic storage duration.
    If you completed [Part II](part2.xhtml), you’ll need to account for similar uncertainty
    around variables whose address is taken with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator, since they can be updated through pointers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析的某些复制操作将涉及具有静态存储持续时间的变量，这些变量可以被多个函数访问（或者在局部静态变量的情况下，仅为同一函数的多个调用）。我们并不总是能准确知道这些变量何时被更新，因此我们的数据流分析需要将它们与具有自动存储持续时间的变量区分开来。如果你完成了
    [第二部分](part2.xhtml)，你将需要考虑类似的不确定性，尤其是对于那些使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    运算符取地址的变量，因为它们可能通过指针被更新。
- en: 'Copy propagation isn’t useful by itself, but it makes our other optimizations
    more effective. When we propagate constants, we create new opportunities for constant
    folding. And we’ll sometimes replace every use of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction’s destination with its source, which makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    itself useless. We’ll remove these useless instructions in our last optimization
    pass: dead store elimination.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 复制传播本身并没有多大用处，但它能使其他优化更加有效。当我们传播常量时，就会为常量折叠创造新的机会。我们有时会将每个<sup class="SANS_TheSansMonoCd_W5Regular_11">Copy</sup>指令的目标替换为其源，这样就使得<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</sup>本身变得无用。我们将在最后的优化过程中移除这些无用的指令：死存储消除。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dead Store Elimination</samp>
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <sup class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">死存储消除</sup>
- en: 'When an instruction updates a variable’s value but we never use that new value,
    the instruction is called a *dead store*. (The term *store* here refers to any
    instruction that stores a value in a variable, not the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction we introduced in [Part II](part2.xhtml).) Because dead stores don’t
    impact a program’s observable behavior, it’s safe to remove them. Let’s look at
    a simple example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当一条指令更新了变量的值，但我们从未使用该新值时，这条指令就被称为*死存储*。（这里的*store*指的是任何将值存储到变量中的指令，而不是我们在[第二部分](part2.xhtml)中介绍的TACKY<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Store</sup>指令。）由于死存储不会影响程序的可观察行为，因此可以安全地将其移除。让我们看一个简单的例子：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has automatic
    storage duration, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> is a dead store. We don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    between this instruction and the end of the function, which is also the end of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s lifetime.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设<sup class="SANS_TheSansMonoCd_W5Regular_11">x</sup>具有自动存储持续时间，指令<sup class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</sup>就是死存储。在这条指令和函数结束（即<sup class="SANS_TheSansMonoCd_W5Regular_11">x</sup>的生命周期结束）之间，我们没有使用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">x</sup>。
- en: 'Here’s another kind of dead store:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种死存储的例子：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we’ll never use the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    + b</samp>, because we’ll overwrite it first; this means <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a + b</samp> is a dead store. The dead store elimination pass will identify
    such useless instructions and remove them. The challenge is proving that an instruction
    really is a dead store; to do this, we’ll need to analyze every path through the
    function and make sure that the value it assigns to its destination is never used.
    Once again, we’ll use data-flow analysis to figure out when we can apply this
    optimization safely.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们永远不会使用<sup class="SANS_TheSansMonoCd_W5Regular_11">a + b</sup>的结果，因为我们会首先覆盖它；这意味着<sup
    class="SANS_TheSansMonoCd_W5Regular_11">x = a + b</sup>是一个死存储。死存储消除过程会识别这些无用的指令并将其移除。挑战在于证明一条指令确实是死存储；为此，我们需要分析函数的每一条路径，确保它为目标变量赋的值从未被使用。我们将再次使用数据流分析来确保何时可以安全地应用此优化。
- en: Like copy propagation, dead store elimination gets more complicated when you
    factor in objects that can be accessed by multiple functions or through pointers.
    For instance, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a global
    variable, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    in our first example is *not* a dead store; <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    might be used after the function returns. Our data-flow analysis will have to
    take this possibility into account.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与复制传播类似，当你考虑到可以由多个函数或通过指针访问的对象时，死存储消除会变得更加复杂。例如，如果<sup class="SANS_TheSansMonoCd_W5Regular_11">x</sup>是一个全局变量，那么我们第一个例子中的指令<sup
    class="SANS_TheSansMonoCd_W5Regular_11">x = 10</sup>就*不是*死存储；<sup class="SANS_TheSansMonoCd_W5Regular_11">x</sup>可能会在函数返回后被使用。我们的数据流分析必须考虑到这种可能性。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">With Our Powers
    Combined …</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <sup class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">当我们的力量结合时……</sup>'
- en: Now let’s look at how the four optimizations we’ll implement in this chapter
    work together. We’ll use the TACKY program in [Listing 19-5](chapter19.xhtml#list19-5)
    as a running example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看本章中我们将实现的四种优化如何协同工作。我们将以[TACKY 程序](chapter19.xhtml#list19-5)为例进行讲解。
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-5: An unoptimized
    TACKY program</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-5：一个未优化的 TACKY 程序</samp>
- en: Using all four optimizations, we can reduce this function to a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. I’ll display
    the results of each round of optimization, highlighting any changed instructions.
    Because each optimization can create more opportunities to apply the other three,
    we’ll need to run most of them several times to fully optimize this function.
    For now, we’ll decide which optimization to run at each step in an ad hoc way,
    by looking at the code and seeing which one will be most useful. We’ll use a more
    systematic approach when we actually implement our optimization pipeline.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有四个优化方法，我们可以将这个函数简化为一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    指令。我将展示每轮优化的结果，并突出显示任何改变的指令。由于每次优化都能为应用其他三种优化创造更多机会，我们需要多次运行大部分优化才能完全优化这个函数。现在，我们将根据每次查看代码来决定运行哪种优化，选择最有用的一种。我们将在实际实现优化管道时，采用更系统化的方法。
- en: 'Let’s start with a copy propagation pass, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4 - x</samp>:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一次复制传播开始，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> 替换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4 - x</samp> 中：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can’t replace the second use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>, because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has more than one possible value
    at that point: it might be <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, depending on whether
    we take the conditional jump. Next, we’ll apply constant folding to evaluate <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 4 - 4</samp>:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能替换 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的第二次使用，出现在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp> 中，因为此时 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    可能有多个值：它可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，具体取决于是否进行条件跳转。接下来，我们将应用常量折叠来计算
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4 - 4</samp>：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By replacing a binary operation with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, we’ve created another opportunity for copy propagation. We can replace
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> with its value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令替换二元操作，我们为复制传播创造了另一个机会。我们可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> 指令中用 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    替换 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 的值：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> depends
    on a constant condition, we can run constant folding again to turn it into an
    unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> 依赖于常量条件，我们可以再次运行常量折叠，将其转化为无条件的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This change makes <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp>
    unreachable, so we’ll run unreachable code elimination to delete it. This pass
    will also remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    instruction and <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> label,
    which have no effect once we’ve removed <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 3</samp>:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化使得 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp> 无法到达，因此我们将运行无法到达代码消除来删除它。这个阶段还将删除
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> 指令和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    标签，因为一旦我们删除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp>，它们就不再有效：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We couldn’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>
    earlier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> had two
    different values on the different paths to that instruction. We just solved that
    problem by eliminating the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 3</samp>. Now we can run copy propagation again:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前不能重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>，因为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在不同路径上有两个不同的值。我们通过消除 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 3</samp> 的路径解决了这个问题。现在我们可以再次运行复制传播：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we’ll run another round of constant folding:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将再运行一轮常量折叠：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And we’ll run copy propagation one last time:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最后一次运行复制传播：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We’ve managed to calculate this function’s return value at compile time, eliminating
    every use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> in the process. Now
    we’ll run dead store elimination to clean up the instructions that assign to these
    three variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地在编译时计算了这个函数的返回值，消除了整个过程中对<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>的使用。现在我们将运行死代码消除，清理赋值给这三个变量的指令：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we’ll run unreachable code elimination to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNot
    Zero</samp> instruction and the <samp class="SANS_TheSansMonoCd_W5Regular_11">End</samp>
    label. These are both redundant, since we just eliminated the one instruction
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> jumps
    over. This last round of optimization will reduce our function to a single instruction:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将运行不可达代码消除，移除<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNot Zero</samp>指令和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">End</samp>标签。这两者都是冗余的，因为我们刚刚移除了<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>跳过的那条指令。这轮优化将使我们的函数简化为单一指令：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example highlighted some of the ways our optimizations work together. Copy
    propagation may replace variables with constants, creating new opportunities for
    constant folding; constant folding rewrites arithmetic operations as <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions, creating new opportunities for copy propagation. Constant folding
    can replace conditional jumps with unconditional ones, making some instructions
    unreachable; eliminating unreachable code simplifies the program’s control flow,
    which promotes copy propagation. Copy propagation may make <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions redundant, which lets us remove them during dead store elimination.
    And dead store elimination can potentially remove every instruction between a
    jump and the label it jumps to, which makes the jump, and possibly the label,
    candidates for unreachable code elimination.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了我们的优化方法如何协同工作。复制传播可能会将变量替换为常量，从而为常量折叠创造新的机会；常量折叠将算术运算重写为<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令，创造了新的复制传播机会。常量折叠还可以将条件跳转替换为无条件跳转，从而使一些指令变得不可达；消除不可达代码简化了程序的控制流，这有助于复制传播。复制传播可能使<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令冗余，从而使我们能够在死代码消除过程中将其移除。死代码消除可能会移除跳转与其目标标签之间的每一条指令，这使得跳转和可能的标签成为不可达代码消除的候选项。
- en: Now we know what each optimization does and how they all work together. Next,
    we’ll add a few new command line options that will allow us to test them out.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了每个优化的作用以及它们如何协同工作。接下来，我们将添加一些新的命令行选项，允许我们进行测试。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing the Optimization Passes</samp>
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">测试优化过程</samp>
- en: This chapter’s tests work differently than the tests in earlier chapters. We
    need to verify that our optimizations don’t change the program’s observable behavior
    but do simplify constant expressions and remove useless code. Our current strategy—compiling
    C programs, running them, and making sure they behave correctly—satisfies the
    first requirement but not the second. Just running a program can’t tell you whether
    the optimization phase *did* anything. To address the second point, the test script
    will inspect your compiler’s assembly output for each test program. To address
    the first point, it will also run each test program and verify its behavior, like
    in earlier chapters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的测试与早期章节的测试有所不同。我们需要验证我们的优化是否没有改变程序的可观察行为，但可以简化常量表达式并移除无用代码。我们当前的策略——编译C程序，运行它们，并确保它们行为正确——满足了第一个要求，但没有满足第二个要求。仅仅运行程序并不能告诉你优化阶段是否*做了*任何事情。为了处理第二个问题，测试脚本将检查每个测试程序的编译器汇编输出。为了处理第一个问题，它还将运行每个测试程序并验证其行为，就像在早期章节中一样。
- en: 'To support this chapter’s tests, you’ll need to add a few command line options
    to your compiler:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持本章的测试，你需要为编译器添加一些命令行选项：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> Directs your compiler
    to emit an assembly file, but not assemble or link it. Running <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-S
    /path/to/program.c</samp> should write an assembly file to */path/to/program.s*.
    (I suggested adding this option to help with debugging back in [Chapter 1](chapter1.xhtml);
    you’ll need to add it now if you haven’t already.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> 指示编译器生成汇编文件，但不进行汇编或链接。运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-S /path/to/program.c</samp> 应该会将汇编文件写入
    */path/to/program.s*。（我建议在[第1章](chapter1.xhtml)中添加此选项，以帮助调试；如果你还没有添加，现在需要加上它。）
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--fold-constants</samp> Enables
    constant folding.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--fold-constants</samp> 启用常量折叠。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--propagate-copies</samp> Enables
    copy propagation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--propagate-copies</samp> 启用复制传播。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-unreachable-code</samp> Enables
    unreachable code elimination.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-unreachable-code</samp> 启用不可达代码消除。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-dead-stores</samp> Enables
    dead store elimination.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-dead-stores</samp> 启用死存储消除。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--optimize</samp> Enables all four
    optimizations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--optimize</samp> 启用所有四项优化。
- en: The options to enable optimizations should be passed to the optimization stage,
    which we’ll implement next. It should be possible to enable more than one individual
    optimization; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--fold-constants
    --propagate-copies</samp> should enable both constant folding and copy propagation,
    but not the other two optimizations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 启用优化的选项应传递给优化阶段，我们将在接下来实现它。应该能够启用多个单独的优化；例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--fold-constants
    --propagate-copies</samp> 应同时启用常量折叠和复制传播，但不启用其他两个优化。
- en: If your compiler doesn’t generate assembly exactly the way I’ve laid out in
    this book, the test script should still be able to validate your assembly output
    for this chapter’s tests, but there are a couple of caveats to keep in mind. First,
    the test script understands only AT&T assembly syntax, which is the syntax we’ve
    been using throughout the book. Second, the script doesn’t recognize every single
    assembly instruction; it only knows about the instructions we’ve used in this
    book and a handful of others that are particularly common in real-world assembly
    code. If you emit instructions that the test script doesn’t understand, some tests
    may fail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器生成的汇编与我在本书中所描述的完全不同，测试脚本仍然应该能够验证你在本章测试中的汇编输出，但有几个注意事项需要记住。首先，测试脚本只理解AT&T汇编语法，这也是我们在本书中使用的语法。其次，脚本并不识别每一条汇编指令；它只知道我们在本书中使用的指令以及一些在现实汇编代码中特别常见的其他指令。如果你发出的指令是测试脚本无法识别的，某些测试可能会失败。
- en: Next, we’ll wire up the new optimization stage, which will control when we call
    each individual optimization.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将接入新的优化阶段，控制何时调用每个单独的优化。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wiring Up the Optimization Stage</samp>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">优化阶段的接线</samp>
- en: The optimization stage will run right after we convert the program to TACKY.
    This stage will optimize each TACKY function independently, without any knowledge
    of the other functions defined in the program. For example, it won’t try to evaluate
    function calls during the constant folding pass or remove them during dead store
    elimination. (We can’t remove function calls during dead store elimination because
    we don’t know whether they have side effects. We *can* remove them during unreachable
    code elimination, though—if a function call will never execute, it doesn’t matter
    what side effects the function has.) Optimizations like these, which transform
    one function at a time, are called *intraprocedural optimizations*. Most production
    compilers also perform *interprocedural optimizations*, which transform whole
    translation units instead of individual functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 优化阶段将在我们将程序转换为TACKY后立即运行。此阶段将独立地优化每个TACKY函数，而不考虑程序中定义的其他函数。例如，它不会在常量折叠阶段尝试评估函数调用，也不会在死存储消除阶段删除它们。（我们不能在死存储消除阶段删除函数调用，因为我们不知道它们是否有副作用。*但是*我们可以在不可达代码消除阶段删除它们——如果一个函数调用永远不会执行，那么它的副作用就无关紧要。）像这些一次只转换一个函数的优化被称为*过程内优化*。大多数生产级编译器还会执行*过程间优化*，即转换整个翻译单元，而不是单个函数。
- en: Each individual optimization will take the body of a TACKY function as input
    and return a semantically equivalent function body as output. In the constant
    folding pass, we’ll represent the function body as a list of TACKY instructions,
    like we normally do. But in the other three optimization passes, we’ll represent
    each function as a *control-flow graph*. This is an intermediate representation
    that explicitly models the different execution paths through a piece of code.
    We’ll talk more about how to construct control-flow graphs and why they’re useful
    later in the chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的优化将以TACKY函数的函数体作为输入，返回一个语义等效的函数体作为输出。在常量折叠阶段，我们将像往常一样将函数体表示为一系列TACKY指令。但在其他三个优化阶段，我们将每个函数表示为*控制流图*。这是一个中间表示，显式地建模了代码段中不同的执行路径。我们将在本章后面详细讨论如何构建控制流图以及它们为什么有用。
- en: The optimization stage will process each function by running through all of
    the enabled optimizations over and over. It will stop once it reaches a *fixed
    point*, where running them again doesn’t change the function further. [Listing
    19-6](chapter19.xhtml#list19-6) illustrates this optimization pipeline.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 优化阶段将通过反复运行所有启用的优化来处理每个函数。它将在达到*固定点*时停止，此时再次运行优化将不会进一步改变函数。[列表19-6](chapter19.xhtml#list19-6)展示了这个优化管道。
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-6: The TACKY optimization
    pipeline</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表19-6：TACKY优化管道</samp>
- en: In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp>
    is the list of instructions in the body of a TACKY function and <samp class="SANS_TheSansMonoCd_W5Regular_11">enabled_optimizations</samp>
    is a list of strings representing the optimizations that we enabled on the command
    line. (This would be a pretty kludgy way to store command line options in a real
    program; feel free to represent these options differently in your own code.) If
    <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp> is empty, we’ll
    just return it, since there’s nothing to optimize. Otherwise, we’ll perform constant
    folding if it’s enabled ❶.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，<samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp>是TACKY函数体中指令的列表，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">enabled_optimizations</samp>是表示命令行中启用的优化的字符串列表。（在实际程序中，这将是存储命令行选项的一种相当笨重的方式；可以在你自己的代码中采用不同的方式表示这些选项。）如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp>为空，我们将直接返回它，因为没有内容可以优化。否则，如果启用了常量折叠，我们将执行常量折叠❶。
- en: Next, we’ll convert the function body from a list of instructions into a control-flow
    graph ❷. We’ll apply all the other enabled optimizations to this representation.
    Then, we’ll convert the optimized control-flow graph back to a list of instructions
    ❸, which we’ll compare to the original list ❹. If it’s different, and if we haven’t
    optimized away the entire function, we’ll go through the loop again to take advantage
    of any new optimization opportunities. If it’s the same, we can’t optimize it
    any further, so we’re done.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把函数体从指令列表转换为控制流图❷。我们将对该表示应用所有启用的优化。然后，我们将优化后的控制流图转换回指令列表❸，并与原始列表❹进行比较。如果它不同，并且我们没有优化掉整个函数，我们将重新进行循环，以利用任何新的优化机会。如果它相同，我们就不能再进一步优化了，优化过程结束。
- en: Using the optimization pipeline in [Listing 19-6](chapter19.xhtml#list19-6),
    we’ll never miss an optimization opportunity. Whenever one optimization changes
    the program, we’ll rerun the other three to take advantage of those changes. This
    is feasible because we’re implementing only four optimizations, and all of our
    test programs are small enough to optimize pretty quickly. Production compilers,
    which implement dozens of optimizations and compile much larger programs, don’t
    take this approach; if they did, compilation would take way too long. Instead,
    they apply a fixed sequence of optimizations just once, running each individual
    optimization in the place where it’s likely to have the biggest impact. As a result,
    they can end up missing optimization opportunities. (Finding the best order to
    run optimizations for any given program is an open research question called the
    *phase ordering problem*.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[清单19-6](chapter19.xhtml#list19-6)中的优化管道，我们就不会错过任何优化机会。每当一个优化改变了程序时，我们会重新运行其他三个优化，以利用这些变化。这是可行的，因为我们只实现了四个优化，而且我们所有的测试程序都足够小，能够快速优化。生产编译器实现了几十种优化，并编译了更大的程序，因此不会采用这种方法；如果采用，编译时间会非常长。相反，它们只会应用一次固定顺序的优化，按照可能产生最大影响的顺序运行每个优化。因此，它们可能会错过优化机会。（为任何给定的程序找到最佳优化执行顺序是一个开放的研究问题，称为*阶段排序问题*。）
- en: Go ahead and add the optimization pipeline to your compiler. For now, define
    each individual optimization as a stub that takes a list of instructions and returns
    them unchanged. You can stub out the conversions to and from control-flow graphs
    the same way. Write this plumbing code now so that you can test the individual
    optimization passes as you implement them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 继续将优化管道添加到你的编译器中。现在，先将每个优化定义为一个存根，它接受一个指令列表并返回不变的指令。你也可以以相同的方式为控制流图的转换添加存根。现在编写这些支撑代码，以便在实现各个优化时能够测试它们。
- en: 'Once everything is wired up, you can start on your first optimization: constant
    folding!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有内容都设置好，你就可以开始进行第一个优化：常量折叠！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Constant Folding</samp>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">常量折叠</samp>
- en: Constant folding is the simplest optimization in this chapter. This pass iterates
    through all the instructions in a TACKY function and evaluates any instructions
    with constant source operands. First, we’ll talk briefly about how to add constant
    folding to the version of the compiler you implemented in [Part I](part1.xhtml).
    Then, we’ll discuss how to handle the types and TACKY instructions you added in
    [Part II](part2.xhtml). If you haven’t worked through [Part II](part2.xhtml) yet,
    feel free to skip the latter discussion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 常量折叠是本章中最简单的优化。此优化遍历TACKY函数中的所有指令，并评估任何具有常量源操作数的指令。首先，我们将简要讨论如何将常量折叠添加到你在[第一部分](part1.xhtml)中实现的编译器版本。然后，我们将讨论如何处理你在[第二部分](part2.xhtml)中添加的类型和TACKY指令。如果你还没有完成[第二部分](part2.xhtml)，可以跳过后面的讨论。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding
    for Part I TACKY Programs</samp>
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">第一部分TACKY程序的常量折叠</samp>
- en: 'The constant folding pass should evaluate four of the TACKY instructions from
    [Part I](part1.xhtml): <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>. When you
    find a <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instruction
    with a constant source operand, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    instruction with two constant source operands, replace it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
    For example, you should replace'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 常量折叠过程应评估来自 [第一部分](part1.xhtml) 的四条TACKY指令：<samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>。当你发现一个源操作数为常量的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> 指令，或者一个源操作数为常量的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> 指令时，将其替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>。例如，你应该替换
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'with:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your constant folding pass could run into two kinds of invalid expressions:
    division by zero and operations that result in integer overflow. These are both
    undefined behaviors, so it doesn’t matter how you evaluate them. However, your
    compiler can’t just fail if it encounters one of these invalid expressions, because
    the program’s behavior is undefined only if it actually reaches the invalid expression
    at runtime. For example, if a program includes division by zero in a branch that’s
    never taken, you should still be able to compile it.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你的常量折叠（constant folding）过程可能会遇到两种无效的表达式：除以零和导致整数溢出的操作。这些都是未定义的行为，因此无论你如何评估它们，结果都一样。然而，你的编译器不能在遇到这些无效表达式时直接失败，因为只有在程序运行时实际到达这些无效表达式时，程序的行为才是未定义的。例如，如果程序在一个从未被执行的分支中包含除以零的操作，你仍然应该能够编译它。
- en: You should also evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> instructions
    with constant conditions. If the condition is met, replace the instruction with
    an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>. If
    the condition isn’t met, remove the instruction from the program. That’s all there
    is to it! If you completed only [Part I](part1.xhtml), you can skip to the test
    suite once you’ve implemented constant folding for these four instructions. If
    you completed [Part II](part2.xhtml), there are a few more instructions you’ll
    need to handle.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该评估常量条件下的 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> 指令。如果条件满足，将指令替换为无条件的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>。如果条件不满足，则从程序中移除该指令。就这么简单！如果你只完成了
    [第一部分](part1.xhtml)，在实现了这四条指令的常量折叠后，你可以跳过测试套件。如果你完成了 [第二部分](part2.xhtml)，还有一些其他指令需要处理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">支持第二部分TACKY程序</samp>
- en: 'When we added the new arithmetic types in [Part II](part2.xhtml), we also added
    type conversion instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>.
    The constant folding pass should evaluate all of these instructions when their
    source operands are constants.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [第二部分](part2.xhtml) 中添加了新的算术类型时，我们也添加了类型转换指令：<samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>。常量折叠过程应在源操作数为常量时评估所有这些指令。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction can
    perform type conversions too; we use it to convert between signed and unsigned
    integers of the same size. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction copies an unsigned constant to a signed variable, or vice versa, this
    pass should convert the constant to the correct type. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, you should
    replace
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>`指令也可以执行类型转换；我们使用它在相同大小的有符号和无符号整数之间进行转换。当一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令将无符号常量复制到有符号变量，或反之时，这一过程应将常量转换为正确的类型。例如，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>，你应该替换'
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'with:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'with:'
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Be careful to perform every type conversion with exactly the same semantics
    that the program would use at runtime. For example, when you convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an integer type, truncate its value toward zero; when you convert an integer
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, round to the
    nearest representable value. The good news is that you already know how to perform
    all of these type conversions at compile time, since you had to convert static
    initializers to the correct type throughout [Part II](part2.xhtml). Ideally, you’ll
    be able to reuse the code you’ve already written to perform these type conversions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 小心进行每一个类型转换，确保与程序运行时使用的语义完全一致。例如，当你将<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>转换为整数类型时，应将其值截断为零；当你将整数转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>时，应舍入到最近的可表示值。好消息是，你已经知道如何在编译时执行所有这些类型转换，因为在[第二部分](part2.xhtml)中，你必须将静态初始化值转换为正确的类型。理想情况下，你应该能够重用你已经编写的代码来执行这些类型转换。
- en: You’ll also need to adhere to C semantics when you evaluate unsigned arithmetic
    operations. In particular, you should ensure that unsigned arithmetic wraps around,
    like it would at runtime. How you accomplish this will depend entirely on what
    language you’re writing your compiler in. Some languages support wraparound unsigned
    arithmetic as part of their standard library. In Rust, for example, methods like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_sub</samp>
    provide the same semantics as unsigned arithmetic in C. In other languages, you
    might use a third-party library for unsigned arithmetic. For example, Python doesn’t
    provide unsigned integer types, but the NumPy library does. If you don’t want
    to use an external library, or you can’t find a suitable one, it isn’t terribly
    difficult to implement wraparound unsigned arithmetic yourself.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要遵循C语言语义来评估无符号算术运算。特别是，你应该确保无符号算术运算能正确地回绕，就像运行时一样。如何实现这一点完全取决于你用来编写编译器的语言。例如，Rust提供了像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wrapping_add</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_sub</samp>的方法，它们提供与C语言中的无符号算术相同的语义。在其他语言中，你可能需要使用第三方库来实现无符号算术。例如，Python不提供无符号整数类型，但NumPy库提供了。如果你不想使用外部库，或者找不到合适的库，其实自己实现回绕无符号算术也并不困难。
- en: 'Finally, when you evaluate floating-point operations, you’ll need to use round-to-nearest,
    ties-to-even rounding and handle negative zero and infinity correctly. If you
    added support for NaN for extra credit in [Chapter 13](chapter13.xhtml), you’ll
    need to evaluate operations on NaN correctly too. This shouldn’t require any special
    effort on your part—the vast majority of programming languages use IEEE 754 semantics—but
    there’s a small chance that your implementation language handles negative zero,
    NaN, or infinity differently than C. Start with a simple implementation of constant
    folding that doesn’t try to address these edge cases; you can rely on the test
    suite to catch any problems. If you run into any cases that your implementation
    language doesn’t evaluate correctly, you have two options: either find a third-party
    library to handle them for you or evaluate them yourself as a special case.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在评估浮点操作时，您需要使用四舍五入到最接近的值、偶数舍入规则，并正确处理负零和无穷大。如果您在[第13章](chapter13.xhtml)为NaN添加了额外的支持，您还需要正确评估NaN上的操作。这应该不需要您做任何特别的工作——绝大多数编程语言都使用IEEE
    754语义——但有小概率您的实现语言在处理负零、NaN或无穷大时与C语言不同。从一个简单的常量折叠实现开始，不需要尝试解决这些边缘情况；您可以依赖测试套件来捕获任何问题。如果您遇到您的实现语言无法正确评估的情况，您有两个选择：要么找到一个第三方库来处理它们，要么将它们作为特殊情况自己处理。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Control-Flow Graphs</samp>
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">控制流图</samp>
- en: For the rest of the chapter, we’ll represent TACKY functions as control-flow
    graphs. A graph representation is a good fit for our remaining optimizations,
    which have to account for the different paths we might take through a function.
    The nodes in the control-flow graph represent sequences of straight-line code
    called *basic blocks*, except for two special nodes that represent the function’s
    entry and exit points. Each node has outgoing edges to the nodes that could execute
    immediately after it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用控制流图表示TACKY函数。图形表示非常适合我们剩下的优化，它们必须考虑我们在函数中可能经过的不同路径。控制流图中的节点表示称为*基本块*的直线代码序列，除了两个特殊节点，分别表示函数的入口和出口。每个节点都有指向可以立即执行的下一个节点的边。
- en: As an example, let’s look at the control-flow graph for [Listing 19-7](chapter19.xhtml#list19-7).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们来看一下[清单19-7](chapter19.xhtml#list19-7)的控制流图。
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-7: A TACKY function
    with multiple execution paths</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-7：具有多个执行路径的TACKY函数</samp>
- en: This function executes a loop that repeatedly retrieves a value by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp>, then processes that
    value by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp> ever returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this function immediately
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>
    ever returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the function
    immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. [Figure
    19-1](#fig19-1) shows the corresponding control-flow graph.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数执行一个循环，通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp>反复获取一个值，然后通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>处理该值。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp>返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，该函数立即返回<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>。如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>返回<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，该函数立即返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。[图19-1](#fig19-1)展示了对应的控制流图。
- en: '![](../images/fig19-1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-1: The control-flow
    graph for [Listing 19-7](chapter19.xhtml#list19-7) [Description](description-52.xhtml)</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-1：[清单 19-7](chapter19.xhtml#list19-7)的控制流图
    [描述](description-52.xhtml)</samp>
- en: 'There’s a single outgoing edge from the special <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    node to block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>,
    since we’ll always execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> at the start of the function.
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> will have exactly
    one outgoing edge in every control-flow graph, since C functions have only one
    entry point.) After we execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, there are two possibilities:
    we can execute the next block in the program, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, or we can jump to block
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    has outgoing edges to both of those blocks. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> has outgoing edges to both
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction exits
    the function, so <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>
    each have a single outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从特殊的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> 节点到块 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> 有一条单一的出边，因为我们总是在函数开始时执行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>。（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> 在每个控制流图中都会有一条出边，因为 C 函数只有一个入口点。）在执行完
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    后，有两种可能性：我们可以执行程序中的下一个块 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>，或者我们可以跳转到块 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> 有指向这两个块的出边。按照同样的逻辑，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    有指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>
    的出边。一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令退出函数，因此 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>
    各自有一条出边指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Control-Flow
    Graph</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">定义控制流图</samp>
- en: Now that you know what a control-flow graph looks like, let’s look at how to
    construct one. First, we’ll define the graph data structure. [Listing 19-8](chapter19.xhtml#list19-8)
    sketches out one possible representation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道控制流图是什么样子了，我们来看看如何构建一个。首先，我们将定义图的结构。[清单 19-8](chapter19.xhtml#list19-8)概述了其中一种可能的表示方法。
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-8: One way to represent
    the control-flow graph</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-8：表示控制流图的一种方式</samp>
- en: Every node in the graph has a unique <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>,
    which identifies it as <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, or a numbered basic
    block. We’ll assign numeric IDs to basic blocks according to their order in the
    original TACKY function. Each basic block holds a list of TACKY instructions,
    a list of *successors* (the blocks that could execute right after it), and another
    list of *predecessors* (the blocks that could execute right before it). The entry
    and exit nodes don’t hold any instructions. <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    as the very first point in the function, has successors but no predecessors. <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, on the other hand, has predecessors
    but no successors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每个节点都有一个唯一的 <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>，用于标识该节点是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>，还是一个编号的基本块。我们将根据它们在原始
    TACKY 函数中的顺序为基本块分配数字 ID。每个基本块包含一个 TACKY 指令列表，一个 *后继* 列表（表示可以在其之后执行的块），以及另一个 *前驱*
    列表（表示可以在其之前执行的块）。入口节点和出口节点不包含任何指令。<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    作为函数的第一个节点，拥有后继但没有前驱。<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>
    则相反，拥有前驱但没有后继。
- en: You’ll need a way to associate both basic blocks and individual instructions
    with extra information so that you can track the results of data-flow analysis
    in the copy propagation and dead store elimination passes. The definition in [Listing
    19-8](chapter19.xhtml#list19-8) doesn’t include a way to track this information.
    You could either attach it directly to the graph or store it in a separate data
    structure. The pseudocode throughout this chapter will use <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate
    _instruction</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_instruction_annotation</samp>
    to save and look up information about individual instructions. It will use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">annotate_block</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block
    _annotation</samp> to save and look up information about basic blocks by block
    ID.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一种方法将基本块和单独的指令与额外信息关联，以便在拷贝传播和死存储消除的过程中跟踪数据流分析的结果。[清单 19-8](chapter19.xhtml#list19-8)中的定义并没有提供跟踪这些信息的方法。你可以将它直接附加到图中，或者存储在一个单独的数据结构中。本章中的伪代码将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate _instruction</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_instruction_annotation</samp> 来保存和查找有关单个指令的信息。它将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate_block</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block
    _annotation</samp> 来保存和查找通过块 ID 获取的基本块信息。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*Your graph data structure might look quite different from [Listing 19-8](chapter19.xhtml#list19-8).
    For instance, you might want to represent the graph as a map from node_id to node,
    instead of a list of nodes, or track the entry and exit nodes separately from
    the nodes that represent basic blocks. You can define your control-flow graph
    in whatever way makes sense to you and suits your implementation language, as
    long as it includes all the information you’ll need.*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的图数据结构可能与 [清单 19-8](chapter19.xhtml#list19-8) 中的结构非常不同。例如，你可能希望将图表示为从 node_id
    到节点的映射，而不是节点的列表，或者将入口和出口节点与表示基本块的节点分开跟踪。你可以按照适合你实现语言的方式定义控制流图，只要它包含你所需的所有信息。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Basic Blocks</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建基本块</samp>
- en: Next, let’s see how to partition the body of a TACKY function into basic blocks.
    You can’t have any jumps into or out of the middle of a basic block. The only
    way to execute a basic block is to start at its first instruction and continue
    all the way to the end. This implies that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    can appear only as the first instruction in a block, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    or jump instruction can appear only as the last instruction. [Listing 19-9](chapter19.xhtml#list19-9)
    demonstrates how to split a list of instructions into basic blocks along these
    boundaries.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将TACKY函数的主体划分为基本块。基本块的中间不能有跳转进出。执行基本块的唯一方法是从其第一条指令开始，一直到结束。这意味着<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>只能作为块中的第一条指令出现，而<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>或跳转指令只能作为最后一条指令出现。[清单
    19-9](chapter19.xhtml#list19-9)演示了如何在这些边界上将指令列表拆分为基本块。
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-9: Partitioning
    a list of instructions into basic blocks</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-9：将指令列表划分为基本块</samp>
- en: When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction, we start a new basic block beginning with that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    ❶. When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction or a conditional or unconditional jump, we add it to the current block,
    then start a new empty block ❷. When we encounter any other instruction, we add
    it to the current block without starting a new block ❸.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>指令时，我们会从该<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> ❶开始一个新的基本块。当我们遇到一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令或条件跳转或无条件跳转时，我们将其添加到当前块，然后开始一个新的空块
    ❷。当我们遇到任何其他指令时，我们将其添加到当前块中，而不开始一个新的块 ❸。
- en: '[Listing 19-9](chapter19.xhtml#list19-9) just partitions a function body into
    a list of lists of instructions. The next step (which I won’t provide pseudocode
    for) is to convert these lists of instructions into <samp class="SANS_TheSansMonoCd_W5Regular_11">BasicBlock</samp>
    nodes with increasing block IDs. We’ll then add these nodes to the graph, along
    with the entry and exit nodes.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 19-9](chapter19.xhtml#list19-9)只是将函数体划分为指令的列表。接下来的步骤（我不会提供伪代码）是将这些指令列表转换为具有递增块
    ID 的<samp class="SANS_TheSansMonoCd_W5Regular_11">BasicBlock</samp>节点。然后我们将这些节点添加到图中，并添加入口节点和出口节点。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Edges to the
    Control-Flow Graph</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">向控制流图添加边</samp>
- en: After adding every node to the graph, we’ll add edges from each node to its
    successors, as [Listing 19-10](chapter19.xhtml#list19-10) demonstrates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在将每个节点添加到图中之后，我们将从每个节点添加到其后继节点的边，如[清单 19-10](chapter19.xhtml#list19-10)所示。
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-10: Adding edges
    to the control-flow graph</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-10：向控制流图添加边</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_all_edges</samp> ❶ is our unfinished
    control-flow graph, which has nodes but no edges. We’ll begin by adding an edge
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> to the first basic
    block ❷. (We can assume that the function contains at least one basic block, since
    we don’t optimize empty functions.) Throughout this listing, we’ll use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp> function, which takes
    two node IDs, to add edges to the graph. Keep in mind that whenever we add an
    edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>, we must update both the
    successors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> and the
    predecessors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>. I’ve
    omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp>,
    since it will depend on how you’ve defined your control-flow graph.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp>` 参数传递给 `<samp class="SANS_TheSansMonoCd_W5Regular_11">add_all_edges</samp>`
    ❶ 是我们未完成的控制流图，它有节点但没有边。我们将首先添加一条从 `<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>`
    到第一个基本块 ❷ 的边。（我们可以假设该函数至少包含一个基本块，因为我们不会优化空函数。）在整个示例中，我们将使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp>`
    函数，它接受两个节点 ID，用来向图中添加边。请记住，每次我们从 `<samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp>`
    添加一条边到 `<samp class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>` 时，我们必须更新 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">node1</samp>` 的所有后继节点以及 `<samp class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>`
    的所有前驱节点。我已省略了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp>`
    的伪代码，因为它将取决于你如何定义控制流图。'
- en: Next, we’ll add outgoing edges from the nodes that correspond to basic blocks.
    To process one of these nodes, we’ll first determine which other node will follow
    it by default if we don’t jump or return at the end of the block. If we’re processing
    the very last block, the next node will be <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
    Otherwise, it will just be whatever basic block comes next in the original TACKY
    function ❸.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为与基本块对应的节点添加外向边。为了处理其中一个节点，我们首先要确定如果在块的末尾不进行跳转或返回，默认情况下将跟随它的下一个节点。如果我们处理的是最后一个块，下一节点将是
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>`。否则，下一节点将是原始 TACKY
    函数中紧接着的基本块 ❸。
- en: We’ll figure out what edges to add by inspecting the last instruction in the
    current basic block. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, we’ll add one outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
    If it’s an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    we’ll add an edge to the block that begins with the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>.
    We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block_by_label</samp>
    helper function, which I won’t show the pseudocode for, to look up which block
    begins with a particular label. I recommend building a map from labels to block
    IDs ahead of time so that this function can just perform a map lookup.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查当前基本块中的最后一条指令来确定需要添加哪些边。如果它是 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>`
    指令，我们将添加一条指向 `<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>` 的外向边。如果它是无条件的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>` 指令，我们将添加一条指向以对应 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>` 开头的块的边。我们使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">get_block_by_label</samp>`
    辅助函数（我不会展示其伪代码），通过标签查找以特定标签开头的块。我建议提前构建一个从标签到块 ID 的映射，以便这个函数可以直接执行映射查找。
- en: If a block ends with a conditional jump, we’ll add two outgoing edges. The first
    edge, which represents taking the jump, will go to the block that starts with
    the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> ❹.
    The other edge, which represents not taking the jump ❺, will go to the default
    next node, identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">next_id</samp>.
    If a block ends with any other instruction, we’ll add a single outgoing edge to
    the default next node.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个块以条件跳转结束，我们将添加两条外向边。第一条边，表示进行跳转，将指向以对应 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>`
    ❹ 开头的块。另一条边，表示不进行跳转 ❺，将指向默认的下一个节点，由 `<samp class="SANS_TheSansMonoCd_W5Regular_11">next_id</samp>`
    标识。如果一个块以其他指令结束，我们将添加一条指向默认下一个节点的外向边。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting a Control-Flow
    Graph to a List of Instructions</samp>
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将控制流图转换为指令列表</samp>
- en: 'At this point, you should have working code to convert a TACKY function into
    a control-flow graph. You’ll also need code to go in the other direction and convert
    a control-flow graph back to a list of instructions. This operation is much simpler:
    just sort all the basic blocks by ID, then concatenate all their instructions.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该已经有了能够将 TACKY 函数转换为控制流图的工作代码。你还需要一段代码来进行反向操作，将控制流图转换回指令列表。这一操作要简单得多：只需要按
    ID 排序所有基本块，然后将它们的指令连接起来。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Your Control-Flow
    Graph Code Reusable</samp>
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使你的控制流图代码可重用</samp>
- en: In the next chapter, we’ll build control-flow graphs of assembly programs. We’ll
    use the same algorithm to construct these graphs, but we’ll look for different
    individual control-flow instructions. For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, and conditional jump
    instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> all signal the end of
    a basic block in assembly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将构建汇编程序的控制流图。我们将使用相同的算法来构建这些图，但我们会寻找不同的单独控制流指令。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>，以及像 <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> 这样的条件跳转指令，都会标志着汇编中基本块的结束。
- en: Once you have working code to construct control-flow graphs, you might want
    to refactor it so you can use it for assembly programs too. This is completely
    optional, but it will save you some effort in the next chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了构建控制流图的工作代码，你可能想重构它，以便也能用于汇编程序。这是完全可选的，但它会在下一章节省你一些精力。
- en: 'First, you’ll need to generalize the <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp>
    data type so that a block can contain either TACKY or assembly instructions. Next,
    you’ll need to generalize the logic to analyze specific instructions in [Listings
    19-9](chapter19.xhtml#list19-9) and [19-10](chapter19.xhtml#list19-10). For instance,
    you could define a one-off data type to represent both assembly and TACKY instructions,
    which captures just the information you need to build the control-flow graph:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp> 数据类型进行泛化，以便一个块可以包含
    TACKY 或汇编指令。接着，你需要泛化逻辑来分析 [清单 19-9](chapter19.xhtml#list19-9) 和 [19-10](chapter19.xhtml#list19-10)
    中的具体指令。例如，你可以定义一个一次性的数据类型，来表示汇编和 TACKY 指令，这样就能捕获构建控制流图所需的信息：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Instead of inspecting individual TACKY instructions to determine where a basic
    block ends or what its successors are, you can convert each instruction to a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> and inspect
    that. Then, when you need to build control-flow graphs for assembly programs,
    you’ll use a different helper function to convert an assembly instruction to a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> but leave
    everything else the same.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要检查单独的 TACKY 指令来确定基本块的结束位置或它的后继，你可以将每个指令转换为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp>
    并检查它。然后，当你需要为汇编程序构建控制流图时，你将使用不同的辅助函数将汇编指令转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp>，但其他部分保持不变。
- en: 'That wraps up our discussion of control-flow graphs. We’re now ready to move
    on to our second optimization pass: unreachable code elimination.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对控制流图的讨论。现在我们准备继续进行第二个优化步骤：不可达代码消除。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unreachable Code Elimination</samp>
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">不可达代码消除</samp>
- en: We’ll split up this pass into three steps, first removing basic blocks that
    will never execute, then useless jumps, and finally useless labels. The last two
    steps might leave us with empty blocks that don’t contain any instructions. Optionally,
    we can clean up after this optimization by removing these empty blocks from the
    control-flow graph.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个步骤分为三步，首先移除永远不会执行的基本块，然后是无用的跳转，最后是无用的标签。最后两个步骤可能会留下不包含任何指令的空块。可选地，我们可以通过从控制流图中移除这些空块来清理优化后的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Eliminating Unreachable
    Blocks</samp>
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">消除不可达块</samp>
- en: 'To find every block that might possibly execute, we’ll traverse the control-flow
    graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    We’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>’s successor,
    then all of that node’s successors, and so on, until we run out of nodes to explore.
    If this traversal never reaches a particular basic block, we’ll know that block
    is safe to remove. Let’s try out this approach on the example from [Listing 19-4](chapter19.xhtml#list19-4),
    which we looked at when we first introduced unreachable code elimination:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到每一个可能执行的块，我们将从<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>开始遍历控制流图。我们将访问<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>的后继节点，然后访问该节点的所有后继节点，依此类推，直到没有更多的节点可以探索。如果这个遍历永远没有到达某个基本块，那么我们就知道该块可以安全地移除。我们来试试这种方法，基于[清单
    19-4](chapter19.xhtml#list19-4)中的示例，正如我们第一次介绍无法到达的代码消除时所看的那样：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We determined earlier that <samp class="SANS_TheSansMonoCd_W5Regular_11">x =
    my_function()</samp> is unreachable. Assuming this listing is the entire body
    of a TACKY function, it will have the control-flow graph shown in [Figure 19-2](#fig19-2).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前确定了<samp class="SANS_TheSansMonoCd_W5Regular_11">x = my_function()</samp>是无法到达的。假设这个清单是一个TACKY函数的完整函数体，它将具有[图
    19-2](#fig19-2)所示的控制流图。
- en: '![](../images/fig19-2.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-2: The control-flow
    graph for [Listing 19-4](chapter19.xhtml#list19-4) [Description](description-53.xhtml)</samp>'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-2：控制流图，[清单 19-4](chapter19.xhtml#list19-4)
    [描述](description-53.xhtml)</samp>
- en: Note that there’s no path from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>.
    If we traverse this graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    we’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Along the way,
    we’ll keep track of which nodes we’ve visited so far. Once we’re done, we’ll see
    that we never visited <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, so we’ll remove it. I won’t
    provide the pseudocode for exploring the graph, since it’s just an ordinary breadth-
    or depth-first graph traversal.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>之间没有路径。如果我们从<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>开始遍历这个图，我们将访问<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>。在此过程中，我们将跟踪已经访问的节点。一旦完成，我们会发现我们从未访问过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>，因此我们将其移除。我不会提供用于遍历图的伪代码，因为这只是普通的广度优先或深度优先图遍历。
- en: When you remove a node from the graph, remember to remove its outgoing edges
    too. For example, when we remove <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> from the graph in [Figure
    19-2](#fig19-2), we should also remove it from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>’s list of predecessors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从图中移除一个节点时，记得也要移除它的输出边。例如，当我们在[图 19-2](#fig19-2)中移除<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>时，我们还应该将其从<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>的前驱列表中移除。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless
    Jumps</samp>
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">移除无用的跳转</samp>
- en: Next, we’ll remove any useless jump instructions. Remember that by default,
    if a block doesn’t end with a jump or <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, control falls through to the next block from the original program
    order. We can delete a jump instruction if it targets this default next block.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将移除所有无用的跳转指令。请记住，默认情况下，如果一个块没有以跳转或<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令结尾，控制流将按照原始程序顺序流向下一个块。如果跳转指令指向这个默认的下一个块，我们可以删除它。
- en: We’ll look at each basic block that ends with a conditional or unconditional
    jump and figure out which block would follow it by default if the jump weren’t
    taken. If this default next block is its only successor, the jump instruction
    is redundant. [Listing 19-11](chapter19.xhtml#list19-11) demonstrates this approach.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看每个以条件或无条件跳转结尾的基本块，并弄清楚如果没有执行跳转，默认情况下会跟随哪个块。如果这个默认的下一个块是它唯一的后继块，那么跳转指令就是冗余的。[Listing
    19-11](chapter19.xhtml#list19-11) 演示了这种方法。
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-11: Removing redundant
    jumps</samp>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-11: 删除冗余跳转</samp>'
- en: First, we’ll sort the basic blocks by their position in the original TACKY function
    ❶; this is one reason we numbered the blocks when we first constructed the graph.
    Next, we’ll iterate over this sorted list of basic blocks (except the last one,
    since a jump at the very end of the function is never redundant) ❷. If a block
    ends with a jump, we’ll search for a successor other than the next block in the
    list. If we find one, we’ll keep the jump instruction. Otherwise, we’ll remove
    it ❸.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将按原始 TACKY 函数中的位置对基本块进行排序❶；这也是我们在构建图时为基本块编号的原因之一。接下来，我们将遍历这个排序后的基本块列表（最后一个除外，因为函数结尾的跳转永远不会是冗余的）❷。如果某个块以跳转结尾，我们将寻找一个除了列表中下一个块之外的后继块。如果找到了，我们就保留跳转指令；否则，我们就删除它❸。
- en: Note that the next block in the list won’t necessarily have the next consecutive
    numerical ID, since we may have deleted blocks earlier. Block 2, for example,
    might be followed by block 4\. That’s why we can’t just increment a block’s ID
    number to find its default successor.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表中的下一个块不一定会有下一个连续的数字 ID，因为我们可能已经删除了前面的块。例如，块 2 可能会被块 4 跟随。这就是为什么我们不能仅通过递增块的
    ID 来找到它的默认后继块。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless
    Labels</samp>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">删除无用标签</samp>
- en: Removing useless labels is similar to removing useless jumps. After sorting
    basic blocks by numeric ID, we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction at the start of a block if we’ll enter it only by falling through
    from the previous block, rather than jumping to it explicitly. More concretely,
    we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> at
    the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>
    if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i
    - 1]</samp>. We can also delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[0]</samp>
    if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    This transformation is safe because we just deleted redundant jump instructions;
    we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i - 1]</samp>
    won’t end with an explicit jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>.
    I won’t provide pseudocode for this step, since it would look basically the same
    as [Listing 19-11](chapter19.xhtml#list19-11).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 删除无用标签类似于删除无用跳转。在按数字 ID 对基本块进行排序后，如果某个基本块仅通过从前一个块的顺序流进入，而不是显式跳转到它，我们可以删除该块开头的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> 指令。更具体地说，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>
    只有一个前驱块 <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i - 1]</samp>，我们就可以删除其开头的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[0]</samp>
    的唯一前驱是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>，我们也可以删除它开头的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>。这个转换是安全的，因为我们只是删除了冗余的跳转指令；我们知道
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i - 1]</samp> 不会以显式跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp> 结尾。我不会为此步骤提供伪代码，因为它基本上与
    [Listing 19-11](chapter19.xhtml#list19-11) 中的内容相同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Empty Blocks</samp>
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">删除空块</samp>
- en: Eliminating unreachable jumps and labels might result in blocks with no instructions.
    If you want, you can remove them; this will shrink the graph and might speed up
    later optimization passes a bit. When you remove a block, make sure to update
    the edges in the control-flow graph accordingly. For example, if the graph has
    edges from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and you delete <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    you’ll need to add an edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 消除不可达的跳转和标签可能会导致某些代码块没有指令。如果你愿意，可以删除它们；这将缩小图形并可能稍微加速后续的优化过程。当你删除一个块时，确保相应地更新控制流图中的边。例如，如果图中有从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>的边，以及从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>的边，而你删除了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>，你将需要添加一条从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>的边。
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Little Bit About Data-Flow Analysis</samp>
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">关于数据流分析的一些基本介绍</samp>
- en: This section will give a quick overview of data-flow analysis, which we’ll rely
    on in the next two optimization passes. You’ll learn what it is, when it’s useful,
    and what features all data-flow analyses have in common. This isn’t intended to
    be a complete explanation of data-flow analysis; my goal here is just to introduce
    a few key ideas and describe how they fit together, to make the specific analyses
    in later sections easier to follow.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要概述数据流分析，我们将在接下来的两个优化过程中依赖它。你将了解它是什么，何时有用，以及所有数据流分析共有的特征。这不是数据流分析的完整解释；我的目标只是介绍几个关键概念，并描述它们是如何结合在一起的，以便使后续部分中的具体分析更容易理解。
- en: 'Data-flow analysis answers questions about how values are defined and used
    throughout a function. Different data-flow analyses answer different questions.
    In the copy propagation pass, for example, we’ll implement *reaching copies analysis*.
    This answers the question: Given some instruction *i* in a TACKY function, and
    two operands <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">v</samp> that appear in that function,
    can we guarantee that <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> are equal at the point
    just before *i* executes?'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流分析回答有关值在整个函数中如何定义和使用的问题。不同的数据流分析回答不同的问题。例如，在复制传播阶段，我们将实现*到达复制分析*。它回答的问题是：在一个TACKY函数中，给定某个指令*i*，以及在该函数中出现的两个操作数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">u</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>，我们能否保证在*i*执行之前，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">u</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>是相等的？
- en: 'We can divide all data-flow analyses into two broad categories: forward and
    backward analyses. In a *forward analysis*, information travels forward through
    the control-flow graph. Reaching copies analysis is a forward analysis. When we
    see a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>, that tells us that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    might have the same value later in the same basic block or in one of that block’s
    successors. In a *backward analysis*, the reverse is true. In the dead store elimination
    pass, we’ll implement a backward analysis called *liveness analysis*. This analysis
    tells us whether a variable’s current value will ever be used. If we see an instruction
    that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, that tells us
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> may be live earlier
    in the same basic block or in one of that block’s predecessors.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有数据流分析分为两大类：正向分析和反向分析。在*正向分析*中，信息在控制流图中向前传播。达成副本分析是一种正向分析。当我们看到一条 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>` 指令 `<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp>` 时，这意味着 `<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>` 和
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>` 可能在同一基本块中或该块的后继块中具有相同的值。在*反向分析*中，情况则相反。在死存储消除过程中，我们将实现一种反向分析，称为
    *活跃度分析*。这种分析告诉我们一个变量的当前值是否会被使用。如果我们看到一条使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>`
    的指令，这意味着 `<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>` 可能在同一基本块中或该块的前驱块中较早时刻活跃。
- en: Each data-flow analysis has its own transfer function and meet operator. The
    *transfer function* calculates the analysis results within a single basic block.
    This function analyzes how individual instructions impact the results, but it
    doesn’t need to deal with multiple execution paths. The *meet operator* combines
    information from multiple paths to calculate how each basic block is impacted
    by its neighbors. We’ll use an *iterative algorithm* to drive the entire analysis.
    This algorithm calls the transfer function and meet operator on each basic block
    and keeps track of which blocks still need to be analyzed. It’s iterative because
    we may need to visit some blocks multiple times as we propagate information along
    different execution paths. This algorithm will traverse the control-flow graph,
    analyzing each basic block it visits, until it reaches a fixed point where the
    analysis results no longer change. At that point, we’ll know that every possible
    execution path is accounted for. The iterative algorithm isn’t the only way to
    solve data-flow analysis problems, but it’s the only one we’ll discuss in this
    book.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据流分析都有其独特的传输函数和合并操作符。*传输函数* 计算单个基本块内的分析结果。此函数分析各个指令如何影响结果，但不需要处理多条执行路径。*合并操作符*
    将多条路径的信息合并，以计算每个基本块如何受到其邻居的影响。我们将使用*迭代算法*来驱动整个分析。该算法会在每个基本块上调用传输函数和合并操作符，并跟踪哪些块仍然需要分析。它是迭代的，因为我们可能需要多次访问某些块，以便沿不同的执行路径传播信息。该算法将遍历控制流图，分析它访问的每个基本块，直到达到固定点，即分析结果不再变化。到那时，我们就知道所有可能的执行路径都已被考虑。迭代算法并不是解决数据流分析问题的唯一方法，但它是本书中唯一讨论的方法。
- en: While different analyses use different transfer functions and meet operators,
    they all use essentially the same iterative algorithm. Forward and backward analyses
    use different versions of this algorithm because they propagate data in opposite
    directions. We’ll implement both versions in the next two sections.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不同的分析使用不同的传输函数和合并操作符，它们本质上都使用相同的迭代算法。正向分析和反向分析使用该算法的不同版本，因为它们在相反的方向上传递数据。我们将在接下来的两节中实现这两种版本。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Copy Propagation</samp>
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">副本传播</samp>
- en: If the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    appears in a function, we can sometimes replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> later in that function.
    Let’s call the instruction where we’d like to perform this substitution *i*. The
    substitution is safe when two conditions are met. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> must appear on every path from the program’s entry point to *i*. Consider
    the control-flow graph in [Figure 19-3](#fig19-3), which doesn’t meet this condition.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个函数中出现指令<samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>，有时我们可以在函数的后续部分将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>替换为<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>。我们称希望执行此替换的指令为*i*。当满足两个条件时，替换是安全的。首先，指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>必须出现在从程序入口点到*i*的每条路径上。考虑[图19-3](#fig19-3)中的控制流图，它不满足这个条件。
- en: '![](../images/fig19-3.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-3: A control-flow
    graph for a function where we cannot perform copy propagation [Description](description-54.xhtml)</samp>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-3：一个不能执行复制传播的函数控制流图 [描述](description-54.xhtml)</samp>
- en: In this control-flow graph, there are two paths from the start of the function
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>. Because only
    one of these paths passes through <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 2</samp>, it isn’t safe to substitute <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in this <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. In [Figure 19-4](#fig19-4), on the other hand, every path to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> passes through <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp>.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制流图中，从函数的起始点到<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>有两条路径。因为只有其中一条路径经过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp>，所以在这个<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令中将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>替换为<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>是不安全的。另一方面，在[图19-4](#fig19-4)中，每条通向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>的路径都会经过<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 2</samp>。
- en: '![](../images/fig19-4.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-4: A control-flow
    graph for a function where we can perform copy propagation [Description](description-55.xhtml)</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-4：一个可以执行复制传播的函数控制流图 [描述](description-55.xhtml)</samp>
- en: No matter which path we take through [Figure 19-4](#fig19-4), we’ll execute
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp> before we reach the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction, so we
    can safely rewrite that instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们通过[图19-4](#fig19-4)选择哪条路径，我们都会在到达<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令之前执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp>，因此我们可以安全地将该指令重写为<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>。
- en: '[Figure 19-5](#fig19-5) shows another, slightly trickier example.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19-5](#fig19-5)展示了另一个稍微复杂一点的例子。'
- en: '![](../images/fig19-5.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-5: Another control-flow
    graph where copy propagation is safe [Description](description-56.xhtml)</samp>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图19-5：另一个可以安全执行复制传播的控制流图 [描述](description-56.xhtml)</samp>
- en: Once again, there are two different paths to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
    Both paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>,
    but they pass through different instances of this instruction that appear in different
    blocks. In <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp>;
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>. But in either case,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    will have the same value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. That means it’s still safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp>.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，通往<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>的路径有两条。两条路径都经过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>，但它们通过不同的指令实例，这些实例出现在不同的块中。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>的值为<samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp>；在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>中，其值为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>。但无论是哪种情况，当我们到达<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>的值是相同的。这意味着仍然可以将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>重写为<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp>。
- en: 'Before we rewrite instruction *i*, there’s a second condition that each path
    to *i* must satisfy: between the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> and *i*, neither <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> can be updated again.
    Consider this fragment of TACKY:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写指令*i*之前，还有第二个条件需要满足：每条通往*i*的路径必须满足：在指令<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp>和*i*之间，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>不能再次被更新。请考虑以下TACKY片段：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>,
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s value is no longer
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> at that point. Updating
    the variable that appeared on the right-hand side of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction causes the same problem:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>中将<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>替换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp>，因为此时<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>的值不再是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp>。更新在<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令右侧出现的变量也会导致同样的问题：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Right before <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 0</samp>, we
    know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    have the same value. But after that instruction, their values will be different,
    so we can’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
    When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction’s
    source or destination is updated, we say the copy is *killed*. Once a copy is
    killed, we can’t propagate it to later points in the program.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">y = 0</samp>之前，我们知道<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>的值是相同的。但在那条指令之后，它们的值将不同，因此我们不能重写<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>。当<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令的源或目标被更新时，我们称该复制被*杀死*。一旦复制被杀死，我们就不能将其传播到程序的后续位置。
- en: 'It’s possible for <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    to appear multiple times on some path to *i*. It’s unsafe to propagate it only
    if it’s killed after the *last* time it appears. In the following example, it’s
    safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>可能在通往*i*的某些路径中多次出现。只有当它在最后一次出现后被杀死时，传播它才是不安全的。在下面的示例中，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>重写为<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>是安全的：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If there are multiple paths to *i*, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction we’re interested in must not be killed on any of them. Take a look
    at [Figure 19-6](#fig19-6), where <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> is killed on one path but not another.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个路径通向*i*，我们关注的<code>Copy</code>指令不能在任何路径上被杀死。看看[图 19-6](#fig19-6)，其中<code>x
    = y</code>在一条路径上被杀死，但在另一条路径上没有。
- en: '![](../images/fig19-6.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-6: A control-flow
    graph where a reaching copy is killed along one path [Description](description-57.xhtml)</samp>'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-6：一个控制流图，其中一个到达的复制在一条路径上被杀死
    [描述](description-57.xhtml)</samp>
- en: If we jump over <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will have the same
    value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    But if we take the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, their values will be different.
    Because we don’t know ahead of time which path the program will take, we can’t
    rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跳过<code>B</code><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>，当我们到达<code>B</code><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>中的<code>Return</code>指令时，<code>x</code>和<code>y</code>将具有相同的值。但如果我们走过<code>B</code><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>路径，它们的值将会不同。因为我们无法预先知道程序会走哪条路径，所以我们不能重写<code>Return(x)</code>。
- en: 'Let’s consider one final edge case. Suppose that <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> is followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>,
    with no intervening kills:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个最终的边缘案例。假设<code>x = y</code>后面跟着<code>y = x</code>，且中间没有其他被杀死的指令：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Normally, updating <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> would
    kill the earlier <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    But after <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> still have the same
    value. There are multiple correct ways to handle this case. One option is to say
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp>, so only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
    reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>. In that
    case, we’d rewrite the final instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + x</samp>. This might let us remove <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> later, during dead store elimination, depending on where else <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is used. Another option is to
    simply ignore <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> during
    our analysis, on the grounds that it has no effect; it just assigns <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    the same value it already had. Then, when we’re rewriting instructions, we can
    go ahead and eliminate <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
    and rewrite the last instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = y + y</samp>. A third option is to propagate *both* copies in the final instruction,
    substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This substitution
    is safe but not particularly helpful, since it won’t help us get rid of either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. We’ll go
    with the second option and eliminate the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，更新<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>会导致之前的<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令失效。但是在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>之后，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>仍然拥有相同的值。处理这种情况有多种正确的方法。一个选项是说<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>会使<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp>失效，因此只有<samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>会影响<samp
    class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>。在这种情况下，我们会将最后一条指令重写为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">z = x + x</samp>。这可能会让我们在后续的死存储消除过程中删除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>，具体取决于<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>在其他地方的使用情况。另一个选项是简单地忽略我们的分析中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>，理由是它没有任何效果；它只是将<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>赋值为它已经拥有的相同的值。然后，当我们重写指令时，可以直接删除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>并将最后的指令重写为<samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = y + y</samp>。第三个选项是将*两个*副本传播到最后一条指令中，分别将<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>替换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，并将<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>替换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。这种替换是安全的，但并不是特别有帮助，因为它不会帮助我们去掉任何一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令。我们将选择第二个选项，去除冗余的<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>。
- en: If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction appears
    on every path to instruction *i*, and it isn’t killed on any of those paths, we
    say that it *reaches* instruction *i*. At the start of the copy propagation pass,
    we’ll perform reaching copies analysis to determine which copies reach each instruction
    in the TACKY function. Then, we’ll use the results of this analysis to identify
    instructions that we can rewrite safely.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令出现在到达指令*i*的每一条路径上，并且在这些路径上都没有被消除，我们就说它*到达*指令*i*。在副本传播过程的开始，我们将执行到达副本分析，以确定哪些副本到达TACKY函数中的每一条指令。然后，我们将利用这个分析结果来识别可以安全重写的指令。
- en: We’ll implement this whole optimization for the subset of TACKY we defined in
    [Part I](part1.xhtml), then extend it to handle the new language features from
    [Part II](part2.xhtml).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第一部分](part1.xhtml)中定义的TACKY子集上实现这个优化，然后扩展它以处理[第二部分](part2.xhtml)中的新语言特性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reaching Copies Analysis</samp>
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">到达副本分析</samp>
- en: 'To implement reaching copies analysis, we’ll define each of the elements of
    data-flow analysis that we discussed earlier: the transfer function, meet operator,
    and iterative algorithm. The transfer function and meet operator we’ll discuss
    in this section are specific to reaching copies analysis, while the iterative
    algorithm applies to every forward data-flow analysis.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现到达复制分析，我们将定义之前讨论过的每一个数据流分析元素：转移函数、交汇操作符和迭代算法。我们将在本节中讨论的转移函数和交汇操作符是特定于到达复制分析的，而迭代算法适用于所有的前向数据流分析。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp>
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">转移函数</samp>
- en: The transfer function takes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions that reach the beginning of a basic block and calculates which copies
    reach each individual instruction within the block. It also calculates which copies
    reach the end of the block, just after the final instruction. The rules here are
    pretty simple. First, if *i* is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, it reaches the instruction that comes right after it. Second, if
    some <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction reaches
    *i*, it also reaches the instruction right after *i*, unless *i* kills it. Let’s
    work through an example. Suppose a basic block contains the instructions in [Listing
    19-12](chapter19.xhtml#list19-12).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 转移函数会接收所有到达基本块起始位置的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    指令，并计算哪些复制指令会到达块内的每个单独指令。它还会计算哪些复制指令到达块的末尾，即最后一条指令之后。这里的规则相当简单。首先，如果 *i* 是一条 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令，它会到达紧跟其后的指令。其次，如果某条 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令到达 *i*，它也会到达 *i* 后面的指令，除非
    *i* 会终结它。让我们通过一个例子来理解。假设一个基本块包含了 [Listing 19-12](chapter19.xhtml#list19-12) 中的指令。
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-12: A basic block</samp>'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-12: 一个基本块</samp>'
- en: Let’s assume that one <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>, reaches
    the start of this basic block. This <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    will reach the first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a</samp>. Once we encounter <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a</samp>, we add it to the current set of reaching copies, so both <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    = y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> reach
    the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp>.
    Because this next instruction updates <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    it kills <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>. We therefore
    remove <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp> from the set
    of reaching copies, but we add <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 10</samp>. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp>
    kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>. We don’t add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> as a reaching copy
    because it’s not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    The final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction
    doesn’t add or remove any reaching copies. [Table 19-1](chapter19.xhtml#tab19-1)
    lists which copies reach each instruction in this basic block.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">a
    = y</samp>，到达这个基本块的起始位置。这条 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    指令将会到达第一条指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>。一旦我们遇到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>，我们将它添加到当前的到达复制集，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a</samp> 都会到达下一条指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp>。由于这条指令更新了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>，它终结了 <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    = y</samp>。因此，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp> 从到达复制集移除，但添加
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp>。最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y * 3</samp> 终结了 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>。我们不会将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> 添加为到达复制，因为它不是一条
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令。最终的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    指令不会添加或移除任何到达复制。[Table 19-1](chapter19.xhtml#tab19-1) 列出了每条指令在这个基本块中到达的复制指令。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-1:</samp> <samp class="SANS_Futura_Std_Book_11">Copies
    Reaching Each Instruction in [Listing 19-12](chapter19.xhtml#list19-12)</samp>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 19-1：</samp> <samp class="SANS_Futura_Std_Book_11">[示例
    19-12](chapter19.xhtml#list19-12) 中每条指令达到的副本</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Reaching
    copies</samp> |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">达到的副本</samp>
    |'
- en: '| --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y}</samp> |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y, x = a}</samp> |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y, x = a}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = a, y = 10}</samp> |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = a, y = 10}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">End of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">块结束</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
- en: Things get a little trickier when we consider variables with static storage
    duration. As [Listing 19-13](chapter19.xhtml#list19-13) demonstrates, these variables
    can be updated in other functions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑具有静态存储持续时间的变量时，事情变得有些复杂。如[示例 19-13](chapter19.xhtml#list19-13)所示，这些变量可以在其他函数中被更新。
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-13: A C program
    where multiple functions access the same variable with static storage duration</samp>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 19-13：一个 C 程序，其中多个函数访问同一个具有静态存储持续时间的变量</samp>
- en: Our reaching copies analysis should recognize that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">update
    _var</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> kills
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static_var = 5</samp> ❶. Otherwise,
    it will incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    to return the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.
    At first glance, it might look like this problem applies only to file scope variables,
    but as [Listing 19-14](chapter19.xhtml#list19-14) illustrates, it impacts static
    local variables too.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的达到副本分析应当识别出在 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 中调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">update _var</samp> 会导致 <samp class="SANS_TheSansMonoCd_W5Regular_11">static_var
    = 5</samp> ❶ 被修改。否则，它会错误地重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    使其返回常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>。乍一看，这个问题似乎只适用于文件作用域的变量，但正如[示例
    19-14](chapter19.xhtml#list19-14)所示，它同样影响静态局部变量。
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-14: A C program
    where a function call indirectly updates a static local variable</samp>'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 19-14：一个 C 程序，其中函数调用间接更新静态局部变量</samp>
- en: When we analyze <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, we’ll
    need to know that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">indirect_update</samp>
    at ❶ can update <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>. Otherwise,
    we’ll incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to return <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分析 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> 时，我们需要知道在 ❶ 处对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">indirect_update</samp> 的调用可以更新 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">total</samp>。否则，我们会错误地将 <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    重写为返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>。
- en: There are a couple of ways to solve this problem. One option is to figure out
    which function calls will update which static variables. This would make reaching
    copies analysis an interprocedural analysis, which gathers information about multiple
    functions. This approach gets complicated very quickly. Our other option is to
    assume that every function call updates every static variable. We’ll go with this
    option because it’s much simpler. Whenever we encounter a function call, we’ll
    kill any copies to or from static variables. This approach is *conservative*;
    it guarantees that we’ll never perform an unsafe optimization, but it may lead
    us to kill some reaching copies unnecessarily and miss some safe optimizations.
    In contrast, using interprocedural analysis would be a more *aggressive* approach
    because it would miss fewer optimizations. More aggressive optimization techniques
    aren’t always better; they often come at the cost of increased complexity and
    longer compilation times.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。一种选择是找出哪些函数调用会更新哪些静态变量。这将使得到达副本分析成为一个跨过程分析，收集多个函数的信息。这种方法很快会变得复杂。我们的另一个选择是假设每个函数调用都会更新每个静态变量。我们将选择这个方法，因为它更简单。每当我们遇到一个函数调用时，我们将杀死任何指向或来自静态变量的副本。这个方法是*保守的*；它保证我们永远不会执行不安全的优化，但可能会导致我们不必要地杀死一些到达副本，并错过一些安全的优化。相比之下，使用跨过程分析将是一种更*激进的*方法，因为它会错过更少的优化。更激进的优化技术并不总是更好；它们通常会增加复杂性和更长的编译时间。
- en: '[Listing 19-15](chapter19.xhtml#list19-15) gives the pseudocode for the transfer
    function.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 19-15](chapter19.xhtml#list19-15) 给出了传递函数的伪代码。'
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-15: The transfer
    function for reaching copies analysis</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 19-15：用于到达副本分析的传递函数</samp>
- en: To process an instruction, we’ll first record the set of copies that reach the
    point just before that instruction executes ❶. (We’ll refer to this information
    later when we actually rewrite the instruction.) Then, we’ll inspect the instruction
    itself to calculate which copies reach the point just after it. In the special
    case where <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> reaches
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we won’t add or remove
    any reaching copies ❷. As we saw earlier, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> will have no effect, since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> already have the same
    value. Otherwise, we’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> by killing
    any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> ❸,
    then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> to the
    set of reaching copies ❹.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理一条指令，我们首先会记录在该指令执行之前到达该点的副本集合❶。（当我们实际重写该指令时，将会用到这些信息。）然后，我们将检查该指令本身，以计算哪些副本到达指令执行后的点。在特殊情况下，当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> 到达 <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> 时，我们不会添加或移除任何到达副本❷。正如我们之前所看到的，<samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> 不会产生任何效果，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 已经具有相同的值。否则，我们将通过杀死所有指向或来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的副本❸ 来处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>，然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> 添加到到达副本集合中❹。
- en: When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction, we’ll kill any copies to or from variables with static storage duration
    along with any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    the variable that will hold the result of the function call ❺. The two other instructions
    from [Part I](part1.xhtml) that update variables are <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>. To handle either
    of these, we’ll kill any copies to or from its destination ❻. The remaining TACKY
    instructions from [Part I](part1.xhtml), like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>,
    don’t add or kill any reaching copies. After processing every instruction, we’ll
    record which copies reach the very end of the block ❼.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到<FunCall>指令时，我们将消除与静态存储期变量有关的任何拷贝以及与dst相关的任何拷贝，后者将保存函数调用结果❺。来自[第I部分](part1.xhtml)的另外两条更新变量的指令是<Unary>和<Binary>。为了处理其中任何一个，我们将消除与其目标❻有关的任何拷贝。来自[第I部分](part1.xhtml)的其余TACKY指令，如<Jump>，<Return>和<Label>，不会增加或杀死任何到达拷贝。在处理每个指令后，我们将记录哪些拷贝到达块的末尾
    ❼。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp>
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: meet运算符
- en: Next, we’ll implement the meet operator, which propagates information about
    reaching copies from one block to another. This operator calculates the set of
    initial reaching copies that we’ll pass to the transfer function. Recall that
    a copy reaches some point in the program only if it appears, and isn’t killed,
    on *every* path to that point. Therefore, a copy reaches the beginning of a block
    only if it reaches the end of all of that block’s predecessors. In other words,
    we’ll just take the set intersection of the results from every predecessor. [Listing
    19-16](chapter19.xhtml#list19-16) gives the pseudocode for the meet operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现meet运算符，它将传播关于从一个块到另一个块的到达拷贝的信息。该运算符计算了我们将传递给传输函数的初始到达拷贝集合。请记住，只有当拷贝在程序中的每条路径上都出现且没有被杀死时，拷贝才能到达某一点。因此，拷贝只有在到达所有该块前驱的末尾时，才能到达该块的开头。换句话说，我们将仅仅取每个前驱的结果的集合交集。[清单19-16](chapter19.xhtml#list19-16)给出了meet运算符的伪代码。
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-16: The meet operator
    for reaching copies analysis</samp>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 清单19-16：用于到达拷贝分析的meet运算符
- en: The meet operator takes two arguments. The first is the block whose incoming
    copies we want to calculate. The second, <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>,
    is the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions
    that appear in the function. We initialize the set of incoming copies to this
    value ❶, because it’s the *identity element* for set intersection. That is, given
    any set of reaching copies, *S*, the intersection of *S* with <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>
    is just *S*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: meet运算符接受两个参数。第一个是我们想要计算传入拷贝的块。第二个参数all_copies是函数中出现的所有Copy指令的集合。我们将传入拷贝的集合初始化为这个值
    ❶，因为它是集合交集的*恒等元素*。也就是说，对于任何到达拷贝的集合*S*，与all_copies的交集就是*S*。
- en: Next, we iterate over the block’s predecessors, which might include other basic
    blocks, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> node, or
    both. No copies reach the very start of a function, so if we find <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    in the list of predecessors we just return the empty set ❷. (The intersection
    of the empty set and anything else is still the empty set, so there’s no need
    to look at the block’s other predecessors.) Otherwise, we look up the set of copies
    that reach the end of each predecessor ❸, which we recorded at the end of [Listing
    19-15](chapter19.xhtml#list19-15), and take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">incoming_copies</samp>
    with each of these sets.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历块的前驱，这些前驱可能包括其他基本块、<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    节点，或者两者。如果我们在前驱列表中找到了 <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>，我们就返回空集
    ❷。（空集与任何其他集合的交集仍然是空集，所以无需再查看该块的其他前驱。）否则，我们查找到达每个前驱末端的副本集 ❸，这些副本集我们在 [Listing 19-15](chapter19.xhtml#list19-15)
    末尾记录过，然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">incoming_copies</samp>
    与每个副本集进行交集。
- en: We have one edge case to consider. If unreachable code elimination is disabled,
    the block we’re analyzing might not have any predecessors. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp>
    on a block with no predecessors will return <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>,
    so we assume that every possible <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction reaches the start of the block. We don’t care how this ultimately
    impacts the block itself, which will never execute anyway. We *do* care how this
    impacts the block’s successors, which might be reachable. For instance, if a reachable
    block <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and unreachable block
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> both jump to block <samp
    class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, then block <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    is reachable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个极端情况需要考虑。如果禁用了不可达代码消除，我们正在分析的块可能没有任何前驱。对没有前驱的块调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp>
    将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>，因此我们假设每个可能的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令都会到达该块的起始位置。我们并不关心这最终如何影响该块本身，因为它反正不会执行。我们*确实*关心的是它如何影响该块的后继块，后继块可能是可达的。例如，如果一个可达块
    <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> 和一个不可达块 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    都跳转到块 <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>，那么块 <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    就是可达的。
- en: Luckily, our analysis is still safe. The intersection of the real results from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and the junk results from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> will always be a subset
    of the copies that actually reach <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>; this is a conservative
    approximation of the results we’d get if we enabled unreachable code elimination
    and deleted <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> entirely.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的分析依然是安全的。来自 <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> 的真实结果和来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> 的垃圾结果的交集将始终是实际上从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">A</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    的副本的子集；这是一个保守的近似结果，假设我们启用了不可达代码消除并完全删除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp>
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">迭代算法</samp>
- en: 'We can analyze a basic block with the meet operator and transfer function once
    we know the results from the blocks that preceded it. Now we’ll tie everything
    together and analyze the entire function. There’s just one problem: control-flow
    graphs can have loops! We can’t analyze a block until we’ve analyzed all of its
    predecessors, which requires us to analyze all of their predecessors, and so on.
    Once we hit a loop, it seems like we’re stuck; we can’t analyze any of the blocks
    in the loop, because each block directly or indirectly precedes itself.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道前面块的结果，就可以使用交集运算符和传输函数分析基本块。现在我们将把所有内容结合起来，分析整个函数。但有一个问题：控制流图可能有循环！我们无法分析一个块，直到我们分析完它的所有前驱，这要求我们分析它们的所有前驱，依此类推。一旦遇到循环，我们似乎就陷入困境了；我们无法分析循环中的任何一个块，因为每个块直接或间接地先于自己。
- en: To get unstuck, we need some way to analyze a block even if we don’t have complete
    results from all of its predecessors. The solution is to maintain a provisional
    result for every block; if we need to analyze a block before some of its predecessors,
    we can use those predecessors’ provisional results. At first, before we’ve explored
    any paths to a block, its provisional result includes every <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction in the function. Then, with each new path to the block (or rather,
    the end of the block) that we explore, we eliminate any copies that don’t appear,
    or are killed, along that path. This means a block’s provisional result always
    tells us which reaching copies appear (and aren’t killed) on *every* path to the
    end of that block that we’ve explored so far. Once we’ve explored every possible
    path, we’ll have the block’s final result.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了摆脱困境，我们需要某种方法来分析一个块，即使我们没有来自其所有前驱块的完整结果。解决方案是为每个块保持一个临时结果；如果我们需要在某些前驱块的结果之前分析一个块，我们可以使用那些前驱块的临时结果。最初，在我们还没有探索到某个块的任何路径之前，它的临时结果包含函数中的每一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令。然后，在我们探索到该块的每一条新路径时（更确切地说，是探索到该块的末端），我们会去除任何没有出现或在该路径上被“杀死”的副本。这意味着，一个块的临时结果始终告诉我们在我们目前为止探索的到达该块末端的*每一条*路径上，哪些到达副本出现（并且没有被杀死）。一旦我们探索了所有可能的路径，就会得到该块的最终结果。
- en: That’s the basic idea; now let’s put it into practice. First, we’ll annotate
    each basic block with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions in the function. As we learned earlier, this set is the identity
    element for our meet operator. Initializing every block with the identity element
    ensures that blocks we haven’t yet analyzed don’t change the result of the meet
    operator. Let’s try out this approach on the control-flow graph in [Figure 19-7](#fig19-7).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本的思路；现在让我们付诸实践。首先，我们会用函数中所有的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    指令集合对每个基本块进行注解。正如我们之前学到的，这个集合是我们 meet 操作符的单位元素。用单位元素初始化每个块可以确保我们还没有分析过的块不会改变 meet
    操作符的结果。让我们在 [图 19-7](#fig19-7) 中的控制流图上尝试这个方法。
- en: '![](../images/fig19-7.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-7: A control-flow
    graph with a loop [Description](description-58.xhtml)</samp>'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-7：带有循环的控制流图 [描述](description-58.xhtml)</samp>
- en: 'This control-flow graph contains two <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>. We’ll initially annotate
    each block with the set containing both copies. Then, we’ll analyze the blocks
    in order. We can calculate the final results for <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> in just one pass because
    its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    [Figure 19-8](#fig19-8) illustrates the annotations on each block after we’ve
    processed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制流图包含两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4</samp>。我们最初会用包含这两个副本的集合对每个块进行注解。然后，我们按顺序分析这些块。我们只需一遍就能计算出 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> 的最终结果，因为它的唯一前驱是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>。
    [图 19-8](#fig19-8) 展示了我们处理完 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> 后在每个块上的注解。
- en: '![](../images/fig19-8.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-8: The provisional
    results of reaching copies analysis for [Figure 19-7](#fig19-7), after processing
    B</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I-SUB_11">0 [Description](description-59.xhtml)</samp>'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-8：在处理 B 后，对 [图 19-7](#fig19-7)
    的到达副本分析的临时结果</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I-SUB_11">0
    [描述](description-59.xhtml)</samp>
- en: 'At this point, the annotation on <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> is correct: only <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 3</samp> reaches the end of that block. The other two blocks are still annotated
    with every copy. Next, we’ll apply the meet operator to see which copies reach
    the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>.
    This block has two predecessors: <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> and itself. We’ll therefore
    take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3, y = 4}</samp>, which
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>. This is the same
    result we’d get if <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> were <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>’s only predecessor. That’s
    exactly the behavior we want: because we haven’t analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> yet, it shouldn’t contribute
    to the result of the meet operator. Once we apply the transfer function to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    we’ll recognize that only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>
    reaches the end of the block. We’ll then have all the information we need to process
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    too. [Figure 19-9](#fig19-9) shows the annotations on each block after we’ve analyzed
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>上的标注是正确的：只有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> 到达了该块的末尾。其他两个块仍然标注着每个副本。接下来，我们将应用
    meet 操作符，看看哪些副本能到达 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> 的起始位置。该块有两个前驱：<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> 和它本身。因此，我们将取 <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 3}</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3, y = 4}</samp>
    的交集，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>。这与如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    唯一前驱时的结果相同。这正是我们想要的行为：因为我们还没有分析 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>，它不应该对 meet 操作符的结果产生影响。一旦我们将传输函数应用于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>，我们会发现只有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp> 到达了该块的末尾。然后，我们就能拥有处理
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    所需的所有信息。[图 19-9](#fig19-9) 展示了我们分析了 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> 后每个块的标注情况。
- en: '![](../images/fig19-9.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-9.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-9: The provisional
    results of reaching copies analysis after analyzing each basic block once [Description](description-60.xhtml)</samp>'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-9：分析每个基本块一次后的副本到达分析的临时结果
    [描述](description-60.xhtml)</samp>
- en: Each block now has the correct set of reaching copies. But we don’t yet have
    the right answer for each individual instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. ([Figures 19-8](#fig19-8)
    and [19-9](#fig19-9) don’t show the annotations on individual instructions.) When
    we last analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    we assumed that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> reached
    the start of the block, which would imply that it also reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = process(y)</samp>. Now that we have more accurate information, we need to analyze
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    again. This time, the meet operator will take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 4}</samp>,
    which is the empty set. We’ll pass this result to the transfer function to recalculate
    the results for individual instructions in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. This time around, we’ll
    correctly conclude that no <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions reach <samp class="SANS_TheSansMonoCd_W5Regular_11">x = process(y)</samp>
    (or any point in the block before <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4</samp>, for that matter).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen the iterative algorithm in action, let’s implement it. [Listing
    19-17](chapter19.xhtml#list19-17) gives the pseudocode for this algorithm.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-17: The iterative
    algorithm for reaching copies analysis</samp>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: We’ll maintain a worklist of basic blocks we need to process, including blocks
    that we need to revisit after updating one of their predecessors. In the initial
    setup for this algorithm, we’ll add each basic block to the worklist ❶, since
    we need to analyze every block at least once. We’ll also initialize each block
    with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions that appear in the function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Next, we enter our main processing loop, where we’ll remove a block from the
    front of the worklist ❷, then analyze it using the meet operator and transfer
    function. If this analysis changes the block’s outgoing reaching copies, we’ll
    add all of its successors to the worklist so we can reanalyze them using those
    new results ❸. If a successor is already in the worklist, we don’t need to add
    it again. We’ll repeat this process until the worklist is empty.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-17](chapter19.xhtml#list19-17) works for any forward data-flow
    analysis. Only the transfer function, the meet operator, and the identity element
    used to initialize each basic block will vary.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rewriting TACKY Instructions</samp>
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">重写TACKY指令</samp>
- en: After running reaching copies analysis, we’ll look for opportunities to rewrite,
    or even remove, each instruction in the TACKY function. To rewrite an instruction,
    we’ll check whether the copies that reach it define any of its operands. If they
    do, we’ll replace those operands with their values. If we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    and its reaching copies include <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we’ll
    remove it instead of trying to rewrite it; the instruction has no effect if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    already have the same value. [Listing 19-18](chapter19.xhtml#list19-18) demonstrates
    how to process each instruction.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行到达副本分析后，我们将寻找机会重写或甚至删除TACKY函数中的每一条指令。为了重写一条指令，我们将检查到达它的副本是否定义了它的任何操作数。如果定义了，我们将用它们的值替换这些操作数。如果我们遇到形式为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    指令，并且它的到达副本中包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>，我们将删除它，而不是尝试重写它；因为如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    已经具有相同的值，那么该指令没有任何效果。[Listing 19-18](chapter19.xhtml#list19-18) 演示了如何处理每一条指令。
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-18: Rewriting an
    instruction based on the results of reaching copies analysis</samp>'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-18: 基于到达副本分析结果重写指令</samp>'
- en: Given the set of copies that reach the current instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">replace_operand</samp>
    replaces a single TACKY operand with its value. If the operand is a constant or
    we can’t find a reaching copy that assigns to it, we just return the original
    value.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 给定到达当前指令的副本集合，<samp class="SANS_TheSansMonoCd_W5Regular_11">replace_operand</samp>
    用其值替换单个 TACKY 操作数。如果操作数是常量，或者我们无法找到分配给它的到达副本，我们将直接返回原始值。
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_instruction</samp>,
    we start by looking up the set of copies that reach the current instruction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">instr</samp> ❶. If <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, we’ll
    search this set, which we call <samp class="SANS_TheSansMonoCd_W5Regular_11">reaching_copies</samp>,
    for a copy from its source to its destination or vice versa ❷. If we find one,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>’s operands already
    have the same value, so we can delete it. ([Listing 19-18](chapter19.xhtml#list19-18)
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to indicate
    that we should delete the instruction; your code might indicate this differently.)
    Otherwise, we try to replace the instruction’s source operand using <samp class="SANS_TheSansMonoCd_W5Regular_11">replace
    _operand</samp> ❸. We’ll attempt to replace the source operands of other TACKY
    instructions in the same way. [Listing 19-18](chapter19.xhtml#list19-18) demonstrates
    how to rewrite the source operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>; I’ve omitted
    the remaining TACKY instructions from [Part I](part1.xhtml) because the logic
    is the same.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_instruction</samp> 中，我们首先查找到达当前指令的副本集合
    <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp> ❶。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>
    是一条 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令，我们将搜索这个集合（我们称之为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reaching_copies</samp>），寻找一个从源到目的地或反向的副本
    ❷。如果找到了，<samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp> 的操作数已经具有相同的值，因此我们可以删除它。（[Listing
    19-18](chapter19.xhtml#list19-18) 返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    来表示我们应该删除该指令；您的代码可能会以不同的方式表示这一点。）否则，我们尝试使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">replace
    _operand</samp> ❸ 来替换该指令的源操作数。我们将以相同的方式尝试替换其他TACKY指令的源操作数。[Listing 19-18](chapter19.xhtml#list19-18)
    演示了如何在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    中重写源操作数；我已经省略了 [Part I](part1.xhtml) 中其余的 TACKY 指令，因为它们的逻辑是相同的。
- en: At this point, you have a complete copy propagation pass that performs reaching
    copies analysis and uses the results to optimize a TACKY function. If you skipped
    [Part II](part2.xhtml), you can move on to this section’s test suite. But if you
    completed [Part II](part2.xhtml), you still have some work to do.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经完成了一个完整的复制传播过程，该过程执行了到达复制分析，并使用结果优化了一个TACKY函数。如果你跳过了[第二部分](part2.xhtml)，可以直接进入本节的测试套件。但如果你完成了[第二部分](part2.xhtml)，你还有一些工作要做。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">支持第二部分TACKY程序</samp>
- en: To make copy propagation work with the TACKY code we generate in [Part II](part2.xhtml),
    we need to solve a couple of problems. The first problem is that we sometimes
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions to
    perform type conversions. We don’t want to propagate copies between signed and
    unsigned types, because we sometimes generate different assembly code for operations
    on signed and unsigned values. If we replace a signed value with an unsigned one
    in a comparison, for example, we’ll end up generating the wrong condition code
    for that comparison. Our reaching copies analysis will treat any <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    between signed and unsigned operands like a type conversion instruction instead
    of a normal copy operation. We won’t add it as a reaching copy in the transfer
    function, and we won’t include it in the set of initial reaching copies at the
    start of the iterative algorithm.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使复制传播与我们在[第二部分](part2.xhtml)中生成的TACKY代码一起工作，我们需要解决几个问题。第一个问题是我们有时使用<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令进行类型转换。我们不希望在有符号和无符号类型之间传播复制，因为我们有时会为有符号和无符号值的操作生成不同的汇编代码。例如，如果我们在比较中将一个有符号值替换为无符号值，最终生成的条件码会是错误的。我们的到达复制分析会将任何有符号和无符号操作数之间的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>视为类型转换指令，而不是普通的复制操作。我们不会将其作为到达复制添加到传递函数中，也不会在迭代算法开始时将其包含在初始到达复制集合中。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*Another solution would be to introduce separate signed and unsigned TACKY
    operators for comparisons, remainder operations, and division, so we wouldn’t
    have to check the types of operands to distinguish between these cases during
    code generation. The LLVM IR uses this approach.*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*另一种解决方案是为比较、余数操作和除法引入单独的有符号和无符号TACKY运算符，这样我们就不需要在代码生成过程中检查操作数的类型来区分这些情况。LLVM
    IR采用了这种方法。*'
- en: The second problem is that variables can be updated through pointers. These
    updates are difficult to analyze. If we see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(v,
    ptr)</samp>, we don’t know which object <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to, so we don’t know which copies to kill. This is similar to the issue
    we ran into with static variables, which could be updated in other functions.
    To solve this problem, we’ll find all the variables that could be accessed through
    pointers (these are called *aliased variables*). We’ll assume that every <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction updates every
    one of these variables. We’ll assume that function calls update these variables
    too, since we can declare a variable in one function and then update it through
    a pointer in a different function. Let’s use this approach to analyze [Listing
    19-19](chapter19.xhtml#list19-19).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是变量可以通过指针进行更新。这些更新很难分析。如果我们看到指令<samp class="SANS_TheSansMonoCd_W5Regular_11">Store(v,
    ptr)</samp>，我们不知道<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>指向哪个对象，因此也无法知道该删除哪些复制。这与我们遇到的静态变量问题类似，静态变量可能在其他函数中更新。为了解决这个问题，我们将找到所有可能通过指针访问的变量（这些变量称为*别名变量*）。我们将假设每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>指令都会更新这些变量。我们还假设函数调用也会更新这些变量，因为我们可以在一个函数中声明一个变量，然后在另一个函数中通过指针更新它。让我们用这种方法来分析[示例19-19](chapter19.xhtml#list19-19)。
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-19: A TACKY function
    that updates variables through pointers</samp>'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例19-19：通过指针更新变量的TACKY函数</samp>
- en: First, we’ll identify the aliased variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">function_with_pointers</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are aliased because they’re both used in <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instructions. (Let’s assume that none of the variables in this listing are static,
    so we don’t have to worry about whether other functions take their address.) Next,
    we’ll run reaching copies analysis. Since this whole function body is one basic
    block, we can just apply the transfer function to the entire thing. We’ll add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> to
    the set of reaching copies, as usual. Then, when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction, we’ll kill the copies to our two aliased variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. [Table 19-2](chapter19.xhtml#tab19-2)
    describes which copies will reach each instruction in this function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将识别 <samp class="SANS_TheSansMonoCd_W5Regular_11">function_with_pointers</samp>
    中的别名变量。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    都在 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> 指令中使用，它们是别名。
    （假设此列表中的变量都不是静态的，因此我们无需担心其他函数是否取用它们的地址。）接下来，我们将进行到达副本分析。由于整个函数体是一个基本块，我们可以将传递函数应用于整个函数。像往常一样，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 2</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> 添加到到达副本集合中。然后，当我们到达
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 指令时，我们将删除对两个别名变量 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    的副本。[表 19-2](chapter19.xhtml#tab19-2)描述了每条指令将到达哪些副本。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-2:</samp> <samp class="SANS_Futura_Std_Book_11">Copies
    Reaching Each Instruction in [Listing 19-19](chapter19.xhtml#list19-19)</samp>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 19-2：</samp> <samp class="SANS_Futura_Std_Book_11">每条指令的到达副本
    [Listing 19-19](chapter19.xhtml#list19-19)</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Reaching
    copies</samp> |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">到达副本</samp>
    |'
- en: '| --- | --- |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1}</samp> |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1, y = 2}</samp> |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1, y = 2}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1 = GetAddress(x)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1 = GetAddress(x)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(10, ptr1)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(10, ptr1)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2 = GetAddress(y)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z = 3}</samp> |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2 = GetAddress(y)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z = 3}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z
    = 3}</samp> |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z
    = 3}</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(z)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(z)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">End of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">块的结尾</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
- en: We correctly recognize that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    which means that we can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + y</samp>. We also assume that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    because our analysis isn’t smart enough to realize that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    couldn’t possibly point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
    Therefore, we won’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + y</samp>, even though it would be safe to do so. Once again, we’re making
    a conservative assumption; we’ll miss some safe optimizations, but we’ll never
    apply any that are unsafe.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正确地识别到 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>` 指令可能会覆盖
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>`，这意味着我们不能在 `<samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + y</samp>` 中将 `<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>` 替换为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>`。我们还假设 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>`
    指令可能会覆盖 `<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>`，因为我们的分析没有足够智能地意识到
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>` 不可能指向 `<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>`。因此，即使将
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>` 替换为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>`
    在 `<samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>` 中是安全的，我们也不会这么做。再一次，我们做出了保守的假设；我们可能会错过一些安全的优化，但绝不会应用任何不安全的优化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Address-Taken
    Analysis</samp>
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实现地址获取分析</samp>
- en: The approach we just used to identify aliased variables is called *address-taken
    analysis*. To perform this analysis, we’ll inspect each instruction in a TACKY
    function and identify every variable that either has static storage duration or
    has its address taken by a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction. (We’ll assume that all static variables are aliased, because their
    addresses might be taken in other functions.) We’ll rerun this analysis on every
    iteration through the optimization pipeline because the results can change if
    we optimize away any <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instructions. [Listing 19-20](chapter19.xhtml#list19-20) demonstrates how it fits
    into the overall optimization pipeline we defined in [Listing 19-6](chapter19.xhtml#list19-6).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用的识别别名变量的方法叫做 *地址获取分析*。为了执行这个分析，我们将检查 TACKY 函数中的每一条指令，并识别出每个变量，它们要么具有静态存储持续时间，要么其地址被
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>` 指令获取。（我们假设所有静态变量都是别名，因为它们的地址可能在其他函数中被获取。）我们将在优化管道的每次迭代中重新执行此分析，因为如果我们优化掉任何
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>` 指令，结果可能会发生变化。[示例
    19-20](chapter19.xhtml#list19-20) 展示了它如何适应我们在 [示例 19-6](chapter19.xhtml#list19-6)
    中定义的整体优化管道。
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-20: Adding address-taken
    analysis to the TACKY optimization pipeline</samp>'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 19-20：将地址获取分析添加到 TACKY 优化管道中</samp>
- en: Address-taken analysis is just one kind of *alias analysis*, also known as *pointer
    analysis*, which tries to determine whether two pointers or variables can refer
    to the same object. Most pointer analysis algorithms are more powerful than address-taken
    analysis. For example, they could figure out that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    will never point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in
    [Listing 19-19](chapter19.xhtml#list19-19).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 地址获取分析只是 *别名分析* 的一种，也叫 *指针分析*，它尝试确定两个指针或变量是否可以引用同一个对象。大多数指针分析算法比地址获取分析更强大。例如，它们可以推断出在
    [示例 19-19](chapter19.xhtml#list19-19) 中 `<samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>`
    永远不会指向 `<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>`。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating the Transfer Function</samp>
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">更新传递函数</samp>
- en: Next, we’ll extend the transfer function to support the new types and instructions
    we added in [Part II](part2.xhtml).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展传递函数，以支持我们在 [第二部分](part2.xhtml) 中添加的新类型和指令。
- en: '[Listing 19-21](chapter19.xhtml#list19-21) illustrates our new and improved
    transfer function. It reproduces [Listing 19-15](chapter19.xhtml#list19-15), with
    the changes to support additional types bolded.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 19-21](chapter19.xhtml#list19-21)展示了我们新改进的传输函数。它重新生成了[列表 19-15](chapter19.xhtml#list19-15)，并将支持额外类型的更改部分加粗。'
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-21: The transfer
    function for reaching copies analysis, with support for features from Part II</samp>'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 19-21：用于到达拷贝分析的传输函数，支持第二部分中的特性</samp>
- en: We’ve already touched on most of the changes in this listing. Before we add
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">current_reaching_copies</samp>, we’ll
    make sure that its source and destination have the same type, or at least types
    with the same signedness. The <samp class="SANS_TheSansMonoCd_W5Regular_11">signedness</samp>
    helper function should count <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    as a signed type and all pointer types as unsigned types, so we can propagate
    copies between <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, between different
    pointer types, and between pointers and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. (The concept of signedness doesn’t apply to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    or non-scalar types. That’s fine, because we don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions to convert to or from these types. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or non-scalar
    operand, both operands will have the same type, so we won’t need to check their
    signedness.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了此列表中的大多数更改。在将<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">current_reaching_copies</samp>之前，我们将确保其源和目标具有相同类型，或者至少是具有相同符号性的类型。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signedness</samp>辅助函数应将<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>视为有符号类型，将所有指针类型视为无符号类型，因此我们可以在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>、不同指针类型之间以及指针和<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>之间传播拷贝。（符号性概念不适用于<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>或非标量类型。没关系，因为我们不会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令来转换这些类型。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>或非标量操作数，则两个操作数将具有相同类型，因此我们不需要检查它们的符号性。)
- en: When we encounter a function call or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction, we’ll kill any copies to or from aliased variables. We’ll also account
    for the fact that a function call may not have a destination operand. Note that
    we don’t kill the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp> operand. <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    doesn’t change the value of the destination pointer itself, just the value of
    the object it points to. Finally, when we encounter any of the other instructions
    we added in [Part II](part2.xhtml)—including type conversions, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>—we’ll
    kill any copies to or from its destination. We won’t track copies to or from individual
    subobjects within structures or arrays, so <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> will kill
    reaching copies without generating any new ones.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到函数调用或<samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>指令时，我们将删除与别名变量相关的任何拷贝操作。我们还需要考虑到函数调用可能没有目标操作数的情况。请注意，我们不会删除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>指令的<samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp>操作数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>不会改变目标指针本身的值，只会改变它所指向对象的值。最后，当我们遇到我们在[第二部分](part2.xhtml)中添加的其他指令时——包括类型转换、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>——我们将删除与其目标相关的任何拷贝操作。我们不会跟踪结构或数组内部单独子对象的拷贝操作，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>将删除到达拷贝，而不会生成任何新的拷贝。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating rewrite_instruction</samp>
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">更新 rewrite_instruction</samp>
- en: 'We’ll rewrite most of the new TACKY instructions from [Part II](part2.xhtml)
    in the same way as the instructions from [Part I](part1.xhtml), replacing any
    source operands that are defined by reaching copies. The one exception is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, which we’ll never rewrite.
    It wouldn’t make sense to apply copy propagation to <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>,
    because it uses its source operand’s address rather than its value.  ### <samp
    class="SANS_Futura_Std_Bold_B_11">Dead Store Elimination</samp>'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与[第一部分](part1.xhtml)中的指令相同的方式重写[第二部分](part2.xhtml)中的大多数新 TACKY 指令，替换任何由传递复制定义的源操作数。唯一的例外是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>，我们永远不会重写它。对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp> 应用复制传播没有意义，因为它使用的是源操作数的地址，而不是它的值。###
    <samp class="SANS_Futura_Std_Bold_B_11">死存储消除</samp>
- en: Our last optimization is dead store elimination. We’ll use liveness analysis,
    a backward data-flow analysis, to calculate which variables are live at every
    point in the function we’re optimizing. Then, we’ll use the results of this analysis
    to identify dead stores and eliminate them.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个优化是死存储消除。我们将使用活跃性分析，一种向后的数据流分析，来计算在我们优化的函数中的每个点哪些变量是活跃的。然后，我们将使用分析结果来识别并消除死存储。
- en: A variable is *live* at a particular point if its value at that point might
    be read later in the program. Otherwise, it’s *dead*. To be more precise, a variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live at any given point
    *p* when two conditions are met. First, there must be at least one path from *p*
    to some later instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is *generated*
    by any instruction that uses it. Second, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    must not be updated on the path from *p* to that later instruction. We say that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is *killed* by any instruction
    that updates it, just like a reaching copy is killed when either of its operands
    is updated. (You’ll see the terms *generate* and *kill* in discussions of most
    data-flow analyses, not just the two in this chapter.) Consider the control-flow
    graph in [Figure 19-10](#fig19-10).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量在某个特定点的值可能在程序的后续部分被读取，那么它在该点是*活跃的*。否则，它是*死的*。更精确地说，当满足两个条件时，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    在某个给定点 *p* 是活跃的。首先，必须存在至少一条从 *p* 到某个后续指令的路径，该路径使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。我们说
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是由任何使用它的指令*生成*的。其次，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在从 *p* 到该后续指令的路径上不能被更新。我们说 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是由任何更新它的指令*消除*的，就像当其操作数被更新时，一个传递复制会被消除一样。（在大多数数据流分析中，你会看到*生成*和*消除*这两个术语，而不仅仅是本章中提到的两个。）请参考[图
    19-10](#fig19-10)中的控制流图。
- en: '![](../images/fig19-10.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-10.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-10: A control-flow
    graph in which x is live just after it’s defined [Description](description-61.xhtml)</samp>'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-10：一个控制流图，其中 x 在定义后立即变为活跃
    [描述](description-61.xhtml)</samp>
- en: There are two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. On the path through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is never used. On the path
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is used in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is live at the point after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    because it’s generated on one of these paths. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is also live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, at the beginning of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    On the other hand, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead
    at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    and at every point in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, since there are no paths
    from those points to an instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is also dead
    at the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, since we don’t use its (uninitialized)
    value before we assign it a new value in <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp>.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>
    有两条路径。在通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    的路径上，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 从未被使用。在通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> 的路径上，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    被用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令。我们知道，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> 后是活跃的，因为它在这些路径中的一条上被生成。按照相同的逻辑，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    的末尾、在 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    的开头以及在 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令前也是活跃的。另一方面，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> 的末尾以及在 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> 中的每个点都是死的，因为从这些点到任何使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的指令没有路径。注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    在 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    的最开始也是死的，因为在我们为其赋新值之前，我们并没有使用它（未初始化的）值。
- en: Now let’s look at the control-flow graph in [Figure 19-11](#fig19-11).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下[图 19-11](#fig19-11)中的控制流图。
- en: '![](../images/fig19-11.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig19-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-11: A control-flow
    graph with a dead store to x [Description](description-62.xhtml)</samp>'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 19-11：一个具有对 x 的死存储的控制流图 [描述](description-62.xhtml)</samp>
- en: 'Again, we have two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Both
    paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions that use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    but on both paths <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is killed
    between <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction that generates
    it. This means that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is
    dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>.
    It’s alive at just two points in this control-flow graph: right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = f()</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = g()</samp> in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有两条路径从 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> 到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>。这两条路径都经过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令，但在这两条路径上，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> 和生成它的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    指令之间被杀死。这意味着 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> 后立即死亡。在这个控制流图中，<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    仅在两个点是活跃的：在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = f()</samp> 之后（在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    中），以及在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = g()</samp> 之后（在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    中）。
- en: An instruction is a dead store if it assigns to a dead variable and has no other
    side effects. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    is a dead store in [Figure 19-11](#fig19-11) but not in [Figure 19-10](#fig19-10).
    Note that we care whether the variable is dead just *after* the instruction, not
    before it. In the code fragment
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一条指令赋值给一个死变量且没有其他副作用，那么它就是一条死存储。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> 在[图 19-11](#fig19-11)中是死存储，但在[图 19-10](#fig19-10)中不是。请注意，我们关心的是变量在指令执行*之后*是否为死变量，而不是在执行之前。代码片段中
- en: '[PRE58]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live just before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> but dead after it. The
    fact that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead just
    after we update it means that this instruction is a dead store, so we can eliminate
    it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = x + 1</samp> 之前是活跃的，但之后就死亡了。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    在更新后立刻死亡，这意味着这条指令是一个死存储，因此我们可以将其消除。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Liveness Analysis</samp>
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">活跃性分析</samp>
- en: Like every data-flow analysis, liveness analysis requires a transfer function,
    a meet operator, and an iterative algorithm. Because this is a backward-flow problem,
    the transfer function will start at the end of a basic block and work its way
    to the beginning, instead of working from start to finish like we did in reaching
    copies analysis. Similarly, the meet operator will gather information from a block’s
    successors, not its predecessors. We’ll also use a slightly different iterative
    algorithm to send data backward through the control-flow graph. Let’s take a closer
    look at each of these pieces.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个数据流分析一样，活跃性分析需要一个转移函数、一个合并运算符和一个迭代算法。由于这是一个反向流问题，转移函数将从基本块的末尾开始，逐步向前推进，而不是像我们在到达拷贝分析中那样从开始到结束。同样，合并运算符将从一个块的后继中收集信息，而不是从前驱中收集。我们还将使用一个稍微不同的迭代算法，通过控制流图将数据反向传递。让我们仔细看看这些部分。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp>'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">转移函数</samp>'
- en: The transfer function takes the set of variables that are live at the end of
    a basic block and figures out which variables are live just before each instruction.
    As we saw in [Figures 19-10](#fig19-10) and [19-11](#fig19-11), an instruction
    generates any variables that it reads and kills any variables that it updates.
    For example, to calculate the live variables before the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y * z</samp>, we would take the set of variables that are live right after the
    instruction, add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, and remove <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    If an instruction reads and writes the same variable, it generates the variable
    instead of killing it. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = x + 1</samp> generates <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 转移函数获取基本块结束时的活跃变量集合，并计算出每条指令之前哪些变量是活跃的。正如我们在[图 19-10](#fig19-10)和[图 19-11](#fig19-11)中看到的，一条指令会生成它读取的任何变量，并杀死它更新的任何变量。例如，要计算指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = y * z</samp>之前的活跃变量，我们需要先获取指令执行后活跃的变量集合，再加上<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>，并移除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。如果一条指令同时读取和写入同一个变量，它会生成该变量而不是杀死它。例如，指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp>会生成<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。
- en: Let’s apply the transfer function to the basic block in [Listing 19-22](chapter19.xhtml#list19-22).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将转移函数应用于[清单 19-22](chapter19.xhtml#list19-22)中的基本块。
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-22: A basic block</samp>'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-22：一个基本块</samp>
- en: The transfer function will start at the bottom of this basic block and work
    its way up. Let’s assume that there are no live variables at the end of the block,
    after the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction.
    (This assumption might not hold if the function deals with static variables, but
    we’ll worry about that later.) When we process the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to the set of live variables. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 3 * x</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    and generate <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. The next
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp>, generates
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This has no effect because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is already live. Finally,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    leaving no live variables at the start of the basic block. [Table 19-3](chapter19.xhtml#tab19-3)
    summarizes which variables are live just after each instruction in [Listing 19-22](chapter19.xhtml#list19-22).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 转移函数将从基本块的底部开始，向上处理。假设在块的末尾，即在<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令之后，没有活跃变量。（如果函数处理静态变量，这个假设可能不成立，但我们稍后再讨论这个问题。）当我们处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令时，我们会将<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>添加到活跃变量集合中。然后，指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 3 * x</samp>会杀死<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>并生成<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>。接下来的指令<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = x + 1</samp>会生成<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，但没有实际效果，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>已经是活跃的。最后，指令<samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 4</samp>会杀死<samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>，使得在基本块开始时没有任何活跃变量。[表
    19-3](chapter19.xhtml#tab19-3)总结了[清单 19-22](chapter19.xhtml#list19-22)中每条指令之后哪些变量是活跃的。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-3:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Live Variables After Each Instruction in [Listing 19-22](chapter19.xhtml#list19-22)</samp>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 19-3：</samp> <samp class="SANS_Futura_Std_Book_11">[清单
    19-22](chapter19.xhtml#list19-22)中每条指令后的活跃变量</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Live
    variables</samp> |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">活跃变量</samp>
    |'
- en: '| --- | --- |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Beginning of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">块的开始</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3 * x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y}</samp>
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3 * x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y}</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
- en: Static variables complicate things, much like they did during reaching copies
    analysis. We don’t know how other functions will interact with any static variables
    that we encounter; they could read them, update them, or both. We’ll assume that
    every function reads every static variable. This assumption is conservative, since
    it prevents us from eliminating earlier writes to those variables. [Listing 19-23](chapter19.xhtml#list19-23)
    gives the pseudocode for the transfer function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量使事情变得复杂，正如在到达拷贝分析时那样。我们不知道其他函数将如何与遇到的静态变量交互；它们可能会读取、更新，或者同时执行这两者。我们假设每个函数都会读取每个静态变量。这个假设是保守的，因为它防止我们忽略之前对这些变量的写操作。[列表
    19-23](chapter19.xhtml#list19-23)给出了传递函数的伪代码。
- en: '[PRE60]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-23: The transfer
    function for liveness analysis</samp>'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 19-23：活跃性分析的传递函数</samp>
- en: We’ll start with the set of variables that are live at the end of the block
    ❶, then process the list of instructions in reverse ❷. We annotate each instruction
    with the set of variables that are live just after it executes ❸; we’ll use this
    annotation later to figure out whether the instruction is a dead store. Then,
    we calculate which variables are live just before the instruction. We’ll kill
    its destination if it has one, then add every variable that it reads. [Listing
    19-23](chapter19.xhtml#list19-23) includes the pseudocode to handle the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction, which updates
    one operand and reads two others, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    instruction, which reads an operand but doesn’t update anything. It omits the
    pseudocode to handle most of the other instructions, since they follow the same
    pattern. <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> is the one
    special case; we’ll kill its destination and add its arguments, as usual, but
    we’ll add every static variable too ❹. Finally, we’ll annotate the whole block
    with the variables that are live before the first instruction ❺. The meet operator
    will use this information later.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在块结束时活跃的变量集合 ❶ 开始，然后反向处理指令列表 ❷。我们用每条指令执行后活跃的变量集合对每条指令进行注释 ❸；稍后我们将使用这些注释来判断指令是否是死存储。接下来，我们计算指令执行前活跃的变量。如果它有目标变量，我们将把它杀死，然后添加每个它读取的变量。[列表
    19-23](chapter19.xhtml#list19-23)包括了处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    指令的伪代码，该指令更新一个操作数并读取两个操作数，和 <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    指令，该指令读取一个操作数但不更新任何内容。大多数其他指令的伪代码没有包括，因为它们遵循相同的模式。<samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    是一个特例；我们将像往常一样杀死它的目标并添加它的参数，但我们还将添加所有静态变量 ❹。最后，我们将用块中第一条指令前活跃的变量对整个块进行注释 ❺。Meet
    运算符将在稍后使用这些信息。
- en: There are a couple of ways to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">all_static_variables</samp>.
    One option is to scan this TACKY function and look for static variables before
    you start the dead store elimination pass. Another option is to scan the whole
    symbol table for static variables, without worrying about which variables show
    up in which functions. There’s no harm in adding superfluous static variables
    here, since they won’t change which instructions we eventually eliminate.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">all_static_variables</samp>
    有几种方法。一种选择是扫描这个 TACKY 函数，在开始死存储消除过程之前寻找静态变量。另一种选择是扫描整个符号表中的静态变量，而不必担心哪些变量出现在哪些函数中。在这里添加多余的静态变量没有害处，因为它们不会改变我们最终消除的指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp>
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Meet 运算符</samp>
- en: The meet operator calculates which variables are live at the end of a basic
    block. To find the live variables at the end of some block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    we’ll look at all of its successors. If a variable is live at the start of at
    least one successor, it must also be live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    because there’s at least one path from the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    through that successor to an instruction that generates that variable. Basically,
    we’ll take the set union of all the live variables at the start of all the block’s
    successors.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: meet 运算符计算基本块结束时哪些变量是活跃的。为了找出某个块 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    结束时哪些变量是活跃的，我们将查看它的所有后继节点。如果一个变量在至少一个后继节点的起始位置是活跃的，那么它在 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    结束时也一定是活跃的，因为从 <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> 结束到通过该后继节点到达生成该变量的指令之间至少存在一条路径。基本上，我们将取所有后继节点起始位置的活跃变量的集合并集。
- en: We’ll assume that every static variable is live at the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>
    node. Other functions, or other invocations of the current function, might read
    those variables. Variables with automatic storage duration are all dead at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, since they’re not accessible
    after we leave the function. The pseudocode in [Listing 19-24](chapter19.xhtml#list19-24)
    defines the meet operator.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设每个静态变量在 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> 节点是活跃的。其他函数或当前函数的其他调用可能会读取这些变量。具有自动存储持续时间的变量在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> 处都是死的，因为在离开函数后，它们无法访问。[清单
    19-24](chapter19.xhtml#list19-24) 中的伪代码定义了 meet 运算符。
- en: '[PRE61]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-24: The meet operator
    for liveness analysis</samp>'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 19-24：生存性分析中的 meet 运算符</samp>
- en: In reaching copies analysis, we were looking for copies that appeared on *every*
    path to a point, so we used set intersection as our meet operator. In liveness
    analysis, we want to know if a variable is used on *any* path from a point, so
    we use set union instead. This is unrelated to the fact that one analysis is forward
    and the other is backward. Some forward analyses use set union because they care
    whether at least one path to a point has some property. Some backward analyses
    use set intersection because they care whether every path from a point has some
    property. Other, more complex analyses don’t use set union or intersection, and
    instead use different meet operators entirely.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达副本分析中，我们寻找的是出现在*每一条*路径上的副本，因此我们使用集合交集作为 meet 运算符。在生存性分析中，我们想知道一个变量是否在从某一点出发的*任何*路径上被使用，因此我们改为使用集合并集。这与一种分析是前向的，另一种是后向的无关。有些前向分析使用集合并集，因为它们关心是否至少有一条路径到达某个点并具有某些属性。有些后向分析使用集合交集，因为它们关心从某个点出发的每条路径是否具有某些属性。其他一些更复杂的分析则不使用集合并集或交集，而是使用完全不同的
    meet 运算符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp>
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">迭代算法</samp>
- en: Finally, we’ll implement the iterative algorithm for liveness analysis. This
    differs from the iterative algorithm in [Listing 19-17](chapter19.xhtml#list19-17)
    in a couple of ways. First, when the annotation on a block changes, we’ll add
    its predecessors, rather than its successors, to the worklist. Second, we’ll use
    a different initial block annotation. Recall that each block’s initial annotation
    should be the identity element for the meet operator. Since our meet operator
    is set union, the initial annotation is the empty set. As we analyze more paths
    from a block to later points in the program, we’ll add more live variables to
    this set.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现生存性分析的迭代算法。这与[清单 19-17](chapter19.xhtml#list19-17)中的迭代算法有几个不同之处。首先，当一个代码块的注解发生变化时，我们将把它的前驱节点，而不是后继节点，添加到工作列表中。其次，我们将使用不同的初始块注解。回想一下，每个块的初始注解应该是
    meet 运算符的单位元素。由于我们的 meet 运算符是集合并集，因此初始注解是空集。当我们分析更多从块到程序后续点的路径时，我们会将更多的活跃变量添加到这个集合中。
- en: I won’t provide the pseudocode for the backward iterative algorithm, since it’s
    so similar to the forward algorithm we’ve already defined. But I will give you
    a couple of tips about how to implement it. First, you may want to initialize
    the worklist in postorder. (Recall that you sort the nodes of a graph in postorder
    by performing a depth-first traversal and visiting each node after you’ve visited
    its successors.) This makes the backward algorithm terminate faster, just like
    initializing the worklist in reverse postorder helps the forward algorithm terminate
    faster. This ordering means that whenever possible, you’ll visit each block only
    after you’ve visited all of its successors.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会提供反向迭代算法的伪代码，因为它与我们之前定义的前向算法非常相似。但我会给你一些关于如何实现它的建议。首先，你可能希望在后序遍历时初始化工作列表。（回忆一下，通过执行深度优先遍历并在访问所有后继节点后访问每个节点来对图的节点进行后序排序。）这种方式使得反向算法能更快结束，就像在反向后序排序中初始化工作列表能帮助前向算法更快结束一样。这个顺序意味着，只要可能，你将在访问完所有后继节点后才访问每个块。
- en: My second tip is to make your backward iterative algorithm reusable. In the
    next chapter, we’ll implement liveness analysis again, this time for assembly
    programs. The details of the meet operator and transfer function will change,
    but the iterative algorithm won’t. Try to structure your code so that you’ll be
    able to reuse the same iterative algorithm with a different meet operator and
    transfer function; then, you’ll be able to use it to analyze assembly programs
    in the next chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第二个建议是使你的反向迭代算法具有可重用性。在下一章中，我们将再次实现活跃性分析，这次是针对汇编程序的。meet 操作符和传递函数的细节会有所不同，但迭代算法不会改变。尝试将代码结构化，以便能够使用不同的
    meet 操作符和传递函数重用相同的迭代算法；这样，你就可以在下一章中用它来分析汇编程序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Dead Stores</samp>
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">移除无效存储</samp>
- en: 'After we run liveness analysis, we’ll find any dead stores in the TACKY function
    and remove them. An instruction is a dead store if its destination is dead as
    soon as we execute it, like in the following example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行活跃性分析后，我们将找到 TACKY 函数中的所有无效存储并将其删除。如果一条指令的目标在执行时变为死值，那它就是无效存储，像下面这个例子：
- en: '[PRE62]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Liveness analysis will tell us that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>,
    making that instruction safe to delete. We’ll never delete function calls, even
    when they update dead variables, because they may have other side effects. We
    also won’t delete instructions without destinations, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>. [Listing 19-25](chapter19.xhtml#list19-25)
    demonstrates how to identify a dead store.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃性分析会告诉我们，在执行完 <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp> 后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 已经变为死值，这使得该指令可以安全删除。我们永远不会删除函数调用，即使它们更新了死变量，因为这些调用可能有其他副作用。我们也不会删除没有目标的指令，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>。
    [列表 19-25](chapter19.xhtml#list19-25) 展示了如何识别无效存储。
- en: '[PRE63]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-25: Identifying
    a dead store</samp>'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 19-25：识别无效存储</samp>
- en: If you completed only [Part I](part1.xhtml), you’ve learned everything you need
    to know about dead store elimination! You can skip straight to the test suite.
    Otherwise, read on to learn how to handle the types and instructions we added
    in [Part II](part2.xhtml).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只完成了 [第一部分](part1.xhtml)，你已经学到了关于无效存储消除所需的所有知识！你可以直接跳到测试套件了。否则，请继续阅读，了解我们在
    [第二部分](part2.xhtml) 中添加的类型和指令如何处理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  id: totrans-388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">支持第二部分 TACKY 程序</samp>
- en: 'To update the transfer function, we’ll need to think through which live variables
    each new instruction might generate or kill. The type conversion instructions,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>,
    are straightforward. Each one generates its source operand and kills its destination,
    much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instructions we already handle.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> also follows the usual
    pattern: it generates both source operands and kills its destination.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新传递函数，我们需要思考每个新指令可能生成或删除哪些活跃变量。类型转换指令，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>，是直接的。每个指令都会生成它的源操作数并删除它的目标操作数，就像我们已经处理过的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    指令一样。<samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> 也遵循相同的模式：它生成两个源操作数并删除它的目标。
- en: 'The operations on pointers and aggregate types are trickier. Pointers cause
    essentially the same problem they did in reaching copies analysis: when we read
    or write through a pointer, we can’t tell which underlying object is being accessed.
    When in doubt, we should err on the conservative side and assume that a variable
    is live. Therefore, reading through a pointer should generate every aliased variable,
    but writing through a pointer shouldn’t kill any of them. We’ll take a similar
    approach to aggregate variables: reading part of an aggregate variable will generate
    it, but updating part of it won’t kill it. I won’t provide updated pseudocode
    for the transfer function; now that we’ve covered the key points, I’ll let you
    work through the remaining details on your own. The meet operator won’t change;
    in particular, static variables are still live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>,
    but other aliased variables aren’t, because their lifetimes end when the function
    returns.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 指针和聚合类型的操作更加复杂。指针引发的基本问题和我们在分析拷贝时遇到的问题一样：当我们通过指针进行读取或写入时，我们无法判断是哪个底层对象被访问了。在不确定的情况下，我们应采取保守的方式，假设变量是活跃的。因此，通过指针读取应该生成所有别名变量，但通过指针写入不应删除任何一个变量。我们将对聚合变量采取类似的方法：读取聚合变量的部分内容将生成它，但更新它的部分内容不会使其失效。我不会提供传递函数的更新伪代码；现在我们已经覆盖了关键点，剩下的细节就交给你自己去处理。meet
    操作符不会改变；特别是，静态变量在 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> 时仍然是活跃的，但其他别名变量不是，因为它们的生命周期在函数返回时结束。
- en: 'Finally, let’s update the last step in this optimization, where we use the
    results of liveness analysis to find dead stores and eliminate them. We’ll never
    eliminate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction,
    since we don’t know whether its destination is dead. Even if every single variable
    in the current function is dead, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    might still have a visible side effect. For instance, it could update an object
    defined in a different function, like in the following example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新这个优化中的最后一步，我们利用活跃性分析的结果来查找死存储并消除它们。我们永远不会消除 <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    指令，因为我们无法知道它的目的地是否已死。即使当前函数中的每一个变量都已死，<samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    指令仍然可能有可见的副作用。例如，它可能会更新一个在不同函数中定义的对象，就像以下示例所示：
- en: '[PRE64]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction,
    there are no live variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">update_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">through _pointer</samp>. But that instruction
    clearly isn’t a dead store; it updates an object that our analysis didn’t track
    but that will likely be read later in the program.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> 指令之后，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">update_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">through _pointer</samp> 中没有活跃的变量。但显然，该指令并不是死存储；它更新了一个我们分析未跟踪的对象，但该对象很可能会在程序后续中被读取。
- en: The usual logic for spotting dead stores applies to all the other instructions
    from [Part II](part2.xhtml), including <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 识别死存储的常见逻辑适用于[第二部分](part2.xhtml)中的所有其他指令，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'In this chapter, you implemented four important compiler optimizations: constant
    folding, unreachable code elimination, copy propagation, and dead store elimination.
    You learned how these optimizations work together to transform the TACKY representation
    of a program, resulting in smaller, faster, simpler assembly code than your compiler
    produced before. You also learned how to construct a control-flow graph and perform
    data-flow analysis. These techniques are fundamental to many different optimizations,
    not just the ones we covered in this chapter. If you ever want to implement more
    TACKY optimizations on your own, you’ll be well prepared.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你实现了四个重要的编译器优化：常量折叠、不可达代码消除、复制传播和死存储消除。你学习了这些优化如何协同工作，转换程序的TACKY表示形式，从而生成比以前的编译器生成的更小、更快、更简洁的汇编代码。你还学习了如何构建控制流图并执行数据流分析。这些技术是许多不同优化的基础，不仅限于我们在本章中讨论的优化。如果你将来想自己实现更多TACKY优化，你将做好充分的准备。
- en: In the next chapter, you’ll write a register allocator. You’ll use a graph coloring
    algorithm to map pseudoregisters to hardware registers, and you’ll learn how to
    spill a register when graph coloring fails and you run out of registers. You’ll
    also use a technique called register coalescing to clean up many of the unnecessary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions in your
    assembly code. By the end of the chapter, your assembly programs still won’t look
    quite like what a production compiler would generate, but they’ll be a lot closer.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将编写一个寄存器分配器。你将使用图着色算法将伪寄存器映射到硬件寄存器，并学习如何在图着色失败且寄存器不足时溢出寄存器。你还将使用一种叫做寄存器合并的技术，清除汇编代码中许多不必要的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令。到本章结束时，你的汇编程序仍然不像生产编译器生成的那样，但会接近得多。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">附加资源</samp>
- en: This section lists the resources I referred to while writing this chapter, organized
    by topic.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了我在写这一章时参考的资源，按主题组织。
- en: '**Security implications of compiler optimizations**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器优化的安全隐患**'
- en: “Dead Store Elimination (Still) Considered Harmful” by Zhaomo Yang et al. surveys
    the different ways programmers try to avoid unwanted dead store elimination and
    the limits of each approach (*[https://<wbr>www<wbr>.usenix<wbr>.org<wbr>/system<wbr>/files<wbr>/conference<wbr>/usenixsecurity17<wbr>/sec17<wbr>-yang<wbr>.pdf](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf)*).
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zhaomo Yang等人的《死存储消除（仍然）被认为有害》调查了程序员尝试避免不必要的死存储消除的不同方法，以及每种方法的局限性 (*[https://<wbr>www<wbr>.usenix<wbr>.org<wbr>/system<wbr>/files<wbr>/conference<wbr>/usenixsecurity17<wbr>/sec17<wbr>-yang<wbr>.pdf](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf)*).
- en: “The Correctness-Security Gap in Compiler Optimization” by Vijay D’Silva, Mathias
    Payer, and Dawn Song looks at the security impact of a few different compiler
    optimizations and formalizes some of the security properties that optimizations
    should preserve (*[https://<wbr>ieeexplore<wbr>.ieee<wbr>.org<wbr>/stamp<wbr>/stamp<wbr>.jsp<wbr>?tp<wbr>=&arnumber<wbr>=7163211](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7163211)*).
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vijay D’Silva、Mathias Payer和Dawn Song的《编译器优化中的正确性-安全性差距》探讨了几种不同编译器优化对安全性的影响，并对优化应保持的安全性特性进行了形式化定义
    (*[https://<wbr>ieeexplore<wbr>.ieee<wbr>.org<wbr>/stamp<wbr>/stamp<wbr>.jsp<wbr>?tp<wbr>=&arnumber<wbr>=7163211](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7163211)*).
- en: '**Data-flow analysis**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据流分析**'
- en: '[Chapter 9](chapter9.xhtml) of *Compilers: Principles, Techniques, and Tools*,
    2nd edition, by Alfred V. Aho et al. (Addison-Wesley, 2006) defines data-flow
    analysis more rigorously than I did here. It also proves that the iterative algorithm
    is correct and terminates in a reasonable amount of time and discusses the use
    of reverse postorder traversal (which it calls *depth-first ordering*) in this
    algorithm.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《编译原理：原理、技术与工具》第2版，第9章，Alfred V. Aho等人（Addison-Wesley，2006）对数据流分析进行了比我在这里更严谨的定义。它还证明了迭代算法是正确的，并在合理的时间内终止，并讨论了反向后序遍历（它称之为*深度优先排序*）在此算法中的应用。
- en: Paul Hilfinger’s lecture slides from CS164 at UC Berkeley give an example-heavy
    overview of the same material (*[https://<wbr>inst<wbr>.eecs<wbr>.berkeley<wbr>.edu<wbr>/~cs164<wbr>/sp11<wbr>/lectures<wbr>/lecture37<wbr>-2x2<wbr>.pdf](https://inst.eecs.berkeley.edu/~cs164/sp11/lectures/lecture37-2x2.pdf)*).
    I found the explanation of liveness analysis in these slides particularly helpful.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paul Hilfinger在UC Berkeley的CS164课程讲座幻灯片提供了关于相同材料的实例丰富的概述 (*[https://inst.eecs.berkeley.edu/~cs164/sp11/lectures/lecture37-2x2.pdf](https://inst.eecs.berkeley.edu/~cs164/sp11/lectures/lecture37-2x2.pdf)*)。我发现这些幻灯片中关于活跃性分析的解释特别有帮助。
- en: Eli Bendersky’s blog post “Directed Graph Traversal, Orderings and Applications
    to Data-Flow Analysis” describes how to sort graphs in postorder and reverse postorder
    to speed up data-flow analysis (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2015<wbr>/directed<wbr>-graph<wbr>-traversal<wbr>-orderings<wbr>-and<wbr>-applications<wbr>-to<wbr>-data<wbr>-flow<wbr>-analysis](https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis)*).
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eli Bendersky的博客文章《有向图遍历、排序与数据流分析的应用》描述了如何通过后序和反向后序排序图形，以加速数据流分析 (*[https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis](https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis)*).
- en: '**Copy propagation**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制传播**'
- en: 'Every discussion of reaching copies analysis seems to formulate it slightly
    differently. The version in this chapter draws on Jeffrey Ullman’s lecture notes
    on *Compilers: Principles, Techniques, and Tools* (*[http://<wbr>infolab<wbr>.stanford<wbr>.edu<wbr>/~ullman<wbr>/dragon<wbr>/slides3<wbr>.pdf](http://infolab.stanford.edu/~ullman/dragon/slides3.pdf)*
    and *[http://<wbr>infolab<wbr>.stanford<wbr>.edu<wbr>/~ullman<wbr>/dragon<wbr>/slides4<wbr>.pdf](http://infolab.stanford.edu/~ullman/dragon/slides4.pdf)*).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次讨论到达副本分析时，似乎都用稍微不同的方式进行表述。本章中的版本借鉴了Jeffrey Ullman在《编译原理：原理、技术与工具》中的讲义 (*[http://infolab.stanford.edu/~ullman/dragon/slides3.pdf](http://infolab.stanford.edu/~ullman/dragon/slides3.pdf)*
    和 *[http://infolab.stanford.edu/~ullman/dragon/slides4.pdf](http://infolab.stanford.edu/~ullman/dragon/slides4.pdf)*).
- en: I’ve borrowed the idea of deleting redundant copies from LLVM’s low-level copy
    propagation pass (*[https://<wbr>llvm<wbr>.org<wbr>/doxygen<wbr>/MachineCopyPropagation<wbr>_8cpp<wbr>_source<wbr>.html](https://llvm.org/doxygen/MachineCopyPropagation_8cpp_source.html)*).
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我借用了LLVM低级复制传播阶段删除冗余副本的想法 (*[https://llvm.org/doxygen/MachineCopyPropagation_8cpp_source.html](https://llvm.org/doxygen/MachineCopyPropagation_8cpp_source.html)*).
- en: '**Alias analysis**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**别名分析**'
- en: You can find a quick overview of alias analysis algorithms in Phillip Gibbons’s
    lecture slides from his Carnegie Mellon course on compiler optimizations (*[https://<wbr>www<wbr>.cs<wbr>.cmu<wbr>.edu<wbr>/afs<wbr>/cs<wbr>/academic<wbr>/class<wbr>/15745<wbr>-s16<wbr>/www<wbr>/lectures<wbr>/L16<wbr>-Pointer<wbr>-Analysis<wbr>.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L16-Pointer-Analysis.pdf)*).
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Phillip Gibbons的讲座幻灯片中找到关于别名分析算法的简要概述，这些幻灯片来自他在卡内基梅隆大学的编译器优化课程 (*[https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L16-Pointer-Analysis.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L16-Pointer-Analysis.pdf)*).
