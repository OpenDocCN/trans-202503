- en: '![](../images/pg556.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-51.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">19</samp> <samp class="SANS_Dogma_OT_Bold_B_11">OPTIMIZING
    TACKY PROGRAMS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the first two parts of this book, you wrote a compiler that supported much
    of the C language. You made sure that the executable programs you produced were
    correct— in other words, that their behavior conformed to the C standard—but you
    didn’t worry about their performance. You didn’t try to make them run faster,
    take up less storage space, or consume less memory. In [Part III](part3.xhtml),
    you’ll focus on *optimizing* these programs—that is, making them smaller and faster
    without changing their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some compiler optimizations are *machine-independent*. This means they aren’t
    affected by the details of the target architecture, like the number of available
    registers or constraints on specific assembly instructions. A compiler typically
    performs these optimizations on an intermediate representation like TACKY before
    converting it to assembly. *Machine-dependent* optimizations, on the other hand,
    need to take the target architecture into account, so these are usually performed
    later, after the program has been converted to assembly. This chapter covers four
    widely used machine-independent optimizations: constant folding, unreachable code
    elimination, copy propagation, and dead store elimination. You’ll add a new optimization
    stage, bolded in the diagram at the start of the chapter, to apply these four
    optimizations to TACKY programs. The next chapter covers register allocation,
    a machine-dependent optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to complete [Part II](part2.xhtml) before you start on [Part
    III](part3.xhtml). For each optimization, we’ll start with an implementation that
    doesn’t account for the language features from [Part II](part2.xhtml). Then, if
    necessary, we’ll extend it to support those features; you’ll skip this step if
    you didn’t do [Part II](part2.xhtml). We’ll need this extra step for every optimization
    except unreachable code elimination, which isn’t affected by the features from
    [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'These two chapters include just a few of the optimizations you’d find in a
    production compiler, but the basic concepts we’ll cover apply to lots of other
    optimizations too. Before we get started, let’s consider a question that’s fundamental
    to every compiler optimization: How do we know our optimized code is correct?'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Safety and Observable Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First and foremost, compiler optimizations must be *safe*, meaning they cannot
    change the program’s semantics. (It doesn’t matter how speedy your program is
    if it doesn’t behave correctly!) In particular, an optimization must not change
    the program’s *observable behavior*, which is the behavior visible to its execution
    environment. Returning an exit status, printing a message to stdout, and writing
    to a file are all examples of observable behavior. Most of the actions that a
    program takes—like calculating values, updating local variables, and transferring
    control from one statement to another—are not visible to the execution environment,
    so they affect the program’s observable behavior only indirectly. This gives us
    lots of flexibility to transform the program. We can reorder, replace, and even
    delete code as long as the observable behavior doesn’t change.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how GCC optimizes a simple C program. [Listing 19-1](chapter19.xhtml#list19-1)
    initializes three variables with the values <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>,
    then adds them up and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-1: A C program that
    adds three variables</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This program will have the same observable behavior every time it runs: it
    will terminate with an exit status of <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>.
    You can run the following command to compile the program without optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will produce the assembly in [Listing 19-2](chapter19.xhtml#list19-2),
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-2: The unoptimized
    assembly for [Listing 19-1](chapter19.xhtml#list19-1)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This assembly program faithfully implements [Listing 19-1](chapter19.xhtml#list19-1)’s
    source code: it initializes three locations on the stack with the values <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>; adds them up; and
    then returns the result in EAX. Now let’s compile the same source code with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp> switch to enable optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the assembly in [Listing 19-3](chapter19.xhtml#list19-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-3: The optimized
    assembly for [Listing 19-1](chapter19.xhtml#list19-1)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of initializing three variables and then adding them up, this assembly
    program just returns the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp>.
    [Listings 19-2](chapter19.xhtml#list19-2) and [19-3](chapter19.xhtml#list19-3)
    look quite different, but they both produce the right observable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Four TACKY Optimizations</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section introduces the optimizations we’ll implement in this chapter:
    constant folding, unreachable code elimination, copy propagation, and dead store
    elimination. These optimizations aim to speed up our code and reduce the amount
    of space it takes up. Individually, some of them further one or both of these
    goals, while others aren’t particularly helpful on their own. The real payoff
    comes from the way they work together, because running any one of them creates
    new opportunities to apply the other three. We’ll look at these four optimizations
    in turn, then discuss how each one makes the others more effective.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump in, be aware that I’ll use minimal notation in most of this chapter’s
    TACKY listings. I’ll write copies as <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(Var("x"),
    Var("y"))</samp>, as I’ve occasionally done in earlier chapters, and I’ll take
    similar shortcuts with other instructions. For example, I’ll write binary operations
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a + b</samp> instead of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, Var("a"), Var("b"), Var("x"))</samp>
    and labels as <samp class="SANS_TheSansMonoCd_W5Regular_11">Target:</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(Target)</samp>. This notation
    lets us focus on the high-level logic of our TACKY programs, not the details of
    each TACKY instruction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *constant folding* pass evaluates constant expressions at compile time.
    For example, constant folding will replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    TACKY instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Constant folding can also turn conditional jumps into unconditional jumps or
    eliminate them entirely. It will transform
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: into
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: because the program will always make this jump. It will also delete the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: because the program will never make this jump. (Deleting useless jumps is often
    considered a type of dead code elimination rather than constant folding, but we’re
    transforming conditional jumps in this pass anyway, so we might as well delete
    the useless ones too.)
  prefs: []
  type: TYPE_NORMAL
- en: Constant folding helps with both speed and code size. A single arithmetic operation
    or comparison might require several assembly instructions. Some of those instructions,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, are quite slow.
    Constant folding ultimately replaces that assembly code with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unreachable Code
    Elimination</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Unreachable code elimination* removes instructions that we know will never
    run. Consider the fragment of TACKY in [Listing 19-4](chapter19.xhtml#list19-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-4: A fragment of
    TACKY with an unreachable instruction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ll always jump over the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">my_function</samp>,
    we can get rid of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction
    is useless, since it jumps to the instruction that we’d execute next anyway. We’ll
    remove this instruction too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can also eliminate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp>
    label, assuming no other instruction jumps to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions we
    just removed aren’t unreachable code; a running program will reach both of them,
    though they won’t have any effect. But removing unreachable code often makes jumps
    and labels useless, so this pass is a logical place to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating unreachable code clearly reduces code size. It’s also pretty clear
    that removing useless jumps saves time; even a useless instruction takes some
    amount of time to execute. It turns out that removing truly unreachable instructions,
    like the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> in [Listing
    19-4](chapter19.xhtml#list19-4), can speed up the program too, by reducing memory
    pressure and freeing up space in the processor’s instruction cache.
  prefs: []
  type: TYPE_NORMAL
- en: Removing unused labels, on the other hand, won’t impact speed or code size,
    since labels don’t become machine instructions in the final executable. We’ll
    remove these labels anyway because it makes our TACKY programs a bit easier to
    read and debug and requires very little extra work.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pass is especially handy for cleaning up the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction we add to the end of every TACKY function. Recall that we add this
    instruction as a backstop in case the source code is missing a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. When we convert a program to TACKY, we can’t tell whether this extra
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> is necessary, so we
    end up adding it to functions that don’t need it. The unreachable code elimination
    pass removes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions that we added unnecessarily, while retaining any that we actually
    need. This is one example of a broader principle: generating inefficient code
    and optimizing it later is often easier than generating efficient code to begin
    with.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copy Propagation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a program includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">dst = src</samp>, the
    *copy propagation* pass tries to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> in later instructions.
    Take the following snippet of TACKY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with
    its current value, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Replacing a variable with a constant is a special case of copy propagation called
    *constant propagation*. In other cases, we’ll replace one variable with another.
    For instance, we can rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, figuring out whether it’s safe to perform copy propagation can be
    tricky. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Depending on which path we take, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s
    value will be either <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> when we reach the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. Since we don’t
    know which path we’ll take to that instruction, we can’t safely replace <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with either value. To handle
    cases like this one, we’ll need to analyze every possible path to the instruction
    we’d like to rewrite. We’ll use a technique called *data-flow analysis* to look
    at all the paths through a function and find the places where we can perform copy
    propagation safely. Data-flow analysis isn’t just useful for copy propagation;
    it’s used in lots of different compiler optimizations, including dead store elimination,
    which we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the copies we analyze will involve variables with static storage duration,
    which can be accessed by multiple functions (or just multiple invocations of the
    same function, in the case of local static variables). We won’t always be able
    to tell exactly when these variables are updated, so our data-flow analysis will
    need to treat them a bit differently than variables with automatic storage duration.
    If you completed [Part II](part2.xhtml), you’ll need to account for similar uncertainty
    around variables whose address is taken with the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator, since they can be updated through pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy propagation isn’t useful by itself, but it makes our other optimizations
    more effective. When we propagate constants, we create new opportunities for constant
    folding. And we’ll sometimes replace every use of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction’s destination with its source, which makes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    itself useless. We’ll remove these useless instructions in our last optimization
    pass: dead store elimination.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dead Store Elimination</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When an instruction updates a variable’s value but we never use that new value,
    the instruction is called a *dead store*. (The term *store* here refers to any
    instruction that stores a value in a variable, not the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction we introduced in [Part II](part2.xhtml).) Because dead stores don’t
    impact a program’s observable behavior, it’s safe to remove them. Let’s look at
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has automatic
    storage duration, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> is a dead store. We don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    between this instruction and the end of the function, which is also the end of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another kind of dead store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’ll never use the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    + b</samp>, because we’ll overwrite it first; this means <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a + b</samp> is a dead store. The dead store elimination pass will identify
    such useless instructions and remove them. The challenge is proving that an instruction
    really is a dead store; to do this, we’ll need to analyze every path through the
    function and make sure that the value it assigns to its destination is never used.
    Once again, we’ll use data-flow analysis to figure out when we can apply this
    optimization safely.
  prefs: []
  type: TYPE_NORMAL
- en: Like copy propagation, dead store elimination gets more complicated when you
    factor in objects that can be accessed by multiple functions or through pointers.
    For instance, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a global
    variable, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    in our first example is *not* a dead store; <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    might be used after the function returns. Our data-flow analysis will have to
    take this possibility into account.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">With Our Powers
    Combined …</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how the four optimizations we’ll implement in this chapter
    work together. We’ll use the TACKY program in [Listing 19-5](chapter19.xhtml#list19-5)
    as a running example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-5: An unoptimized
    TACKY program</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using all four optimizations, we can reduce this function to a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction. I’ll display
    the results of each round of optimization, highlighting any changed instructions.
    Because each optimization can create more opportunities to apply the other three,
    we’ll need to run most of them several times to fully optimize this function.
    For now, we’ll decide which optimization to run at each step in an ad hoc way,
    by looking at the code and seeing which one will be most useful. We’ll use a more
    systematic approach when we actually implement our optimization pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a copy propagation pass, substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4 - x</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t replace the second use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>, because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> has more than one possible value
    at that point: it might be <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, depending on whether
    we take the conditional jump. Next, we’ll apply constant folding to evaluate <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 4 - 4</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By replacing a binary operation with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, we’ve created another opportunity for copy propagation. We can replace
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> with its value, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> depends
    on a constant condition, we can run constant folding again to turn it into an
    unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This change makes <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 3</samp>
    unreachable, so we’ll run unreachable code elimination to delete it. This pass
    will also remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    instruction and <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> label,
    which have no effect once we’ve removed <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 3</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We couldn’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + 5</samp>
    earlier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> had two
    different values on the different paths to that instruction. We just solved that
    problem by eliminating the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 3</samp>. Now we can run copy propagation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll run another round of constant folding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll run copy propagation one last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve managed to calculate this function’s return value at compile time, eliminating
    every use of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> in the process. Now
    we’ll run dead store elimination to clean up the instructions that assign to these
    three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll run unreachable code elimination to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNot
    Zero</samp> instruction and the <samp class="SANS_TheSansMonoCd_W5Regular_11">End</samp>
    label. These are both redundant, since we just eliminated the one instruction
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> jumps
    over. This last round of optimization will reduce our function to a single instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example highlighted some of the ways our optimizations work together. Copy
    propagation may replace variables with constants, creating new opportunities for
    constant folding; constant folding rewrites arithmetic operations as <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions, creating new opportunities for copy propagation. Constant folding
    can replace conditional jumps with unconditional ones, making some instructions
    unreachable; eliminating unreachable code simplifies the program’s control flow,
    which promotes copy propagation. Copy propagation may make <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions redundant, which lets us remove them during dead store elimination.
    And dead store elimination can potentially remove every instruction between a
    jump and the label it jumps to, which makes the jump, and possibly the label,
    candidates for unreachable code elimination.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know what each optimization does and how they all work together. Next,
    we’ll add a few new command line options that will allow us to test them out.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Testing the Optimization Passes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter’s tests work differently than the tests in earlier chapters. We
    need to verify that our optimizations don’t change the program’s observable behavior
    but do simplify constant expressions and remove useless code. Our current strategy—compiling
    C programs, running them, and making sure they behave correctly—satisfies the
    first requirement but not the second. Just running a program can’t tell you whether
    the optimization phase *did* anything. To address the second point, the test script
    will inspect your compiler’s assembly output for each test program. To address
    the first point, it will also run each test program and verify its behavior, like
    in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this chapter’s tests, you’ll need to add a few command line options
    to your compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> Directs your compiler
    to emit an assembly file, but not assemble or link it. Running <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-S
    /path/to/program.c</samp> should write an assembly file to */path/to/program.s*.
    (I suggested adding this option to help with debugging back in [Chapter 1](chapter1.xhtml);
    you’ll need to add it now if you haven’t already.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--fold-constants</samp> Enables
    constant folding.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--propagate-copies</samp> Enables
    copy propagation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-unreachable-code</samp> Enables
    unreachable code elimination.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--eliminate-dead-stores</samp> Enables
    dead store elimination.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--optimize</samp> Enables all four
    optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: The options to enable optimizations should be passed to the optimization stage,
    which we’ll implement next. It should be possible to enable more than one individual
    optimization; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--fold-constants
    --propagate-copies</samp> should enable both constant folding and copy propagation,
    but not the other two optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: If your compiler doesn’t generate assembly exactly the way I’ve laid out in
    this book, the test script should still be able to validate your assembly output
    for this chapter’s tests, but there are a couple of caveats to keep in mind. First,
    the test script understands only AT&T assembly syntax, which is the syntax we’ve
    been using throughout the book. Second, the script doesn’t recognize every single
    assembly instruction; it only knows about the instructions we’ve used in this
    book and a handful of others that are particularly common in real-world assembly
    code. If you emit instructions that the test script doesn’t understand, some tests
    may fail.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll wire up the new optimization stage, which will control when we call
    each individual optimization.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wiring Up the Optimization Stage</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optimization stage will run right after we convert the program to TACKY.
    This stage will optimize each TACKY function independently, without any knowledge
    of the other functions defined in the program. For example, it won’t try to evaluate
    function calls during the constant folding pass or remove them during dead store
    elimination. (We can’t remove function calls during dead store elimination because
    we don’t know whether they have side effects. We *can* remove them during unreachable
    code elimination, though—if a function call will never execute, it doesn’t matter
    what side effects the function has.) Optimizations like these, which transform
    one function at a time, are called *intraprocedural optimizations*. Most production
    compilers also perform *interprocedural optimizations*, which transform whole
    translation units instead of individual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Each individual optimization will take the body of a TACKY function as input
    and return a semantically equivalent function body as output. In the constant
    folding pass, we’ll represent the function body as a list of TACKY instructions,
    like we normally do. But in the other three optimization passes, we’ll represent
    each function as a *control-flow graph*. This is an intermediate representation
    that explicitly models the different execution paths through a piece of code.
    We’ll talk more about how to construct control-flow graphs and why they’re useful
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The optimization stage will process each function by running through all of
    the enabled optimizations over and over. It will stop once it reaches a *fixed
    point*, where running them again doesn’t change the function further. [Listing
    19-6](chapter19.xhtml#list19-6) illustrates this optimization pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-6: The TACKY optimization
    pipeline</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp>
    is the list of instructions in the body of a TACKY function and <samp class="SANS_TheSansMonoCd_W5Regular_11">enabled_optimizations</samp>
    is a list of strings representing the optimizations that we enabled on the command
    line. (This would be a pretty kludgy way to store command line options in a real
    program; feel free to represent these options differently in your own code.) If
    <samp class="SANS_TheSansMonoCd_W5Regular_11">function_body</samp> is empty, we’ll
    just return it, since there’s nothing to optimize. Otherwise, we’ll perform constant
    folding if it’s enabled ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll convert the function body from a list of instructions into a control-flow
    graph ❷. We’ll apply all the other enabled optimizations to this representation.
    Then, we’ll convert the optimized control-flow graph back to a list of instructions
    ❸, which we’ll compare to the original list ❹. If it’s different, and if we haven’t
    optimized away the entire function, we’ll go through the loop again to take advantage
    of any new optimization opportunities. If it’s the same, we can’t optimize it
    any further, so we’re done.
  prefs: []
  type: TYPE_NORMAL
- en: Using the optimization pipeline in [Listing 19-6](chapter19.xhtml#list19-6),
    we’ll never miss an optimization opportunity. Whenever one optimization changes
    the program, we’ll rerun the other three to take advantage of those changes. This
    is feasible because we’re implementing only four optimizations, and all of our
    test programs are small enough to optimize pretty quickly. Production compilers,
    which implement dozens of optimizations and compile much larger programs, don’t
    take this approach; if they did, compilation would take way too long. Instead,
    they apply a fixed sequence of optimizations just once, running each individual
    optimization in the place where it’s likely to have the biggest impact. As a result,
    they can end up missing optimization opportunities. (Finding the best order to
    run optimizations for any given program is an open research question called the
    *phase ordering problem*.)
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add the optimization pipeline to your compiler. For now, define
    each individual optimization as a stub that takes a list of instructions and returns
    them unchanged. You can stub out the conversions to and from control-flow graphs
    the same way. Write this plumbing code now so that you can test the individual
    optimization passes as you implement them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything is wired up, you can start on your first optimization: constant
    folding!'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Constant Folding</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constant folding is the simplest optimization in this chapter. This pass iterates
    through all the instructions in a TACKY function and evaluates any instructions
    with constant source operands. First, we’ll talk briefly about how to add constant
    folding to the version of the compiler you implemented in [Part I](part1.xhtml).
    Then, we’ll discuss how to handle the types and TACKY instructions you added in
    [Part II](part2.xhtml). If you haven’t worked through [Part II](part2.xhtml) yet,
    feel free to skip the latter discussion.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant Folding
    for Part I TACKY Programs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The constant folding pass should evaluate four of the TACKY instructions from
    [Part I](part1.xhtml): <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>. When you
    find a <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instruction
    with a constant source operand, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    instruction with two constant source operands, replace it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
    For example, you should replace'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Your constant folding pass could run into two kinds of invalid expressions:
    division by zero and operations that result in integer overflow. These are both
    undefined behaviors, so it doesn’t matter how you evaluate them. However, your
    compiler can’t just fail if it encounters one of these invalid expressions, because
    the program’s behavior is undefined only if it actually reaches the invalid expression
    at runtime. For example, if a program includes division by zero in a branch that’s
    never taken, you should still be able to compile it.'
  prefs: []
  type: TYPE_NORMAL
- en: You should also evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> instructions
    with constant conditions. If the condition is met, replace the instruction with
    an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>. If
    the condition isn’t met, remove the instruction from the program. That’s all there
    is to it! If you completed only [Part I](part1.xhtml), you can skip to the test
    suite once you’ve implemented constant folding for these four instructions. If
    you completed [Part II](part2.xhtml), there are a few more instructions you’ll
    need to handle.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we added the new arithmetic types in [Part II](part2.xhtml), we also added
    type conversion instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>.
    The constant folding pass should evaluate all of these instructions when their
    source operands are constants.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction can
    perform type conversions too; we use it to convert between signed and unsigned
    integers of the same size. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction copies an unsigned constant to a signed variable, or vice versa, this
    pass should convert the constant to the correct type. For example, if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, you should
    replace
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Be careful to perform every type conversion with exactly the same semantics
    that the program would use at runtime. For example, when you convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an integer type, truncate its value toward zero; when you convert an integer
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, round to the
    nearest representable value. The good news is that you already know how to perform
    all of these type conversions at compile time, since you had to convert static
    initializers to the correct type throughout [Part II](part2.xhtml). Ideally, you’ll
    be able to reuse the code you’ve already written to perform these type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to adhere to C semantics when you evaluate unsigned arithmetic
    operations. In particular, you should ensure that unsigned arithmetic wraps around,
    like it would at runtime. How you accomplish this will depend entirely on what
    language you’re writing your compiler in. Some languages support wraparound unsigned
    arithmetic as part of their standard library. In Rust, for example, methods like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wrapping_sub</samp>
    provide the same semantics as unsigned arithmetic in C. In other languages, you
    might use a third-party library for unsigned arithmetic. For example, Python doesn’t
    provide unsigned integer types, but the NumPy library does. If you don’t want
    to use an external library, or you can’t find a suitable one, it isn’t terribly
    difficult to implement wraparound unsigned arithmetic yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when you evaluate floating-point operations, you’ll need to use round-to-nearest,
    ties-to-even rounding and handle negative zero and infinity correctly. If you
    added support for NaN for extra credit in [Chapter 13](chapter13.xhtml), you’ll
    need to evaluate operations on NaN correctly too. This shouldn’t require any special
    effort on your part—the vast majority of programming languages use IEEE 754 semantics—but
    there’s a small chance that your implementation language handles negative zero,
    NaN, or infinity differently than C. Start with a simple implementation of constant
    folding that doesn’t try to address these edge cases; you can rely on the test
    suite to catch any problems. If you run into any cases that your implementation
    language doesn’t evaluate correctly, you have two options: either find a third-party
    library to handle them for you or evaluate them yourself as a special case.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Control-Flow Graphs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the rest of the chapter, we’ll represent TACKY functions as control-flow
    graphs. A graph representation is a good fit for our remaining optimizations,
    which have to account for the different paths we might take through a function.
    The nodes in the control-flow graph represent sequences of straight-line code
    called *basic blocks*, except for two special nodes that represent the function’s
    entry and exit points. Each node has outgoing edges to the nodes that could execute
    immediately after it.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s look at the control-flow graph for [Listing 19-7](chapter19.xhtml#list19-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-7: A TACKY function
    with multiple execution paths</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This function executes a loop that repeatedly retrieves a value by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp>, then processes that
    value by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">get_input</samp> ever returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this function immediately
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">process_input</samp>
    ever returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, the function
    immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. [Figure
    19-1](#fig19-1) shows the corresponding control-flow graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-1: The control-flow
    graph for [Listing 19-7](chapter19.xhtml#list19-7) [Description](description-52.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a single outgoing edge from the special <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    node to block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>,
    since we’ll always execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> at the start of the function.
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> will have exactly
    one outgoing edge in every control-flow graph, since C functions have only one
    entry point.) After we execute <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, there are two possibilities:
    we can execute the next block in the program, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, or we can jump to block
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    has outgoing edges to both of those blocks. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp> has outgoing edges to both
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction exits
    the function, so <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">3</samp>
    each have a single outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Control-Flow
    Graph</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know what a control-flow graph looks like, let’s look at how to
    construct one. First, we’ll define the graph data structure. [Listing 19-8](chapter19.xhtml#list19-8)
    sketches out one possible representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-8: One way to represent
    the control-flow graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Every node in the graph has a unique <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp>,
    which identifies it as <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, or a numbered basic
    block. We’ll assign numeric IDs to basic blocks according to their order in the
    original TACKY function. Each basic block holds a list of TACKY instructions,
    a list of *successors* (the blocks that could execute right after it), and another
    list of *predecessors* (the blocks that could execute right before it). The entry
    and exit nodes don’t hold any instructions. <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    as the very first point in the function, has successors but no predecessors. <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, on the other hand, has predecessors
    but no successors.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a way to associate both basic blocks and individual instructions
    with extra information so that you can track the results of data-flow analysis
    in the copy propagation and dead store elimination passes. The definition in [Listing
    19-8](chapter19.xhtml#list19-8) doesn’t include a way to track this information.
    You could either attach it directly to the graph or store it in a separate data
    structure. The pseudocode throughout this chapter will use <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate
    _instruction</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_instruction_annotation</samp>
    to save and look up information about individual instructions. It will use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">annotate_block</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block
    _annotation</samp> to save and look up information about basic blocks by block
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Your graph data structure might look quite different from [Listing 19-8](chapter19.xhtml#list19-8).
    For instance, you might want to represent the graph as a map from node_id to node,
    instead of a list of nodes, or track the entry and exit nodes separately from
    the nodes that represent basic blocks. You can define your control-flow graph
    in whatever way makes sense to you and suits your implementation language, as
    long as it includes all the information you’ll need.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Basic Blocks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let’s see how to partition the body of a TACKY function into basic blocks.
    You can’t have any jumps into or out of the middle of a basic block. The only
    way to execute a basic block is to start at its first instruction and continue
    all the way to the end. This implies that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    can appear only as the first instruction in a block, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    or jump instruction can appear only as the last instruction. [Listing 19-9](chapter19.xhtml#list19-9)
    demonstrates how to split a list of instructions into basic blocks along these
    boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-9: Partitioning
    a list of instructions into basic blocks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction, we start a new basic block beginning with that <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    ❶. When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction or a conditional or unconditional jump, we add it to the current block,
    then start a new empty block ❷. When we encounter any other instruction, we add
    it to the current block without starting a new block ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-9](chapter19.xhtml#list19-9) just partitions a function body into
    a list of lists of instructions. The next step (which I won’t provide pseudocode
    for) is to convert these lists of instructions into <samp class="SANS_TheSansMonoCd_W5Regular_11">BasicBlock</samp>
    nodes with increasing block IDs. We’ll then add these nodes to the graph, along
    with the entry and exit nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Edges to the
    Control-Flow Graph</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After adding every node to the graph, we’ll add edges from each node to its
    successors, as [Listing 19-10](chapter19.xhtml#list19-10) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-10: Adding edges
    to the control-flow graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_all_edges</samp> ❶ is our unfinished
    control-flow graph, which has nodes but no edges. We’ll begin by adding an edge
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> to the first basic
    block ❷. (We can assume that the function contains at least one basic block, since
    we don’t optimize empty functions.) Throughout this listing, we’ll use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp> function, which takes
    two node IDs, to add edges to the graph. Keep in mind that whenever we add an
    edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>, we must update both the
    successors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node1</samp> and the
    predecessors of <samp class="SANS_TheSansMonoCd_W5Regular_11">node2</samp>. I’ve
    omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge</samp>,
    since it will depend on how you’ve defined your control-flow graph.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add outgoing edges from the nodes that correspond to basic blocks.
    To process one of these nodes, we’ll first determine which other node will follow
    it by default if we don’t jump or return at the end of the block. If we’re processing
    the very last block, the next node will be <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
    Otherwise, it will just be whatever basic block comes next in the original TACKY
    function ❸.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll figure out what edges to add by inspecting the last instruction in the
    current basic block. If it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, we’ll add one outgoing edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.
    If it’s an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    we’ll add an edge to the block that begins with the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>.
    We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_block_by_label</samp>
    helper function, which I won’t show the pseudocode for, to look up which block
    begins with a particular label. I recommend building a map from labels to block
    IDs ahead of time so that this function can just perform a map lookup.
  prefs: []
  type: TYPE_NORMAL
- en: If a block ends with a conditional jump, we’ll add two outgoing edges. The first
    edge, which represents taking the jump, will go to the block that starts with
    the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> ❹.
    The other edge, which represents not taking the jump ❺, will go to the default
    next node, identified by <samp class="SANS_TheSansMonoCd_W5Regular_11">next_id</samp>.
    If a block ends with any other instruction, we’ll add a single outgoing edge to
    the default next node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting a Control-Flow
    Graph to a List of Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, you should have working code to convert a TACKY function into
    a control-flow graph. You’ll also need code to go in the other direction and convert
    a control-flow graph back to a list of instructions. This operation is much simpler:
    just sort all the basic blocks by ID, then concatenate all their instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Your Control-Flow
    Graph Code Reusable</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the next chapter, we’ll build control-flow graphs of assembly programs. We’ll
    use the same algorithm to construct these graphs, but we’ll look for different
    individual control-flow instructions. For instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, and conditional jump
    instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">jne</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">je</samp> all signal the end of
    a basic block in assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have working code to construct control-flow graphs, you might want
    to refactor it so you can use it for assembly programs too. This is completely
    optional, but it will save you some effort in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll need to generalize the <samp class="SANS_TheSansMonoCd_W5Regular_11">graph</samp>
    data type so that a block can contain either TACKY or assembly instructions. Next,
    you’ll need to generalize the logic to analyze specific instructions in [Listings
    19-9](chapter19.xhtml#list19-9) and [19-10](chapter19.xhtml#list19-10). For instance,
    you could define a one-off data type to represent both assembly and TACKY instructions,
    which captures just the information you need to build the control-flow graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Instead of inspecting individual TACKY instructions to determine where a basic
    block ends or what its successors are, you can convert each instruction to a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> and inspect
    that. Then, when you need to build control-flow graphs for assembly programs,
    you’ll use a different helper function to convert an assembly instruction to a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">generic_instruction</samp> but leave
    everything else the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'That wraps up our discussion of control-flow graphs. We’re now ready to move
    on to our second optimization pass: unreachable code elimination.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unreachable Code Elimination</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll split up this pass into three steps, first removing basic blocks that
    will never execute, then useless jumps, and finally useless labels. The last two
    steps might leave us with empty blocks that don’t contain any instructions. Optionally,
    we can clean up after this optimization by removing these empty blocks from the
    control-flow graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Eliminating Unreachable
    Blocks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To find every block that might possibly execute, we’ll traverse the control-flow
    graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    We’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>’s successor,
    then all of that node’s successors, and so on, until we run out of nodes to explore.
    If this traversal never reaches a particular basic block, we’ll know that block
    is safe to remove. Let’s try out this approach on the example from [Listing 19-4](chapter19.xhtml#list19-4),
    which we looked at when we first introduced unreachable code elimination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We determined earlier that <samp class="SANS_TheSansMonoCd_W5Regular_11">x =
    my_function()</samp> is unreachable. Assuming this listing is the entire body
    of a TACKY function, it will have the control-flow graph shown in [Figure 19-2](#fig19-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-2: The control-flow
    graph for [Listing 19-4](chapter19.xhtml#list19-4) [Description](description-53.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that there’s no path from <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>.
    If we traverse this graph starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>,
    we’ll visit <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Along the way,
    we’ll keep track of which nodes we’ve visited so far. Once we’re done, we’ll see
    that we never visited <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, so we’ll remove it. I won’t
    provide the pseudocode for exploring the graph, since it’s just an ordinary breadth-
    or depth-first graph traversal.
  prefs: []
  type: TYPE_NORMAL
- en: When you remove a node from the graph, remember to remove its outgoing edges
    too. For example, when we remove <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> from the graph in [Figure
    19-2](#fig19-2), we should also remove it from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>’s list of predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless
    Jumps</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll remove any useless jump instructions. Remember that by default,
    if a block doesn’t end with a jump or <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, control falls through to the next block from the original program
    order. We can delete a jump instruction if it targets this default next block.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at each basic block that ends with a conditional or unconditional
    jump and figure out which block would follow it by default if the jump weren’t
    taken. If this default next block is its only successor, the jump instruction
    is redundant. [Listing 19-11](chapter19.xhtml#list19-11) demonstrates this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-11: Removing redundant
    jumps</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll sort the basic blocks by their position in the original TACKY function
    ❶; this is one reason we numbered the blocks when we first constructed the graph.
    Next, we’ll iterate over this sorted list of basic blocks (except the last one,
    since a jump at the very end of the function is never redundant) ❷. If a block
    ends with a jump, we’ll search for a successor other than the next block in the
    list. If we find one, we’ll keep the jump instruction. Otherwise, we’ll remove
    it ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the next block in the list won’t necessarily have the next consecutive
    numerical ID, since we may have deleted blocks earlier. Block 2, for example,
    might be followed by block 4\. That’s why we can’t just increment a block’s ID
    number to find its default successor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Useless
    Labels</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing useless labels is similar to removing useless jumps. After sorting
    basic blocks by numeric ID, we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    instruction at the start of a block if we’ll enter it only by falling through
    from the previous block, rather than jumping to it explicitly. More concretely,
    we can delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> at
    the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>
    if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i
    - 1]</samp>. We can also delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    at the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[0]</samp>
    if its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    This transformation is safe because we just deleted redundant jump instructions;
    we know that <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i - 1]</samp>
    won’t end with an explicit jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">sorted_blocks[i]</samp>.
    I won’t provide pseudocode for this step, since it would look basically the same
    as [Listing 19-11](chapter19.xhtml#list19-11).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Empty Blocks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Eliminating unreachable jumps and labels might result in blocks with no instructions.
    If you want, you can remove them; this will shrink the graph and might speed up
    later optimization passes a bit. When you remove a block, make sure to update
    the edges in the control-flow graph accordingly. For example, if the graph has
    edges from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and you delete <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    you’ll need to add an edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Little Bit About Data-Flow Analysis</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will give a quick overview of data-flow analysis, which we’ll rely
    on in the next two optimization passes. You’ll learn what it is, when it’s useful,
    and what features all data-flow analyses have in common. This isn’t intended to
    be a complete explanation of data-flow analysis; my goal here is just to introduce
    a few key ideas and describe how they fit together, to make the specific analyses
    in later sections easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data-flow analysis answers questions about how values are defined and used
    throughout a function. Different data-flow analyses answer different questions.
    In the copy propagation pass, for example, we’ll implement *reaching copies analysis*.
    This answers the question: Given some instruction *i* in a TACKY function, and
    two operands <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">v</samp> that appear in that function,
    can we guarantee that <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> are equal at the point
    just before *i* executes?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can divide all data-flow analyses into two broad categories: forward and
    backward analyses. In a *forward analysis*, information travels forward through
    the control-flow graph. Reaching copies analysis is a forward analysis. When we
    see a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>, that tells us that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    might have the same value later in the same basic block or in one of that block’s
    successors. In a *backward analysis*, the reverse is true. In the dead store elimination
    pass, we’ll implement a backward analysis called *liveness analysis*. This analysis
    tells us whether a variable’s current value will ever be used. If we see an instruction
    that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, that tells us
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> may be live earlier
    in the same basic block or in one of that block’s predecessors.'
  prefs: []
  type: TYPE_NORMAL
- en: Each data-flow analysis has its own transfer function and meet operator. The
    *transfer function* calculates the analysis results within a single basic block.
    This function analyzes how individual instructions impact the results, but it
    doesn’t need to deal with multiple execution paths. The *meet operator* combines
    information from multiple paths to calculate how each basic block is impacted
    by its neighbors. We’ll use an *iterative algorithm* to drive the entire analysis.
    This algorithm calls the transfer function and meet operator on each basic block
    and keeps track of which blocks still need to be analyzed. It’s iterative because
    we may need to visit some blocks multiple times as we propagate information along
    different execution paths. This algorithm will traverse the control-flow graph,
    analyzing each basic block it visits, until it reaches a fixed point where the
    analysis results no longer change. At that point, we’ll know that every possible
    execution path is accounted for. The iterative algorithm isn’t the only way to
    solve data-flow analysis problems, but it’s the only one we’ll discuss in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: While different analyses use different transfer functions and meet operators,
    they all use essentially the same iterative algorithm. Forward and backward analyses
    use different versions of this algorithm because they propagate data in opposite
    directions. We’ll implement both versions in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Copy Propagation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    appears in a function, we can sometimes replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> later in that function.
    Let’s call the instruction where we’d like to perform this substitution *i*. The
    substitution is safe when two conditions are met. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> must appear on every path from the program’s entry point to *i*. Consider
    the control-flow graph in [Figure 19-3](#fig19-3), which doesn’t meet this condition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-3: A control-flow
    graph for a function where we cannot perform copy propagation [Description](description-54.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this control-flow graph, there are two paths from the start of the function
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>. Because only
    one of these paths passes through <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 2</samp>, it isn’t safe to substitute <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in this <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. In [Figure 19-4](#fig19-4), on the other hand, every path to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> passes through <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-4: A control-flow
    graph for a function where we can perform copy propagation [Description](description-55.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: No matter which path we take through [Figure 19-4](#fig19-4), we’ll execute
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 2</samp> before we reach the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction, so we
    can safely rewrite that instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-5](#fig19-5) shows another, slightly trickier example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-5: Another control-flow
    graph where copy propagation is safe [Description](description-56.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, there are two different paths to <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
    Both paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>,
    but they pass through different instances of this instruction that appear in different
    blocks. In <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>’s value is <samp class="SANS_TheSansMonoCd_W5Regular_11">20</samp>;
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    it’s <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>. But in either case,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    will have the same value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. That means it’s still safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we rewrite instruction *i*, there’s a second condition that each path
    to *i* must satisfy: between the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> and *i*, neither <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> can be updated again.
    Consider this fragment of TACKY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>,
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s value is no longer
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> at that point. Updating
    the variable that appeared on the right-hand side of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction causes the same problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Right before <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 0</samp>, we
    know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    have the same value. But after that instruction, their values will be different,
    so we can’t rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
    When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction’s
    source or destination is updated, we say the copy is *killed*. Once a copy is
    killed, we can’t propagate it to later points in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible for <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    to appear multiple times on some path to *i*. It’s unsafe to propagate it only
    if it’s killed after the *last* time it appears. In the following example, it’s
    safe to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(2)</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If there are multiple paths to *i*, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction we’re interested in must not be killed on any of them. Take a look
    at [Figure 19-6](#fig19-6), where <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> is killed on one path but not another.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-6: A control-flow
    graph where a reaching copy is killed along one path [Description](description-57.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If we jump over <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will have the same
    value when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    But if we take the path through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, their values will be different.
    Because we don’t know ahead of time which path the program will take, we can’t
    rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider one final edge case. Suppose that <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> is followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>,
    with no intervening kills:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Normally, updating <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> would
    kill the earlier <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    But after <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> still have the same
    value. There are multiple correct ways to handle this case. One option is to say
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp>, so only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
    reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp>. In that
    case, we’d rewrite the final instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + x</samp>. This might let us remove <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> later, during dead store elimination, depending on where else <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is used. Another option is to
    simply ignore <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp> during
    our analysis, on the grounds that it has no effect; it just assigns <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    the same value it already had. Then, when we’re rewriting instructions, we can
    go ahead and eliminate <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>
    and rewrite the last instruction as <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = y + y</samp>. A third option is to propagate *both* copies in the final instruction,
    substituting <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This substitution
    is safe but not particularly helpful, since it won’t help us get rid of either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction. We’ll go
    with the second option and eliminate the redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction appears
    on every path to instruction *i*, and it isn’t killed on any of those paths, we
    say that it *reaches* instruction *i*. At the start of the copy propagation pass,
    we’ll perform reaching copies analysis to determine which copies reach each instruction
    in the TACKY function. Then, we’ll use the results of this analysis to identify
    instructions that we can rewrite safely.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement this whole optimization for the subset of TACKY we defined in
    [Part I](part1.xhtml), then extend it to handle the new language features from
    [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reaching Copies Analysis</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To implement reaching copies analysis, we’ll define each of the elements of
    data-flow analysis that we discussed earlier: the transfer function, meet operator,
    and iterative algorithm. The transfer function and meet operator we’ll discuss
    in this section are specific to reaching copies analysis, while the iterative
    algorithm applies to every forward data-flow analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The transfer function takes all the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions that reach the beginning of a basic block and calculates which copies
    reach each individual instruction within the block. It also calculates which copies
    reach the end of the block, just after the final instruction. The rules here are
    pretty simple. First, if *i* is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, it reaches the instruction that comes right after it. Second, if
    some <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction reaches
    *i*, it also reaches the instruction right after *i*, unless *i* kills it. Let’s
    work through an example. Suppose a basic block contains the instructions in [Listing
    19-12](chapter19.xhtml#list19-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-12: A basic block</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that one <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>, reaches
    the start of this basic block. This <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    will reach the first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a</samp>. Once we encounter <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = a</samp>, we add it to the current set of reaching copies, so both <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    = y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> reach
    the next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp>.
    Because this next instruction updates <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    it kills <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp>. We therefore
    remove <samp class="SANS_TheSansMonoCd_W5Regular_11">a = y</samp> from the set
    of reaching copies, but we add <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 10</samp>. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp>
    kills <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp>. We don’t add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> as a reaching copy
    because it’s not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    The final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction
    doesn’t add or remove any reaching copies. [Table 19-1](chapter19.xhtml#tab19-1)
    lists which copies reach each instruction in this basic block.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-1:</samp> <samp class="SANS_Futura_Std_Book_11">Copies
    Reaching Each Instruction in [Listing 19-12](chapter19.xhtml#list19-12)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Reaching
    copies</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = a</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{a
    = y, x = a}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y * 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = a, y = 10}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(x)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">End of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 10}</samp> |'
  prefs: []
  type: TYPE_TB
- en: Things get a little trickier when we consider variables with static storage
    duration. As [Listing 19-13](chapter19.xhtml#list19-13) demonstrates, these variables
    can be updated in other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-13: A C program
    where multiple functions access the same variable with static storage duration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our reaching copies analysis should recognize that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">update
    _var</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> kills
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static_var = 5</samp> ❶. Otherwise,
    it will incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    to return the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>.
    At first glance, it might look like this problem applies only to file scope variables,
    but as [Listing 19-14](chapter19.xhtml#list19-14) illustrates, it impacts static
    local variables too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-14: A C program
    where a function call indirectly updates a static local variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we analyze <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>, we’ll
    need to know that the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">indirect_update</samp>
    at ❶ can update <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp>. Otherwise,
    we’ll incorrectly rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    to return <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of ways to solve this problem. One option is to figure out
    which function calls will update which static variables. This would make reaching
    copies analysis an interprocedural analysis, which gathers information about multiple
    functions. This approach gets complicated very quickly. Our other option is to
    assume that every function call updates every static variable. We’ll go with this
    option because it’s much simpler. Whenever we encounter a function call, we’ll
    kill any copies to or from static variables. This approach is *conservative*;
    it guarantees that we’ll never perform an unsafe optimization, but it may lead
    us to kill some reaching copies unnecessarily and miss some safe optimizations.
    In contrast, using interprocedural analysis would be a more *aggressive* approach
    because it would miss fewer optimizations. More aggressive optimization techniques
    aren’t always better; they often come at the cost of increased complexity and
    longer compilation times.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-15](chapter19.xhtml#list19-15) gives the pseudocode for the transfer
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-15: The transfer
    function for reaching copies analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To process an instruction, we’ll first record the set of copies that reach the
    point just before that instruction executes ❶. (We’ll refer to this information
    later when we actually rewrite the instruction.) Then, we’ll inspect the instruction
    itself to calculate which copies reach the point just after it. In the special
    case where <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> reaches
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we won’t add or remove
    any reaching copies ❷. As we saw earlier, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = x</samp> will have no effect, since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> already have the same
    value. Otherwise, we’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> by killing
    any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> ❸,
    then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp> to the
    set of reaching copies ❹.
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction, we’ll kill any copies to or from variables with static storage duration
    along with any copies to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    the variable that will hold the result of the function call ❺. The two other instructions
    from [Part I](part1.xhtml) that update variables are <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>. To handle either
    of these, we’ll kill any copies to or from its destination ❻. The remaining TACKY
    instructions from [Part I](part1.xhtml), like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>,
    don’t add or kill any reaching copies. After processing every instruction, we’ll
    record which copies reach the very end of the block ❼.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll implement the meet operator, which propagates information about
    reaching copies from one block to another. This operator calculates the set of
    initial reaching copies that we’ll pass to the transfer function. Recall that
    a copy reaches some point in the program only if it appears, and isn’t killed,
    on *every* path to that point. Therefore, a copy reaches the beginning of a block
    only if it reaches the end of all of that block’s predecessors. In other words,
    we’ll just take the set intersection of the results from every predecessor. [Listing
    19-16](chapter19.xhtml#list19-16) gives the pseudocode for the meet operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-16: The meet operator
    for reaching copies analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The meet operator takes two arguments. The first is the block whose incoming
    copies we want to calculate. The second, <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>,
    is the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions
    that appear in the function. We initialize the set of incoming copies to this
    value ❶, because it’s the *identity element* for set intersection. That is, given
    any set of reaching copies, *S*, the intersection of *S* with <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>
    is just *S*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate over the block’s predecessors, which might include other basic
    blocks, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp> node, or
    both. No copies reach the very start of a function, so if we find <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>
    in the list of predecessors we just return the empty set ❷. (The intersection
    of the empty set and anything else is still the empty set, so there’s no need
    to look at the block’s other predecessors.) Otherwise, we look up the set of copies
    that reach the end of each predecessor ❸, which we recorded at the end of [Listing
    19-15](chapter19.xhtml#list19-15), and take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">incoming_copies</samp>
    with each of these sets.
  prefs: []
  type: TYPE_NORMAL
- en: We have one edge case to consider. If unreachable code elimination is disabled,
    the block we’re analyzing might not have any predecessors. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp>
    on a block with no predecessors will return <samp class="SANS_TheSansMonoCd_W5Regular_11">all_copies</samp>,
    so we assume that every possible <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction reaches the start of the block. We don’t care how this ultimately
    impacts the block itself, which will never execute anyway. We *do* care how this
    impacts the block’s successors, which might be reachable. For instance, if a reachable
    block <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and unreachable block
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> both jump to block <samp
    class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, then block <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    is reachable.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, our analysis is still safe. The intersection of the real results from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and the junk results from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> will always be a subset
    of the copies that actually reach <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>; this is a conservative
    approximation of the results we’d get if we enabled unreachable code elimination
    and deleted <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> entirely.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can analyze a basic block with the meet operator and transfer function once
    we know the results from the blocks that preceded it. Now we’ll tie everything
    together and analyze the entire function. There’s just one problem: control-flow
    graphs can have loops! We can’t analyze a block until we’ve analyzed all of its
    predecessors, which requires us to analyze all of their predecessors, and so on.
    Once we hit a loop, it seems like we’re stuck; we can’t analyze any of the blocks
    in the loop, because each block directly or indirectly precedes itself.'
  prefs: []
  type: TYPE_NORMAL
- en: To get unstuck, we need some way to analyze a block even if we don’t have complete
    results from all of its predecessors. The solution is to maintain a provisional
    result for every block; if we need to analyze a block before some of its predecessors,
    we can use those predecessors’ provisional results. At first, before we’ve explored
    any paths to a block, its provisional result includes every <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction in the function. Then, with each new path to the block (or rather,
    the end of the block) that we explore, we eliminate any copies that don’t appear,
    or are killed, along that path. This means a block’s provisional result always
    tells us which reaching copies appear (and aren’t killed) on *every* path to the
    end of that block that we’ve explored so far. Once we’ve explored every possible
    path, we’ll have the block’s final result.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the basic idea; now let’s put it into practice. First, we’ll annotate
    each basic block with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions in the function. As we learned earlier, this set is the identity
    element for our meet operator. Initializing every block with the identity element
    ensures that blocks we haven’t yet analyzed don’t change the result of the meet
    operator. Let’s try out this approach on the control-flow graph in [Figure 19-7](#fig19-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-7: A control-flow
    graph with a loop [Description](description-58.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This control-flow graph contains two <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>. We’ll initially annotate
    each block with the set containing both copies. Then, we’ll analyze the blocks
    in order. We can calculate the final results for <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> in just one pass because
    its only predecessor is <samp class="SANS_TheSansMonoCd_W5Regular_11">ENTRY</samp>.
    [Figure 19-8](#fig19-8) illustrates the annotations on each block after we’ve
    processed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-8: The provisional
    results of reaching copies analysis for [Figure 19-7](#fig19-7), after processing
    B</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I-SUB_11">0 [Description](description-59.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the annotation on <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> is correct: only <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 3</samp> reaches the end of that block. The other two blocks are still annotated
    with every copy. Next, we’ll apply the meet operator to see which copies reach
    the start of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>.
    This block has two predecessors: <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> and itself. We’ll therefore
    take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3, y = 4}</samp>, which
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 3}</samp>. This is the same
    result we’d get if <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp> were <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>’s only predecessor. That’s
    exactly the behavior we want: because we haven’t analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp> yet, it shouldn’t contribute
    to the result of the meet operator. Once we apply the transfer function to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    we’ll recognize that only <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 4</samp>
    reaches the end of the block. We’ll then have all the information we need to process
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    too. [Figure 19-9](#fig19-9) shows the annotations on each block after we’ve analyzed
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-9: The provisional
    results of reaching copies analysis after analyzing each basic block once [Description](description-60.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each block now has the correct set of reaching copies. But we don’t yet have
    the right answer for each individual instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. ([Figures 19-8](#fig19-8)
    and [19-9](#fig19-9) don’t show the annotations on individual instructions.) When
    we last analyzed <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    we assumed that <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3</samp> reached
    the start of the block, which would imply that it also reaches <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = process(y)</samp>. Now that we have more accurate information, we need to analyze
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    again. This time, the meet operator will take the intersection of <samp class="SANS_TheSansMonoCd_W5Regular_11">{y
    = 3}</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">{y = 4}</samp>,
    which is the empty set. We’ll pass this result to the transfer function to recalculate
    the results for individual instructions in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>. This time around, we’ll
    correctly conclude that no <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions reach <samp class="SANS_TheSansMonoCd_W5Regular_11">x = process(y)</samp>
    (or any point in the block before <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 4</samp>, for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen the iterative algorithm in action, let’s implement it. [Listing
    19-17](chapter19.xhtml#list19-17) gives the pseudocode for this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-17: The iterative
    algorithm for reaching copies analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll maintain a worklist of basic blocks we need to process, including blocks
    that we need to revisit after updating one of their predecessors. In the initial
    setup for this algorithm, we’ll add each basic block to the worklist ❶, since
    we need to analyze every block at least once. We’ll also initialize each block
    with the set of all <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions that appear in the function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we enter our main processing loop, where we’ll remove a block from the
    front of the worklist ❷, then analyze it using the meet operator and transfer
    function. If this analysis changes the block’s outgoing reaching copies, we’ll
    add all of its successors to the worklist so we can reanalyze them using those
    new results ❸. If a successor is already in the worklist, we don’t need to add
    it again. We’ll repeat this process until the worklist is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-17](chapter19.xhtml#list19-17) works for any forward data-flow
    analysis. Only the transfer function, the meet operator, and the identity element
    used to initialize each basic block will vary.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rewriting TACKY Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After running reaching copies analysis, we’ll look for opportunities to rewrite,
    or even remove, each instruction in the TACKY function. To rewrite an instruction,
    we’ll check whether the copies that reach it define any of its operands. If they
    do, we’ll replace those operands with their values. If we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">x = y</samp>
    and its reaching copies include <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">y = x</samp>, we’ll
    remove it instead of trying to rewrite it; the instruction has no effect if <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    already have the same value. [Listing 19-18](chapter19.xhtml#list19-18) demonstrates
    how to process each instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-18: Rewriting an
    instruction based on the results of reaching copies analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Given the set of copies that reach the current instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">replace_operand</samp>
    replaces a single TACKY operand with its value. If the operand is a constant or
    we can’t find a reaching copy that assigns to it, we just return the original
    value.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_instruction</samp>,
    we start by looking up the set of copies that reach the current instruction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">instr</samp> ❶. If <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction, we’ll
    search this set, which we call <samp class="SANS_TheSansMonoCd_W5Regular_11">reaching_copies</samp>,
    for a copy from its source to its destination or vice versa ❷. If we find one,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">instr</samp>’s operands already
    have the same value, so we can delete it. ([Listing 19-18](chapter19.xhtml#list19-18)
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to indicate
    that we should delete the instruction; your code might indicate this differently.)
    Otherwise, we try to replace the instruction’s source operand using <samp class="SANS_TheSansMonoCd_W5Regular_11">replace
    _operand</samp> ❸. We’ll attempt to replace the source operands of other TACKY
    instructions in the same way. [Listing 19-18](chapter19.xhtml#list19-18) demonstrates
    how to rewrite the source operands in <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>; I’ve omitted
    the remaining TACKY instructions from [Part I](part1.xhtml) because the logic
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a complete copy propagation pass that performs reaching
    copies analysis and uses the results to optimize a TACKY function. If you skipped
    [Part II](part2.xhtml), you can move on to this section’s test suite. But if you
    completed [Part II](part2.xhtml), you still have some work to do.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make copy propagation work with the TACKY code we generate in [Part II](part2.xhtml),
    we need to solve a couple of problems. The first problem is that we sometimes
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instructions to
    perform type conversions. We don’t want to propagate copies between signed and
    unsigned types, because we sometimes generate different assembly code for operations
    on signed and unsigned values. If we replace a signed value with an unsigned one
    in a comparison, for example, we’ll end up generating the wrong condition code
    for that comparison. Our reaching copies analysis will treat any <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    between signed and unsigned operands like a type conversion instruction instead
    of a normal copy operation. We won’t add it as a reaching copy in the transfer
    function, and we won’t include it in the set of initial reaching copies at the
    start of the iterative algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Another solution would be to introduce separate signed and unsigned TACKY
    operators for comparisons, remainder operations, and division, so we wouldn’t
    have to check the types of operands to distinguish between these cases during
    code generation. The LLVM IR uses this approach.*'
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is that variables can be updated through pointers. These
    updates are difficult to analyze. If we see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(v,
    ptr)</samp>, we don’t know which object <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>
    points to, so we don’t know which copies to kill. This is similar to the issue
    we ran into with static variables, which could be updated in other functions.
    To solve this problem, we’ll find all the variables that could be accessed through
    pointers (these are called *aliased variables*). We’ll assume that every <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction updates every
    one of these variables. We’ll assume that function calls update these variables
    too, since we can declare a variable in one function and then update it through
    a pointer in a different function. Let’s use this approach to analyze [Listing
    19-19](chapter19.xhtml#list19-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-19: A TACKY function
    that updates variables through pointers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll identify the aliased variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">function_with_pointers</samp>.
    Both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are aliased because they’re both used in <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instructions. (Let’s assume that none of the variables in this listing are static,
    so we don’t have to worry about whether other functions take their address.) Next,
    we’ll run reaching copies analysis. Since this whole function body is one basic
    block, we can just apply the transfer function to the entire thing. We’ll add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> to
    the set of reaching copies, as usual. Then, when we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction, we’ll kill the copies to our two aliased variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. [Table 19-2](chapter19.xhtml#tab19-2)
    describes which copies will reach each instruction in this function.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-2:</samp> <samp class="SANS_Futura_Std_Book_11">Copies
    Reaching Each Instruction in [Listing 19-19](chapter19.xhtml#list19-19)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Reaching
    copies</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = 3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x
    = 1, y = 2}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1 = GetAddress(x)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Store(10, ptr1)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">{x = 1, y = 2, z = 3}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr2 = GetAddress(y)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z = 3}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">z = x + y</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{z
    = 3}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(z)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">End of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We correctly recognize that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    which means that we can’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + y</samp>. We also assume that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction might overwrite <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    because our analysis isn’t smart enough to realize that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    couldn’t possibly point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.
    Therefore, we won’t replace <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">z
    = x + y</samp>, even though it would be safe to do so. Once again, we’re making
    a conservative assumption; we’ll miss some safe optimizations, but we’ll never
    apply any that are unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Address-Taken
    Analysis</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The approach we just used to identify aliased variables is called *address-taken
    analysis*. To perform this analysis, we’ll inspect each instruction in a TACKY
    function and identify every variable that either has static storage duration or
    has its address taken by a <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instruction. (We’ll assume that all static variables are aliased, because their
    addresses might be taken in other functions.) We’ll rerun this analysis on every
    iteration through the optimization pipeline because the results can change if
    we optimize away any <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    instructions. [Listing 19-20](chapter19.xhtml#list19-20) demonstrates how it fits
    into the overall optimization pipeline we defined in [Listing 19-6](chapter19.xhtml#list19-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-20: Adding address-taken
    analysis to the TACKY optimization pipeline</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Address-taken analysis is just one kind of *alias analysis*, also known as *pointer
    analysis*, which tries to determine whether two pointers or variables can refer
    to the same object. Most pointer analysis algorithms are more powerful than address-taken
    analysis. For example, they could figure out that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr1</samp>
    will never point to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in
    [Listing 19-19](chapter19.xhtml#list19-19).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating the Transfer Function</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, we’ll extend the transfer function to support the new types and instructions
    we added in [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-21](chapter19.xhtml#list19-21) illustrates our new and improved
    transfer function. It reproduces [Listing 19-15](chapter19.xhtml#list19-15), with
    the changes to support additional types bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-21: The transfer
    function for reaching copies analysis, with support for features from Part II</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already touched on most of the changes in this listing. Before we add
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">current_reaching_copies</samp>, we’ll
    make sure that its source and destination have the same type, or at least types
    with the same signedness. The <samp class="SANS_TheSansMonoCd_W5Regular_11">signedness</samp>
    helper function should count <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    as a signed type and all pointer types as unsigned types, so we can propagate
    copies between <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, between different
    pointer types, and between pointers and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. (The concept of signedness doesn’t apply to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    or non-scalar types. That’s fine, because we don’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions to convert to or from these types. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or non-scalar
    operand, both operands will have the same type, so we won’t need to check their
    signedness.)
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter a function call or <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    instruction, we’ll kill any copies to or from aliased variables. We’ll also account
    for the fact that a function call may not have a destination operand. Note that
    we don’t kill the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst_ptr</samp> operand. <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    doesn’t change the value of the destination pointer itself, just the value of
    the object it points to. Finally, when we encounter any of the other instructions
    we added in [Part II](part2.xhtml)—including type conversions, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>—we’ll
    kill any copies to or from its destination. We won’t track copies to or from individual
    subobjects within structures or arrays, so <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp> will kill
    reaching copies without generating any new ones.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Updating rewrite_instruction</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ll rewrite most of the new TACKY instructions from [Part II](part2.xhtml)
    in the same way as the instructions from [Part I](part1.xhtml), replacing any
    source operands that are defined by reaching copies. The one exception is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, which we’ll never rewrite.
    It wouldn’t make sense to apply copy propagation to <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>,
    because it uses its source operand’s address rather than its value.  ### <samp
    class="SANS_Futura_Std_Bold_B_11">Dead Store Elimination</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our last optimization is dead store elimination. We’ll use liveness analysis,
    a backward data-flow analysis, to calculate which variables are live at every
    point in the function we’re optimizing. Then, we’ll use the results of this analysis
    to identify dead stores and eliminate them.
  prefs: []
  type: TYPE_NORMAL
- en: A variable is *live* at a particular point if its value at that point might
    be read later in the program. Otherwise, it’s *dead*. To be more precise, a variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live at any given point
    *p* when two conditions are met. First, there must be at least one path from *p*
    to some later instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    We say that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is *generated*
    by any instruction that uses it. Second, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    must not be updated on the path from *p* to that later instruction. We say that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is *killed* by any instruction
    that updates it, just like a reaching copy is killed when either of its operands
    is updated. (You’ll see the terms *generate* and *kill* in discussions of most
    data-flow analyses, not just the two in this chapter.) Consider the control-flow
    graph in [Figure 19-10](#fig19-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-10: A control-flow
    graph in which x is live just after it’s defined [Description](description-61.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There are two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. On the path through
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is never used. On the path
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is used in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. We know that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is live at the point after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    because it’s generated on one of these paths. By the same logic, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is also live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, at the beginning of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>,
    and just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.
    On the other hand, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead
    at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>
    and at every point in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>, since there are no paths
    from those points to an instruction that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is also dead
    at the very beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_SUB_11">0</samp>, since we don’t use its (uninitialized)
    value before we assign it a new value in <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the control-flow graph in [Figure 19-11](#fig19-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig19-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 19-11: A control-flow
    graph with a dead store to x [Description](description-62.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we have two paths from <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = 10</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. Both
    paths pass through <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions that use <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    but on both paths <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is killed
    between <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp> and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction that generates
    it. This means that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is
    dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>.
    It’s alive at just two points in this control-flow graph: right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = f()</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">1</samp>
    and right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = g()</samp> in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp><samp class="SANS_TheSansMonoCd_W5Regular_SUB_11">2</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: An instruction is a dead store if it assigns to a dead variable and has no other
    side effects. Therefore, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 10</samp>
    is a dead store in [Figure 19-11](#fig19-11) but not in [Figure 19-10](#fig19-10).
    Note that we care whether the variable is dead just *after* the instruction, not
    before it. In the code fragment
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live just before <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> but dead after it. The
    fact that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is dead just
    after we update it means that this instruction is a dead store, so we can eliminate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Liveness Analysis</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like every data-flow analysis, liveness analysis requires a transfer function,
    a meet operator, and an iterative algorithm. Because this is a backward-flow problem,
    the transfer function will start at the end of a basic block and work its way
    to the beginning, instead of working from start to finish like we did in reaching
    copies analysis. Similarly, the meet operator will gather information from a block’s
    successors, not its predecessors. We’ll also use a slightly different iterative
    algorithm to send data backward through the control-flow graph. Let’s take a closer
    look at each of these pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Transfer Function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The transfer function takes the set of variables that are live at the end of
    a basic block and figures out which variables are live just before each instruction.
    As we saw in [Figures 19-10](#fig19-10) and [19-11](#fig19-11), an instruction
    generates any variables that it reads and kills any variables that it updates.
    For example, to calculate the live variables before the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = y * z</samp>, we would take the set of variables that are live right after the
    instruction, add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, and remove <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
    If an instruction reads and writes the same variable, it generates the variable
    instead of killing it. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x
    = x + 1</samp> generates <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply the transfer function to the basic block in [Listing 19-22](chapter19.xhtml#list19-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-22: A basic block</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The transfer function will start at the bottom of this basic block and work
    its way up. Let’s assume that there are no live variables at the end of the block,
    after the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction.
    (This assumption might not hold if the function deals with static variables, but
    we’ll worry about that later.) When we process the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    to the set of live variables. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">y
    = 3 * x</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    and generate <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. The next
    instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp>, generates
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. This has no effect because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is already live. Finally,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> will kill <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>,
    leaving no live variables at the start of the basic block. [Table 19-3](chapter19.xhtml#tab19-3)
    summarizes which variables are live just after each instruction in [Listing 19-22](chapter19.xhtml#list19-22).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 19-3:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Live Variables After Each Instruction in [Listing 19-22](chapter19.xhtml#list19-22)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Live
    variables</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Beginning of block</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">x = x + 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{x}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">y = 3 * x</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{y}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(y)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Static variables complicate things, much like they did during reaching copies
    analysis. We don’t know how other functions will interact with any static variables
    that we encounter; they could read them, update them, or both. We’ll assume that
    every function reads every static variable. This assumption is conservative, since
    it prevents us from eliminating earlier writes to those variables. [Listing 19-23](chapter19.xhtml#list19-23)
    gives the pseudocode for the transfer function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-23: The transfer
    function for liveness analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the set of variables that are live at the end of the block
    ❶, then process the list of instructions in reverse ❷. We annotate each instruction
    with the set of variables that are live just after it executes ❸; we’ll use this
    annotation later to figure out whether the instruction is a dead store. Then,
    we calculate which variables are live just before the instruction. We’ll kill
    its destination if it has one, then add every variable that it reads. [Listing
    19-23](chapter19.xhtml#list19-23) includes the pseudocode to handle the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction, which updates
    one operand and reads two others, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>
    instruction, which reads an operand but doesn’t update anything. It omits the
    pseudocode to handle most of the other instructions, since they follow the same
    pattern. <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> is the one
    special case; we’ll kill its destination and add its arguments, as usual, but
    we’ll add every static variable too ❹. Finally, we’ll annotate the whole block
    with the variables that are live before the first instruction ❺. The meet operator
    will use this information later.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of ways to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">all_static_variables</samp>.
    One option is to scan this TACKY function and look for static variables before
    you start the dead store elimination pass. Another option is to scan the whole
    symbol table for static variables, without worrying about which variables show
    up in which functions. There’s no harm in adding superfluous static variables
    here, since they won’t change which instructions we eventually eliminate.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Meet Operator</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The meet operator calculates which variables are live at the end of a basic
    block. To find the live variables at the end of some block <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    we’ll look at all of its successors. If a variable is live at the start of at
    least one successor, it must also be live at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    because there’s at least one path from the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    through that successor to an instruction that generates that variable. Basically,
    we’ll take the set union of all the live variables at the start of all the block’s
    successors.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume that every static variable is live at the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>
    node. Other functions, or other invocations of the current function, might read
    those variables. Variables with automatic storage duration are all dead at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>, since they’re not accessible
    after we leave the function. The pseudocode in [Listing 19-24](chapter19.xhtml#list19-24)
    defines the meet operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-24: The meet operator
    for liveness analysis</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In reaching copies analysis, we were looking for copies that appeared on *every*
    path to a point, so we used set intersection as our meet operator. In liveness
    analysis, we want to know if a variable is used on *any* path from a point, so
    we use set union instead. This is unrelated to the fact that one analysis is forward
    and the other is backward. Some forward analyses use set union because they care
    whether at least one path to a point has some property. Some backward analyses
    use set intersection because they care whether every path from a point has some
    property. Other, more complex analyses don’t use set union or intersection, and
    instead use different meet operators entirely.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Iterative Algorithm</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we’ll implement the iterative algorithm for liveness analysis. This
    differs from the iterative algorithm in [Listing 19-17](chapter19.xhtml#list19-17)
    in a couple of ways. First, when the annotation on a block changes, we’ll add
    its predecessors, rather than its successors, to the worklist. Second, we’ll use
    a different initial block annotation. Recall that each block’s initial annotation
    should be the identity element for the meet operator. Since our meet operator
    is set union, the initial annotation is the empty set. As we analyze more paths
    from a block to later points in the program, we’ll add more live variables to
    this set.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t provide the pseudocode for the backward iterative algorithm, since it’s
    so similar to the forward algorithm we’ve already defined. But I will give you
    a couple of tips about how to implement it. First, you may want to initialize
    the worklist in postorder. (Recall that you sort the nodes of a graph in postorder
    by performing a depth-first traversal and visiting each node after you’ve visited
    its successors.) This makes the backward algorithm terminate faster, just like
    initializing the worklist in reverse postorder helps the forward algorithm terminate
    faster. This ordering means that whenever possible, you’ll visit each block only
    after you’ve visited all of its successors.
  prefs: []
  type: TYPE_NORMAL
- en: My second tip is to make your backward iterative algorithm reusable. In the
    next chapter, we’ll implement liveness analysis again, this time for assembly
    programs. The details of the meet operator and transfer function will change,
    but the iterative algorithm won’t. Try to structure your code so that you’ll be
    able to reuse the same iterative algorithm with a different meet operator and
    transfer function; then, you’ll be able to use it to analyze assembly programs
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Dead Stores</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After we run liveness analysis, we’ll find any dead stores in the TACKY function
    and remove them. An instruction is a dead store if its destination is dead as
    soon as we execute it, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Liveness analysis will tell us that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is dead right after <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 1</samp>,
    making that instruction safe to delete. We’ll never delete function calls, even
    when they update dead variables, because they may have other side effects. We
    also won’t delete instructions without destinations, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>. [Listing 19-25](chapter19.xhtml#list19-25)
    demonstrates how to identify a dead store.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 19-25: Identifying
    a dead store</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you completed only [Part I](part1.xhtml), you’ve learned everything you need
    to know about dead store elimination! You can skip straight to the test suite.
    Otherwise, read on to learn how to handle the types and instructions we added
    in [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Supporting Part II
    TACKY Programs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To update the transfer function, we’ll need to think through which live variables
    each new instruction might generate or kill. The type conversion instructions,
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp>,
    are straightforward. Each one generates its source operand and kills its destination,
    much like the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instructions we already handle.
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AddPtr</samp> also follows the usual
    pattern: it generates both source operands and kills its destination.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operations on pointers and aggregate types are trickier. Pointers cause
    essentially the same problem they did in reaching copies analysis: when we read
    or write through a pointer, we can’t tell which underlying object is being accessed.
    When in doubt, we should err on the conservative side and assume that a variable
    is live. Therefore, reading through a pointer should generate every aliased variable,
    but writing through a pointer shouldn’t kill any of them. We’ll take a similar
    approach to aggregate variables: reading part of an aggregate variable will generate
    it, but updating part of it won’t kill it. I won’t provide updated pseudocode
    for the transfer function; now that we’ve covered the key points, I’ll let you
    work through the remaining details on your own. The meet operator won’t change;
    in particular, static variables are still live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>,
    but other aliased variables aren’t, because their lifetimes end when the function
    returns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s update the last step in this optimization, where we use the
    results of liveness analysis to find dead stores and eliminate them. We’ll never
    eliminate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction,
    since we don’t know whether its destination is dead. Even if every single variable
    in the current function is dead, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp>
    might still have a visible side effect. For instance, it could update an object
    defined in a different function, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: After the <samp class="SANS_TheSansMonoCd_W5Regular_11">Store</samp> instruction,
    there are no live variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">update_</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">through _pointer</samp>. But that instruction
    clearly isn’t a dead store; it updates an object that our analysis didn’t track
    but that will likely be read later in the program.
  prefs: []
  type: TYPE_NORMAL
- en: The usual logic for spotting dead stores applies to all the other instructions
    from [Part II](part2.xhtml), including <samp class="SANS_TheSansMonoCd_W5Regular_11">Load</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyToOffset</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CopyFromOffset</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you implemented four important compiler optimizations: constant
    folding, unreachable code elimination, copy propagation, and dead store elimination.
    You learned how these optimizations work together to transform the TACKY representation
    of a program, resulting in smaller, faster, simpler assembly code than your compiler
    produced before. You also learned how to construct a control-flow graph and perform
    data-flow analysis. These techniques are fundamental to many different optimizations,
    not just the ones we covered in this chapter. If you ever want to implement more
    TACKY optimizations on your own, you’ll be well prepared.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll write a register allocator. You’ll use a graph coloring
    algorithm to map pseudoregisters to hardware registers, and you’ll learn how to
    spill a register when graph coloring fails and you run out of registers. You’ll
    also use a technique called register coalescing to clean up many of the unnecessary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions in your
    assembly code. By the end of the chapter, your assembly programs still won’t look
    quite like what a production compiler would generate, but they’ll be a lot closer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section lists the resources I referred to while writing this chapter, organized
    by topic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Security implications of compiler optimizations**'
  prefs: []
  type: TYPE_NORMAL
- en: “Dead Store Elimination (Still) Considered Harmful” by Zhaomo Yang et al. surveys
    the different ways programmers try to avoid unwanted dead store elimination and
    the limits of each approach (*[https://<wbr>www<wbr>.usenix<wbr>.org<wbr>/system<wbr>/files<wbr>/conference<wbr>/usenixsecurity17<wbr>/sec17<wbr>-yang<wbr>.pdf](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “The Correctness-Security Gap in Compiler Optimization” by Vijay D’Silva, Mathias
    Payer, and Dawn Song looks at the security impact of a few different compiler
    optimizations and formalizes some of the security properties that optimizations
    should preserve (*[https://<wbr>ieeexplore<wbr>.ieee<wbr>.org<wbr>/stamp<wbr>/stamp<wbr>.jsp<wbr>?tp<wbr>=&arnumber<wbr>=7163211](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7163211)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-flow analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](chapter9.xhtml) of *Compilers: Principles, Techniques, and Tools*,
    2nd edition, by Alfred V. Aho et al. (Addison-Wesley, 2006) defines data-flow
    analysis more rigorously than I did here. It also proves that the iterative algorithm
    is correct and terminates in a reasonable amount of time and discusses the use
    of reverse postorder traversal (which it calls *depth-first ordering*) in this
    algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paul Hilfinger’s lecture slides from CS164 at UC Berkeley give an example-heavy
    overview of the same material (*[https://<wbr>inst<wbr>.eecs<wbr>.berkeley<wbr>.edu<wbr>/~cs164<wbr>/sp11<wbr>/lectures<wbr>/lecture37<wbr>-2x2<wbr>.pdf](https://inst.eecs.berkeley.edu/~cs164/sp11/lectures/lecture37-2x2.pdf)*).
    I found the explanation of liveness analysis in these slides particularly helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eli Bendersky’s blog post “Directed Graph Traversal, Orderings and Applications
    to Data-Flow Analysis” describes how to sort graphs in postorder and reverse postorder
    to speed up data-flow analysis (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2015<wbr>/directed<wbr>-graph<wbr>-traversal<wbr>-orderings<wbr>-and<wbr>-applications<wbr>-to<wbr>-data<wbr>-flow<wbr>-analysis](https://eli.thegreenplace.net/2015/directed-graph-traversal-orderings-and-applications-to-data-flow-analysis)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy propagation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every discussion of reaching copies analysis seems to formulate it slightly
    differently. The version in this chapter draws on Jeffrey Ullman’s lecture notes
    on *Compilers: Principles, Techniques, and Tools* (*[http://<wbr>infolab<wbr>.stanford<wbr>.edu<wbr>/~ullman<wbr>/dragon<wbr>/slides3<wbr>.pdf](http://infolab.stanford.edu/~ullman/dragon/slides3.pdf)*
    and *[http://<wbr>infolab<wbr>.stanford<wbr>.edu<wbr>/~ullman<wbr>/dragon<wbr>/slides4<wbr>.pdf](http://infolab.stanford.edu/~ullman/dragon/slides4.pdf)*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ve borrowed the idea of deleting redundant copies from LLVM’s low-level copy
    propagation pass (*[https://<wbr>llvm<wbr>.org<wbr>/doxygen<wbr>/MachineCopyPropagation<wbr>_8cpp<wbr>_source<wbr>.html](https://llvm.org/doxygen/MachineCopyPropagation_8cpp_source.html)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alias analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a quick overview of alias analysis algorithms in Phillip Gibbons’s
    lecture slides from his Carnegie Mellon course on compiler optimizations (*[https://<wbr>www<wbr>.cs<wbr>.cmu<wbr>.edu<wbr>/afs<wbr>/cs<wbr>/academic<wbr>/class<wbr>/15745<wbr>-s16<wbr>/www<wbr>/lectures<wbr>/L16<wbr>-Pointer<wbr>-Analysis<wbr>.pdf](https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L16-Pointer-Analysis.pdf)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
