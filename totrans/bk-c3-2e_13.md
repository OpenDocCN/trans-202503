## **13**

**3D TRANSFORMATIONS**

![Image](graphics/common-01.jpg)

All of the features and functions I’ve discussed in this book so far have involved two dimensions; every element has height and width, and all of the calculations have involved only the *x*-axis and *y*-axis. But with the introduction of the *z*-axis in the CSS Transforms Module, CSS3 offers a revolutionary way to transform an element in the third dimension (you can learn more at *[http://www.w3.org/TR/css-transforms-1/](http://www.w3.org/TR/css-transforms-1/)*).

At the time I wrote the first edition of this book, only Safari (for Mac and iOS) supported 3D transformations, but now just a few years later, stable implementations are in place across all major browsers, including IE10 and above—an incredibly rapid rate of adoption. At the time of this writing, in Safari, you need to apply the `-webkit-` prefix to all properties, but no other browsers have a requirement for a vendor prefix.

The work of moving objects around in three dimensions can be quite processor-intensive, but most (if not all) browsers have implemented what’s known as *hardware acceleration,* performing the required calculations directly on the device’s graphics chip rather than in the software of the browser or on the main processor. The result is that 3D-transformed elements usually animate in a way that’s smoother and more performant than other elements that are animated using only JavaScript. This being the case, you can go ahead and use 3D transformations in your pages without too much concern.

### **3D Elements in CSS**

Three-dimensional objects in CSS are based on the *Cartesian coordinate system*, which is illustrated in [Figure 13-1](ch13.html#ch13fig1). You can read about it on Wikipedia (*[http://en.wikipedia.org/wiki/Cartesian_coordinate_system/](http://en.wikipedia.org/wiki/Cartesian_coordinate_system/)*). I discussed the two-dimensional version of this system in [Chapter 6](ch06.html#ch06).

![Image](graphics/f13-01.jpg)

*Figure 13-1: The Cartesian coordinate system, with the axes* x, y*, and* z*^([1](footnote.html#footnote6))*

**NOTE**
*If you have experience using three-dimensional computer graphics programs, you should be familiar with the calculations and terminology used in this chapter. If not, don’t worry; I’ll do my best to explain it all as I go along.*

In CSS, the *z*-axis is based on the viewer: If you think of the *x*-axis as left to right and the *y*-axis as up and down, then think of the *z*-axis as toward and away. When you move an element along the *z*-axis by a positive value, you move it toward yourself; likewise, moving it by a negative value moves it away from you. You can change this somewhat by using different perspectives, which I’ll explain in due course.

I must point out that, although I’ll talk a lot about 3D in this chapter, I’m only referring to 3D coordinates. The elements themselves are still two-dimensional; they only have height and width. They are moved around in three-dimensional space, however, like moving a piece of paper around in the air.

Illustrating three-dimensional transformation concepts on the printed page is quite hard, so I strongly suggest you take a look at the examples on the website that accompanies this book (*[http:/www.thebookofcss3.com/](http://www.thebookofcss3.com/)*); I’ve added transition rules to some of the examples so they animate when you interact with them, showing more clearly the three-dimensional effects that are difficult to convey in a two-dimensional book. These examples should aid your understanding of some of the techniques used in this chapter. I also recommend the test page put together by the team at Westciv (*[http://www.westciv.com/tools/3Dtransforms/](http://www.westciv.com/tools/3Dtransforms/)*). This site allows you to try out different combinations of transformation values to see the effect they have on elements.

Before I introduce the new and extended transformation properties, a quick note about the examples being used in this chapter. Although each example may employ different classes to apply unique style rules, all of the examples use the same basic markup:

```
<div class="d3-parent">
    <div class="d3-child">
        <h2>The Book Of</h2>
        <h1>CSS3</h1>
    </div>
</div>
```

Most of the transformation work is performed on the *.d3-child* element, although a few properties must be applied to a parent, which is why I also have the *.d3-parent* element. I’ll be clear about whether properties are applied to parents or children as I go through the chapter.

### **The Transformation Functions**

In [Chapter 12](ch12.html#ch12), I introduced the `transform` property and its associated functions, for use in two-dimensional transformations. Three-dimensional transformations use the same property and many of the same functions, but also extend some of those functions and add some entirely new ones. I’ll explain each of the transformation functions in turn and note whether they are completely new or extend the existing 2D transformation properties that I have already discussed. Note that the `transform` property is always applied to the child element (*.d3-child* in the example markup).

#### ***Rotation Around an Axis***

I’ll begin explaining the 3D transformation functions as I did the 2D functions—with rotation. Two-dimensional space has only one axis to rotate around, so the `rotate()` function requires only a single value. But when you’re dealing with three dimensions, you’ve got three axes to rotate around and, therefore, three properties to control this.

```
E {
    transform: rotateX(angle);
    transform: rotateY(angle);
    transform: rotateZ(angle);
}
```

Like the `rotate()` function, each of the functions accepts a single angle value (negative values are permitted). I use the `deg` (degrees) unit in my examples and demonstrate how each of these works by showing the same degree of rotation around each axis using the following code:

```
➊ .trans-x { transform: rotateX(45deg); }
➋ .trans-y { transform: rotateY(45deg); }
➌ .trans-z { transform: rotateZ(45deg); }
```

You can see the results in [Figure 13-2](ch13.html#ch13fig2). The first example (➊) shows an element rotated around the *x*-axis. To understand what’s happening here, imagine a line running horizontally across the center of the element; the half of the element above the line is inclined 45 degrees away from you, and the half below the line is inclined 45 degrees toward you. The next example (➋) applies the rotation on the *y*-axis. Imagine a vertical line running down the center of the box; the half of the element to the left of the line is inclined 45 degrees toward you and the half on the right, 45 degrees away. The final example (➌) shows the same rotation again, but this time around the *z*-axis, which has the same effect as the two-dimensional `rotate()` function.

![Image](graphics/f13-02.jpg)

*Figure 13-2: A rotation of 45 degrees around each of the three axes*

If you want to rotate an element around more than one axis, you can apply multiple functions to an element:

```
E { transform: rotateX(angle) rotateY(angle) rotateZ(angle); }
```

Another new function—`rotate3d()`—also allows you to rotate an element around multiple axes; however, it’s not a shorthand function. Here’s the syntax:

```
E { transform: rotate3d(x,y,z,angle); }
```

The `*angle*` value is straightforward, but the `*x*`, `*y*`, and `*z*` values are not quite so simple. Each takes a number value, which is used to calculate a direction vector (the full explanation of which is beyond the scope of this book; visit *[http://mathworld.wolfram.com/CartesianCoordinates.html](http://mathworld.wolfram.com/CartesianCoordinates.html)* for an overview of the topic). The origin of the vector is the point where all the axes meet—by default, the center of the element—represented by the values `0,0,0`. A direction vector is a line in three-dimensional space, going from the origin to the coordinates given by the `*x,y,z*` values provided to the `rotate3d()` function. The element will be rotated around this line by the amount specified in the `*angle*` value.

This subject is quite complex, so I’ll explain by showing a few simple examples, once again with the same 45 degrees of rotation, using the following code:

```
➊ .trans-x { transform: rotate3d(1,1,0,45deg); }
➋ .trans-y { transform: rotate3d(1,0,1,45deg); }
➌ .trans-z { transform: rotate3d(0,10,10,45deg); }
```

You can see the output in [Figure 13-3](ch13.html#ch13fig3). The first (left) example (➊) has the values `1,1,0`, meaning the imaginary line goes to a point 1px along the *x*-axis and *y*-axis. (In fact, the “line” continues past that point in the same direction; the values `10,10,0` or `1000,1000,0` would produce the same results.) The element is rotated 45 degrees around that line. The second (middle) example (➋) has the values `1,0,1`, creating a point 1px along the *x*-axis and *y*-axis and rotating the element by 45 degrees around that line. The final example (➌), shown on the right, has the values `0,10,10`, so the element rotates 15 degrees around a line between the origin and a point 10px along the *y*-axis and *z*-axis. Remember that any two equal values would have the same effect.

![Image](graphics/f13-03.jpg)

*Figure 13-3: Rotation using directional vectors with the* `*rotate3d*` *function*

You probably won’t use the `rotate3d()` function often when coding pure CSS transformations as the calculations involved are quite complex. But when combined with the mathematical processing capabilities of JavaScript, the flexibility of this approach could really come into its own.

#### ***Perspective***

The next function, `perspective()`, is actually one of the most important as it creates an artificial viewpoint from where you view the object in three-dimensional space, providing the illusion of depth. If not specified, the element will appear “flat” to the viewer, regardless of any other transform functions applied (unless perspective is inherited from the parent; see “[The `perspective` and `perspective-origin` Properties](ch13.html#ch13leve1sec157)” on [page 159](ch13.html#page_159) for details). Here’s the syntax:

```
E { transform: perspective(depth); }
```

The value `*depth*` is either a length unit or the default keyword `none`. This length sets a “viewpoint” at that distance along the *z*-axis away from the element’s origin (`*z*` = 0). A low depth value—say, 50px—will make the element appear extremely close to the viewer, with exaggerated dimensions; a value of around 1000px can be considered “normal.”

The `perspective()` function is probably easier to show than to describe. In the next example, I use different values for the function to show you how various values change the viewers … er, perspective. Here’s the code:

```
➊ .trans-1 { transform: perspective(1000px) rotateX(30deg) rotateY(45deg); }
➋ .trans-2 { transform: perspective(250px) rotateX(30deg) rotateY(45deg); }
➌ .trans-3 { transform: perspective(150px) rotateX(30deg) rotateY(45deg); }
```

**WARNING** *The* `*perspective()*` *function must always be listed first when using multiple functions on the* `*transform*` *property; if listed after other functions, it will be ignored.*

You can see the results of the code in [Figure 13-4](ch13.html#ch13fig4). In the example on the left (➊), the element is viewed from a `perspective()` distance of 1000px. This is, as I said, the “normal” distance; the element is rotated around two axes but appears to be correctly proportioned. In the middle example (➋), the `perspective()` value has decreased to 250px, making the element appear exaggerated in proportion as I placed the viewpoint closer to the element. The final (right) example (➌) shows the element from a `perspective()` value of 150px, which means you are effectively viewing it from 150px along the *z*-axis, making the element appear quite exaggerated.

![Image](graphics/f13-04.jpg)

*Figure 13-4: The effects of different* `*perspective()*` *function values*

Before I move on, I want to make a slight digression. You may be wondering why the code contains so much repetition; why couldn’t I have done something like this instead?

```
.d3-child { transform: rotateX(30deg) rotateY(45deg); }
.trans-1 { transform: perspective(20px); }
.trans-2 { transform: perspective(50px); }
.trans-3 { transform: perspective(1000px); }
```

The reason is if I don’t specify a function, its value is presumed to be the default, so the values I set in the functions on the `h1` element are effectively overwritten by (the absence of) the functions in the subsequent styles. I explained this in [Chapter 12](ch12.html#ch12) in the section “[An Important Note About Transformation Functions](ch12.html#ch12leve1sec146).”

#### ***Translation Along the Axis***

The `translateX()` and `translateY()` functions (and their shorthand, `translate()`) are used to move an element along its axis by a specified length in two dimensions, but the move into a third dimension requires a new function: `translateZ()`. The syntax is identical to its sibling properties:

```
E { transform: translateZ(length); }
```

The `*length*` value is any number with a unit of length. For example, to move an element 30px along the *z*-axis (toward the viewer), use this:

```
E { transform: translateZ(30px); }
```

Now that you’ve met the new functions, let’s see them at work. In the following example, I show two elements that are styled identically but for different values for the `translateZ()` function:

```
➊ .trans-z1 { transform: translateZ(-40px); }
➋ .trans-z2 { transform: translateZ(40px); }
```

You can see the results in [Figure 13-5](ch13.html#ch13fig5)—note that I’ve angled the parent elements slightly and also made the elements transparent so you can more easily see the effect. In the first example (➊, on the left), the `translateZ()` function has a value of −40px, moving it negatively along the *z*-axis and making it appear smaller than its parent. The next (➋, on the right) has a value of 40px for `translateZ()`, moving it positively by that amount along the *z*-axis and making it appear larger.

**NOTE**
*This concept is much easier to grasp when you see the elements animated, so I once more encourage you to look at the accompanying example files to get a better feel for the way these functions behave.*

![Image](graphics/f13-05.jpg)

*Figure 13-5: Translation in different directions along the* z*-axis*

A shorthand function, `translate3d()`, is also available. This shorthand allows you to set all three values simultaneously. The syntax is a logical extension of the `translate()` function:

```
E { transform: translate3d(translateX,translateY,translateZ); }
```

Each of the arguments is equivalent to the named function, so each accepts a numerical value, positive or negative, with a CSS length unit or percentage, as shown here:

```
E { transform: translate3d(0,100%,1em); }
```

#### ***Scaling***

I also introduced the `scale()` function, along with the subfunctions `scaleX()` and `scaleY()`, in [Chapter 12](ch12.html#ch12). The move to three dimensions adds a new sub-function, `scaleZ()`, which has this syntax:

```
E { transform: scaleZ(number); }
```

As with its siblings, the `*number*` value provides a factor to scale the element by, so a value of 2 doubles the element’s size along the *z*-axis. The resulting behavior is probably not what you’d expect, however; the element itself has no depth, if you recall, so an increase in `scaleZ()` by itself doesn’t seem to change the element. What the increase actually does is act as a multiplier to any value that’s supplied to `translateZ()`. For example, consider this code:

```
E { transform: scaleZ(3) translateZ(10px); }
```

The `scaleZ()` function’s value of 3 multiplies the `translateZ` function’s value of 10px, so the element appears 30px (3 × 10px) along the *z*-axis.

In addition to `scaleZ()`, a new shorthand function, `scale3d()`, has also been added. Here is its syntax:

```
E { transform: scale3d(scaleX,scaleY,scaleZ); }
```

As should be fairly clear, this shorthand simply accepts a number for each of the values, acting as a scaling factor on the pertinent axis. Here is a pair of examples to show you 3D scaling in action:

```
➊ .trans-z1 { transform: scaleZ(2.5) translateZ(-10px); }
➋ .trans-z2 { transform: scale3d(1.25,1.25,4) translateZ(10px); }
```

The results appear in [Figure 13-6](ch13.html#ch13fig6). The first (left) example (➊) shows an element with a `translateZ()` value of −10px and a `scaleZ()` value of 2.5; as I mentioned, `scaleZ()` acts as a multiplier of `translateZ()`, so the element moves 25px negatively along the *z*-axis. In the second example (➋), I used the `scale3d` function to set values of 1.25 on the *x*-axis and *y*-axis and `4` on the *z*-axis. The resulting element, shown on the right, is 25 percent larger on the two-dimensional axes, and the `scaleZ()` value multiplies the `translateZ()` value of 10px to move the element 40px along the *z*-axis.

![Image](graphics/f13-06.jpg)

*Figure 13-6: Scaling on different and multiple axes*

#### ***The Transformation Matrix***

One of the more esoteric aspects of 2D transformations that I introduced in [Chapter 12](ch12.html#ch12) is the `matrix()` function. This function allows you to apply complex transformations using six values (based around a grid pattern) and some trigonometric calculations. You can also apply 3D transformations using a matrix with the `matrix3d()` function. But if you thought the 2D matrix was hard to grasp, you might want to skip this one—`matrix3d()` has a whopping 16 values! Here’s the syntax:

```
E { transform: matrix3d(
    m01,m02,m03,m04,
    m05,m06,m07,m08,
    m09,m10,m11,m12,
    m13,m14,m15,m16
); }
```

**NOTE**
*The line breaks are shown here for clarity; you don’t need to use them in practice.*

Each of the `*m*` values is a number, but I can’t even begin to explain what each of them does! I suggest you read an introduction to the subject (*[http://dev.opera.com/articles/understanding-the-css-transforms-matrix/](http://dev.opera.com/articles/understanding-the-css-transforms-matrix/)* is a good place to start) and decide if this is something you want to learn more about.

Here, I provide some simple examples using this code to demonstrate the functionality:

```
➊ .trans-1 { transform: matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,10,10,10,1); }
➋ .trans-2 { transform: matrix3d(1.5,0,0,0,0,1.5,0,0,0,0,2,0,0,0,10,1); }
➌ .trans-3 { transform: matrix3d(0.96,-0.26,0,0,0.26,0.96,0,0,0,0,1,0,-10, 0,20,1); }
```

You can see the results in [Figure 13-7](ch13.html#ch13fig7). The first (left) example (➊) shows the element moved 10px along each axis with the equivalent of the `translate3d()` function—the `*m13*`, `*m14*`, and `*m15*` values in the matrix operate as `translateX()`, `translateY()`, and `translateZ()`, respectively. In the second example (➋), I scaled the image by a factor of 1.5 on the *x*-axis and *y*-axis (the `*m1*` and `*m6*` values) and by a factor of 2 on the *z*-axis (the `*m11*` value), which multiplies the `translateZ()` value (`*m15*`) to move the element 20px along the *z*-axis, as shown in the middle example. The final example (➌) requires a scientific calculator for some trigonometric functions, as I’ve rotated the element by 15 degrees on the *z*-axis. To create the rotation, you need to give a value of cos(15)—which is 0.96—to `*m1*` and `*m6*` and then sin(15)—that is, 0.26—to `*m5*` and negative sin(15) to `*m2*`. I also translated the element by 10px on the *x*-axis with the value in `*m13*`. You can view the result on the right in the figure.

![Image](graphics/f13-07.jpg)

*Figure 13-7: Transformations applied with the* `*matrix3d()*` *function*

As I’m sure you can see, this function is quite powerful—and quite complex. Whether you want to learn the full potential of `matrix3d()` depends largely on you and your projects, but I feel it’s beyond the scope of this book. Don’t forget you can perform all of these transformations with the individual functions; you’ll end up with more code, but it will be easier to understand—not only for yourself but also for anyone tasked with maintaining the website after you!

### **The perspective and perspective-origin Properties**

Earlier in the chapter, I introduced the `perspective()` transformation function, but a `perspective` property is also available. The syntax is pretty straightforward:

```
E { perspective: depth; }
```

The property operates in the same way as the function: The `*depth*` value is a length unit that sets the distance from the element’s origin, *z* = 0\. In fact, the only difference between the function and the property is that the value supplied to the property applies only to its child elements, not to itself.

The companion property of `perspective` is `perspective-origin`. This property sets the point in 3D space from which you view the element. Here’s the syntax:

```
E { perspective-origin: x-position y-position; }
```

The `*x-position*` value can be any one of the keywords—`left`, `right`, or `center`—and the `*y-position*` value can be `top`, `bottom`, or `center`. Percentage or length values can also be used. You should be familiar with these pairs of values from using other properties, such as `background-position` or `transform-origin`.

The default is `center center` (or `50% 50%`), so you are viewing the line of perspective as if it started at the absolute center of the element. Changing the values of `perspective-origin` changes the origin of that line of perspective.

That may sound a little brain-bending; once again, showing it is easier than explaining it. In this next example, I show the same transformed element from different perspective origins. Here’s the code:

```
  .d3-parent { perspective: 200px; }
  .d3-child { transform: rotateX(45deg) rotateZ(90deg); }
➊ .trans-1 { perspective-origin: left center; }
➋ .trans-2 { perspective-origin: 100% 100%; }
➌ .trans-3 { perspective-origin: 75% 25%; }
```

The examples are illustrated in [Figure 13-8](ch13.html#ch13fig8). A reference example is shown first (at the far left); this is a transformed element viewed from the default origin of `center center`. The second example (➊) is the same element but with `perspective-origin` at the center of the left-hand side of the element. The angle you’re viewing the element from has changed; the viewpoint appears to be to the left of the element. In the third example (➋), I used length values of `100% 100%`, which changes the origin to the bottom of the right-hand side. The viewpoint appears to be to the right of the element, looking up. The last (far right) example (➌) is viewed from a point 75 percent along the *x*-axis and 25 percent along the *y*-axis; this example is similar to the reference example, but the viewpoint has shifted slightly to be just to the right of, and slightly above, the element.

![Image](graphics/f13-08.jpg)

*Figure 13-8: Different values for the* `*perspective-origin*` *property*

### **The Transformation Origin**

When explaining 2D transformations in [Chapter 12](ch12.html#ch12), I talked about each element’s origin point—the point at which all transformations are applied—and how you can set its position using the `transform-origin` property. The same property is also used for setting the origin point of 3D transformations, but as three dimensional coordinate systems have three axes (*x*-axis, *y*-axis, and *z*-axis), the property also accepts three values:

```
E { transform-origin: x y z; }
```

The first two values, `*x*` and `*y*`, act the same as in the `transform-origin` property for 2D elements; that is, they accept values as either a keyword (`left`, `right`, `center` for `*x*`, and `top`, `bottom`, `center` for `*y*`), a length unit, or a percentage. The default value is `center center`, or `50% 50%`. The third value, `*z*`, is a length value, which sets the distance along the *z*-axis that the transformation will happen. This value can seem quite counterintuitive as it seems to act in reverse; if a negative value is given, the transformation origin is behind the element, which makes it appear in front of its parent; likewise, a positive value places the origin in front of the element, making the element appear behind its parent.

I’ll illustrate this with a demonstration showing three elements identical in all values but `transform-origin`. Here’s the relevant code for these examples:

```
  .d3-child { transform: rotateX(45deg) rotateZ(90deg); }
➊ .trans-1 { transform-origin: 50% 0 0; }
➋ .trans-2 { transform-origin: 50% 100% 0; }
➌ .trans-3 { transform-origin: center bottom -50px; }
```

You can see the output in [Figure 13-9](ch13.html#ch13fig9). From left to right, the first example is, once again, a reference element, with the origin at its default position, dead center. The next (➊) shows the same element with the `transform-origin` value set to the center of the top side, and in the original (unchanged) position on the *z*-axis. The third example (➋) sets the transformation origin to the center-bottom of the element, and the final (far right) example (➌) has the same transformation origin on the *x*- and *y*-axes (set with keywords rather than percentages) but it’s 50px along the *z*-axis—that is, toward the viewer (as it appears).

![Image](graphics/f13-09.jpg)

*Figure 13-9: Different* `*transform-origin*` *values on a transformed element*

As before, you’ll see these differences much more clearly if you view the example files, as you can see the elements actually rotate around their transformation origin.

### **The transform-style Property**

When elements transformed in 3D are nested, the default behavior is that all descendant elements are flattened to the plane of the parent—that is, any transformation functions applied to child elements are ignored. You can change this behavior with a property called `transform-style`; here’s the syntax:

```
E { transform-style: keyword; }
```

The keyword value can be either `flat` (the default) or `preserve-3d`. Explaining the difference is easier if I start with an example: In this, I have two elements with identical rules applied, except for the value given to `transform-style`:

```
.trans-1 { transform-style: flat; }
.trans-2 { transform-style: preserve-3d; }
```

The difference, as shown in [Figure 13-10](ch13.html#ch13fig10), is quite stark: The example on the left has the default value of `flat`, so the inner element is kept in the same dimensional plane as its parent; you can clearly see the contrast with the second example, which has a `transform-style` value of `preserve-3d`, where the inner element sits in a separate plane, further along the *z*-axis from its parent.

**WARNING** *Internet Explorer 10 and 11 don’t support the* `*preserve-3d*` *value of this property.*

![Image](graphics/f13-10.jpg)

*Figure 13-10: Comparing the effects of different values for the* `*transform-style*` *property*

### **Showing or Hiding the Backface**

Sometimes you’ll encounter a situation where the element has been rotated to such a degree that it faces away from you and you are seeing the “back” of it (known as the *backface*). By default, the element behaves as if it were transparent, so you will see the reverse of what appears on the front. You can change this by using the `backface-visibility` property, which has this syntax:

```
E { backface-visibility: state; }
```

The `*state*` value is one of two keywords: `hidden` or `visible`. The default is `visible`, which behaves in the way I just described; the alternative, `hidden`, shows nothing. These work in the same way as the `visibility` property, which you should be familiar with from CSS2.

The following is a quick example illustrating the difference between the two `*state*`s by showing two elements that are identical except for their `backface-visibility` values. Here’s the code:

```
.d3-child {
    backface-visibility: visible;
    transform: rotateY(180deg);
}
.bf-hidden { backface-visibility: hidden; }
```

You can see the result in [Figure 13-11](ch13.html#ch13fig11). Both example elements are rotated around the *y*-axis so they are facing away from you. The example on the left shows the element with a value of `visible` on the `backface-visibility` property, so you can clearly see the back of the element. In the example on the right, you can see … well … nothing. The `backface-visibility` property has a value of `hidden`, so nothing is displayed—no `border`, no `background-color`, nothing. To confirm that the element is actually there, visit the website that accompanies this book and take a look at the animated code examples so you can better see how they work.

![Image](graphics/f13-11.jpg)

*Figure 13-11: Demonstrating the* `*backface-visibility*` *property*

### **Summary**

The introduction of the third dimension takes CSS into areas that are rich with potential—many demos are available that show clever uses of 3D transformations to build objects or environments. But, for me, the best use of the extra dimension is in smaller, subtle details; adding depth to rollover effects or making two-sided “cards” that flip to reveal information on the reverse.

As with everything, CSS 3D transformations are best used appropriately, so they add to the user experience of your websites rather than detract from it with unnecessary tricks.

### **3D Transformations: Browser Support**

|  | **Chrome** | **Firefox** | **Safari** | **IE** |
| 3D transformations | Yes | Yes | Yes^([*](ch13.html#footnote30a)) | IE10^([†](ch13.html#footnote31a)) |

[*](ch13.html#footnote_30a) With vendor prefix

[†](ch13.html#footnote_31a) No support for the `preserve-3d` value for `transform-style`