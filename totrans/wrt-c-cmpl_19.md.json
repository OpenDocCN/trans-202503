["```\nvoid return_nothing(void) {\n    return;\n}\n```", "```\nvoid perform_side_effect(void) {\n    extern int some_variable;\n    some_variable = 100;\n}\n```", "```\nflag ? perform_side_effect() : return_nothing();\n```", "```\n(void) (1 + 1);\n```", "```\nint i = 0;\nflag ? perform_side_effect() : (void) (i = 3);\n```", "```\nperform_side_effect();\n```", "```\nfor (perform_side_effect(); i < 10; perform_side_effect())\n    `--snip--`\n```", "```\n(void) perform_side_effect();\n```", "```\nvoid *malloc(size_t size);\n```", "```\nvoid *malloc(unsigned long size);\n```", "```\nint *many_ints = malloc(100 * sizeof (int));\n```", "```\nmany_ints[10] = 10;\n```", "```\nvoid free(void *ptr);\n```", "```\nfree(many_ints);\n```", "```\nsizeof (long);\nsizeof 10.0;\n```", "```\nint array[3];\nreturn sizeof array;\n```", "```\nreturn sizeof puts(\"Shouting into the void\");\n```", "```\ndouble *null_ptr = 0;\nreturn sizeof *null_ptr;\n```", "```\nprogram = Program(declaration*)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, initializer? init,\n                        type var_type, storage_class?)\nfunction_declaration = (identifier name, identifier* params, block? body,\n                        type fun_type, storage_class?)\ninitializer = SingleInit(exp) | CompoundInit(initializer*)\ntype = Char | SChar | UChar | Int | Long | UInt | ULong | Double **|** **Void**\n     | FunType(type* params, type ret)\n     | Pointer(type referenced)\n     | Array(type element, int size)\nstorage_class = Static | Extern\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(**exp?**)\n          | Expression(exp)\n | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(const)\n    | String(string)\n    | Var(identifier)\n    | Cast(type target_type, exp)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\n    | Dereference(exp)\n    | AddrOf(exp)\n    | Subscript(exp, exp)\n **| SizeOf(exp)**\n **| SizeOfT(type)**\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\nconst = ConstInt(int) | ConstLong(int) | ConstUInt(int) | ConstULong(int)\n      | ConstDouble(double) | ConstChar(int) | ConstUChar(int)\n```", "```\nsizeof (int) a;\n```", "```\nsizeof ((int) a);\n```", "```\n<type-name> ::= {<type-specifier>}+ [<abstract-declarator>]\n```", "```\n<cast-exp> ::= \"(\" <type-name> \")\" <cast-exp>\n             | <unary-exp>\n```", "```\n<unary-exp> ::= <unop> ❶ <cast-exp>\n              | \"sizeof\" ❷ <unary-exp>\n              | \"sizeof\" \"(\" <type-name> \")\"\n              | <postfix-exp>\n```", "```\n<exp> ::= **<cast-exp>** | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n```", "```\n<program> ::= {<declaration>}\n<declaration> ::= <variable-declaration> | <function-declaration>\n<variable-declaration> ::= {<specifier>}+ <declarator> [\"=\" <initializer>] \";\"\n<function-declaration> ::= {<specifier>}+ <declarator> (<block> | \";\")\n<declarator> ::= \"*\" <declarator> | <direct-declarator>\n<direct-declarator> ::= <simple-declarator> [<declarator-suffix>]\n<declarator-suffix> ::= <param-list> | {\"[\" <const> \"]\"}+\n<param-list> ::= \"(\" \"void\" \")\" | \"(\" <param> {\",\" <param>} \")\"\n<param> ::= {<type-specifier>}+ <declarator>\n<simple-declarator> ::= <identifier> | \"(\" <declarator> \")\"\n<type-specifier> ::= \"int\" | \"long\" | \"unsigned\" | \"signed\" | \"double\" | \"char\" **| \"void\"**\n<specifier> ::= <type-specifier> | \"static\" | \"extern\"\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<initializer> ::= <exp> | \"{\" <initializer> {\",\" <initializer>} [\",\"] \"}\"\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" **[<exp>]** \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= **<cast-exp>** | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n**<cast-exp> ::= \"(\" <type-name> \")\" <cast-exp>**\n **| <unary-exp>**\n<unary-exp> ::= <unop> **<cast-exp>**\n              **| \"sizeof\" <unary-exp>**\n              **| \"sizeof\" \"(\" <type-name> \")\"**\n              | <postfix-exp>\n**<type-name> ::= {<type-specifier>}+ [<abstract-declarator>]**\n<postfix-exp> ::= <primary-exp> {\"[\" <exp> \"]\"}\n<primary-exp> ::= <const> | <identifier> | \"(\" <exp> \")\" | {<string>}+\n                | <identifier> \"(\" [<argument-list>] \")\"\n<argument-list> ::= <exp> {\",\" <exp>}\n<abstract-declarator> ::= \"*\" [<abstract-declarator>]\n                        | <direct-abstract-declarator>\n<direct-abstract-declarator> ::= \"(\" <abstract-declarator> \")\" {\"[\" <const> \"]\"}\n                               | {\"[\" <const> \"]\"}+\n<unop> ::= \"-\" | \"~\" | \"!\" | \"*\" | \"&\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<const> ::= <int> | <long> | <uint> | <ulong> | <double> | <char>\n<identifier> ::= ? An identifier token ?\n<string> ::= ? A string token ?\n<int> ::= ? An int token ?\n<char> ::= ? A char token ?\n<long> ::= ? An int or long token ?\n<uint> ::= ? An unsigned int token ?\n<ulong> ::= ? An unsigned int or unsigned long token ?\n<double> ::= ? A floating-point constant token ?\n```", "```\nint main(void);\n```", "```\nFunType(params=[], ret=Int)\n```", "```\nint *a;\nvoid *b;\n`--snip--`\nreturn a == b;\n```", "```\nint *a;\nvoid *b;\n`--snip--`\nreturn flag ? a : b;\n```", "```\nint *a = 0;\nvoid *b = a;\n```", "```\nint use_int_pointer(int *a);\nvoid *ptr = 0;\nuse_int_pointer(ptr);\n```", "```\nget_common_pointer_type(e1, e2):\n    e1_t = get_type(e1)\n    e2_t = get_type(e2)\n    if e1_t == e2_t:\n        return e1_t\n    else if is_null_pointer_constant(e1):\n        return e2_t\n    else if is_null_pointer_constant(e2):\n        return e1_t\n    **else if e1_t == Pointer(Void) and e2_t is a pointer type:**\n        **return Pointer(Void)**\n    **else if e2_t == Pointer(Void) and e1_t is a pointer type:**\n        **return Pointer(Void)**\n    else:\n        fail(\"Expressions have incompatible types\")\n```", "```\nconvert_by_assignment(e, target_type):\n    if get_type(e) == target_type:\n        return e\n    if get_type(e) is arithmetic and target_type is arithmetic:\n        return convert_to(e, target_type)\n    if is_null_pointer_constant(e) and target_type is a pointer type:\n        return convert_to(e, target_type)\n **if target_type == Pointer(Void) and get_type(e) is a pointer type:**\n **return convert_to(e, target_type)**\n **if target_type is a pointer type and get_type(e) == Pointer(Void):**\n **return convert_to(e, target_type)**\n    else:\n        fail(\"Cannot convert type for assignment\")\n```", "```\nint return_int(void) {\n    return 1;\n}\n\nvoid return_void(void) {\n    return;\n}\n```", "```\nint return_int(void) {\n    return;\n}\n\nvoid return_void(void) {\n    return 1;\n}\n```", "```\nvoid return_void(void) {\n    return (void) 1;\n}\n```", "```\nis_scalar(t):\n    match t with\n    | Void -> return False\n    | Array(elem_t, size) -> return False\n    | FunType(param_ts, ret_t) -> return False\n    | _ -> return True\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | Unary(Not, inner) ->\n        typed_inner = typecheck_and_convert(inner, symbols)\n        if not is_scalar(get_type(typed_inner)):\n            fail(\"Logical operators only apply to scalar expressions\")\n `--snip--`\n```", "```\n | Cast(t, inner) ->\n        typed_inner = typecheck_and_convert(inner, symbols)\n `--snip--`\n      ❶ if t == Void:\n            return set_type(Cast(t, typed_inner), Void)\n      ❷ if not is_scalar(t):\n            fail(\"Can only cast to scalar type or void\")\n      ❸ if not is_scalar(get_type(typed_inner)):\n            fail(\"Cannot cast non-scalar expression to scalar type\")\n        else:\n            return set_type(Cast(t, typed_inner), t)\n```", "```\nis_complete(t):\n    return t != Void\nis_pointer_to_complete(t):\n    match t with\n    | Pointer(t) -> return is_complete(t)\n    | _ -> return False\n```", "```\n | Binary(Add, e1, e2) ->\n        typed_e1 = typecheck_and_convert(e1, symbols)\n        typed_e2 = typecheck_and_convert(e2, symbols)\n        t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n        if t1 and t2 are arithmetic:\n `--snip--`\n        else if **is_pointer_to_complete(t1)** and t2 is an integer type:\n `--snip--`\n        else if **is_pointer_to_complete(t2)** and t1 is an integer type:\n `--snip--`\n        else:\n            fail(\"Invalid operands for addition\")\n```", "```\nvoid (*ptr_to_void_array)[3];\n```", "```\nvalidate_type_specifier(t):\n    match t with\n    | Array(elem_t, size) ->\n      ❶ if not is_complete(elem_t):\n            fail(\"Illegal array of incomplete type\")\n validate_type_specifier(elem_t)\n    | Pointer(referenced_t) -> ❷ validate_type_specifier(referenced_t)\n    | FunType(param_ts, ret_t) ->\n        for param_t in param_ts:\n            validate_type_specifier(param_t)\n        validate_type_specifier(ret_t)\n  ❸ | _ -> return\n```", "```\nvoid *void_ptr = malloc(4);\nvoid *another_ptr = &*void_ptr;\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n    | `--snip--`\n    | Conditional(condition, e1, e2) ->\n        typed_cond = typecheck_and_convert(condition, symbols)\n        typed_e1 = typecheck_and_convert(e1, symbols)\n        typed_e2 = typecheck_and_convert(e2, symbols)\n      ❶ if not is_scalar(get_type(typed_cond)):\n            fail(\"Condition in conditional operator must be scalar\")\n        t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n        if t1 == Void and t2 == Void:\n          ❷ result_type = Void\n        else if t1 and t2 are arithmetic types:\n            result_type = get_common_type(t1, t2)\n        else if t1 or t2 is a pointer type:\n            result_type = get_common_pointer_type(typed_e1, typed_e2)\n        else:\n            fail(\"Cannot convert branches of conditional to a common type\")\n        `--snip--`\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | Binary(Equal, e1, e2) ->\n        typed_e1 = typecheck_and_convert(e1, symbols)\n        typed_e2 = typecheck_and_convert(e2, symbols)\n        t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n        if t1 or t2 is a pointer type:\n            common_type = get_common_pointer_type(typed_e1, typed_e2)\n        else **if t1 and t2 are arithmetic types:**\n            common_type = get_common_type(t1, t2)\n **else:**\n **fail(\"Invalid operands to equality expression\")**\n `--snip--`\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | SizeOfT(t) ->\n      ❶ validate_type_specifier(t)\n      ❷ if not is_complete(t):\n            fail(\"Can't get the size of an incomplete type\")\n        return set_type(e, ULong)\n    | SizeOf(inner) ->\n ❸ typed_inner = typecheck_exp(inner, symbols)\n      ❹ if not is_complete(get_type(typed_inner)):\n            fail(\"Can't get the size of an incomplete type\")\n        return set_type(SizeOf(typed_inner), ULong)\n```", "```\nFunCall(identifier fun_name, val* args, **val? dst**)\n```", "```\nReturn(**val?**)\n```", "```\nemit_tacky(e, instructions, symbols):\n    match e with\n  | `--snip--`\n    | Cast(Void, inner) ->\n        emit_tacky_and_convert(inner, instructions, symbols)\n        return PlainOperand(Var(\"DUMMY\"))\n```", "```\n | Conditional(condition, e1, e2) ->\n `--snip--`\n        cond = emit_tacky_and_convert(condition, instructions, symbols)\n        instructions.append(JumpIfZero(cond, e2_label))\n        dst = make_tacky_variable(get_type(e), symbols)\n        v1 = emit_tacky_and_convert(e1, instructions, symbols)\n        instructions.append_all(\n          ❶ [Copy(v1, dst),\n              Jump(end),\n              Label(e2_label)])\n v2 = emit_tacky_and_convert(e2, instructions, symbols)\n        instructions.append_all(\n          ❷ [Copy(v2, dst),\n              Label(end)])\n        return PlainOperand(dst)\n```", "```\n | Conditional(condition, e1, e2) ->\n `--snip--`\n        cond = emit_tacky_and_convert(condition, instructions, symbols)\n        instructions.append(JumpIfZero(cond, e2_label))\n        if get_type(e) == Void:\n            emit_tacky_and_convert(e1, instructions, symbols)\n            instructions.append_all(\n            [Jump(end),\n              Label(e2_label)])\n            emit_tacky_and_convert(e2, instructions, symbols)\n            instructions.append(Label(end))\n          ❶ return PlainOperand(Var(\"DUMMY\"))\n        else:\n `--snip--`\n```", "```\n | SizeOf(inner) ->\n        t = get_type(inner)\n        result = size(t)\n        return PlainOperand(Constant(ConstULong(result)))\n    | SizeOfT(t) ->\n        result = size(t)\n        return PlainOperand(Constant(ConstULong(result)))\n```", "```\nprogram = Program(top_level*)\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, type t, static_init* init_list)\n          | StaticConstant(identifier, type t, static_init init)\ninstruction = Return(**val?**)\n            | SignExtend(val src, val dst)\n            | Truncate(val src, val dst)\n            | ZeroExtend(val src, val dst)\n            | DoubleToInt(val src, val dst)\n            | DoubleToUInt(val src, val dst)\n            | IntToDouble(val src, val dst)\n            | UIntToDouble(val src, val dst)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | GetAddress(val src, val dst)\n            | Load(val src_ptr, val dst)\n            | Store(val src, val dst_ptr)\n            | AddPtr(val ptr, val index, int scale, val dst)\n            | CopyToOffset(val src, identifier dst, int offset)\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, **val?** dst)\nval = Constant(const) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\nMov(`<val type>`, val, `<dst register>`)\nRet\n```", "```\n`<fix stack alignment>`\n`<move arguments to general-purpose registers>`\n`<move arguments to XMM registers>`\n`<push arguments onto the stack>`\nCall(fun_name)\n`<deallocate arguments/padding>`\n❶ Mov(`<dst type>`, `<dst register>`, dst)\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">FunCall(fun_name, args,\n        dst)</samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><fix stack alignment>\n<move arguments to general-purpose registers>\n<move arguments to XMM registers>\n<push arguments onto the stack></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Call(fun_name)</samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><deallocate arguments/padding></samp>\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst type></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><dst register></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">, dst)</samp></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><fix stack alignment>\n<move arguments to general-purpose registers>\n<move arguments to XMM registers>\n<push arguments onto the stack></samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">Call(fun_name)</samp>\n<samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><deallocate arguments/padding></samp>\n```"]