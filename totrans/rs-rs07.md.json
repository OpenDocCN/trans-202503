["```\nfn test_inner<T>(init: T, frobnify: bool) { ... }\n#[test]\nfn test_1u8_frobnified() {\n  test_inner(1u8, true);\n}\n// ...\n#[test]\nfn test_1i128_not_frobnified() {\n  test_inner(1i128, false);\n}\n```", "```\nmacro_rules! test_battery {\n  ($($t:ty as $name:ident),*)) => {\n    $(\n      mod $name {\n        #[test]\n        fn frobnified() { test_inner::<$t>(1, true) }\n        #[test]\n        fn unfrobnified() { test_inner::<$t>(1, false) }\n      }\n    )*\n  }\n}\ntest_battery! {\n  u8 as u8_tests,\n  // ...\n  i128 as i128_tests\n);\n```", "```\nmacro_rules! clone_from_copy {\n  ($($t:ty),*) => {\n    $(impl Clone for $t {\n      fn clone(&self) -> Self { *self }\n    })*\n  }\n}\nclone_from_copy![bool, f32, f64, u8, i8, /* ... */];\n```", "```\nmacro_rules! /* macro name */ {\n  (/* 1st matcher */) => { /* 1st transcriber */ };\n  (/* 2nd matcher */) => { /* 2nd transcriber */ };\n}\n```", "```\n$($key:expr => $value:expr),+\n```", "```\n$(map.insert($key, $value);)+\n```", "```\nmacro_rules! let_foo {\n  ($x:expr) => {\n    let foo = $x;\n  }\n}\nlet foo = 1;\n// expands to let foo = 2;\nlet_foo!(2);\nassert_eq!(foo, 1);\n```", "```\nmacro_rules! please_set {\n  ($i:ident, $x:expr) => {\n    $i = $x;\n  }\n}\nlet mut x = 1;\nplease_set!(x, x + 1);\nassert_eq!(x, 2);\n```", "```\nmacro_rules! name_as_debug {\n  ($t:ty) => {\n    impl ::core::fmt::Debug for $t {\n      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result\n      { ::core::write!(f, ::core::stringify!($t)) }\n} }; }\n```"]