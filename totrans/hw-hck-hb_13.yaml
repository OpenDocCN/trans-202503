- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No Kiddin’: Real-Life Examples'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: You’ve learned about embedded systems, and you’ve learned about embedded attacks.
    You might still feel like the hands-on attack details for real systems is missing.
    This chapter will help bridge the gap between laboratory examples and real life,
    and we’ll provide examples of both fault injection and power analysis attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Fault Injection Attacks
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fault injection attacks have probably been used the most in (published) real-world
    attacks of products (compared to power analysis). Two high-profile examples you
    might have heard about are attacking the Sony PlayStation’s hypervisor and the
    Xbox 360 via the “reset glitch.” Gaming systems are interesting targets because
    they typically have some of the best security in consumer-level equipment. During
    the same timeframe that these PlayStation and Xbox 360 attacks were occurring,
    most other consumer electronics (such as routers and TVs) had no boot signing
    and required no advanced attacks to exploit. You can also explore details on attacks,
    such as the Nintendo Switch attack and beyond, if you want to see how device security
    has been improving.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: PlayStation 3 Hypervisor
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Game consoles are always going to be a target, as there is a motivated population
    interested in attacking them. Gamers may be looking to run pirated versions of
    games, may be interested in modifying the games themselves (or cheating within
    the games), or they may want to run custom code on a fairly widely available and
    powerful platform. This last reason was especially the case with the Sony PlayStation
    3, which had a unique Cell microprocessor that lent itself well to multiprocessing.
    Although now you would plan on just building an algorithm to put onto your graphics
    processing unit (GPU), the field of GPU computing was not as easily accessible;
    for example, CUDA was released in June 2007 and OpenCL in August 2008, but clusters
    of PlayStation 3 consoles were tested as early as January 2007.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The PlayStation release supported running Linux directly. Linux itself was running
    under control of the PlayStation hypervisor, which prevented the user from accessing
    anything unintended (such as secure key storage). Attacking the PlayStation effectively
    meant finding a way around the hypervisor, as only then could one probe into the
    rest of the system to recover critical secrets. After initial work on breaking
    the PlayStation 3 occurred, Sony announced it no longer would support running
    Linux on future PlayStation updates due to the security risks. This announcement
    had the side effect of giving hackers added incentive to fully break the PlayStation
    3, since running Linux on an updated PlayStation 3 now required a successful attack.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: What was this attack? We’re actually going to concentrate on the “initial work,”
    which occurred thanks to George Hotz (GeoHot) and wasn’t the final exploit on
    the PlayStation, but it remains a well-known attack, so it’s worth understanding
    as an example of a fault attack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: To understand the attack, we first have to look at some details on how the Linux
    kernel gets access to memory. To do so, the Linux kernel requests that the hypervisor
    allocate a memory buffer. The hypervisor duly allocates the requested buffer.
    The kernel also requests that a number of references be made in the hash table
    (HTAB) page index, so there are a number of references to this same block of memory.
    You can see an abstract view of the memory at this point in [Figure 13-1](#figure13-1),
    step 1.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![f13001](image_fi/278748c13/f13001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: The five steps of PS3 pwnage'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](#figure13-1) shows an abstract view of the memory contents throughout
    the attack. HTABs are “handles” that give the kernel access to a particular memory
    range, as indicated by the arrows. Gray cells are accessible only to the hypervisor,
    whereas white cells are accessible to the kernel.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Back to the attack. Everything until now is nice and safe. The kernel has read/write
    access to a block of memory, but the hypervisor is well aware of this memory and
    ensures that no out-of-bound reads or writes occur. The attack comes when we request
    that the hypervisor deallocate the memory by closing all those references made
    through the HTAB in step 1 of [Figure 13-1](#figure13-1). At this point in time,
    we insert a glitch onto the PS3 memory bus with the goal of failing one of the
    deallocations. We’ll explain in a second why this is important, but for now note
    that the attack works because the deallocation is never “verified.” If the pointer
    to what we were supposed to deallocate on the hardware is corrupted, the hypervisor
    won’t know about this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The physical fault comes from a logic-level signal inserted onto the memory
    data bus (that is, DQx pins). The original demo used a field-programmable gate
    array (FPGA) board to generate a short (~40ns) pulse, but later people re-creating
    this also demonstrated it with microcontrollers to generate similar pulses (in
    the 40 to 300ns range). As many deallocations are forced, the fault can simply
    be manually triggered. Specific timing isn’t needed since only one of the deallocations
    needs to fail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to step 2 in [Figure 13-1](#figure13-1): the kernel has access
    to a piece of memory that was not actually invalidated in the HTAB. The hypervisor
    isn’t aware of this, as it thinks it safely deallocated the memory and removed
    all references to it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The final stage of the attack is to generate a new virtual memory space that
    overlaps with this chunk of memory the kernel can read/write to. This virtual
    memory space will also include an HTAB for the page map within this virtual space,
    but if we are lucky, that HTAB will be in a chunk of memory we can read/write
    from, as shown in step 3 in [Figure 13-1](#figure13-1). If we can write to the
    HTAB, this means we can map memory pages into our space, which normally only the
    hypervisor should be able to do. This would bypass most protections since the
    memory pages appear to be passing through the valid HTAB, and the kernel itself
    is reading/writing a memory address that it is allowed to access.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击的最后阶段是生成一个新的虚拟内存空间，该空间与内核可以读写的内存块重叠。这个虚拟内存空间还将包括该虚拟空间内的页面映射的HTAB，但如果我们幸运的话，该HTAB将位于我们可以读写的内存块中，如[图13-1](#figure13-1)中步骤3所示。如果我们可以写入HTAB，这意味着我们可以将内存页映射到我们的空间中，这通常只有超监视器能够执行。这样可以绕过大多数保护机制，因为内存页看起来是通过有效的HTAB传递的，而且内核本身正在读写它允许访问的内存地址。
- en: The final step in achieving full read/write access is to remap the original
    HTAB so we can read/write to this table directly, as shown in step 4 in [Figure
    13-1](#figure13-1). By switching back to the original memory space (not the virtual
    memory space created for the attack), we can now write to the main HTAB to remap
    arbitrary memory pages into our buffer. Since we have read/write access to this
    buffer, we can get read/write access to any memory locations, including the hypervisor
    code itself, as shown in step 5 in [Figure 13-1](#figure13-1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实现完全读写访问的最后一步是重新映射原始HTAB，以便我们可以直接对这个表进行读写，如[图13-1](#figure13-1)中步骤4所示。通过切换回原始内存空间（而不是为攻击创建的虚拟内存空间），我们现在可以写入主HTAB，从而将任意内存页映射到我们的缓冲区中。由于我们对这个缓冲区拥有读写访问权限，我们可以获得对任何内存位置的读写访问权限，包括超监视器代码本身，如[图13-1](#figure13-1)中步骤5所示。
- en: The vulnerability can occur because the hypervisor became decoupled from the
    HTAB status, so it isn’t aware the kernel still has read/write access to the newly
    created virtual memory space. It’s also helped by the hypervisor allowing the
    kernel to discover the actual memory address of that initial buffer by standard
    API calls (which helps when creating the virtual memory space in getting the HTAB
    overlap).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞的产生是因为超监视器与HTAB状态脱耦，因此它无法意识到内核仍然拥有对新创建的虚拟内存空间的读写访问权限。这个漏洞也受到超监视器允许内核通过标准API调用发现该初始缓冲区的实际内存地址的帮助（这在创建虚拟内存空间时有助于获取HTAB重叠）。
- en: If you’re interested in more details, you may be able to find a mirror of the
    original code posted by Hotz. Due to a lawsuit, Hotz stopped any further work
    on Sony products. You may also find useful a series of blog posts by xorloser
    that include both the original details and some updated versions of the attack
    tools (called XorHack). These blog posts provide complete examples of the attack
    if you want the gory details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对更多细节感兴趣，你可以找到Hotz发布的原始代码镜像。由于诉讼，Hotz停止了对Sony产品的进一步工作。你还可以找到xorloser发布的一系列博客文章，其中包括原始细节和一些更新版本的攻击工具（称为XorHack）。这些博客文章提供了完整的攻击示例，如果你想了解详细的技术内容，可以参考。
- en: The takeaway is that with fault attacks, one can use a variety of methods to
    apply the fault. The attack may not be limited to the voltage, clock, electromagnetic
    (EM), and optical fault injection methods, for example. In this case, the memory
    bus itself is faulted, which may be a more exposed target than attempting to insert
    a fault onto the power supply of a complex device. The fault injection device
    can be a simple microcontroller, and it even works with an Arduino used to pulse
    the appropriate memory bus pin.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，在故障攻击中，可以使用多种方法来施加故障。例如，攻击不局限于电压、时钟、电磁（EM）和光学故障注入方法。在这种情况下，内存总线本身出现故障，这可能比尝试在复杂设备的电源上注入故障更容易成为目标。故障注入设备可以是一个简单的微控制器，甚至可以使用Arduino来脉冲相应的内存总线引脚。
- en: The other takeaway is that clever target preparation makes life much easier.
    Although the attack would work with careful timing to fault a single HTAB entry,
    it’s much easier to force a massive number of entries to be modified at once.
    Doing so allows rather loose timing on the fault injection, as the attack is designed
    such that only a small number of successes would be needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个结论是巧妙的目标准备使得攻击更加轻松。尽管攻击可以通过精确的时序来故障单个HTAB条目，但同时修改大量条目要容易得多。这样做可以在故障注入时使用较为宽松的时序，因为该攻击设计成只需少量的成功即可完成。
- en: Xbox 360
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Xbox 360
- en: The Xbox 360 is another game console that has been successfully attacked with
    fault injection. This work is primarily credited to GliGli and Tiros, with previous
    reverse engineering work done by various users (see [https://github.com/Free60Project](https://github.com/Free60Project)
    for full credits for the Reset Glitch Hack, and see the detailed hardware on [https://github.com/gligli/tools/tree/master/reset_glitch_hack](https://github.com/gligli/tools/tree/master/reset_glitch_hack)).
    [Figure 13-2](#figure13-2) shows a high-level overview of the attack steps.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The Xbox 360 has a ROM-based first-stage bootloader (1BL) that loads the second-stage
    bootloader (2BL, also referred to as CB on the Xbox) stored in NAND flash. The
    1BL verifies the RSA signature of the 2BL before loading it. Finally, 2BL loads
    a block called CD that includes the hypervisor and kernel—basically meaning we
    would ideally prefer to load our own CD block, as then we don’t even need to exploit
    the hypervisor since we’d simply be running our own code entirely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The 2BL block will verify the expected SHA-1 hash for the CD block before running
    this code. Because the 2BL block was checked with an RSA signature, we can’t modify
    the SHA-1 hash that the 2BL block expects for the CD block without being detected.
    If we had an SHA-1 hash collision, we could load our own (unexpected) code, but
    there is a much easier way forward.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The SHA-1 will be calculated on the CD code and then compared with something
    like `memcmp()`. We know such operations are susceptible to fault attacks, so
    we could look to insert a glitch at this point in time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the timing, some hardware features of the Xbox 360 are used. In
    particular, the main central processing unit (CPU) has an exposed pin that can
    be used to bypass the phase-locked loop (PLL). The result is the CPU runs at a
    much slower 520 kHz. This pin has been labeled CPU_PLL_BYPASS in the examples,
    but keep in mind, these pin names are not based on public documentation such as
    a datasheet. It’s possible this pin is actually something like a feedback loop
    for the PLL, but grounding it has the same effect as if it were a bypass enabled
    for the PLL.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![f13002](image_fi/278748c13/f13002.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: Sequence of a successful fault attack on the Xbox 360 “fat” version'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: With the CPU now running at a slower speed, it is easier to fine-tune the fault
    injection timing. In this case, the fault injection method is a short spike on
    the reset line of the CPU. Rather than reset the system, this fault causes the
    SHA-1 comparison to report a successful comparison, even if the SHA-1 hash doesn’t
    match.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: If the reset line fault isn’t successful, one might expect other avenues, such
    as voltage or electromagnetic fault injection, might be successful. But like the
    PlayStation attacks, the goal is to develop very simple tools such that the attack
    is easy to replicate. Sending simple logic-level signals onto the reset pin is
    something one can do with a complex programmable logic device (CPLD), a field-programmable
    gate array (FPGA), or a microcontroller.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: And the modchips are doing exactly that. These chips “weaponize” the fault vulnerability.
    They use details of the power-on self-test (POST) system that reports the boot
    progress. By tying into the POST reporting, it’s possible to know almost exactly
    when to trigger the slow clock operation and then inject the reset glitch. Like
    any fault attack, the reset glitch will not have a perfect success rate. If the
    glitch is unsuccessful, the modchip detects it, resets the system properly, and
    simply tries again. This process allows loading of an unsecured binary in 30–60
    seconds in most cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Again, clever preparation has turned a relatively complex target into one that
    can be attacked with basic electronics. In this case, rather than forcing a number
    of vulnerable operations to occur, the target is slowed down considerably. Later
    revisions of the hardware did not have the same test point but instead exposed
    the clock generator on the I2C bus. By tying into the I2C bus, an attacker could
    slow down the main CPU with similar results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Having external control over the clock frequency may be possible, even for complex
    targets. For example, a target may use a PLL to multiply up a crystal frequency;
    replacing a 12 MHz crystal with a 1 MHz oscillator might make the main CPU run
    at 66.7 MHz instead of the targeted 800 MHz. Whether this is successful is far
    from a sure thing, however. The PLLs and oscillators themselves have limits (they
    may not operate that slowly), external parts such as DRAM will have upper and
    lower frequency limits (DRAM chips have minimum and maximum refresh times), and
    the CPU may detect frequency deviation and shut itself down to prevent attacks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The Xbox 360 reset glitch shows that time spent “exploring” a target may be
    useful in finding vulnerabilities that are exploitable at scale. In this case,
    reaching a reliable fault attack combines several observations that alone might
    not have been an obvious attack vector: the boot stages are known to an observer
    in real time; a pin on the CPU allows running at a much slower speed, and short
    glitches on the reset pin (at least when running very slowly) do not correctly
    reset the chip, but instead insert faults.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Power Analysis Attacks
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fault injection attacks demonstrated in the previous section were used to
    achieve temporary privileges beyond what the security architecture was supposed
    to permit (allowing loading of unsigned firmware, for example). Although fault
    injection can be about information disclosure through a memory dump or key disclosure
    through differential fault analysis, it is often about gaining privileges to then
    continue the attack. By comparison, power analysis is almost entirely concerned
    with revealing sensitive information, such as encryption keys. The difference
    is that a successful power analysis attack may provide you with the “keys to the
    kingdom.” These keys can make it impossible to discern an attacker from a legitimate
    owner or operator, and they may allow scaling without the further need of a hardware
    attack.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中展示的故障注入攻击被用来获取超出安全架构原本许可的临时权限（例如，允许加载未签名的固件）。虽然故障注入可以通过内存转储或通过差分故障分析泄露密钥，但它通常是为了获得权限，从而继续攻击。相比之下，功率分析几乎完全关注于揭示敏感信息，例如加密密钥。区别在于，成功的功率分析攻击可能为你提供“王国的钥匙”。这些密钥可能使得难以区分攻击者和合法的所有者或操作员，并且它们可能允许在没有进一步硬件攻击的情况下进行规模扩展。
- en: Philips Hue Attack
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 飞利浦 Hue 攻击
- en: 'The Philips Hue bulbs are smart lights that allow various settings to be controlled
    remotely by the owner. These lights communicate with the Zigbee Light Link (ZLL),
    which runs over a very constrained wireless network protocol (IEEE 802.15.4).
    Here we present part of “IoT Goes Nuclear: Creating a ZigBee Chain Reaction,”
    by Eyal Ronen et al. This work details recovering Philips Hue firmware encryption
    keys. After finding a bug, the authors also managed to bypass the “proximity test,”
    which these lightbulbs normally use to protect them from being disassociated from
    their network by an attacker more than about 1 meter away. This bug and proximity
    test bypass allow an attacker to create a worm that disassociates a victim bulb
    from the network within full Zigbee range (30–400 meters, depending on conditions)
    and remotely installs the wormed firmware, after which the now-infected bulb starts
    attacking other bulbs. Power analysis is used to compromise the (global) firmware
    encryption and signing key.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 飞利浦 Hue 灯泡是智能灯具，允许所有者远程控制各种设置。这些灯具通过 Zigbee Light Link (ZLL) 进行通信，该协议运行在一个非常受限的无线网络协议（IEEE
    802.15.4）上。这里我们展示了“物联网走向核爆：创建 ZigBee 链式反应”（Eyal Ronen 等人）的部分内容。该研究详细说明了如何恢复飞利浦
    Hue 固件的加密密钥。在发现一个漏洞后，作者还成功绕过了这些灯泡通常用来防止它们被距离超过 1 米的攻击者从网络中断开的“接近性测试”。这个漏洞和接近性测试绕过使得攻击者能够创建一个蠕虫程序，在完整的
    Zigbee 范围内（30-400 米，取决于条件）使受害者灯泡从网络中断开，并远程安装蠕虫固件，之后已感染的灯泡开始攻击其他灯泡。通过功率分析，攻击者能够破坏（全球）固件的加密和签名密钥。
- en: The Zigbee Light Link
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Zigbee Light Link
- en: ZLL is a specific version of Zigbee (not the same as regular Zigbee or Zigbee
    Home Automation) that, like Zigbee, uses a low-power wireless protocol called
    IEEE 802.15.4\. ZLL has a simple method of letting a new device, such as a bulb
    you just purchased, join the network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ZLL 是 Zigbee 的一个特定版本（与常规 Zigbee 或 Zigbee 家庭自动化不同），它像 Zigbee 一样，使用一种称为 IEEE 802.15.4
    的低功耗无线协议。ZLL 有一个简单的方法，允许新设备（比如你刚购买的灯泡）加入网络。
- en: This joining process relies on a fixed master key to transfer the unique network
    key to the new bulb, and the device will be connected to a network with the unique
    key. The shared master key is no longer in use in the network once the unique
    key is transferred, as the master key was always at risk of being leaked. The
    network owner would have to put the network in a mode that allows new devices
    to join, so new devices cannot be added without the owner’s knowledge. This explanation,
    however, doesn’t describe how we solve the problem of replacing a bridge that
    has died, or if a user needs to move a bulb from one network to another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加入过程依赖于一个固定的主密钥，将唯一的网络密钥传递给新灯泡，设备将连接到一个具有唯一密钥的网络。一旦唯一密钥被传递，网络中不再使用共享的主密钥，因为主密钥始终有泄露的风险。网络所有者需要将网络置于允许新设备加入的模式，这样新设备无法在没有所有者知情的情况下被添加。然而，这个解释并没有描述我们如何解决替换已经故障的桥接器，或者用户需要将灯泡从一个网络移到另一个网络的问题。
- en: Bypassing Proximity Checking
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绕过接近性检查
- en: For scenarios where the unique network key needs to change, we come into the
    second portion, a special “Reset to Factory New” message, which allows someone
    to de-authenticate a bulb from an existing network such that it can now join a
    different network. To perform this step, you needed to be physically close (~1
    meter range). The ZLL master key (as you might expect) was leaked, meaning anyone
    could send those messages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The proximity check is normally done by rejecting messages less than a certain
    signal strength. Although it’s possible to use high-power radio transmitters to
    fake the radio distance and reset devices from a longer range, doing so isn’t
    “wormable,” as the Hue transmitter itself isn’t strong enough. A wormable solution
    presented itself via a firmware bug and some compatibility requirements. First,
    a crafted “Reset to Factory New” message is sent to the victim. It’s designed
    to exploit the firmware bug such that the proximity test is bypassed. After the
    factory reset, the victim actively starts searching for Zigbee networks. The details
    are in the paper; here we focus on the power analysis part of the attack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Firmware Updates on Hue
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we have reached the stage where a device could be forced to join a new,
    attacker-controlled network, at which point you could send a firmware update request.
    The real question is, what is the actual format of the firmware update file and
    how can we send one ourselves? At this stage, we reset your vision of the attack
    setup and return to a legitimate Philips Hue lamp.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The Philips Hue lamps have the ability to perform a firmware update. By standard
    reverse engineering techniques, along with just looking at sample implementations
    of Zigbee over-the-air (OTA) update mechanisms posted as part of reference designs,
    we can learn how it works. When a bulb needs a firmware update, it downloads the
    file from the bridge device (which previously downloaded it from a remote server)
    into an external SPI flash memory chip. The actual OTA download can take some
    time (often at least an hour), as only small amounts are sent in each packet.
    If the network is in a busy wireless environment or the bulb is at the edge of
    radio range, this time can be extended considerably.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Rather than attempt to sniff an update from this slow OTA interface directly,
    we can look at what’s happening to the SPI chip, which provides us with an “update-ready”
    SPI flash image. If we want to trigger an update on a given bulb, we can just
    write this SPI image to the SPI flash chip, and the bulb will perform the actual
    reprogramming of itself. This programming is initiated by a byte in the SPI flash
    image that indicates the bulb is ready for an update. On boot, the bulb checks
    the value of this byte and triggers the programming, if indicated. This programming
    mechanism also means that if you interrupted the reprogramming phase by turning
    the bulb power off, on the next boot, the bulb would automatically restart the
    reprogramming step.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Getting Firmware Keys with Power Analysis
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过功率分析获取固件密钥
- en: AES-CCM is used for encrypting and authenticating the firmware file (the AES-CCM
    specification is available in IETF RFC 3610), so we cannot simply upload any forged
    image. We first need to extract the key. To do this, the SPI flash chip becomes
    our “input” to the encryption algorithm that we can break with power analysis.
    In this case, CCM makes things a little trickier than you might assume at first
    guess. We no longer have a direct input to each of the encryption modes, as AES-CCM
    uses AES-CTR mode along with AES-CBC. [Figure 13-3](#figure13-3) gives an incomplete
    overview of CCM, focused only on what we need for the attack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: AES-CCM 用于加密和验证固件文件（AES-CCM 的规范可以在 IETF RFC 3610 中找到），因此我们不能简单地上传任何伪造的映像。我们首先需要提取密钥。为此，SPI
    闪存芯片成为我们加密算法的“输入”，我们可以通过功率分析破解它。在这种情况下，CCM 使得事情比你最初猜测的要复杂一些。我们不再有每个加密模式的直接输入，因为
    AES-CCM 使用了 AES-CTR 模式与 AES-CBC 一起使用。[图 13-3](#figure13-3) 提供了一个不完整的 CCM 概述，只关注我们攻击所需要的部分。
- en: 'The top row of AES blocks are AES in CTR mode: an increasing counter is encrypted
    to obtain 128-bit chunks of stream cipher (*CTR*[*m*], 8). This is used to decrypt
    the ciphertext using a simple XOR operation (9). To create the authentication
    tag, the bottom row of AES blocks’ ciphertext is being XOR’d to the input of the
    next block (3, 5), which constitutes the cipher block chaining (*CBC*[*m*], 2,
    4). We left out some pieces of how the authentication tag is precisely calculated,
    but that’s irrelevant for the attack.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: AES 块的最上一行是 AES 在 CTR 模式下：一个递增的计数器被加密以获得128位的流密码块（*CTR*[*m*], 8）。这用于通过简单的 XOR
    操作解密密文（9）。为了创建身份验证标签，AES 块的最下一行密文被 XOR 到下一个块的输入（3, 5），这构成了密码块链接（*CBC*[*m*], 2,
    4）。我们省略了一些关于身份验证标签是如何精确计算的细节，但这些对攻击来说并不重要。
- en: '![f13003](image_fi/278748c13/f13003.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f13003](image_fi/278748c13/f13003.png)'
- en: 'Figure 13-3: All you need to know about AES-CCM for the attack'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3：攻击中需要了解的所有 AES-CCM 信息
- en: How do we attack CCM using power analysis? Going after AES-CTR is not an option,
    since we don’t know the input (7, because of the unknown IV), and we don’t know
    the output either, as that is the cipher stream, which is never accessible (8).
    On the AES-CBC, we also cannot perform a vanilla CPA; the input is the decrypted
    firmware (9, which we don’t know), and the output of the AES-CBC (2, 4) is never
    accessible. However, Ronen et al. describe how to perform a clever key transformation
    (like we did in Chapter 12) that allows obtaining the key from the AES-CBC (1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通过功率分析攻击 CCM？直接攻击 AES-CTR 不行，因为我们不知道输入（7，因为 IV 是未知的），也不知道输出，因为那是密码流，永远无法访问（8）。在
    AES-CBC 中，我们也无法执行普通的 CPA；输入是解密后的固件（9，我们不知道），AES-CBC 的输出（2, 4）也永远无法访问。不过，Ronen
    等人描述了如何进行巧妙的密钥变换（就像我们在第12章中做的那样），从而能够从 AES-CBC 中获得密钥（1）。
- en: Let’s start at the top, with the ciphertext *CT*. We split that into 128-bit
    blocks, *CT*[*m*], where *m* is the block index. AES-CTR decryption is a stream
    cipher, and we’ll write the stream (8) as *CTR*[*m*] = `AES`(*k*, *IV*[*ctr*]
    || *m*), where || is concatenation of bits, so we can write the *PT* (9) coming
    out of it as *PT*[*m*] = *CT*[*m*] ⊕ *CTR*[*m*].
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最上面开始，先看密文 *CT*。我们将其分割成128位的块，*CT*[*m*]，其中 *m* 是块的索引。AES-CTR 解密是一种流密码，我们将流（8）写作
    *CTR*[*m*] = `AES`(*k*, *IV*[*ctr*] || *m*)，其中 || 表示位的连接，所以我们可以将从中得到的 *PT*（9）写作
    *PT*[*m*] = *CT*[*m*] ⊕ *CTR*[*m*]。
- en: The *IV*[*ctr*] in CCM consists of a few fields, but basically the nonce is
    the big unknown to us at this point. For simplicity, we’ll just say we don’t know
    *IV*[*ctr*] (for now).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CCM 中的 *IV*[*ctr*] 由几个字段组成，但基本上此时对我们来说最大的未知数是 nonce。为了简化，我们暂时可以说我们不知道 *IV*[*ctr*]（暂时如此）。
- en: Next, AES-CBC is used to encrypt *PT*[*m*], generating the authentication tag.
    We can write output block *m* of CBC (2, 4) as *CBC*[*m*] = `AES`(*k*, *PT*[*m*]
    ⊕ *CBC*[*m–1*]), with block *m* = *0* defined using *CBC*[*-1*] = *IV*[*mac*].
    We can substitute *PT*[*m*]to get *CBC*[*m*] = `AES` (*k*, *CT*[*m*] ⊕ *CTR*[*m*]
    ⊕ *CBC*[*m–1*]).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，AES-CBC 用于加密 *PT*[*m*]，生成身份验证标签。我们可以将 CBC 的输出块 *m*（2, 4）写作 *CBC*[*m*] =
    `AES`(*k*, *PT*[*m*] ⊕ *CBC*[*m–1*])，其中块 *m* = *0* 使用 *CBC*[*-1*] = *IV*[*mac*]
    来定义。我们可以替换 *PT*[*m*] 来得到 *CBC*[*m*] = `AES` (*k*, *CT*[*m*] ⊕ *CTR*[*m*] ⊕ *CBC*[*m–1*])。
- en: So far so good, although everything in that formula is unknown except for the
    *CT*. In a regular AES-ECB power analysis attack, we assume we at least know the
    plaintext or the ciphertext, and thus we can recover *k*. The problem with any
    of the preceding AES functions is that we don’t know the input and we don’t know
    the output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The cleverness comes in at this point. In AES, `AddRoundKey`(*k, p*) is just
    *k* ⊕ *p*, meaning we can rewrite `AddRoundKey`(*k*, *p* ⊕ *d*) = `AddRoundKey`(*k*
    ⊕ *p*, *d*). This means if *p* is unknown and fixed, we can just consider it to
    be part of a transformed key *k* ⊕ *p*. If we control *d*, we can do a CPA attack
    to recover *k* ⊕ *p*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In our CCM case, we can’t attack `AddRoundKey`(*k*, *CT*[*m*] ⊕ *CTR*[*m*] ⊕
    *CBC*[*m–1*]), but we can attack `AddRoundKey`(*k* ⊕ *CTR*[*m*] ⊕ *CBC*[*m–1*],
    *CT*[*m*]), because we control *CT*[*m*]! Assuming the target leaks, we can use
    *CPA*[*a*] (see [Figure 13-4](#figure13-4)) to find the transformed key *k* ⊕
    *CTR*[*m*] ⊕ *CBC*[*m-1*], which in itself isn’t useful. This transformed key
    allows us to calculate all intermediate data until the second `AddRoundKey`(*k*,
    *p′*). This second `AddRoundKey` again uses *k*, which we don’t know. However,
    since we know the transformed round key and *CT*, we can calculate *p′*. We can
    now apply a vanilla *CPA*[*b*] attack using *p′* to recover *k* from the second
    round of AES.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![f13004](image_fi/278748c13/f13004.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: Two CPA attacks: one on the transformed key and one on the regular
    key'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Once we have *k* (1 in [Figure 13-3](#figure13-3)), we have a few more steps
    to go. Note that we still don’t have *PT* or any of the IVs. However, *k* allows
    us to finish the “modified” AES calculation of [Figure 13-4](#figure13-4) to obtain
    the *CBC*[*m*] blocks 2. This block we can now decrypt to get *CT*[*m*] ⊕ *CTR*[*m*]
    ⊕ *CBC*[*m–1*] 3, and because we know *CT*[*m*], we know *CTR*[*m*] ⊕ *CBC*[*m–1*].
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: For the final blow, we can use the same attack on the subsequent block *m+1*.
    This allows us to find *CBC*[*m+1*] 4 and *CT*[*m+1*] ⊕ *CTR*[*m+1*]⊕ *CBC*[*m*]
    5. Since we already knew *CT*[*m+1*] and *CBC*[*m*] from the previous attack,
    we can XOR it out and calculate *CTR*[*m+1*] 6, which is equal to `AES`(*k*, *IV*[*ctr*]
    || *m+1*). Since we know *k*, we can decrypt this to find *IV*[*ctr*] 7, and we
    subsequently can calculate *CTR*[*m*] for any *m* 8, which finally allows us to
    decrypt *PT*[*m*] = *CTR*[*m*] ⊕ *CT*[*m*] 9!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We now have the firmware key and plaintext; therefore, we have easy access to
    forge firmware. Using the attack that allows us to disassociate a Hue from its
    network and upload new firmware, we could create a worm that propagates throughout
    a city. In the paper, the authors calculate that for a city like Paris, about
    15,000 Hue lights need to be present for the worm to take over all of the Hue
    lights in the city.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This attack combines a scalable/real-life attack, hardware reverse engineering,
    wireless communication, protocol abuse, exploiting a firmware bug, *and* a power
    analysis attack on CCM. Add whipped cream, and it would be the perfect dessert.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we described how the PlayStation 3, Xbox 360, and Philips Hue
    lights were broken using hardware attacks. Especially in systems that have a small
    density of software flaws, hardware attacks can be a critical step leading to
    compromise.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
