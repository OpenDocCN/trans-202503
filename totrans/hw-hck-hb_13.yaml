- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: 'No Kiddin’: Real-Life Examples'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不开玩笑：现实生活中的例子
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: You’ve learned about embedded systems, and you’ve learned about embedded attacks.
    You might still feel like the hands-on attack details for real systems is missing.
    This chapter will help bridge the gap between laboratory examples and real life,
    and we’ll provide examples of both fault injection and power analysis attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了嵌入式系统，并且了解了嵌入式攻击。你可能仍然觉得缺少有关真实系统的实际攻击细节。本章将帮助弥补实验室示例与现实生活之间的差距，我们将提供故障注入和电源分析攻击的例子。
- en: Fault Injection Attacks
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障注入攻击
- en: Fault injection attacks have probably been used the most in (published) real-world
    attacks of products (compared to power analysis). Two high-profile examples you
    might have heard about are attacking the Sony PlayStation’s hypervisor and the
    Xbox 360 via the “reset glitch.” Gaming systems are interesting targets because
    they typically have some of the best security in consumer-level equipment. During
    the same timeframe that these PlayStation and Xbox 360 attacks were occurring,
    most other consumer electronics (such as routers and TVs) had no boot signing
    and required no advanced attacks to exploit. You can also explore details on attacks,
    such as the Nintendo Switch attack and beyond, if you want to see how device security
    has been improving.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入攻击可能是（公开的）真实世界攻击中使用最多的攻击手段（相较于电源分析）。你可能听说过的两个高调例子是攻击索尼PlayStation的虚拟机和通过“重置漏洞”攻击Xbox
    360。游戏系统是有趣的攻击目标，因为它们通常拥有一些最强的消费者级别设备安全性。在这些PlayStation和Xbox 360攻击发生的同一时间段，其他大多数消费电子产品（如路由器和电视）都没有启动签名，且无需高级攻击就能被利用。如果你想看看设备安全如何改进，还可以探索其他攻击细节，比如任天堂Switch的攻击等。
- en: PlayStation 3 Hypervisor
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PlayStation 3虚拟机
- en: Game consoles are always going to be a target, as there is a motivated population
    interested in attacking them. Gamers may be looking to run pirated versions of
    games, may be interested in modifying the games themselves (or cheating within
    the games), or they may want to run custom code on a fairly widely available and
    powerful platform. This last reason was especially the case with the Sony PlayStation
    3, which had a unique Cell microprocessor that lent itself well to multiprocessing.
    Although now you would plan on just building an algorithm to put onto your graphics
    processing unit (GPU), the field of GPU computing was not as easily accessible;
    for example, CUDA was released in June 2007 and OpenCL in August 2008, but clusters
    of PlayStation 3 consoles were tested as early as January 2007.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏主机始终是攻击的目标，因为有一群有动机的用户希望攻击它们。玩家可能想运行盗版游戏，可能有兴趣修改游戏本身（或者在游戏中作弊），或者他们可能希望在一个相对广泛可用且强大的平台上运行自定义代码。尤其是在索尼PlayStation
    3的情况下，它采用了独特的Cell微处理器，能够很好地支持多任务处理。虽然现在你可能计划将一个算法直接放到你的图形处理单元（GPU）上，但GPU计算领域在当时并不像现在这么容易接触；例如，CUDA在2007年6月发布，OpenCL在2008年8月发布，但PlayStation
    3主机集群早在2007年1月就已经开始测试。
- en: The PlayStation release supported running Linux directly. Linux itself was running
    under control of the PlayStation hypervisor, which prevented the user from accessing
    anything unintended (such as secure key storage). Attacking the PlayStation effectively
    meant finding a way around the hypervisor, as only then could one probe into the
    rest of the system to recover critical secrets. After initial work on breaking
    the PlayStation 3 occurred, Sony announced it no longer would support running
    Linux on future PlayStation updates due to the security risks. This announcement
    had the side effect of giving hackers added incentive to fully break the PlayStation
    3, since running Linux on an updated PlayStation 3 now required a successful attack.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: PlayStation支持直接运行Linux。Linux本身在PlayStation虚拟机的控制下运行，虚拟机阻止了用户访问任何不当的内容（例如安全密钥存储）。有效地攻击PlayStation意味着要找到绕过虚拟机的方法，只有这样才能深入系统的其他部分，恢复关键的机密信息。在最初的PlayStation
    3破解工作完成后，索尼宣布未来的PlayStation更新将不再支持运行Linux，因为存在安全风险。这一宣布间接激励了黑客进一步攻破PlayStation
    3，因为在更新后的PlayStation 3上运行Linux现在需要成功的攻击。
- en: What was this attack? We’re actually going to concentrate on the “initial work,”
    which occurred thanks to George Hotz (GeoHot) and wasn’t the final exploit on
    the PlayStation, but it remains a well-known attack, so it’s worth understanding
    as an example of a fault attack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么攻击？我们实际上将专注于“初步工作”，这项工作得益于乔治·霍兹（George Hotz，GeoHot），并不是最终的PlayStation漏洞，但它仍然是一个著名的攻击，因此作为故障攻击的一个例子值得了解。
- en: To understand the attack, we first have to look at some details on how the Linux
    kernel gets access to memory. To do so, the Linux kernel requests that the hypervisor
    allocate a memory buffer. The hypervisor duly allocates the requested buffer.
    The kernel also requests that a number of references be made in the hash table
    (HTAB) page index, so there are a number of references to this same block of memory.
    You can see an abstract view of the memory at this point in [Figure 13-1](#figure13-1),
    step 1.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个攻击，我们首先需要了解一些关于Linux内核如何访问内存的细节。为此，Linux内核请求虚拟机监控器分配一个内存缓冲区。虚拟机监控器按要求分配了该缓冲区。内核还请求在哈希表（HTAB）页索引中创建多个引用，因此该内存块有多个引用。你可以在[图13-1](#figure13-1)的步骤1中看到此时内存的抽象视图。
- en: '![f13001](image_fi/278748c13/f13001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f13001](image_fi/278748c13/f13001.png)'
- en: 'Figure 13-1: The five steps of PS3 pwnage'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：PS3攻陷的五个步骤
- en: '[Figure 13-1](#figure13-1) shows an abstract view of the memory contents throughout
    the attack. HTABs are “handles” that give the kernel access to a particular memory
    range, as indicated by the arrows. Gray cells are accessible only to the hypervisor,
    whereas white cells are accessible to the kernel.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](#figure13-1)展示了攻击过程中内存内容的抽象视图。HTAB是“句柄”，它让内核访问特定的内存范围，如箭头所示。灰色单元格仅对虚拟机监控器可见，而白色单元格对内核可见。'
- en: Back to the attack. Everything until now is nice and safe. The kernel has read/write
    access to a block of memory, but the hypervisor is well aware of this memory and
    ensures that no out-of-bound reads or writes occur. The attack comes when we request
    that the hypervisor deallocate the memory by closing all those references made
    through the HTAB in step 1 of [Figure 13-1](#figure13-1). At this point in time,
    we insert a glitch onto the PS3 memory bus with the goal of failing one of the
    deallocations. We’ll explain in a second why this is important, but for now note
    that the attack works because the deallocation is never “verified.” If the pointer
    to what we were supposed to deallocate on the hardware is corrupted, the hypervisor
    won’t know about this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回到攻击部分。到目前为止，一切都很好且安全。内核对一块内存具有读写权限，但虚拟机监控器（hypervisor）非常清楚这块内存，并确保不会发生越界读写。当我们请求虚拟机监控器通过关闭在[图13-1](#figure13-1)步骤1中通过HTAB所做的所有引用来释放内存时，攻击便开始了。在此时，我们在PS3内存总线上插入一个故障，目的是使某个释放操作失败。稍后我们会解释为什么这很重要，但现在请注意，攻击之所以有效，是因为释放操作从未被“验证”。如果指向我们应该释放的硬件内存的指针被破坏，虚拟机监控器将无法察觉这一点。
- en: The physical fault comes from a logic-level signal inserted onto the memory
    data bus (that is, DQx pins). The original demo used a field-programmable gate
    array (FPGA) board to generate a short (~40ns) pulse, but later people re-creating
    this also demonstrated it with microcontrollers to generate similar pulses (in
    the 40 to 300ns range). As many deallocations are forced, the fault can simply
    be manually triggered. Specific timing isn’t needed since only one of the deallocations
    needs to fail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 物理故障来自于一个插入到内存数据总线上的逻辑级信号（即DQx引脚）。最初的演示使用了一个现场可编程门阵列（FPGA）板来生成一个短脉冲（约40ns），但后来复现此攻击的人也使用微控制器生成类似的脉冲（在40到300ns的范围内）。由于许多释放操作被强制执行，故障可以通过手动触发。具体的时序并不需要，因为只要有一个释放操作失败就足够。
- en: 'This brings us to step 2 in [Figure 13-1](#figure13-1): the kernel has access
    to a piece of memory that was not actually invalidated in the HTAB. The hypervisor
    isn’t aware of this, as it thinks it safely deallocated the memory and removed
    all references to it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们进入[图13-1](#figure13-1)的第二步：内核可以访问一块内存，而这块内存实际上在HTAB中并没有被作废。虚拟机监控器对此并不知情，因为它认为它已经安全地释放了内存并移除了所有引用。
- en: The final stage of the attack is to generate a new virtual memory space that
    overlaps with this chunk of memory the kernel can read/write to. This virtual
    memory space will also include an HTAB for the page map within this virtual space,
    but if we are lucky, that HTAB will be in a chunk of memory we can read/write
    from, as shown in step 3 in [Figure 13-1](#figure13-1). If we can write to the
    HTAB, this means we can map memory pages into our space, which normally only the
    hypervisor should be able to do. This would bypass most protections since the
    memory pages appear to be passing through the valid HTAB, and the kernel itself
    is reading/writing a memory address that it is allowed to access.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击的最后阶段是生成一个新的虚拟内存空间，该空间与内核可以读写的内存块重叠。这个虚拟内存空间还将包括该虚拟空间内的页面映射的HTAB，但如果我们幸运的话，该HTAB将位于我们可以读写的内存块中，如[图13-1](#figure13-1)中步骤3所示。如果我们可以写入HTAB，这意味着我们可以将内存页映射到我们的空间中，这通常只有超监视器能够执行。这样可以绕过大多数保护机制，因为内存页看起来是通过有效的HTAB传递的，而且内核本身正在读写它允许访问的内存地址。
- en: The final step in achieving full read/write access is to remap the original
    HTAB so we can read/write to this table directly, as shown in step 4 in [Figure
    13-1](#figure13-1). By switching back to the original memory space (not the virtual
    memory space created for the attack), we can now write to the main HTAB to remap
    arbitrary memory pages into our buffer. Since we have read/write access to this
    buffer, we can get read/write access to any memory locations, including the hypervisor
    code itself, as shown in step 5 in [Figure 13-1](#figure13-1).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实现完全读写访问的最后一步是重新映射原始HTAB，以便我们可以直接对这个表进行读写，如[图13-1](#figure13-1)中步骤4所示。通过切换回原始内存空间（而不是为攻击创建的虚拟内存空间），我们现在可以写入主HTAB，从而将任意内存页映射到我们的缓冲区中。由于我们对这个缓冲区拥有读写访问权限，我们可以获得对任何内存位置的读写访问权限，包括超监视器代码本身，如[图13-1](#figure13-1)中步骤5所示。
- en: The vulnerability can occur because the hypervisor became decoupled from the
    HTAB status, so it isn’t aware the kernel still has read/write access to the newly
    created virtual memory space. It’s also helped by the hypervisor allowing the
    kernel to discover the actual memory address of that initial buffer by standard
    API calls (which helps when creating the virtual memory space in getting the HTAB
    overlap).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞的产生是因为超监视器与HTAB状态脱耦，因此它无法意识到内核仍然拥有对新创建的虚拟内存空间的读写访问权限。这个漏洞也受到超监视器允许内核通过标准API调用发现该初始缓冲区的实际内存地址的帮助（这在创建虚拟内存空间时有助于获取HTAB重叠）。
- en: If you’re interested in more details, you may be able to find a mirror of the
    original code posted by Hotz. Due to a lawsuit, Hotz stopped any further work
    on Sony products. You may also find useful a series of blog posts by xorloser
    that include both the original details and some updated versions of the attack
    tools (called XorHack). These blog posts provide complete examples of the attack
    if you want the gory details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对更多细节感兴趣，你可以找到Hotz发布的原始代码镜像。由于诉讼，Hotz停止了对Sony产品的进一步工作。你还可以找到xorloser发布的一系列博客文章，其中包括原始细节和一些更新版本的攻击工具（称为XorHack）。这些博客文章提供了完整的攻击示例，如果你想了解详细的技术内容，可以参考。
- en: The takeaway is that with fault attacks, one can use a variety of methods to
    apply the fault. The attack may not be limited to the voltage, clock, electromagnetic
    (EM), and optical fault injection methods, for example. In this case, the memory
    bus itself is faulted, which may be a more exposed target than attempting to insert
    a fault onto the power supply of a complex device. The fault injection device
    can be a simple microcontroller, and it even works with an Arduino used to pulse
    the appropriate memory bus pin.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，在故障攻击中，可以使用多种方法来施加故障。例如，攻击不局限于电压、时钟、电磁（EM）和光学故障注入方法。在这种情况下，内存总线本身出现故障，这可能比尝试在复杂设备的电源上注入故障更容易成为目标。故障注入设备可以是一个简单的微控制器，甚至可以使用Arduino来脉冲相应的内存总线引脚。
- en: The other takeaway is that clever target preparation makes life much easier.
    Although the attack would work with careful timing to fault a single HTAB entry,
    it’s much easier to force a massive number of entries to be modified at once.
    Doing so allows rather loose timing on the fault injection, as the attack is designed
    such that only a small number of successes would be needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个结论是巧妙的目标准备使得攻击更加轻松。尽管攻击可以通过精确的时序来故障单个HTAB条目，但同时修改大量条目要容易得多。这样做可以在故障注入时使用较为宽松的时序，因为该攻击设计成只需少量的成功即可完成。
- en: Xbox 360
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Xbox 360
- en: The Xbox 360 is another game console that has been successfully attacked with
    fault injection. This work is primarily credited to GliGli and Tiros, with previous
    reverse engineering work done by various users (see [https://github.com/Free60Project](https://github.com/Free60Project)
    for full credits for the Reset Glitch Hack, and see the detailed hardware on [https://github.com/gligli/tools/tree/master/reset_glitch_hack](https://github.com/gligli/tools/tree/master/reset_glitch_hack)).
    [Figure 13-2](#figure13-2) shows a high-level overview of the attack steps.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Xbox 360 是另一个成功被故障注入攻击的游戏主机。这项工作主要归功于 GliGli 和 Tiros，之前的逆向工程工作由不同的用户完成（有关 Reset
    Glitch Hack 的完整致谢请参见 [https://github.com/Free60Project](https://github.com/Free60Project)，有关详细硬件信息请参见
    [https://github.com/gligli/tools/tree/master/reset_glitch_hack](https://github.com/gligli/tools/tree/master/reset_glitch_hack)）。[图
    13-2](#figure13-2) 显示了攻击步骤的高层次概览。
- en: The Xbox 360 has a ROM-based first-stage bootloader (1BL) that loads the second-stage
    bootloader (2BL, also referred to as CB on the Xbox) stored in NAND flash. The
    1BL verifies the RSA signature of the 2BL before loading it. Finally, 2BL loads
    a block called CD that includes the hypervisor and kernel—basically meaning we
    would ideally prefer to load our own CD block, as then we don’t even need to exploit
    the hypervisor since we’d simply be running our own code entirely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Xbox 360 有一个基于 ROM 的第一阶段引导加载程序（1BL），它加载存储在 NAND 闪存中的第二阶段引导加载程序（2BL，也称为 Xbox
    上的 CB）。1BL 在加载 2BL 之前验证 2BL 的 RSA 签名。最后，2BL 加载一个名为 CD 的块，其中包含虚拟机监控器和内核——基本上意味着我们最好加载我们自己的
    CD 块，这样我们就不需要利用虚拟机监控器，因为我们将完全运行我们自己的代码。
- en: The 2BL block will verify the expected SHA-1 hash for the CD block before running
    this code. Because the 2BL block was checked with an RSA signature, we can’t modify
    the SHA-1 hash that the 2BL block expects for the CD block without being detected.
    If we had an SHA-1 hash collision, we could load our own (unexpected) code, but
    there is a much easier way forward.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 2BL 块将在运行此代码之前验证 CD 块的预期 SHA-1 哈希。由于 2BL 块已通过 RSA 签名进行检查，我们无法在不被检测到的情况下修改 2BL
    块期望的 CD 块 SHA-1 哈希。如果我们有一个 SHA-1 哈希碰撞，我们可以加载我们自己的（意外的）代码，但有一种更简单的方法可以继续。
- en: The SHA-1 will be calculated on the CD code and then compared with something
    like `memcmp()`. We know such operations are susceptible to fault attacks, so
    we could look to insert a glitch at this point in time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1 将会在 CD 代码上计算，并与类似 `memcmp()` 的方法进行比较。我们知道这类操作容易受到故障攻击，因此我们可以考虑在此时插入一个故障。
- en: To simplify the timing, some hardware features of the Xbox 360 are used. In
    particular, the main central processing unit (CPU) has an exposed pin that can
    be used to bypass the phase-locked loop (PLL). The result is the CPU runs at a
    much slower 520 kHz. This pin has been labeled CPU_PLL_BYPASS in the examples,
    but keep in mind, these pin names are not based on public documentation such as
    a datasheet. It’s possible this pin is actually something like a feedback loop
    for the PLL, but grounding it has the same effect as if it were a bypass enabled
    for the PLL.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化时序，使用了 Xbox 360 的一些硬件特性。特别是，主中央处理单元（CPU）有一个暴露的引脚，可以用来绕过相位锁定环（PLL）。结果是，CPU
    以更慢的速度运行，只有 520 kHz。这个引脚在示例中被标记为 CPU_PLL_BYPASS，但请记住，这些引脚名称并非基于公开文档，如数据手册。这个引脚实际上可能是
    PLL 的反馈回路，但将其接地的效果与启用 PLL 绕过是一样的。
- en: '![f13002](image_fi/278748c13/f13002.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![f13002](image_fi/278748c13/f13002.png)'
- en: 'Figure 13-2: Sequence of a successful fault attack on the Xbox 360 “fat” version'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2：成功故障攻击 Xbox 360 "fat" 版本的序列
- en: With the CPU now running at a slower speed, it is easier to fine-tune the fault
    injection timing. In this case, the fault injection method is a short spike on
    the reset line of the CPU. Rather than reset the system, this fault causes the
    SHA-1 comparison to report a successful comparison, even if the SHA-1 hash doesn’t
    match.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CPU 以更慢的速度运行，更容易微调故障注入时序。在这种情况下，故障注入方法是在 CPU 的重置线上的短暂冲击。这个故障不会重置系统，而是导致 SHA-1
    比较报告成功的比较，即使 SHA-1 哈希不匹配。
- en: If the reset line fault isn’t successful, one might expect other avenues, such
    as voltage or electromagnetic fault injection, might be successful. But like the
    PlayStation attacks, the goal is to develop very simple tools such that the attack
    is easy to replicate. Sending simple logic-level signals onto the reset pin is
    something one can do with a complex programmable logic device (CPLD), a field-programmable
    gate array (FPGA), or a microcontroller.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重置线故障无法成功，可能需要尝试其他途径，例如电压或电磁故障注入，可能会成功。但像PlayStation攻击一样，目标是开发非常简单的工具，使得攻击易于复制。将简单的逻辑电平信号发送到重置引脚是可以通过复杂的可编程逻辑设备（CPLD）、现场可编程门阵列（FPGA）或微控制器来完成的。
- en: And the modchips are doing exactly that. These chips “weaponize” the fault vulnerability.
    They use details of the power-on self-test (POST) system that reports the boot
    progress. By tying into the POST reporting, it’s possible to know almost exactly
    when to trigger the slow clock operation and then inject the reset glitch. Like
    any fault attack, the reset glitch will not have a perfect success rate. If the
    glitch is unsuccessful, the modchip detects it, resets the system properly, and
    simply tries again. This process allows loading of an unsecured binary in 30–60
    seconds in most cases.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 而这些改装芯片正是这样做的。这些芯片将故障漏洞“武器化”。它们利用电源自检（POST）系统的细节，该系统报告启动进度。通过接入POST报告，几乎可以准确知道何时触发慢时钟操作，然后注入重置故障。像所有故障攻击一样，重置故障不会有完美的成功率。如果故障不成功，改装芯片会检测到并正确重置系统，然后重新尝试。这个过程通常可以在30到60秒内加载不安全的二进制文件。
- en: Again, clever preparation has turned a relatively complex target into one that
    can be attacked with basic electronics. In this case, rather than forcing a number
    of vulnerable operations to occur, the target is slowed down considerably. Later
    revisions of the hardware did not have the same test point but instead exposed
    the clock generator on the I2C bus. By tying into the I2C bus, an attacker could
    slow down the main CPU with similar results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，巧妙的准备将一个相对复杂的目标转变为可以用基础电子设备攻击的目标。在这种情况下，目标被大大减速，而不是强迫发生大量易受攻击的操作。硬件的后续版本没有相同的测试点，而是暴露了I2C总线上的时钟发生器。通过接入I2C总线，攻击者可以以类似的效果减慢主CPU的速度。
- en: Having external control over the clock frequency may be possible, even for complex
    targets. For example, a target may use a PLL to multiply up a crystal frequency;
    replacing a 12 MHz crystal with a 1 MHz oscillator might make the main CPU run
    at 66.7 MHz instead of the targeted 800 MHz. Whether this is successful is far
    from a sure thing, however. The PLLs and oscillators themselves have limits (they
    may not operate that slowly), external parts such as DRAM will have upper and
    lower frequency limits (DRAM chips have minimum and maximum refresh times), and
    the CPU may detect frequency deviation and shut itself down to prevent attacks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对时钟频率进行外部控制可能是可行的，即使对于复杂的目标也是如此。例如，一个目标可能使用相位锁定环（PLL）来倍频一个晶体频率；将12 MHz的晶体替换为1
    MHz的振荡器可能使主CPU以66.7 MHz的频率运行，而不是目标的800 MHz。然而，这是否成功远远不确定。PLL和振荡器本身有其限制（可能无法以如此慢的速度工作），外部部件如DRAM也有上下频率限制（DRAM芯片有最小和最大刷新时间），而CPU可能会检测到频率偏差并自动关机以防止攻击。
- en: 'The Xbox 360 reset glitch shows that time spent “exploring” a target may be
    useful in finding vulnerabilities that are exploitable at scale. In this case,
    reaching a reliable fault attack combines several observations that alone might
    not have been an obvious attack vector: the boot stages are known to an observer
    in real time; a pin on the CPU allows running at a much slower speed, and short
    glitches on the reset pin (at least when running very slowly) do not correctly
    reset the chip, but instead insert faults.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Xbox 360重置故障表明，花时间“探索”目标可能有助于发现可以大规模利用的漏洞。在这种情况下，达成可靠的故障攻击结合了几个单独的观察，这些观察本身可能并不是一个显而易见的攻击途径：启动阶段对观察者是实时已知的；CPU上的一个引脚可以以更慢的速度运行，并且在重置引脚上的短暂故障（至少在运行非常慢时）不会正确重置芯片，而是插入故障。
- en: Power Analysis Attacks
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电源分析攻击
- en: The fault injection attacks demonstrated in the previous section were used to
    achieve temporary privileges beyond what the security architecture was supposed
    to permit (allowing loading of unsigned firmware, for example). Although fault
    injection can be about information disclosure through a memory dump or key disclosure
    through differential fault analysis, it is often about gaining privileges to then
    continue the attack. By comparison, power analysis is almost entirely concerned
    with revealing sensitive information, such as encryption keys. The difference
    is that a successful power analysis attack may provide you with the “keys to the
    kingdom.” These keys can make it impossible to discern an attacker from a legitimate
    owner or operator, and they may allow scaling without the further need of a hardware
    attack.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中展示的故障注入攻击被用来获取超出安全架构原本许可的临时权限（例如，允许加载未签名的固件）。虽然故障注入可以通过内存转储或通过差分故障分析泄露密钥，但它通常是为了获得权限，从而继续攻击。相比之下，功率分析几乎完全关注于揭示敏感信息，例如加密密钥。区别在于，成功的功率分析攻击可能为你提供“王国的钥匙”。这些密钥可能使得难以区分攻击者和合法的所有者或操作员，并且它们可能允许在没有进一步硬件攻击的情况下进行规模扩展。
- en: Philips Hue Attack
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 飞利浦 Hue 攻击
- en: 'The Philips Hue bulbs are smart lights that allow various settings to be controlled
    remotely by the owner. These lights communicate with the Zigbee Light Link (ZLL),
    which runs over a very constrained wireless network protocol (IEEE 802.15.4).
    Here we present part of “IoT Goes Nuclear: Creating a ZigBee Chain Reaction,”
    by Eyal Ronen et al. This work details recovering Philips Hue firmware encryption
    keys. After finding a bug, the authors also managed to bypass the “proximity test,”
    which these lightbulbs normally use to protect them from being disassociated from
    their network by an attacker more than about 1 meter away. This bug and proximity
    test bypass allow an attacker to create a worm that disassociates a victim bulb
    from the network within full Zigbee range (30–400 meters, depending on conditions)
    and remotely installs the wormed firmware, after which the now-infected bulb starts
    attacking other bulbs. Power analysis is used to compromise the (global) firmware
    encryption and signing key.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 飞利浦 Hue 灯泡是智能灯具，允许所有者远程控制各种设置。这些灯具通过 Zigbee Light Link (ZLL) 进行通信，该协议运行在一个非常受限的无线网络协议（IEEE
    802.15.4）上。这里我们展示了“物联网走向核爆：创建 ZigBee 链式反应”（Eyal Ronen 等人）的部分内容。该研究详细说明了如何恢复飞利浦
    Hue 固件的加密密钥。在发现一个漏洞后，作者还成功绕过了这些灯泡通常用来防止它们被距离超过 1 米的攻击者从网络中断开的“接近性测试”。这个漏洞和接近性测试绕过使得攻击者能够创建一个蠕虫程序，在完整的
    Zigbee 范围内（30-400 米，取决于条件）使受害者灯泡从网络中断开，并远程安装蠕虫固件，之后已感染的灯泡开始攻击其他灯泡。通过功率分析，攻击者能够破坏（全球）固件的加密和签名密钥。
- en: The Zigbee Light Link
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Zigbee Light Link
- en: ZLL is a specific version of Zigbee (not the same as regular Zigbee or Zigbee
    Home Automation) that, like Zigbee, uses a low-power wireless protocol called
    IEEE 802.15.4\. ZLL has a simple method of letting a new device, such as a bulb
    you just purchased, join the network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ZLL 是 Zigbee 的一个特定版本（与常规 Zigbee 或 Zigbee 家庭自动化不同），它像 Zigbee 一样，使用一种称为 IEEE 802.15.4
    的低功耗无线协议。ZLL 有一个简单的方法，允许新设备（比如你刚购买的灯泡）加入网络。
- en: This joining process relies on a fixed master key to transfer the unique network
    key to the new bulb, and the device will be connected to a network with the unique
    key. The shared master key is no longer in use in the network once the unique
    key is transferred, as the master key was always at risk of being leaked. The
    network owner would have to put the network in a mode that allows new devices
    to join, so new devices cannot be added without the owner’s knowledge. This explanation,
    however, doesn’t describe how we solve the problem of replacing a bridge that
    has died, or if a user needs to move a bulb from one network to another.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加入过程依赖于一个固定的主密钥，将唯一的网络密钥传递给新灯泡，设备将连接到一个具有唯一密钥的网络。一旦唯一密钥被传递，网络中不再使用共享的主密钥，因为主密钥始终有泄露的风险。网络所有者需要将网络置于允许新设备加入的模式，这样新设备无法在没有所有者知情的情况下被添加。然而，这个解释并没有描述我们如何解决替换已经故障的桥接器，或者用户需要将灯泡从一个网络移到另一个网络的问题。
- en: Bypassing Proximity Checking
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绕过接近性检查
- en: For scenarios where the unique network key needs to change, we come into the
    second portion, a special “Reset to Factory New” message, which allows someone
    to de-authenticate a bulb from an existing network such that it can now join a
    different network. To perform this step, you needed to be physically close (~1
    meter range). The ZLL master key (as you might expect) was leaked, meaning anyone
    could send those messages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要更改唯一网络密钥的场景，我们进入了第二部分，一个特殊的“恢复出厂设置”消息，它允许某人将灯泡从现有网络中去认证，以便它现在可以加入不同的网络。要执行这一步，你需要物理接近（大约1米范围）。ZLL主密钥（正如你可能预料的那样）被泄漏了，这意味着任何人都可以发送这些消息。
- en: The proximity check is normally done by rejecting messages less than a certain
    signal strength. Although it’s possible to use high-power radio transmitters to
    fake the radio distance and reset devices from a longer range, doing so isn’t
    “wormable,” as the Hue transmitter itself isn’t strong enough. A wormable solution
    presented itself via a firmware bug and some compatibility requirements. First,
    a crafted “Reset to Factory New” message is sent to the victim. It’s designed
    to exploit the firmware bug such that the proximity test is bypassed. After the
    factory reset, the victim actively starts searching for Zigbee networks. The details
    are in the paper; here we focus on the power analysis part of the attack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接近性检查通常通过拒绝信号强度低于某个值的消息来完成。尽管可以使用高功率无线电发射器伪造无线电距离并从更远的范围重置设备，但这样做并不是“蠕虫式”的，因为Hue的发射器本身的功率不足够强大。一个“蠕虫式”的解决方案通过固件漏洞和一些兼容性要求出现了。首先，发送一个精心设计的“恢复出厂设置”消息给受害者。这个消息的设计目的是利用固件漏洞，从而绕过接近性测试。工厂重置后，受害者会主动开始搜索Zigbee网络。详细内容在论文中，本文重点介绍攻击的功率分析部分。
- en: Firmware Updates on Hue
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hue上的固件更新
- en: Now we have reached the stage where a device could be forced to join a new,
    attacker-controlled network, at which point you could send a firmware update request.
    The real question is, what is the actual format of the firmware update file and
    how can we send one ourselves? At this stage, we reset your vision of the attack
    setup and return to a legitimate Philips Hue lamp.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了一个阶段，在这个阶段，一个设备可以被强制加入一个新的、由攻击者控制的网络，此时你可以发送固件更新请求。真正的问题是，固件更新文件的实际格式是什么，我们该如何自己发送一个固件更新文件？在这个阶段，我们将重置你对攻击设置的理解，并返回到一个合法的飞利浦Hue灯泡。
- en: The Philips Hue lamps have the ability to perform a firmware update. By standard
    reverse engineering techniques, along with just looking at sample implementations
    of Zigbee over-the-air (OTA) update mechanisms posted as part of reference designs,
    we can learn how it works. When a bulb needs a firmware update, it downloads the
    file from the bridge device (which previously downloaded it from a remote server)
    into an external SPI flash memory chip. The actual OTA download can take some
    time (often at least an hour), as only small amounts are sent in each packet.
    If the network is in a busy wireless environment or the bulb is at the edge of
    radio range, this time can be extended considerably.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 飞利浦Hue灯泡具备执行固件更新的能力。通过标准的逆向工程技术，以及仅仅查看作为参考设计一部分的Zigbee空中下载（OTA）更新机制的示例实现，我们可以了解其工作原理。当灯泡需要固件更新时，它从桥接设备（之前从远程服务器下载的）下载文件到外部SPI闪存芯片中。实际的OTA下载可能需要一些时间（通常至少需要一个小时），因为每个数据包中发送的只是小量数据。如果网络处于繁忙的无线环境中，或者灯泡处于无线电范围的边缘，这段时间可能会大大延长。
- en: Rather than attempt to sniff an update from this slow OTA interface directly,
    we can look at what’s happening to the SPI chip, which provides us with an “update-ready”
    SPI flash image. If we want to trigger an update on a given bulb, we can just
    write this SPI image to the SPI flash chip, and the bulb will perform the actual
    reprogramming of itself. This programming is initiated by a byte in the SPI flash
    image that indicates the bulb is ready for an update. On boot, the bulb checks
    the value of this byte and triggers the programming, if indicated. This programming
    mechanism also means that if you interrupted the reprogramming phase by turning
    the bulb power off, on the next boot, the bulb would automatically restart the
    reprogramming step.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不直接尝试从这个慢速OTA接口嗅探更新，而是查看SPI芯片的情况，这可以为我们提供一个“更新就绪”的SPI闪存镜像。如果我们想触发给定灯泡的更新，我们只需要将这个SPI镜像写入SPI闪存芯片，灯泡就会执行实际的自我重编程。这个编程过程由SPI闪存镜像中的一个字节触发，该字节指示灯泡准备好进行更新。启动时，灯泡会检查这个字节的值，并在必要时触发编程。这个编程机制也意味着，如果你在重编程阶段通过关闭灯泡电源来中断过程，下次启动时，灯泡会自动重新启动并继续重编程步骤。
- en: Getting Firmware Keys with Power Analysis
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过功率分析获取固件密钥
- en: AES-CCM is used for encrypting and authenticating the firmware file (the AES-CCM
    specification is available in IETF RFC 3610), so we cannot simply upload any forged
    image. We first need to extract the key. To do this, the SPI flash chip becomes
    our “input” to the encryption algorithm that we can break with power analysis.
    In this case, CCM makes things a little trickier than you might assume at first
    guess. We no longer have a direct input to each of the encryption modes, as AES-CCM
    uses AES-CTR mode along with AES-CBC. [Figure 13-3](#figure13-3) gives an incomplete
    overview of CCM, focused only on what we need for the attack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: AES-CCM 用于加密和验证固件文件（AES-CCM 的规范可以在 IETF RFC 3610 中找到），因此我们不能简单地上传任何伪造的映像。我们首先需要提取密钥。为此，SPI
    闪存芯片成为我们加密算法的“输入”，我们可以通过功率分析破解它。在这种情况下，CCM 使得事情比你最初猜测的要复杂一些。我们不再有每个加密模式的直接输入，因为
    AES-CCM 使用了 AES-CTR 模式与 AES-CBC 一起使用。[图 13-3](#figure13-3) 提供了一个不完整的 CCM 概述，只关注我们攻击所需要的部分。
- en: 'The top row of AES blocks are AES in CTR mode: an increasing counter is encrypted
    to obtain 128-bit chunks of stream cipher (*CTR*[*m*], 8). This is used to decrypt
    the ciphertext using a simple XOR operation (9). To create the authentication
    tag, the bottom row of AES blocks’ ciphertext is being XOR’d to the input of the
    next block (3, 5), which constitutes the cipher block chaining (*CBC*[*m*], 2,
    4). We left out some pieces of how the authentication tag is precisely calculated,
    but that’s irrelevant for the attack.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: AES 块的最上一行是 AES 在 CTR 模式下：一个递增的计数器被加密以获得128位的流密码块（*CTR*[*m*], 8）。这用于通过简单的 XOR
    操作解密密文（9）。为了创建身份验证标签，AES 块的最下一行密文被 XOR 到下一个块的输入（3, 5），这构成了密码块链接（*CBC*[*m*], 2,
    4）。我们省略了一些关于身份验证标签是如何精确计算的细节，但这些对攻击来说并不重要。
- en: '![f13003](image_fi/278748c13/f13003.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f13003](image_fi/278748c13/f13003.png)'
- en: 'Figure 13-3: All you need to know about AES-CCM for the attack'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3：攻击中需要了解的所有 AES-CCM 信息
- en: How do we attack CCM using power analysis? Going after AES-CTR is not an option,
    since we don’t know the input (7, because of the unknown IV), and we don’t know
    the output either, as that is the cipher stream, which is never accessible (8).
    On the AES-CBC, we also cannot perform a vanilla CPA; the input is the decrypted
    firmware (9, which we don’t know), and the output of the AES-CBC (2, 4) is never
    accessible. However, Ronen et al. describe how to perform a clever key transformation
    (like we did in Chapter 12) that allows obtaining the key from the AES-CBC (1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通过功率分析攻击 CCM？直接攻击 AES-CTR 不行，因为我们不知道输入（7，因为 IV 是未知的），也不知道输出，因为那是密码流，永远无法访问（8）。在
    AES-CBC 中，我们也无法执行普通的 CPA；输入是解密后的固件（9，我们不知道），AES-CBC 的输出（2, 4）也永远无法访问。不过，Ronen
    等人描述了如何进行巧妙的密钥变换（就像我们在第12章中做的那样），从而能够从 AES-CBC 中获得密钥（1）。
- en: Let’s start at the top, with the ciphertext *CT*. We split that into 128-bit
    blocks, *CT*[*m*], where *m* is the block index. AES-CTR decryption is a stream
    cipher, and we’ll write the stream (8) as *CTR*[*m*] = `AES`(*k*, *IV*[*ctr*]
    || *m*), where || is concatenation of bits, so we can write the *PT* (9) coming
    out of it as *PT*[*m*] = *CT*[*m*] ⊕ *CTR*[*m*].
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最上面开始，先看密文 *CT*。我们将其分割成128位的块，*CT*[*m*]，其中 *m* 是块的索引。AES-CTR 解密是一种流密码，我们将流（8）写作
    *CTR*[*m*] = `AES`(*k*, *IV*[*ctr*] || *m*)，其中 || 表示位的连接，所以我们可以将从中得到的 *PT*（9）写作
    *PT*[*m*] = *CT*[*m*] ⊕ *CTR*[*m*]。
- en: The *IV*[*ctr*] in CCM consists of a few fields, but basically the nonce is
    the big unknown to us at this point. For simplicity, we’ll just say we don’t know
    *IV*[*ctr*] (for now).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CCM 中的 *IV*[*ctr*] 由几个字段组成，但基本上此时对我们来说最大的未知数是 nonce。为了简化，我们暂时可以说我们不知道 *IV*[*ctr*]（暂时如此）。
- en: Next, AES-CBC is used to encrypt *PT*[*m*], generating the authentication tag.
    We can write output block *m* of CBC (2, 4) as *CBC*[*m*] = `AES`(*k*, *PT*[*m*]
    ⊕ *CBC*[*m–1*]), with block *m* = *0* defined using *CBC*[*-1*] = *IV*[*mac*].
    We can substitute *PT*[*m*]to get *CBC*[*m*] = `AES` (*k*, *CT*[*m*] ⊕ *CTR*[*m*]
    ⊕ *CBC*[*m–1*]).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，AES-CBC 用于加密 *PT*[*m*]，生成身份验证标签。我们可以将 CBC 的输出块 *m*（2, 4）写作 *CBC*[*m*] =
    `AES`(*k*, *PT*[*m*] ⊕ *CBC*[*m–1*])，其中块 *m* = *0* 使用 *CBC*[*-1*] = *IV*[*mac*]
    来定义。我们可以替换 *PT*[*m*] 来得到 *CBC*[*m*] = `AES` (*k*, *CT*[*m*] ⊕ *CTR*[*m*] ⊕ *CBC*[*m–1*])。
- en: So far so good, although everything in that formula is unknown except for the
    *CT*. In a regular AES-ECB power analysis attack, we assume we at least know the
    plaintext or the ciphertext, and thus we can recover *k*. The problem with any
    of the preceding AES functions is that we don’t know the input and we don’t know
    the output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，尽管公式中的所有内容都未知，除了*CT*。在常规的AES-ECB功率分析攻击中，我们假设至少知道明文或密文，从而可以恢复*k*。任何前述AES函数的问题在于，我们不知道输入，也不知道输出。
- en: The cleverness comes in at this point. In AES, `AddRoundKey`(*k, p*) is just
    *k* ⊕ *p*, meaning we can rewrite `AddRoundKey`(*k*, *p* ⊕ *d*) = `AddRoundKey`(*k*
    ⊕ *p*, *d*). This means if *p* is unknown and fixed, we can just consider it to
    be part of a transformed key *k* ⊕ *p*. If we control *d*, we can do a CPA attack
    to recover *k* ⊕ *p*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关键就在于此时。 在AES中，`AddRoundKey`(*k, p*) 就是 *k* ⊕ *p*，这意味着我们可以将 `AddRoundKey`(*k*,
    *p* ⊕ *d*) 重写为 `AddRoundKey`(*k* ⊕ *p*, *d*)。这意味着，如果*p*是未知且固定的，我们可以将其视为已转换密钥*k*
    ⊕ *p*的一部分。如果我们控制了*d*，我们可以进行CPA攻击来恢复*k* ⊕ *p*。
- en: In our CCM case, we can’t attack `AddRoundKey`(*k*, *CT*[*m*] ⊕ *CTR*[*m*] ⊕
    *CBC*[*m–1*]), but we can attack `AddRoundKey`(*k* ⊕ *CTR*[*m*] ⊕ *CBC*[*m–1*],
    *CT*[*m*]), because we control *CT*[*m*]! Assuming the target leaks, we can use
    *CPA*[*a*] (see [Figure 13-4](#figure13-4)) to find the transformed key *k* ⊕
    *CTR*[*m*] ⊕ *CBC*[*m-1*], which in itself isn’t useful. This transformed key
    allows us to calculate all intermediate data until the second `AddRoundKey`(*k*,
    *p′*). This second `AddRoundKey` again uses *k*, which we don’t know. However,
    since we know the transformed round key and *CT*, we can calculate *p′*. We can
    now apply a vanilla *CPA*[*b*] attack using *p′* to recover *k* from the second
    round of AES.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CCM情况下，我们无法攻击 `AddRoundKey`(*k*, *CT*[*m*] ⊕ *CTR*[*m*] ⊕ *CBC*[*m–1*])，但我们可以攻击
    `AddRoundKey`(*k* ⊕ *CTR*[*m*] ⊕ *CBC*[*m–1*], *CT*[*m*])，因为我们控制了*CT*[*m*]！假设目标发生泄漏，我们可以使用*CPA*[*a*]（见[图13-4](#figure13-4)）来找到已转换的密钥*k*
    ⊕ *CTR*[*m*] ⊕ *CBC*[*m-1*]，虽然这本身没有直接用处。这个已转换的密钥让我们能够计算所有中间数据，直到第二次`AddRoundKey`(*k*,
    *p′*)。第二次`AddRoundKey`仍然使用*k*，这是我们不知道的。然而，由于我们知道已转换的轮密钥和*CT*，我们可以计算出*p′*。我们现在可以使用一个普通的*CPA*[*b*]攻击，利用*p′*来恢复从AES第二轮的*k*。
- en: '![f13004](image_fi/278748c13/f13004.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![f13004](image_fi/278748c13/f13004.png)'
- en: 'Figure 13-4: Two CPA attacks: one on the transformed key and one on the regular
    key'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-4：两种CPA攻击：一种针对转换密钥，另一种针对常规密钥
- en: Once we have *k* (1 in [Figure 13-3](#figure13-3)), we have a few more steps
    to go. Note that we still don’t have *PT* or any of the IVs. However, *k* allows
    us to finish the “modified” AES calculation of [Figure 13-4](#figure13-4) to obtain
    the *CBC*[*m*] blocks 2. This block we can now decrypt to get *CT*[*m*] ⊕ *CTR*[*m*]
    ⊕ *CBC*[*m–1*] 3, and because we know *CT*[*m*], we know *CTR*[*m*] ⊕ *CBC*[*m–1*].
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了*k*（在[图13-3](#figure13-3)中是1），我们还有几个步骤要走。请注意，我们仍然没有*PT*或任何IV。然而，*k*允许我们完成[图13-4](#figure13-4)中的“修改”AES计算，从而得到*CBC*[*m*]块2。现在我们可以解密此块，得到*CT*[*m*]
    ⊕ *CTR*[*m*] ⊕ *CBC*[*m-1*] 3，并且由于我们知道*CT*[*m*]，我们就知道*CTR*[*m*] ⊕ *CBC*[*m-1*]。
- en: For the final blow, we can use the same attack on the subsequent block *m+1*.
    This allows us to find *CBC*[*m+1*] 4 and *CT*[*m+1*] ⊕ *CTR*[*m+1*]⊕ *CBC*[*m*]
    5. Since we already knew *CT*[*m+1*] and *CBC*[*m*] from the previous attack,
    we can XOR it out and calculate *CTR*[*m+1*] 6, which is equal to `AES`(*k*, *IV*[*ctr*]
    || *m+1*). Since we know *k*, we can decrypt this to find *IV*[*ctr*] 7, and we
    subsequently can calculate *CTR*[*m*] for any *m* 8, which finally allows us to
    decrypt *PT*[*m*] = *CTR*[*m*] ⊕ *CT*[*m*] 9!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，我们可以对后续块*m+1*使用相同的攻击。这让我们能够找到*CBC*[*m+1*] 4和*CT*[*m+1*] ⊕ *CTR*[*m+1*]⊕
    *CBC*[*m*] 5。由于我们已经从之前的攻击中知道了*CT*[*m+1*]和*CBC*[*m*]，我们可以通过XOR操作计算出*CTR*[*m+1*]
    6，这等于`AES`(*k*, *IV*[*ctr*] || *m+1*)。因为我们知道*k*，我们可以解密这个结果来找出*IV*[*ctr*] 7，随后我们可以计算出任何*m*的*CTR*[*m*]
    8，最终使我们能够解密*PT*[*m*] = *CTR*[*m*] ⊕ *CT*[*m*] 9！
- en: We now have the firmware key and plaintext; therefore, we have easy access to
    forge firmware. Using the attack that allows us to disassociate a Hue from its
    network and upload new firmware, we could create a worm that propagates throughout
    a city. In the paper, the authors calculate that for a city like Paris, about
    15,000 Hue lights need to be present for the worm to take over all of the Hue
    lights in the city.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了固件密钥和明文，因此我们可以轻松地伪造固件。通过利用一种可以让我们将Hue从其网络中断开并上传新固件的攻击，我们可以创建一个在城市中传播的蠕虫。文章中，作者计算出，对于像巴黎这样的城市，大约需要15,000个Hue灯才能使蠕虫控制城市中的所有Hue灯。
- en: This attack combines a scalable/real-life attack, hardware reverse engineering,
    wireless communication, protocol abuse, exploiting a firmware bug, *and* a power
    analysis attack on CCM. Add whipped cream, and it would be the perfect dessert.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该攻击结合了可扩展/现实攻击、硬件逆向工程、无线通信、协议滥用、利用固件漏洞、*以及*对 CCM 的功耗分析攻击。再加上鲜奶油，它就成了完美的甜点。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we described how the PlayStation 3, Xbox 360, and Philips Hue
    lights were broken using hardware attacks. Especially in systems that have a small
    density of software flaws, hardware attacks can be a critical step leading to
    compromise.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了如何通过硬件攻击破解 PlayStation 3、Xbox 360 和 Philips Hue 灯具。尤其是在那些软件漏洞较少的系统中，硬件攻击可能是导致系统被攻破的关键步骤。
