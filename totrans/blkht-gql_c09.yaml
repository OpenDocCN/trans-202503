- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Request Forgery and Hijacking
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: When attackers execute hijacking and forgery-based attacks against servers and
    clients, they can take sensitive actions with potentially devastating outcomes.
    In this chapter, we’ll test for these vulnerabilities and learn about defenses
    an application might implement to mitigate these types of flaws.
  prefs: []
  type: TYPE_NORMAL
- en: '*Request forgery* occurs when an attacker is able to carry out an action, ideally
    a sensitive one, on behalf of a client or server. When attackers target clients,
    they may, for example, try to force the client to transfer money to a digital
    wallet or bank account that they control. When attackers target servers, they
    may instead aim to obtain sensitive server-side data, probe for hidden or internal
    services, make internal requests to restricted networks, access cloud environment–related
    information, and more. By contrast, *hijacking* refers to the ability to steal
    another user’s session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of GraphQL, each of these attack vectors poses a threat. We’ll
    discuss three forms that these attacks can take: cross-site request forgery (CSRF),
    server-side request forgery (SSRF), and cross-site WebSocket hijacking (CSWSH).'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often pronounced *sea-surf*, *CSRF* is a client-side attack that causes victims
    to execute unwanted actions on a website to which they are authenticated. In such
    an attack, the attacker writes code and embeds it in a website that they operate
    (or, sometimes, in a third-party site that allows them to do so). They then force
    the victim to visit that site by leveraging attacks such as social engineering.
    When the code executes in the victim’s browser, it forges and sends a request
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, these requests perform state-changing actions. They might
    update the email or password of an account, transfer money from one account to
    another, disable account security settings such as multifactor authentication,
    grant permissions, or even add a new account to an application. [Figure 9-1](#figure9-1)
    illustrates the typical CSRF attack flow, using a banking website as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: The flow of a CSRF attack'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF takes advantage of the fact that, when a client is logged in to an application,
    the browser sends necessary information in every HTTP request it makes to the
    site, such as session cookies (in the `Cookie` header), and other standard headers
    like `Host` or `User-Agent`. Web servers have no way to distinguish between legitimate
    requests and those that result from a user being tricked, which is why CSRF attacks
    work well when no mitigations are in place to prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers use many techniques to achieve CSRF, but one common tactic relies
    on specially crafted HTML forms, created using `<form>` tags. The attacker waits
    for a user to submit a form on their website or, to increase their chances of
    success, does so automatically using JavaScript code. When a condition allows
    an attacker to perform a CSRF attack using the GET method, they might also use
    HTML tags such as `<a>` and `<img>` as vectors. These tags, which aren’t usually
    considered harmful, could provide an attacker with the option to embed CSRF payloads
    in websites that allow the insertion of image links and hyperlinks. These tags
    can make only plain GET requests, so if a website has anti-CSRF tokens in place,
    the attack probably won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Because a CSRF attack relies on the victim’s authenticated session, the attacker
    can take only those actions that the victim is allowed to perform on the website.
    For example, if a victim is logged in to a banking website but can transfer only
    $1,000 a day, a CSRF attack would be limited to transferring that dollar amount.
    Additionally, if a particular request requires administrator-level privileges
    that the client session doesn’t have, the request will fail. Chapter 7 provides
    techniques for bypassing certain GraphQL authorization controls.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF is at least two decades old. The first CSRF-related vulnerability with
    an assigned CVE identifier we could find, CVE-2002-1648, is from 2002, although
    some people suggest that CSRF vulnerabilities may go back as far as 2001\. When
    it comes to GraphQL, developers may use either queries or mutations to build schemas
    that support performing sensitive actions (such as changing account settings or
    transferring money from one account to another). This may allow an attacker to
    perform state-changing actions. As you’ve learned, state-changing actions are
    usually done with mutations. However, developers may choose to implement these
    using queries.
  prefs: []
  type: TYPE_NORMAL
- en: Locating State-Changing Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *state-changing action* alters the application in some way. For example, changing
    DVGA’s mode from Beginner to Expert, or vice versa, is considered a state-changing
    operation. If you’re hunting for CSRF, you should target these actions. As you
    know by now, state-changing actions in GraphQL are typically performed using mutations.
    However, you can sometimes perform write operations that are state changing by
    using GraphQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with the more likely scenario: identifying state-changing operations
    based on mutations. To find impactful CSRF vulnerabilities, try extracting the
    list of available mutations and searching for ones that give you a foothold in
    the application or allow you to escalate your existing privileges. The introspection
    query shown in [Listing 9-1](#listing9-1) should return the mutation fields that
    exist in a schema.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-1: Introspection query to extract mutation field names'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run this query against DVGA by using Altair, ensuring that DVGA’s
    mode is set to Beginner. You should identify a few state-changing actions, such
    as `createUser`, `importPaste`, `editPaste`, `uploadPaste`, `deletePaste`, and
    `createPaste`.
  prefs: []
  type: TYPE_NORMAL
- en: In cases when you don’t notice any sensitive actions, the next thing to look
    for is whether you can use queries to perform state-changing actions. GraphQL
    servers sometimes support operations over GET, and when they do, they might intentionally
    reject GET-based mutations to allow read operations using GET only. This provides
    a degree of protection against CSRF-like vulnerabilities, as you’ll learn later
    in this chapter. However, if our target uses any GET-based queries to perform
    important state changes, that mitigation is useless. Execute the introspection
    query shown in [Listing 9-2](#listing9-2) to fetch the names of the available
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-2: Introspection query to extract query field names'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an excerpt of the returned list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Does any query name stand out? The list has a few potential state-changing queries,
    but `deleteAllPastes` is particularly interesting. A query that deletes all pastes
    would fit better as a mutation than a query. However, because this application
    is vulnerable, it doesn’t take CSRF issues into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for POST-Based Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve identified a few state-changing queries and mutations, we can
    attempt to craft an HTML form that exploits them. Our attack might trick a user
    into clicking a link that redirects them to a malicious website containing a form
    like the one in [Listing 9-3](#listing9-3). When submitted, it will make a POST
    request to DVGA by using the `createPaste` mutation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-3: HTML-form POST-based CSRF exploit'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `method` attribute to define a POST-based form named `query`. This
    form will perform the request to the DVGA’s URL, defined in the `action` attribute.
    You’ll notice that we also define a hidden `<input>` tag by setting the `type`
    attribute to `hidden`. This ensures that the form used to execute the query will
    remain invisible to the victim; it won’t display in their browser. We encode and
    define the GraphQL mutation in the `value` attribute. The decoded version of the
    mutation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To observe how this form would work in an attack, download the CSRF proof-of-concept
    code from the book’s GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html).
    Save this file to Kali’s desktop with the extension *.html*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s use Burp Suite to view the outbound requests sent in a CSRF attack.
    Launch Burp Suite and open its built-in browser by clicking **Open Browser**.
    Make sure it’s currently set to not intercept requests. Then, drag and drop the
    HTML file from your desktop into the browser window. You should see the Submit
    button shown in [Figure 9-2](#figure9-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: A POST-based CSRF example'
  prefs: []
  type: TYPE_NORMAL
- en: In Burp, toggle the Intercept button to **Intercept Is On**. Now, click **Submit**
    in the form and observe the resulting request in Burp’s Proxy tab. It should look
    similar to [Figure 9-3](#figure9-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: The POST request sent from a victim’s browser after a CSRF attack'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the mutation is encoded and sent as a single value to the `query`
    body parameter. This happens because POST-based HTML forms transform `<input>`
    tags into HTTP body parameters, and we used an input tag named `query`.
  prefs: []
  type: TYPE_NORMAL
- en: Because HTML forms can’t send JSON-formatted data without some help from a language
    like JavaScript, the submitted mutation isn’t sent as JSON, as indicated by the
    `Content-Type` header. Here, it is set to `application/x-www-form-urlencoded`
    rather than `application/json`. Even so, some GraphQL servers may convert the
    payload back to JSON in the backend, despite lacking the proper `Content-Type`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an HTML form employs the POST method, we can use one of the following
    three encoding types to encode the data: `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain`. By default, when the `enctype` attribute
    isn’t set, such as in our exploit code, the form uses `application/x-www-form-urlencoded`,
    which encodes all characters before sending them to the server. Now that you’ve
    seen how the CSRF exploit triggered a GraphQL query, click **Forward** to send
    it to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Submitting a CSRF Form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enticing a user to click a button could introduce challenges. If the user hesitates
    and doesn’t go through with it, our attack fails. What if we could submit the
    form automatically, as soon as they visit the page? This is possible to do with
    JavaScript code. [Listing 9-4](#listing9-4) executes the form two seconds after
    someone visits the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-4: Automatic form submission with JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: The two-second delay is there to give you some time to understand what you are
    looking at. In real-world scenarios, you’ll want to forge the request on behalf
    of the victim immediately, without any delay.
  prefs: []
  type: TYPE_NORMAL
- en: To see this attack in action, download the file at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html)
    to Kali’s desktop. Next, toggle on Burp’s intercept mode; then drag and drop the
    downloaded file into the browser. As soon as you drop it, the message `This form
    is going to submit itself in 2 seconds` should appear. Next, you should see the
    intercepted POST request in Burp. If you click Forward, you should see a response
    from the GraphQL API in the browser indicating that the mutation resulted in the
    creation of a new paste, including some metadata, like the paste’s ID, title,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that the paste creation has indeed worked, open the DVGA user interface
    at *http://localhost:5013* and visit the Public Pastes page. You should see the
    newly created paste shown in [Figure 9-4](#figure9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: A paste created via a CSRF attack'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just simulated forging a paste mutation on behalf of a
    victim.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for GET-Based Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many GraphQL implementations forbid any use of GET, but sending mutations by
    using the GET method is especially taboo, because it’s considered a security risk
    that could lead to CSRF vulnerabilities, as you’ve learned. More often than not,
    GraphQL servers will reject any incoming queries that use a mutation over the
    GET method. To test whether a GraphQL server supports them, you could send a cURL
    command like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%20` indicates spaces, `%7B` and `%7D` are the URL-encoded opening and
    closing curly brackets (`{}`) of the mutation query, and the plus sign (`+`) is
    an encoded space. When sent to DVGA, the response to this cURL command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, DVGA does not allow mutations using the GET method. However,
    in penetration tests, assume that nothing is off the table and test all hypotheses,
    because you never know when you will run into a completely custom GraphQL implementation
    that deviates from the standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'GET-based CSRF attacks are somewhat more interesting than POST-based ones because
    applications often won’t implement anti-CSRF protections on GET requests. This
    is because state-changing actions typically use other HTTP methods. If a server
    allows mutations over GET, we could exploit the HTML anchor (`<a>`) tag with the
    hypertext reference attribute (`href`) to build a hyperlink that will send the
    mutation to the server. The anchor tag executes only GET-based requests, which
    is why it isn’t a great candidate for POST-based CSRF exploitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could use image tags (`<img>`) with the source (`src`) attribute
    to embed our mutation, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This technique works on any platform that lets you specify innocent-looking
    HTML tags such as `<a>` and `<img>`. Thus, in addition to tricking victims to
    visit an attacker-controlled website containing these links, you might be able
    to use them in legitimate websites that accept URLs and render the links on the
    client side. As a result, clients will make direct GET requests to another site
    chosen by the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can’t send mutations to DVGA by using the GET method, we can try
    using GET to send the state-changing query `deleteAllPastes`. As the name implies,
    the `deleteAllPastes` query will delete all pastes in the server’s database. We
    can exploit this query by using either GET or POST.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform such a CSRF attack, this HTML file uses `<form>` tags to submit
    the query. JavaScript code defined using the `<script>` HTML tags makes the request
    automatically, as soon as the victim loads the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this attack, save the file at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html)
    to your desktop as an HTML file. Make sure Burp Suite is intercepting traffic,
    and then drag and drop the HTML file into your browser window. You should see
    the outbound HTTP GET request sent after two seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’re able to use CSRF to forge a GET-based query that deletes all pastes. Now
    let’s try using HTML tags such as `<a>` and `<img>` to trigger a GET-based CSRF.
    One way to do this is to create an HTML page that performs a GET request using
    an `<img>` tag, such as the one in [Listing 9-5](#listing9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-5: GET-based CSRF using image tags'
  prefs: []
  type: TYPE_NORMAL
- en: Save this as an HTML file. As before, it will execute as soon as the page loads,
    because the browser will try to fetch the URL defined using the `src` attribute
    and send a GraphQL query.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A second way we could exploit GET-based CSRF is by abusing another vulnerability,
    such as *HTML injection*, which allows an attacker to inject HTML tags into a
    web page. If a victim visits the site, their browser will render the HTML code.
    In particular, if an attacker is able to inject a hyperlink using the `<a>` tag
    or an image link using the `<img>` tag, clients will initiate the GET request
    when they visit the page, following the tags’ default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Can we trigger CSRF on DVGA using HTML injection? Let’s find out. Open Firefox,
    navigate to ***http://localhost:5013***, and go to the **Public Pastes** page.
    Next, open Developer Tools (CTRL-SHIFT-I) and go to the **Network** tab. Ensure
    that Altair is pointing to *http://localhost:5013/graphql* and enter the mutation
    in [Listing 9-6](#listing9-6), which will create a new paste with a CSRF payload
    as its content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-6: Creating a paste containing a CSRF payload'
  prefs: []
  type: TYPE_NORMAL
- en: This request injects the `<img>` tag containing the `deleteAllPastes` query
    into the Public Pastes page. To do so, it relies on the fact that DVGA fetches
    paste data by using GraphQL subscriptions (with WebSocket as the transport protocol).
    Your browser subscribes to new paste-creation events, so whenever a new paste
    is created, the subscription automatically populates the page with its title,
    content, and other information. By putting our payload in the `createPaste` `content`
    field, we effectively embed it on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when clients send queries using `createPaste` and the `content` field,
    they will render the payload. Take a close look at what happens in your Network
    tab once you send the query. You should see the outbound GET request shown in
    [Figure 9-5](#figure9-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: A GET-based query sent through an HTML image tag containing a CSRF
    payload'
  prefs: []
  type: TYPE_NORMAL
- en: If you refresh your browser, you should no longer see any pastes, as the CSRF
    attack should have deleted them. Click **Rollback DVGA**, located in the top-right
    drop-down menu, to restore the server to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve discussed GET- and POST-based CSRF attacks. We’ve also discussed how some
    GraphQL servers attempt to prevent CSRF by rejecting mutations using the GET method,
    and how to test for those as well. Next, let’s use BatchQL and GraphQL Cop to
    automatically flag GraphQL servers that might be vulnerable to CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Testing with BatchQL and GraphQL Cop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BatchQL has multiple CSRF-related test cases. Let’s run it against DVGA to
    see what information we’re able to get about its CSRF vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used `grep` with the `-i` flag to filter out results unrelated
    to CSRF vulnerabilities. BatchQL detected that both GET and POST allow non-JSON-based
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL Cop is similar to BatchQL in the way it tests for CSRF vulnerabilities,
    except it additionally tests whether the server supports mutations over GET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Automated tools may introduce false positives, so we recommend always manually
    verifying that their results are accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing CSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the years since CSRF was discovered, browser vendors such as Mozilla and
    Google have significantly improved their CSRF mitigations. Various open source
    web server frameworks have also made CSRF vulnerabilities tremendously harder
    to exploit. This section explains the CSRF mitigations that exist today at the
    browser and server levels.
  prefs: []
  type: TYPE_NORMAL
- en: The SameSite Flag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Browsers have started supporting a special HTTP cookie attribute called `SameSite`.
    This attribute allows developers to decide whether the client browser should attach
    the cookie when making cross-site requests. To set this cookie attribute, the
    application needs to set a `Set-Cookie` response header. This interferes with
    a CSRF attack’s attempt to send a request from the attacker website (say, *attacker.com*)
    to a target website of interest (*banking.com*).
  prefs: []
  type: TYPE_NORMAL
- en: One challenge with using the `SameSite` attribute is that older browsers may
    not support it. However, most of the modern browsers do. Mozilla’s Developer website
    has a dedicated section about `SameSite` browser support that developers can use
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SameSite` cookie attribute accepts three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Strict` Send the cookie only when the user is browsing within the same origin'
  prefs: []
  type: TYPE_NORMAL
- en: '`Lax` Send cookies only when the request uses HTTP GET and was not initiated
    by a script, such as by top-level navigation'
  prefs: []
  type: TYPE_NORMAL
- en: '`None` Send the cookie on cross-site requests, effectively providing no protection'
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL servers that set cookies with the `SameSite` attribute will return
    a `Set-Cookie` HTTP response header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When a website sets a cookie without specifying the `SameSite` attribute, modern
    browsers such as Chrome assume it is set to `Lax`. When a cookie is set with a
    value of `Strict`, the cookie won’t be sent on cross-site requests if a CSRF attack
    takes place.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-CSRF Tokens
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To protect against CSRF vulnerabilities at the server level, web frameworks
    introduced *anti-CSRF tokens*. These are hard-to-guess, cryptographically strong,
    and unique strings generated on the server. The server expects the client to pass
    an anti-CSRF token on every request. When a server sees an incoming request without
    such a token, the server rejects that request.
  prefs: []
  type: TYPE_NORMAL
- en: Servers can generate anti-CSRF tokens per request or once for the lifetime of
    a user session. Generating a token per request is stronger mitigation and more
    difficult to defeat because it reduces the amount of time an attacker has to obtain
    a valid token. Once a token gets invalidated, the server should no longer accept
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clients typically send anti-CSRF tokens to the server by using an HTTP request
    header, such as `X-CSRF-TOKEN`, or in an HTTP body parameter, such as `csrf-token`.
    Many web frameworks have built-in support for CSRF protection, allowing developers
    to build secure applications without requiring them to implement CSRF defenses
    from scratch. Here is an example HTTP request that contains an anti-CSRF token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to remember that, just like any other security control, tokens
    can be defeated if implemented incorrectly. Here are a few ways an attacker might
    go about bypassing anti-CSRF tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing the CSRF token value.** Some anti-CSRF implementations may fail
    when a CSRF parameter exists but no value is set, resulting in a null value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Removing the CSRF parameter and token value altogether.** Some anti-CSRF
    implementations may fail when the parameter is not set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusing a CSRF token in subsequent requests.** If an attacker can capture
    one valid anti-CSRF token, such as one belonging to their own session, and the
    server doesn’t invalidate already-used tokens, it’s possible to reuse that token
    in CSRF attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replacing the CSRF token with a random string of the same character length.**
    Some servers may simply look at the token value and check its length. If the length
    is equal to that of a normal token (for example, 14 characters), they may let
    the request go through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brute-forcing the CSRF token.** Some CSRF tokens may be cryptographically
    weak, allowing an attacker to brute-force them. For example, they might be short
    in length, use a predictable pattern, or employ a weak cryptographic algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When combined, browser- and server-level CSRF protections follow the defense-in-depth
    security principle and make CSRF harder for attackers to exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Side Request Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*SSRF* allows an attacker to perform requests on behalf of an impacted server.
    Using SSRF, attackers could force the server to establish connections to internal
    services, often providing access to restricted network zones, internal APIs, and
    sensitive data. Web applications can introduce SSRF in many ways. Frequently,
    applications expose functionality to clients that takes input from them and uses
    it to perform a particular action. For example, consider an application that lets
    the user supply a URL to a photo they like from a specific website, such as *imgur.com*.
    The application then downloads the photo and sends it to the user over email as
    an attachment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the application expects two inputs: a URL to *imgur.com* containing
    an image, and an email address. What if an attacker supplies other inputs, such
    as a URL like *http://lab.blackhatgraphql.com/cat.png* and an email address like
    *info@blackhatgraphql.com*? If the application doesn’t validate the inputs by,
    say, ensuring that the URL’s domain is *imgur.com*, then, once the user submits
    this information, the application might instead attempt to reach the attacker-controlled
    website, download the image to disk, and save it to a folder. It might then use
    a command line utility or a script to send the email with the attachment to the
    user.'
  prefs: []
  type: TYPE_NORMAL
- en: An attacker could also supply a variety of URLs as input, including URLs that
    contain addresses of private, non-routable IP addresses (such as *172.16.0.0/24*
    or *10.10.0.0/24*). If the server happens to exist on a network where these ranges
    exist, it may perform calls to internal services, such as databases or internal
    websites on the network, allowing an attacker to read responses from servers they
    shouldn’t otherwise be able to reach. An attacker can also attempt to guess internal
    URLs in hopes of landing on a valid one that resolves to an internal address (such
    as *internal.example.com*, *internal2.example.com*, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: With the adoption of cloud infrastructure, SSRF has become one of the greatest
    vulnerabilities for hackers to find. This is because many cloud providers host
    metadata endpoint URLs, which allow cloud instances to read information about
    themselves, such as the role assigned to the instance and the credentials in use.
    Because SSRF could allow an attacker to make internal calls, it could provide
    them with the ability to obtain this sensitive information about the vulnerable
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers can attempt SSRF on a variety of protocols other than HTTP, such as
    File Transfer Protocol (FTP), Server Message Block (SMB), Lightweight Directory
    Access Protocol (LDAP), and so on. And, just like other API technologies, GraphQL
    isn’t immune to SSRF vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Types of SSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might encounter three kinds of SSRF vulnerability when performing a GraphQL
    penetration test. Much like the blind SQL injection you learned about in Chapter
    8, *blind SSRF* vulnerabilities provide no concrete visual indication that the
    vulnerability exists. Instead, an attacker may be able to infer the presence of
    a vulnerability by using out-of-band exploitation tools that can listen to various
    protocol messages.
  prefs: []
  type: TYPE_NORMAL
- en: For example, recall the URL image-fetching service we discussed earlier. When
    exploiting a blind SSRF, an attacker may be able to tell that the application
    is vulnerable by capturing traffic on the remote server that hosts *lab.blackhatgraphql.com*.
    When the attacker submits the URL *http://lab.blackhatgraphql.com/cat.png*, the
    application may initiate certain connections on different protocols before it
    attempts to perform the image fetch over HTTP, such as TCP connections on port
    80\. This could indicate that the application is attempting to reach the attacker-controlled
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to determine the existence of a blind SSRF is through timing analysis.
    An attacker can introduce an intentional, artificial delay in the HTTP responses
    that the attacker-controlled server returns, and then determine whether the attack
    succeeded based on the amount of time it takes for the vulnerable application
    to return a response.
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, a *semi-blind SSRF* offers some evidence, but not a full
    indication, that an SSRF vulnerability exists. The information could include errors
    or partial server responses. Imagine that an attacker tries submitting various
    internal URLs to the image-fetching service in an attempt to discover which network
    the host is on. For example, they might submit *http://10.10.0.254/index.html*
    or *http://172.12.0.254/index.html*. In a successful attempt, the application
    may send an email without the attachment, while for a failed attempt, it wouldn’t
    send an email at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last type of SSRF is the kind you should hope to discover as a penetration
    tester: *non-blind SSRF* (also called *full-read SSRF*), in which the server returns
    a full response to the attacker, indicating that the SSRF vulnerability exists.
    In the example of the image-fetching service, we may see the full HTTP response
    after providing a non-image-based URL to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Vulnerable Operations, Fields, and Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When testing GraphQL servers for SSRF, examine all possible operations, whether
    they’re mutations or queries. As you might expect, SSRF typically affects one
    or more vulnerable GraphQL arguments that accept values, such as scalars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also pay close attention to GraphQL field names to see what they were designed
    to do. For example, fields whose names include verbs such as *fetch*, *import*,
    *download*, or *read* could all imply that the server performs an action, such
    as reading from somewhere or fetching a resource. In addition to field names,
    certain argument names could suggest that the server is attempting to perform
    an outbound connection to resolve the query. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ip`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`url`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`host`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`network`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`domain`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`site`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`target`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fetch`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`img_url`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`target_url`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`remote_url`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a partial list, but it should give you an idea of which keywords could
    be telling.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for SSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s go ahead and test for SSRF vulnerabilities in DVGA by using Burp Suite.
    Open the built-in browser by clicking **Open Browser**. Then, quickly tour DVGA’s
    web interface. Does anything jump out at you? How about the Import a Paste page,
    shown in [Figure 9-6](#figure9-6)?
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-6: DVGA’s Import a Paste page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Import from URL form takes a URL and attempts to import the paste from
    it. To see what happens when you submit a URL, toggle on the Intercept mode in
    Burp Suite, enter any URL into the search bar, and click **Submit**. (Here is
    an example paste you could import: *https://pastebin.com/raw/LQ6u1qyi*.) You should
    see a request like the following in Burp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the request uses the `importPaste` mutation, which accepts
    four arguments: `host`, `port`, `path`, and `scheme`. The POST JSON payload includes
    the `variables` key to pass the URL components (values) to these arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, DVGA uses the URL as part of an HTTP GET request, reads the
    response, and adds it into its paste database. To see the imported content, click
    the **Forward** button in Burp Suite to send the request to the GraphQL server,
    toggle off Intercept mode, and go to the **Private Pastes** page.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, GraphQL made an HTTP call to retrieve this content from the
    URL. This type of functionality screams SSRF! Let’s manually explore the same
    GraphQL query, changing some of the values. The mutation is shown in [Listing
    9-7](#listing9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-7: The `importPaste` mutation'
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely, the four arguments compose the building blocks of a URL
    that GraphQL will construct (in this case, *https://pastebin.com:443/raw/LQ6u1qyi*).
    If we can use the HTTP (or HTTPS) scheme and provide any domain and port that
    we desire, nothing stops us from poking around for other services on DVGA’s network,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens when we specify an internal URL instead of an external
    one. In [Listing 9-8](#listing9-8), we specify a different URL destination to
    import a paste from. The mutation will force DVGA to import a paste by making
    an HTTP request to *http://localhost:8080/paste.txt*. Note that while `localhost`
    is a valid host, port `8080` is not open on the DVGA container. Therefore, this
    request won’t return anything meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-8: The malicious version of the `importPaste` mutation'
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the mutation, you should see this response from Altair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The server returns an empty `result` object value. We were able to get this
    response in Altair pretty quickly. (In our lab, we received it within 100 milliseconds.)
    So, we now know that we get an immediate result without any data in the `result`
    JSON key if we probe a port that isn’t open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s simulate an SSRF vulnerability by probing for a service that does
    exist. To simulate an additional service on the DVGA container, we’ll use Netcat.
    First, start a Netcat listener in the DVGA container by running the following
    Docker command in Kali’s terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll construct a payload to send an HTTP probe to the port Netcat is
    binding to (7773), as shown in [Listing 9-9](#listing9-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-9: A mutation query to abuse an SSRF vulnerability'
  prefs: []
  type: TYPE_NORMAL
- en: If you send this query, you should receive output similar to [Listing 9-10](#listing9-10)
    in your Netcat listener.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-10: DVGA request reached the internal service'
  prefs: []
  type: TYPE_NORMAL
- en: This shows that DVGA made a GET request to an internal, unexposed port. Note
    that this port is not directly accessible by the Kali machine; we’re using DVGA
    itself to reach it, illustrating how an SSRF vulnerability can give an attacker
    access to services they otherwise wouldn’t be able to reach directly. This SSRF
    attack is more specifically a *cross-site port attack (XSPA)*, which falls under
    the SSRF vulnerability category.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed that Altair hangs after sending the `importPaste`
    mutation in [Listing 9-10](#listing9-10). This happens because the Netcat listener
    we opened won’t return a response, but Altair waits until it receives a response
    from the GraphQL API. This is effectively a blind SSRF, because we have no direct
    access to the response as the attacker; all we know is that the client hangs when
    we probe a port that’s open. You can close the Netcat listener by pressing CTRL-C.
    Altair’s state should then return to normal.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing SSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine whether an application might be vulnerable to SSRF, we can ask
    ourselves this question: Does a client have control over any of the target URLs
    the API flows use? SSRF mostly involves manipulating target URLs by directing
    them to unexpected and restricted internal or external locations. Here are some
    strategies for protecting against this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input validation.** Allows rejecting dangerous characters passed to GraphQL
    arguments that accept URLs as part of a query or mutation. Ensures that only authorized
    URLs are accepted and helps reduce the risk of SSRF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network segmentation.** Helps minimize the risk by ensuring that applications
    can communicate with only the relevant internal networks. A vulnerable GraphQL
    API in your staging network shouldn’t be able to reach another GraphQL API in
    your production network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Threat modeling.** Allows identifying potential risks earlier in the development
    life cycle of GraphQL APIs and, more specifically, in queries or mutations that
    have the potential to be vulnerable to SSRF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Least privileges principle.** Helps minimize the blast radius. Ensure that
    the instance on which GraphQL runs does not have overly permissive permissions
    and cannot perform privileged actions across applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we’ll pivot to talking about hijacking-based vulnerabilities
    that impact GraphQL subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site WebSocket Hijacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an attacker can hijack a user’s session by getting their hands on session
    cookies that grant special privileges on an application, they can perform actions
    using the victim’s privileges and access their sensitive data. *CSWSH* is a CSRF
    vulnerability that impacts the handshake part of WebSocket communications, which
    use cookie-based authentication. Because GraphQL APIs can use WebSocket for subscription
    operations, they risk being vulnerable to CSWSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 3, we showed the handshake request and response sent between a GraphQL
    client and server when using subscriptions over WebSocket to communicate. Clients
    initiate these WebSocket handshakes over HTTP and may include a cookie like the
    following if the WebSocket server implements authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: CSWSH can occur when a WebSocket connection handshake doesn’t include an anti-CSRF
    token to prevent attackers from performing cross-origin requests. When no such
    token exists, it’s easy for an attacker to develop special code that forges WebSocket
    messages on behalf of the victim and uses their authenticated session.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to anti-CSRF tokens, WebSocket servers should also validate the
    `Origin` header in the WebSocket handshake request. The `Origin` header has an
    important security function, as it identifies the request’s source. If a server
    doesn’t check this header, it won’t know whether the handshake request was forged.
    Any handshake with an unauthorized origin should return a *403 Forbidden* response
    code rather than *101 Switching Protocols*.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Subscription Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSWSH vulnerabilities lie at the transport protocol level and so aren’t flaws
    in GraphQL itself. In the context of GraphQL, you’ll find them only when a GraphQL
    API uses subscriptions to perform real-time updates. Thus, to test for CSWSH,
    we’ll first want to know whether the target application has any subscription-related
    fields. To discover this, we can use an introspection query that relies on the
    `subscriptionType` to get field names, as shown in [Listing 9-11](#listing9-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-11: Getting subscription field names by using introspection'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this query in Altair against DVGA, you should notice a field in the
    schema named `paste` that the subscription operation can use.
  prefs: []
  type: TYPE_NORMAL
- en: Hijacking a Subscription Query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s hijack a subscription query and exfiltrate its response. To simulate
    this attack, we’ll take the following steps. From the attacker’s perspective,
    we’ll open a Netcat TCP listener on port 4444, where we’ll receive the exfiltrated
    response. Next, from the victim’s perspective, we’ll simulate a user falling victim
    to a social-engineering attack by dropping an HTML file into the browser so it
    loads the JavaScript code, hijacking the user’s session to perform a WebSocket
    handshake and subscribe to the `paste` event. We’ll also create a new paste in
    DVGA for the subscription query to pick up. This will simulate website activity
    that the victim may have access to that the attacker shouldn’t. Finally, we’ll
    read the exfiltrated response obtained by Netcat.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by first examining the underlying code to understand the attack
    pattern. Save the CSWSH hijacking code at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html)
    to your desktop. Make sure the filename has the *.html* extension. [Listing 9-12](#listing9-12)
    shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-12: JavaScript code that performs WebSocket hijacking'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a new `WebSocket` object and specify the DVGA’s subscription URL
    ❶. At ❷, we declare a `query` variable containing the subscription query. This
    query subscribes to the `paste` event and fetches fields such as `id`, `title`,
    `content`, `ipAddr`, `userAgent`, `public`, and the owner’s `name`. At ❸, we send
    a JSON string containing this query over the WebSocket protocol. After the message
    is sent, the `ws.onmessage` event handler is called when incoming WebSocket messages
    are received. This handler will parse the message as a JSON object ❹. Once the
    message is parsed, the code at ❺ will exfiltrate the response to a destination
    (in this case, *http://localhost:4444*) by using GET URL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get things started! In a terminal window, run the following command to
    start the Netcat listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `-vlp` flags we pass to Netcat tell it to listen (`-l`) in verbose mode
    (`-v`) on port (`-p`) 4444\. Next, open a browser window and drop the HTML file
    you downloaded earlier into the browser’s window. You should see the page shown
    in [Figure 9-7](#figure9-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-7: The WebSocket hijacking demo'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open another browser window and click **Create Paste** on the left to
    open the Create a Paste page on *http://localhost:5013*. Enter something you’ll
    recognize as the title and your message, as shown in [Figure 9-8](#figure9-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c09/F09008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-8: A paste creation in DVGA'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click **Submit**, and pay close attention the terminal window in which
    Netcat is running. You should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Netcat received a GET request from the victim containing the exfiltrated paste
    data. You can see that the request’s URL parameters start with `/?{%22type`. The
    payload is URL encoded, but when you decode it, you can immediately tell it’s
    the paste data we created using DVGA’s user interface. You can perform this URL
    decoding with a website such as [https://meyerweb.com/eric/tools/dencoder](https://meyerweb.com/eric/tools/dencoder)
    or by using Python from the terminal, as shown in [Listing 9-13](#listing9-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 9-13: URL decoding with Python'
  prefs: []
  type: TYPE_NORMAL
- en: We were able to exfiltrate data by forcing a client to visit an attacker-controlled
    website, where custom code sent forged, cross-site WebSocket messages and exfiltrated
    their responses to a remote Netcat listener.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing CSWSH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because CSWSH is a CSRF attack, you can prevent it by using CSRF mitigation
    techniques. WebSocket servers that use forms of authentication other than cookies
    to authenticate clients, such as JWT, can also offer protections. When a server
    uses JWT tokens, cross-site WebSocket messages won’t be able to authenticate without
    the proper headers, resulting in a handshake failure.
  prefs: []
  type: TYPE_NORMAL
- en: Validation of the `Origin` header is also crucial to preventing CSWSH attacks,
    and from a hacker’s perspective, this validation is worth testing for bypasses.
    Servers may check the header in odd ways. For instance, if the application allows
    only the origin *example.com*, an attacker might try creating a domain that uses
    it as its subdomain, like *example.com.attacker.net*. If the server validates
    the `Origin` header in a naive way (for instance, by checking for the string *example.com*),
    such an attack might pass the validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about attacks affecting GraphQL API consumers and
    servers. Using GET- and POST-based CSRF, attackers could forge queries and mutations
    on behalf of clients. By hijacking WebSocket communications by using CSWSH, an
    attacker could exfiltrate GraphQL subscription responses. Finally, SSRF allows
    attackers to forge requests on behalf of servers and potentially reach internal
    resources.
  prefs: []
  type: TYPE_NORMAL
