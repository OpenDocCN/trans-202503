- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Don’t Lick the Probe: How to Inject Faults'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Chips and devices are engineered to have an extremely low fault probability
    when operating within their normal ranges. Running chips outside their normal
    operating ranges, however, eventually causes faults to occur. For this reason,
    their running environments are often controlled: the power lines on a printed
    circuit board (PCB) have decoupling capacitors to buffer voltage spikes or dips,
    clock circuits are restricted to specific ranges, and fans keep temperatures in
    check. If you happen to be in space, beyond the protection of Earth’s atmosphere,
    you need radiation shielding and other fault-resistant circuitry to prevent faults
    from occurring.'
  prefs: []
  type: TYPE_NORMAL
- en: Though chips and their packaging resist most naturally occurring faults, they
    are typically not hardened against malicious attackers. Chips specifically made
    to resist attackers who have physical access to them, such as the secure microcontrollers
    found in some smart cards, are notable exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we describe different methods of injecting faults that are
    commonly used in fault-injection security testing and are accessible to a range
    of attackers. These methods include *voltage and clock* *fault injections*, *electromagnetic
    fault injection (EMFI)*, *optical fault injection*,and *body biasing injection*.
    For each technique, we’ll also cover some of the specific parameters you might
    need to search. (We discussed strategies for searching those parameters in Chapter
    4.)
  prefs: []
  type: TYPE_NORMAL
- en: Many fault injection techniques were pioneered in the field of *failure analysis
    (FA)*, which studies chip failures in order to minimize failure rates during or
    after fabrication. Failure analysis engineers have great fault injection toys
    at their disposal, including scanning electron microscopes (SEMs), focused ion
    beams (FIBs), microprobing stations, radiation chambers, and more. We won’t discuss
    these instruments, as they are cost-prohibitive to most people, and attackers
    tend to use lower-budget tools if they can.
  prefs: []
  type: TYPE_NORMAL
- en: Methods that generate more unpredictable faults are possible, too. For example,
    simply heating a chip or using a strong flashlight can cause faults—in some cases,
    successful faults. But because the time and space resolution are very poor with
    such methods, it’s hard to target a specific operation, so we cover many low-cost
    options for doing similar experiments that have a better degree of control.
  prefs: []
  type: TYPE_NORMAL
- en: Clock Fault Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Clock fault injection*, commonly referred to as *clock glitching*, aims to
    insert a rogue, too-narrow, or too-wide clock edge. We discussed clock glitching
    in Chapter 4 and introduced an example in Figure 4-2 of what a clock glitch looks
    like, but we haven’t yet explained why clock glitching works in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a bit of theory on digital circuits to explore how clock glitching
    works—specifically, *D flip-flops* and *combinatorial logic*. Consider the D(ata)
    flip-flop as 1-bit memory. It takes an *input data signal* *(D)* and *clock signal*
    *(CLK)* as input, and it has an *output data signal (Q)* as output. The output
    remains the same as its internal 1-bit memory throughout the clock cycle, except
    during a small period when the clock signal goes from low to high, which is the
    *positive clock edge*. At this edge, the flip-flop sets its memory to the value
    of D. A set of *n* flip-flops is also called an n*-bit register*.
  prefs: []
  type: TYPE_NORMAL
- en: Combinatorial logic, which is the collection of wires and Boolean gates in a
    digital circuit, typically feeds the input and output to flip-flops. For example,
    combinatorial logic could implement an n*-bit ripple-carry adder (RCA)*, which
    is a circuit that calculates the sum of two *n*-bit input registers and stores
    the result in an (*n* + 1)–bit output register. An RCA is built from a series
    of 1-bit *full adders,* which are circuits that perform addition of two 1-bit
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-1](#figure5-1) shows an example of a 4-bit counter: the register
    consists of a 4-bit register (four D flip-flops 1) and a 4-bit ripple-carry adder
    2 (constructed from four full adders 3). In the steady state before the clock
    ticks, the register’s output is fed to the RCA, which adds the number 1 to it
    and feeds the result of that addition to the register’s input. When the clock
    4 ticks, the register captures that input, and the register’s output changes.
    This changed output is fed to the RCA to calculate the next counter value, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/278748c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: A circuit that increases a counter every clock tick'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider what happens when a positive clock edge hits the input register
    feeding into the RCA. The register’s memory and output changes to whatever value
    is input to them. As soon as the output changes, the signals start propagating
    through the RCA, which means they propagate through the full adders one by one.
    Finally, the signals reach the output register connected to the RCA. On the next
    positive clock edge, the output register’s state changes to the result of the
    RCA.
  prefs: []
  type: TYPE_NORMAL
- en: The time it takes for the signals to travel from the input of a combinatorial
    circuit to the output is called the *propagation delay*. The propagation delay
    depends on many factors, including the number and types of gates in the circuit,
    the way the gates are connected, the data values at the input, but also the transistor
    feature size, temperature, and supply voltage. Each combinatorial circuit on a
    chip, therefore, has its own propagation delay. *Electronic design automation
    (EDA)* software can find the worst-case propagation delay for a circuit using
    *static timing analysis*. This worst-case propagation delay is the length of the
    *critical path*, which limits the operating ranges of the chip design. It’s specifically
    used to calculate the maximum clock frequency at which a circuit can run. Once
    a chip exceeds the maximum clock frequency, the input into the critical path will
    not have fully propagated into the output before the next clock edge, meaning
    that the output registers may memorize a value that is not the correct output
    of the circuit. (And, hey, that sounds a lot like a fault, doesn’t it?)
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, in order to function properly, flip-flops need a stable input
    during a small duration before and after the clock edge, respectively called the
    *setup time* and *hold time*. Unsurprisingly, a *setup time violation* occurs
    when data changes at a register input right before the clock edge, and a *hold
    time violation* occurs when data changes at a register input right after the clock
    edge. An attacker can cause these kinds of violations (thereby causing faults)
    by operating the device outside the specified ranges for clock frequency, supply
    voltage, and temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-2](#figure5-2) shows a simple digital device containing two registers
    that hold a byte of data each.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/278748c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: A simple shift register working correctly'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, each register holds a byte of data (the register consists of eight
    flip-flops), and the state of the bits making up the byte is moved between registers
    on a positive clock edge. After the first clock edge, the two registers hold the
    bytes 0xA2 and 0x9B. The next input byte, 0x17, is waiting at the left register,
    and 0xA2 waits at the right register. At the second clock edge, 0x17 moves into
    the left register. The right register reads the output of the left register, 0xA2,
    and after a short time, it appears at the right register output. Another data
    shift from left to right happens at the next clock edge.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-3](#figure5-3) shows the same circuit operating with a faulty clock,
    in which we introduce a very short clock cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](image_fi/278748c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: A simple shift register working incorrectly'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, after the first clock edge, the left and right registers hold
    bytes 0xA2 and 0x9B, respectively, which is the same starting state as in [Figure
    5-2](#figure5-2). As before, the next input byte, 0x17, is waiting, but now we
    have a short clock cycle interfering with the orderly process. The input byte,
    0x17, is still being copied to the left register, as was the case in the correctly
    functioning circuit. However, the short cycle has not allowed the output bus of
    the left register sufficient time to stabilize, so its output is somewhere in
    transition between 0xA2 and 0x17\. This means the right register is now in some
    unknown state, 0xXX, which it also sends to its output. On the next clock edge,
    the circuit continues to operate as normal, setting the value 0x17 onto the output
    data bus, but the data sequence in this case changes the value 0xA2 into something
    different, causing a fault in whatever program was executing!
  prefs: []
  type: TYPE_NORMAL
- en: Metastability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides violating the critical path timing, violating the timing constraints
    has other effects. If data changes too closely to a clock edge, the flip-flop
    output enters a *metastable* state, which is typically represented as an invalid
    logic level that takes some time to reach the final value (see [Figure 5-4](#figure5-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/278748c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: Flip-flop output in a metastable state'
  prefs: []
  type: TYPE_NORMAL
- en: What does this look like on a real device? We can use a field-programmable gate
    array (FPGA) to build a system that allows us to adjust the clock to cause these
    states to become more likely by slightly shifting the clock edge to fall before/after
    the data transition. In the example shown in [Figure 5-5](#figure5-5), the flip-flop’s
    output should alternate between 0 and 1 if no invalid states occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05005](image_fi/278748c05/f05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: A circuit that allows shifting a clock edge to cause metastability'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-6](#figure5-6) shows that indeed no invalid states are entered. We’re
    using an oscilloscope’s *persistence* mode to show the circuit operation. Many
    runs of the same operation are plotted on top of each other, and the intensity
    and color show the most likely “path.” In this case, the darker shade in [Figure
    5-6](#figure5-6) is most likely, and the lighter shade is least likely. The output
    is sometimes 1 and sometimes 0\. It always transitions, however, which means if
    it’s 0, it becomes 1, or vice versa, and both transitions (1 to 0 and 0 to 1)
    are equally likely, as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05006](image_fi/278748c05/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Nominal operation'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 5-7](#figure5-7), we adjust the clock edge by changing the delay
    line to cause metastability. The flip-flop now takes a much longer time to reach
    a final value. The metastability means the final value is defined by random noise
    that pushes the flip-flop into a stable state. This means not only that the final
    value is random, but also that because the settling time is longer than expected,
    some circuitry may sample the metastable flip-flop in the initial state, and some
    may see the final state. For this example, we lowered the core voltage slightly
    to exaggerate the metastable settling time.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05007](image_fi/278748c05/f05007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: Metastable data output from shifting the clock edge to cause timing
    violations (low-voltage operation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-8](#figure5-8) shows the clock edge and output when run at normal
    voltages.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05008](image_fi/278748c05/f05008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Metastable data output from shifting the clock edge to cause timing
    violations (normal voltage operation)'
  prefs: []
  type: TYPE_NORMAL
- en: The slightly longer metastable state is still present, but note that the lack
    of transition does sometimes still happen, which demonstrates that violating setup
    and hold times will propagate invalid logic states.
  prefs: []
  type: TYPE_NORMAL
- en: Fault Sensitivity Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Propagation delays depend, among other things, on the data values present, which
    means faults caused by violating setup and hold time issues may depend on the
    data values. *Fault sensitivity analysis* exploits this behavior; the idea is
    that you overclock a device to the point where only certain data values cause
    faults. Say 0xFF causes a fault when the device is overclocked and other values
    do not, so if you get a fault, you know a value was 0xFF. After some characterization,
    you can learn what those data values were by detecting whether there was a fault.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One limitation of clock glitching is that it requires a device using an external
    clock input. When looking at a typical device’s datasheet, you might find it has
    an internal clock generator. A dead giveaway on a small embedded device is that
    it has no external crystal or clock generator, pointing to the probable use of
    an internal generator. This means you can’t feed an external clock into the device,
    and without control over the clock, there is no clock faulting.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the datasheet shows an external crystal, something like a *phase-locked
    loop* *(PLL)* might modify it internally. An indication of this is when the external
    crystal frequency is lower than the expected device operating frequency. The crystal
    on a Raspberry Pi is 19.2 MHz, but the operating frequency of the main CPU can
    be several hundred MHz. This is because that external clock is multiplied up to
    a much higher internal level by the PLL, which is also the case for almost all
    System-on-Chip (SoC)devices, such as cell phones. Even many low-cost and low-power
    devices have PLLs. You can still use clock faults to attack devices with a PLL,
    but the effectiveness is lower due to the way PLLs work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in seeing the effectiveness of clock fault injection
    with a PLL, see “Peak Clock: Fault Injection into PLL-Based Systems via Clock
    Manipulation” by Bodo Selmke, Florian Hauschild, and Johannes Obermaier (presented
    at ASHES 2019).'
  prefs: []
  type: TYPE_NORMAL
- en: Required Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 4, we introduced a simple method of generating clock glitches by
    switching between two different clock frequencies. Another method is to insert
    small pulses (glitches) into a single-source clock with an FPGA, which allows
    you to use two phase-shifted clocks XOR’d together (see [Figure 5-9](#figure5-9)),
    so they can generate a faulty clock easily.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05009](image_fi/278748c05/f05009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-9: Generating clock faults using an FPGA'
  prefs: []
  type: TYPE_NORMAL
- en: Almost every FPGA provides clock blocks that are capable of performing the required
    phase adjustment logic. For example, the ChipWhisperer project implements such
    clock faulting on a Xilinx Spartan-6 FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: We can use an XOR method to generate a faulty clock, as in this example. The
    phase shifts are implemented via clock control blocks present inside most FPGAs.
    In [Figure 5-9](#figure5-9), the source (input) clock’s objective 1 is to end
    up with the “faulty” clock 2. To do this, the input clock is phase-shifted (delayed)
    by the first block to give us clock 3. This clock is again phase-shifted to give
    us clock 4. Using a logic AND with one input inverted, we are able to get a pulse
    that is the width set by the second phase shift, which is offset from the edge
    of the original clock by the delay inserted by the first phase shift 5. This “fault
    stream” contains an endless stream of pulses, so we can choose to siphon off only
    a few pulses using an AND gate to give us our glitch 6. Finally, we insert this
    glitch into the original clock using an XOR to provide us with the final clock
    2. The smallest phase shifts that the FPGA can perform and the minimum logic gates’
    switching speeds limit this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use analog delay lines where variable resistors (or variable
    capacitors) can fine-tune the delay (see [Figure 5-10](#figure5-10)), which performs
    the same operation we achieved with an FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05010](image_fi/278748c05/f05010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-10: Generating clock glitches using analog delay lines'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-10](#figure5-10) shows the use of resistor-capacitor (RC) blocks,
    which take the place of the phase-shift elements shown in [Figure 5-9](#figure5-9).
    You can use standalone logic chips to build the entirety of that circuit by selecting
    the appropriate chips depending on the logic levels required (for example, 3.3
    V or 5.0 V). We suggest using multiturn trimmer pots if you want to use a variable
    resistor. You can use an Arduino to trigger the *Glitch Enable* pin, which switches
    between the regular clock and the glitchy clock (see the “Voltage Fault Injection”
    section later in the chapter or jump ahead to [Listing 5-1](#listing5-1) for a
    code example).'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to high-speed designs, “logic level” has many different meanings
    beyond even the levels you might have come across, such as 3.3 V and 5.0 V. Clocks
    will commonly use a type of signaling called *low-voltage differential signaling
    (LVDS)*, where two wires conduct signals of opposite phase, meaning that while
    one wire goes high, the other goes low. These signal levels are also much smaller;
    the typical voltage difference (swing) between low and high may be only 0.35 V,
    and this swing will be around some common level voltage. By “common level,” we
    mean it doesn’t go to 0 V (low), but instead some level below a fixed voltage.
    If the common level was 1.65 V (half of 3.3 V), the signal may swing from 1.3
    V to 2.0 V to switch from low to high (in this case, a 0.7 V swing).
  prefs: []
  type: TYPE_NORMAL
- en: The physical logic levels don’t affect the idea of clock glitching, but they
    may require additional physical effort from you. The FPGA output drivers will
    typically support some of these high-speed logic levels, for example, but you’ll
    need to understand what your target device is expecting in order to drive the
    glitch into the device properly. You may also require an LVDS driver chip or similar
    to generate an effective clock glitch.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way to insert a clock glitch is to have two clocks: one regular clock
    and one very fast clock. In Chapter 4, we briefly alluded to the fact that by
    temporarily switching to the fast clock, you can cause a fault. The length of
    the overclock will depend on the switching speed between the two clocks. In principle,
    you could do this with an Arduino or an FPGA, though the former has a slow switching
    speed. This clock-switching method is not only simple to implement, but you also
    can use it for almost any clock speed with a suitable switch. You can glitch an
    8 MHz clock or a 1 GHz clock with this method.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also generate clock glitches with a suitably fast development board
    by toggling an I/O pin. For example, if you have a device running at 100 MHz,
    you could be generating a 5 MHz clock in “software” by setting an I/O pin low
    for 10 cycles then high for 10 cycles. You can insert glitches by simply toggling
    the I/O pin for a single cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Clock Fault Injection Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve introduced two variants of clock fault injection: temporary overclocking
    (refer to Figure 4-8) and inserting a glitch into a clock (refer to [Figure 5-9](#figure5-9)).
    If you want to keep it simple, the temporary overclocking is easier to construct,
    but if you’re able, we recommend building the clock glitch insertion circuit,
    as it can generate more variations of glitches. We discussed the wait cycles,
    glitch cycles, overclock frequency, glitch offset, and glitch widthparameters
    in Chapter 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Voltage Fault Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We perform voltage fault injection by tampering with the supply voltage to
    a chip (for instance, by temporarily depriving it of power). Two main views exist
    on how voltage fault injection works: the timing view and the threshold view.
    The *threshold view* simply states that by changing the voltage on a circuit,
    the voltage threshold for a logical 0 and 1 changes, effectively changing data.
    The *timing view* leverages the fact that a relation exists between the voltage
    over a circuit and the frequencies at which it runs stably without faults. As
    mentioned earlier, a flip-flop needs a stable input for some time before and after
    a clock edge in order to capture the input value correctly. As it turns out, turning
    up the voltage on a chip decreases the propagation delay, which means the signals
    change faster and can cause hold time violations, as signals may change before
    the hold time is over. On the other hand, dropping the voltage can cause setup
    time violations, as signals may still be changing too closely to the next clock
    edge. A short glitch (a drop or spike in the supply voltage) can affect correct
    operation. The voltage on the circuit needs to be changed only when switching
    occurs in the relevant transistors. This duration is much smaller than a clock
    cycle, and therefore it’s easily sub-nanosecond on modern devices. Such a very
    short voltage change is what we are ideally aiming for when doing voltage fault
    injection.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the voltage change we speak of is right at the supply to the transistor
    itself, deep inside the chip. The *power supply network*, which routes power through
    a chip, is between a transistor and the chip’s external power supply. This network
    affects the shape of a glitch, because on-chip capacitance and inductance filter
    out any fast spikes and dips. Therefore, any glitch on the supply to the chip
    needs to be long enough so that after it has worked its way down to the transistors,
    it will be the shape that actually is able to affect the parts of the circuit
    we are interested in. The *clock network* routes the clock to all relevant gates.
    Both the clock and power supply networks reach all of the chip, so a voltage glitch
    can cause faults in many transistors at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, between a device’s power source and the power supply to a chip,
    many decoupling capacitors are aimed at reducing any dips and spikes caused by
    a switching power supply and noise picked up on the PCB from other components.
    This array of capacitors causes chips to operate with a very small probability
    of faults when operated within normal conditions. Of course, they also affect
    the dips and spikes that we intentionally want to inject when doing fault injection.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Voltage Glitches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fault injection principle is to operate a chip outside its normal conditions
    at the time when it is of interest to do so. With voltage fault injection, the
    goal is to create a stable power supply for the chip, except at the moment of
    a significant operation when it should be dropped or spiked to outside the normal
    operating voltage range.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can consider three main methods of generating the appropriate voltage glitch.
    The first is to use a programmable signal generator, where the signal generator
    output goes through a voltage buffer to power the target device. The second method
    is to switch between two power supplies: the regular operating voltage and the
    “glitch” voltage. Finally, the crowbar method simply shorts the supplied operating
    voltage.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Switching-Based Injector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are generating a voltage excursion, you’ll need some form of programmable
    power supply or waveform generator. Typical programmable power supplies can’t
    switch voltages fast enough, and typical waveform generators don’t output sufficient
    power to drive a target. (The goal is < 1ms glitches, often in the range of 40–1,000ns.
    Commercial fault injectors go as low as 2ns.) The objective is to generate a waveform
    as shown in [Figure 5-11](#figure5-11), which has the standard baseline voltage,
    and then insert a glitch at some lower or higher voltage.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05011](image_fi/278748c05/f05011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-11: Voltage fault injection waveform'
  prefs: []
  type: TYPE_NORMAL
- en: This particular waveform was generated from a circuit based on Chris Gerlinsky’s
    presentation “Breaking Code Read Protection on the NXP LPC-Family Microcontrollers”
    (REcon Brussels 2017). Gerlinsky outlines the design for a glitcher using the
    MAX4619 analog switch, which has a 10–20 Ω on-resistance (depending on supply
    voltage). The “on-resistance” is the effective resistance in the switch; 10 or
    20 Ω will limit how much current you can push through to the target. Gerlinsky
    put several of the channels in parallel to generate an even more powerful fault
    injection platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-12](#figure5-12) shows the MAX4619 with the same parallel circuitry
    to generate a multiplexor. The VCC can be 3.3 V or 5 V; using the higher voltage
    (5 V) means you have more flexibility on the input voltages and a lower on-resistance.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05012](image_fi/278748c05/f05012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-12: Voltage-switching circuit'
  prefs: []
  type: TYPE_NORMAL
- en: This circuit requires an external source to provide the signal that triggers
    the switch between the regular operating voltage (normal voltage in) and the glitch
    voltage (glitch voltage in). An embedded platform, such as an Arduino, can easily
    generate the switching signal. [Listing 5-1](#listing5-1) shows the code, which
    works on the classic ATmega328P-based Arduinos (Arduino Uno and similar).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: Arduino code for generating a quick pulse'
  prefs: []
  type: TYPE_NORMAL
- en: This code generates pulses of three different durations by using a delay routine
    that isn’t very accurate and the CPU execution speed as a timing source. You can
    easily add buttons or other interfaces to send pulses of other durations.
  prefs: []
  type: TYPE_NORMAL
- en: You can use several other devices as the multiplexor. One option is to use two
    separate complementary switch chips rather than one integrated device, such as
    the TS12A4515P and TS12A4514P. These switch chips are also available in a breadboard-friendly
    DIP package and have one “normally closed” and one “normally open” switch. The
    advantage of separate packages may be that more power dissipation is possible,
    for example. Other versions have dual-input power supplies, allowing you to pass
    negative voltages for more complex glitch options.
  prefs: []
  type: TYPE_NORMAL
- en: These multiplexors still have reasonably high on-resistance. Targeting a device
    drawing only 1 mA to 100 mA may work, for example, so you could target a simple
    standalone microcontroller. But if you are interested in a higher-power device
    or even a complete system, you won’t be able to use this simple voltage fault
    injection method because the multiplexor may overheat.
  prefs: []
  type: TYPE_NORMAL
- en: Target Preparation for the Switching Glitch Generator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you have the voltage-generation hardware, you can prepare the target. The
    goal is to make the power supply run a single power plane by disconnecting the
    standard power supply and connecting yours. The difficulty of this operation can
    range widely, mainly because a PCB has to be modified manually. Surface-mounted
    microcontrollers on a single-sided PCB with only one power plane will be easy
    to modify, whereas modifying multi-power-plane SoCs using ball grid array (BGA)
    connections will be difficult. Assuming you do not have a BGA PCB rework station,
    we focus on manual modifications using standard tools, such as a soldering iron
    and scalpels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to connect the injector:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the power plane to target. A microcontroller typically has only one,
    but for more sophisticated embedded chips, multiple power planes power different
    parts of the chip. Target the specific plane that powers the operation you are
    interested in faulting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no single way to determine the correct power plane, but some target
    study can help. Look for “VCC” or “VCORE” in datasheets/pinouts and PCB markings.
    Alternatively, measure the voltage over different pins on the chip and match those
    with known core voltages. You’ll need to know the normal voltage in any case in
    order to drive the chip later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a point on the PCB where you can disconnect the standard power supply from
    the PCB circuitry and feed in your own. To decrease the effects of capacitance
    and inductance, find a location on the PCB that is as physically close as possible
    to the target, keeping in mind that one power plane may feed into multiple pins
    on the chip package. When you disconnect the standard power supply, disconnect
    the entire power plane and then drive that plane with your injector. PCB designs,
    pinouts, and/or tracing PCB lines will help you identify a point. A voltage regulator
    or power management IC feeds a power plane, which is where you can cut the supply.
    Alternatively, you can remove inline components, such as resistors or inductors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of targets that actively monitor and manage their power supply (complex
    SoC with power management ICs being a typical example), once you completely disconnect
    the power, the monitoring circuit will note this and possibly prevent the chip
    from completing its boot sequence or even from starting up again. Make sure the
    monitoring circuit is intact or bypassed in such a way that the voltage it sees
    is not at all interrupted. Doing this depends on how the circuit is implemented
    and requires knowledge of the electronics involved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a scalpel to sever the PCB track carefully and disconnect the existing power
    supply. Double-check that you have indeed disconnected it by measuring whether
    the connection is no longer present. When you are sure it’s disconnected, solder
    the output of the injector to the power plane. Use short wires to avoid adding
    too much inductance. Use the cut as a point to power the circuit or solder a wire
    onto a (removed) decoupling capacitor pad that is on the power plane close to
    the chip.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get a nice clean fault into the chip, remove as much capacitance from the
    PCB as possible by desoldering the decoupling capacitors. These are often tiny
    capacitors inserted between VCC and GND to reduce noise on the power supply and
    actually avoid accidental faults in the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One approach is to desolder them one by one, until you’ve either removed them
    all or until the chip stops working. In the latter case, put the last capacitor
    you removed back in and hope for the best. Usually, the chip will start working
    again. You may be able to inject faults without removing capacitance, but be prepared
    to accept a lower success rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before moving on, check whether you actually can boot the device and run it
    normally when powered by your power supply. If it doesn’t run, recheck and debug
    every step you took, knowing that you may brick the device. You now should have
    a target that is run from your stable power supply and over which you have control.
    Once you reach this point, let your fault experiments commence (like the examples
    in Chapter 4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Crowbar Injected Faults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an alternative to the controlled voltage glitch, the crowbar method employs
    more force and gives less control but is easier to implement. Whereas the previous
    hardware allowed careful control over the normal and fault operating voltage,
    the crowbar method instead briefly shorts the regular operating voltage to 0 V.
    The crowbar is simply a “dead short” applied across one of the device’s power
    supplies. This must be done with care, as you can damage the power supply’s circuitry
    if the glitch is too long, bearing in mind that these supplies may not include
    short-circuit protection.
  prefs: []
  type: TYPE_NORMAL
- en: The short circuits cause ringing in the power distribution circuit, which are
    in effect large spikes. The nature of the glitch depends on the specifics of the
    board and is hard for an attacker to control. This method was introduced in Colin
    O’Flynn’s paper “Fault Injection Using Crowbars on Embedded Systems” (IACR Cryptology
    ePrint Archive, 2017).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a Crowbar
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The crowbar itself can be a MOSFET device; a MOSFET is simply a transistor.
    The specific MOSFET will depend on the device you are attacking. If your device
    has strong power supplies or large decoupling capacitors that you’re unable to
    remove, you need a high-power MOSFET. A high-power MOSFET has slower switching
    times compared to a lower-power MOSFET, so using a high-power MOSFET imposes minimum
    limits on the duration of the glitch.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of two such MOSFETs are the DMN2056U for the low-power device and the
    IRF7807 for the high-power device. Both are logic-level MOSFETs (meaning a signal
    generator or Arduino can easily drive them), but the IRF7807 has much lower on-resistance,
    which is necessary when attempting to drag down the power rails and generate a
    fault in a higher-power device such as a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Better results are found using logic-level drive MOSFETs, which can be fully
    turned on by a 3.3 V signal. Standard MOSFETs require a higher voltage (5 V to
    10 V) to be switched on, which means you won’t get as strong a crowbar effect
    if you drive them only from a 3.3 V signal. Appropriate MOSFETs are mostly available
    in surface mount format; through-hole MOSFETs are typically too slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drive the gate of the MOSFET via any suitable signal source: a laboratory
    waveform generator, an FPGA board, or an Arduino. You can use the same code from
    [Listing 5-1](#listing5-1) to trigger the MOSFET for a programmable period of
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: Target Preparation for Crowbar Glitch Generator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Compared to the controlled voltage fault, the crowbar injection method requires
    considerably less target preparation. You need only to identify an appropriate
    power plane, and you don’t need to disconnect that plane from the rest of the
    circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the sensitive power rail is much the same as in the controlled voltage
    fault. You might consult a device datasheet to determine to what voltages the
    various power pins are connected. See Chapter 3 for details of where to find such
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Attach the crowbar across the decoupling capacitors for the device. These capacitors
    will almost always have a very low impedance path to the power pin. Since the
    capacitors are simple two-terminal devices, it’s also fairly simple to make this
    connection physically. One end of the decoupling capacitor very often is connected
    to the ground line of the power rail, making it possible to solder the crowbar
    device directly across the decoupling capacitor. Let’s look at a quick example
    of this with a Raspberry Pi 3 Model B+.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Fault Attack with a Crowbar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Raspberry Pi foundation doesn’t publish full schematics for the more recent
    Raspberry Pi devices. For instance, the schematic for the Raspberry Pi 3 Model
    B+ is limited and doesn’t show the full pinout of the main SoC. It does have some
    information about the power rails (see [Figure 5-13](#figure5-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05013](image_fi/278748c05/f05013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-13: Part of the Raspberry Pi 3 Model B+ schematic, with main power
    regulator on the left (licensed under a Creative Commons Attribution-NoDerivatives
    4.0 International [CC BY-ND] license)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, you’ll want something like the “Microprocessor Unit” or “Core”
    voltage power rail. Inspecting the schematic reveals the following labels: 3V3A,
    3V3, 1V8, DDR_1V2, VDD_CORE, and a few others. In the case of the Raspberry Pi
    3 Model B+, the VDD_CORE looks like the winner. But we want to insert the fault
    much closer to the main SoC, not right at the power regulator. You’ll notice from
    [Figure 5-13](#figure5-13) that pin 19 of the power regulator chip connects to
    VDD_CORE. Let’s look at that chip (see [Figure 5-14](#figure5-14)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05014](image_fi/278748c05/f05014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-14: Part of the Raspberry Pi 3 Model B+ showing the main SoC (2) and
    power IC (1)'
  prefs: []
  type: TYPE_NORMAL
- en: The connection to pin 19 is shown as 1 in [Figure 5-14](#figure5-14). The main
    SoC is nearby at 2, but it’s far enough that inserting glitches at the output
    of the power regulator chip won’t be too effective. Luckily, we can use a multimeter
    to find a 0 Ω (direct short) from the VDD_CORE output and locations underneath
    the main SoC. [Figure 5-15](#figure5-15) shows the view underneath the SoC.
  prefs: []
  type: TYPE_NORMAL
- en: The three outlined sections in [Figure 5-15](#figure5-15) all show direct shorts
    to each other and to the VDD_CORE rail. The voltage is around 1.2 V if we measure
    it at power-on. An important note is that we might have multiple rails of a similar
    voltage; the DDR voltage is also 1.2 V, but a different rail.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the outlined sections of VDD_CORE in [Figure 5-15](#figure5-15) may
    go to different pins on the SoC. For example, this is a quad-core device that
    might have other accelerators on board too. Thus, we expect the package might
    expose different power pins that are all on the VDD_CORE rail. We may need to
    try inserting faults into each one of those three groups. For now, we’ll solder
    wires to each of those groups, as shown in [Figure 5-16](#figure5-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05015](image_fi/278748c05/f05015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-15: Underneath the main SoC, with the outlined areas all electrically
    connected together and to the VDD_CORE rail'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05016](image_fi/278748c05/f05016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-16: Each of the three VDD_CORE connections are broken out to wires
    to complete the glitch insertion.'
  prefs: []
  type: TYPE_NORMAL
- en: You might want to use a smaller wire, but this example shows how you can get
    away with using crude equipment. One warning is the wires will break off very
    easily; we covered the wires in hot melt glue to hold them in place. You could
    use something else (epoxy, for example), but hot melt glue has the advantage of
    being easily removable. We’ve also had success using just a needle (pogo pin)
    to connect the power, which means you don’t need to solder to the target board.
    The downside is you cannot as easily move the target around, so in this example
    we’ll continue with the soldered wire, which will be more robust. With the target
    prepared, let’s set up the glitch hardware next.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a Fault Using Crowbar Hardware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to attach a MOSFET across the VDD_CORE power rail to insert a glitch.
    [Figure 5-17](#figure5-17) shows the general setup, where the MOSFET is an N-Channel
    IRF7807\. The important part is that the MOSFET has a logic-level gate threshold,
    which means you can drive the MOSFET by any regular digital signal.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05017](image_fi/278748c05/f05017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-17: The MOSFET (left) shorts the VDD_CORE power rail'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the crowbar, we’ll need a method of triggering the MOSFET. [Listing
    5-1](#listing5-1) shows how to generate small pulses with an Arduino, so we can
    simply repurpose that. The pulse output from the Arduino GPIO pin is driven into
    the Trigger input shown in [Figure 5-17](#figure5-17). Alternatively, we can use
    a pulse generator to generate the small pulses or dedicated hardware, such as
    the ChipWhisperer-Lite or Riscure’s Inspector FI hardware. We’ll need to experiment
    with the width of the pulse, but we want it to range from around 100ns to 50μs.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we used the fact the ChipWhisperer-Lite has the MOSFET crowbar
    output on an SMA, and we simply placed it onto the VDD_CORE wire (see [Figure
    5-18](#figure5-18)), which effectively gives us the crowbar setup from [Figure
    5-17](#figure5-17), along with a programmable pulse generator.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05018](image_fi/278748c05/f05018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-18: The ChipWhisperer-Lite includes a MOSFET in the glitch (crowbar)
    output we can use to perform the attack. Note the hot glue kindergarten skills
    used to hold wires in place.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the VDD_CORE wires is routed to the center pin of the SMA connector,
    which connects to the MOSFET. You could make this look more official, but we wanted
    to show how even very simple setups can be successful. You’ll also note that we
    used a separate ground connection. In this example, the ground wire soldered to
    the backside of the PCB broke off before use (we mentioned they were fragile),
    so instead, we used a ground on the I/O header. We wanted the wires to be fairly
    short to minimize the parasitic effects of the wire length; longer wires (with
    larger inductance) will dampen the pulse we are attempting to insert. Shorter
    wires means we should be able to more closely control the width of the inserted
    pulse.
  prefs: []
  type: TYPE_NORMAL
- en: You can confirm your glitch hardware is working correctly if you are able to
    reset the Raspberry Pi. Inserting too long of a glitch should result in a reset
    of the device. If you don’t get a reset, it means you don’t have a powerful enough
    glitch (or a long enough glitch).
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Of course, the Raspberry Pi needs to be running a program for us to understand
    if a glitch actually occurs. We’re going to use the idea of our simple loop code
    from Listing 4-2 in Chapter 4, modified to add additional loops and remove triggers,
    as shown in [Listing 5-2](#listing5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: A double-loop example'
  prefs: []
  type: TYPE_NORMAL
- en: We add two `for` loops, thereby increasing the duration in which potentially
    glitchable instructions are executing. The two loops mean if we glitch out of
    the inner loop, the outer loop still runs again. Using two loops also means the
    target is jumping to slightly different locations, increasing our code’s vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Now we compile and run the program, making sure to turn optimizations off to
    avoid the compiler getting too smart about optimizing the code (use, for example,
    `-O0` for GCC or Clang compilers). We also added the `volatile` keyword to ensure
    the loops make it to the final binary.
  prefs: []
  type: TYPE_NORMAL
- en: While running the Pi, we generate small pulses to cause faults. [Figure 5-19](#figure5-19)
    shows the output of a fault session.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05019](image_fi/278748c05/f05019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-19: Results from a successful fault insertion'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-19](#figure5-19) shows various faults in the `cnt` variable’s value,
    which should be 100,000,000 under normal circumstances. Note also that the values
    for `i` and `j` at the end of the `for` loops aren’t affected in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we’re monitoring the output on an HDMI-connected monitor, so we
    can see that many other processes are running that we didn’t corrupt, which is
    mostly because the loop program takes the majority of the CPU time, but we can
    occasionally crash the system as well.
  prefs: []
  type: TYPE_NORMAL
- en: For the optimal parameters, first determine the shortest fault where the target
    consistently resets. This fault is too aggressive, but it provides an upper bound
    on the length. For the Raspberry Pi, resets are especially annoying due to the
    time it takes to reboot, so we’ll scale the length back from there.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t worry about synchronizing the fault, since the loop from [Listing 5-2](#listing5-2)
    will be the main task running. Most of the processor time will be spent in the
    loop to avoid needing to characterize the platform more carefully or deal with
    a trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Fault Injection Results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This example illustrates how glitching is capable of creating interesting faults,
    even on a fairly complex Linux target. The results of this attack will simply
    be faults in the loop counter values. [Figure 5-19](#figure5-19) showed an example
    of a successful attack that resulted from a 3.2 µs-wide pulse injected at arbitrary
    times in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-20](#figure5-20) shows the waveform for this glitch. The regular
    voltage is about 1.2 V and the crowbar injection drops it to 0.96 V.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05020](image_fi/278748c05/f05020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-20: The glitch waveform injected into a Raspberry Pi'
  prefs: []
  type: TYPE_NORMAL
- en: Releasing the crowbar causes a rapid spike up to 1.44 V and the resulting ringing
    on the power rail. We expect that this is responsible for the faulty behavior,
    rather than the reduced operating voltage. We used no other method than the crowbar
    to introduce this, but the complex power distribution networks of these boards
    tend to ring when poked this way. This ringing waveform also explains why we used
    such a wide input pulse. You’ll notice that the 3.2 µs pulse time reflects the
    gradual reduction in the power seen at the target, rather than a sudden drop out,
    which is related to the fact that we still have some inductance in the injection
    line and the capacitive power supply network will resist some change.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the long duration and the demo nature of the attack, we used software
    triggering and didn’t have specific hardware triggers to which we could synchronize
    our glitcher. See Colin’s YouTube video titled “Voltage (VCC) Glitching Raspberry
    Pi 3 model B+ with ChipWhisperer-Lite,” which shows it working on this Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage Fault Injection Search Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When switching between two voltages, we need to first determine the *base* *voltage*
    at which to run the target. At first we can use the voltage at which it normally
    runs. If we want to optimize a bit, however, we run the target on the highest
    voltage (for spikes) or lowest voltage (for dips) at which it still reliably operates.
    By adjusting the voltage up (if we will be spiking the voltage with our fault)
    or down (if we will be dipping the voltage with our fault), we decrease the amount
    of charge that the glitch needs to inject to induce a voltage that results in
    a fault.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the operation timing and base voltage right, you can start to
    tune the actual fault. If using the crowbar injection, as described earlier in
    the “Crowbar Injected Faults” section, you won’t have control over the glitch
    voltage, as the crowbar simply pulls to ground. However, if your injector allows
    you to control the glitch voltage, experiment to see what causes the device to
    fault. Progressively move out of operating range so as not to cause permanent
    damage. Positive spikes have a much higher chance of burning your target, so try
    voltage dips first. You can generate dips that go below 0 V for a short time to
    drain capacitances, but doing this for too long may also cause damage.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the voltage settings, you will, of course, have the parameters related
    to the glitch location. We discussed those in Chapter 4, as well as the relevant
    search strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Electromagnetic Fault Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Electromagnetic fault injection* uses a strong electromagnetic pulse to cause
    a fault. You can produce such faults in a variety of ways, but the easiest method
    is to pulse a strong current through a coil of wire. Electromagnetic injection
    is governed by Faraday’s law, which says that a changing magnetic field through
    a wire loop causes a voltage difference to appear across the loop terminals. The
    current spike through the coil generates such a changing magnetic field. The wires
    on a chip form the loop part. When the changing magnetic field hits the wires
    on the chip, we get voltage spikes that can temporarily cause signal levels to
    flip from 1 to 0, or vice versa. A convenient property of electromagnetic fault
    injection is that once you’ve built your setup, you don’t need to modify your
    targets; simply hold the probe over the chip and fire away.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, some fault injectors can generate a continuous electromagnetic
    field. These are more specifically used for biasing ring oscillators, which is
    done to reduce the entropy in a random number generator. See Jeroen Senden’s MSc
    thesis titled Biasing a Ring-Oscillator Based True Random Number Generator with
    an Electro-Magnetic Fault Injection Using Harmonic Waves” (University of Twente,
    2015) for more details on this.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-21](#figure5-21) shows an electromagnetic fault injector’s general
    structure, where the coil of wire generates a magnetic field that induces a flow
    of current and a voltage somewhere inside the chip being targeted. Per “Inducing
    Local Timing Fault Through EM Injection,” by Marjan Ghodrati et al., the result
    is a localized clock fault. The somewhat more interesting aspect is that you can
    carefully position the probe itself over the chip surface, meaning you can target
    a specific area of the chip. Even though the field may not be targeted as finely
    as you could with a laser beam, it does have more of a localized effect than either
    clock or voltage fault injection. You also don’t run the risk of burning yourself
    with acid, since decapsulation is not required, but you will be dealing with high
    voltages and currents, so avoid the temptation to lick the electromagnetic probe.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05021](image_fi/278748c05/f05021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-21: Electromagnetic pulses insert voltages into the target chip.'
  prefs: []
  type: TYPE_NORMAL
- en: Many packages have a heat spreader over top of the chip. While we’ve found you
    can still insert some fields through the thin spreader, it does drastically reduce
    the power delivered to the chip. Removing the heat spreader is helpful for many
    attacks, including EMFI, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Electromagnetic Faults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your budget determines whether you buy or build the coil and pulse generator.
    The coil of wire can take many forms. The easiest methods are to use off-the-shelf
    magnetic field probes or solid-core inductors. Some useful probe design references
    include “Magnetic Microprobe Design for EM Fault Attack” by Rachid Omarouayache
    et al. (EMC Europe, 2013) and “Electro Magnetic Fault Injection in Practice” by
    Rajesh Velegalati, Robert Van Spyk, and Jasper van Woudenberg (ICMC, 2013). Often
    the probes will be built out of an SMA connector, as the examples in [Figure 5-22](#figure5-22)
    show.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need a signal to feed into the probe. The required signal strength
    determines what equipment you’ll need. The most basic pulse is derived from the
    discharge of a capacitor across the probe coil. The objective is to achieve a
    very high rate of current change through the coil, so having fewer turns on the
    coil reduces the inductance resulting in a faster rise time.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05022](image_fi/278748c05/f05022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-22: Sample homebrew and commercial probes'
  prefs: []
  type: TYPE_NORMAL
- en: You can purchase commercial pulse generators, which have a wide range of voltage
    and current outputs. By adjusting the voltage and/or current of the pulse, you
    can adjust the type of effect that will be induced in the target device. Avtech,
    Riscure, NewAE Technology, and Keysight are all pulse generator (or EMFI tool)
    vendors. Typical voltages used for fault injection are 60–400 V and currents are
    0.5–20 A, and pulse lengths are on the order of tens of nanoseconds (and therefore
    power on the order of tens of microwatts; don’t worry about melting the probe
    tip).
  prefs: []
  type: TYPE_NORMAL
- en: One parameter that can be defined either by the pulse generator or the probe
    tip is the polarity of the pulse induced in the chip. You can change it by switching
    the polarity of the voltage pulse going into the probe or by reversing the direction
    of the probe coil. Either method reverses the magnetic field’s direction, thereby
    reversing the direction of the induced current. In some situations, you might
    not be able to change the polarity safely. For example, when using high voltages,
    you certainly want the exposed part of a metal connector to be at ground potential.
    In practice, the choice of pulse polarity is arbitrary; we will tend to test both
    on a specific device, as one polarity may work better on a specific device than
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, get the probe tip as close to the die as possible, without touching
    the die. As a rule of thumb, you want the distance to your target to be smaller
    than the loop diameter. If your loop diameter is 1 mm or so, you can just place
    it on top of the package. If the diameter is smaller than that, consider decapping
    the chip.
  prefs: []
  type: TYPE_NORMAL
- en: Architectures for Electromagnetic Fault Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Electromagnetic fault injector tools can use many architectures, and they are
    generally split into two main types: a direct drive of the injection coil and
    a coupled drive (see [Figure 5-23](#figure5-23)). The two electromagnetic fault
    injector tools on the left and center use a *direct*-*drive* architecture, and
    the electromagnetic fault injector tool on the right uses a *coupled drive* (here
    coupled with capacitor C1). In a direct-drive electromagnetic fault injector tool,
    a capacitor bank is directly switched onto the coil for a controlled length of
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05023](image_fi/278748c05/f05023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-23: EMFI tools'
  prefs: []
  type: TYPE_NORMAL
- en: The direct-drive architecture has the advantage of being relatively forgiving
    of the probe connected to the device. It does not require close matching of impedance
    or other considerations, since almost anything connected to the drive will be
    driven as rapidly as possible from the capacitor bank. On both of the direct-drive
    architectures, resistor R1 is used to limit current through the switching element
    (MOSFET) to avoid destruction if the output is shorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can subdivide the direct drive into either a *high-side* or *low-side*
    switching architecture. The advantage of low-side switching is that it’s simple
    to construct and achieve high performance; the major downside is that your output
    “tip” is always connected to the high voltage source, which is a dangerous situation.
    You can find an example of this architecture in the first open source EMFI tool,
    presented by Ang Cui and Rick Housley in their work “BADFET: Defeating Modern
    Secure Boot Using Second-Order Pulsed Electromagnetic Fault Injection” (WOOT ’17).'
  prefs: []
  type: TYPE_NORMAL
- en: A more complex but safer choice is to use high-side switching. With that option,
    the switching element must “ride the pulse,” which means when the switch closes,
    the control voltage must rapidly follow the pulse voltage. In the center example
    in [Figure 5-23](#figure5-23), the connection marked “Trigger In GND” is not at
    system ground potential; instead, it’s at the high side of the output coil (which
    is in the process of pulsing from 0 V to 400 V or so). Connecting a normal system
    ground (which is expected to be at 0 V) to the “Trigger In GND” requires additional
    circuitry to function, but it ensures that high voltages are present only during
    the pulse operation. The high-side switching arrangement is used by the ChipSHOUTER
    tool, and you can find more info on this construction in the ChipSHOUTER design
    details and schematic available from [www.chipshouter.com](http://www.chipshouter.com).
  prefs: []
  type: TYPE_NORMAL
- en: The coupled architecture shown on the right side of [Figure 5-23](#figure5-23)
    allows the simplicity of low-side drive, but uses a coupling (such as a transformer,
    inductor, or capacitor) to transfer the probe energy to ensure that the voltage
    is present only during the discharge event. The example in [Figure 5-23](#figure5-23)
    shows a capacitor C1 being used to couple the energy. If resistor R3 is chosen
    to be very small, you can connect the “Trigger In GND” to system ground, as in
    this example. The resistor R2 is used to develop the voltage across it when the
    MOSFET is turned on (closed), which will cause a changing voltage that is coupled
    through capacitor C1.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture may require tuning with different probes—for example, by changing
    the values of R4 and C1\. The presentation “Design Considerations for EM Pulse
    Fault Injection” by Arthur Beckers et al. (CARDIS 2019) provides a good overview
    of this architecture’s design. This architecture provides a trade-off between
    simplicity of design, effectiveness of pulse generation, and inherent safety by
    limiting the possible exposure to high voltage at the output (which cannot be
    as easily enclosed as the rest of the circuitry).
  prefs: []
  type: TYPE_NORMAL
- en: EMFI Pulse Shapes and Widths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What should a typical drive waveform look like? [Figure 5-24](#figure5-24) shows
    an example of such a waveform. The voltage goes into a coil where you can see
    it goes from 0 V to 400 V and back to 0 V.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we’re generating two pulses in a row. You might expect that only
    very short (narrow) pulses are relevant. If a CPU is running at 50 MHz, a single
    clock cycle is 20ns, so should you really insert wider pulses, like the 1,000ns
    pulse shown? When considering the pulse width, remember it is the *change* in
    magnetic flux that is inserting a fault. Thus, we’re primarily concerned with
    *edges*. The changing voltage of the edges is the only interesting times for the
    actual fault insertion. A very wide pulse means inducing a current at the rising
    edge and the opposite direction current at the falling edge.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05024](image_fi/278748c05/f05024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-24: An example of the drive waveform inserted into a coil for an EMFI
    attack'
  prefs: []
  type: TYPE_NORMAL
- en: Search Parameters for Electromagnetic Fault Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One major parameter in EMFI is the type of probe tip used as well as the tip’s
    construction, such as the number of windings, the type of core used, and the polarity
    of the field generated by the tip. In general, these parameters are harder to
    vary, as they are highly dependent on your specific physical hardware. Changing
    the parameters may mean building new physical tips, which isn’t as easy as just
    changing some Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the correct polarity that will generate your desired fault is, unfortunately,
    just a matter of luck. We’re not aware of any way to predict which is going to
    work better, but we’ve seen that one polarity can trigger different faults from
    what the other polarity triggers. As an example of the effect of polarity on a
    real device, see Colin O’Flynn’s “BAM BAM!! On Reliability of EMFI for in-situ
    Automotive ECU Attacks” (ESCAR EU, 2020), where one polarity was unsuccessful
    but the other polarity was highly successful on an ECU target.
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of the core construction itself, research suggests using a small
    number of loops (starting with just a single loop) with a sharpened ferrite core.
    A wet grinder (often used for knife sharpening) is perfect for shaping ferrite
    cores.
  prefs: []
  type: TYPE_NORMAL
- en: Electromagnetic fault injection is normally nondestructive, so you can start
    your *glitch power* (*glitch* *voltage* multiplied by *glitch current*) at 50
    percent of the maximum and then move up or down, depending on whether you get
    no results or too many crashes. You may not be able to configure the *glitch duration*,
    as it depends on the pulse generator. If you can configure it, however, starting
    with anything from 10–50ns is reasonable. As discussed earlier, very wide pulses
    may actually result in two pulses inserted into the target.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have some initial settings, remember to check your setup and use the
    search strategies discussed in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: Optical Fault Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chips consist of semiconductor material that typically is created using doped
    silicon and has the interesting property (for us hackers) that the conductivity
    of the gate changes when you light the gate up with a sufficient photon intensity.
    Strong light pulses turn out to have the ability to ionize the semiconductor region,
    which leads to a localized fault.
  prefs: []
  type: TYPE_NORMAL
- en: Humans have actually known about the effect of photons since we started putting
    ICs close to and into radiation-intense environments, such as outer space. All
    kinds of radiation produce the same effect as illuminating transistors with photons,
    such as radiating them with alpha particles, X-rays, and so on. Ask your buddy
    in avionics or space tech about *single event upsets*—basically, space itself
    is clumsily trying to inject faults on your chip. People doing failure analysis
    can simulate these kinds of effects by bombarding ICs with lasers. The nice thing
    about lasers is that they are a bit safer and more accessible to us than particle
    accelerators or X-ray machines. This means we can use them for injecting faults.
  prefs: []
  type: TYPE_NORMAL
- en: Chip Preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to access a chip with light, you must first remove part or all of the
    packaging in a process called *decapsulation* *(decapping)* or *depackaging* of
    the chip, as described in Chapter 1. For front-side access to the chip, simply
    decapsulate the top (assuming it is not a *flip-chip* device, as discussed in
    Chapter 3). [Figure 5-25](#figure5-25) shows an example of a decapsulated smart
    card chip.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05025](image_fi/278748c05/f05025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-25: Decapsulated publicly available smart card chip with bonding wires
    intact (source: Riscure)'
  prefs: []
  type: TYPE_NORMAL
- en: To decapsulate a device, we use acid (typically fuming nitric acid) to etch
    away the encapsulation chemically. The specific process you need to use changes
    for different packaging types. Therefore, exposing a silicon chip is part skill
    and part science. Be prepared to lose a few samples on the experimental path to
    developing a decapsulation technique, and be aware that decapping is dangerous
    to do outside the confines of a proper chemical lab. With some effort, it is possible;
    see the *International Journal of PoC || GTFO*, Issue 0x04, for some good hints
    on performing decapsulation at home.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to burn a hole in the package through which the chip can be seen,
    while ensuring that the bonding wires and the rest of the package remain intact
    so that you can use the chip in place on its original PCB. The chip’s packaging
    determines what parts of the chip you can access. You can decapsulate a BGA package
    only on one side, which normally exposes the front side of the chip; flip-chip
    packages provide access to the rear side of the chip instead. In cases where chip
    stacking happens in the manufacturing process, you may end up having access only
    to one of the chips in the package. Package-on-package encapsulation presents
    its own challenges. (See Chapter 3 for a discussion of some of these packages.)
  prefs: []
  type: TYPE_NORMAL
- en: When decapsulation is not an option, depackaging and rebonding may work. With
    this technique, you completely dissolve the package and destroy the bonding wires,
    leaving only the silicon chip. Once you extract the chip from the package, you
    can access its front and rear, but you need to reconnect the chip by rebonding.
    Chip preparation labs can rebond, or you can do it yourself (with some practice)
    if you have access to a wire-bonding machine.
  prefs: []
  type: TYPE_NORMAL
- en: Front-Side and Back-Side Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can perform light attacks from two directions: the front side of the chip
    or the back side of the chip (see [Figure 5-26](#figure5-26)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05026](image_fi/278748c05/f05026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-26: Laser attacks from both sides of a chip (credit: Riscure)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrows indicate the source of the laser beam. The front side of the chip
    has the metal layers that make up the wires connecting the gates. Older chips
    may have three metal layers, and modern ICs may have more than 10 layers. The
    silicon substrate is on the back side of the chip. The gates you want to target
    are sandwiched between the metal and the substrate, so you need to get the photons
    past those obstacles. The key to reaching this target is twofold: wavelength and
    power.'
  prefs: []
  type: TYPE_NORMAL
- en: On the front side of the chip shown in [Figure 5-26](#figure5-26), the metal
    will scatter your photons, and though the gaps between the wires are relatively
    small, they are big enough for photons to sneak through. A shorter wavelength
    helps them get through small gaps. The scattering between layers works like one
    of those old Bagatelle pinball games, where even though the marble is aimed through
    one place at the top, the area where it can land is spread out over a much wider
    area at the bottom. This makes the landing area wider than the size of the spot
    from which your light source emits. Wavelengths between roughly 400 nm and 900
    nm work well as the silicon in the targets easily absorbs them.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how many metal layers you need to bounce off, the frequency you
    choose, and the duration of the laser pulse, you’ll need up to a few watts of
    power. Overpowered diode lasers are nice because it’s easier to turn down the
    power than it is to turn it up. In lab situations, attenuated 445 nm/3 W and 808
    nm/14 W lasers for the front side are pulsed for anything from 20ns up to 1,000ns.
    Don’t let the high-power ratings discourage you. See Sergei P. Skorobogatov and
    Ross J. Anderson’s paper “Optical Fault Induction Attacks” (CHES 2002) for a discussion
    of successfully using a 650 nm/10 mW laser for fault injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: On the back side, you need to punch through the substrate, which is basically
    a thick (hundreds of micrometers) slab of silicon that your photons need to penetrate
    before they can have an effect. The dilemma here is that you’ll want to use a
    wavelength that isn’t absorbed by the silicon substrate, but one that is absorbed
    by the gates, which are also made of silicon!
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to use a wavelength at which silicon just becomes
    transparent to the laser beam. In the infrared range, 1,064 nm is a good choice,
    as it also can blast an enormous number of photons to have an effect on the gates.
    We’ve used 20 W diode lasers to do this, though that may be “slightly” overpowered.
    The substrate also will diffuse your photons, which increases the effective spot
    size; polishing and thinning the substrate are helpful if you have access to those
    kinds of polishing machines.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-27](#figure5-27) shows the penetration depth through various materials
    for different light wavelengths.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05027](image_fi/278748c05/f05027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-27: Penetration depths in silicon for various photon wavelengths'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that silicon is just on the verge of becoming transparent to the
    laser at 1,064 nm. The absorption coefficient begins to increase rapidly as the
    wavelength becomes shorter. Notice the change between 1,200nm (1.2μm) and 800nm
    (0.8μm), for example.
  prefs: []
  type: TYPE_NORMAL
- en: Light Sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When attempting to inject faults using photons, consider the following properties
    of light sources: time precision, space precision, wavelength, and intensity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a sufficient blast of photons on your chip using many methods;
    here are three:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a camera flashgun wrapped in tin foil with a pinhole through which the light
    exits on its way through a microscope to focus the beam. This is obviously a very
    cost-effective solution, though the precision in time and space is limited (also
    introduced in Skorobogatov and Anderson’s “Optical Fault Induction Attacks”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use laser cutters made for IC edits. Failure analysis labs typically have these
    devices, but they’re not within the average hacker’s budget. We mention them because
    they were used for fault injection before dedicated tools became available. (Note
    that these laser cutters are different from those for cutting wood or metals.)
    The beam intensity of these cutters is more than sufficient for fault injection.
    They are designed for making microscopic modification to chips by burning away
    parts. One downside is that when they are used for cutting, time precision is
    not a requirement, which severely restricts the ability to blast photons at the
    correct instant. Yagi-based laser cutters have jitter in the time between triggering
    the laser and the actual photon emissions, which means they offer inconsistent
    repeatability when used for fault injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use diode lasers. You can combine diode lasers with microscope optics to focus
    on a small spot or with optical fibers to guide a beam, as shown in [Figure 5-28](#figure5-28).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f05028](image_fi/278748c05/f05028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-28: Optical fiber laser fault injection (source: Riscure)'
  prefs: []
  type: TYPE_NORMAL
- en: This photo shows an optical fiber precisely positioned over a decapped smart
    card chip, targeting a diode laser into a specific area of the chip. You can combine
    the microscope and optical fibers with an XY machining table to position the laser,
    which produces small, intense spots and pulses with very little timing jitter.
  prefs: []
  type: TYPE_NORMAL
- en: You can extend optical fault injection to more advanced techniques beyond the
    scope of this book. For example, when dealing with highly protected chips, you
    can use multiple laser sources. If you have a chip with a CPU and a crypto accelerator,
    you sometimes can inject a fault in both cores by placing one laser spot over
    an area of the CPU and the other over an area of the crypto accelerator, and then
    hitting them both.
  prefs: []
  type: TYPE_NORMAL
- en: Optical Fault Injection Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of optical fault injection is that you can position the injected
    fault accurately by aiming the laser at a carefully selected part of the chip,
    which allows you to target small sections of functionality (for instance, a JTAG
    unlock circuit). Finding the right spot is tricky and requires some kind of XY
    positioning table to automate the search for a useful spot. You will need something
    with specs (that is, positioning resolution) that match your spot sizes, which
    can go down to 1 micron.
  prefs: []
  type: TYPE_NORMAL
- en: Next to an XY station, you need to choose one of the aforementioned light sources
    and optionally attach it to an optical microscope. Note that any microscope has
    a certain range of frequencies to which it is virtually transparent, so make sure
    it matches with the light source frequency.
  prefs: []
  type: TYPE_NORMAL
- en: The spot size is configurable using different magnifications on an optical microscope
    setup. You can decrease the effective spot size by lowering the light intensity,
    which decreases scattering. Ideally, the spot size should be around 1–50 microns
    in diameter. The smaller you make the spot, the higher the precision in targeting
    a specific area, but that also means you have to search the XY space for more
    spots. In general, we recommend starting with a larger size. If you end up getting
    only crashes and no interesting faults, you may be hitting too large of an area,
    so then try decreasing the spot size.
  prefs: []
  type: TYPE_NORMAL
- en: Optical Fault Injection Configurable Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first parameter to consider is a *target area* for the XY scan. You can
    do a little bit of optical reverse engineering of photos of your die to identify
    the different blocks. In our experience, avoiding memory cells can be a timesaver,
    though including memory decoders can be interesting. If you don’t want to restrict
    yourself, just scan the whole die.
  prefs: []
  type: TYPE_NORMAL
- en: Two parameters, the *light intensity* and the *duration*, configure the amount
    of energy you deliver. Too much energy means you will kill the chip. We have a
    tiny chip graveyard next to our setups, just as a reminder. For all light sources,
    you can control intensity by using filters that block light. For laser cutters,
    you can also change the intensity electronically, and for diode lasers, you can
    modulate both intensity and duration by modulating the power supply. For the duration,
    you typically aim for about the length of one clock cycle, but there is some wiggle
    room here. In our experiments, we’ve observed successful faults at the length
    of dozens of clock cycles (at lower intensities).
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part of the scan is that the amount of energy required to cause a
    fault varies for different parts of the chip, which means you need to combine
    optimizing the parameters with an XY scan. To avoid frying the chip, first do
    a run on such low energy that there are no faults or other observable effects.
    Try a light intensity of 1 percent to 10 percent of the maximum and a duration
    of 10–50ns, and start scanning over the chip in, for example, a 20×20 grid. If
    you see any behavior that’s irregular, terminate the experiment, reduce the settings,
    and repeat until you get no faults. Then start increasing the energy in small
    steps, each time performing a new scan over the chip. Once you start seeing interesting
    faults, you can start narrowing down the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When you do double-laser optical fault injection, you’ll double most of the
    parameters we just described, leading to a highly complex search space. There
    is no magic bullet here, and it’s just a matter of applying divide-and-conquer
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: Body Biasing Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Body biasing injection (BBI)* is a fault injection method that falls somewhere
    between electromagnetic fault injection and laser fault injection. It uses a physical
    needle placed on the backside of a die (see [Figure 5-29](#figure5-29)). A high
    voltage pulse is injected on the needle, which can be coupled to various internal
    nodes in the IC. Philippe Maurine introduced this method in his paper “Techniques
    for EM Fault Injection: Equipments and Experimental Results” (FDTC 2012).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05029](image_fi/278748c05/f05029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-29: Body biasing injection uses a needle on the die’s backside.'
  prefs: []
  type: TYPE_NORMAL
- en: The needle is a standard spring-loaded test point probe. In the case of [Figure
    5-29](#figure5-29), we cheat a little for the backside attack. The target device
    is a standard microcontroller that is available in a wafer-level chip-scale package
    (WLCSP). These WLCSP devices are effectively a slice of the silicon wafer with
    solder bumps added, designed for some of the smallest electronics. As an artifact
    of their construction, they often expose the backside of the device, so you don’t
    need to perform any work. A simple insulating cover may be present that is easy
    to scrape off, but it doesn’t require the acid decapsulation we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: To inject a fault, a relatively high-voltage pulse is inserted onto the needle
    that is touching the device backside. This high-voltage pulse is required, as
    there is no direct (low-resistance) connection between the backside and the internal
    nodes of the device. [Figure 5-30](#figure5-30) shows an example of a pulse.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05030](image_fi/278748c05/f05030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-30: Example pulse for input = 10 V, pulse = 680 ns width. BBI requires
    a high voltage like EMFI, but it has more limited peak currents than EMFI.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice the peak voltage of more than 150 V on the die’s backside. This
    higher voltage, however, translates to a small voltage at internal nodes in the
    ICs; therefore, we don’t “blow out” the IC. The peak current of 0.8 A in this
    case is much smaller than with EMFI, where we may have peak currents of 20 A or
    more in the coil.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to optical fault injection, and even compared to EMFI, the BBI technique
    is much lower cost. One architecture uses a simple step-up transformer, meaning
    it’s possible to build a working BBI probe for about $15 (see [Figure 5-31](#figure5-31)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05031](image_fi/278748c05/f05031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-31: This ChipJabber-BasicBBI probe can be assembled at a very low
    cost.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a step-up transformer (the messy winding to the right of center
    in [Figure 5-31](#figure5-31)) is driven with a simple MOSFET-based switch. By
    changing the input voltage, you can adjust the output voltage for the BBI. See
    [https://github.com/newaetech/chipjabber-basicbbi/](https://github.com/newaetech/chipjabber-basicbbi/)
    and the paper “Low-Cost Body Biasing Injection (BBI) Attacks on WLCSP Devices”
    by Colin O’Flynn (CARDIS, 2020) for full details of the schematic.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters for Body Biasing Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parameters for BBI are relatively basic. Besides the standard parameters,
    such as timing and physical location on the die surface, BBI adds the *pulse voltage*.
    We typically start very low (as close to 0 V as the power supply will go) and
    increase it until we see faults. Effective voltage may range from 10 V to 500
    V, depending on the device. The primary driver of the voltage requirements is
    the backside thickness. You can get a rough estimate by using a multimeter to
    measure from the die backside to a ground pin. If the resistance is around 20
    kΩ to 50 kΩ, you will need a very low voltage (10 V to 50 V). If the resistance
    is around 100 kΩ to 300 kΩ, you may need a higher voltage, such as 75 V to 200
    V. If the resistance is much higher (1 MΩ), the attack may be ineffective or require
    much higher voltages.
  prefs: []
  type: TYPE_NORMAL
- en: BBI can damage a device fairly easily. These higher-voltage pulses are being
    directly injected to the silicon and can more easily cause permanent faults in
    the device compared to electromagnetic fault injection. Starting at a low voltage
    and ramping up is a suggested search strategy to avoid damaging your device.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering Hardware Faults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve mentioned the trigger several times, with the assumption that some trigger
    event is easily accessible. In reality, the trigger event may be simple or complicated,
    but we are ultimately making a decision on what event precedes the operation of
    interest we want to fault.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements around triggering will have parallels to side-channel power
    analysis, which we describe in Chapter 9. The main difference between side-channel
    power analysis and fault injection as it relates to triggering is that with fault
    injection, we are actively manipulating the device execution, compared to power
    analysis, which is passively listening. Because power analysis is passively listening,
    we can find triggers in already recorded data, but with fault injection, we need
    a trigger that occurs during the device operation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common fault triggers on a microcontroller is the reset pin.
    When a device boots, it often performs several security-critical functions, such
    as checking the value of fuse bits, checking boot signatures, and so on. This
    routine tells us the starting point (when the reset becomes inactive so the device
    can run), but how long should we check from the trigger point? Some experimentation
    is required to determine that. You could write a program for your microcontroller
    that sets an I/O pin high as soon as the code starts. The time between the reset
    pin going inactive and your user I/O pin going high indicates when the device
    was performing startup code.
  prefs: []
  type: TYPE_NORMAL
- en: Some devices also include a reset input and reset output. These devices use
    the reset output to tell other devices in the system when the main microcontroller
    is up and running. This information can provide an even more reliable trigger,
    since the reset output may be actually set as part of that reset logic.
  prefs: []
  type: TYPE_NORMAL
- en: More complex triggers will often be based on certain I/O from the device, such
    as a serial message indicating the device is at a certain boot state. As an example,
    [Listing 5-3](#listing5-3) shows the boot messages from an Echo Dot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: Boot messages from an Echo Dot provide enough detail that we could
    target fault injection at various aspects.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s rare to have such detailed boot messages, but in this example, the serial
    port messages tell when certain functions, such as the RSA-2048 signature calculation,
    were successful. We would likely want to trigger a fault after the RSA-2048 calculation
    but before the PKCS#1 verification. If we simply want to validate that we can
    cause faults at all, that long 87ms RSA-2048 operation would be a perfect target.
    By corrupting the RSA-2048 calculation, we’d see the signature verification fail
    (since the RSA operation is not being performed correctly).
  prefs: []
  type: TYPE_NORMAL
- en: In general, you can often find useful timing information by comparing the device
    booting with known-good settings and with invalid settings. If you send an incorrect
    password to the device, does it lock up or turn on an error indicator? Logically,
    your fault’s location then must be sometime between when the device started processing
    and that lockup or error condition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll walk through some examples of how you can more concretely
    find these trigger points by looking at a few real-life examples.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unpredictable Target Timing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the countermeasures against fault injection, whether intentionally implemented
    or not, is having a nonconstant time between the trigger and the target operation.
    If this time is jittery, how can the attacker time the injection to hit a specific
    operation in the code sequence?
  prefs: []
  type: TYPE_NORMAL
- en: 'Timing jitter arises in several ways: by intentionally introducing random delays
    in the code, when a target running an operating system and a scheduler is regularly
    processing interrupts, or if the target is running on a jittery clock. Any of
    these cases will negatively impact the fault injection success rate, because the
    target operation will occur at unpredictable times. One way to compensate for
    such jitter is to use side-channel signals to synchronize your injector to your
    target. Using a power side channel means triggering on a waveform in the power
    measurement—often using FPGAs to do real-time triggering.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fault attacks provide a powerful means of introducing all sorts of unintended
    behavior into devices. While there might seem to be an overwhelming number of
    possibilities, a little experimentation can often result in a successful fault
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has outlined the kinds of effects that you can induce via fault
    injection, as well as some of the common methods—namely, clock fault injection,
    voltage fault injection, optical fault injection, EM fault injection, and body
    biasing injection. This should give you the background you need to understand
    and apply these attacks in your research.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, we’ll discuss side-channel power analysis, which may
    be used in tandem with fault injection. You can use side-channel power analysis
    to figure out what functions are being performed inside a device, which is a powerful
    tool for determining whether your faults are causing unintended effects, even
    when you can’t see any output from the target device.
  prefs: []
  type: TYPE_NORMAL
- en: Since you’ve made it this far, here’s a little fault injection gem that’s outside
    of the scope of the book but will have widespread applicability with all the embedded
    devices out there. If the classic stack-smashing buffer overflow payload is being
    stopped by a length check, just fault the buffer length check to regain that 1990s
    code injection feel. Have fun!
  prefs: []
  type: TYPE_NORMAL
