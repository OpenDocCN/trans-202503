- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: 'Don’t Lick the Probe: How to Inject Faults'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 别舔探针：如何注入故障
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Chips and devices are engineered to have an extremely low fault probability
    when operating within their normal ranges. Running chips outside their normal
    operating ranges, however, eventually causes faults to occur. For this reason,
    their running environments are often controlled: the power lines on a printed
    circuit board (PCB) have decoupling capacitors to buffer voltage spikes or dips,
    clock circuits are restricted to specific ranges, and fans keep temperatures in
    check. If you happen to be in space, beyond the protection of Earth’s atmosphere,
    you need radiation shielding and other fault-resistant circuitry to prevent faults
    from occurring.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片和设备在其正常范围内运行时，经过精心设计以确保极低的故障概率。然而，当芯片超出其正常工作范围时，最终会导致故障发生。为此，它们的运行环境通常会受到控制：印刷电路板（PCB）上的电源线配有去耦电容器以缓冲电压的尖峰或波动，时钟电路被限制在特定范围内，风扇用于保持温度控制。如果你恰好处于太空中，超出了地球大气层的保护，你需要辐射屏蔽和其他抗故障电路来防止故障发生。
- en: Though chips and their packaging resist most naturally occurring faults, they
    are typically not hardened against malicious attackers. Chips specifically made
    to resist attackers who have physical access to them, such as the secure microcontrollers
    found in some smart cards, are notable exceptions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管芯片及其封装能抵抗大多数自然发生的故障，但它们通常并没有针对恶意攻击者进行加固。专门用于抵御具有物理访问权限的攻击者的芯片，例如某些智能卡中找到的安全微控制器，是著名的例外。
- en: In this chapter, we describe different methods of injecting faults that are
    commonly used in fault-injection security testing and are accessible to a range
    of attackers. These methods include *voltage and clock* *fault injections*, *electromagnetic
    fault injection (EMFI)*, *optical fault injection*,and *body biasing injection*.
    For each technique, we’ll also cover some of the specific parameters you might
    need to search. (We discussed strategies for searching those parameters in Chapter
    4.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了在故障注入安全测试中常用的不同故障注入方法，这些方法可以被一系列攻击者访问。 这些方法包括*电压和时钟* *故障注入*、*电磁故障注入（EMFI）*、*光学故障注入*和*体偏置注入*。对于每种技术，我们还将讨论你可能需要搜索的一些具体参数。（我们在第4章中讨论了搜索这些参数的策略。）
- en: Many fault injection techniques were pioneered in the field of *failure analysis
    (FA)*, which studies chip failures in order to minimize failure rates during or
    after fabrication. Failure analysis engineers have great fault injection toys
    at their disposal, including scanning electron microscopes (SEMs), focused ion
    beams (FIBs), microprobing stations, radiation chambers, and more. We won’t discuss
    these instruments, as they are cost-prohibitive to most people, and attackers
    tend to use lower-budget tools if they can.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多故障注入技术最初源自*故障分析（FA）*领域，该领域研究芯片故障，以便在制造过程中或之后最小化故障率。故障分析工程师拥有非常强大的故障注入工具，包括扫描电子显微镜（SEM）、聚焦离子束（FIB）、微探针站、辐射室等。我们不会讨论这些仪器，因为它们对大多数人来说成本过高，而且攻击者通常会使用低成本的工具。
- en: Methods that generate more unpredictable faults are possible, too. For example,
    simply heating a chip or using a strong flashlight can cause faults—in some cases,
    successful faults. But because the time and space resolution are very poor with
    such methods, it’s hard to target a specific operation, so we cover many low-cost
    options for doing similar experiments that have a better degree of control.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能生成更多不可预测故障的方法。例如，简单地加热芯片或使用强光手电筒就能引发故障——在某些情况下，成功的故障。但由于这种方法的时间和空间分辨率非常差，因此很难针对特定操作进行攻击，所以我们介绍了许多低成本的选项，来进行类似的实验，这些方法有更好的控制度。
- en: Clock Fault Injection
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟故障注入
- en: '*Clock fault injection*, commonly referred to as *clock glitching*, aims to
    insert a rogue, too-narrow, or too-wide clock edge. We discussed clock glitching
    in Chapter 4 and introduced an example in Figure 4-2 of what a clock glitch looks
    like, but we haven’t yet explained why clock glitching works in detail.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*时钟故障注入*，通常称为*时钟故障*，旨在插入一个不正常的、过窄或过宽的时钟边缘。我们在第4章中讨论了时钟故障，并在图4-2中展示了时钟故障的示例，但我们尚未详细解释为什么时钟故障能够工作。'
- en: Let’s start with a bit of theory on digital circuits to explore how clock glitching
    works—specifically, *D flip-flops* and *combinatorial logic*. Consider the D(ata)
    flip-flop as 1-bit memory. It takes an *input data signal* *(D)* and *clock signal*
    *(CLK)* as input, and it has an *output data signal (Q)* as output. The output
    remains the same as its internal 1-bit memory throughout the clock cycle, except
    during a small period when the clock signal goes from low to high, which is the
    *positive clock edge*. At this edge, the flip-flop sets its memory to the value
    of D. A set of *n* flip-flops is also called an n*-bit register*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一点数字电路理论开始，探讨时钟毛刺是如何工作的——特别是 *D 触发器* 和 *组合逻辑*。考虑将 D（数据）触发器作为 1 位存储单元。它接受
    *输入数据信号*（*D*）和 *时钟信号*（*CLK*）作为输入，并输出 *输出数据信号（Q）*。在整个时钟周期内，输出保持与其内部 1 位存储器相同，只有在时钟信号从低电平跳变到高电平的短暂时间内，输出才会发生变化，这个时刻被称为
    *正向时钟边沿*。在这个边沿，触发器将其存储器设置为 D 的值。一组 *n* 个触发器也被称为 n*-位寄存器*。
- en: Combinatorial logic, which is the collection of wires and Boolean gates in a
    digital circuit, typically feeds the input and output to flip-flops. For example,
    combinatorial logic could implement an n*-bit ripple-carry adder (RCA)*, which
    is a circuit that calculates the sum of two *n*-bit input registers and stores
    the result in an (*n* + 1)–bit output register. An RCA is built from a series
    of 1-bit *full adders,* which are circuits that perform addition of two 1-bit
    inputs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 组合逻辑是数字电路中由导线和布尔门构成的集合，通常用于为触发器提供输入和输出。例如，组合逻辑可以实现一个 n*-位波纹进位加法器（RCA）*，这是一种电路，用于计算两个
    *n* 位输入寄存器的和，并将结果存储在一个（*n* + 1）位的输出寄存器中。RCA 是由一系列 1 位 *全加器* 构成的，全加器是用于执行两个 1 位输入加法运算的电路。
- en: '[Figure 5-1](#figure5-1) shows an example of a 4-bit counter: the register
    consists of a 4-bit register (four D flip-flops 1) and a 4-bit ripple-carry adder
    2 (constructed from four full adders 3). In the steady state before the clock
    ticks, the register’s output is fed to the RCA, which adds the number 1 to it
    and feeds the result of that addition to the register’s input. When the clock
    4 ticks, the register captures that input, and the register’s output changes.
    This changed output is fed to the RCA to calculate the next counter value, and
    so on.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](#figure5-1) 显示了一个 4 位计数器的示例：该寄存器由一个 4 位寄存器（四个 D 触发器 1）和一个 4 位波纹进位加法器
    2（由四个全加器 3 构成）组成。在时钟信号跳变前的稳态中，寄存器的输出会输入到 RCA 中，RCA 将其加上数字 1，并将加法结果反馈给寄存器的输入。当时钟信号
    4 跳变时，寄存器捕捉到这个输入，寄存器的输出发生变化。这个变化后的输出会输入到 RCA 中，用于计算下一个计数器值，依此类推。'
- en: '![f05001](image_fi/278748c05/f05001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/278748c05/f05001.png)'
- en: 'Figure 5-1: A circuit that increases a counter every clock tick'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：每个时钟跳变都会增加计数器的电路
- en: Let’s consider what happens when a positive clock edge hits the input register
    feeding into the RCA. The register’s memory and output changes to whatever value
    is input to them. As soon as the output changes, the signals start propagating
    through the RCA, which means they propagate through the full adders one by one.
    Finally, the signals reach the output register connected to the RCA. On the next
    positive clock edge, the output register’s state changes to the result of the
    RCA.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下当正向时钟边沿作用于输入寄存器时，会发生什么情况。寄存器的存储和输出会变化为其输入的值。输出一旦变化，信号就会开始通过 RCA 传播，这意味着它们会依次通过每个全加器。最终，信号会到达与
    RCA 相连接的输出寄存器。在下一个正向时钟边沿，输出寄存器的状态会更新为 RCA 的计算结果。
- en: The time it takes for the signals to travel from the input of a combinatorial
    circuit to the output is called the *propagation delay*. The propagation delay
    depends on many factors, including the number and types of gates in the circuit,
    the way the gates are connected, the data values at the input, but also the transistor
    feature size, temperature, and supply voltage. Each combinatorial circuit on a
    chip, therefore, has its own propagation delay. *Electronic design automation
    (EDA)* software can find the worst-case propagation delay for a circuit using
    *static timing analysis*. This worst-case propagation delay is the length of the
    *critical path*, which limits the operating ranges of the chip design. It’s specifically
    used to calculate the maximum clock frequency at which a circuit can run. Once
    a chip exceeds the maximum clock frequency, the input into the critical path will
    not have fully propagated into the output before the next clock edge, meaning
    that the output registers may memorize a value that is not the correct output
    of the circuit. (And, hey, that sounds a lot like a fault, doesn’t it?)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信号从组合电路输入传播到输出所需的时间称为*传播延迟*。传播延迟取决于多个因素，包括电路中的门数量和类型、门的连接方式、输入的数据值，还包括晶体管的特征尺寸、温度和电源电压。因此，每个芯片上的组合电路都有自己的传播延迟。*电子设计自动化（EDA）*软件可以通过*静态时序分析*来找到电路的最坏情况传播延迟。这个最坏情况的传播延迟就是*关键路径*的长度，限制了芯片设计的工作范围。它特别用于计算电路可以运行的最大时钟频率。一旦芯片超过最大时钟频率，关键路径的输入将在下一个时钟边缘到来之前没有完全传播到输出，这意味着输出寄存器可能记住一个不是电路正确输出的值。（嘿，这听起来像是故障，不是吗？）
- en: As it turns out, in order to function properly, flip-flops need a stable input
    during a small duration before and after the clock edge, respectively called the
    *setup time* and *hold time*. Unsurprisingly, a *setup time violation* occurs
    when data changes at a register input right before the clock edge, and a *hold
    time violation* occurs when data changes at a register input right after the clock
    edge. An attacker can cause these kinds of violations (thereby causing faults)
    by operating the device outside the specified ranges for clock frequency, supply
    voltage, and temperature.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，为了正常工作，触发器需要在时钟边缘前后分别保持一个稳定的输入，这段时间分别称为*建立时间*和*保持时间*。不足为奇的是，当数据在时钟边缘前改变时，会发生*建立时间违规*，而当数据在时钟边缘后改变时，则会发生*保持时间违规*。攻击者可以通过使设备在时钟频率、电源电压和温度的规定范围外工作，来引发这些违规（从而造成故障）。
- en: '[Figure 5-2](#figure5-2) shows a simple digital device containing two registers
    that hold a byte of data each.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](#figure5-2) 显示了一个简单的数字设备，包含两个寄存器，每个寄存器存储一个字节的数据。'
- en: '![f05002](image_fi/278748c05/f05002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](image_fi/278748c05/f05002.png)'
- en: 'Figure 5-2: A simple shift register working correctly'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：一个简单的移位寄存器正常工作
- en: Normally, each register holds a byte of data (the register consists of eight
    flip-flops), and the state of the bits making up the byte is moved between registers
    on a positive clock edge. After the first clock edge, the two registers hold the
    bytes 0xA2 and 0x9B. The next input byte, 0x17, is waiting at the left register,
    and 0xA2 waits at the right register. At the second clock edge, 0x17 moves into
    the left register. The right register reads the output of the left register, 0xA2,
    and after a short time, it appears at the right register output. Another data
    shift from left to right happens at the next clock edge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个寄存器保存一个字节的数据（该寄存器由八个触发器组成），组成字节的位的状态在正时钟边缘时在寄存器间移动。第一次时钟边缘后，两个寄存器分别保存字节0xA2和0x9B。下一个输入字节0x17在左侧寄存器等待，而0xA2在右侧寄存器等待。第二次时钟边缘时，0x17进入左侧寄存器。右侧寄存器读取左侧寄存器的输出0xA2，并在短时间后出现在右侧寄存器输出。下一个时钟边缘时，数据再次从左侧寄存器移动到右侧寄存器。
- en: '[Figure 5-3](#figure5-3) shows the same circuit operating with a faulty clock,
    in which we introduce a very short clock cycle.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-3](#figure5-3) 显示了相同电路在时钟故障下的运行情况，其中我们引入了一个非常短的时钟周期。'
- en: '![f05003](image_fi/278748c05/f05003.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f05003](image_fi/278748c05/f05003.png)'
- en: 'Figure 5-3: A simple shift register working incorrectly'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：一个简单的移位寄存器工作不正常
- en: In this example, after the first clock edge, the left and right registers hold
    bytes 0xA2 and 0x9B, respectively, which is the same starting state as in [Figure
    5-2](#figure5-2). As before, the next input byte, 0x17, is waiting, but now we
    have a short clock cycle interfering with the orderly process. The input byte,
    0x17, is still being copied to the left register, as was the case in the correctly
    functioning circuit. However, the short cycle has not allowed the output bus of
    the left register sufficient time to stabilize, so its output is somewhere in
    transition between 0xA2 and 0x17\. This means the right register is now in some
    unknown state, 0xXX, which it also sends to its output. On the next clock edge,
    the circuit continues to operate as normal, setting the value 0x17 onto the output
    data bus, but the data sequence in this case changes the value 0xA2 into something
    different, causing a fault in whatever program was executing!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在第一次时钟沿后，左侧和右侧寄存器分别保持字节0xA2和0x9B，这与[图 5-2](#figure5-2)中的起始状态相同。如之前所示，下一个输入字节0x17在等待，但现在有一个短时钟周期干扰了有序过程。输入字节0x17仍然被复制到左侧寄存器中，就像在正常工作电路中的情况一样。然而，短周期未能为左寄存器的输出总线提供足够的时间来稳定，因此其输出在0xA2和0x17之间的过渡状态。这意味着右侧寄存器现在处于某个未知状态0xXX，它也将其输出到外部总线。在下一个时钟沿，电路继续正常操作，将值0x17设置到输出数据总线上，但在这种情况下，数据序列将0xA2更改为其他值，从而导致执行的任何程序出现故障！
- en: Metastability
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 亚稳态
- en: Besides violating the critical path timing, violating the timing constraints
    has other effects. If data changes too closely to a clock edge, the flip-flop
    output enters a *metastable* state, which is typically represented as an invalid
    logic level that takes some time to reach the final value (see [Figure 5-4](#figure5-4)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了违反关键路径时序，违反时序约束还有其他影响。如果数据在时钟沿附近发生变化，翻转触发器的输出将进入*亚稳态*，这通常表现为一个无效的逻辑电平，需要一些时间才能达到最终值（参见[图
    5-4](#figure5-4)）。
- en: '![f05004](image_fi/278748c05/f05004.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f05004](image_fi/278748c05/f05004.png)'
- en: 'Figure 5-4: Flip-flop output in a metastable state'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：翻转触发器输出处于亚稳态
- en: What does this look like on a real device? We can use a field-programmable gate
    array (FPGA) to build a system that allows us to adjust the clock to cause these
    states to become more likely by slightly shifting the clock edge to fall before/after
    the data transition. In the example shown in [Figure 5-5](#figure5-5), the flip-flop’s
    output should alternate between 0 and 1 if no invalid states occurred.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际设备上，这看起来是什么样的？我们可以使用现场可编程门阵列（FPGA）来构建一个系统，使我们能够调整时钟，通过略微调整时钟沿使其在数据过渡前后产生这些更可能的状态。在[图
    5-5](#figure5-5)中所示的例子中，如果没有发生无效状态，翻转触发器的输出应该在0和1之间交替。
- en: '![f05005](image_fi/278748c05/f05005.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f05005](image_fi/278748c05/f05005.png)'
- en: 'Figure 5-5: A circuit that allows shifting a clock edge to cause metastability'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：一个允许通过移动时钟沿来引发亚稳态的电路
- en: '[Figure 5-6](#figure5-6) shows that indeed no invalid states are entered. We’re
    using an oscilloscope’s *persistence* mode to show the circuit operation. Many
    runs of the same operation are plotted on top of each other, and the intensity
    and color show the most likely “path.” In this case, the darker shade in [Figure
    5-6](#figure5-6) is most likely, and the lighter shade is least likely. The output
    is sometimes 1 and sometimes 0\. It always transitions, however, which means if
    it’s 0, it becomes 1, or vice versa, and both transitions (1 to 0 and 0 to 1)
    are equally likely, as expected.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-6](#figure5-6)显示了确实没有进入无效状态。我们使用示波器的*持久性*模式来展示电路操作。多次相同操作的运行被叠加在一起，强度和颜色显示最可能的“路径”。在这种情况下，[图
    5-6](#figure5-6)中的较深色调最可能，较浅色调最不可能。输出有时是1，有时是0。然而，它总是会发生过渡，这意味着如果是0，它会变成1，反之亦然，且两种过渡（从1到0和从0到1）是同样可能的，正如预期的那样。'
- en: '![f05006](image_fi/278748c05/f05006.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f05006](image_fi/278748c05/f05006.png)'
- en: 'Figure 5-6: Nominal operation'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：名义操作
- en: In [Figure 5-7](#figure5-7), we adjust the clock edge by changing the delay
    line to cause metastability. The flip-flop now takes a much longer time to reach
    a final value. The metastability means the final value is defined by random noise
    that pushes the flip-flop into a stable state. This means not only that the final
    value is random, but also that because the settling time is longer than expected,
    some circuitry may sample the metastable flip-flop in the initial state, and some
    may see the final state. For this example, we lowered the core voltage slightly
    to exaggerate the metastable settling time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5-7](#figure5-7) 中，我们通过改变延迟线来调整时钟边缘，以引起亚稳态。此时，触发器需要更长的时间才能达到最终值。亚稳态意味着最终值是由推动触发器进入稳定状态的随机噪声定义的。这不仅意味着最终值是随机的，还意味着由于稳定时间长于预期，某些电路可能会在初始状态下采样亚稳态触发器，而其他电路则可能看到最终状态。在这个例子中，我们略微降低了核心电压，以夸大亚稳态的稳定时间。
- en: '![f05007](image_fi/278748c05/f05007.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f05007](image_fi/278748c05/f05007.png)'
- en: 'Figure 5-7: Metastable data output from shifting the clock edge to cause timing
    violations (low-voltage operation)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：通过改变时钟边缘来引起时序违规的亚稳态数据输出（低电压操作）
- en: '[Figure 5-8](#figure5-8) shows the clock edge and output when run at normal
    voltages.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](#figure5-8) 显示了在正常电压下运行时的时钟边缘和输出。'
- en: '![f05008](image_fi/278748c05/f05008.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f05008](image_fi/278748c05/f05008.png)'
- en: 'Figure 5-8: Metastable data output from shifting the clock edge to cause timing
    violations (normal voltage operation)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8：通过改变时钟边缘来引起时序违规的亚稳态数据输出（正常电压操作）
- en: The slightly longer metastable state is still present, but note that the lack
    of transition does sometimes still happen, which demonstrates that violating setup
    and hold times will propagate invalid logic states.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 略长的亚稳态仍然存在，但请注意，缺乏过渡有时仍会发生，这证明了违反建立时间和保持时间将传播无效的逻辑状态。
- en: Fault Sensitivity Analysis
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障敏感性分析
- en: Propagation delays depend, among other things, on the data values present, which
    means faults caused by violating setup and hold time issues may depend on the
    data values. *Fault sensitivity analysis* exploits this behavior; the idea is
    that you overclock a device to the point where only certain data values cause
    faults. Say 0xFF causes a fault when the device is overclocked and other values
    do not, so if you get a fault, you know a value was 0xFF. After some characterization,
    you can learn what those data values were by detecting whether there was a fault.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 传播延迟依赖于多种因素，包括数据值，这意味着由于违反建立时间和保持时间而导致的故障可能依赖于数据值。*故障敏感性分析*利用了这一行为；其思想是将设备超频，直到只有特定的数据值会引发故障。比如，当设备被超频时，0xFF
    会导致故障，而其他值则不会，因此，如果你遇到故障，就知道值是 0xFF。经过一些特性测试后，你可以通过检测是否有故障来了解那些数据值是什么。
- en: Limitations
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: One limitation of clock glitching is that it requires a device using an external
    clock input. When looking at a typical device’s datasheet, you might find it has
    an internal clock generator. A dead giveaway on a small embedded device is that
    it has no external crystal or clock generator, pointing to the probable use of
    an internal generator. This means you can’t feed an external clock into the device,
    and without control over the clock, there is no clock faulting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟故障的一个限制是，它要求设备使用外部时钟输入。当查看典型设备的数据手册时，你可能会发现它有一个内部时钟发生器。小型嵌入式设备的一个明显特征是没有外部晶体或时钟发生器，这意味着它可能使用内部发生器。这意味着你不能将外部时钟输入到设备中，而没有对时钟的控制，就无法进行时钟故障。
- en: Even if the datasheet shows an external crystal, something like a *phase-locked
    loop* *(PLL)* might modify it internally. An indication of this is when the external
    crystal frequency is lower than the expected device operating frequency. The crystal
    on a Raspberry Pi is 19.2 MHz, but the operating frequency of the main CPU can
    be several hundred MHz. This is because that external clock is multiplied up to
    a much higher internal level by the PLL, which is also the case for almost all
    System-on-Chip (SoC)devices, such as cell phones. Even many low-cost and low-power
    devices have PLLs. You can still use clock faults to attack devices with a PLL,
    but the effectiveness is lower due to the way PLLs work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据手册显示了外部晶体，类似于*相位锁定环*（*PLL*）的东西也可能在内部修改它。这种情况的一个指示是，当外部晶体的频率低于预期的设备工作频率时。树莓派上的晶体是
    19.2 MHz，但主 CPU 的工作频率可以达到几百 MHz。这是因为该外部时钟通过 PLL 被倍增到更高的内部频率，这对于几乎所有的系统芯片（SoC）设备来说都是一样的，比如手机。即使是许多低成本、低功耗的设备也有
    PLL。你仍然可以使用时钟故障来攻击带有 PLL 的设备，但由于 PLL 的工作方式，其有效性较低。
- en: 'If you are interested in seeing the effectiveness of clock fault injection
    with a PLL, see “Peak Clock: Fault Injection into PLL-Based Systems via Clock
    Manipulation” by Bodo Selmke, Florian Hauschild, and Johannes Obermaier (presented
    at ASHES 2019).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你对查看带有 PLL 的时钟故障注入的有效性感兴趣，可以参考 Bodo Selmke、Florian Hauschild 和 Johannes Obermaier
    的《Peak Clock: Fault Injection into PLL-Based Systems via Clock Manipulation》（发表于
    ASHES 2019）。'
- en: Required Hardware
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所需硬件
- en: In Chapter 4, we introduced a simple method of generating clock glitches by
    switching between two different clock frequencies. Another method is to insert
    small pulses (glitches) into a single-source clock with an FPGA, which allows
    you to use two phase-shifted clocks XOR’d together (see [Figure 5-9](#figure5-9)),
    so they can generate a faulty clock easily.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们介绍了一种通过在两种不同的时钟频率之间切换来生成时钟故障的简单方法。另一种方法是使用 FPGA 向单一源时钟插入小脉冲（故障），这使得你可以使用两个相位移的时钟进行异或运算（见
    [图 5-9](#figure5-9)），从而轻松生成故障时钟。
- en: '![f05009](image_fi/278748c05/f05009.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![f05009](image_fi/278748c05/f05009.png)'
- en: 'Figure 5-9: Generating clock faults using an FPGA'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：使用 FPGA 生成时钟故障
- en: Almost every FPGA provides clock blocks that are capable of performing the required
    phase adjustment logic. For example, the ChipWhisperer project implements such
    clock faulting on a Xilinx Spartan-6 FPGA.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 FPGA 都提供能够执行所需相位调整逻辑的时钟模块。例如，ChipWhisperer 项目在 Xilinx Spartan-6 FPGA 上实现了这样的时钟故障。
- en: We can use an XOR method to generate a faulty clock, as in this example. The
    phase shifts are implemented via clock control blocks present inside most FPGAs.
    In [Figure 5-9](#figure5-9), the source (input) clock’s objective 1 is to end
    up with the “faulty” clock 2. To do this, the input clock is phase-shifted (delayed)
    by the first block to give us clock 3. This clock is again phase-shifted to give
    us clock 4. Using a logic AND with one input inverted, we are able to get a pulse
    that is the width set by the second phase shift, which is offset from the edge
    of the original clock by the delay inserted by the first phase shift 5. This “fault
    stream” contains an endless stream of pulses, so we can choose to siphon off only
    a few pulses using an AND gate to give us our glitch 6. Finally, we insert this
    glitch into the original clock using an XOR to provide us with the final clock
    2. The smallest phase shifts that the FPGA can perform and the minimum logic gates’
    switching speeds limit this approach.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用异或方法来生成故障时钟，如本例所示。相位移是通过大多数 FPGA 内部的时钟控制模块来实现的。在 [图 5-9](#figure5-9) 中，源（输入）时钟的目标
    1 是最终得到“故障”时钟 2。为此，输入时钟首先通过第一个模块进行相位移（延迟），得到时钟 3。这个时钟再次进行相位移，得到时钟 4。通过逻辑与运算并反转其中一个输入，我们能够得到一个脉冲，其宽度由第二个相位移设置，并且相对于原始时钟的边缘，由第一个相位移插入的延迟偏移
    5。这个“故障流”包含无尽的脉冲流，因此我们可以选择通过与门仅抽取几个脉冲，得到我们的故障 6。最后，我们使用异或将这个故障插入原始时钟，生成最终的时钟 2。FPGA
    可以执行的最小相位移和最小逻辑门切换速度限制了这种方法的可行性。
- en: Another option is to use analog delay lines where variable resistors (or variable
    capacitors) can fine-tune the delay (see [Figure 5-10](#figure5-10)), which performs
    the same operation we achieved with an FPGA.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用模拟延迟线，其中可变电阻（或可变电容）可以微调延迟（见 [图 5-10](#figure5-10)），这实现了我们通过 FPGA 实现的相同操作。
- en: '![f05010](image_fi/278748c05/f05010.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![f05010](image_fi/278748c05/f05010.png)'
- en: 'Figure 5-10: Generating clock glitches using analog delay lines'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-10：使用模拟延迟线生成时钟故障
- en: '[Figure 5-10](#figure5-10) shows the use of resistor-capacitor (RC) blocks,
    which take the place of the phase-shift elements shown in [Figure 5-9](#figure5-9).
    You can use standalone logic chips to build the entirety of that circuit by selecting
    the appropriate chips depending on the logic levels required (for example, 3.3
    V or 5.0 V). We suggest using multiturn trimmer pots if you want to use a variable
    resistor. You can use an Arduino to trigger the *Glitch Enable* pin, which switches
    between the regular clock and the glitchy clock (see the “Voltage Fault Injection”
    section later in the chapter or jump ahead to [Listing 5-1](#listing5-1) for a
    code example).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-10](#figure5-10)展示了使用电阻-电容（RC）模块，这些模块取代了[图5-9](#figure5-9)中展示的相位移元件。你可以使用独立的逻辑芯片，通过选择适合所需逻辑电平的芯片（例如3.3
    V或5.0 V），来构建整个电路。如果你想使用可变电阻，我们建议使用多圈调节电位器。你可以使用Arduino触发*故障使能*引脚，这个引脚在常规时钟和故障时钟之间切换（可以参考本章后面的“电压故障注入”部分，或者跳到[代码示例5-1](#listing5-1)查看代码示例）。'
- en: When it comes to high-speed designs, “logic level” has many different meanings
    beyond even the levels you might have come across, such as 3.3 V and 5.0 V. Clocks
    will commonly use a type of signaling called *low-voltage differential signaling
    (LVDS)*, where two wires conduct signals of opposite phase, meaning that while
    one wire goes high, the other goes low. These signal levels are also much smaller;
    the typical voltage difference (swing) between low and high may be only 0.35 V,
    and this swing will be around some common level voltage. By “common level,” we
    mean it doesn’t go to 0 V (low), but instead some level below a fixed voltage.
    If the common level was 1.65 V (half of 3.3 V), the signal may swing from 1.3
    V to 2.0 V to switch from low to high (in this case, a 0.7 V swing).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在高速设计中，“逻辑电平”有着多种不同的含义，超出了你可能遇到的3.3 V和5.0 V等电平。时钟通常使用一种叫做*低压差分信号传输（LVDS）*的信号方式，其中两根线传输相反相位的信号，也就是说，当一根线变高时，另一根线则变低。这些信号电平通常也要小得多；低电平与高电平之间的典型电压差（波动）可能只有0.35
    V，并且这种波动会围绕某个共同电平电压进行。“共同电平”指的是电压不会降到0 V（低电平），而是低于某个固定电压的一定电平。例如，如果共同电平是1.65 V（即3.3
    V的一半），信号的波动范围可能是从1.3 V到2.0 V，表示从低电平到高电平的切换（在这种情况下，波动幅度为0.7 V）。
- en: The physical logic levels don’t affect the idea of clock glitching, but they
    may require additional physical effort from you. The FPGA output drivers will
    typically support some of these high-speed logic levels, for example, but you’ll
    need to understand what your target device is expecting in order to drive the
    glitch into the device properly. You may also require an LVDS driver chip or similar
    to generate an effective clock glitch.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 物理逻辑电平不会影响时钟故障的概念，但可能需要你付出额外的物理努力。FPGA输出驱动器通常会支持一些这些高速逻辑电平，但你需要理解目标设备的要求，以便将故障信号正确地注入到设备中。你可能还需要一个LVDS驱动芯片或类似设备来产生有效的时钟故障。
- en: 'An easier way to insert a clock glitch is to have two clocks: one regular clock
    and one very fast clock. In Chapter 4, we briefly alluded to the fact that by
    temporarily switching to the fast clock, you can cause a fault. The length of
    the overclock will depend on the switching speed between the two clocks. In principle,
    you could do this with an Arduino or an FPGA, though the former has a slow switching
    speed. This clock-switching method is not only simple to implement, but you also
    can use it for almost any clock speed with a suitable switch. You can glitch an
    8 MHz clock or a 1 GHz clock with this method.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 插入时钟故障的一个更简单方法是使用两个时钟：一个常规时钟和一个非常快速的时钟。在第4章中，我们简要提到过，通过暂时切换到快速时钟，可以引发故障。超频的时长将取决于两个时钟之间的切换速度。从原理上讲，你可以使用Arduino或FPGA来实现，尽管前者的切换速度较慢。这种时钟切换方法不仅易于实现，而且只要有合适的开关，你几乎可以用它来处理任何时钟频率。你可以使用这种方法插入8
    MHz时钟或1 GHz时钟的故障。
- en: You can also generate clock glitches with a suitably fast development board
    by toggling an I/O pin. For example, if you have a device running at 100 MHz,
    you could be generating a 5 MHz clock in “software” by setting an I/O pin low
    for 10 cycles then high for 10 cycles. You can insert glitches by simply toggling
    the I/O pin for a single cycle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过切换I/O引脚来生成时钟故障，只要开发板足够快。例如，如果你的设备以100 MHz运行，你可以通过在“软件”中设置I/O引脚为低电平10个周期，再设置为高电平10个周期，来生成5
    MHz的时钟。通过简单地切换I/O引脚一个周期，你就可以插入故障。
- en: Clock Fault Injection Parameters
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟故障注入参数
- en: 'We’ve introduced two variants of clock fault injection: temporary overclocking
    (refer to Figure 4-8) and inserting a glitch into a clock (refer to [Figure 5-9](#figure5-9)).
    If you want to keep it simple, the temporary overclocking is easier to construct,
    but if you’re able, we recommend building the clock glitch insertion circuit,
    as it can generate more variations of glitches. We discussed the wait cycles,
    glitch cycles, overclock frequency, glitch offset, and glitch widthparameters
    in Chapter 4.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了两种时钟故障注入的变体：临时超频（参见图4-8）和将毛刺插入到时钟信号中（参见[图5-9](#figure5-9)）。如果你想简化操作，临时超频更容易构建，但如果可能的话，我们推荐构建时钟毛刺插入电路，因为它可以生成更多种类的毛刺。我们在第4章讨论了等待周期、毛刺周期、超频频率、毛刺偏移和毛刺宽度等参数。
- en: Voltage Fault Injection
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电压故障注入
- en: 'We perform voltage fault injection by tampering with the supply voltage to
    a chip (for instance, by temporarily depriving it of power). Two main views exist
    on how voltage fault injection works: the timing view and the threshold view.
    The *threshold view* simply states that by changing the voltage on a circuit,
    the voltage threshold for a logical 0 and 1 changes, effectively changing data.
    The *timing view* leverages the fact that a relation exists between the voltage
    over a circuit and the frequencies at which it runs stably without faults. As
    mentioned earlier, a flip-flop needs a stable input for some time before and after
    a clock edge in order to capture the input value correctly. As it turns out, turning
    up the voltage on a chip decreases the propagation delay, which means the signals
    change faster and can cause hold time violations, as signals may change before
    the hold time is over. On the other hand, dropping the voltage can cause setup
    time violations, as signals may still be changing too closely to the next clock
    edge. A short glitch (a drop or spike in the supply voltage) can affect correct
    operation. The voltage on the circuit needs to be changed only when switching
    occurs in the relevant transistors. This duration is much smaller than a clock
    cycle, and therefore it’s easily sub-nanosecond on modern devices. Such a very
    short voltage change is what we are ideally aiming for when doing voltage fault
    injection.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过干扰芯片的电源电压来执行电压故障注入（例如，暂时切断电源）。关于电压故障注入的工作原理，存在两种主要观点：时序视图和阈值视图。*阈值视图*简单地指出，通过改变电路上的电压，可以改变逻辑0和1的电压阈值，从而有效地改变数据。*时序视图*利用了电压与电路稳定运行频率之间的关系，这些频率能够在没有故障的情况下稳定运行。如前所述，触发器在时钟边沿前后需要稳定的输入一段时间，以便正确捕捉输入值。事实证明，提高芯片上的电压会降低传播延迟，这意味着信号变化更快，可能会导致保持时间违规，因为信号可能会在保持时间结束前发生变化。另一方面，降低电压则可能导致设置时间违规，因为信号可能会与下一个时钟边沿的时间太接近。一个短暂的毛刺（电源电压的下降或尖峰）也可能影响正确操作。电路上的电压变化只需要在相关晶体管切换时发生，这个持续时间远小于一个时钟周期，因此在现代设备上通常是亚纳秒级的。这样的非常短暂的电压变化就是我们在进行电压故障注入时理想的目标。
- en: However, the voltage change we speak of is right at the supply to the transistor
    itself, deep inside the chip. The *power supply network*, which routes power through
    a chip, is between a transistor and the chip’s external power supply. This network
    affects the shape of a glitch, because on-chip capacitance and inductance filter
    out any fast spikes and dips. Therefore, any glitch on the supply to the chip
    needs to be long enough so that after it has worked its way down to the transistors,
    it will be the shape that actually is able to affect the parts of the circuit
    we are interested in. The *clock network* routes the clock to all relevant gates.
    Both the clock and power supply networks reach all of the chip, so a voltage glitch
    can cause faults in many transistors at the same time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们所说的电压变化是直接作用于晶体管本身的电源供应端，位于芯片内部。*电源网络*负责将电力传输到芯片内，它位于晶体管与芯片外部电源之间。这个网络会影响毛刺的形状，因为芯片内部的电容和电感会滤除任何快速的尖峰和波动。因此，任何电压毛刺必须足够长，以便它能够传递到晶体管并形成能够真正影响我们关注的电路部分的形状。*时钟网络*负责将时钟信号传递到所有相关的门电路。时钟和电源网络覆盖整个芯片，因此电压毛刺可能会同时影响多个晶体管，导致故障。
- en: Furthermore, between a device’s power source and the power supply to a chip,
    many decoupling capacitors are aimed at reducing any dips and spikes caused by
    a switching power supply and noise picked up on the PCB from other components.
    This array of capacitors causes chips to operate with a very small probability
    of faults when operated within normal conditions. Of course, they also affect
    the dips and spikes that we intentionally want to inject when doing fault injection.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在设备的电源和芯片的电源之间，许多去耦电容器旨在减少由开关电源引起的电压下陷和尖峰，以及从PCB上的其他元件拾取的噪声。这些电容器的阵列使得芯片在正常条件下运行时，发生故障的概率非常小。当然，它们也会影响我们在进行故障注入时故意想要注入的下陷和尖峰。
- en: Generating Voltage Glitches
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成电压故障
- en: The fault injection principle is to operate a chip outside its normal conditions
    at the time when it is of interest to do so. With voltage fault injection, the
    goal is to create a stable power supply for the chip, except at the moment of
    a significant operation when it should be dropped or spiked to outside the normal
    operating voltage range.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入的原理是在芯片处于感兴趣的时刻，将其置于正常工作条件之外进行操作。对于电压故障注入，目标是为芯片创建一个稳定的电源，除了在某些重要操作时，需要将其电压降低或突增，超出正常工作电压范围。
- en: 'You can consider three main methods of generating the appropriate voltage glitch.
    The first is to use a programmable signal generator, where the signal generator
    output goes through a voltage buffer to power the target device. The second method
    is to switch between two power supplies: the regular operating voltage and the
    “glitch” voltage. Finally, the crowbar method simply shorts the supplied operating
    voltage.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑三种生成适当电压故障的方法。第一种是使用可编程信号发生器，其中信号发生器的输出通过电压缓冲器为目标设备供电。第二种方法是在两个电源之间切换：常规工作电压和“故障”电压。最后，短路法则简单地将供电的工作电压短接。
- en: Building a Switching-Based Injector
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建基于开关的注入器
- en: If you are generating a voltage excursion, you’ll need some form of programmable
    power supply or waveform generator. Typical programmable power supplies can’t
    switch voltages fast enough, and typical waveform generators don’t output sufficient
    power to drive a target. (The goal is < 1ms glitches, often in the range of 40–1,000ns.
    Commercial fault injectors go as low as 2ns.) The objective is to generate a waveform
    as shown in [Figure 5-11](#figure5-11), which has the standard baseline voltage,
    and then insert a glitch at some lower or higher voltage.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在生成电压波动，你将需要某种形式的可编程电源或波形发生器。典型的可编程电源无法快速切换电压，而典型的波形发生器输出的功率不足以驱动目标设备。（目标是<
    1ms的故障，通常在40–1,000ns范围内。商用故障注入器可低至2ns。）目标是生成一个如[图5-11](#figure5-11)所示的波形，该波形具有标准基线电压，然后在某个更低或更高的电压下插入一个故障。
- en: '![f05011](image_fi/278748c05/f05011.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![f05011](image_fi/278748c05/f05011.png)'
- en: 'Figure 5-11: Voltage fault injection waveform'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-11：电压故障注入波形
- en: This particular waveform was generated from a circuit based on Chris Gerlinsky’s
    presentation “Breaking Code Read Protection on the NXP LPC-Family Microcontrollers”
    (REcon Brussels 2017). Gerlinsky outlines the design for a glitcher using the
    MAX4619 analog switch, which has a 10–20 Ω on-resistance (depending on supply
    voltage). The “on-resistance” is the effective resistance in the switch; 10 or
    20 Ω will limit how much current you can push through to the target. Gerlinsky
    put several of the channels in parallel to generate an even more powerful fault
    injection platform.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定波形是从基于Chris Gerlinsky在“破解NXP LPC系列微控制器的代码读取保护”（REcon布鲁塞尔2017）演讲中的电路生成的。Gerlinsky概述了使用MAX4619模拟开关的故障注入器设计，该开关具有10–20
    Ω的导通电阻（取决于供电电压）。导通电阻是开关中的有效电阻；10或20 Ω会限制你能推动到目标的电流量。Gerlinsky将多个通道并联，以生成一个更强大的故障注入平台。
- en: '[Figure 5-12](#figure5-12) shows the MAX4619 with the same parallel circuitry
    to generate a multiplexor. The VCC can be 3.3 V or 5 V; using the higher voltage
    (5 V) means you have more flexibility on the input voltages and a lower on-resistance.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-12](#figure5-12)展示了MAX4619与相同的并联电路生成一个多路复用器。VCC可以是3.3V或5V；使用更高电压（5V）意味着你在输入电压上有更多的灵活性，并且导通电阻更低。'
- en: '![f05012](image_fi/278748c05/f05012.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![f05012](image_fi/278748c05/f05012.png)'
- en: 'Figure 5-12: Voltage-switching circuit'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-12：电压开关电路
- en: This circuit requires an external source to provide the signal that triggers
    the switch between the regular operating voltage (normal voltage in) and the glitch
    voltage (glitch voltage in). An embedded platform, such as an Arduino, can easily
    generate the switching signal. [Listing 5-1](#listing5-1) shows the code, which
    works on the classic ATmega328P-based Arduinos (Arduino Uno and similar).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该电路需要一个外部信号源来触发开关操作，切换常规工作电压（正常电压输入）和故障电压（故障电压输入）之间。像Arduino这样的嵌入式平台可以轻松生成切换信号。[列表5-1](#listing5-1)展示了代码，适用于经典的基于ATmega328P的Arduino（Arduino
    Uno及类似产品）。
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: Arduino code for generating a quick pulse'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-1：用于生成快速脉冲的Arduino代码
- en: This code generates pulses of three different durations by using a delay routine
    that isn’t very accurate and the CPU execution speed as a timing source. You can
    easily add buttons or other interfaces to send pulses of other durations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码通过使用一个不太精确的延迟例程和CPU执行速度作为定时源，生成三种不同时长的脉冲。你可以轻松添加按钮或其他接口来发送其他时长的脉冲。
- en: You can use several other devices as the multiplexor. One option is to use two
    separate complementary switch chips rather than one integrated device, such as
    the TS12A4515P and TS12A4514P. These switch chips are also available in a breadboard-friendly
    DIP package and have one “normally closed” and one “normally open” switch. The
    advantage of separate packages may be that more power dissipation is possible,
    for example. Other versions have dual-input power supplies, allowing you to pass
    negative voltages for more complex glitch options.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其他几种设备作为多路复用器。一个选择是使用两个独立的互补开关芯片，而不是一个集成设备，例如TS12A4515P和TS12A4514P。这些开关芯片也有面包板友好的DIP封装，并且具有一个“常闭”和一个“常开”开关。使用独立封装的优点可能是可以提供更多的功耗，例如。其他版本还配有双输入电源，允许你传递负电压以实现更复杂的故障选项。
- en: These multiplexors still have reasonably high on-resistance. Targeting a device
    drawing only 1 mA to 100 mA may work, for example, so you could target a simple
    standalone microcontroller. But if you are interested in a higher-power device
    or even a complete system, you won’t be able to use this simple voltage fault
    injection method because the multiplexor may overheat.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多路复用器仍然具有相对较高的开关电阻。例如，针对仅需1 mA到100 mA电流的设备可能是可行的，因此你可以针对一个简单的独立微控制器。但如果你对更高功率的设备或甚至是一个完整的系统感兴趣，就无法使用这种简单的电压故障注入方法，因为多路复用器可能会过热。
- en: Target Preparation for the Switching Glitch Generator
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 切换故障生成器的目标准备
- en: Once you have the voltage-generation hardware, you can prepare the target. The
    goal is to make the power supply run a single power plane by disconnecting the
    standard power supply and connecting yours. The difficulty of this operation can
    range widely, mainly because a PCB has to be modified manually. Surface-mounted
    microcontrollers on a single-sided PCB with only one power plane will be easy
    to modify, whereas modifying multi-power-plane SoCs using ball grid array (BGA)
    connections will be difficult. Assuming you do not have a BGA PCB rework station,
    we focus on manual modifications using standard tools, such as a soldering iron
    and scalpels.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了电压生成硬件，就可以准备目标。目标是通过断开标准电源并连接你自己的电源，使电源运行单一电源平面。这个操作的难度范围很广，主要是因为需要手动修改PCB。单面PCB上的表面贴装微控制器，只有一个电源平面，容易修改；而修改使用球栅阵列（BGA）连接的多电源平面SoC则较为困难。假设你没有BGA
    PCB返修站，我们将重点关注使用标准工具（如烙铁和手术刀）进行手动修改。
- en: 'Follow these steps to connect the injector:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤连接注入器：
- en: Choose the power plane to target. A microcontroller typically has only one,
    but for more sophisticated embedded chips, multiple power planes power different
    parts of the chip. Target the specific plane that powers the operation you are
    interested in faulting.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要针对的电源平面。微控制器通常只有一个电源平面，但对于更复杂的嵌入式芯片，多个电源平面为芯片的不同部分供电。选择供电你感兴趣的故障操作的特定平面。
- en: There is no single way to determine the correct power plane, but some target
    study can help. Look for “VCC” or “VCORE” in datasheets/pinouts and PCB markings.
    Alternatively, measure the voltage over different pins on the chip and match those
    with known core voltages. You’ll need to know the normal voltage in any case in
    order to drive the chip later.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有单一的方法来确定正确的电源平面，但一些目标研究可以帮助你。查看数据手册/引脚图和PCB标记中的“VCC”或“VCORE”。或者，测量芯片不同引脚上的电压，并将其与已知的核心电压进行匹配。无论如何，你需要知道正常电压，以便稍后驱动芯片。
- en: Find a point on the PCB where you can disconnect the standard power supply from
    the PCB circuitry and feed in your own. To decrease the effects of capacitance
    and inductance, find a location on the PCB that is as physically close as possible
    to the target, keeping in mind that one power plane may feed into multiple pins
    on the chip package. When you disconnect the standard power supply, disconnect
    the entire power plane and then drive that plane with your injector. PCB designs,
    pinouts, and/or tracing PCB lines will help you identify a point. A voltage regulator
    or power management IC feeds a power plane, which is where you can cut the supply.
    Alternatively, you can remove inline components, such as resistors or inductors.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个在 PCB 上可以断开标准电源与电路连接的点，并注入你自己的电源。为了减少电容和电感的影响，找到一个尽可能接近目标的位置，记住一个电源平面可能会连接到芯片封装上的多个引脚。当你断开标准电源时，要断开整个电源平面，然后用注入器驱动该平面。PCB
    设计、引脚分配和/或追踪 PCB 连线会帮助你找到这个点。电压调节器或电源管理 IC 供电的电源平面就是你可以切断电源的地方。或者，你也可以拆除串联组件，例如电阻或电感。
- en: In the case of targets that actively monitor and manage their power supply (complex
    SoC with power management ICs being a typical example), once you completely disconnect
    the power, the monitoring circuit will note this and possibly prevent the chip
    from completing its boot sequence or even from starting up again. Make sure the
    monitoring circuit is intact or bypassed in such a way that the voltage it sees
    is not at all interrupted. Doing this depends on how the circuit is implemented
    and requires knowledge of the electronics involved.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于那些主动监控并管理电源的目标（复杂的 SoC 和电源管理 IC 是典型的例子），一旦完全断开电源，监控电路将检测到这一点，并可能阻止芯片完成启动过程，甚至无法重新启动。确保监控电路完好无损或以某种方式绕过，使其看到的电压不会被中断。这样做取决于电路的实现方式，需要对涉及的电子元件有一定了解。
- en: Use a scalpel to sever the PCB track carefully and disconnect the existing power
    supply. Double-check that you have indeed disconnected it by measuring whether
    the connection is no longer present. When you are sure it’s disconnected, solder
    the output of the injector to the power plane. Use short wires to avoid adding
    too much inductance. Use the cut as a point to power the circuit or solder a wire
    onto a (removed) decoupling capacitor pad that is on the power plane close to
    the chip.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用手术刀小心地切断 PCB 路径并断开现有电源。通过测量连接是否不存在，仔细确认你确实已经断开电源。当你确认已经断开后，将注入器的输出焊接到电源平面。使用短线以避免增加过多的电感。使用切割点为电路供电，或者将电线焊接到靠近芯片的（已拆除的）解耦电容焊盘上。
- en: To get a nice clean fault into the chip, remove as much capacitance from the
    PCB as possible by desoldering the decoupling capacitors. These are often tiny
    capacitors inserted between VCC and GND to reduce noise on the power supply and
    actually avoid accidental faults in the field.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将故障注入到芯片中，尽可能通过拆除解耦电容来减少 PCB 上的电容。这些电容通常是小型电容，插入在 VCC 和 GND 之间，用于减少电源上的噪声，实际上还可以避免现场发生意外故障。
- en: One approach is to desolder them one by one, until you’ve either removed them
    all or until the chip stops working. In the latter case, put the last capacitor
    you removed back in and hope for the best. Usually, the chip will start working
    again. You may be able to inject faults without removing capacitance, but be prepared
    to accept a lower success rate.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种方法是逐个拆除这些电容，直到你拆除了所有电容，或者直到芯片停止工作。后一种情况下，将最后拆除的电容重新焊回去，希望能有好的结果。通常，芯片会重新开始工作。你可能能在不拆除电容的情况下注入故障，但要准备接受较低的成功率。
- en: Before moving on, check whether you actually can boot the device and run it
    normally when powered by your power supply. If it doesn’t run, recheck and debug
    every step you took, knowing that you may brick the device. You now should have
    a target that is run from your stable power supply and over which you have control.
    Once you reach this point, let your fault experiments commence (like the examples
    in Chapter 4).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，检查在使用你的电源供电时，设备是否能够启动并正常运行。如果无法启动，重新检查并调试每一步，知道你可能会使设备变砖。现在，你应该已经有了一个由稳定电源供电并可以控制的目标。一旦达到这个点，就可以开始进行故障实验（像第4章中的示例）。
- en: Crowbar Injected Faults
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超压注入故障
- en: As an alternative to the controlled voltage glitch, the crowbar method employs
    more force and gives less control but is easier to implement. Whereas the previous
    hardware allowed careful control over the normal and fault operating voltage,
    the crowbar method instead briefly shorts the regular operating voltage to 0 V.
    The crowbar is simply a “dead short” applied across one of the device’s power
    supplies. This must be done with care, as you can damage the power supply’s circuitry
    if the glitch is too long, bearing in mind that these supplies may not include
    short-circuit protection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为控制电压故障的替代方法，短路法（crowbar）使用更大的力量，控制性较差，但更容易实现。与先前的硬件允许对正常和故障工作电压进行精确控制不同，短路法是通过短暂地将正常工作电压短接到0
    V来实现的。短路法实际上是将一个“死短”应用于设备的电源供应之一。这必须小心进行，因为如果故障持续时间过长，可能会损坏电源电路，特别是考虑到这些电源可能没有短路保护。
- en: The short circuits cause ringing in the power distribution circuit, which are
    in effect large spikes. The nature of the glitch depends on the specifics of the
    board and is hard for an attacker to control. This method was introduced in Colin
    O’Flynn’s paper “Fault Injection Using Crowbars on Embedded Systems” (IACR Cryptology
    ePrint Archive, 2017).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 短路会在电源分配电路中引起振铃，这实际上是大幅的电压尖峰。故障的性质取决于板子的具体情况，并且对于攻击者来说很难控制。此方法在Colin O’Flynn的论文《使用短路器在嵌入式系统中进行故障注入》（IACR
    Cryptology ePrint Archive, 2017）中进行了介绍。
- en: Selecting a Crowbar
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择短路器
- en: The crowbar itself can be a MOSFET device; a MOSFET is simply a transistor.
    The specific MOSFET will depend on the device you are attacking. If your device
    has strong power supplies or large decoupling capacitors that you’re unable to
    remove, you need a high-power MOSFET. A high-power MOSFET has slower switching
    times compared to a lower-power MOSFET, so using a high-power MOSFET imposes minimum
    limits on the duration of the glitch.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 短路器本身可以是一个MOSFET器件；MOSFET本质上是一种晶体管。具体选择哪种MOSFET将取决于你攻击的设备。如果你的设备有强大的电源或大容量的去耦电容，且你无法将其移除，你需要一个高功率MOSFET。与低功率MOSFET相比，高功率MOSFET的开关时间较慢，因此使用高功率MOSFET会对故障持续时间施加最小限制。
- en: Examples of two such MOSFETs are the DMN2056U for the low-power device and the
    IRF7807 for the high-power device. Both are logic-level MOSFETs (meaning a signal
    generator or Arduino can easily drive them), but the IRF7807 has much lower on-resistance,
    which is necessary when attempting to drag down the power rails and generate a
    fault in a higher-power device such as a Raspberry Pi.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 两个此类MOSFET的例子是低功耗设备的DMN2056U和高功耗设备的IRF7807。它们都是逻辑电平MOSFET（意味着信号发生器或Arduino可以轻松驱动它们），但IRF7807具有更低的导通电阻，在试图拖低电源轨并在高功耗设备（如Raspberry
    Pi）中产生故障时非常必要。
- en: Better results are found using logic-level drive MOSFETs, which can be fully
    turned on by a 3.3 V signal. Standard MOSFETs require a higher voltage (5 V to
    10 V) to be switched on, which means you won’t get as strong a crowbar effect
    if you drive them only from a 3.3 V signal. Appropriate MOSFETs are mostly available
    in surface mount format; through-hole MOSFETs are typically too slow.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑电平驱动的MOSFET可以获得更好的效果，因为它们可以通过3.3 V信号完全开启。标准MOSFET需要更高的电压（5 V至10 V）才能开启，这意味着如果只用3.3
    V信号驱动它们，你将无法获得强大的短路效应。合适的MOSFET通常以表面贴装的形式提供；穿孔式MOSFET通常速度过慢。
- en: 'You can drive the gate of the MOSFET via any suitable signal source: a laboratory
    waveform generator, an FPGA board, or an Arduino. You can use the same code from
    [Listing 5-1](#listing5-1) to trigger the MOSFET for a programmable period of
    time.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过任何合适的信号源来驱动MOSFET的栅极：如实验室波形发生器、FPGA开发板或Arduino。你可以使用[清单5-1](#listing5-1)中的相同代码来触发MOSFET，在可编程的时间内产生故障。
- en: Target Preparation for Crowbar Glitch Generator
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 短路故障发生器的目标准备
- en: Compared to the controlled voltage fault, the crowbar injection method requires
    considerably less target preparation. You need only to identify an appropriate
    power plane, and you don’t need to disconnect that plane from the rest of the
    circuit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与控制电压故障相比，短路注入方法需要的目标准备工作要少得多。你只需要确定一个合适的电源平面，并且无需将该电源平面与电路的其他部分断开连接。
- en: Determining the sensitive power rail is much the same as in the controlled voltage
    fault. You might consult a device datasheet to determine to what voltages the
    various power pins are connected. See Chapter 3 for details of where to find such
    information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确定敏感电源轨与控制电压故障的过程非常相似。你可能需要查阅设备的数据手册，以确定各个电源引脚连接的电压值。有关此类信息的详细内容，请参见第3章。
- en: Attach the crowbar across the decoupling capacitors for the device. These capacitors
    will almost always have a very low impedance path to the power pin. Since the
    capacitors are simple two-terminal devices, it’s also fairly simple to make this
    connection physically. One end of the decoupling capacitor very often is connected
    to the ground line of the power rail, making it possible to solder the crowbar
    device directly across the decoupling capacitor. Let’s look at a quick example
    of this with a Raspberry Pi 3 Model B+.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将撬棍连接到设备的去耦电容器上。这些电容器几乎总是与电源引脚之间有一个非常低的阻抗路径。由于电容器是简单的双端元件，因此将其物理连接起来也相对简单。去耦电容器的一端通常连接到电源轨的地线，这使得可以将撬棍设备直接焊接到去耦电容器上。让我们通过一个树莓派
    3 Model B+ 的快速示例来看一下。
- en: Raspberry Pi Fault Attack with a Crowbar
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树莓派故障攻击与撬棍
- en: The Raspberry Pi foundation doesn’t publish full schematics for the more recent
    Raspberry Pi devices. For instance, the schematic for the Raspberry Pi 3 Model
    B+ is limited and doesn’t show the full pinout of the main SoC. It does have some
    information about the power rails (see [Figure 5-13](#figure5-13)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派基金会没有发布最近款树莓派设备的完整原理图。例如，树莓派 3 Model B+ 的原理图是有限的，并未显示主 SoC 的完整引脚图。它确实包含一些关于电源轨的信息（见
    [图 5-13](#figure5-13)）。
- en: '![f05013](image_fi/278748c05/f05013.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![f05013](image_fi/278748c05/f05013.png)'
- en: 'Figure 5-13: Part of the Raspberry Pi 3 Model B+ schematic, with main power
    regulator on the left (licensed under a Creative Commons Attribution-NoDerivatives
    4.0 International [CC BY-ND] license)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-13：树莓派 3 Model B+ 原理图的一部分，主电源调节器位于左侧（根据 Creative Commons Attribution-NoDerivatives
    4.0 国际 [CC BY-ND] 许可协议授权）
- en: 'In most cases, you’ll want something like the “Microprocessor Unit” or “Core”
    voltage power rail. Inspecting the schematic reveals the following labels: 3V3A,
    3V3, 1V8, DDR_1V2, VDD_CORE, and a few others. In the case of the Raspberry Pi
    3 Model B+, the VDD_CORE looks like the winner. But we want to insert the fault
    much closer to the main SoC, not right at the power regulator. You’ll notice from
    [Figure 5-13](#figure5-13) that pin 19 of the power regulator chip connects to
    VDD_CORE. Let’s look at that chip (see [Figure 5-14](#figure5-14)).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您会需要类似“微处理器单元”或“核心”电压电源轨的东西。检查原理图会发现以下标签：3V3A、3V3、1V8、DDR_1V2、VDD_CORE
    等等。在树莓派 3 Model B+ 的情况下，VDD_CORE 看起来是最合适的。然而，我们希望将故障插入得更接近主 SoC，而不是直接在电源调节器处。您会注意到从
    [图 5-13](#figure5-13) 可以看到，电源调节器芯片的第 19 引脚连接到 VDD_CORE。让我们看看那颗芯片（见 [图 5-14](#figure5-14)）。
- en: '![f05014](image_fi/278748c05/f05014.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![f05014](image_fi/278748c05/f05014.png)'
- en: 'Figure 5-14: Part of the Raspberry Pi 3 Model B+ showing the main SoC (2) and
    power IC (1)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-14：树莓派 3 Model B+ 的一部分，显示了主 SoC（2）和电源 IC（1）
- en: The connection to pin 19 is shown as 1 in [Figure 5-14](#figure5-14). The main
    SoC is nearby at 2, but it’s far enough that inserting glitches at the output
    of the power regulator chip won’t be too effective. Luckily, we can use a multimeter
    to find a 0 Ω (direct short) from the VDD_CORE output and locations underneath
    the main SoC. [Figure 5-15](#figure5-15) shows the view underneath the SoC.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-14](#figure5-14) 中显示了连接到第 19 引脚的部分，标记为 1。主 SoC 位于附近，标记为 2，但它距离足够远，以至于在电源调节器芯片输出端插入故障并不会太有效。幸运的是，我们可以使用万用表找到
    VDD_CORE 输出与主 SoC 下方位置之间的 0 Ω（直接短路）。[图 5-15](#figure5-15) 显示了 SoC 下方的视图。'
- en: The three outlined sections in [Figure 5-15](#figure5-15) all show direct shorts
    to each other and to the VDD_CORE rail. The voltage is around 1.2 V if we measure
    it at power-on. An important note is that we might have multiple rails of a similar
    voltage; the DDR voltage is also 1.2 V, but a different rail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-15](#figure5-15) 中的三个勾画部分都显示了它们彼此之间以及与 VDD_CORE 轨之间的直接短路。如果我们在上电时测量，电压大约是
    1.2 V。需要注意的是，我们可能会有多个相似电压的轨道；例如，DDR 电压也是 1.2 V，但属于不同的轨道。'
- en: Each of the outlined sections of VDD_CORE in [Figure 5-15](#figure5-15) may
    go to different pins on the SoC. For example, this is a quad-core device that
    might have other accelerators on board too. Thus, we expect the package might
    expose different power pins that are all on the VDD_CORE rail. We may need to
    try inserting faults into each one of those three groups. For now, we’ll solder
    wires to each of those groups, as shown in [Figure 5-16](#figure5-16).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-15](#figure5-15) 中 VDD_CORE 的每个勾画部分可能连接到 SoC 的不同引脚。例如，这是一个四核设备，可能还搭载了其他加速器。因此，我们预计该芯片可能暴露出不同的电源引脚，这些引脚都在
    VDD_CORE 轨上。我们可能需要尝试向这三组中的每一组插入故障。目前，我们将像 [图 5-16](#figure5-16) 中所示的那样，将电线焊接到每一组。'
- en: '![f05015](image_fi/278748c05/f05015.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![f05015](image_fi/278748c05/f05015.png)'
- en: 'Figure 5-15: Underneath the main SoC, with the outlined areas all electrically
    connected together and to the VDD_CORE rail'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![f05016](image_fi/278748c05/f05016.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-16: Each of the three VDD_CORE connections are broken out to wires
    to complete the glitch insertion.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: You might want to use a smaller wire, but this example shows how you can get
    away with using crude equipment. One warning is the wires will break off very
    easily; we covered the wires in hot melt glue to hold them in place. You could
    use something else (epoxy, for example), but hot melt glue has the advantage of
    being easily removable. We’ve also had success using just a needle (pogo pin)
    to connect the power, which means you don’t need to solder to the target board.
    The downside is you cannot as easily move the target around, so in this example
    we’ll continue with the soldered wire, which will be more robust. With the target
    prepared, let’s set up the glitch hardware next.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a Fault Using Crowbar Hardware
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to attach a MOSFET across the VDD_CORE power rail to insert a glitch.
    [Figure 5-17](#figure5-17) shows the general setup, where the MOSFET is an N-Channel
    IRF7807\. The important part is that the MOSFET has a logic-level gate threshold,
    which means you can drive the MOSFET by any regular digital signal.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![f05017](image_fi/278748c05/f05017.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-17: The MOSFET (left) shorts the VDD_CORE power rail'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Besides the crowbar, we’ll need a method of triggering the MOSFET. [Listing
    5-1](#listing5-1) shows how to generate small pulses with an Arduino, so we can
    simply repurpose that. The pulse output from the Arduino GPIO pin is driven into
    the Trigger input shown in [Figure 5-17](#figure5-17). Alternatively, we can use
    a pulse generator to generate the small pulses or dedicated hardware, such as
    the ChipWhisperer-Lite or Riscure’s Inspector FI hardware. We’ll need to experiment
    with the width of the pulse, but we want it to range from around 100ns to 50μs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we used the fact the ChipWhisperer-Lite has the MOSFET crowbar
    output on an SMA, and we simply placed it onto the VDD_CORE wire (see [Figure
    5-18](#figure5-18)), which effectively gives us the crowbar setup from [Figure
    5-17](#figure5-17), along with a programmable pulse generator.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![f05018](image_fi/278748c05/f05018.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-18: The ChipWhisperer-Lite includes a MOSFET in the glitch (crowbar)
    output we can use to perform the attack. Note the hot glue kindergarten skills
    used to hold wires in place.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: One of the VDD_CORE wires is routed to the center pin of the SMA connector,
    which connects to the MOSFET. You could make this look more official, but we wanted
    to show how even very simple setups can be successful. You’ll also note that we
    used a separate ground connection. In this example, the ground wire soldered to
    the backside of the PCB broke off before use (we mentioned they were fragile),
    so instead, we used a ground on the I/O header. We wanted the wires to be fairly
    short to minimize the parasitic effects of the wire length; longer wires (with
    larger inductance) will dampen the pulse we are attempting to insert. Shorter
    wires means we should be able to more closely control the width of the inserted
    pulse.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一条VDD_CORE电源线连接到SMA连接器的中央引脚，该引脚与MOSFET相连。你可以使这个连接看起来更正式，但我们想展示即使是非常简单的设置也能成功。你还会注意到我们使用了单独的接地连接。在本示例中，焊接在PCB背面的接地线在使用前断裂了（我们提到过它们很脆弱），因此我们改为使用I/O头上的接地。我们希望电线尽量短，以减少电线长度的寄生效应；较长的电线（具有较大的电感）会削弱我们试图插入的脉冲。较短的电线意味着我们应该能够更精确地控制插入脉冲的宽度。
- en: You can confirm your glitch hardware is working correctly if you are able to
    reset the Raspberry Pi. Inserting too long of a glitch should result in a reset
    of the device. If you don’t get a reset, it means you don’t have a powerful enough
    glitch (or a long enough glitch).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能重置树莓派，说明你的故障硬件工作正常。插入过长的故障应该导致设备重启。如果没有重启，说明故障不够强大（或不够长）。
- en: Raspberry Pi Code
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 树莓派代码
- en: Of course, the Raspberry Pi needs to be running a program for us to understand
    if a glitch actually occurs. We’re going to use the idea of our simple loop code
    from Listing 4-2 in Chapter 4, modified to add additional loops and remove triggers,
    as shown in [Listing 5-2](#listing5-2).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，树莓派需要运行一个程序，才能让我们了解故障是否发生。我们将使用第4章[清单4-2](#listing4-2)中的简单循环代码思路，并进行修改，增加额外的循环并移除触发器，如[清单5-2](#listing5-2)所示。
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: A double-loop example'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-2：一个双循环示例
- en: We add two `for` loops, thereby increasing the duration in which potentially
    glitchable instructions are executing. The two loops mean if we glitch out of
    the inner loop, the outer loop still runs again. Using two loops also means the
    target is jumping to slightly different locations, increasing our code’s vulnerability.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个`for`循环，从而增加了潜在故障指令执行的时长。这两个循环意味着，如果我们在内循环中发生故障，外循环仍然会继续运行。使用两个循环还意味着目标会跳转到稍微不同的位置，增加了我们代码的脆弱性。
- en: Now we compile and run the program, making sure to turn optimizations off to
    avoid the compiler getting too smart about optimizing the code (use, for example,
    `-O0` for GCC or Clang compilers). We also added the `volatile` keyword to ensure
    the loops make it to the final binary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编译并运行程序，确保关闭优化选项，以避免编译器过于智能地优化代码（例如，使用`-O0`选项对于GCC或Clang编译器）。我们还添加了`volatile`关键字，以确保循环能够进入最终的二进制文件。
- en: While running the Pi, we generate small pulses to cause faults. [Figure 5-19](#figure5-19)
    shows the output of a fault session.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Pi时，我们生成小的脉冲来引发故障。[图5-19](#figure5-19)显示了故障会话的输出。
- en: '![f05019](image_fi/278748c05/f05019.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f05019](image_fi/278748c05/f05019.png)'
- en: 'Figure 5-19: Results from a successful fault insertion'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-19：成功故障插入的结果
- en: '[Figure 5-19](#figure5-19) shows various faults in the `cnt` variable’s value,
    which should be 100,000,000 under normal circumstances. Note also that the values
    for `i` and `j` at the end of the `for` loops aren’t affected in this example.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-19](#figure5-19)显示了`cnt`变量值的各种故障，在正常情况下，`cnt`值应为100,000,000。还要注意，`for`循环结束时`i`和`j`的值在本示例中未受到影响。'
- en: In this case, we’re monitoring the output on an HDMI-connected monitor, so we
    can see that many other processes are running that we didn’t corrupt, which is
    mostly because the loop program takes the majority of the CPU time, but we can
    occasionally crash the system as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在HDMI连接的显示器上监控输出，因此我们可以看到许多其他进程正在运行，而我们并没有破坏它们，这主要是因为循环程序占用了大部分CPU时间，但我们也偶尔会使系统崩溃。
- en: For the optimal parameters, first determine the shortest fault where the target
    consistently resets. This fault is too aggressive, but it provides an upper bound
    on the length. For the Raspberry Pi, resets are especially annoying due to the
    time it takes to reboot, so we’ll scale the length back from there.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最优参数，首先确定目标持续重启时的最短故障。这种故障过于激进，但它为故障时长提供了上限。对于树莓派来说，重启的时间尤为烦人，因此我们会从这个上限缩短故障时长。
- en: We don’t worry about synchronizing the fault, since the loop from [Listing 5-2](#listing5-2)
    will be the main task running. Most of the processor time will be spent in the
    loop to avoid needing to characterize the platform more carefully or deal with
    a trigger.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要担心同步故障，因为来自[Listing 5-2](#listing5-2)的循环将是主要执行任务。大部分处理器时间将花费在循环中，从而避免需要更仔细地表征平台或处理触发器。
- en: Fault Injection Results
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障注入结果
- en: This example illustrates how glitching is capable of creating interesting faults,
    even on a fairly complex Linux target. The results of this attack will simply
    be faults in the loop counter values. [Figure 5-19](#figure5-19) showed an example
    of a successful attack that resulted from a 3.2 µs-wide pulse injected at arbitrary
    times in the loop.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了故障注入如何能够在相当复杂的Linux目标上产生有趣的故障。此次攻击的结果将仅仅是循环计数器值的故障。[图5-19](#figure5-19)展示了一个成功攻击的例子，结果是在循环中的任意时刻注入一个3.2微秒宽的脉冲。
- en: '[Figure 5-20](#figure5-20) shows the waveform for this glitch. The regular
    voltage is about 1.2 V and the crowbar injection drops it to 0.96 V.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-20](#figure5-20)展示了这种故障的波形。正常电压大约是1.2V，而短路注入将其降至0.96V。'
- en: '![f05020](image_fi/278748c05/f05020.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![f05020](image_fi/278748c05/f05020.png)'
- en: 'Figure 5-20: The glitch waveform injected into a Raspberry Pi'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-20：注入到Raspberry Pi中的故障波形
- en: Releasing the crowbar causes a rapid spike up to 1.44 V and the resulting ringing
    on the power rail. We expect that this is responsible for the faulty behavior,
    rather than the reduced operating voltage. We used no other method than the crowbar
    to introduce this, but the complex power distribution networks of these boards
    tend to ring when poked this way. This ringing waveform also explains why we used
    such a wide input pulse. You’ll notice that the 3.2 µs pulse time reflects the
    gradual reduction in the power seen at the target, rather than a sudden drop out,
    which is related to the fact that we still have some inductance in the injection
    line and the capacitive power supply network will resist some change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 释放短路器会导致电压迅速升高至1.44V，并在电源轨上产生振铃。我们预计这应该是导致故障行为的原因，而不是降低的工作电压。我们没有使用其他方法来引入这个故障，唯一使用的是短路器，但这些板的复杂电力分配网络在被这种方式刺激时通常会产生振铃。这种振铃波形也解释了为什么我们使用了如此宽的输入脉冲。你会注意到，3.2微秒的脉冲时间反映了目标上看到的电力逐渐减少，而不是突然的电压下降，这与我们注入线中仍有一定的电感以及电容电源网络对变化的抵抗有关。
- en: Due to the long duration and the demo nature of the attack, we used software
    triggering and didn’t have specific hardware triggers to which we could synchronize
    our glitcher. See Colin’s YouTube video titled “Voltage (VCC) Glitching Raspberry
    Pi 3 model B+ with ChipWhisperer-Lite,” which shows it working on this Raspberry
    Pi.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于攻击持续时间较长且具有演示性质，我们使用了软件触发器，并没有特定的硬件触发器来同步我们的故障注入器。请参见Colin的YouTube视频，标题为“使用ChipWhisperer-Lite对Raspberry
    Pi 3 model B+进行电压（VCC）故障注入”，该视频展示了其在这款Raspberry Pi上工作的过程。
- en: Voltage Fault Injection Search Parameters
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电压故障注入搜索参数
- en: When switching between two voltages, we need to first determine the *base* *voltage*
    at which to run the target. At first we can use the voltage at which it normally
    runs. If we want to optimize a bit, however, we run the target on the highest
    voltage (for spikes) or lowest voltage (for dips) at which it still reliably operates.
    By adjusting the voltage up (if we will be spiking the voltage with our fault)
    or down (if we will be dipping the voltage with our fault), we decrease the amount
    of charge that the glitch needs to inject to induce a voltage that results in
    a fault.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换两个电压之间时，我们需要首先确定运行目标的*基础* *电压*。一开始我们可以使用其正常运行时的电压。然而，如果我们想优化一些，我们可以将目标运行在最高电压（针对尖峰）或最低电压（针对下陷），只要它仍然能够可靠地工作。通过调整电压（如果我们要通过故障使电压上升）或下降（如果我们要通过故障使电压下降），我们减少了故障注入器需要注入的电荷量，从而诱发一个导致故障的电压。
- en: Once you have the operation timing and base voltage right, you can start to
    tune the actual fault. If using the crowbar injection, as described earlier in
    the “Crowbar Injected Faults” section, you won’t have control over the glitch
    voltage, as the crowbar simply pulls to ground. However, if your injector allows
    you to control the glitch voltage, experiment to see what causes the device to
    fault. Progressively move out of operating range so as not to cause permanent
    damage. Positive spikes have a much higher chance of burning your target, so try
    voltage dips first. You can generate dips that go below 0 V for a short time to
    drain capacitances, but doing this for too long may also cause damage.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the voltage settings, you will, of course, have the parameters related
    to the glitch location. We discussed those in Chapter 4, as well as the relevant
    search strategies.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Electromagnetic Fault Injection
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Electromagnetic fault injection* uses a strong electromagnetic pulse to cause
    a fault. You can produce such faults in a variety of ways, but the easiest method
    is to pulse a strong current through a coil of wire. Electromagnetic injection
    is governed by Faraday’s law, which says that a changing magnetic field through
    a wire loop causes a voltage difference to appear across the loop terminals. The
    current spike through the coil generates such a changing magnetic field. The wires
    on a chip form the loop part. When the changing magnetic field hits the wires
    on the chip, we get voltage spikes that can temporarily cause signal levels to
    flip from 1 to 0, or vice versa. A convenient property of electromagnetic fault
    injection is that once you’ve built your setup, you don’t need to modify your
    targets; simply hold the probe over the chip and fire away.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, some fault injectors can generate a continuous electromagnetic
    field. These are more specifically used for biasing ring oscillators, which is
    done to reduce the entropy in a random number generator. See Jeroen Senden’s MSc
    thesis titled Biasing a Ring-Oscillator Based True Random Number Generator with
    an Electro-Magnetic Fault Injection Using Harmonic Waves” (University of Twente,
    2015) for more details on this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-21](#figure5-21) shows an electromagnetic fault injector’s general
    structure, where the coil of wire generates a magnetic field that induces a flow
    of current and a voltage somewhere inside the chip being targeted. Per “Inducing
    Local Timing Fault Through EM Injection,” by Marjan Ghodrati et al., the result
    is a localized clock fault. The somewhat more interesting aspect is that you can
    carefully position the probe itself over the chip surface, meaning you can target
    a specific area of the chip. Even though the field may not be targeted as finely
    as you could with a laser beam, it does have more of a localized effect than either
    clock or voltage fault injection. You also don’t run the risk of burning yourself
    with acid, since decapsulation is not required, but you will be dealing with high
    voltages and currents, so avoid the temptation to lick the electromagnetic probe.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![f05021](image_fi/278748c05/f05021.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-21: Electromagnetic pulses insert voltages into the target chip.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Many packages have a heat spreader over top of the chip. While we’ve found you
    can still insert some fields through the thin spreader, it does drastically reduce
    the power delivered to the chip. Removing the heat spreader is helpful for many
    attacks, including EMFI, as shown next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Generating Electromagnetic Faults
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your budget determines whether you buy or build the coil and pulse generator.
    The coil of wire can take many forms. The easiest methods are to use off-the-shelf
    magnetic field probes or solid-core inductors. Some useful probe design references
    include “Magnetic Microprobe Design for EM Fault Attack” by Rachid Omarouayache
    et al. (EMC Europe, 2013) and “Electro Magnetic Fault Injection in Practice” by
    Rajesh Velegalati, Robert Van Spyk, and Jasper van Woudenberg (ICMC, 2013). Often
    the probes will be built out of an SMA connector, as the examples in [Figure 5-22](#figure5-22)
    show.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need a signal to feed into the probe. The required signal strength
    determines what equipment you’ll need. The most basic pulse is derived from the
    discharge of a capacitor across the probe coil. The objective is to achieve a
    very high rate of current change through the coil, so having fewer turns on the
    coil reduces the inductance resulting in a faster rise time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![f05022](image_fi/278748c05/f05022.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-22: Sample homebrew and commercial probes'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: You can purchase commercial pulse generators, which have a wide range of voltage
    and current outputs. By adjusting the voltage and/or current of the pulse, you
    can adjust the type of effect that will be induced in the target device. Avtech,
    Riscure, NewAE Technology, and Keysight are all pulse generator (or EMFI tool)
    vendors. Typical voltages used for fault injection are 60–400 V and currents are
    0.5–20 A, and pulse lengths are on the order of tens of nanoseconds (and therefore
    power on the order of tens of microwatts; don’t worry about melting the probe
    tip).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: One parameter that can be defined either by the pulse generator or the probe
    tip is the polarity of the pulse induced in the chip. You can change it by switching
    the polarity of the voltage pulse going into the probe or by reversing the direction
    of the probe coil. Either method reverses the magnetic field’s direction, thereby
    reversing the direction of the induced current. In some situations, you might
    not be able to change the polarity safely. For example, when using high voltages,
    you certainly want the exposed part of a metal connector to be at ground potential.
    In practice, the choice of pulse polarity is arbitrary; we will tend to test both
    on a specific device, as one polarity may work better on a specific device than
    another.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Finally, get the probe tip as close to the die as possible, without touching
    the die. As a rule of thumb, you want the distance to your target to be smaller
    than the loop diameter. If your loop diameter is 1 mm or so, you can just place
    it on top of the package. If the diameter is smaller than that, consider decapping
    the chip.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Architectures for Electromagnetic Fault Injection
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Electromagnetic fault injector tools can use many architectures, and they are
    generally split into two main types: a direct drive of the injection coil and
    a coupled drive (see [Figure 5-23](#figure5-23)). The two electromagnetic fault
    injector tools on the left and center use a *direct*-*drive* architecture, and
    the electromagnetic fault injector tool on the right uses a *coupled drive* (here
    coupled with capacitor C1). In a direct-drive electromagnetic fault injector tool,
    a capacitor bank is directly switched onto the coil for a controlled length of
    time.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![f05023](image_fi/278748c05/f05023.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-23: EMFI tools'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The direct-drive architecture has the advantage of being relatively forgiving
    of the probe connected to the device. It does not require close matching of impedance
    or other considerations, since almost anything connected to the drive will be
    driven as rapidly as possible from the capacitor bank. On both of the direct-drive
    architectures, resistor R1 is used to limit current through the switching element
    (MOSFET) to avoid destruction if the output is shorted.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'You can subdivide the direct drive into either a *high-side* or *low-side*
    switching architecture. The advantage of low-side switching is that it’s simple
    to construct and achieve high performance; the major downside is that your output
    “tip” is always connected to the high voltage source, which is a dangerous situation.
    You can find an example of this architecture in the first open source EMFI tool,
    presented by Ang Cui and Rick Housley in their work “BADFET: Defeating Modern
    Secure Boot Using Second-Order Pulsed Electromagnetic Fault Injection” (WOOT ’17).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: A more complex but safer choice is to use high-side switching. With that option,
    the switching element must “ride the pulse,” which means when the switch closes,
    the control voltage must rapidly follow the pulse voltage. In the center example
    in [Figure 5-23](#figure5-23), the connection marked “Trigger In GND” is not at
    system ground potential; instead, it’s at the high side of the output coil (which
    is in the process of pulsing from 0 V to 400 V or so). Connecting a normal system
    ground (which is expected to be at 0 V) to the “Trigger In GND” requires additional
    circuitry to function, but it ensures that high voltages are present only during
    the pulse operation. The high-side switching arrangement is used by the ChipSHOUTER
    tool, and you can find more info on this construction in the ChipSHOUTER design
    details and schematic available from [www.chipshouter.com](http://www.chipshouter.com).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The coupled architecture shown on the right side of [Figure 5-23](#figure5-23)
    allows the simplicity of low-side drive, but uses a coupling (such as a transformer,
    inductor, or capacitor) to transfer the probe energy to ensure that the voltage
    is present only during the discharge event. The example in [Figure 5-23](#figure5-23)
    shows a capacitor C1 being used to couple the energy. If resistor R3 is chosen
    to be very small, you can connect the “Trigger In GND” to system ground, as in
    this example. The resistor R2 is used to develop the voltage across it when the
    MOSFET is turned on (closed), which will cause a changing voltage that is coupled
    through capacitor C1.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: This architecture may require tuning with different probes—for example, by changing
    the values of R4 and C1\. The presentation “Design Considerations for EM Pulse
    Fault Injection” by Arthur Beckers et al. (CARDIS 2019) provides a good overview
    of this architecture’s design. This architecture provides a trade-off between
    simplicity of design, effectiveness of pulse generation, and inherent safety by
    limiting the possible exposure to high voltage at the output (which cannot be
    as easily enclosed as the rest of the circuitry).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: EMFI Pulse Shapes and Widths
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What should a typical drive waveform look like? [Figure 5-24](#figure5-24) shows
    an example of such a waveform. The voltage goes into a coil where you can see
    it goes from 0 V to 400 V and back to 0 V.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we’re generating two pulses in a row. You might expect that only
    very short (narrow) pulses are relevant. If a CPU is running at 50 MHz, a single
    clock cycle is 20ns, so should you really insert wider pulses, like the 1,000ns
    pulse shown? When considering the pulse width, remember it is the *change* in
    magnetic flux that is inserting a fault. Thus, we’re primarily concerned with
    *edges*. The changing voltage of the edges is the only interesting times for the
    actual fault insertion. A very wide pulse means inducing a current at the rising
    edge and the opposite direction current at the falling edge.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![f05024](image_fi/278748c05/f05024.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-24: An example of the drive waveform inserted into a coil for an EMFI
    attack'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Search Parameters for Electromagnetic Fault Injection
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One major parameter in EMFI is the type of probe tip used as well as the tip’s
    construction, such as the number of windings, the type of core used, and the polarity
    of the field generated by the tip. In general, these parameters are harder to
    vary, as they are highly dependent on your specific physical hardware. Changing
    the parameters may mean building new physical tips, which isn’t as easy as just
    changing some Python code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the correct polarity that will generate your desired fault is, unfortunately,
    just a matter of luck. We’re not aware of any way to predict which is going to
    work better, but we’ve seen that one polarity can trigger different faults from
    what the other polarity triggers. As an example of the effect of polarity on a
    real device, see Colin O’Flynn’s “BAM BAM!! On Reliability of EMFI for in-situ
    Automotive ECU Attacks” (ESCAR EU, 2020), where one polarity was unsuccessful
    but the other polarity was highly successful on an ECU target.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of the core construction itself, research suggests using a small
    number of loops (starting with just a single loop) with a sharpened ferrite core.
    A wet grinder (often used for knife sharpening) is perfect for shaping ferrite
    cores.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Electromagnetic fault injection is normally nondestructive, so you can start
    your *glitch power* (*glitch* *voltage* multiplied by *glitch current*) at 50
    percent of the maximum and then move up or down, depending on whether you get
    no results or too many crashes. You may not be able to configure the *glitch duration*,
    as it depends on the pulse generator. If you can configure it, however, starting
    with anything from 10–50ns is reasonable. As discussed earlier, very wide pulses
    may actually result in two pulses inserted into the target.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Once you have some initial settings, remember to check your setup and use the
    search strategies discussed in Chapter 4.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Optical Fault Injection
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chips consist of semiconductor material that typically is created using doped
    silicon and has the interesting property (for us hackers) that the conductivity
    of the gate changes when you light the gate up with a sufficient photon intensity.
    Strong light pulses turn out to have the ability to ionize the semiconductor region,
    which leads to a localized fault.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Humans have actually known about the effect of photons since we started putting
    ICs close to and into radiation-intense environments, such as outer space. All
    kinds of radiation produce the same effect as illuminating transistors with photons,
    such as radiating them with alpha particles, X-rays, and so on. Ask your buddy
    in avionics or space tech about *single event upsets*—basically, space itself
    is clumsily trying to inject faults on your chip. People doing failure analysis
    can simulate these kinds of effects by bombarding ICs with lasers. The nice thing
    about lasers is that they are a bit safer and more accessible to us than particle
    accelerators or X-ray machines. This means we can use them for injecting faults.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Chip Preparation
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to access a chip with light, you must first remove part or all of the
    packaging in a process called *decapsulation* *(decapping)* or *depackaging* of
    the chip, as described in Chapter 1. For front-side access to the chip, simply
    decapsulate the top (assuming it is not a *flip-chip* device, as discussed in
    Chapter 3). [Figure 5-25](#figure5-25) shows an example of a decapsulated smart
    card chip.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![f05025](image_fi/278748c05/f05025.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-25: Decapsulated publicly available smart card chip with bonding wires
    intact (source: Riscure)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: To decapsulate a device, we use acid (typically fuming nitric acid) to etch
    away the encapsulation chemically. The specific process you need to use changes
    for different packaging types. Therefore, exposing a silicon chip is part skill
    and part science. Be prepared to lose a few samples on the experimental path to
    developing a decapsulation technique, and be aware that decapping is dangerous
    to do outside the confines of a proper chemical lab. With some effort, it is possible;
    see the *International Journal of PoC || GTFO*, Issue 0x04, for some good hints
    on performing decapsulation at home.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to burn a hole in the package through which the chip can be seen,
    while ensuring that the bonding wires and the rest of the package remain intact
    so that you can use the chip in place on its original PCB. The chip’s packaging
    determines what parts of the chip you can access. You can decapsulate a BGA package
    only on one side, which normally exposes the front side of the chip; flip-chip
    packages provide access to the rear side of the chip instead. In cases where chip
    stacking happens in the manufacturing process, you may end up having access only
    to one of the chips in the package. Package-on-package encapsulation presents
    its own challenges. (See Chapter 3 for a discussion of some of these packages.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: When decapsulation is not an option, depackaging and rebonding may work. With
    this technique, you completely dissolve the package and destroy the bonding wires,
    leaving only the silicon chip. Once you extract the chip from the package, you
    can access its front and rear, but you need to reconnect the chip by rebonding.
    Chip preparation labs can rebond, or you can do it yourself (with some practice)
    if you have access to a wire-bonding machine.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Front-Side and Back-Side Attacks
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can perform light attacks from two directions: the front side of the chip
    or the back side of the chip (see [Figure 5-26](#figure5-26)).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![f05026](image_fi/278748c05/f05026.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-26: Laser attacks from both sides of a chip (credit: Riscure)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrows indicate the source of the laser beam. The front side of the chip
    has the metal layers that make up the wires connecting the gates. Older chips
    may have three metal layers, and modern ICs may have more than 10 layers. The
    silicon substrate is on the back side of the chip. The gates you want to target
    are sandwiched between the metal and the substrate, so you need to get the photons
    past those obstacles. The key to reaching this target is twofold: wavelength and
    power.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: On the front side of the chip shown in [Figure 5-26](#figure5-26), the metal
    will scatter your photons, and though the gaps between the wires are relatively
    small, they are big enough for photons to sneak through. A shorter wavelength
    helps them get through small gaps. The scattering between layers works like one
    of those old Bagatelle pinball games, where even though the marble is aimed through
    one place at the top, the area where it can land is spread out over a much wider
    area at the bottom. This makes the landing area wider than the size of the spot
    from which your light source emits. Wavelengths between roughly 400 nm and 900
    nm work well as the silicon in the targets easily absorbs them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how many metal layers you need to bounce off, the frequency you
    choose, and the duration of the laser pulse, you’ll need up to a few watts of
    power. Overpowered diode lasers are nice because it’s easier to turn down the
    power than it is to turn it up. In lab situations, attenuated 445 nm/3 W and 808
    nm/14 W lasers for the front side are pulsed for anything from 20ns up to 1,000ns.
    Don’t let the high-power ratings discourage you. See Sergei P. Skorobogatov and
    Ross J. Anderson’s paper “Optical Fault Induction Attacks” (CHES 2002) for a discussion
    of successfully using a 650 nm/10 mW laser for fault injection attacks.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: On the back side, you need to punch through the substrate, which is basically
    a thick (hundreds of micrometers) slab of silicon that your photons need to penetrate
    before they can have an effect. The dilemma here is that you’ll want to use a
    wavelength that isn’t absorbed by the silicon substrate, but one that is absorbed
    by the gates, which are also made of silicon!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to use a wavelength at which silicon just becomes
    transparent to the laser beam. In the infrared range, 1,064 nm is a good choice,
    as it also can blast an enormous number of photons to have an effect on the gates.
    We’ve used 20 W diode lasers to do this, though that may be “slightly” overpowered.
    The substrate also will diffuse your photons, which increases the effective spot
    size; polishing and thinning the substrate are helpful if you have access to those
    kinds of polishing machines.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-27](#figure5-27) shows the penetration depth through various materials
    for different light wavelengths.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![f05027](image_fi/278748c05/f05027.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-27: Penetration depths in silicon for various photon wavelengths'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You can see that silicon is just on the verge of becoming transparent to the
    laser at 1,064 nm. The absorption coefficient begins to increase rapidly as the
    wavelength becomes shorter. Notice the change between 1,200nm (1.2μm) and 800nm
    (0.8μm), for example.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Light Sources
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When attempting to inject faults using photons, consider the following properties
    of light sources: time precision, space precision, wavelength, and intensity.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a sufficient blast of photons on your chip using many methods;
    here are three:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Use a camera flashgun wrapped in tin foil with a pinhole through which the light
    exits on its way through a microscope to focus the beam. This is obviously a very
    cost-effective solution, though the precision in time and space is limited (also
    introduced in Skorobogatov and Anderson’s “Optical Fault Induction Attacks”).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use laser cutters made for IC edits. Failure analysis labs typically have these
    devices, but they’re not within the average hacker’s budget. We mention them because
    they were used for fault injection before dedicated tools became available. (Note
    that these laser cutters are different from those for cutting wood or metals.)
    The beam intensity of these cutters is more than sufficient for fault injection.
    They are designed for making microscopic modification to chips by burning away
    parts. One downside is that when they are used for cutting, time precision is
    not a requirement, which severely restricts the ability to blast photons at the
    correct instant. Yagi-based laser cutters have jitter in the time between triggering
    the laser and the actual photon emissions, which means they offer inconsistent
    repeatability when used for fault injection.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use diode lasers. You can combine diode lasers with microscope optics to focus
    on a small spot or with optical fibers to guide a beam, as shown in [Figure 5-28](#figure5-28).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f05028](image_fi/278748c05/f05028.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-28: Optical fiber laser fault injection (source: Riscure)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: This photo shows an optical fiber precisely positioned over a decapped smart
    card chip, targeting a diode laser into a specific area of the chip. You can combine
    the microscope and optical fibers with an XY machining table to position the laser,
    which produces small, intense spots and pulses with very little timing jitter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: You can extend optical fault injection to more advanced techniques beyond the
    scope of this book. For example, when dealing with highly protected chips, you
    can use multiple laser sources. If you have a chip with a CPU and a crypto accelerator,
    you sometimes can inject a fault in both cores by placing one laser spot over
    an area of the CPU and the other over an area of the crypto accelerator, and then
    hitting them both.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Optical Fault Injection Setup
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of optical fault injection is that you can position the injected
    fault accurately by aiming the laser at a carefully selected part of the chip,
    which allows you to target small sections of functionality (for instance, a JTAG
    unlock circuit). Finding the right spot is tricky and requires some kind of XY
    positioning table to automate the search for a useful spot. You will need something
    with specs (that is, positioning resolution) that match your spot sizes, which
    can go down to 1 micron.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Next to an XY station, you need to choose one of the aforementioned light sources
    and optionally attach it to an optical microscope. Note that any microscope has
    a certain range of frequencies to which it is virtually transparent, so make sure
    it matches with the light source frequency.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The spot size is configurable using different magnifications on an optical microscope
    setup. You can decrease the effective spot size by lowering the light intensity,
    which decreases scattering. Ideally, the spot size should be around 1–50 microns
    in diameter. The smaller you make the spot, the higher the precision in targeting
    a specific area, but that also means you have to search the XY space for more
    spots. In general, we recommend starting with a larger size. If you end up getting
    only crashes and no interesting faults, you may be hitting too large of an area,
    so then try decreasing the spot size.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Optical Fault Injection Configurable Parameters
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first parameter to consider is a *target area* for the XY scan. You can
    do a little bit of optical reverse engineering of photos of your die to identify
    the different blocks. In our experience, avoiding memory cells can be a timesaver,
    though including memory decoders can be interesting. If you don’t want to restrict
    yourself, just scan the whole die.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Two parameters, the *light intensity* and the *duration*, configure the amount
    of energy you deliver. Too much energy means you will kill the chip. We have a
    tiny chip graveyard next to our setups, just as a reminder. For all light sources,
    you can control intensity by using filters that block light. For laser cutters,
    you can also change the intensity electronically, and for diode lasers, you can
    modulate both intensity and duration by modulating the power supply. For the duration,
    you typically aim for about the length of one clock cycle, but there is some wiggle
    room here. In our experiments, we’ve observed successful faults at the length
    of dozens of clock cycles (at lower intensities).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part of the scan is that the amount of energy required to cause a
    fault varies for different parts of the chip, which means you need to combine
    optimizing the parameters with an XY scan. To avoid frying the chip, first do
    a run on such low energy that there are no faults or other observable effects.
    Try a light intensity of 1 percent to 10 percent of the maximum and a duration
    of 10–50ns, and start scanning over the chip in, for example, a 20×20 grid. If
    you see any behavior that’s irregular, terminate the experiment, reduce the settings,
    and repeat until you get no faults. Then start increasing the energy in small
    steps, each time performing a new scan over the chip. Once you start seeing interesting
    faults, you can start narrowing down the parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: When you do double-laser optical fault injection, you’ll double most of the
    parameters we just described, leading to a highly complex search space. There
    is no magic bullet here, and it’s just a matter of applying divide-and-conquer
    principles.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Body Biasing Injection
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Body biasing injection (BBI)* is a fault injection method that falls somewhere
    between electromagnetic fault injection and laser fault injection. It uses a physical
    needle placed on the backside of a die (see [Figure 5-29](#figure5-29)). A high
    voltage pulse is injected on the needle, which can be coupled to various internal
    nodes in the IC. Philippe Maurine introduced this method in his paper “Techniques
    for EM Fault Injection: Equipments and Experimental Results” (FDTC 2012).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![f05029](image_fi/278748c05/f05029.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-29: Body biasing injection uses a needle on the die’s backside.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The needle is a standard spring-loaded test point probe. In the case of [Figure
    5-29](#figure5-29), we cheat a little for the backside attack. The target device
    is a standard microcontroller that is available in a wafer-level chip-scale package
    (WLCSP). These WLCSP devices are effectively a slice of the silicon wafer with
    solder bumps added, designed for some of the smallest electronics. As an artifact
    of their construction, they often expose the backside of the device, so you don’t
    need to perform any work. A simple insulating cover may be present that is easy
    to scrape off, but it doesn’t require the acid decapsulation we discussed earlier.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: To inject a fault, a relatively high-voltage pulse is inserted onto the needle
    that is touching the device backside. This high-voltage pulse is required, as
    there is no direct (low-resistance) connection between the backside and the internal
    nodes of the device. [Figure 5-30](#figure5-30) shows an example of a pulse.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![f05030](image_fi/278748c05/f05030.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-30: Example pulse for input = 10 V, pulse = 680 ns width. BBI requires
    a high voltage like EMFI, but it has more limited peak currents than EMFI.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice the peak voltage of more than 150 V on the die’s backside. This
    higher voltage, however, translates to a small voltage at internal nodes in the
    ICs; therefore, we don’t “blow out” the IC. The peak current of 0.8 A in this
    case is much smaller than with EMFI, where we may have peak currents of 20 A or
    more in the coil.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Compared to optical fault injection, and even compared to EMFI, the BBI technique
    is much lower cost. One architecture uses a simple step-up transformer, meaning
    it’s possible to build a working BBI probe for about $15 (see [Figure 5-31](#figure5-31)).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![f05031](image_fi/278748c05/f05031.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-31: This ChipJabber-BasicBBI probe can be assembled at a very low
    cost.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a step-up transformer (the messy winding to the right of center
    in [Figure 5-31](#figure5-31)) is driven with a simple MOSFET-based switch. By
    changing the input voltage, you can adjust the output voltage for the BBI. See
    [https://github.com/newaetech/chipjabber-basicbbi/](https://github.com/newaetech/chipjabber-basicbbi/)
    and the paper “Low-Cost Body Biasing Injection (BBI) Attacks on WLCSP Devices”
    by Colin O’Flynn (CARDIS, 2020) for full details of the schematic.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Parameters for Body Biasing Injection
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parameters for BBI are relatively basic. Besides the standard parameters,
    such as timing and physical location on the die surface, BBI adds the *pulse voltage*.
    We typically start very low (as close to 0 V as the power supply will go) and
    increase it until we see faults. Effective voltage may range from 10 V to 500
    V, depending on the device. The primary driver of the voltage requirements is
    the backside thickness. You can get a rough estimate by using a multimeter to
    measure from the die backside to a ground pin. If the resistance is around 20
    kΩ to 50 kΩ, you will need a very low voltage (10 V to 50 V). If the resistance
    is around 100 kΩ to 300 kΩ, you may need a higher voltage, such as 75 V to 200
    V. If the resistance is much higher (1 MΩ), the attack may be ineffective or require
    much higher voltages.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: BBI can damage a device fairly easily. These higher-voltage pulses are being
    directly injected to the silicon and can more easily cause permanent faults in
    the device compared to electromagnetic fault injection. Starting at a low voltage
    and ramping up is a suggested search strategy to avoid damaging your device.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Triggering Hardware Faults
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve mentioned the trigger several times, with the assumption that some trigger
    event is easily accessible. In reality, the trigger event may be simple or complicated,
    but we are ultimately making a decision on what event precedes the operation of
    interest we want to fault.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The requirements around triggering will have parallels to side-channel power
    analysis, which we describe in Chapter 9. The main difference between side-channel
    power analysis and fault injection as it relates to triggering is that with fault
    injection, we are actively manipulating the device execution, compared to power
    analysis, which is passively listening. Because power analysis is passively listening,
    we can find triggers in already recorded data, but with fault injection, we need
    a trigger that occurs during the device operation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common fault triggers on a microcontroller is the reset pin.
    When a device boots, it often performs several security-critical functions, such
    as checking the value of fuse bits, checking boot signatures, and so on. This
    routine tells us the starting point (when the reset becomes inactive so the device
    can run), but how long should we check from the trigger point? Some experimentation
    is required to determine that. You could write a program for your microcontroller
    that sets an I/O pin high as soon as the code starts. The time between the reset
    pin going inactive and your user I/O pin going high indicates when the device
    was performing startup code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Some devices also include a reset input and reset output. These devices use
    the reset output to tell other devices in the system when the main microcontroller
    is up and running. This information can provide an even more reliable trigger,
    since the reset output may be actually set as part of that reset logic.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: More complex triggers will often be based on certain I/O from the device, such
    as a serial message indicating the device is at a certain boot state. As an example,
    [Listing 5-3](#listing5-3) shows the boot messages from an Echo Dot.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: Boot messages from an Echo Dot provide enough detail that we could
    target fault injection at various aspects.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: It’s rare to have such detailed boot messages, but in this example, the serial
    port messages tell when certain functions, such as the RSA-2048 signature calculation,
    were successful. We would likely want to trigger a fault after the RSA-2048 calculation
    but before the PKCS#1 verification. If we simply want to validate that we can
    cause faults at all, that long 87ms RSA-2048 operation would be a perfect target.
    By corrupting the RSA-2048 calculation, we’d see the signature verification fail
    (since the RSA operation is not being performed correctly).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In general, you can often find useful timing information by comparing the device
    booting with known-good settings and with invalid settings. If you send an incorrect
    password to the device, does it lock up or turn on an error indicator? Logically,
    your fault’s location then must be sometime between when the device started processing
    and that lockup or error condition.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll walk through some examples of how you can more concretely
    find these trigger points by looking at a few real-life examples.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unpredictable Target Timing
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the countermeasures against fault injection, whether intentionally implemented
    or not, is having a nonconstant time between the trigger and the target operation.
    If this time is jittery, how can the attacker time the injection to hit a specific
    operation in the code sequence?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Timing jitter arises in several ways: by intentionally introducing random delays
    in the code, when a target running an operating system and a scheduler is regularly
    processing interrupts, or if the target is running on a jittery clock. Any of
    these cases will negatively impact the fault injection success rate, because the
    target operation will occur at unpredictable times. One way to compensate for
    such jitter is to use side-channel signals to synchronize your injector to your
    target. Using a power side channel means triggering on a waveform in the power
    measurement—often using FPGAs to do real-time triggering.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fault attacks provide a powerful means of introducing all sorts of unintended
    behavior into devices. While there might seem to be an overwhelming number of
    possibilities, a little experimentation can often result in a successful fault
    attack.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has outlined the kinds of effects that you can induce via fault
    injection, as well as some of the common methods—namely, clock fault injection,
    voltage fault injection, optical fault injection, EM fault injection, and body
    biasing injection. This should give you the background you need to understand
    and apply these attacks in your research.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, we’ll discuss side-channel power analysis, which may
    be used in tandem with fault injection. You can use side-channel power analysis
    to figure out what functions are being performed inside a device, which is a powerful
    tool for determining whether your faults are causing unintended effects, even
    when you can’t see any output from the target device.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Since you’ve made it this far, here’s a little fault injection gem that’s outside
    of the scope of the book but will have widespread applicability with all the embedded
    devices out there. If the classic stack-smashing buffer overflow payload is being
    stopped by a length check, just fault the buffer length check to regain that 1990s
    code injection feel. Have fun!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
