- en: Chapter 36. Process Resources
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 36 章：进程资源
- en: Each process consumes system resources such as memory and CPU time. This chapter
    looks at resource-related system calls. We begin with the *getrusage()* system
    call, which allows a process to monitor the resources that it has used or that
    its children have used. We then look at the *setrlimit()* and *getrlimit()* system
    calls, which can be used to change and retrieve limits on the calling process’s
    consumption of various resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都会消耗系统资源，如内存和 CPU 时间。本章介绍与资源相关的系统调用。我们从 *getrusage()* 系统调用开始，它允许进程监控自身或其子进程使用的资源。接下来，我们将讨论
    *setrlimit()* 和 *getrlimit()* 系统调用，这些调用可以用于更改和获取调用进程对各种资源的使用限制。
- en: Process Resource Usage
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程资源使用
- en: The *getrusage()* system call retrieves statistics about various system resources
    used by the calling process or by all of its children.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*getrusage()* 系统调用检索调用进程或其所有子进程使用的各种系统资源的统计信息。'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: 'The *who* argument specifies the process(es) for which resource usage information
    is to be retrieved. It has one of the following values:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*who* 参数指定要检索资源使用信息的进程。它有以下几种值：'
- en: '`RUSAGE_SELF`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUSAGE_SELF`'
- en: Return information about the calling process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用进程的信息。
- en: '`RUSAGE_CHILDREN`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUSAGE_CHILDREN`'
- en: Return information about all children of the calling process that have terminated
    and been waited for.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 返回有关调用进程所有已终止并等待的子进程的信息。
- en: '`RUSAGE_THREAD` (since Linux 2.6.26)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUSAGE_THREAD`（自 Linux 2.6.26 起）'
- en: Return information about the calling thread. This value is Linux-specific.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 返回调用线程的信息。此值为 Linux 特定。
- en: The *res_usage* argument is a pointer to a structure of type *rusage*, defined
    as shown in [Example 36-1](ch36.html#definition_of_the_rusage_structure "Example 36-1. Definition
    of the rusage structure").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*res_usage* 参数是指向 *rusage* 类型结构体的指针，定义如 [示例 36-1](ch36.html#definition_of_the_rusage_structure
    "Example 36-1. Definition of the rusage structure") 所示。'
- en: Example 36-1. Definition of the *rusage* structure
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 36-1. *rusage* 结构定义
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As indicated in the comments in [Example 36-1](ch36.html#definition_of_the_rusage_structure
    "Example 36-1. Definition of the rusage structure"), on Linux, many of the fields
    in the *rusage* structure are not filled in by *getrusage()* (or *wait3()* and
    *wait4()*), or they are filled in only by more recent kernel versions. Some of
    the fields that are unused on Linux are used on other UNIX implementations. These
    fields are provided on Linux so that, if they are implemented at a future date,
    the *rusage* structure does not need to undergo a change that would break existing
    application binaries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [示例 36-1](ch36.html#definition_of_the_rusage_structure "Example 36-1. Definition
    of the rusage structure") 中的注释所示，在 Linux 上，许多 *rusage* 结构中的字段未被 *getrusage()*（或
    *wait3()* 和 *wait4()*）填写，或者仅在更新的内核版本中才会填写。在 Linux 上未使用的某些字段在其他 UNIX 实现中会被使用。Linux
    提供这些字段，以便将来实现时，*rusage* 结构不需要修改，从而避免破坏现有的应用程序二进制文件。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although *getrusage()* appears on most UNIX implementations, it is only weakly
    specified in SUSv3 (which specifies only the fields *ru_utime* and *ru_stime*).
    In part, this is because the meaning of much of the information in the *rusage*
    structure is implementation-dependent.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *getrusage()* 出现在大多数 UNIX 实现中，但它在 SUSv3 中仅有弱定义（只指定了 *ru_utime* 和 *ru_stime*
    字段）。部分原因是 *rusage* 结构中的许多信息的含义依赖于具体实现。
- en: The *ru_utime* and *ru_stime* fields are structures of type *timeval* ([Calendar
    Time](ch10.html#calendar_time "Calendar Time")), which return the number of seconds
    and microseconds of CPU time consumed by a process in user mode and kernel mode,
    respectively. (Similar information is retrieved by the *times()* system call described
    in Section 10.7.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*ru_utime* 和 *ru_stime* 字段是 *timeval* 类型的结构体（[日历时间](ch10.html#calendar_time
    "Calendar Time")），分别返回进程在用户模式和内核模式下消耗的 CPU 时间的秒数和微秒数。（通过 *times()* 系统调用可以检索到类似的信息，详见第
    10.7 节。）'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux-specific `/proc/`*PID*`/stat` files expose some resource usage information
    (CPU time and page faults) about all processes on the system. See the *proc(5)*
    manual page for further details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 特定的 `/proc/`*PID*`/stat` 文件暴露了系统上所有进程的一些资源使用信息（CPU 时间和页面错误）。有关详细信息，请参见
    *proc(5)* 手册页。
- en: The *rusage* structure returned by the *getrusage()* `RUSAGE_CHILDREN` operation
    includes the resource usage statistics of all of the descendants of the calling
    process. For example, if we have three processes related as parent, child, and
    grandchild, then, when the child does a *wait()* on the grandchild, the resource
    usage values of the grandchild are added to the child’s `RUSAGE_CHILDREN` values;
    when the parent performs a *wait()* for the child, the resource usage values of
    both the child and the grandchild are added to the parent’s `RUSAGE_CHILDREN`
    values. Conversely, if the child does not *wait()* on the grandchild, then the
    grandchild’s resource usages are not recorded in the `RUSAGE_CHILDREN` values
    of the parent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*getrusage()*返回的*rusage*结构体中的`RUSAGE_CHILDREN`操作包含了调用进程所有后代的资源使用统计信息。例如，如果我们有三个进程，分别为父进程、子进程和孙进程，那么当子进程对孙进程执行*wait()*时，孙进程的资源使用值会被加到子进程的`RUSAGE_CHILDREN`值中；当父进程对子进程执行*wait()*时，子进程和孙进程的资源使用值都会被加到父进程的`RUSAGE_CHILDREN`值中。相反，如果子进程没有对孙进程执行*wait()*，那么孙进程的资源使用值不会被记录在父进程的`RUSAGE_CHILDREN`值中。'
- en: For the `RUSAGE_CHILDREN` operation, the *ru_maxrss* field returns the maximum
    resident set size among all of the descendants of the calling process (rather
    than a sum for all descendants).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RUSAGE_CHILDREN`操作，*ru_maxrss*字段返回调用进程所有后代进程中的最大常驻集大小（而不是所有后代的总和）。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies that if `SIGCHLD` is being ignored (so that children are not
    turned into zombies that can be waited on), then the child statistics should not
    be added to the values returned by `RUSAGE_CHILDREN`. However, as noted in [Ignoring
    Dead Child Processes](ch26.html#ignoring_dead_child_processes "Ignoring Dead Child
    Processes"), in kernels before 2.6.9, Linux deviates from this requirement—if
    `SIGCHLD` is ignored, then the resource usage values for dead children *are* included
    in the values returned for `RUSAGE_CHILDREN`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果`SIGCHLD`被忽略（这样子进程的子进程就不会变成僵尸进程，不能被等待），那么子进程的统计信息不应该被加入到`RUSAGE_CHILDREN`返回的值中。然而，正如在[忽略死去的子进程](ch26.html#ignoring_dead_child_processes
    "忽略死去的子进程")中所提到的，在2.6.9版本之前的内核中，Linux偏离了这个要求——如果`SIGCHLD`被忽略，那么死去的子进程的资源使用值*会*被包含在返回的`RUSAGE_CHILDREN`值中。
- en: Process Resource Limits
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程资源限制
- en: Each process has a set of resource limits that can be used to restrict the amounts
    of various system resources that the process may consume. For example, we may
    want to set resource limits on a process before execing an arbitrary program,
    if we are concerned that it may consume excessive resources. We can set the resource
    limits of the shell using the *ulimit* built-in command (*limit* in the C shell).
    These limits are inherited by the processes that the shell creates to execute
    user commands.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一组资源限制，用于限制进程可能消耗的各种系统资源。例如，如果我们担心某个程序可能消耗过多资源，可以在执行任意程序之前对进程设置资源限制。我们可以使用*ulimit*内建命令（在C
    shell中为*limit*）来设置shell的资源限制。这些限制会被shell创建的进程继承，用于执行用户命令。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since kernel 2.6.24, the Linux-specific `/proc/`*PID*`/limits` file can be used
    to view all of the resource limits of any process. This file is owned by the real
    user ID of the corresponding process and its permissions allow reading only by
    that user ID (or by a privileged process).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核2.6.24版本起，Linux特有的`/proc/`*PID*`/limits`文件可以用于查看任何进程的所有资源限制。该文件由相应进程的实际用户ID所有，并且其权限只允许该用户ID（或特权进程）读取。
- en: The *getrlimit()* and *setrlimit()* system calls allow a process to fetch and
    modify its resource limits.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*getrlimit()*和*setrlimit()*系统调用允许进程获取和修改其资源限制。'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 两者成功时返回0，出错时返回-1。
- en: 'The *resource* argument identifies the resource limit to be retrieved or changed.
    The *rlim* argument is used to return resource limit values `(getrlimit())` or
    to specify new resource limit values `(setrlimit())`, and is a pointer to a structure
    containing two fields:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*resource*参数标识要获取或更改的资源限制。*rlim*参数用于返回资源限制值`(getrlimit())`或指定新的资源限制值`(setrlimit())`，并且它是指向一个包含两个字段的结构体的指针：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These fields correspond to the two associated limits for a resource: the *soft*
    (*rlim_cur*) and *hard* (*rlim_max*) limits. (The *rlim_t* data type is an integer
    type.) The soft limit governs the amount of the resource that may be consumed
    by the process. A process can adjust the soft limit to any value from 0 up to
    the hard limit. For most resources, the sole purpose of the hard limit is to provide
    this ceiling for the soft limit. A privileged (`CAP_SYS_RESOURCE`) process can
    adjust the hard limit in either direction (as long as its value remains greater
    than the soft limit), but an unprivileged process can adjust the hard limit only
    to a lower value (irreversibly). The value `RLIM_INFINITY` in *rlim_cur* or *rlim_max*
    means infinity (no limit on the resource), both when retrieved via *getrlimit()*
    and when set via *setrlimit()*.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段对应于资源的两个相关限制：*软限制*（*rlim_cur*）和*硬限制*（*rlim_max*）。（*rlim_t*数据类型是整数类型。）软限制控制进程可以消耗的资源量。进程可以将软限制调整为从0到硬限制的任何值。对于大多数资源，硬限制的唯一目的是为软限制提供上限。特权进程（`CAP_SYS_RESOURCE`）可以在任一方向调整硬限制（只要其值始终大于软限制），但非特权进程只能将硬限制调整为较低的值（不可逆）。在*rlim_cur*或*rlim_max*中的值`RLIM_INFINITY`表示无限（资源没有限制），无论是通过*getrlimit()*获取还是通过*setrlimit()*设置。
- en: In most cases, resource limits are enforced for both privileged and unprivileged
    processes. They are inherited by child processes created via *fork()* and are
    preserved across an *exec()*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，资源限制适用于特权进程和非特权进程。它们会被通过*fork()*创建的子进程继承，并在*exec()*调用过程中保留。
- en: The values that can be specified for the *resource* argument of *getrlimit()*
    and *setrlimit()* are summarized in [Table 36-1](ch36.html#resource_values_for_getrlimit_open_paren
    "Table 36-1. Resource values for getrlimit() and setrlimit()") and detailed in
    Section 36.3.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*getrlimit()*和*setrlimit()*的*resource*参数可以指定的值总结在[表36-1](ch36.html#resource_values_for_getrlimit_open_paren
    "表36-1. getrlimit()和setrlimit()的资源值")中，并在第36.3节中详细描述。'
- en: Although a resource limit is a per-process attribute, in some cases, the limit
    is measured against not just that process’s consumption of the corresponding resource,
    but also against the sum of resources consumed by all processes with the same
    real user ID. The `RLIMIT_NPROC` limit, which places a limit on the number of
    processes that can be created, is a good example of the rationale for this approach.
    Applying this limit against only the number of children that the process itself
    created would be ineffective, since each child that the process created would
    also be able to create further children, which could create more children, and
    so on. Instead, the limit is measured against the count of all processes that
    have the same real user ID. Note, however, that the resource limit is checked
    only in the processes where it has been set (i.e., the process itself and its
    descendants, which inherit the limit). If another process owned by the same real
    user ID has not set the limit (i.e., the limit is infinite) or has set a different
    limit, then that process’s capacity to create children will be checked according
    to the limit that it has set.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管资源限制是每个进程的属性，但在某些情况下，限制不仅针对该进程消耗的相应资源进行衡量，还要衡量所有具有相同实际用户ID的进程所消耗资源的总和。`RLIMIT_NPROC`限制是一个很好的例子，它限制了可创建的进程数量。仅对进程自身创建的子进程数量应用该限制是无效的，因为进程创建的每个子进程也能创建更多的子进程，依此类推。因此，限制是针对所有具有相同实际用户ID的进程的数量进行衡量的。然而，请注意，资源限制仅在设置了限制的进程中检查（即进程本身及其后代，后代继承限制）。如果另一个由相同实际用户ID拥有的进程未设置该限制（即，限制为无限）或设置了不同的限制，则该进程创建子进程的能力将根据其设置的限制进行检查。
- en: As we describe each resource limit below, we note those limits that are measured
    against the resources consumed by all processes with the same real user ID. If
    not otherwise specified, then a resource limit is measured only against the process’s
    own consumption of the resource.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来描述每个资源限制时，我们将指出那些根据所有具有相同实际用户ID的进程所消耗的资源来衡量的限制。如果没有特别说明，那么资源限制仅针对进程自身消耗的资源进行衡量。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that, in many cases, the shell commands for getting and setting resource
    limits (*ulimit* in *bash* and the Korn shell, and *limit* in the C shell) use
    different units from those used in *getrlimit()* and *setrlimit()*. For example,
    the shell commands typically express the limits on the size of various memory
    segments in kilobytes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在许多情况下，获取和设置资源限制的 shell 命令（*bash* 和 Korn shell 中的 *ulimit*，以及 C shell 中的
    *limit*）使用的单位与 *getrlimit()* 和 *setrlimit()* 中使用的单位不同。例如，shell 命令通常以千字节为单位表示各种内存段的大小限制。
- en: Table 36-1. Resource values for *getrlimit()* and *setrlimit()*
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表 36-1. *getrlimit()* 和 *setrlimit()* 的资源值
- en: '| *resource* | Limit on | SUSv3 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| *resource* | 限制 | SUSv3 |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `RLIMIT_AS` | Process virtual memory size (bytes) | • |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_AS` | 进程虚拟内存大小（字节） | • |'
- en: '| `RLIMIT_CORE` | Core file size (bytes) | • |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_CORE` | 核心文件大小（字节） | • |'
- en: '| `RLIMIT_CPU` | CPU time (seconds) | • |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_CPU` | CPU 时间（秒） | • |'
- en: '| `RLIMIT_DATA` | Process data segment (bytes) | • |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_DATA` | 进程数据段（字节） | • |'
- en: '| `RLIMIT_FSIZE` | File size (bytes) | • |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_FSIZE` | 文件大小（字节） | • |'
- en: '| `RLIMIT_MEMLOCK` | Locked memory (bytes) |   |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_MEMLOCK` | 锁定的内存（字节） |   |'
- en: '| `RLIMIT_MSGQUEUE` | Bytes allocated for POSIX message queues for real user
    ID (since Linux 2.6.8) |   |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_MSGQUEUE` | 为实际用户 ID 分配的 POSIX 消息队列字节数（自 Linux 2.6.8 起） |   |'
- en: '| `RLIMIT_NICE` | Nice value (since Linux 2.6.12) |   |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_NICE` | Nice 值（自 Linux 2.6.12 起） |   |'
- en: '| `RLIMIT_NOFILE` | Maximum file descriptor number plus one | • |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_NOFILE` | 最大文件描述符数量加一 | • |'
- en: '| `RLIMIT_NPROC` | Number of processes for real user ID |   |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_NPROC` | 实际用户 ID 的进程数量 |   |'
- en: '| `RLIMIT_RSS` | Resident set size (bytes; not implemented) |   |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_RSS` | 常驻集大小（字节；未实现） |   |'
- en: '| `RLIMIT_RTPRIO` | Realtime scheduling priority (since Linux 2.6.12) |   |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_RTPRIO` | 实时调度优先级（自 Linux 2.6.12 起） |   |'
- en: '| `RLIMIT_RTTIME` | Realtime CPU time (microseconds; since Linux 2.6.25) |
      |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_RTTIME` | 实时 CPU 时间（微秒；自 Linux 2.6.25 起） |   |'
- en: '| `RLIMIT_SIGPENDING` | Number of queued signals for real user ID (since Linux
    2.6.8) |   |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_SIGPENDING` | 实际用户 ID 的已排队信号数量（自 Linux 2.6.8 起） |   |'
- en: '| `RLIMIT_STACK` | Size of stack segment (bytes) | • |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `RLIMIT_STACK` | 栈段大小（字节） | • |'
- en: Example program
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: Before going into the specifics of each resource limit, we look at a simple
    example of the use of resource limits. [Example 36-2](ch36.html#displaying_process_resource_limits
    "Example 36-2. Displaying process resource limits") defines the function *printRlimit()*,
    which displays a message, along with the soft and hard limits for a specified
    resource.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解每个资源限制的具体情况之前，我们先来看一个资源限制使用的简单示例。[示例 36-2](ch36.html#displaying_process_resource_limits
    "示例 36-2. 显示进程资源限制") 定义了 *printRlimit()* 函数，该函数显示一条消息，并显示指定资源的软限制和硬限制。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *rlim_t* data type is typically represented in the same way as *off_t*,
    to handle the representation of `RLIMIT_FSIZE`, the file size resource limit.
    For this reason, when printing *rlim_t* values (as in [Example 36-2](ch36.html#displaying_process_resource_limits
    "Example 36-2. Displaying process resource limits")), we cast them to *long long*
    and use the `%lld` *printf()* specifier, as explained in [I/O on Large Files](ch05.html#i_solidus_o_on_large_files
    "I/O on Large Files").
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*rlim_t* 数据类型通常与 *off_t* 以相同方式表示，用于处理 `RLIMIT_FSIZE`（文件大小资源限制）的表示。因此，当打印 *rlim_t*
    值时（如在 [示例 36-2](ch36.html#displaying_process_resource_limits "示例 36-2. 显示进程资源限制")
    中所示），我们将其强制转换为 *long long* 类型，并使用 `%lld` *printf()* 格式说明符，如在 [大文件 I/O](ch05.html#i_solidus_o_on_large_files
    "大文件 I/O") 中所述。'
- en: 'The program in [Example 36-3](ch36.html#setting_the_rlimit_underscore_nproc_reso
    "Example 36-3. Setting the RLIMIT_NPROC resource limit") calls *setrlimit()* to
    set the soft and hard limits on the number of processes that a user may create
    (`RLIMIT_NPROC`), uses the *printRlimit()* function of [Example 36-2](ch36.html#displaying_process_resource_limits
    "Example 36-2. Displaying process resource limits") to display the limits before
    and after the change, and then creates as many processes as possible. When we
    run this program, setting the soft limit to 30 and the hard limit to 100, we see
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 36-3](ch36.html#setting_the_rlimit_underscore_nproc_reso "示例 36-3. 设置 RLIMIT_NPROC
    资源限制") 中的程序调用 *setrlimit()* 设置用户可以创建的进程数量的软限制和硬限制（`RLIMIT_NPROC`），使用 [示例 36-2](ch36.html#displaying_process_resource_limits
    "示例 36-2. 显示进程资源限制") 的 *printRlimit()* 函数在更改前后显示限制，然后创建尽可能多的进程。当我们运行这个程序时，将软限制设置为
    30，硬限制设置为 100，我们看到以下内容：'
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the program managed to create only 4 new processes, because
    26 processes were already running for this user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序只成功创建了4个新进程，因为该用户已经有26个进程在运行。
- en: Example 36-2. Displaying process resource limits
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 36-2. 显示进程资源限制
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 36-3. Setting the `RLIMIT_NPROC` resource limit
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 36-3. 设置`RLIMIT_NPROC`资源限制
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unrepresentable limit values
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无法表示的限制值
- en: In some programming environments, the *rlim_t* data type may not be able to
    represent the full range of values that could be maintained for a particular resource
    limit. This may be the case on a system that offers multiple programming environments
    in which the size of the *rlim_t* data type differs. Such systems can arise if
    a large-file compilation environment with a 64-bit *off_t* is added to a system
    on which *off_t* was traditionally 32 bits. (In each environment, *rlim_t* would
    be the same size as *off_t*.) This leads to the situation where a program with
    a small *rlim_t* can, after being execed by a program with a 64-bit *off_t*, inherit
    a resource limit (e.g., the file size limit) that is greater than the maximum
    *rlim_t* value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些编程环境中，*rlim_t*数据类型可能无法表示某个特定资源限制的完整值范围。比如在提供多个编程环境的系统中，*rlim_t*数据类型的大小可能有所不同。这种情况可能发生在系统中添加了一个大文件编译环境（即设置`_FILE_OFFSET_BITS`特性测试宏为64，如[大型文件的I/O](ch05.html#i_solidus_o_on_large_files
    "大型文件的I/O")所述），而系统中的*off_t*传统上是32位的（在每个环境中，*rlim_t*的大小将与*off_t*相同）。这会导致一种情况：一个小型*rlim_t*的程序在被一个64位*off_t*的程序执行后，可能会继承一个超过最大*rlim_t*值的资源限制（例如，文件大小限制）。
- en: 'To assist portable applications in handling the possibility that a resource
    limit may be unrepresentable, SUSv3 specifies two constants to indicate unrepresentable
    limit values: `RLIM_SAVED_CUR` and `RLIM_SAVED_MAX`. If a soft resource limit
    can’t be represented in *rlim_t*, then *getrlimit()* will return `RLIM_SAVED_CUR`
    in the *rlim_cur* field. `RLIM_SAVED_MAX` performs an analogous function for an
    unrepresentable hard limit returned in the *rlim_max* field.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可移植的应用程序处理资源限制无法表示的情况，SUSv3规定了两个常量来表示无法表示的限制值：`RLIM_SAVED_CUR`和`RLIM_SAVED_MAX`。如果软资源限制无法在*rlim_t*中表示，那么*getrlimit()*会在*rlim_cur*字段中返回`RLIM_SAVED_CUR`。`RLIM_SAVED_MAX`在*rlim_max*字段中对无法表示的硬限制执行类似的功能。
- en: 'If all possible resource limit values can be represented in *rlim_t*, then
    SUSv3 permits an implementation to define `RLIM_SAVED_CUR` and `RLIM_SAVED_MAX`
    to be the same as `RLIM_INFINITY`. This is how these constants are defined on
    Linux, implying that all possible resource limit values can be represented in
    *rlim_t*. However, this is not the case on 32-bit architectures such as x86-32\.
    On those architectures, in a large-file compilation environment (i.e., setting
    the `_FILE_OFFSET_BITS` feature test macro to 64 as described in [I/O on Large
    Files](ch05.html#i_solidus_o_on_large_files "I/O on Large Files")), the *glibc*
    definition of *rlim_t* is 64 bits wide, but the kernel data type for representing
    a resource limit is *unsigned long*, which is only 32 bits wide. Current versions
    of *glibc* deal with this situation as follows: if a program compiled with `_FILE_OFFSET_BITS=64`
    tries to set a resource limit to a value larger than can be represented in a 32-bit
    *unsigned long*, then the *glibc* wrapper for *setrlimit()* silently converts
    the value to `RLIM_INFINITY`. In other words, the requested setting of the resource
    limit is not honored.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有可能的资源限制值都能在*rlim_t*中表示，那么SUSv3允许实现将`RLIM_SAVED_CUR`和`RLIM_SAVED_MAX`定义为与`RLIM_INFINITY`相同。这就是Linux上如何定义这些常量的方式，意味着所有可能的资源限制值都可以在*rlim_t*中表示。然而，在像x86-32这样的32位架构上并非如此。在这些架构中，在一个大文件编译环境中（即如[大型文件的I/O](ch05.html#i_solidus_o_on_large_files
    "大型文件的I/O")中所述，将`_FILE_OFFSET_BITS`特性测试宏设置为64），*glibc*对*rlim_t*的定义是64位的，但表示资源限制的内核数据类型是*unsigned
    long*，只有32位宽。当前版本的*glibc*对此问题的处理方式如下：如果一个使用`_FILE_OFFSET_BITS=64`编译的程序尝试设置一个大于32位*unsigned
    long*能表示的资源限制值，*glibc*包装函数*setrlimit()*会默默地将该值转换为`RLIM_INFINITY`。换句话说，请求的资源限制设置不会生效。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because utilities that handle files are normally compiled with `_FILE_OFFSET_BITS=64`
    in many x86-32 distributions, the failure to honor resource limits larger than
    the value that can be represented in 32 bits is a problem that can affect not
    only application programmers, but also end users.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在许多x86-32发行版中处理文件的工具通常使用`_FILE_OFFSET_BITS=64`进行编译，所以无法处理超过32位能表示的资源限制这一问题，不仅会影响到应用程序开发者，也会影响最终用户。
- en: One could argue that it might be better for the *glibc setrlimit()* wrapper
    to give an error if the requested resource limit exceeds the capacity of a 32-bit
    *unsigned long*. However, the fundamental problem is a kernel limitation, and
    the behavior described in the main text is the approach that the *glibc* developers
    have taken to dealing with it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会争辩，*glibc setrlimit()* 包装器应该在请求的资源限制超过 32 位 *unsigned long* 的容量时给出错误。然而，根本问题是内核的限制，主文中描述的行为是
    *glibc* 开发者处理该问题的方式。
- en: Details of Specific Resource Limits
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定资源限制的详细信息
- en: In this section, we provide details on each of the resource limits available
    on Linux, noting those that are Linux-specific.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了有关 Linux 上每个资源限制的详细信息，并指出那些特定于 Linux 的限制。
- en: '`RLIMIT_AS`'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_AS`'
- en: The `RLIMIT_AS` limit specifies the maximum size for the process’s virtual memory
    (address space), in bytes. Attempts (*brk()*, *sbrk()*, *mmap()*, *mremap()*,
    and *shmat()*) to exceed this limit fail with the error `ENOMEM`. In practice,
    the most common place where a program may hit this limit is in calls to functions
    in the *malloc* package, which make use of *sbrk()* and *mmap()*. Upon encountering
    this limit, stack growth can also fail with the consequences listed below for
    `RLIMIT_STACK`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_AS` 限制指定了进程虚拟内存（地址空间）的最大大小，以字节为单位。尝试（*brk()*, *sbrk()*, *mmap()*, *mremap()*,
    和 *shmat()*）超过此限制会失败，并返回 `ENOMEM` 错误。在实践中，程序最常遇到此限制的地方是在调用 *malloc* 包中的函数时，这些函数使用了
    *sbrk()* 和 *mmap()*。遇到此限制时，栈的增长也可能失败，后果如下所述的 `RLIMIT_STACK`。'
- en: '`RLIMIT_CORE`'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_CORE`'
- en: The `RLIMIT_CORE` limit specifies the maximum size, in bytes, for core dump
    files produced when a process is terminated by certain signals ([Core Dump Files](ch22.html#core_dump_files
    "Core Dump Files")). Production of a core dump file will stop at this limit. Specifying
    a limit of 0 prevents creation of core dump files, which is sometimes useful because
    core dump files can be very large, and end users usually don’t know what to do
    with them. Another reason for disabling core dumps is security—to prevent the
    contents of a program’s memory from being dumped to disk. If the `RLIMIT_FSIZE`
    limit is lower than this limit, core dump files are limited to `RLIMIT_FSIZE`
    bytes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_CORE` 限制指定了在进程因某些信号终止时生成的核心转储文件的最大大小，以字节为单位（[核心转储文件](ch22.html#core_dump_files
    "核心转储文件")）。在达到此限制时，将停止生成核心转储文件。指定 0 限制会阻止创建核心转储文件，这在某些情况下很有用，因为核心转储文件可能非常大，而且最终用户通常不知道如何处理它们。禁用核心转储的另一个原因是出于安全考虑——防止程序内存的内容被转储到磁盘。如果
    `RLIMIT_FSIZE` 限制低于此限制，则核心转储文件的大小将被限制为 `RLIMIT_FSIZE` 字节。'
- en: '`RLIMIT_CPU`'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_CPU`'
- en: The `RLIMIT_CPU` limit specifies the maximum number of seconds of CPU time (in
    both system and user mode) that can be used by the process. SUSv3 requires that
    the `SIGXCPU` signal be sent to the process when the soft limit is reached, but
    leaves other details unspecified. (The default action for `SIGXCPU` is to terminate
    a process with a core dump.) It is possible to establish a handler for `SIGXCPU`
    that does whatever processing is desired and then returns control to the main
    program. Thereafter, (on Linux) `SIGXCPU` is sent once per second of consumed
    CPU time. If the process continues executing until the hard CPU limit is reached,
    then the kernel sends it a `SIGKILL` signal, which always terminates the process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_CPU` 限制指定了进程可以使用的最大 CPU 时间（系统模式和用户模式下的时间，以秒为单位）。SUSv3 要求在软限制达到时发送 `SIGXCPU`
    信号，但没有指定其他细节。（`SIGXCPU` 的默认操作是终止进程并生成核心转储。）可以为 `SIGXCPU` 设置一个处理程序，执行所需的任何处理后再返回控制权给主程序。此后，（在
    Linux 上）每消耗一秒的 CPU 时间，都会发送一次 `SIGXCPU` 信号。如果进程继续执行，直到达到硬 CPU 限制，则内核会发送 `SIGKILL`
    信号，这总是会终止进程。'
- en: UNIX implementations vary in the details of how they deal with processes that
    continue consuming CPU time after handling a `SIGXCPU` signal. Most continue to
    deliver `SIGXCPU` at regular intervals. If aiming for portable use of this signal,
    we should code an application so that, on first receipt of this signal, it does
    whatever cleanup is required and terminates. (Alternatively, the program could
    change the resource limit after receiving the signal.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 实现对于如何处理在处理 `SIGXCPU` 信号后仍继续消耗 CPU 时间的进程在细节上有所不同。大多数实现会继续定期发送 `SIGXCPU`
    信号。如果目标是信号的可移植使用，我们应该编写应用程序，使其在第一次收到该信号时，执行所需的清理操作并终止。（或者，程序也可以在收到信号后更改资源限制。）
- en: '`RLIMIT_DATA`'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_DATA`'
- en: The `RLIMIT_DATA` limit specifies the maximum size, in bytes, of the process’s
    data segment (the sum of the initialized data, uninitialized data, and heap segments
    described in [Memory Layout of a Process](ch06.html#memory_layout_of_a_process
    "Memory Layout of a Process")). Attempts (*sbrk()* and *brk()*) to extend the
    data segment (program break) beyond this limit fail with the error `ENOMEM`. As
    with `RLIMIT_AS`, the most common place where a program may hit this limit is
    in calls to functions in the *malloc* package.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_DATA`限制指定进程数据段的最大大小，以字节为单位（包括已初始化数据、未初始化数据和堆段，详见[进程内存布局](ch06.html#memory_layout_of_a_process
    "Memory Layout of a Process")）。尝试通过`sbrk()`和`brk()`扩展数据段（程序断点）超出该限制时，会失败并返回错误`ENOMEM`。与`RLIMIT_AS`类似，程序遇到此限制最常见的地方是在调用*malloc*包中的函数时。'
- en: '`RLIMIT_FSIZE`'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_FSIZE`'
- en: The `RLIMIT_FSIZE` limit specifies the maximum size of files that the process
    may create, in bytes. If a process attempts to extend a file beyond the soft limit,
    it is sent a `SIGXFSZ` signal, and the system call (e.g., *write()* or *truncate()*)
    fails with the error `EFBIG`. The default action for `SIGXFSZ` is to terminate
    a process and produce a core dump. It is possible to instead catch this signal
    and return control to the main program. However, any further attempt to extend
    the file will yield the same signal and error.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_FSIZE`限制指定进程可以创建的文件的最大大小，以字节为单位。如果进程尝试将文件扩展到超出软限制的大小，它会收到`SIGXFSZ`信号，并且系统调用（例如，*write()*
    或 *truncate()*) 将因错误`EFBIG`而失败。`SIGXFSZ`的默认动作是终止进程并生成核心转储。也可以捕获此信号，并将控制权返回给主程序。然而，任何进一步尝试扩展文件的操作都会触发相同的信号和错误。'
- en: '`RLIMIT_MEMLOCK`'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_MEMLOCK`'
- en: The `RLIMIT_MEMLOCK` limit (BSD-derived; absent from SUSv3 and available only
    on Linux and the BSDs) specifies the maximum number of bytes of virtual memory
    that a process may lock into physical memory, to prevent the memory from being
    swapped out. This limit affects the *mlock()* and *mlockall()* system calls, and
    the locking options for the *mmap()* and *shmctl()* system calls. We describe
    the details in Section 50.2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_MEMLOCK`限制（源自BSD；SUSv3中没有，仅在Linux和BSD系统上可用）指定进程可以锁定到物理内存中的虚拟内存的最大字节数，以防止内存被换出。此限制影响*mlock()*和*mlockall()*系统调用，以及*mmap()*和*shmctl()*系统调用的锁定选项。我们在第50.2节中描述了详细信息。'
- en: If the `MCL_FUTURE` flag is specified when calling *mlockall()*, then the `RLIMIT_MEMLOCK`
    limit may also cause later calls to *brk()*, *sbrk()*, *mmap()*, or *mremap()*
    to fail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用*mlockall()*时指定了`MCL_FUTURE`标志，则`RLIMIT_MEMLOCK`限制还可能导致之后调用*brk()*, *sbrk()*,
    *mmap()*或*mremap()*失败。
- en: '`RLIMIT_MSGQUEUE`'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_MSGQUEUE`'
- en: 'The `RLIMIT_MSGQUEUE` limit (Linux-specific; since Linux 2.6.8) specifies the
    maximum number of bytes that can be allocated for POSIX message queues for the
    real user ID of the calling process. When a POSIX message queue is created using
    *mq_open()*, bytes are deducted against this limit according to the following
    formula:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_MSGQUEUE`限制（Linux特有；自Linux 2.6.8开始）指定可以为调用进程的真实用户ID分配的POSIX消息队列的最大字节数。当使用*mq_open()*创建POSIX消息队列时，字节数会根据以下公式从此限制中扣除：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this formula, *attr* is the *mq_attr* structure that is passed as the fourth
    argument to *mq_open()*. The addend that includes *sizeof(struct msg_msg *)* ensures
    that the user can’t queue an unlimited number of zero-length messages. (The *msg_msg*
    structure is a data type used internally by the kernel.) This is necessary because,
    although zero-length messages contain no data, they do consume some system memory
    for bookkeeping overhead.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，*attr*是作为第四个参数传递给*mq_open()*的*mq_attr*结构体。包含*sizeof(struct msg_msg *)*的加数确保用户不能排队无限数量的零长度消息。（*msg_msg*结构是内核内部使用的数据类型。）这是必要的，因为尽管零长度消息不包含任何数据，但它们确实会消耗一些系统内存用于账本管理开销。
- en: The `RLIMIT_MSGQUEUE` limit affects only the calling process. Other processes
    belonging to this user are not affected unless they also set this limit or inherit
    it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_MSGQUEUE`限制仅影响调用进程。其他属于该用户的进程不会受到影响，除非它们也设置此限制或继承了此限制。'
- en: '`RLIMIT_NICE`'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_NICE`'
- en: The `RLIMIT_NICE` limit (Linux-specific; since Linux 2.6.12) specifies a ceiling
    on the nice value that may be set for this process using *sched_setscheduler()*
    and *nice()*. The ceiling is calculated as *20 – rlim_cur*, where *rlim_cur* is
    the current `RLIMIT_NICE` soft resource limit. Refer to [Process Priorities (Nice
    Values)](ch35.html#process_priorities_open_parenthesis_nice "Process Priorities
    (Nice Values)") for further details.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_NICE`限制（特定于Linux，适用于Linux 2.6.12及以后版本）指定可以使用*sched_setscheduler()*和*nice()*为进程设置的优先级值的上限。上限计算方式为*20
    – rlim_cur*，其中*rlim_cur*是当前`RLIMIT_NICE`软资源限制的值。有关更多详细信息，请参阅[进程优先级（Nice值）](ch35.html#process_priorities_open_parenthesis_nice
    "进程优先级（Nice值）")。'
- en: '`RLIMIT_NOFILE`'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`RLIMIT_NOFILE`'
- en: The `RLIMIT_NOFILE` limit specifies a number one greater than the maximum file
    descriptor number that a process may allocate. Attempts (e.g., *open()*, *pipe()*,
    *socket()*, *accept()*, *shm_open()*, *dup()*, *dup2()*, *fcntl(F_DUPFD)*, and
    *epoll_create()*) to allocate descriptors beyond this limit fail. In most cases,
    the error is `EMFILE`, but for *dup2(fd, newfd)* it is `EBADF`, and for *fcntl(fd,
    F_DUPFD, newfd)* with *newfd* is greater than or equal to the limit, it is `EINVAL`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLIMIT_NOFILE`限制指定一个数字，比进程可以分配的最大文件描述符号大1。尝试（例如，*open()*, *pipe()*, *socket()*,
    *accept()*, *shm_open()*, *dup()*, *dup2()*, *fcntl(F_DUPFD)*, 和 *epoll_create()*)分配超过此限制的描述符将失败。在大多数情况下，错误是`EMFILE`，但对于*dup2(fd,
    newfd)*，错误是`EBADF`；对于*fcntl(fd, F_DUPFD, newfd)*，如果*newfd*大于或等于限制，错误是`EINVAL`。'
- en: Changes to the `RLIMIT_NOFILE` limit are reflected in the value returned by
    *sysconf(_SC_OPEN_MAX)*. SUSv3 permits, but doesn’t require, an implementation
    to return different values for a call to *sysconf(_SC_OPEN_MAX)* before and after
    changing the `RLIMIT_NOFILE` limit; other implementations may not behave the same
    as Linux on this point.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对`RLIMIT_NOFILE`限制的更改会反映在*sysconf(_SC_OPEN_MAX)*返回的值中。SUSv3允许但不要求实现返回在更改`RLIMIT_NOFILE`限制前后对*sysconf(_SC_OPEN_MAX)*调用的不同值；其他实现可能在这一点上与Linux的行为不同。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 states that if an application sets the soft or hard `RLIMIT_NOFILE` limit
    to a value less than or equal to the number of the highest file descriptor that
    the process currently has open, unexpected behavior may occur.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果应用程序将软限制或硬限制`RLIMIT_NOFILE`设置为小于或等于当前进程已打开的最高文件描述符的值，则可能会出现意外行为。
- en: On Linux, we can check which file descriptors a process currently has open by
    using *readdir()* to scan the contents of the `/proc/`*PID*`/fd` directory, which
    contains symbolic links for each of the file descriptors currently opened by the
    process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，我们可以使用*readdir()*扫描`/proc/`*PID*`/fd`目录的内容，检查进程当前打开了哪些文件描述符，该目录包含每个当前已打开文件描述符的符号链接。
- en: The kernel imposes a ceiling on the value to which the `RLIMIT_NOFILE` limit
    may be raised. In kernels before 2.6.25, this ceiling is a hard-coded value defined
    by the kernel constant `NR_OPEN`, whose value is 1,048,576\. (A kernel rebuild
    is required to raise this ceiling.) Since kernel 2.6.25, the limit is defined
    by the value in the Linux-specific `/proc/sys/fs/nr_open` file. The default value
    in this file is 1,048,576; this can be modified by the superuser. Attempts to
    set the soft or hard `RLIMIT_NOFILE` limit higher than the ceiling value yield
    the error `EPERM`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对`RLIMIT_NOFILE`限制可以提高的值施加了上限。在2.6.25之前的内核中，这个上限是由内核常量`NR_OPEN`定义的硬编码值，其值为1,048,576（要提高此上限，需要重新构建内核）。自2.6.25内核以来，该限制由Linux特有的`/proc/sys/fs/nr_open`文件中的值定义。该文件中的默认值是1,048,576；超级用户可以修改此值。尝试将软限制或硬限制`RLIMIT_NOFILE`设置为高于此上限的值将返回错误`EPERM`。
- en: There is also a system-wide limit on the total number of files that may be opened
    by all processes. This limit can be retrieved and modified via the Linux-specific
    `/proc/sys/fs/file-max` file. (Referring to [Relationship Between File Descriptors
    and Open Files](ch05.html#relationship_between_file_descriptors_an "Relationship
    Between File Descriptors and Open Files"), we can define `file-max` more precisely
    as a system-wide limit on the number of open file descriptions.) Only privileged
    (`CAP_SYS_ADMIN`) processes can exceed the `file-max` limit. In an unprivileged
    process, a system call that encounters the `file-max` limit fails with the error
    `ENFILE`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`RLIMIT_NPROC`'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `RLIMIT_NPROC` limit (BSD-derived; absent from SUSv3 and available only
    on Linux and the BSDs) specifies the maximum number of processes that may be created
    for the real user ID of the calling process. Attempts (*fork()*, *vfork()*, and
    *clone()*) to exceed this limit fail with the error `EAGAIN`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The `RLIMIT_NPROC` limit affects only the calling process. Other processes belonging
    to this user are not affected unless they also set or inherit this limit. This
    limit is not enforced for privileged (`CAP_SYS_ADMIN` or `CAP_SYS_RESOURCE`) processes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux also imposes a system-wide limit on the number of processes that can be
    created by all users. On Linux 2.4 and later, the Linux-specific `/proc/sys/kernel/threads-max`
    file can be used to retrieve and modify this limit.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: To be precise, the `RLIMIT_NPROC` resource limit and the `threads-max` file
    are actually limits on the numbers of threads that can be created, rather than
    the number of processes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The manner in which the default value for the `RLIMIT_NPROC` resource limit
    is set has varied across kernel versions. In Linux 2.2, it was calculated according
    to a fixed formula. In Linux 2.4 and later, it is calculated using a formula based
    on the amount of available physical memory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 doesn’t specify the `RLIMIT_NPROC` resource limit. The SUSv3-mandated
    method for retrieving (but not changing) the maximum number of processes permitted
    to a user ID is via the call *sysconf(_SC_CHILD_MAX)*. This *sysconf()* call is
    supported on Linux, but in kernel versions before 2.6.23, the call does not return
    accurate information—it always returns the value 999\. Since Linux 2.6.23 (and
    with *glibc* 2.4 and later), this call correctly reports the limit (by checking
    the value of the `RLIMIT_NPROC` resource limit).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no portable way of discovering how many processes have already been
    created for a specific user ID. On Linux, we can try scanning all of the `/proc/`*PID*`/status`
    files on the system and examining the information under the `Uid` entry (which
    lists the four process user IDs in the order: real, effective, saved set, and
    file system) in order to estimate the number of processes currently owned by a
    user. Be aware, however, that by the time we have completed such a scan, this
    information may already have changed.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '`RLIMIT_RSS`'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `RLIMIT_RSS` limit (BSD-derived; absent from SUSv3, but widely available)
    specifies the maximum number of pages in the process’s resident set; that is,
    the total number of virtual memory pages currently in physical memory. This limit
    is provided on Linux, but it currently has no effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In older Linux 2.4 kernels (up to and including 2.4.29), `RLIMIT_RSS` did have
    an effect on the behavior of the *madvise()* `MADV_WILLNEED` operation ([Advising
    Future Memory Usage Patterns: *madvise()*](ch50.html#advising_future_memory_usage_patterns_co
    "Advising Future Memory Usage Patterns: madvise()")). If this operation could
    not be performed as a result of encountering the `RLIMIT_RSS` limit, the error
    `EIO` was returned in *errno*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '`RLIMIT_RTPRIO`'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `RLIMIT_RTPRIO` limit (Linux-specific; since Linux 2.6.12) specifies a ceiling
    on the realtime priority that may be set for this process using *sched_setscheduler()*
    and *sched_setparam()*. Refer to [Modifying and Retrieving Policies and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr
    "Modifying and Retrieving Policies and Priorities") for further details.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`RLIMIT_RTTIME`'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `RLIMIT_RTTIME` limit (Linux-specific; since Linux 2.6.25) specifies the
    maximum amount of CPU time in microseconds that a process running under a realtime
    scheduling policy may consume without sleeping (i.e., performing a blocking system
    call). The behavior if this limit is reached is the same as for `RLIMIT_CPU`:
    if the process reaches the soft limit, then a `SIGXCPU` signal is sent to the
    process, and further `SIGXCPU` signals are sent for each additional second of
    CPU time consumed. On reaching the hard limit, a `SIGKILL` signal is sent. Refer
    to [Modifying and Retrieving Policies and Priorities](ch35.html#modifying_and_retrieving_policies_and_pr
    "Modifying and Retrieving Policies and Priorities") for further details.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`RLIMIT_SIGPENDING`'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `RLIMIT_SIGPENDING` limit (Linux-specific; since Linux 2.6.8) specifies
    the maximum number of signals that may be queued for the real user ID of the calling
    process. Attempts (*sigqueue()*) to exceed this limit fail with the error `EAGAIN`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The `RLIMIT_SIGPENDING` limit affects only the calling process. Other processes
    belonging to this user are not affected unless they also set or inherit this limit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As initially implemented, the default value for the `RLIMIT_SIGPENDING` limit
    was 1024\. Since kernel 2.6.12, the default value has been changed to be the same
    as the default value for `RLIMIT_NPROC`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of checking the `RLIMIT_SIGPENDING` limit, the count of queued
    signals includes both realtime and standard signals. (Standard signals can be
    queued only once to a process.) However, this limit is enforced only for *sigqueue()*.
    Even if the number of signals specified by this limit has already been queued
    to processes belonging to this real user ID, it is still possible to use *kill()*
    to queue one instance of each of the signals (including realtime signals) that
    are not already queued to a process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: From kernel 2.6.12 onward, the `SigQ` field of the Linux-specific `/proc/`*PID*`/status`
    file displays the current and maximum number of queued signals for the real user
    ID of the process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '`RLIMIT_STACK`'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `RLIMIT_STACK` limit specifies the maximum size of the process stack, in
    bytes. Attempts to grow the stack beyond this limit result in the generation of
    a `SIGSEGV` signal for the process. Since the stack is exhausted, the only way
    to catch this signal is by establishing an alternate signal stack, as described
    in Section 21.3.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Linux 2.6.23, the `RLIMIT_STACK` limit also determines the amount of space
    available for holding the process’s command-line arguments and environment variables.
    See the *execve(2)* manual page for details.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processes consume various system resources. The *getrusage()* system call allows
    a process to monitor certain of the resources consumed by itself and by its children.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The *setrlimit()* and *getrlimit()* system calls allow a process to set and
    retrieve limits on its consumption of various resources. Each resource limit has
    two components: a soft limit, which is what the kernel enforces when checking
    a process’s resource consumption, and a hard limit, which acts as a ceiling on
    the value of the soft limit. An unprivileged process can set the soft limit for
    a resource to any value in the range from 0 up to the hard limit, but can only
    lower the hard limit. A privileged process can make any changes to either limit
    value, as long as the soft limit is less than or equal to the hard limit. If a
    process encounters a soft limit, it is typically informed of the fact either by
    receiving a signal or via failure of the system call that attempts to exceed the
    limit.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program that shows that the *getrusage()* `RUSAGE_CHILDREN` flag retrieves
    information about only the children for which a *wait()* call has been performed.
    (Have the program create a child process that consumes some CPU time, and then
    have the parent call *getrusage()* before and after calling *wait()*.)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a program that executes a command and then displays its resource usage.
    This is analogous to what the *time(1)* command does. Thus, we would use this
    program as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Write programs to determine what happens if a process’s consumption of various
    resources already exceeds the soft limit specified in a call to *setrlimit()*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
