- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly Text Basics
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll dive into the basics of WAT code. We’ll write most of
    the code in this book in WAT, the lowest level of programming you can write for
    deployment to WebAssembly (although for experienced assembly coders, it might
    seem rather high level).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers a lot of ground. We’ll begin by showing you the two comment
    styles in WebAssembly. Next, we’ll write the traditional hello world application.
    We don’t start with hello world because working with strings from within WAT is
    more challenging than you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: Then we’ll discuss how to import data from JavaScript into our WebAssembly module
    using an import object. We’ll look at named and unnamed global and local variables,
    as well as the data types that WebAssembly supports. We’ll discuss the S-Expression
    syntax and how the `wat2wasm` compiler unpacks those S-Expressions when it compiles
    your code. You’ll delve into conditional logic, including `if`/`else` statements
    and branch tables, and you’ll learn how to use loops and blocks in conjunction
    with conditional logic.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to write simple WebAssembly apps
    that you can execute from the command line using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Simplest Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every WAT application must be a module, so we’ll first look at the module syntax.
    We declare a module in a block, like the one in [Listing 2-1](#listing2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: Single line WAT comment'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a module with the `module` keyword, and anything inside the surrounding
    parentheses is part of the module. To add a comment, we use two semicolons `;;`
    , and everything on the line that follows is a comment. WAT also has block comment
    syntax; you open the block comment with `(;` and close it with `;)` , as shown
    in [Listing 2-2](#listing2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: Multi-line WAT comment'
  prefs: []
  type: TYPE_NORMAL
- en: Because this module doesn’t do anything, we won’t bother to compile it. Instead,
    we’ll move on to writing our hello world application.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World in WebAssembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WAT doesn’t have any native string support, so working with strings requires
    you to work directly with memory as an array of character data. That memory data
    then must be converted into a string in JavaScript code, because manipulating
    strings from within JavaScript is much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings in WAT, you need to declare an array of character
    data that is stored within WebAssembly linear memory. Linear memory is a topic
    we’ll discuss in detail in Chapter 6, but for now know that linear memory is similar
    to a memory heap in native applications, or a giant typed array in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to call an imported JavaScript function from WebAssembly to
    handle I/O operations. Unlike in a native application where the operating system
    usually handles I/O, in a WebAssembly module, I/O must be handled by the embedding
    environment, whether that environment is a web browser, an operating system, or
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Our WAT Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll create a simple WebAssembly module that creates a `hello
    world!` string in linear memory and calls JavaScript to write that string to the
    console. Create a new WAT file and name it *helloworld.wat*. Open that file and
    add the WAT code in [Listing 2-3](#listing2-3).
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: Importing a function'
  prefs: []
  type: TYPE_NORMAL
- en: This code tells WebAssembly to expect the import object `env` from our embedding
    environment, and that within that object we’re expecting the function `print_string`.
    When we write our JavaScript code later, we’ll create this `env` object with the
    `print_string` function, which will be passed to our WebAssembly module when we
    instantiate it.
  prefs: []
  type: TYPE_NORMAL
- en: We also set up the signature as requiring a single `i32` parameter representing
    the length of our string. We name this function `$print_string` so we can access
    it from our WAT code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add an import for our memory buffer. Add the line in bold in [Listing
    2-4](#listing2-4).
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: Importing a function and memory buffer'
  prefs: []
  type: TYPE_NORMAL
- en: 'This new `import` tells our WebAssembly module that we’ll be importing a memory
    buffer from the object `env` and the buffer will be called `buffer`. The `(memory`
    `1)` statement indicates that the buffer will be a single page of linear memory:
    a *page* is the smallest chunk of memory you can allocate at one time to linear
    memory. In WebAssembly, a page is 64KB, which is more than we need for this module,
    so we need just one page. Next, in [Listing 2-5](#listing2-5), we add a few global
    variables to *helloworld.wat*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: Adding global variables'
  prefs: []
  type: TYPE_NORMAL
- en: The first `global` 1 variable is a number imported from our JavaScript import
    object; it maps to a variable with the name `env` in JavaScript (which we’ve yet
    to create). That value will be the starting memory location of our string and
    can be any location in our linear memory page up to the maximum 65,535\. Of course,
    you wouldn’t want to choose a value close to the end of linear memory because
    it would limit the length of the string you could store. If the value passed in
    is `0`, you can use the entire 64KB for your string. If you passed in the value
    `65,532`, you would only be able to use the last four bytes to store character
    data. If you try to write to a memory location that is greater than what was allocated,
    you’ll get a memory error in your JavaScript console. The second global variable,
    `$string_len` 2, is a constant that represents the length of the string we’ll
    define, and we set it to `12`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-6](#listing2-6), we define our string in linear memory using a
    data expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: Adding a data string'
  prefs: []
  type: TYPE_NORMAL
- en: We first pass the location in memory where the module will write data. The data
    is stored in the `$start_string` global variable that the module will import from
    JavaScript. The second parameter is the data string, which we define as the string
    `"hello world!"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can define our `"helloworld"` function and add it to the module, as shown
    in [Listing 2-7](#listing2-7).
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: Adding a `"``helloworld``"` function to the WebAssembly module'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define and export our function as `"helloworld"` for use in JavaScript 1.
    The only thing this function does is call the imported `$print_string` 2 function,
    passing it the length of the string we defined as a global. We can now compile
    our WebAssembly module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running `wat2wasm` generates a *helloworld.wasm* module. To execute the WebAssembly
    module, we’ll need to create a JavaScript file that executes it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the JavaScript File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create *helloworld.js* to run our WebAssembly module. Create and open
    the JavaScript file in your text editor, and add the Node.js file constants as
    well as three variables, as shown in [Listing 2-8](#listing2-8).
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: Declaring the JavaScript variables'
  prefs: []
  type: TYPE_NORMAL
- en: The `hello_world` 1 variable will eventually point to the `helloworld` function
    exported by our WebAssembly module, so we set it to `null` for the time being.
    The `start_string_index` 2 variable is the starting location of our string in
    the linear memory array. We set it to `100` here, so as not to be close to the
    64KB limit. We chose the address 100 arbitrarily. You can choose any address as
    long as none of the memory you’re using extends past the 64KB limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last variable holds the `WebAssembly.Memory` 3 object. The number passed
    represents the number of pages you want to allocate. We initialize it with a size
    of one page by passing in `{initial: 1}` as the only parameter. You can allocate
    up to two gigabytes this way, but setting this value too high can result in an
    error if the browser is unable to find enough contiguous memory to fulfill the
    request.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-9](#listing2-9) shows the next variable we need to declare, `importObject`,
    which will be passed into our WebAssembly module when we instantiate it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: Declaring the `importObject` in JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: Inside our `importObject`, we add an object named `env` 1, an abbreviation of
    *environment*, although you can call this object anything you like as long as
    it matches the name inside the WebAssembly import declaration. These are the values
    that will be passed into the WebAssembly module when it’s instantiated. If there
    is any function or value from the embedding environment you want to make available
    to the WebAssembly module, pass them in here. The `env` object contains the memory
    buffer 2 and the starting location 3 of our string within `buffer`. The third
    property in `env` 4 contains our JavaScript function, `print_string`, which our
    WebAssembly module will call as we instructed in [Listing 2-9](#listing2-9). This
    function retrieves the length of the string in our memory buffer and uses it in
    combination with our starting string index to create a string object. The app
    then displays the string object on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we add the IIFE that asynchronously loads our WebAssembly module
    and then calls the `helloworld` function, as shown in [Listing 2-10](#listing2-10).
  prefs: []
  type: TYPE_NORMAL
- en: '**helloworld.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-10: Instantiating the WebAssembly module in an asynchronous IIFE'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the `async` module awaits the `WebAssembly.instantiate` 1
    function call, but unlike the simple addition example from Listing 1-1, we’re
    passing that function the `importObject` we declared earlier. We then pull the
    `helloworld` function out of `obj.instance.exports` using the destructuring syntax
    to set the `hello_world` variable to the `obj.instance.exports` function 2.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of our IIFE calls the `hello_world` 3 function. We enclose our
    arrow function in parentheses, and then add the function call parentheses to the
    end of our function declaration, which causes this function to execute immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
