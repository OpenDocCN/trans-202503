- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PONG</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PONG</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: 'In this first project, you’ll use JavaScript to re-create one of the first
    arcade video games: the classic *Pong* from Atari. *Pong* is a simple game, but
    it will teach you some important aspects of game design: a game loop, player input,
    collision detection, and score keeping. We’ll even use some basic artificial intelligence
    to program the computer opponent.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个项目中，你将使用JavaScript重新创建第一个街机视频游戏之一：Atari经典的*Pong*。*Pong*是一个简单的游戏，但它将教会你一些游戏设计的重要方面：游戏循环、玩家输入、碰撞检测和记分。我们甚至会使用一些基本的人工智能来编程计算机对手。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">游戏</samp>
- en: '*Pong* was developed in 1972 and was released that year as a hugely successful
    arcade machine. It’s a very basic game, like table tennis, consisting of a ball
    and two paddles positioned on the left and right sides of the screen, which the
    players can move up and down. If the ball hits the top or bottom edge of the screen,
    it bounces off, but if it hits the left or right edge the player on the opposite
    side scores a point. The ball bounces off the paddles normally, unless it hits
    near the top or bottom edge of the paddle, in which case the angle of return changes.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pong*于1972年开发，并在同年作为一款极为成功的街机游戏机发布。这是一个非常基础的游戏，类似乒乓球，由一个球和两个挡板组成，挡板分别位于屏幕的左右两侧，玩家可以上下移动它们。如果球碰到屏幕的顶部或底部边缘，它会反弹回来，但如果碰到左右边缘，对方玩家得分。球会正常地从挡板反弹，除非它碰到挡板的顶部或底部边缘，在这种情况下反弹的角度会发生变化。'
- en: In this chapter we’ll make our own version of *Pong*, which we’ll call *Tennjs*
    (like *Tennis* but with *JS*, get it?). In our game, the left paddle will be controlled
    by the computer and the right paddle will be controlled by a human player. In
    the original game, the paddles were controlled with rotating dial controllers,
    but in our version we’ll use the mouse. The computer, rather than trying to anticipate
    where the ball will bounce, will just attempt to always match the vertical position
    of the ball. In order to give the human player a chance, we’ll set an upper limit
    on how fast the computer can move the paddle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将制作一个属于自己的*Pong*版本，我们将其称为*Tennjs*（就像*Tennis*，但加了*JS*，明白了吗？）。在我们的游戏中，左侧的挡板将由计算机控制，右侧的挡板将由人类玩家控制。在原版游戏中，挡板是通过旋转拨盘控制的，但在我们的版本中，我们将使用鼠标。计算机不会尝试预测球会在哪里反弹，而是始终尝试与球的垂直位置保持一致。为了给人类玩家提供机会，我们会对计算机移动挡板的速度设定一个上限。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setup</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置</samp>
- en: We’ll begin by setting up the project’s file structure and creating a canvas
    for displaying the game. As usual, the project will require an HTML file and a
    JavaScript file. We’ll start with the HTML file. Create a directory called *tennjs*
    and a file in that directory called *index.html*. Then enter the content shown
    in [Listing 10-1](#Lis10-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过设置项目的文件结构并创建一个用于显示游戏的画布来开始。和往常一样，项目将需要一个HTML文件和一个JavaScript文件。我们从HTML文件开始。创建一个名为*tennjs*的目录，并在该目录中创建一个名为*index.html*的文件。然后输入[清单
    10-1](#Lis10-1)所示的内容。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for our game</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-1：我们的游戏的</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: This is almost exactly the same as the HTML file we created in [Chapter 9](chapter9.xhtml),
    so there should be no surprises. The body element includes a canvas element, where
    we’ll draw the game, and a script element referencing the file *script.js*, where
    our game code will live.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们在[第9章](chapter9.xhtml)中创建的HTML文件完全相同，因此应该不会有意外。body元素包含一个canvas元素，我们将在其中绘制游戏，还有一个script元素，引用了*script.js*文件，我们的游戏代码将在其中编写。
- en: Next, we’ll write some JavaScript to set up the canvas. Create the file *script.js*,
    and enter the code shown in [Listing 10-2](#Lis10-2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一些JavaScript代码来设置画布。创建*script.js*文件，并输入[清单 10-2](#Lis10-2)所示的代码。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Setting up the
    canvas in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-2：在</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">中设置画布</samp>
- en: This code should also be familiar. We first get a reference to the canvas with
    document.querySelector and get the canvas’s drawing context. Then we save the
    width and height of the canvas to variables called width and height for easy access
    within the code. Finally, we set the fill style to black and draw a black square
    the size of the canvas. This way the canvas appears to have a black background.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Open *index.html* in your browser, and you should see something like [Figure
    10-1](chapter10.xhtml#fig10-1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Our black square</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We now have a blank, black canvas where we can create our game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Ball</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll draw the ball. Add the code in [Listing 10-3](#Lis10-3) to the end
    of *script.js*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Drawing the ball</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'This code uses the fillRect method to draw the ball as a small white square
    near the top-left corner of the canvas. As in the original *Pong* game, the ball
    is a square rather than a circle. This gives the game a retro feel, and it will
    also simplify the task of detecting when the ball has collided with the walls
    or with a paddle. The size of the ball is stored in a constant called BALL_SIZE.
    We use the “true constant” all-caps style for the identifier name because the
    ball size won’t change during the course of the program. We could just use the
    value 5 instead of the constant BALL_SIZE when we call the fillRect method to
    draw the ball, but we’re going to end up needing to refer to the ball’s size a
    lot more throughout the program. Giving the size a name will make it much easier
    to understand code that needs to know the size of the ball. The other good thing
    about this approach is that if we change our mind later and decide the ball should
    be bigger or smaller, we have to update the code in only place: the declaration
    of the BALL_SIZE constant.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We keep track of the ball’s position with an object containing its x- and y-coordinates,
    created using an object literal ❶. In [Chapter 9](chapter9.xhtml) we used separate
    variables for the x- and y-coordinates of the circle that was being drawn, but
    it’s a bit tidier to store the two variables together as one object, especially
    since this program is going to be longer and more complex.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Refresh *index.html* and you should see the white ball sitting in the top-left
    corner of the canvas, as shown in [Figure 10-2](chapter10.xhtml#fig10-2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The ball</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The ball is stationary for now, but soon enough we’ll write code to make it
    move.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we’re going to do a simple refactor. *Refactoring* is a software development
    term for modifying some code without changing its behavior, usually to make the
    code easier to understand or update. As the code for a project grows more complex,
    refactoring can help keep it organized.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I know that we’re going to want to draw to the canvas multiple
    times, not just once. In fact, we’ll eventually want to redraw the canvas once
    every 30 ms to give our game the appearance of motion. To make that easier to
    accomplish, we’ll refactor so all the current drawing code becomes part of a function
    called draw. That way we can simply call the draw function anytime we want to
    redraw the canvas.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Update *script.js* with the changes shown in [Listing 10-4](#Lis10-4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Refactoring the
    drawing code</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The only change here is to group all the drawing code into a single function
    called draw ❶, which we then immediately call ❷. Because it’s a refactoring, nothing
    actually changes in the behavior of the program. You can refresh *index.html*
    to confirm that everything still looks as before.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game Loop</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost all games contain a *game loop* that orchestrates everything that has
    to happen for each frame of the game. Game loops are similar to animation loops,
    like the one we looked at in [Chapter 9](chapter9.xhtml), but with some additional
    logic. Here’s the general shape of the game loop in most games:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Clear canvas
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Draw image
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Get player input
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Update state
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Check collisions
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Wait a short time
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Repeat
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting and acting on input from a player (or players) is the main thing that
    distinguishes a game from an animation. *Collision detection* is another important
    aspect of most games: checking for when two objects in the game meet and responding
    accordingly. Collision detection is what stops you from walking through walls
    or driving through another car—and in this case, it’s what will make the ball
    bounce off the walls and paddles. Apart from the player input and collision detection
    elements, the steps in the game loop are more or less the same as in an animation
    loop: we clear the canvas, draw the image, update the state of the game to move
    objects to their new positions, pause, and repeat.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Rather than trying to write the whole game loop at once, we’ll build it up gradually.
    Update *script.js* with the content in [Listing 10-5](#Lis10-5), which will be
    the beginnings of the game loop in our game. This code moves the ball (that is,
    updates the ball’s state), redraws the canvas, pauses, and repeats.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: The game loop</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The first change here is to initialize two new variables ❶, xSpeed and ySpeed.
    We’ll use these to control the horizontal and vertical speed of the ball. The
    new update function ❷ uses these two variables to update the position of the ball.
    For every frame, the ball will move xSpeed pixels along the x-axis and ySpeed
    pixels along the y-axis. The two variables start out at 4 and 2, so every frame
    the ball will move 4 pixels to the right and 2 pixels down.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个变化是初始化两个新变量 ❶，`xSpeed` 和 `ySpeed`。我们将使用这两个变量来控制球的水平和垂直速度。新的 `update` 函数
    ❷ 使用这两个变量来更新球的位置。每帧，球将沿 x 轴移动 `xSpeed` 像素，沿 y 轴移动 `ySpeed` 像素。这两个变量的初始值分别为 4 和
    2，因此每帧球会向右移动 4 像素，向下移动 2 像素。
- en: The gameLoop function ❸ calls the draw function followed by the update function.
    Then it calls setTimeout(gameLoop, 30), which will call the gameLoop function
    again after 30 ms. This is almost exactly the same as the setInterval technique
    we used in [Chapter 9](chapter9.xhtml). You may recall that setTimeout calls its
    function only once after the timeout, while setInterval calls its function repeatedly.
    We’re using setTimeout here so we have more control over whether or not to keep
    looping; later on we’ll add some conditional logic to either call setTimeout or
    end the game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameLoop` 函数 ❸ 调用 `draw` 函数，然后是 `update` 函数。接着它调用 `setTimeout(gameLoop, 30)`，这样
    `gameLoop` 函数将在 30 毫秒后再次被调用。这几乎与我们在[第 9 章](chapter9.xhtml)中使用的 `setInterval` 技术完全相同。你可能还记得，`setTimeout`
    只会在超时后调用一次函数，而 `setInterval` 会反复调用其函数。我们这里使用 `setTimeout` 是为了能更好地控制是否继续循环；稍后我们将添加一些条件逻辑，决定是否继续调用
    `setTimeout` 或结束游戏。'
- en: Notice the line above the setTimeout call beginning with two slashes (//). This
    is an example of a *comment*, a note for yourself (or other people reading your
    code) embedded in the program file. When a JavaScript program executes, any text
    on a line following a // is ignored (anything on the line before the // is still
    evaluated as JavaScript code). Thus, you can use comments like this to explain
    how the code works, highlight important features, or make note of something you
    still need to do, without affecting the functionality of the program.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上面 `setTimeout` 调用之前以两个斜杠（//）开头的那一行。这是一个*注释*，是嵌入在程序文件中的个人备注（或其他阅读代码的人备注）。当
    JavaScript 程序执行时，任何在 // 后面的文本都会被忽略（// 前面的部分仍然会被作为 JavaScript 代码执行）。因此，你可以像这样使用注释来解释代码的工作原理、突出重要功能，或者记录需要完成的事项，而不会影响程序的功能。
- en: At the end of the script, we call the gameLoop function ❹ to set the game in
    motion. Since gameLoop currently ends with setTimeout, the result is that gameLoop
    will be repeatedly called once every 30 ms. Reload your page and you should see
    the ball move down and to the right, much like the animation from [Chapter 9](chapter9.xhtml).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的末尾，我们调用 `gameLoop` 函数 ❹ 来启动游戏。由于 `gameLoop` 目前以 `setTimeout` 结束，结果是 `gameLoop`
    每 30 毫秒会被重复调用一次。重新加载页面后，你应该能看到球向下和向右移动，和[第 9 章](chapter9.xhtml)中的动画类似。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bouncing</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反弹</samp>
- en: In the previous section you got the ball moving, but it just flew off the edge
    of the canvas. Next you’ll learn how to make it bounce off the edge of the canvas
    at the appropriate angle—our first collision detection code. Update *script.js*
    with the code in [Listing 10-6](#Lis10-6), which adds a checkCollision function
    to our game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经让球开始移动，但它只是飞出了画布的边缘。接下来你将学习如何使它以合适的角度从画布边缘反弹——我们的第一个碰撞检测代码。用[清单 10-6](#Lis10-6)中的代码更新
    *script.js*，这段代码为我们的游戏添加了一个 `checkCollision` 函数。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Wall collision
    detection</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-6：墙面碰撞检测</samp>
- en: 'The new function, checkCollision, checks to see if the ball has collided with
    one of the four walls of the canvas. If it has, it updates xSpeed or ySpeed as
    appropriate to make the ball bounce off the wall. First, we calculate values for
    the edges of the ball. We need to know where the left, right, top, and bottom
    edges are to determine if these edges have exceeded the bounds of the playing
    area. We group the values in an object called ball ❶ that has left, right, top,
    and bottom properties. Identifying the left and top ball edges is easy: they’re
    ballPosition.x and ballPosition.y, respectively. To get the right and bottom edges,
    we add BALL_SIZE to ballPosition.x and ballPosition.y. This is one of those cases
    noted earlier where having access to the ball’s size as a constant is helpful.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we perform the actual collision detection. If the left edge of the ball
    is less than 0 or the right edge of the ball is greater than the width of the
    canvas ❷, we know that the ball has hit the left or right wall. In both cases,
    the math is the same: the new value of xSpeed should be the negative of the current
    value (that is, the value is *negated*). For example, the first time the ball
    hits the right edge, xSpeed will go from 4 to -4. Meanwhile, ySpeed remains unchanged.
    As a result, the ball continues moving down the screen at the same rate, but now
    it’s moving to the left instead of to the right.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The same kind of check happens for the top of the ball colliding with the top
    wall or the bottom of the ball colliding with the bottom wall ❸. In either of
    these cases, we negate ySpeed, changing it from 2 to -2 when the ball hits the
    top edge, or from -2 to 2 when the ball hits the bottom edge.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The only other change to the code is to add a call to checkCollision to the
    list of things that happen in the gameLoop function ❹. Now when you refresh *index.html*,
    you should see the ball continuously bounce around the play area.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been paying attention, you might have noticed that the ball isn’t
    supposed to bounce off the left and right walls. Once we have moving paddles,
    we’ll modify the collision detection code to only bounce off the paddles or the
    top and bottom walls, and to score a point for a side wall collision.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Paddles</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next task is to draw the two paddles. To do that we’ll first introduce some
    new constants that establish the paddle dimensions and their horizontal position
    relative to the sides of the canvas, as well as some variables defining their
    vertical positions. (The paddles can only move up and down, not from side to side,
    so only their vertical positions need to be variables.) Update *script.js* with
    the changes in [Listing 10-7](#Lis10-7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: Defining the
    paddles</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: First we set up the constants that define the paddles. PADDLE_WIDTH and PADDLE_HEIGHT
    define both paddles to be 5 pixels wide and 20 pixels tall. PADDLE_OFFSET refers
    to the distance of the paddle from the left or right edge of the playing area.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置定义球拍的常量。PADDLE_WIDTH和PADDLE_HEIGHT定义了两个球拍的宽度为5像素，高度为20像素。PADDLE_OFFSET指的是球拍与游戏区域左右边缘的距离。
- en: The variables leftPaddleTop and rightPaddleTop define the current vertical position
    of the top of each paddle. Eventually, leftPaddleTop will be controlled by the
    computer through a function we’ll write to follow the ball, and rightPaddleTop
    will be updated when the player moves the mouse. For now, we’re simply setting
    these values to 10 and 30, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 变量leftPaddleTop和rightPaddleTop定义了每个球拍顶部的当前垂直位置。最终，leftPaddleTop将通过我们编写的函数由计算机控制，跟随球的位置，而rightPaddleTop将在玩家移动鼠标时更新。现在，我们只是将这两个值分别设置为10和30。
- en: Next, we update the draw function to display the paddles using the information
    we just defined. I’ve also added comments to the code to clarify what’s happening
    at each step of the draw function. Modify the code as shown in [Listing 10-8](#Lis10-8).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新绘制函数，使用我们刚刚定义的信息来显示球拍。我还在代码中添加了注释，明确每一步绘制函数的作用。按照[清单10-8](#Lis10-8)所示修改代码。
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: Drawing the paddles</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单10-8：绘制球拍</samp>
- en: In addition to some extra comments to help document the program, the new code
    features two calls to fillRect, one for drawing the left paddle ❶ and one for
    the right ❷. I’ve split the arguments over multiple lines because the identifiers
    are so long. Remember that the parameters to fillRect are x, y, width, and height,
    where x and y are the coordinates of the top-left corner of the rectangle. The
    x-coordinate of the left paddle is PADDLE_OFFSET because we’re using that to mean
    the paddle’s distance from the left edge of the canvas, while the y-coordinate
    of the left paddle is just leftPaddleTop. The width and height arguments are the
    PADDLE_WIDTH and PADDLE_HEIGHT constants.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助文档化程序的额外注释外，新的代码包含了两次调用fillRect，一个用于绘制左边的球拍❶，另一个用于右边的球拍❷。由于标识符太长，我将参数分成了多行。记住，fillRect的参数是x、y、宽度和高度，其中x和y是矩形左上角的坐标。左边球拍的x坐标是PADDLE_OFFSET，因为我们用它表示球拍与画布左边缘的距离，而左边球拍的y坐标就是leftPaddleTop。宽度和高度参数是PADDLE_WIDTH和PADDLE_HEIGHT常量。
- en: 'The right paddle is a bit more complicated to draw: to get the x-coordinate
    of the paddle’s top-left corner, we need to take the width of the canvas and subtract
    the width of the paddle and the offset of the paddle from the right edge. Given
    that the width of the canvas is 500, and the paddle width and offset are both
    10, that means the x-coordinate of the right paddle is 480.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 右边的球拍绘制稍微复杂一些：为了获取球拍左上角的x坐标，我们需要用画布的宽度减去球拍的宽度和球拍从右边缘的偏移量。给定画布的宽度为500，球拍宽度和偏移量都为10，这意味着右边球拍的x坐标是480。
- en: When you refresh *index.html*, you should see the two paddles in addition to
    the bouncing ball, as shown in [Figure 10-3](chapter10.xhtml#fig10-3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刷新*index.html*时，除了弹跳的球之外，你应该能看到两个球拍，如[图10-3](chapter10.xhtml#fig10-3)所示。
- en: '![](../images/Figure_10-3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: The paddles and
    ball</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-3：球拍和球</samp>
- en: Note that the ball currently passes straight through the paddles, because we
    haven’t set up collision detection for the paddles yet. We’ll get to that later
    in this section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，球现在会直接穿过球拍，因为我们还没有为球拍设置碰撞检测。我们稍后会在本节中讲解如何设置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Moving the Paddles
    with Player Input</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">通过玩家输入移动球拍</samp>
- en: The paddles are drawn at the vertical positions given by the variables leftPaddleTop
    and rightPaddleTop, so to make the paddles move up and down, we just have to update
    the values of these variables. Right now we’re concerned only with the right paddle,
    which will be controlled by the human player.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 球拍是在由变量leftPaddleTop和rightPaddleTop给定的垂直位置绘制的，因此为了让球拍上下移动，我们只需要更新这些变量的值。目前我们只关心右边的球拍，它将由玩家控制。
- en: To let the player control the right paddle, we’ll add an event handler to *script.js*
    that listens for mousemove events. [Listing 10-9](#Lis10-9) shows how it’s done.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: Adding an event
    handler to move the right paddle</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: This code follows the same pattern for event handling that you first saw in
    [Chapter 8](chapter8.xhtml). We use document.addEventListener to check for mouse
    movements. When one is detected, the event handler function updates the value
    of rightPaddleTop based on the y-coordinate of the mousemove event (e.y). The
    y-coordinate is relative to the top of the page, not the top of the canvas, so
    we subtract canvas.offsetTop (the distance from the top of the canvas to the top
    of the page) from the y-coordinate. This way the assigned rightPaddleTop value
    will be based on the distance of the mouse from the top of the canvas, and the
    paddle will follow the mouse accurately.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Refresh *index.html*, and you should see the right paddle move vertically as
    the mouse moves up and down. [Figure 10-4](chapter10.xhtml#fig10-4) shows how
    it should look.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: The right paddle
    moving with the mouse</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Our game has now officially become interactive! The player has full control
    of the position of the right paddle.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Paddle
    Collisions</samp>
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step is to add collision detection for the paddles. We need to know
    if the ball has hit a paddle and, if so, make the ball bounce off the paddle appropriately.
    This requires a lot of code, so I’ll break it up over a few listings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we have to do is create objects defining the four edges of the
    two paddles, as we did for the ball in [Listing 10-6](#Lis10-6). These changes
    are shown in [Listing 10-10](#Lis10-10).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: Defining the
    edges of the paddles</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The leftPaddle and rightPaddle objects contain the edges of their respective
    paddles as four properties, left, right, top, and bottom. As in [Listing 10-8](#Lis10-8),
    determining where the edges of the right paddle are requires a bit more math because
    we have to take into account the width of the canvas, the offset of the paddle,
    and the width of the paddle.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Next we need a function, which we’ll call checkPaddleCollision, that takes the
    ball object and one of the paddle objects and returns true if the ball is intersecting
    with that paddle. The function definition is shown in [Listing 10-11](#Lis10-11).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: The checkPaddleCollision
    function</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'This function will be called with the ball and each of the paddle objects defined
    earlier. It uses a long Boolean expression made up of four subexpressions that
    are all &&’d together, so it returns true only if all four subexpressions are
    true. (I added spacing to each subexpression so the operands line up vertically;
    this is just to make the code easier to read.) In English, the subexpressions
    say:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The left edge of the ball must be to the left of the right edge of the paddle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The right edge of the ball must be to the right of the left edge of the
    paddle.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The top edge of the ball must be above the bottom edge of the paddle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The bottom edge of the ball must be below the top edge of the paddle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: If the first two conditions are true, the ball is intersecting horizontally,
    and if the last two conditions are true, the ball is intersecting vertically.
    The ball is truly intersecting with the paddle only if all four conditions are
    true. To illustrate this, see [Figure 10-5](chapter10.xhtml#fig10-5).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The figure shows four possible scenarios we might check. In all the scenarios,
    the paddle has the following bounds: {left: 10, right: 15, top: 5, bottom: 25}.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(a), ball has the bounds {left: 20,
    right: 25, top: 30, bottom: 35}. In this case, ball.left < paddle.right is false
    (the left side of the ball is not to the left of the right side of the paddle),
    but ball.right > paddle.left is true. Likewise, ball.top < paddle.bottom is false
    and ball.bottom > paddle.top is true. The ball is neither vertically nor horizontally
    intersecting with the paddle.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(b), ball has the bounds {left: 20,
    right: 25, top: 22, bottom: 27}. This time, ball.top < paddle.bottom and ball.bottom
    > paddle.top are both true, which means that the ball is vertically intersecting
    with the paddle, but not horizontally intersecting.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(c), ball has the bounds {left: 13,
    right: 18, top: 30, bottom: 35}. In this case, the ball is horizontally intersecting
    with the paddle, but not vertically intersecting.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in [Figure 10-5](chapter10.xhtml#fig10-5)(d), ball has the bounds
    {left: 13, right: 18, top: 22, bottom: 27}. Now the ball is both horizontally
    and vertically intersecting with the paddle. All four subexpressions are true,
    so check PaddleCollision returns true.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-5.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: Collision detection
    conditions</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to actually call the checkPaddleCollision function from within
    the checkCollision function, once for each paddle, and handle the case where the
    function returns true. You can find this code in [Listing 10-12](#Lis10-12).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-12: Checking for
    paddle collisions</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Remember that checkPaddleCollision takes an object representing the ball and
    an object representing a paddle and returns true if the two are intersecting.
    If checkPaddleCollision(ball, leftPaddle) returns true, we set xSpeed to Math.abs(xSpeed)
    ❶, which has the effect of setting it to 4 because in our game xSpeed is only
    ever 4 (when moving to the right) or -4 (when moving to the left).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we didn’t just negate xSpeed, as we did with the
    vertical wall collision code earlier. Using the absolute value is a little trick
    to avoid multiple collisions that could send the ball bouncing back and forth
    “inside” the paddle. It’s possible that if the ball hits at just the right point
    at the end of the paddle it will get bounced back, but the next frame will also
    result in a collision with the same paddle. If we were negating the xSpeed, then
    it would just keep bouncing. By forcing the updated xSpeed to be positive, we
    can ensure that a collision with the left paddle will always result in the ball
    bouncing to the right.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we do the same thing with the right paddle. In this case, if
    there’s a collision we update xSpeed to -Math.abs(xSpeed) ❷, which in effect is
    -4, meaning that the ball will bounce to the left.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Refresh *index.html* again, and try to move the right paddle with your mouse
    so the ball hits it. You should now have ball-paddle bounces happening! At this
    point the ball can still safely bounce off the side walls, but we’ll fix that
    soon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bouncing Near the
    Paddle Ends</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I mentioned at the beginning of this chapter that in *Pong* you can change the
    angle of the ball’s bounce by hitting it near the top or bottom of the paddle.
    We’ll implement that functionality now. First we’ll add a new function called
    adjustAngle immediately before checkCollision. It checks if the ball is near the
    top or bottom of the paddle, and updates ySpeed if it is. See [Listing 10-13](#Lis10-13)
    for the code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-13: Adjusting the
    bounce angle</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The adjustAngle function has two parameters, distanceFromTop and distanceFromBottom.
    These represent the distance from the top of the ball to the top of the paddle
    and from the bottom of the paddle to the bottom of the ball, respectively. The
    function first checks if distanceFromTop is less than 0 ❶. If so, that means the
    top edge of the ball is above the top edge of the paddle at collision time, which
    is how we’ll define being near the top of the paddle. In this case, we subtract
    0.5 from ySpeed. If the ball is moving down the screen when it hits near the top
    of the paddle, then ySpeed is positive, so subtracting 0.5 reduces the vertical
    speed. For example, at the start of the game, ySpeed is 2. If you align the paddle
    so the ball hits the top, ySpeed will become 1.5 after the bounce, effectively
    reducing the angle of bounce. However, if the ball is moving up the screen, then
    ySpeed is negative. In this case, subtracting 0.5 after a hit near the top of
    the paddle will increase the ball’s vertical speed. For example, a ySpeed of -2
    will become -2.5.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: If the ball hits near the bottom of the paddle ❷, the opposite happens. In this
    case, we add 0.5 to ySpeed, increasing the vertical speed if the ball is moving
    down the screen or decreasing the speed if the ball is moving up the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update the checkCollision function to call the new adjustAngle
    function as part of the collision detection logic for the two paddles. [Listing
    10-14](#Lis10-14) shows the changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-14: Calling adjustAngle</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Within the if statement for each paddle, we declare distanceFromTop and distanceFromBottom,
    the arguments needed for the adjustAngle function. Then we call adjustAngle before
    updating xSpeed as before.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Now try out the game and see if you can hit the ball near the edge of the paddle!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Scoring Points</samp>
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Games are usually more fun when you can win or lose. In *Pong*, you score a
    point if you hit the wall behind the opposing player’s paddle. When this happens,
    the ball gets reset to its starting position and speed for the next round of play.
    We’ll deal with that part in this section too, but first, to keep track of the
    scores, we’ll need to create some new variables. Update *script.js* with the code
    in [Listing 10-15](#Lis10-15).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-15: Variables to
    keep track of the scores</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare two new variables, leftScore and rightScore, and set them both
    to 0. Later we’ll add logic to increment these variables when points are scored.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add code for displaying the scores to the end of the draw function.
    Update the function as shown in [Listing 10-16](#Lis10-16).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-16: Drawing the
    scores</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: This code uses some new canvas properties and methods we haven’t seen yet. First,
    we use ctx.font to set the font of the text we’re about to draw. This is similar
    to a CSS font declaration. In this case, we’re setting the font to be 30 pixels
    tall and monospace style. *Monospace* means that each character takes up the same
    width, and is usually used for code, as in this book’s code listings. It looks
    like this. There are many monospace fonts, but because operating systems can come
    with different fonts installed, we give only a generic font style (monospace),
    meaning the operating system should use the default font for that font style.
    In most operating systems, Courier or Courier New is the default monospace font.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use ctx.textAlign to set the alignment for the text. We choose "left"
    alignment, but because we want this to apply only to the left score, before drawing
    the right score we change the alignment to "right". This way if the scores get
    into double digits the numbers will extend toward the middle of the screen, keeping
    things visually balanced.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the left score, we use the ctx.fillText method. This method has
    three parameters: the text to be drawn, and the x- and y-coordinates at which
    to draw it. The first parameter must be a string, so we call the toString method
    on leftScore to convert it from a number to a string. We use 50 for the x- and
    y-coordinates to place the text near the top-left corner of the canvas.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The meaning of the x-coordinate parameter for fillText depends on the text’s
    alignment. For left-aligned text, the x-coordinate specifies the left edge of
    the text, whereas for right-aligned text it specifies the right edge.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The right score is handled similarly to the left score: we set the text alignment,
    then call fillText to display the score. This time we set the x-coordinate to
    width - 50, so it appears as far from the right as the left score appears from
    the left.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: When you refresh *index.html*, you should see the initial scores rendered, as
    illustrated in [Figure 10-6](chapter10.xhtml#fig10-6).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-6.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: Displaying the
    scores</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to handle the case where the ball hits the side walls. Instead of
    bouncing, the appropriate score should be incremented and the ball should be reset
    to its original speed and position. First we’ll do another refactor and write
    a function that resets the ball. This also requires some changes to how the ball’s
    speed and position variables are handled. [Listing 10-17](#Lis10-17) shows the
    changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-17: The initBall
    function</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ve separated the *declaration* of the ball state variables (ball Position,
    xSpeed, and ySpeed) from the *initialization* of those variables. For example,
    ballPosition is declared at the top level of the program ❶ but initialized in
    the new initBall function ❷ (short for “initialize ball”). The same goes for xSpeed
    and ySpeed. This is so we can reset the ball to its initial position and speed
    whenever we want simply by calling initBall, rather than by copy-pasting the values
    of the ball state variables all over the program. In particular, we can now call
    initBall at the start of the program to set up the ball for the first time, and
    we can also call it anytime the ball hits the left or right wall, to reset the
    ball to its original state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can’t both declare *and* initialize the ball state variables inside
    the initBall function—for example, by placing let ballPosition = {x: 20, y: 30};
    within the function—because the let keyword defines a new variable *in the current
    scope*, which in that case would be the body of initBall. Thus, the variables
    would be available only within initBall. We want the variables to be available
    throughout the program, so we declare them with let at the top level of the program,
    outside the body of any functions. However, because we want to initialize the
    variables multiple times, we assign them their value in the initBall function,
    which can be called repeatedly.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Next we have to modify the collision detection code in the checkCollision function
    to increment the score and reset the ball when the left or right wall is hit.
    [Listing 10-18](#Lis10-18) shows how.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-18: Scoring points
    on wall collisions</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we checked for left and right wall collisions in a single if statement
    that made the ball bounce, but we have to handle the left and right walls individually,
    since a different player scores depending on which wall is hit. Therefore, we’ve
    split the if statement into two. If the ball hits the left wall ❶, rightScore
    is incremented and the ball is reset with a call to our new initBall function.
    If the ball hits the right wall ❷, leftScore is incremented and the ball is reset.
    The logic for collisions with the top and bottom walls remains the same.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since we’ve moved the initialization of the ball state variables to
    the initBall function, we need to call that function before the game loop starts
    in order to set the ball up for the first time. Scroll down to the bottom of *script.js*
    and update the code as shown in [Listing 10-19](#Lis10-19), adding a call to initBall
    before the call to gameLoop.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-19: Calling initBall
    for the first time</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Now when you refresh *index.html*, you should see the scores increment when
    the ball hits a side wall, and the ball should reset to its original speed and
    position after a side wall hit. Of course, it’s pretty easy to beat the computer
    right now because it doesn’t move its paddle yet!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Computer Control</samp>
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s add some challenge to this game! We want the computer-controlled
    opponent to move the left paddle and try to hit the ball. There are various ways
    to do this, but in our simple approach, we’ll have the computer always try to
    match the current position of the ball. The logic for the computer will be very
    simple:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If the top of the ball is above the top of the paddle, move the paddle up.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the bottom of the ball is below the bottom of the paddle, move the paddle
    down.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, do nothing.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this approach, if the computer could move at any speed, then it would never
    miss. Since this would be no fun for us humans, we’ll set a speed limit for the
    computer. [Listing 10-20](#Lis10-20) shows how.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-20: Limiting the
    computer’s speed</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We declare the computer’s speed limit as a constant, MAX_COMPUTER_SPEED. By
    setting it to 2, we’re saying that the computer isn’t allowed to move the paddle
    more than 2 pixels per frame of the game.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll define a function called followBall that applies some very rudimentary
    artificial intelligence to move the computer’s paddle. The new function is shown
    in [Listing 10-21](#Lis10-21). Add it to your code between the draw function and
    the update function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-21: Computer-controlled
    paddle</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Within the followBall function, we define objects representing the ball ❶ and
    the left paddle ❷, each with top and bottom properties representing their upper
    and lower bounds. Then we implement the paddle movement logic with two if statements.
    If the top of the ball is above the top of the paddle ❸, we move the paddle up
    by subtracting MAX_COMPUTER_SPEED from leftPaddleTop. Likewise, if the bottom
    of the ball is below the bottom of the paddle ❹, we move the paddle down by adding
    MAX_COMPUTER_SPEED to leftPaddleTop.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We call our new followBall function within the update function ❺. This way,
    moving the left paddle becomes part of the process of updating the state of the
    game that happens with each iteration of the game loop.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and see if you can score a point against the computer!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Game Over</samp>
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final step in creating our game is to make it winnable (or losable). To
    do that, we have to add some kind of game over condition, and stop the game loop
    at that point. In this case, we’ll stop the game loop once one of the players
    reaches 10 points, then display the text “GAME OVER.”
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to declare a variable for keeping track of whether or not the
    game is over. We’ll use this variable to decide whether to continue repeating
    the gameLoop function. [Listing 10-22](#Lis10-22) shows the changes to make.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-22: Adding the gameOver
    variable</samp>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Near the top of *script.js*, we declare a variable called gameOver for recording
    whether the game is over ❶. We initialize it to false so the game doesn’t end
    before it begins. Then, within the checkCollision function, we check to see if
    either of the scores has exceeded 9 ❷. If so, we set gameOver to true. This check
    could happen anywhere, but we do it in checkCollision to keep the logic that increments
    the scores and the logic that checks the scores together.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a function for writing the text “GAME OVER,” and we’ll modify
    the game loop so it ends when gameOver is true. [Listing 10-23](#Lis10-23) shows
    how.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-23: Ending the game</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We define the drawGameOver function after the checkCollision function ❶. It
    draws the text “GAME OVER” to the middle of the canvas in large, white text. To
    position the text in the middle of the canvas, we set the text alignment to "center"
    and use half the canvas width and height as the text’s x- and y-coordinates. (With
    center alignment, the x-coordinate refers to the horizontal midpoint of the text.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the gameLoop function, we’ve wrapped the call to setTimeout in a conditional
    statement that checks the value of the gameOver variable. If it’s true ❷, the
    game is over, so we call the draw and drawGameOver functions. (The draw function
    is needed to display the final score; otherwise, the winning player would still
    be stuck with nine points.) If gameOver is false ❸, the game can continue: we
    keep looping as before by using setTimeout to call gameLoop again after 30 ms.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Once gameOver becomes true and the game loop ends, the game effectively stops.
    Nothing else will be drawn to the screen after the “GAME OVER” text—at least,
    not until the page is refreshed and the program starts again from the beginning.
    Go ahead and do that now: refresh *index.html* and see if you can beat the computer!
    Once one of you gets more than nine points you should see the “GAME OVER” text,
    as shown in [Figure 10-7](chapter10.xhtml#fig10-7).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-7.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: Game over</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you beat the computer, but don’t worry if you didn’t—the game is pretty
    hard. Here are some things you can do to make it easier for yourself:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Increase the time between frames in gameLoop.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the paddles taller.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the computer’s max speed.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it easier to hit the edge of the paddle.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the effect on ySpeed of hitting the edge of the paddle.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have a working game, you can make any changes you want. If you’re
    already a *Pong* pro, you might want to make it harder instead; the following
    exercises provide a few suggestions. You could also try customizing the appearance,
    or changing the size of the canvas—it’s your game now.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Complete Code</samp>
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For your convenience, [Listing 10-24](#Lis10-24) shows the whole *script.js*
    file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-24: The complete
    code</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you created a full game from scratch. The basics of game loops,
    collision detection, and rendering are broadly applicable, so with the knowledge
    you’ve acquired here you can start creating all kinds of 2D games. For example,
    you might try implementing your own version of *Breakout* or *Snake*. If you need
    some help with the logic, there are lots of tutorials online that you can follow.
    Have fun!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
