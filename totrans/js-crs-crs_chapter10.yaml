- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PONG</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this first project, you’ll use JavaScript to re-create one of the first
    arcade video games: the classic *Pong* from Atari. *Pong* is a simple game, but
    it will teach you some important aspects of game design: a game loop, player input,
    collision detection, and score keeping. We’ll even use some basic artificial intelligence
    to program the computer opponent.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Pong* was developed in 1972 and was released that year as a hugely successful
    arcade machine. It’s a very basic game, like table tennis, consisting of a ball
    and two paddles positioned on the left and right sides of the screen, which the
    players can move up and down. If the ball hits the top or bottom edge of the screen,
    it bounces off, but if it hits the left or right edge the player on the opposite
    side scores a point. The ball bounces off the paddles normally, unless it hits
    near the top or bottom edge of the paddle, in which case the angle of return changes.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll make our own version of *Pong*, which we’ll call *Tennjs*
    (like *Tennis* but with *JS*, get it?). In our game, the left paddle will be controlled
    by the computer and the right paddle will be controlled by a human player. In
    the original game, the paddles were controlled with rotating dial controllers,
    but in our version we’ll use the mouse. The computer, rather than trying to anticipate
    where the ball will bounce, will just attempt to always match the vertical position
    of the ball. In order to give the human player a chance, we’ll set an upper limit
    on how fast the computer can move the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setup</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll begin by setting up the project’s file structure and creating a canvas
    for displaying the game. As usual, the project will require an HTML file and a
    JavaScript file. We’ll start with the HTML file. Create a directory called *tennjs*
    and a file in that directory called *index.html*. Then enter the content shown
    in [Listing 10-1](#Lis10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for our game</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is almost exactly the same as the HTML file we created in [Chapter 9](chapter9.xhtml),
    so there should be no surprises. The body element includes a canvas element, where
    we’ll draw the game, and a script element referencing the file *script.js*, where
    our game code will live.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write some JavaScript to set up the canvas. Create the file *script.js*,
    and enter the code shown in [Listing 10-2](#Lis10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Setting up the
    canvas in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code should also be familiar. We first get a reference to the canvas with
    document.querySelector and get the canvas’s drawing context. Then we save the
    width and height of the canvas to variables called width and height for easy access
    within the code. Finally, we set the fill style to black and draw a black square
    the size of the canvas. This way the canvas appears to have a black background.
  prefs: []
  type: TYPE_NORMAL
- en: Open *index.html* in your browser, and you should see something like [Figure
    10-1](chapter10.xhtml#fig10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Our black square</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a blank, black canvas where we can create our game.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Ball</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll draw the ball. Add the code in [Listing 10-3](#Lis10-3) to the end
    of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Drawing the ball</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code uses the fillRect method to draw the ball as a small white square
    near the top-left corner of the canvas. As in the original *Pong* game, the ball
    is a square rather than a circle. This gives the game a retro feel, and it will
    also simplify the task of detecting when the ball has collided with the walls
    or with a paddle. The size of the ball is stored in a constant called BALL_SIZE.
    We use the “true constant” all-caps style for the identifier name because the
    ball size won’t change during the course of the program. We could just use the
    value 5 instead of the constant BALL_SIZE when we call the fillRect method to
    draw the ball, but we’re going to end up needing to refer to the ball’s size a
    lot more throughout the program. Giving the size a name will make it much easier
    to understand code that needs to know the size of the ball. The other good thing
    about this approach is that if we change our mind later and decide the ball should
    be bigger or smaller, we have to update the code in only place: the declaration
    of the BALL_SIZE constant.'
  prefs: []
  type: TYPE_NORMAL
- en: We keep track of the ball’s position with an object containing its x- and y-coordinates,
    created using an object literal ❶. In [Chapter 9](chapter9.xhtml) we used separate
    variables for the x- and y-coordinates of the circle that was being drawn, but
    it’s a bit tidier to store the two variables together as one object, especially
    since this program is going to be longer and more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh *index.html* and you should see the white ball sitting in the top-left
    corner of the canvas, as shown in [Figure 10-2](chapter10.xhtml#fig10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The ball</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The ball is stationary for now, but soon enough we’ll write code to make it
    move.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we’re going to do a simple refactor. *Refactoring* is a software development
    term for modifying some code without changing its behavior, usually to make the
    code easier to understand or update. As the code for a project grows more complex,
    refactoring can help keep it organized.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I know that we’re going to want to draw to the canvas multiple
    times, not just once. In fact, we’ll eventually want to redraw the canvas once
    every 30 ms to give our game the appearance of motion. To make that easier to
    accomplish, we’ll refactor so all the current drawing code becomes part of a function
    called draw. That way we can simply call the draw function anytime we want to
    redraw the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Update *script.js* with the changes shown in [Listing 10-4](#Lis10-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Refactoring the
    drawing code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The only change here is to group all the drawing code into a single function
    called draw ❶, which we then immediately call ❷. Because it’s a refactoring, nothing
    actually changes in the behavior of the program. You can refresh *index.html*
    to confirm that everything still looks as before.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game Loop</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost all games contain a *game loop* that orchestrates everything that has
    to happen for each frame of the game. Game loops are similar to animation loops,
    like the one we looked at in [Chapter 9](chapter9.xhtml), but with some additional
    logic. Here’s the general shape of the game loop in most games:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Clear canvas
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Draw image
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Get player input
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Update state
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Check collisions
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Wait a short time
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Repeat
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting and acting on input from a player (or players) is the main thing that
    distinguishes a game from an animation. *Collision detection* is another important
    aspect of most games: checking for when two objects in the game meet and responding
    accordingly. Collision detection is what stops you from walking through walls
    or driving through another car—and in this case, it’s what will make the ball
    bounce off the walls and paddles. Apart from the player input and collision detection
    elements, the steps in the game loop are more or less the same as in an animation
    loop: we clear the canvas, draw the image, update the state of the game to move
    objects to their new positions, pause, and repeat.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than trying to write the whole game loop at once, we’ll build it up gradually.
    Update *script.js* with the content in [Listing 10-5](#Lis10-5), which will be
    the beginnings of the game loop in our game. This code moves the ball (that is,
    updates the ball’s state), redraws the canvas, pauses, and repeats.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: The game loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first change here is to initialize two new variables ❶, xSpeed and ySpeed.
    We’ll use these to control the horizontal and vertical speed of the ball. The
    new update function ❷ uses these two variables to update the position of the ball.
    For every frame, the ball will move xSpeed pixels along the x-axis and ySpeed
    pixels along the y-axis. The two variables start out at 4 and 2, so every frame
    the ball will move 4 pixels to the right and 2 pixels down.
  prefs: []
  type: TYPE_NORMAL
- en: The gameLoop function ❸ calls the draw function followed by the update function.
    Then it calls setTimeout(gameLoop, 30), which will call the gameLoop function
    again after 30 ms. This is almost exactly the same as the setInterval technique
    we used in [Chapter 9](chapter9.xhtml). You may recall that setTimeout calls its
    function only once after the timeout, while setInterval calls its function repeatedly.
    We’re using setTimeout here so we have more control over whether or not to keep
    looping; later on we’ll add some conditional logic to either call setTimeout or
    end the game.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the line above the setTimeout call beginning with two slashes (//). This
    is an example of a *comment*, a note for yourself (or other people reading your
    code) embedded in the program file. When a JavaScript program executes, any text
    on a line following a // is ignored (anything on the line before the // is still
    evaluated as JavaScript code). Thus, you can use comments like this to explain
    how the code works, highlight important features, or make note of something you
    still need to do, without affecting the functionality of the program.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the script, we call the gameLoop function ❹ to set the game in
    motion. Since gameLoop currently ends with setTimeout, the result is that gameLoop
    will be repeatedly called once every 30 ms. Reload your page and you should see
    the ball move down and to the right, much like the animation from [Chapter 9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bouncing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section you got the ball moving, but it just flew off the edge
    of the canvas. Next you’ll learn how to make it bounce off the edge of the canvas
    at the appropriate angle—our first collision detection code. Update *script.js*
    with the code in [Listing 10-6](#Lis10-6), which adds a checkCollision function
    to our game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Wall collision
    detection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new function, checkCollision, checks to see if the ball has collided with
    one of the four walls of the canvas. If it has, it updates xSpeed or ySpeed as
    appropriate to make the ball bounce off the wall. First, we calculate values for
    the edges of the ball. We need to know where the left, right, top, and bottom
    edges are to determine if these edges have exceeded the bounds of the playing
    area. We group the values in an object called ball ❶ that has left, right, top,
    and bottom properties. Identifying the left and top ball edges is easy: they’re
    ballPosition.x and ballPosition.y, respectively. To get the right and bottom edges,
    we add BALL_SIZE to ballPosition.x and ballPosition.y. This is one of those cases
    noted earlier where having access to the ball’s size as a constant is helpful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we perform the actual collision detection. If the left edge of the ball
    is less than 0 or the right edge of the ball is greater than the width of the
    canvas ❷, we know that the ball has hit the left or right wall. In both cases,
    the math is the same: the new value of xSpeed should be the negative of the current
    value (that is, the value is *negated*). For example, the first time the ball
    hits the right edge, xSpeed will go from 4 to -4. Meanwhile, ySpeed remains unchanged.
    As a result, the ball continues moving down the screen at the same rate, but now
    it’s moving to the left instead of to the right.'
  prefs: []
  type: TYPE_NORMAL
- en: The same kind of check happens for the top of the ball colliding with the top
    wall or the bottom of the ball colliding with the bottom wall ❸. In either of
    these cases, we negate ySpeed, changing it from 2 to -2 when the ball hits the
    top edge, or from -2 to 2 when the ball hits the bottom edge.
  prefs: []
  type: TYPE_NORMAL
- en: The only other change to the code is to add a call to checkCollision to the
    list of things that happen in the gameLoop function ❹. Now when you refresh *index.html*,
    you should see the ball continuously bounce around the play area.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been paying attention, you might have noticed that the ball isn’t
    supposed to bounce off the left and right walls. Once we have moving paddles,
    we’ll modify the collision detection code to only bounce off the paddles or the
    top and bottom walls, and to score a point for a side wall collision.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Paddles</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next task is to draw the two paddles. To do that we’ll first introduce some
    new constants that establish the paddle dimensions and their horizontal position
    relative to the sides of the canvas, as well as some variables defining their
    vertical positions. (The paddles can only move up and down, not from side to side,
    so only their vertical positions need to be variables.) Update *script.js* with
    the changes in [Listing 10-7](#Lis10-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: Defining the
    paddles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First we set up the constants that define the paddles. PADDLE_WIDTH and PADDLE_HEIGHT
    define both paddles to be 5 pixels wide and 20 pixels tall. PADDLE_OFFSET refers
    to the distance of the paddle from the left or right edge of the playing area.
  prefs: []
  type: TYPE_NORMAL
- en: The variables leftPaddleTop and rightPaddleTop define the current vertical position
    of the top of each paddle. Eventually, leftPaddleTop will be controlled by the
    computer through a function we’ll write to follow the ball, and rightPaddleTop
    will be updated when the player moves the mouse. For now, we’re simply setting
    these values to 10 and 30, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we update the draw function to display the paddles using the information
    we just defined. I’ve also added comments to the code to clarify what’s happening
    at each step of the draw function. Modify the code as shown in [Listing 10-8](#Lis10-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: Drawing the paddles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to some extra comments to help document the program, the new code
    features two calls to fillRect, one for drawing the left paddle ❶ and one for
    the right ❷. I’ve split the arguments over multiple lines because the identifiers
    are so long. Remember that the parameters to fillRect are x, y, width, and height,
    where x and y are the coordinates of the top-left corner of the rectangle. The
    x-coordinate of the left paddle is PADDLE_OFFSET because we’re using that to mean
    the paddle’s distance from the left edge of the canvas, while the y-coordinate
    of the left paddle is just leftPaddleTop. The width and height arguments are the
    PADDLE_WIDTH and PADDLE_HEIGHT constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right paddle is a bit more complicated to draw: to get the x-coordinate
    of the paddle’s top-left corner, we need to take the width of the canvas and subtract
    the width of the paddle and the offset of the paddle from the right edge. Given
    that the width of the canvas is 500, and the paddle width and offset are both
    10, that means the x-coordinate of the right paddle is 480.'
  prefs: []
  type: TYPE_NORMAL
- en: When you refresh *index.html*, you should see the two paddles in addition to
    the bouncing ball, as shown in [Figure 10-3](chapter10.xhtml#fig10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: The paddles and
    ball</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the ball currently passes straight through the paddles, because we
    haven’t set up collision detection for the paddles yet. We’ll get to that later
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Moving the Paddles
    with Player Input</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The paddles are drawn at the vertical positions given by the variables leftPaddleTop
    and rightPaddleTop, so to make the paddles move up and down, we just have to update
    the values of these variables. Right now we’re concerned only with the right paddle,
    which will be controlled by the human player.
  prefs: []
  type: TYPE_NORMAL
- en: To let the player control the right paddle, we’ll add an event handler to *script.js*
    that listens for mousemove events. [Listing 10-9](#Lis10-9) shows how it’s done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: Adding an event
    handler to move the right paddle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code follows the same pattern for event handling that you first saw in
    [Chapter 8](chapter8.xhtml). We use document.addEventListener to check for mouse
    movements. When one is detected, the event handler function updates the value
    of rightPaddleTop based on the y-coordinate of the mousemove event (e.y). The
    y-coordinate is relative to the top of the page, not the top of the canvas, so
    we subtract canvas.offsetTop (the distance from the top of the canvas to the top
    of the page) from the y-coordinate. This way the assigned rightPaddleTop value
    will be based on the distance of the mouse from the top of the canvas, and the
    paddle will follow the mouse accurately.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh *index.html*, and you should see the right paddle move vertically as
    the mouse moves up and down. [Figure 10-4](chapter10.xhtml#fig10-4) shows how
    it should look.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: The right paddle
    moving with the mouse</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our game has now officially become interactive! The player has full control
    of the position of the right paddle.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Paddle
    Collisions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step is to add collision detection for the paddles. We need to know
    if the ball has hit a paddle and, if so, make the ball bounce off the paddle appropriately.
    This requires a lot of code, so I’ll break it up over a few listings.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we have to do is create objects defining the four edges of the
    two paddles, as we did for the ball in [Listing 10-6](#Lis10-6). These changes
    are shown in [Listing 10-10](#Lis10-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: Defining the
    edges of the paddles</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The leftPaddle and rightPaddle objects contain the edges of their respective
    paddles as four properties, left, right, top, and bottom. As in [Listing 10-8](#Lis10-8),
    determining where the edges of the right paddle are requires a bit more math because
    we have to take into account the width of the canvas, the offset of the paddle,
    and the width of the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: Next we need a function, which we’ll call checkPaddleCollision, that takes the
    ball object and one of the paddle objects and returns true if the ball is intersecting
    with that paddle. The function definition is shown in [Listing 10-11](#Lis10-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: The checkPaddleCollision
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function will be called with the ball and each of the paddle objects defined
    earlier. It uses a long Boolean expression made up of four subexpressions that
    are all &&’d together, so it returns true only if all four subexpressions are
    true. (I added spacing to each subexpression so the operands line up vertically;
    this is just to make the code easier to read.) In English, the subexpressions
    say:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The left edge of the ball must be to the left of the right edge of the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The right edge of the ball must be to the right of the left edge of the
    paddle.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The top edge of the ball must be above the bottom edge of the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  The bottom edge of the ball must be below the top edge of the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: If the first two conditions are true, the ball is intersecting horizontally,
    and if the last two conditions are true, the ball is intersecting vertically.
    The ball is truly intersecting with the paddle only if all four conditions are
    true. To illustrate this, see [Figure 10-5](chapter10.xhtml#fig10-5).
  prefs: []
  type: TYPE_NORMAL
- en: 'The figure shows four possible scenarios we might check. In all the scenarios,
    the paddle has the following bounds: {left: 10, right: 15, top: 5, bottom: 25}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(a), ball has the bounds {left: 20,
    right: 25, top: 30, bottom: 35}. In this case, ball.left < paddle.right is false
    (the left side of the ball is not to the left of the right side of the paddle),
    but ball.right > paddle.left is true. Likewise, ball.top < paddle.bottom is false
    and ball.bottom > paddle.top is true. The ball is neither vertically nor horizontally
    intersecting with the paddle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(b), ball has the bounds {left: 20,
    right: 25, top: 22, bottom: 27}. This time, ball.top < paddle.bottom and ball.bottom
    > paddle.top are both true, which means that the ball is vertically intersecting
    with the paddle, but not horizontally intersecting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(c), ball has the bounds {left: 13,
    right: 18, top: 30, bottom: 35}. In this case, the ball is horizontally intersecting
    with the paddle, but not vertically intersecting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in [Figure 10-5](chapter10.xhtml#fig10-5)(d), ball has the bounds
    {left: 13, right: 18, top: 22, bottom: 27}. Now the ball is both horizontally
    and vertically intersecting with the paddle. All four subexpressions are true,
    so check PaddleCollision returns true.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: Collision detection
    conditions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to actually call the checkPaddleCollision function from within
    the checkCollision function, once for each paddle, and handle the case where the
    function returns true. You can find this code in [Listing 10-12](#Lis10-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-12: Checking for
    paddle collisions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that checkPaddleCollision takes an object representing the ball and
    an object representing a paddle and returns true if the two are intersecting.
    If checkPaddleCollision(ball, leftPaddle) returns true, we set xSpeed to Math.abs(xSpeed)
    ❶, which has the effect of setting it to 4 because in our game xSpeed is only
    ever 4 (when moving to the right) or -4 (when moving to the left).
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we didn’t just negate xSpeed, as we did with the
    vertical wall collision code earlier. Using the absolute value is a little trick
    to avoid multiple collisions that could send the ball bouncing back and forth
    “inside” the paddle. It’s possible that if the ball hits at just the right point
    at the end of the paddle it will get bounced back, but the next frame will also
    result in a collision with the same paddle. If we were negating the xSpeed, then
    it would just keep bouncing. By forcing the updated xSpeed to be positive, we
    can ensure that a collision with the left paddle will always result in the ball
    bouncing to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we do the same thing with the right paddle. In this case, if
    there’s a collision we update xSpeed to -Math.abs(xSpeed) ❷, which in effect is
    -4, meaning that the ball will bounce to the left.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh *index.html* again, and try to move the right paddle with your mouse
    so the ball hits it. You should now have ball-paddle bounces happening! At this
    point the ball can still safely bounce off the side walls, but we’ll fix that
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bouncing Near the
    Paddle Ends</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I mentioned at the beginning of this chapter that in *Pong* you can change the
    angle of the ball’s bounce by hitting it near the top or bottom of the paddle.
    We’ll implement that functionality now. First we’ll add a new function called
    adjustAngle immediately before checkCollision. It checks if the ball is near the
    top or bottom of the paddle, and updates ySpeed if it is. See [Listing 10-13](#Lis10-13)
    for the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-13: Adjusting the
    bounce angle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The adjustAngle function has two parameters, distanceFromTop and distanceFromBottom.
    These represent the distance from the top of the ball to the top of the paddle
    and from the bottom of the paddle to the bottom of the ball, respectively. The
    function first checks if distanceFromTop is less than 0 ❶. If so, that means the
    top edge of the ball is above the top edge of the paddle at collision time, which
    is how we’ll define being near the top of the paddle. In this case, we subtract
    0.5 from ySpeed. If the ball is moving down the screen when it hits near the top
    of the paddle, then ySpeed is positive, so subtracting 0.5 reduces the vertical
    speed. For example, at the start of the game, ySpeed is 2. If you align the paddle
    so the ball hits the top, ySpeed will become 1.5 after the bounce, effectively
    reducing the angle of bounce. However, if the ball is moving up the screen, then
    ySpeed is negative. In this case, subtracting 0.5 after a hit near the top of
    the paddle will increase the ball’s vertical speed. For example, a ySpeed of -2
    will become -2.5.
  prefs: []
  type: TYPE_NORMAL
- en: If the ball hits near the bottom of the paddle ❷, the opposite happens. In this
    case, we add 0.5 to ySpeed, increasing the vertical speed if the ball is moving
    down the screen or decreasing the speed if the ball is moving up the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update the checkCollision function to call the new adjustAngle
    function as part of the collision detection logic for the two paddles. [Listing
    10-14](#Lis10-14) shows the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-14: Calling adjustAngle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Within the if statement for each paddle, we declare distanceFromTop and distanceFromBottom,
    the arguments needed for the adjustAngle function. Then we call adjustAngle before
    updating xSpeed as before.
  prefs: []
  type: TYPE_NORMAL
- en: Now try out the game and see if you can hit the ball near the edge of the paddle!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Scoring Points</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Games are usually more fun when you can win or lose. In *Pong*, you score a
    point if you hit the wall behind the opposing player’s paddle. When this happens,
    the ball gets reset to its starting position and speed for the next round of play.
    We’ll deal with that part in this section too, but first, to keep track of the
    scores, we’ll need to create some new variables. Update *script.js* with the code
    in [Listing 10-15](#Lis10-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-15: Variables to
    keep track of the scores</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare two new variables, leftScore and rightScore, and set them both
    to 0. Later we’ll add logic to increment these variables when points are scored.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add code for displaying the scores to the end of the draw function.
    Update the function as shown in [Listing 10-16](#Lis10-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-16: Drawing the
    scores</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code uses some new canvas properties and methods we haven’t seen yet. First,
    we use ctx.font to set the font of the text we’re about to draw. This is similar
    to a CSS font declaration. In this case, we’re setting the font to be 30 pixels
    tall and monospace style. *Monospace* means that each character takes up the same
    width, and is usually used for code, as in this book’s code listings. It looks
    like this. There are many monospace fonts, but because operating systems can come
    with different fonts installed, we give only a generic font style (monospace),
    meaning the operating system should use the default font for that font style.
    In most operating systems, Courier or Courier New is the default monospace font.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use ctx.textAlign to set the alignment for the text. We choose "left"
    alignment, but because we want this to apply only to the left score, before drawing
    the right score we change the alignment to "right". This way if the scores get
    into double digits the numbers will extend toward the middle of the screen, keeping
    things visually balanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the left score, we use the ctx.fillText method. This method has
    three parameters: the text to be drawn, and the x- and y-coordinates at which
    to draw it. The first parameter must be a string, so we call the toString method
    on leftScore to convert it from a number to a string. We use 50 for the x- and
    y-coordinates to place the text near the top-left corner of the canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The meaning of the x-coordinate parameter for fillText depends on the text’s
    alignment. For left-aligned text, the x-coordinate specifies the left edge of
    the text, whereas for right-aligned text it specifies the right edge.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The right score is handled similarly to the left score: we set the text alignment,
    then call fillText to display the score. This time we set the x-coordinate to
    width - 50, so it appears as far from the right as the left score appears from
    the left.'
  prefs: []
  type: TYPE_NORMAL
- en: When you refresh *index.html*, you should see the initial scores rendered, as
    illustrated in [Figure 10-6](chapter10.xhtml#fig10-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: Displaying the
    scores</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to handle the case where the ball hits the side walls. Instead of
    bouncing, the appropriate score should be incremented and the ball should be reset
    to its original speed and position. First we’ll do another refactor and write
    a function that resets the ball. This also requires some changes to how the ball’s
    speed and position variables are handled. [Listing 10-17](#Lis10-17) shows the
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-17: The initBall
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ve separated the *declaration* of the ball state variables (ball Position,
    xSpeed, and ySpeed) from the *initialization* of those variables. For example,
    ballPosition is declared at the top level of the program ❶ but initialized in
    the new initBall function ❷ (short for “initialize ball”). The same goes for xSpeed
    and ySpeed. This is so we can reset the ball to its initial position and speed
    whenever we want simply by calling initBall, rather than by copy-pasting the values
    of the ball state variables all over the program. In particular, we can now call
    initBall at the start of the program to set up the ball for the first time, and
    we can also call it anytime the ball hits the left or right wall, to reset the
    ball to its original state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can’t both declare *and* initialize the ball state variables inside
    the initBall function—for example, by placing let ballPosition = {x: 20, y: 30};
    within the function—because the let keyword defines a new variable *in the current
    scope*, which in that case would be the body of initBall. Thus, the variables
    would be available only within initBall. We want the variables to be available
    throughout the program, so we declare them with let at the top level of the program,
    outside the body of any functions. However, because we want to initialize the
    variables multiple times, we assign them their value in the initBall function,
    which can be called repeatedly.'
  prefs: []
  type: TYPE_NORMAL
- en: Next we have to modify the collision detection code in the checkCollision function
    to increment the score and reset the ball when the left or right wall is hit.
    [Listing 10-18](#Lis10-18) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-18: Scoring points
    on wall collisions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we checked for left and right wall collisions in a single if statement
    that made the ball bounce, but we have to handle the left and right walls individually,
    since a different player scores depending on which wall is hit. Therefore, we’ve
    split the if statement into two. If the ball hits the left wall ❶, rightScore
    is incremented and the ball is reset with a call to our new initBall function.
    If the ball hits the right wall ❷, leftScore is incremented and the ball is reset.
    The logic for collisions with the top and bottom walls remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since we’ve moved the initialization of the ball state variables to
    the initBall function, we need to call that function before the game loop starts
    in order to set the ball up for the first time. Scroll down to the bottom of *script.js*
    and update the code as shown in [Listing 10-19](#Lis10-19), adding a call to initBall
    before the call to gameLoop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-19: Calling initBall
    for the first time</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you refresh *index.html*, you should see the scores increment when
    the ball hits a side wall, and the ball should reset to its original speed and
    position after a side wall hit. Of course, it’s pretty easy to beat the computer
    right now because it doesn’t move its paddle yet!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Computer Control</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s add some challenge to this game! We want the computer-controlled
    opponent to move the left paddle and try to hit the ball. There are various ways
    to do this, but in our simple approach, we’ll have the computer always try to
    match the current position of the ball. The logic for the computer will be very
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: If the top of the ball is above the top of the paddle, move the paddle up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the bottom of the ball is below the bottom of the paddle, move the paddle
    down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, do nothing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this approach, if the computer could move at any speed, then it would never
    miss. Since this would be no fun for us humans, we’ll set a speed limit for the
    computer. [Listing 10-20](#Lis10-20) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-20: Limiting the
    computer’s speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the computer’s speed limit as a constant, MAX_COMPUTER_SPEED. By
    setting it to 2, we’re saying that the computer isn’t allowed to move the paddle
    more than 2 pixels per frame of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll define a function called followBall that applies some very rudimentary
    artificial intelligence to move the computer’s paddle. The new function is shown
    in [Listing 10-21](#Lis10-21). Add it to your code between the draw function and
    the update function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-21: Computer-controlled
    paddle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Within the followBall function, we define objects representing the ball ❶ and
    the left paddle ❷, each with top and bottom properties representing their upper
    and lower bounds. Then we implement the paddle movement logic with two if statements.
    If the top of the ball is above the top of the paddle ❸, we move the paddle up
    by subtracting MAX_COMPUTER_SPEED from leftPaddleTop. Likewise, if the bottom
    of the ball is below the bottom of the paddle ❹, we move the paddle down by adding
    MAX_COMPUTER_SPEED to leftPaddleTop.
  prefs: []
  type: TYPE_NORMAL
- en: We call our new followBall function within the update function ❺. This way,
    moving the left paddle becomes part of the process of updating the state of the
    game that happens with each iteration of the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and see if you can score a point against the computer!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Game Over</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final step in creating our game is to make it winnable (or losable). To
    do that, we have to add some kind of game over condition, and stop the game loop
    at that point. In this case, we’ll stop the game loop once one of the players
    reaches 10 points, then display the text “GAME OVER.”
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to declare a variable for keeping track of whether or not the
    game is over. We’ll use this variable to decide whether to continue repeating
    the gameLoop function. [Listing 10-22](#Lis10-22) shows the changes to make.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-22: Adding the gameOver
    variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Near the top of *script.js*, we declare a variable called gameOver for recording
    whether the game is over ❶. We initialize it to false so the game doesn’t end
    before it begins. Then, within the checkCollision function, we check to see if
    either of the scores has exceeded 9 ❷. If so, we set gameOver to true. This check
    could happen anywhere, but we do it in checkCollision to keep the logic that increments
    the scores and the logic that checks the scores together.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add a function for writing the text “GAME OVER,” and we’ll modify
    the game loop so it ends when gameOver is true. [Listing 10-23](#Lis10-23) shows
    how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-23: Ending the game</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We define the drawGameOver function after the checkCollision function ❶. It
    draws the text “GAME OVER” to the middle of the canvas in large, white text. To
    position the text in the middle of the canvas, we set the text alignment to "center"
    and use half the canvas width and height as the text’s x- and y-coordinates. (With
    center alignment, the x-coordinate refers to the horizontal midpoint of the text.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the gameLoop function, we’ve wrapped the call to setTimeout in a conditional
    statement that checks the value of the gameOver variable. If it’s true ❷, the
    game is over, so we call the draw and drawGameOver functions. (The draw function
    is needed to display the final score; otherwise, the winning player would still
    be stuck with nine points.) If gameOver is false ❸, the game can continue: we
    keep looping as before by using setTimeout to call gameLoop again after 30 ms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once gameOver becomes true and the game loop ends, the game effectively stops.
    Nothing else will be drawn to the screen after the “GAME OVER” text—at least,
    not until the page is refreshed and the program starts again from the beginning.
    Go ahead and do that now: refresh *index.html* and see if you can beat the computer!
    Once one of you gets more than nine points you should see the “GAME OVER” text,
    as shown in [Figure 10-7](chapter10.xhtml#fig10-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_10-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: Game over</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you beat the computer, but don’t worry if you didn’t—the game is pretty
    hard. Here are some things you can do to make it easier for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Increase the time between frames in gameLoop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the paddles taller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the computer’s max speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it easier to hit the edge of the paddle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the effect on ySpeed of hitting the edge of the paddle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have a working game, you can make any changes you want. If you’re
    already a *Pong* pro, you might want to make it harder instead; the following
    exercises provide a few suggestions. You could also try customizing the appearance,
    or changing the size of the canvas—it’s your game now.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Complete Code</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For your convenience, [Listing 10-24](#Lis10-24) shows the whole *script.js*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-24: The complete
    code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you created a full game from scratch. The basics of game loops,
    collision detection, and rendering are broadly applicable, so with the knowledge
    you’ve acquired here you can start creating all kinds of 2D games. For example,
    you might try implementing your own version of *Breakout* or *Snake*. If you need
    some help with the logic, there are lots of tutorials online that you can follow.
    Have fun!
  prefs: []
  type: TYPE_NORMAL
