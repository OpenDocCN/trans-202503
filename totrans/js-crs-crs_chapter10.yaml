- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PONG</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PONG</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: 'In this first project, you’ll use JavaScript to re-create one of the first
    arcade video games: the classic *Pong* from Atari. *Pong* is a simple game, but
    it will teach you some important aspects of game design: a game loop, player input,
    collision detection, and score keeping. We’ll even use some basic artificial intelligence
    to program the computer opponent.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个项目中，你将使用JavaScript重新创建第一个街机视频游戏之一：Atari经典的*Pong*。*Pong*是一个简单的游戏，但它将教会你一些游戏设计的重要方面：游戏循环、玩家输入、碰撞检测和记分。我们甚至会使用一些基本的人工智能来编程计算机对手。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">游戏</samp>
- en: '*Pong* was developed in 1972 and was released that year as a hugely successful
    arcade machine. It’s a very basic game, like table tennis, consisting of a ball
    and two paddles positioned on the left and right sides of the screen, which the
    players can move up and down. If the ball hits the top or bottom edge of the screen,
    it bounces off, but if it hits the left or right edge the player on the opposite
    side scores a point. The ball bounces off the paddles normally, unless it hits
    near the top or bottom edge of the paddle, in which case the angle of return changes.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pong*于1972年开发，并在同年作为一款极为成功的街机游戏机发布。这是一个非常基础的游戏，类似乒乓球，由一个球和两个挡板组成，挡板分别位于屏幕的左右两侧，玩家可以上下移动它们。如果球碰到屏幕的顶部或底部边缘，它会反弹回来，但如果碰到左右边缘，对方玩家得分。球会正常地从挡板反弹，除非它碰到挡板的顶部或底部边缘，在这种情况下反弹的角度会发生变化。'
- en: In this chapter we’ll make our own version of *Pong*, which we’ll call *Tennjs*
    (like *Tennis* but with *JS*, get it?). In our game, the left paddle will be controlled
    by the computer and the right paddle will be controlled by a human player. In
    the original game, the paddles were controlled with rotating dial controllers,
    but in our version we’ll use the mouse. The computer, rather than trying to anticipate
    where the ball will bounce, will just attempt to always match the vertical position
    of the ball. In order to give the human player a chance, we’ll set an upper limit
    on how fast the computer can move the paddle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将制作一个属于自己的*Pong*版本，我们将其称为*Tennjs*（就像*Tennis*，但加了*JS*，明白了吗？）。在我们的游戏中，左侧的挡板将由计算机控制，右侧的挡板将由人类玩家控制。在原版游戏中，挡板是通过旋转拨盘控制的，但在我们的版本中，我们将使用鼠标。计算机不会尝试预测球会在哪里反弹，而是始终尝试与球的垂直位置保持一致。为了给人类玩家提供机会，我们会对计算机移动挡板的速度设定一个上限。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setup</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置</samp>
- en: We’ll begin by setting up the project’s file structure and creating a canvas
    for displaying the game. As usual, the project will require an HTML file and a
    JavaScript file. We’ll start with the HTML file. Create a directory called *tennjs*
    and a file in that directory called *index.html*. Then enter the content shown
    in [Listing 10-1](#Lis10-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过设置项目的文件结构并创建一个用于显示游戏的画布来开始。和往常一样，项目将需要一个HTML文件和一个JavaScript文件。我们从HTML文件开始。创建一个名为*tennjs*的目录，并在该目录中创建一个名为*index.html*的文件。然后输入[清单
    10-1](#Lis10-1)所示的内容。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file
    for our game</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-1：我们的游戏的</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: This is almost exactly the same as the HTML file we created in [Chapter 9](chapter9.xhtml),
    so there should be no surprises. The body element includes a canvas element, where
    we’ll draw the game, and a script element referencing the file *script.js*, where
    our game code will live.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们在[第9章](chapter9.xhtml)中创建的HTML文件完全相同，因此应该不会有意外。body元素包含一个canvas元素，我们将在其中绘制游戏，还有一个script元素，引用了*script.js*文件，我们的游戏代码将在其中编写。
- en: Next, we’ll write some JavaScript to set up the canvas. Create the file *script.js*,
    and enter the code shown in [Listing 10-2](#Lis10-2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一些JavaScript代码来设置画布。创建*script.js*文件，并输入[清单 10-2](#Lis10-2)所示的代码。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Setting up the
    canvas in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-2：在</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">中设置画布</samp>
- en: This code should also be familiar. We first get a reference to the canvas with
    document.querySelector and get the canvas’s drawing context. Then we save the
    width and height of the canvas to variables called width and height for easy access
    within the code. Finally, we set the fill style to black and draw a black square
    the size of the canvas. This way the canvas appears to have a black background.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该也很熟悉。我们首先通过 `document.querySelector` 获取对画布的引用，并获得画布的绘图上下文。然后，我们将画布的宽度和高度保存到名为
    `width` 和 `height` 的变量中，以便在代码中方便访问。最后，我们将填充样式设置为黑色，并绘制一个与画布大小相同的黑色方块。这样，画布看起来就像是有一个黑色背景。
- en: Open *index.html* in your browser, and you should see something like [Figure
    10-1](chapter10.xhtml#fig10-1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 *index.html*，你应该会看到类似于 [图 10-1](chapter10.xhtml#fig10-1) 的内容。
- en: '![](../images/Figure_10-1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Our black square</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-1：我们的黑色方块</samp>
- en: We now have a blank, black canvas where we can create our game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个空白的黑色画布，可以开始创建我们的游戏了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Ball</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">球</samp>
- en: Next, we’ll draw the ball. Add the code in [Listing 10-3](#Lis10-3) to the end
    of *script.js*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制球。将 [清单 10-3](#Lis10-3) 中的代码添加到 *script.js* 的末尾。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Drawing the ball</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-3：绘制球</samp>
- en: 'This code uses the fillRect method to draw the ball as a small white square
    near the top-left corner of the canvas. As in the original *Pong* game, the ball
    is a square rather than a circle. This gives the game a retro feel, and it will
    also simplify the task of detecting when the ball has collided with the walls
    or with a paddle. The size of the ball is stored in a constant called BALL_SIZE.
    We use the “true constant” all-caps style for the identifier name because the
    ball size won’t change during the course of the program. We could just use the
    value 5 instead of the constant BALL_SIZE when we call the fillRect method to
    draw the ball, but we’re going to end up needing to refer to the ball’s size a
    lot more throughout the program. Giving the size a name will make it much easier
    to understand code that needs to know the size of the ball. The other good thing
    about this approach is that if we change our mind later and decide the ball should
    be bigger or smaller, we have to update the code in only place: the declaration
    of the BALL_SIZE constant.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `fillRect` 方法将球绘制为一个位于画布左上角的小白色方块。就像原版的 *Pong* 游戏一样，球是方形的而不是圆形的。这种设计给游戏带来了复古感，同时也简化了检测球是否与墙壁或挡板碰撞的任务。球的大小保存在一个名为
    BALL_SIZE 的常量中。我们使用全大写的“真常量”风格命名这个标识符，因为球的大小在程序运行过程中不会改变。如果我们仅仅在调用 `fillRect`
    方法绘制球时直接使用值 5，而不是常量 BALL_SIZE，也能实现同样的效果，但随着程序的进行，我们会多次引用球的大小。给球的大小命名将使得需要了解球大小的代码更容易理解。这个方法的另一个好处是，如果我们后来改变主意，决定让球变大或变小，那么我们只需要更新代码中的一个地方：BALL_SIZE
    常量的声明。
- en: We keep track of the ball’s position with an object containing its x- and y-coordinates,
    created using an object literal ❶. In [Chapter 9](chapter9.xhtml) we used separate
    variables for the x- and y-coordinates of the circle that was being drawn, but
    it’s a bit tidier to store the two variables together as one object, especially
    since this program is going to be longer and more complex.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个包含球的 x 和 y 坐标的对象来跟踪球的位置，该对象是通过对象字面量 ❶ 创建的。在 [第 9 章](chapter9.xhtml)中，我们为正在绘制的圆形使用了单独的
    x 和 y 坐标变量，但将这两个变量作为一个对象存储在一起会更整洁，尤其是因为这个程序会变得更长且更复杂。
- en: Refresh *index.html* and you should see the white ball sitting in the top-left
    corner of the canvas, as shown in [Figure 10-2](chapter10.xhtml#fig10-2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新 *index.html*，你应该能看到白色的球出现在画布的左上角，如 [图 10-2](chapter10.xhtml#fig10-2) 所示。
- en: '![](../images/Figure_10-2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The ball</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-2：球</samp>
- en: The ball is stationary for now, but soon enough we’ll write code to make it
    move.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 球现在是静止的，但很快我们将编写代码使其移动。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">重构</samp>
- en: Next we’re going to do a simple refactor. *Refactoring* is a software development
    term for modifying some code without changing its behavior, usually to make the
    code easier to understand or update. As the code for a project grows more complex,
    refactoring can help keep it organized.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行一个简单的重构。*重构*是软件开发中的一个术语，指的是在不改变代码行为的情况下修改代码，通常是为了使代码更易于理解或更新。随着项目代码的复杂性增加，重构有助于保持代码的组织性。
- en: In this case, I know that we’re going to want to draw to the canvas multiple
    times, not just once. In fact, we’ll eventually want to redraw the canvas once
    every 30 ms to give our game the appearance of motion. To make that easier to
    accomplish, we’ll refactor so all the current drawing code becomes part of a function
    called draw. That way we can simply call the draw function anytime we want to
    redraw the canvas.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我知道我们需要多次绘制到画布上，而不仅仅是一次。事实上，我们最终希望每30毫秒重新绘制一次画布，以使游戏呈现运动的效果。为了更容易实现这一点，我们将重构，使所有当前的绘图代码成为名为draw的函数的一部分。这样，我们可以在任何时候调用draw函数来重新绘制画布。
- en: Update *script.js* with the changes shown in [Listing 10-4](#Lis10-4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用[清单 10-4](#Lis10-4)中的更改更新*script.js*。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Refactoring the
    drawing code</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-4：重构绘图代码</samp>
- en: The only change here is to group all the drawing code into a single function
    called draw ❶, which we then immediately call ❷. Because it’s a refactoring, nothing
    actually changes in the behavior of the program. You can refresh *index.html*
    to confirm that everything still looks as before.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是将所有绘图代码组织成一个名为draw ❶的单一函数，然后立即调用它 ❷。由于这是重构，因此程序的行为并没有实际变化。你可以刷新*index.html*来确认一切看起来仍然如之前一样。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Game Loop</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">游戏循环</samp>
- en: 'Almost all games contain a *game loop* that orchestrates everything that has
    to happen for each frame of the game. Game loops are similar to animation loops,
    like the one we looked at in [Chapter 9](chapter9.xhtml), but with some additional
    logic. Here’s the general shape of the game loop in most games:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的游戏都包含一个*游戏循环*，它协调每一帧游戏中必须发生的一切。游戏循环与我们在[第9章](chapter9.xhtml)中看到的动画循环类似，但有一些额外的逻辑。以下是大多数游戏中游戏循环的一般结构：
- en: 1.  Clear canvas
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  清除画布
- en: 2.  Draw image
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  绘制图像
- en: 3.  Get player input
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  获取玩家输入
- en: 4.  Update state
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  更新状态
- en: 5.  Check collisions
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  检查碰撞
- en: 6.  Wait a short time
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  等待短暂时间
- en: 7.  Repeat
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  重复
- en: 'Getting and acting on input from a player (or players) is the main thing that
    distinguishes a game from an animation. *Collision detection* is another important
    aspect of most games: checking for when two objects in the game meet and responding
    accordingly. Collision detection is what stops you from walking through walls
    or driving through another car—and in this case, it’s what will make the ball
    bounce off the walls and paddles. Apart from the player input and collision detection
    elements, the steps in the game loop are more or less the same as in an animation
    loop: we clear the canvas, draw the image, update the state of the game to move
    objects to their new positions, pause, and repeat.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 获取并处理玩家（或玩家们）的输入是将游戏与动画区分开的主要特征。*碰撞检测*是大多数游戏中的另一个重要方面：检查游戏中两个物体何时相遇并作出相应反应。碰撞检测可以阻止你穿过墙壁或开车撞上另一辆车——在这个案例中，它会让小球从墙壁和挡板上弹回。除了玩家输入和碰撞检测元素外，游戏循环中的步骤与动画循环大致相同：我们清除画布，绘制图像，更新游戏状态以将物体移动到新位置，暂停，然后重复。
- en: Rather than trying to write the whole game loop at once, we’ll build it up gradually.
    Update *script.js* with the content in [Listing 10-5](#Lis10-5), which will be
    the beginnings of the game loop in our game. This code moves the ball (that is,
    updates the ball’s state), redraws the canvas, pauses, and repeats.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会试图一次性写完整个游戏循环，而是逐步构建它。用[清单 10-5](#Lis10-5)中的内容更新*script.js*，这将成为我们游戏中游戏循环的起始部分。此代码移动小球（即更新小球的状态），重绘画布，暂停，然后重复。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: The game loop</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-5：游戏循环</samp>
- en: The first change here is to initialize two new variables ❶, xSpeed and ySpeed.
    We’ll use these to control the horizontal and vertical speed of the ball. The
    new update function ❷ uses these two variables to update the position of the ball.
    For every frame, the ball will move xSpeed pixels along the x-axis and ySpeed
    pixels along the y-axis. The two variables start out at 4 and 2, so every frame
    the ball will move 4 pixels to the right and 2 pixels down.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个变化是初始化两个新变量 ❶，`xSpeed` 和 `ySpeed`。我们将使用这两个变量来控制球的水平和垂直速度。新的 `update` 函数
    ❷ 使用这两个变量来更新球的位置。每帧，球将沿 x 轴移动 `xSpeed` 像素，沿 y 轴移动 `ySpeed` 像素。这两个变量的初始值分别为 4 和
    2，因此每帧球会向右移动 4 像素，向下移动 2 像素。
- en: The gameLoop function ❸ calls the draw function followed by the update function.
    Then it calls setTimeout(gameLoop, 30), which will call the gameLoop function
    again after 30 ms. This is almost exactly the same as the setInterval technique
    we used in [Chapter 9](chapter9.xhtml). You may recall that setTimeout calls its
    function only once after the timeout, while setInterval calls its function repeatedly.
    We’re using setTimeout here so we have more control over whether or not to keep
    looping; later on we’ll add some conditional logic to either call setTimeout or
    end the game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameLoop` 函数 ❸ 调用 `draw` 函数，然后是 `update` 函数。接着它调用 `setTimeout(gameLoop, 30)`，这样
    `gameLoop` 函数将在 30 毫秒后再次被调用。这几乎与我们在[第 9 章](chapter9.xhtml)中使用的 `setInterval` 技术完全相同。你可能还记得，`setTimeout`
    只会在超时后调用一次函数，而 `setInterval` 会反复调用其函数。我们这里使用 `setTimeout` 是为了能更好地控制是否继续循环；稍后我们将添加一些条件逻辑，决定是否继续调用
    `setTimeout` 或结束游戏。'
- en: Notice the line above the setTimeout call beginning with two slashes (//). This
    is an example of a *comment*, a note for yourself (or other people reading your
    code) embedded in the program file. When a JavaScript program executes, any text
    on a line following a // is ignored (anything on the line before the // is still
    evaluated as JavaScript code). Thus, you can use comments like this to explain
    how the code works, highlight important features, or make note of something you
    still need to do, without affecting the functionality of the program.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上面 `setTimeout` 调用之前以两个斜杠（//）开头的那一行。这是一个*注释*，是嵌入在程序文件中的个人备注（或其他阅读代码的人备注）。当
    JavaScript 程序执行时，任何在 // 后面的文本都会被忽略（// 前面的部分仍然会被作为 JavaScript 代码执行）。因此，你可以像这样使用注释来解释代码的工作原理、突出重要功能，或者记录需要完成的事项，而不会影响程序的功能。
- en: At the end of the script, we call the gameLoop function ❹ to set the game in
    motion. Since gameLoop currently ends with setTimeout, the result is that gameLoop
    will be repeatedly called once every 30 ms. Reload your page and you should see
    the ball move down and to the right, much like the animation from [Chapter 9](chapter9.xhtml).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的末尾，我们调用 `gameLoop` 函数 ❹ 来启动游戏。由于 `gameLoop` 目前以 `setTimeout` 结束，结果是 `gameLoop`
    每 30 毫秒会被重复调用一次。重新加载页面后，你应该能看到球向下和向右移动，和[第 9 章](chapter9.xhtml)中的动画类似。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Bouncing</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反弹</samp>
- en: In the previous section you got the ball moving, but it just flew off the edge
    of the canvas. Next you’ll learn how to make it bounce off the edge of the canvas
    at the appropriate angle—our first collision detection code. Update *script.js*
    with the code in [Listing 10-6](#Lis10-6), which adds a checkCollision function
    to our game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经让球开始移动，但它只是飞出了画布的边缘。接下来你将学习如何使它以合适的角度从画布边缘反弹——我们的第一个碰撞检测代码。用[清单 10-6](#Lis10-6)中的代码更新
    *script.js*，这段代码为我们的游戏添加了一个 `checkCollision` 函数。
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Wall collision
    detection</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-6：墙面碰撞检测</samp>
- en: 'The new function, checkCollision, checks to see if the ball has collided with
    one of the four walls of the canvas. If it has, it updates xSpeed or ySpeed as
    appropriate to make the ball bounce off the wall. First, we calculate values for
    the edges of the ball. We need to know where the left, right, top, and bottom
    edges are to determine if these edges have exceeded the bounds of the playing
    area. We group the values in an object called ball ❶ that has left, right, top,
    and bottom properties. Identifying the left and top ball edges is easy: they’re
    ballPosition.x and ballPosition.y, respectively. To get the right and bottom edges,
    we add BALL_SIZE to ballPosition.x and ballPosition.y. This is one of those cases
    noted earlier where having access to the ball’s size as a constant is helpful.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数 checkCollision 用于检查球是否与画布的四面墙发生碰撞。如果发生碰撞，它会根据需要更新 xSpeed 或 ySpeed，使球反弹回墙壁。首先，我们需要计算球的各个边缘的位置。我们需要知道球的左边缘、右边缘、上边缘和下边缘的位置，以确定这些边缘是否超出了游戏区域的边界。我们将这些值放在一个名为
    ball ❶ 的对象中，这个对象包含了 left、right、top 和 bottom 属性。确定球的左边缘和上边缘很简单：它们分别是 ballPosition.x
    和 ballPosition.y。为了得到右边缘和下边缘，我们需要将 BALL_SIZE 加到 ballPosition.x 和 ballPosition.y
    上。这是前面提到的那种情况，利用常量 BALL_SIZE 来获取球的尺寸会非常有用。
- en: 'Next, we perform the actual collision detection. If the left edge of the ball
    is less than 0 or the right edge of the ball is greater than the width of the
    canvas ❷, we know that the ball has hit the left or right wall. In both cases,
    the math is the same: the new value of xSpeed should be the negative of the current
    value (that is, the value is *negated*). For example, the first time the ball
    hits the right edge, xSpeed will go from 4 to -4. Meanwhile, ySpeed remains unchanged.
    As a result, the ball continues moving down the screen at the same rate, but now
    it’s moving to the left instead of to the right.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行实际的碰撞检测。如果球的左边缘小于 0 或球的右边缘大于画布的宽度❷，我们就知道球已经撞到左墙或右墙。在这两种情况下，数学操作是一样的：xSpeed
    的新值应该是当前值的相反数（也就是值被*取反*）。例如，当球第一次撞到右边缘时，xSpeed 会从 4 变为 -4。与此同时，ySpeed 保持不变。因此，球会以相同的速度继续向下移动，但现在它向左移动，而不是向右移动。
- en: The same kind of check happens for the top of the ball colliding with the top
    wall or the bottom of the ball colliding with the bottom wall ❸. In either of
    these cases, we negate ySpeed, changing it from 2 to -2 when the ball hits the
    top edge, or from -2 to 2 when the ball hits the bottom edge.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当球的顶部与上墙碰撞，或球的底部与下墙碰撞时，都会发生相同的检查❸。在这两种情况下，我们会改变 ySpeed 的符号，当球撞到顶部时，ySpeed 从
    2 变为 -2，或者当球撞到底部时，ySpeed 从 -2 变为 2。
- en: The only other change to the code is to add a call to checkCollision to the
    list of things that happen in the gameLoop function ❹. Now when you refresh *index.html*,
    you should see the ball continuously bounce around the play area.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的其他代码更改是将对 checkCollision 的调用添加到 gameLoop 函数 ❹ 中。现在，当你刷新 *index.html* 时，应该能看到球在游戏区域内不断反弹。
- en: If you’ve been paying attention, you might have noticed that the ball isn’t
    supposed to bounce off the left and right walls. Once we have moving paddles,
    we’ll modify the collision detection code to only bounce off the paddles or the
    top and bottom walls, and to score a point for a side wall collision.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在关注，可能已经注意到，球本不应该反弹到左右墙上。一旦我们有了可移动的挡板，我们会修改碰撞检测代码，使球只会在挡板或上下墙上反弹，同时对于左右墙的碰撞，我们会得分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Paddles</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">挡板</samp>
- en: Our next task is to draw the two paddles. To do that we’ll first introduce some
    new constants that establish the paddle dimensions and their horizontal position
    relative to the sides of the canvas, as well as some variables defining their
    vertical positions. (The paddles can only move up and down, not from side to side,
    so only their vertical positions need to be variables.) Update *script.js* with
    the changes in [Listing 10-7](#Lis10-7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是绘制两个挡板。为此，我们首先引入一些新的常量，来确定挡板的尺寸及其相对于画布两侧的水平位置，以及一些定义其垂直位置的变量。（挡板只能上下移动，不能左右移动，因此只需要定义它们的垂直位置作为变量。）根据[清单
    10-7](#Lis10-7)中的更改，更新 *script.js* 文件。
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: Defining the
    paddles</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-7：定义挡板</samp>
- en: First we set up the constants that define the paddles. PADDLE_WIDTH and PADDLE_HEIGHT
    define both paddles to be 5 pixels wide and 20 pixels tall. PADDLE_OFFSET refers
    to the distance of the paddle from the left or right edge of the playing area.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置定义球拍的常量。PADDLE_WIDTH和PADDLE_HEIGHT定义了两个球拍的宽度为5像素，高度为20像素。PADDLE_OFFSET指的是球拍与游戏区域左右边缘的距离。
- en: The variables leftPaddleTop and rightPaddleTop define the current vertical position
    of the top of each paddle. Eventually, leftPaddleTop will be controlled by the
    computer through a function we’ll write to follow the ball, and rightPaddleTop
    will be updated when the player moves the mouse. For now, we’re simply setting
    these values to 10 and 30, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 变量leftPaddleTop和rightPaddleTop定义了每个球拍顶部的当前垂直位置。最终，leftPaddleTop将通过我们编写的函数由计算机控制，跟随球的位置，而rightPaddleTop将在玩家移动鼠标时更新。现在，我们只是将这两个值分别设置为10和30。
- en: Next, we update the draw function to display the paddles using the information
    we just defined. I’ve also added comments to the code to clarify what’s happening
    at each step of the draw function. Modify the code as shown in [Listing 10-8](#Lis10-8).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新绘制函数，使用我们刚刚定义的信息来显示球拍。我还在代码中添加了注释，明确每一步绘制函数的作用。按照[清单10-8](#Lis10-8)所示修改代码。
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: Drawing the paddles</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单10-8：绘制球拍</samp>
- en: In addition to some extra comments to help document the program, the new code
    features two calls to fillRect, one for drawing the left paddle ❶ and one for
    the right ❷. I’ve split the arguments over multiple lines because the identifiers
    are so long. Remember that the parameters to fillRect are x, y, width, and height,
    where x and y are the coordinates of the top-left corner of the rectangle. The
    x-coordinate of the left paddle is PADDLE_OFFSET because we’re using that to mean
    the paddle’s distance from the left edge of the canvas, while the y-coordinate
    of the left paddle is just leftPaddleTop. The width and height arguments are the
    PADDLE_WIDTH and PADDLE_HEIGHT constants.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助文档化程序的额外注释外，新的代码包含了两次调用fillRect，一个用于绘制左边的球拍❶，另一个用于右边的球拍❷。由于标识符太长，我将参数分成了多行。记住，fillRect的参数是x、y、宽度和高度，其中x和y是矩形左上角的坐标。左边球拍的x坐标是PADDLE_OFFSET，因为我们用它表示球拍与画布左边缘的距离，而左边球拍的y坐标就是leftPaddleTop。宽度和高度参数是PADDLE_WIDTH和PADDLE_HEIGHT常量。
- en: 'The right paddle is a bit more complicated to draw: to get the x-coordinate
    of the paddle’s top-left corner, we need to take the width of the canvas and subtract
    the width of the paddle and the offset of the paddle from the right edge. Given
    that the width of the canvas is 500, and the paddle width and offset are both
    10, that means the x-coordinate of the right paddle is 480.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 右边的球拍绘制稍微复杂一些：为了获取球拍左上角的x坐标，我们需要用画布的宽度减去球拍的宽度和球拍从右边缘的偏移量。给定画布的宽度为500，球拍宽度和偏移量都为10，这意味着右边球拍的x坐标是480。
- en: When you refresh *index.html*, you should see the two paddles in addition to
    the bouncing ball, as shown in [Figure 10-3](chapter10.xhtml#fig10-3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刷新*index.html*时，除了弹跳的球之外，你应该能看到两个球拍，如[图10-3](chapter10.xhtml#fig10-3)所示。
- en: '![](../images/Figure_10-3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: The paddles and
    ball</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-3：球拍和球</samp>
- en: Note that the ball currently passes straight through the paddles, because we
    haven’t set up collision detection for the paddles yet. We’ll get to that later
    in this section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，球现在会直接穿过球拍，因为我们还没有为球拍设置碰撞检测。我们稍后会在本节中讲解如何设置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Moving the Paddles
    with Player Input</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">通过玩家输入移动球拍</samp>
- en: The paddles are drawn at the vertical positions given by the variables leftPaddleTop
    and rightPaddleTop, so to make the paddles move up and down, we just have to update
    the values of these variables. Right now we’re concerned only with the right paddle,
    which will be controlled by the human player.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 球拍是在由变量leftPaddleTop和rightPaddleTop给定的垂直位置绘制的，因此为了让球拍上下移动，我们只需要更新这些变量的值。目前我们只关心右边的球拍，它将由玩家控制。
- en: To let the player control the right paddle, we’ll add an event handler to *script.js*
    that listens for mousemove events. [Listing 10-9](#Lis10-9) shows how it’s done.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家控制右侧挡板，我们将在 *script.js* 中添加一个事件处理程序来监听 mousemove 事件。[列表 10-9](#Lis10-9)
    显示了如何实现。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: Adding an event
    handler to move the right paddle</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-9：添加事件处理程序以移动右侧挡板</samp>
- en: This code follows the same pattern for event handling that you first saw in
    [Chapter 8](chapter8.xhtml). We use document.addEventListener to check for mouse
    movements. When one is detected, the event handler function updates the value
    of rightPaddleTop based on the y-coordinate of the mousemove event (e.y). The
    y-coordinate is relative to the top of the page, not the top of the canvas, so
    we subtract canvas.offsetTop (the distance from the top of the canvas to the top
    of the page) from the y-coordinate. This way the assigned rightPaddleTop value
    will be based on the distance of the mouse from the top of the canvas, and the
    paddle will follow the mouse accurately.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遵循了你在[第 8 章](chapter8.xhtml)中首次看到的事件处理模式。我们使用 document.addEventListener
    来检测鼠标移动。当检测到鼠标移动时，事件处理函数会根据鼠标移动事件的 y 坐标 (e.y) 更新 rightPaddleTop 的值。这个 y 坐标是相对于页面顶部的，而不是相对于画布顶部，因此我们需要从
    y 坐标中减去 canvas.offsetTop（从画布顶部到页面顶部的距离）。这样，分配给 rightPaddleTop 的值将基于鼠标到画布顶部的距离，挡板将准确地跟随鼠标。
- en: Refresh *index.html*, and you should see the right paddle move vertically as
    the mouse moves up and down. [Figure 10-4](chapter10.xhtml#fig10-4) shows how
    it should look.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新 *index.html*，你应该会看到右侧挡板随着鼠标上下移动而垂直移动。[图 10-4](chapter10.xhtml#fig10-4) 显示了应该是什么样子。
- en: '![](../images/Figure_10-4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: The right paddle
    moving with the mouse</samp>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-4：右侧挡板随着鼠标移动</samp>
- en: Our game has now officially become interactive! The player has full control
    of the position of the right paddle.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在正式变得具有互动性！玩家可以完全控制右侧挡板的位置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Paddle
    Collisions</samp>
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检测挡板碰撞</samp>
- en: The next step is to add collision detection for the paddles. We need to know
    if the ball has hit a paddle and, if so, make the ball bounce off the paddle appropriately.
    This requires a lot of code, so I’ll break it up over a few listings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为挡板添加碰撞检测。我们需要知道球是否击中了挡板，如果是的话，要让球适当地从挡板反弹。这需要很多代码，所以我会将其拆分成几个列表来展示。
- en: The first thing we have to do is create objects defining the four edges of the
    two paddles, as we did for the ball in [Listing 10-6](#Lis10-6). These changes
    are shown in [Listing 10-10](#Lis10-10).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建定义两个挡板四个边缘的对象，就像我们在[列表 10-6](#Lis10-6)中为球所做的那样。这些更改在[列表 10-10](#Lis10-10)中显示。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: Defining the
    edges of the paddles</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-10：定义挡板的边缘</samp>
- en: The leftPaddle and rightPaddle objects contain the edges of their respective
    paddles as four properties, left, right, top, and bottom. As in [Listing 10-8](#Lis10-8),
    determining where the edges of the right paddle are requires a bit more math because
    we have to take into account the width of the canvas, the offset of the paddle,
    and the width of the paddle.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: leftPaddle 和 rightPaddle 对象分别包含它们各自挡板的四个边缘属性：left、right、top 和 bottom。就像在[列表
    10-8](#Lis10-8)中一样，确定右侧挡板的边缘位置需要一些额外的数学计算，因为我们必须考虑到画布的宽度、挡板的偏移量和挡板的宽度。
- en: Next we need a function, which we’ll call checkPaddleCollision, that takes the
    ball object and one of the paddle objects and returns true if the ball is intersecting
    with that paddle. The function definition is shown in [Listing 10-11](#Lis10-11).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数，命名为 checkPaddleCollision，该函数接受球对象和一个挡板对象，并在球与该挡板相交时返回 true。该函数的定义在[列表
    10-11](#Lis10-11)中显示。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: The checkPaddleCollision
    function</samp>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-11：checkPaddleCollision
    函数</samp>
- en: 'This function will be called with the ball and each of the paddle objects defined
    earlier. It uses a long Boolean expression made up of four subexpressions that
    are all &&’d together, so it returns true only if all four subexpressions are
    true. (I added spacing to each subexpression so the operands line up vertically;
    this is just to make the code easier to read.) In English, the subexpressions
    say:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会与之前定义的球和每个球拍对象一起被调用。它使用一个较长的布尔表达式，由四个子表达式组成，这四个子表达式通过 && 运算符连接在一起，因此只有当所有四个子表达式都为真时，才会返回
    true。（我为每个子表达式添加了空格，使得操作数垂直对齐；这样做只是为了让代码更易读。）用英文描述，子表达式如下：
- en: 1.  The left edge of the ball must be to the left of the right edge of the paddle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 球的左边缘必须位于球拍的右边缘的左侧。
- en: 2.  The right edge of the ball must be to the right of the left edge of the
    paddle.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 球的右边缘必须位于球拍的左边缘的右侧。
- en: 3.  The top edge of the ball must be above the bottom edge of the paddle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 球的上边缘必须位于球拍的下边缘之上。
- en: 4.  The bottom edge of the ball must be below the top edge of the paddle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 球的下边缘必须位于球拍的上边缘之下。
- en: If the first two conditions are true, the ball is intersecting horizontally,
    and if the last two conditions are true, the ball is intersecting vertically.
    The ball is truly intersecting with the paddle only if all four conditions are
    true. To illustrate this, see [Figure 10-5](chapter10.xhtml#fig10-5).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前两个条件为真，表示球在水平方向上相交；如果最后两个条件为真，表示球在垂直方向上相交。只有当四个条件都为真时，球才真正与球拍相交。为了说明这一点，请参见[图
    10-5](chapter10.xhtml#fig10-5)。
- en: 'The figure shows four possible scenarios we might check. In all the scenarios,
    the paddle has the following bounds: {left: 10, right: 15, top: 5, bottom: 25}.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '该图展示了我们可能需要检查的四种情况。在所有这些情况下，球拍的边界为：{left: 10, right: 15, top: 5, bottom: 25}。'
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(a), ball has the bounds {left: 20,
    right: 25, top: 30, bottom: 35}. In this case, ball.left < paddle.right is false
    (the left side of the ball is not to the left of the right side of the paddle),
    but ball.right > paddle.left is true. Likewise, ball.top < paddle.bottom is false
    and ball.bottom > paddle.top is true. The ball is neither vertically nor horizontally
    intersecting with the paddle.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '在[图 10-5](chapter10.xhtml#fig10-5)(a)中，球的边界为{left: 20, right: 25, top: 30,
    bottom: 35}。在这种情况下，ball.left < paddle.right 为假（球的左边并没有位于球拍右边的左侧），但 ball.right
    > paddle.left 为真。同样，ball.top < paddle.bottom 为假，而 ball.bottom > paddle.top 为真。球既没有在垂直方向上与球拍相交，也没有在水平方向上与球拍相交。'
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(b), ball has the bounds {left: 20,
    right: 25, top: 22, bottom: 27}. This time, ball.top < paddle.bottom and ball.bottom
    > paddle.top are both true, which means that the ball is vertically intersecting
    with the paddle, but not horizontally intersecting.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '在[图 10-5](chapter10.xhtml#fig10-5)(b)中，球的边界为{left: 20, right: 25, top: 22,
    bottom: 27}。这一次，ball.top < paddle.bottom 和 ball.bottom > paddle.top 都为真，这意味着球在垂直方向上与球拍相交，但在水平方向上没有相交。'
- en: 'In [Figure 10-5](chapter10.xhtml#fig10-5)(c), ball has the bounds {left: 13,
    right: 18, top: 30, bottom: 35}. In this case, the ball is horizontally intersecting
    with the paddle, but not vertically intersecting.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '在[图 10-5](chapter10.xhtml#fig10-5)(c)中，球的边界为{left: 13, right: 18, top: 30,
    bottom: 35}。在这种情况下，球在水平方向上与球拍相交，但在垂直方向上没有相交。'
- en: 'Finally, in [Figure 10-5](chapter10.xhtml#fig10-5)(d), ball has the bounds
    {left: 13, right: 18, top: 22, bottom: 27}. Now the ball is both horizontally
    and vertically intersecting with the paddle. All four subexpressions are true,
    so check PaddleCollision returns true.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，在[图 10-5](chapter10.xhtml#fig10-5)(d)中，球的边界为{left: 13, right: 18, top: 22,
    bottom: 27}。现在，球在水平方向和垂直方向上都与球拍相交。四个子表达式都为真，因此检查 PaddleCollision 返回 true。'
- en: '![](../images/Figure_10-5.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: Collision detection
    conditions</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-5：碰撞检测条件</samp>
- en: Now it’s time to actually call the checkPaddleCollision function from within
    the checkCollision function, once for each paddle, and handle the case where the
    function returns true. You can find this code in [Listing 10-12](#Lis10-12).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在 checkCollision 函数内部实际调用 checkPaddleCollision 函数了，每个球拍调用一次，并处理函数返回 true
    的情况。你可以在[代码清单 10-12](#Lis10-12)中找到这个代码。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-12: Checking for
    paddle collisions</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">代码清单 10-12：检查球拍碰撞</samp>
- en: Remember that checkPaddleCollision takes an object representing the ball and
    an object representing a paddle and returns true if the two are intersecting.
    If checkPaddleCollision(ball, leftPaddle) returns true, we set xSpeed to Math.abs(xSpeed)
    ❶, which has the effect of setting it to 4 because in our game xSpeed is only
    ever 4 (when moving to the right) or -4 (when moving to the left).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，checkPaddleCollision 接受一个表示球的对象和一个表示球拍的对象，并且如果两者相交则返回 true。如果 checkPaddleCollision(ball,
    leftPaddle) 返回 true，我们将 xSpeed 设置为 Math.abs(xSpeed) ❶，这样会将它设置为 4，因为在我们的游戏中 xSpeed
    只有两个值：4（向右移动时）或 -4（向左移动时）。
- en: You might be wondering why we didn’t just negate xSpeed, as we did with the
    vertical wall collision code earlier. Using the absolute value is a little trick
    to avoid multiple collisions that could send the ball bouncing back and forth
    “inside” the paddle. It’s possible that if the ball hits at just the right point
    at the end of the paddle it will get bounced back, but the next frame will also
    result in a collision with the same paddle. If we were negating the xSpeed, then
    it would just keep bouncing. By forcing the updated xSpeed to be positive, we
    can ensure that a collision with the left paddle will always result in the ball
    bouncing to the right.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们没有像之前在垂直墙壁碰撞代码中那样仅仅取反 xSpeed。使用绝对值是一个小技巧，可以避免多次碰撞，这样球就不会在球拍“内部”来回弹跳。如果球恰好在球拍的末端碰撞，它可能会被弹回，但下一帧也会与同一个球拍发生碰撞。如果我们取反
    xSpeed，那么球就会一直弹跳。通过强制更新后的 xSpeed 为正数，我们可以确保与左侧球拍的碰撞总是使球向右弹跳。
- en: Following this, we do the same thing with the right paddle. In this case, if
    there’s a collision we update xSpeed to -Math.abs(xSpeed) ❷, which in effect is
    -4, meaning that the ball will bounce to the left.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对右侧球拍做同样的处理。在这种情况下，如果发生碰撞，我们将 xSpeed 更新为 -Math.abs(xSpeed) ❷，这实际上是 -4，意味着球将向左弹跳。
- en: Refresh *index.html* again, and try to move the right paddle with your mouse
    so the ball hits it. You should now have ball-paddle bounces happening! At this
    point the ball can still safely bounce off the side walls, but we’ll fix that
    soon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次刷新 *index.html*，然后试着用鼠标移动右侧球拍，让球击中它。现在你应该可以看到球与球拍发生弹跳了！此时，球仍然可以安全地从侧墙反弹，但我们很快会修复这个问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bouncing Near the
    Paddle Ends</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在球拍边缘附近弹跳</samp>
- en: I mentioned at the beginning of this chapter that in *Pong* you can change the
    angle of the ball’s bounce by hitting it near the top or bottom of the paddle.
    We’ll implement that functionality now. First we’ll add a new function called
    adjustAngle immediately before checkCollision. It checks if the ball is near the
    top or bottom of the paddle, and updates ySpeed if it is. See [Listing 10-13](#Lis10-13)
    for the code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章开头提到过，在 *Pong* 中，你可以通过在球拍的顶部或底部附近击打球来改变球的弹跳角度。现在我们将实现这个功能。首先，我们会添加一个新的函数，名为
    adjustAngle，紧接在 checkCollision 之前。它检查球是否靠近球拍的顶部或底部，如果是，就更新 ySpeed。请参考 [清单 10-13](#Lis10-13)
    查看代码。
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-13: Adjusting the
    bounce angle</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-13: 调整弹跳角度</samp>'
- en: The adjustAngle function has two parameters, distanceFromTop and distanceFromBottom.
    These represent the distance from the top of the ball to the top of the paddle
    and from the bottom of the paddle to the bottom of the ball, respectively. The
    function first checks if distanceFromTop is less than 0 ❶. If so, that means the
    top edge of the ball is above the top edge of the paddle at collision time, which
    is how we’ll define being near the top of the paddle. In this case, we subtract
    0.5 from ySpeed. If the ball is moving down the screen when it hits near the top
    of the paddle, then ySpeed is positive, so subtracting 0.5 reduces the vertical
    speed. For example, at the start of the game, ySpeed is 2. If you align the paddle
    so the ball hits the top, ySpeed will become 1.5 after the bounce, effectively
    reducing the angle of bounce. However, if the ball is moving up the screen, then
    ySpeed is negative. In this case, subtracting 0.5 after a hit near the top of
    the paddle will increase the ball’s vertical speed. For example, a ySpeed of -2
    will become -2.5.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjustAngle` 函数有两个参数，`distanceFromTop` 和 `distanceFromBottom`。这两个参数分别表示球的顶部到球拍顶部的距离，以及球拍底部到球底部的距离。该函数首先检查
    `distanceFromTop` 是否小于 0 ❶。如果是，这意味着在碰撞时球的顶部边缘位于球拍的顶部边缘之上，这就是我们定义球接近球拍顶部的方式。在这种情况下，我们从
    `ySpeed` 中减去 0.5。如果球在接近球拍顶部时向下移动屏幕，那么 `ySpeed` 为正数，因此减去 0.5 会减少垂直速度。例如，在游戏开始时，`ySpeed`
    为 2。如果你调整球拍使得球击中顶部，弹跳后 `ySpeed` 会变为 1.5，有效地减少了弹跳的角度。然而，如果球向上移动屏幕，那么 `ySpeed` 为负数。在这种情况下，球拍顶部附近的碰撞后减去
    0.5 会增加球的垂直速度。例如，`ySpeed` 为 -2 时，碰撞后会变为 -2.5。'
- en: If the ball hits near the bottom of the paddle ❷, the opposite happens. In this
    case, we add 0.5 to ySpeed, increasing the vertical speed if the ball is moving
    down the screen or decreasing the speed if the ball is moving up the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球击中球拍的底部附近 ❷，情况则相反。在这种情况下，我们将 `ySpeed` 增加 0.5，如果球向下移动屏幕，则增加垂直速度；如果球向上移动屏幕，则减慢垂直速度。
- en: Next, we need to update the checkCollision function to call the new adjustAngle
    function as part of the collision detection logic for the two paddles. [Listing
    10-14](#Lis10-14) shows the changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新 `checkCollision` 函数，将新的 `adjustAngle` 函数作为两个球拍碰撞检测逻辑的一部分来调用。[Listing
    10-14](#Lis10-14) 显示了相关的修改。
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-14: Calling adjustAngle</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-14: 调用 adjustAngle</samp>'
- en: Within the if statement for each paddle, we declare distanceFromTop and distanceFromBottom,
    the arguments needed for the adjustAngle function. Then we call adjustAngle before
    updating xSpeed as before.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个球拍的 `if` 语句内，我们声明了 `distanceFromTop` 和 `distanceFromBottom`，这些是 `adjustAngle`
    函数所需的参数。然后我们像以前一样，在更新 `xSpeed` 之前调用 `adjustAngle`。
- en: Now try out the game and see if you can hit the ball near the edge of the paddle!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下游戏，看看你能否将球击中球拍的边缘附近！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Scoring Points</samp>
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">得分</samp>
- en: Games are usually more fun when you can win or lose. In *Pong*, you score a
    point if you hit the wall behind the opposing player’s paddle. When this happens,
    the ball gets reset to its starting position and speed for the next round of play.
    We’ll deal with that part in this section too, but first, to keep track of the
    scores, we’ll need to create some new variables. Update *script.js* with the code
    in [Listing 10-15](#Lis10-15).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常在你可以赢或输的时候更有趣。在 *Pong* 中，当你击中对方球拍后方的墙壁时，你会得分。发生这种情况时，球会重置到起始位置并恢复速度，进入下一轮游戏。我们将在本节中处理这一部分，但首先，为了跟踪得分，我们需要创建一些新的变量。使用
    [Listing 10-15](#Lis10-15) 中的代码更新 *script.js* 文件。
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-15: Variables to
    keep track of the scores</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-15: 用于跟踪得分的变量</samp>'
- en: Here we declare two new variables, leftScore and rightScore, and set them both
    to 0. Later we’ll add logic to increment these variables when points are scored.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们声明了两个新变量，`leftScore` 和 `rightScore`，并将它们的初始值设置为 0。稍后我们会添加逻辑，当得分时递增这两个变量。
- en: Next, we’ll add code for displaying the scores to the end of the draw function.
    Update the function as shown in [Listing 10-16](#Lis10-16).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `draw` 函数的末尾添加显示得分的代码。按照 [Listing 10-16](#Lis10-16) 中的方式更新该函数。
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-16: Drawing the
    scores</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-16: 绘制得分</samp>'
- en: This code uses some new canvas properties and methods we haven’t seen yet. First,
    we use ctx.font to set the font of the text we’re about to draw. This is similar
    to a CSS font declaration. In this case, we’re setting the font to be 30 pixels
    tall and monospace style. *Monospace* means that each character takes up the same
    width, and is usually used for code, as in this book’s code listings. It looks
    like this. There are many monospace fonts, but because operating systems can come
    with different fonts installed, we give only a generic font style (monospace),
    meaning the operating system should use the default font for that font style.
    In most operating systems, Courier or Courier New is the default monospace font.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一些我们尚未见过的新canvas属性和方法。首先，我们使用ctx.font来设置即将绘制的文本的字体。这类似于CSS中的font声明。在这种情况下，我们将字体设置为30像素高，并使用等宽字体样式。*等宽字体*意味着每个字符占用相同的宽度，通常用于代码，如本书中的代码列表。它看起来像这样。有许多等宽字体，但由于操作系统可能安装了不同的字体，我们仅提供通用的字体样式（monospace），这意味着操作系统应使用该字体样式的默认字体。在大多数操作系统中，Courier或Courier
    New是默认的等宽字体。
- en: Next, we use ctx.textAlign to set the alignment for the text. We choose "left"
    alignment, but because we want this to apply only to the left score, before drawing
    the right score we change the alignment to "right". This way if the scores get
    into double digits the numbers will extend toward the middle of the screen, keeping
    things visually balanced.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用ctx.textAlign来设置文本的对齐方式。我们选择“左”对齐，但因为我们希望这仅应用于左侧得分，所以在绘制右侧得分之前，我们将对齐方式改为“右”。这样，如果得分变为两位数，数字将朝屏幕中间延伸，保持视觉平衡。
- en: 'To display the left score, we use the ctx.fillText method. This method has
    three parameters: the text to be drawn, and the x- and y-coordinates at which
    to draw it. The first parameter must be a string, so we call the toString method
    on leftScore to convert it from a number to a string. We use 50 for the x- and
    y-coordinates to place the text near the top-left corner of the canvas.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示左侧得分，我们使用ctx.fillText方法。这个方法有三个参数：要绘制的文本，以及绘制文本的x和y坐标。第一个参数必须是一个字符串，因此我们调用leftScore的toString方法，将其从数字转换为字符串。我们使用50作为x和y坐标，将文本放置在画布的左上角附近。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The meaning of the x-coordinate parameter for fillText depends on the text’s
    alignment. For left-aligned text, the x-coordinate specifies the left edge of
    the text, whereas for right-aligned text it specifies the right edge.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*fillText的x坐标参数的含义取决于文本的对齐方式。对于左对齐文本，x坐标指定文本的左边缘；而对于右对齐文本，x坐标指定文本的右边缘。*'
- en: 'The right score is handled similarly to the left score: we set the text alignment,
    then call fillText to display the score. This time we set the x-coordinate to
    width - 50, so it appears as far from the right as the left score appears from
    the left.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧得分的处理与左侧得分类似：我们设置文本对齐方式，然后调用fillText来显示得分。这次我们将x坐标设置为width - 50，因此它会出现在距离右侧与左侧得分距离相同的位置。
- en: When you refresh *index.html*, you should see the initial scores rendered, as
    illustrated in [Figure 10-6](chapter10.xhtml#fig10-6).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新*index.html*时，你应该能看到初始得分渲染出来，如[图 10-6](chapter10.xhtml#fig10-6)所示。
- en: '![](../images/Figure_10-6.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: Displaying the
    scores</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-6：显示得分</samp>
- en: Now we have to handle the case where the ball hits the side walls. Instead of
    bouncing, the appropriate score should be incremented and the ball should be reset
    to its original speed and position. First we’ll do another refactor and write
    a function that resets the ball. This also requires some changes to how the ball’s
    speed and position variables are handled. [Listing 10-17](#Lis10-17) shows the
    changes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要处理球撞击侧墙的情况。球不再反弹，应该增加适当的得分，并且将球重置为原始速度和位置。首先我们进行一次重构，编写一个重置球的函数。这还需要对球的速度和位置变量的处理进行一些更改。[示例
    10-17](#Lis10-17)展示了这些更改。
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-17: The initBall
    function</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 10-17：initBall函数</samp>
- en: Here we’ve separated the *declaration* of the ball state variables (ball Position,
    xSpeed, and ySpeed) from the *initialization* of those variables. For example,
    ballPosition is declared at the top level of the program ❶ but initialized in
    the new initBall function ❷ (short for “initialize ball”). The same goes for xSpeed
    and ySpeed. This is so we can reset the ball to its initial position and speed
    whenever we want simply by calling initBall, rather than by copy-pasting the values
    of the ball state variables all over the program. In particular, we can now call
    initBall at the start of the program to set up the ball for the first time, and
    we can also call it anytime the ball hits the left or right wall, to reset the
    ball to its original state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将球的状态变量（ball Position、xSpeed 和 ySpeed）的*声明*与这些变量的*初始化*分开。例如，ballPosition在程序的顶层声明
    ❶，但在新的initBall函数中初始化 ❷（即“初始化球”）。xSpeed 和 ySpeed 也如此。这样一来，我们可以通过调用initBall，轻松地将球重置到初始位置和速度，而不必在程序中到处复制粘贴球的状态变量的值。特别地，我们现在可以在程序开始时调用initBall来首次设置球，并且也可以在球撞到左右墙时随时调用它，将球重置到原始状态。
- en: 'Note that we can’t both declare *and* initialize the ball state variables inside
    the initBall function—for example, by placing let ballPosition = {x: 20, y: 30};
    within the function—because the let keyword defines a new variable *in the current
    scope*, which in that case would be the body of initBall. Thus, the variables
    would be available only within initBall. We want the variables to be available
    throughout the program, so we declare them with let at the top level of the program,
    outside the body of any functions. However, because we want to initialize the
    variables multiple times, we assign them their value in the initBall function,
    which can be called repeatedly.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我们不能在initBall函数内部同时声明*和*初始化球的状态变量——例如，在函数内部放置let ballPosition = {x: 20,
    y: 30};——因为let关键字会在*当前作用域*内定义一个新变量，在这种情况下就是initBall的主体。因此，这些变量只能在initBall函数内部使用。我们希望这些变量在整个程序中都能使用，因此我们在程序的顶层声明它们，而不是在任何函数的主体内声明。然而，因为我们希望多次初始化这些变量，所以我们在initBall函数中为它们赋值，该函数可以被多次调用。'
- en: Next we have to modify the collision detection code in the checkCollision function
    to increment the score and reset the ball when the left or right wall is hit.
    [Listing 10-18](#Lis10-18) shows how.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改checkCollision函数中的碰撞检测代码，当球撞到左右墙时，增加得分并重置球。[列表 10-18](#Lis10-18)展示了如何操作。
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-18: Scoring points
    on wall collisions</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-18：墙壁碰撞得分</samp>
- en: Previously, we checked for left and right wall collisions in a single if statement
    that made the ball bounce, but we have to handle the left and right walls individually,
    since a different player scores depending on which wall is hit. Therefore, we’ve
    split the if statement into two. If the ball hits the left wall ❶, rightScore
    is incremented and the ball is reset with a call to our new initBall function.
    If the ball hits the right wall ❷, leftScore is incremented and the ball is reset.
    The logic for collisions with the top and bottom walls remains the same.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们在一个if语句中检查左右墙的碰撞，并让球反弹，但现在我们需要单独处理左右墙，因为根据撞到哪面墙，不同的玩家得分。因此，我们将if语句拆分成两个。如果球撞到左墙
    ❶，rightScore会增加，并通过调用新的initBall函数重置球。如果球撞到右墙 ❷，leftScore会增加，并重置球。与上下墙的碰撞逻辑保持不变。
- en: Finally, since we’ve moved the initialization of the ball state variables to
    the initBall function, we need to call that function before the game loop starts
    in order to set the ball up for the first time. Scroll down to the bottom of *script.js*
    and update the code as shown in [Listing 10-19](#Lis10-19), adding a call to initBall
    before the call to gameLoop.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们已将球的状态变量初始化移动到initBall函数中，我们需要在游戏循环开始之前调用该函数，以便首次设置球。在*script.js*的底部向下滚动，并按[列表
    10-19](#Lis10-19)所示更新代码，在调用gameLoop之前添加对initBall的调用。
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-19: Calling initBall
    for the first time</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-19：首次调用 initBall</samp>
- en: Now when you refresh *index.html*, you should see the scores increment when
    the ball hits a side wall, and the ball should reset to its original speed and
    position after a side wall hit. Of course, it’s pretty easy to beat the computer
    right now because it doesn’t move its paddle yet!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你刷新 *index.html* 时，你应该能看到分数在球击中侧墙时递增，并且球在击中侧墙后应该恢复到其原始速度和位置。当然，现在很容易打败计算机，因为它还没有移动它的滑块！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Computer Control</samp>
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">计算机控制</samp>
- en: 'Now let’s add some challenge to this game! We want the computer-controlled
    opponent to move the left paddle and try to hit the ball. There are various ways
    to do this, but in our simple approach, we’ll have the computer always try to
    match the current position of the ball. The logic for the computer will be very
    simple:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们给这个游戏增加一些挑战吧！我们希望计算机控制的对手移动左侧的滑块并尝试击打球。实现这一点有多种方法，但在我们简单的方案中，计算机将始终尝试匹配球的当前位置。计算机的逻辑将非常简单：
- en: If the top of the ball is above the top of the paddle, move the paddle up.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果球的顶部在滑块的顶部之上，向上移动滑块。
- en: If the bottom of the ball is below the bottom of the paddle, move the paddle
    down.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果球的底部在滑块的底部之下，向下移动滑块。
- en: Otherwise, do nothing.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，不做任何操作。
- en: With this approach, if the computer could move at any speed, then it would never
    miss. Since this would be no fun for us humans, we’ll set a speed limit for the
    computer. [Listing 10-20](#Lis10-20) shows how.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，如果计算机可以以任何速度移动，那么它将永远不会错过。由于这对我们人类来说没有乐趣，我们将为计算机设置一个速度限制。[示例 10-20](#Lis10-20)展示了如何做。
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-20: Limiting the
    computer’s speed</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 10-20：限制计算机的速度</samp>
- en: We declare the computer’s speed limit as a constant, MAX_COMPUTER_SPEED. By
    setting it to 2, we’re saying that the computer isn’t allowed to move the paddle
    more than 2 pixels per frame of the game.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算机的速度限制声明为一个常量，MAX_COMPUTER_SPEED。通过将其设置为 2，我们表示计算机在每帧游戏中不能移动比 2 像素更多的滑块。
- en: Next, we’ll define a function called followBall that applies some very rudimentary
    artificial intelligence to move the computer’s paddle. The new function is shown
    in [Listing 10-21](#Lis10-21). Add it to your code between the draw function and
    the update function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个名为 followBall 的函数，它应用一些非常基础的人工智能来移动计算机的滑块。新函数在[示例 10-21](#Lis10-21)中展示。将它添加到你的代码中，放在
    draw 函数和 update 函数之间。
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-21: Computer-controlled
    paddle</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 10-21：计算机控制的滑块</samp>
- en: Within the followBall function, we define objects representing the ball ❶ and
    the left paddle ❷, each with top and bottom properties representing their upper
    and lower bounds. Then we implement the paddle movement logic with two if statements.
    If the top of the ball is above the top of the paddle ❸, we move the paddle up
    by subtracting MAX_COMPUTER_SPEED from leftPaddleTop. Likewise, if the bottom
    of the ball is below the bottom of the paddle ❹, we move the paddle down by adding
    MAX_COMPUTER_SPEED to leftPaddleTop.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 followBall 函数中，我们定义了表示球 ❶ 和左侧滑块 ❷ 的对象，每个对象都有表示其上下界限的 top 和 bottom 属性。然后，我们通过两个
    if 语句实现滑块的移动逻辑。如果球的顶部在滑块的顶部之上 ❸，我们通过从 leftPaddleTop 中减去 MAX_COMPUTER_SPEED 来向上移动滑块。同样，如果球的底部在滑块的底部之下
    ❹，我们通过向 leftPaddleTop 添加 MAX_COMPUTER_SPEED 来向下移动滑块。
- en: We call our new followBall function within the update function ❺. This way,
    moving the left paddle becomes part of the process of updating the state of the
    game that happens with each iteration of the game loop.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 update 函数中调用了新的 followBall 函数 ❺。这样，移动左侧滑块就成为了每次游戏循环迭代时更新游戏状态的过程的一部分。
- en: Reload the page and see if you can score a point against the computer!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载页面，看看你能不能在计算机面前得分！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Game Over</samp>
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">游戏结束</samp>
- en: The final step in creating our game is to make it winnable (or losable). To
    do that, we have to add some kind of game over condition, and stop the game loop
    at that point. In this case, we’ll stop the game loop once one of the players
    reaches 10 points, then display the text “GAME OVER.”
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建游戏的最后一步是让游戏可以获胜（或失败）。为了做到这一点，我们必须添加某种游戏结束的条件，并在此时停止游戏循环。在这种情况下，我们将在其中一个玩家达到
    10 分时停止游戏循环，然后显示“游戏结束”的文字。
- en: First, we need to declare a variable for keeping track of whether or not the
    game is over. We’ll use this variable to decide whether to continue repeating
    the gameLoop function. [Listing 10-22](#Lis10-22) shows the changes to make.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明一个变量来跟踪游戏是否结束。我们将使用这个变量来决定是否继续重复执行gameLoop函数。[清单 10-22](#Lis10-22)展示了需要做出的修改。
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-22: Adding the gameOver
    variable</samp>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-22：添加 gameOver 变量</samp>
- en: Near the top of *script.js*, we declare a variable called gameOver for recording
    whether the game is over ❶. We initialize it to false so the game doesn’t end
    before it begins. Then, within the checkCollision function, we check to see if
    either of the scores has exceeded 9 ❷. If so, we set gameOver to true. This check
    could happen anywhere, but we do it in checkCollision to keep the logic that increments
    the scores and the logic that checks the scores together.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在*script.js*的顶部，我们声明了一个名为gameOver的变量，用于记录游戏是否结束 ❶。我们将其初始化为false，这样游戏在开始之前不会结束。然后，在checkCollision函数中，我们检查是否有任何一个得分超过了9
    ❷。如果是这样，我们将gameOver设置为true。这个检查可以在任何地方进行，但我们在checkCollision中进行，以将增加得分的逻辑和检查得分的逻辑放在一起。
- en: Next, we’ll add a function for writing the text “GAME OVER,” and we’ll modify
    the game loop so it ends when gameOver is true. [Listing 10-23](#Lis10-23) shows
    how.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个函数来写入“GAME OVER”文本，并修改游戏循环，使其在gameOver为true时结束。[清单 10-23](#Lis10-23)展示了如何操作。
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-23: Ending the game</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 10-23：结束游戏</samp>
- en: We define the drawGameOver function after the checkCollision function ❶. It
    draws the text “GAME OVER” to the middle of the canvas in large, white text. To
    position the text in the middle of the canvas, we set the text alignment to "center"
    and use half the canvas width and height as the text’s x- and y-coordinates. (With
    center alignment, the x-coordinate refers to the horizontal midpoint of the text.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在checkCollision函数 ❶之后定义了drawGameOver函数。它将“GAME OVER”文本绘制到画布中央，字体为大号白色。为了将文本居中放置，我们将文本对齐方式设置为“center”，并使用画布宽度和高度的一半作为文本的x和y坐标。（在居中对齐的情况下，x坐标表示文本的水平中点。）
- en: 'Within the gameLoop function, we’ve wrapped the call to setTimeout in a conditional
    statement that checks the value of the gameOver variable. If it’s true ❷, the
    game is over, so we call the draw and drawGameOver functions. (The draw function
    is needed to display the final score; otherwise, the winning player would still
    be stuck with nine points.) If gameOver is false ❸, the game can continue: we
    keep looping as before by using setTimeout to call gameLoop again after 30 ms.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在gameLoop函数中，我们将setTimeout的调用包装在一个条件语句中，该语句检查gameOver变量的值。如果为true ❷，游戏结束，因此我们调用draw和drawGameOver函数。（draw函数是用来显示最终得分的；否则，获胜的玩家将仍然停留在九分。）如果gameOver为false
    ❸，游戏可以继续：我们像之前一样使用setTimeout，在30毫秒后再次调用gameLoop，继续循环。
- en: 'Once gameOver becomes true and the game loop ends, the game effectively stops.
    Nothing else will be drawn to the screen after the “GAME OVER” text—at least,
    not until the page is refreshed and the program starts again from the beginning.
    Go ahead and do that now: refresh *index.html* and see if you can beat the computer!
    Once one of you gets more than nine points you should see the “GAME OVER” text,
    as shown in [Figure 10-7](chapter10.xhtml#fig10-7).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦gameOver变为true并且游戏循环结束，游戏实际上就停止了。在“GAME OVER”文本之后，不会再绘制其他内容——至少，直到页面刷新并且程序从头开始重新启动。现在就刷新*index.html*，看看你能否打败电脑！一旦你们中的任何一个得分超过九分，你应该会看到“GAME
    OVER”文本，如[图 10-7](chapter10.xhtml#fig10-7)所示。
- en: '![](../images/Figure_10-7.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_10-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: Game over</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-7：游戏结束</samp>
- en: 'I hope you beat the computer, but don’t worry if you didn’t—the game is pretty
    hard. Here are some things you can do to make it easier for yourself:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能打败电脑，但如果没有也不用担心——这个游戏确实很难。这里有一些可以让你自己轻松些的建议：
- en: Increase the time between frames in gameLoop.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加gameLoop中帧之间的时间。
- en: Make the paddles taller.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加挡板的高度。
- en: Reduce the computer’s max speed.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低电脑的最大速度。
- en: Make it easier to hit the edge of the paddle.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让击中挡板的边缘变得更容易。
- en: Increase the effect on ySpeed of hitting the edge of the paddle.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加击中挡板边缘时ySpeed的效果。
- en: Now that you have a working game, you can make any changes you want. If you’re
    already a *Pong* pro, you might want to make it harder instead; the following
    exercises provide a few suggestions. You could also try customizing the appearance,
    or changing the size of the canvas—it’s your game now.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个可用的游戏，你可以进行任何你想要的修改。如果你已经是一个*Pong*高手，可能想让游戏变得更难一些；下面的练习提供了一些建议。你还可以尝试自定义外观，或更改画布的大小——现在是你的游戏了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Complete Code</samp>
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">完整代码</samp>
- en: For your convenience, [Listing 10-24](#Lis10-24) shows the whole *script.js*
    file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便你，[列表 10-24](#Lis10-24) 显示了完整的*script.js*文件。
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-24: The complete
    code</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 10-24：完整代码</samp>
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you created a full game from scratch. The basics of game loops,
    collision detection, and rendering are broadly applicable, so with the knowledge
    you’ve acquired here you can start creating all kinds of 2D games. For example,
    you might try implementing your own version of *Breakout* or *Snake*. If you need
    some help with the logic, there are lots of tutorials online that you can follow.
    Have fun!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你从零开始创建了一个完整的游戏。游戏循环、碰撞检测和渲染的基础知识是广泛适用的，因此凭借你在这里获得的知识，你可以开始创建各种2D游戏。例如，你可以尝试实现自己的*Breakout*或*Snake*版本。如果你在逻辑上需要一些帮助，网上有很多教程可以跟随。玩得开心！
