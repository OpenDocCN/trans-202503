<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 8: Java</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c2f206e1-36e8-4f89-b533-508263d6ec16" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_73" title="73"/>8</span><br/>
<span class="ChapterTitle">Java</span></h1>
</header>
<figure class="graphic">
<img alt="g08001" src="image_fi/502680c08/g08001.png"/></figure>

<blockquote class="Epigraph" epub:type="epigraph">
<p class="Epigraph">We came back from Christmas break. I got in pretty early, bright eyed and bushy tailed, and talked to Rubin. He informed me that he and Brian had dinner during the week off and that they’d decided that we were going to write everything in Java.</p>
<p class="EpigraphSource">—Joe Onorato</p>
</blockquote>
<h2 id="h1-502680c08-0001">Language Choices</h2>
<p class="BodyFirst">The choice of a programming language for Android was probably more tied to Android’s growth than might otherwise be obvious. After all, a programming language is just the medium to input the information to the computer: Does it really matter?</p>
<p>Yes, it does. Experienced programmers can and do pick up new languages all the time. But even these experts develop patterns that make them more efficient with languages that they know well. And the effect of middleware, or utility libraries that developers can carry from project to project, can’t be discounted. The fact that a programmer can depend on some library<sup class="FootnoteReference"><a href="#c08-footnote-1" id="c08-footnoteref-1">1</a></sup> in one <span epub:type="pagebreak" id="Page_74" title="74"/>project and then use it to bootstrap other projects means that they can be more efficient and productive on every new project because they don’t have to keep re-inventing the world.</p>
<p>The choice to use the Java programming language<sup class="FootnoteReference"><a href="#c08-footnote-2" id="c08-footnoteref-2">2</a></sup> was important, because at the time Android was released, Java was one of the major languages used by software developers around the world. The fact that Android allowed these developers to use their existing language skills to write applications on Android meant that many developers could avoid the ramp-up time that learning a new language would have entailed.</p>
<p>But this language choice was not obvious or immediate in the early days of Android. There were actually three languages being debated internally.</p>
<p>First of all, there was JavaScript. In fact, in the beginning there was <em>only</em> JavaScript, because Android, at the start, was a desktop app written on and around the web’s programming language.</p>
<p>JavaScript is the programming language that developers use to write the code that is on the web pages that we visit. When we see something moving on a browser page, that animation is usually powered by JavaScript code. But JavaScript is a bit, er, messy, as real programming languages go. It’s easy for a developer to get things basically working with JavaScript, but some of its fundamental concepts<sup class="FootnoteReference"><a href="#c08-footnote-3" id="c08-footnoteref-3">3</a></sup> make it more difficult to program larger systems.</p>
<p>After work began on the real platform for Android, there was a choice of which language to use: JavaScript , C++, or Java.</p>
<p>C++ was attractive because many developers know it and it’s used in low-level programming tasks to this day. C++ developers have a lot of control <span epub:type="pagebreak" id="Page_75" title="75"/>over important aspects of their application’s operation, such as memory allocation. But the flip side is that developers have to manage this kind of information in their applications. If they allocate memory to store an object (say, an image), they have to make sure they deallocate it when they are finished. Failing to do this (an all-too-common problem in software) can lead to <em>memory </em><em>leaks</em> where memory is dribbled away and the application simply grows without bound until it uses up everything available in the system and fails when the system has no more memory to offer.</p>
<p>Java is a programming language built around the concept of a <em>runtime</em> or <em>virtual machine (VM)</em>, which handles all of the tedious bits about memory management that C++ programmers have to handle on their own. In the image example above, the Java programmer simply loads an image, which causes the memory to be allocated. When the image is no longer being used, the runtime automatically <em>collects</em> that memory, which is known as <em>garbage collection</em>. Java developers can ignore details of memory collection (and leaks) and get down to the business of writing their actual application logic.</p>
<p>Another reason for the team to consider Java was the existence of J2ME,<sup class="FootnoteReference"><a href="#c08-footnote-4" id="c08-footnoteref-4">4</a></sup> the Java-based platform that ran on various devices already. Ficus Kirkpatrick said, “At the time, to be on a phone and to get these carrier deals, you had to have support for J2ME.” Choosing Java provided some ability to run J2ME code on the platform, which was considered useful at the time that Android was first being created.</p>
<p>Finally, powerful tools for writing Java code were available for free, including Eclipse and NetBeans. On the other hand, C++ didn’t have good free IDE<sup class="FootnoteReference"><a href="#c08-footnote-5" id="c08-footnoteref-5">5</a></sup> support. Microsoft offered VisualStudio, which was a great tool for C++ development, but it wasn’t free, and Android wanted to appeal to all developers without requiring expensive tools.</p>
<p>The first plan was not to have just one language, but to offer a choice. Again, Ficus: “Our original idea was that we were going to do everything in a language-independent way. You were going to be able to write your apps in JavaScript, C++, and Java. Eventually we realized there were like twelve of us <span epub:type="pagebreak" id="Page_76" title="76"/>and we were never going to make that work. So we said ‘OK, we have to pick a language.’”</p>
<p>Andy Rubin saw the choice of just one language as a simplification for developers. Swetland said, “We were toying with some concepts of doing Java and C++. Andy felt very strongly that we needed one language, one API, so as to not confuse things. He saw Symbian<sup class="FootnoteReference"><a href="#c08-footnote-6" id="c08-footnoteref-6">6</a></sup> with their <em>n</em> different toolkits<sup class="FootnoteReference"><a href="#c08-footnote-7" id="c08-footnoteref-7">7</a></sup> as confusing.”</p>
<p>These were the technical details and merits that factored into the debate. The actual decision was a bit less formal; Andy made the call and told Swetland over dinner one evening. </p>
<p>The language choice was a good example of how quickly decisions were made on Android. In part, it was because it was Andy’s call, and Andy tended to make hard decisions that the organization would then scramble to execute. But more important, decisions were made quickly so that the organization could simply move on and do the rest of the infinite set of things that needed doing. The language choice had been debated internally for a while, and there was no right answer, but simply having a decision was more important than everyone being happy with whatever decision that was. So Java was it, and the team moved on.</p>
<p>Ficus said, of the decision: “It didn’t really feel like much of a choice, given that the carriers wanted to see support for J2ME<sup class="FootnoteReference"><a href="#c08-footnote-8" id="c08-footnoteref-8">8</a></sup> apps and this kind of ecosystem that existed at the time. And some of us had worked at Danger before, on the Hiptop, and we knew that we could make Java perform on a low-end device.”</p>
<p>Dianne Hackborn remembers when the decision was made: “Andy, very rightly, said, ‘We cannot do three different languages. That’s ridiculous, and we need to pick one. So we’re going to do Java.’ There was a lot of drama about that. No one cared about JavaScript, but a lot of people cared about C++.”</p>
<p><span epub:type="pagebreak" id="Page_77" title="77"/>The choice of Java made sense for various reasons, including team expertise. For example, the engineers from Danger had learned how to write an operating system with that language in an efficient way for those earlier, very constrained devices. In the end, with this and many other decisions, the team took a pragmatic approach. As Dianne said, “Not because anyone loved it, but because it’s what made sense to make the platform successful, and then the team adjusts.”</p>
<p>Although Java was chosen as the primary language for Android development, there was (and still is) a lot of code written for Android in other languages. Much of the platform itself is written in C++ (and even some limited parts in assembly language). Also, most games are written in C++, as are some other apps, in full or in part. C++ is a popular language with many developers, because it offers some performance advantages for low-level code, as well as integration with existing C++ libraries and tools. But the main language, especially for most non-game applications, became Java, and that’s what all of the Android APIs were written in and for.</p>
<p>Not everybody was happy with the language decision. San Mehat wasn’t a big fan of Java, especially for the low-level systems programming that he did. “I didn’t have a problem with the language itself. Well, maybe I did, inasmuch as it hid all the details that were important to writing code that scaled and ran well.” He ordered a new license plate for his car, JAVA SUX. “When you go to get the license plate, they [the Department of Motor Vehicles] ask you what it stands for. I said that I used to work for Sun and we made this Java thing, and it stands for Secondary User Extensions, and they said ‘Okay.’”</p>
<figure>
<img alt="" class="" src="image_fi/502680c08/f08001.png"/>
<figcaption><p>San’s license plate. San was not a fan of Android’s language choice. (Picture courtesy Eric Fischer.)</p></figcaption>
</figure>
<h2 id="h1-502680c08-0002"><span epub:type="pagebreak" id="Page_78" title="78"/>Runtimes</h2>
<p class="BodyFirst">To understand runtimes, you need to understand something about programming languages. Programmers write their code in whatever language they choose (C, Java, C++, Kotlin, Python, assembly . . . whatever). Computers don’t understand these languages; they understand binary code (0s and 1s) . . . and that’s it. The binary code represents instructions that the computer executes, like “add these two numbers.” In order to convert from typical programming languages into the binary-encoded instructions that the computer understands, programmers use tools called compilers.</p>
<p>Compilers translate from whatever language the programmer uses into binary instructions that the computer understands. So, for example, you can take a chunk of code written in C and compile it into a binary representation for a PC such that that compiled C code will run on that PC.</p>
<p>That same compiled code may not run on a different kind of computer, like a Mac, or a Linux server, because that other computer may not have the same kind of CPU, so the binary instructions the compiler generated won’t make sense on that other system. Instead, the original source code needs to be compiled into a different binary version for each different type of hardware you want to run it on.</p>
<figure>
<img alt="" class="" src="image_fi/502680c08/f08002.png"/>
<figcaption><p>Separate compilers create unique executables for every type of machine on which the code will be run.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_79" title="79"/>Along comes Java. The Java compiler translates source code not into machine-readable code, but into an intermediate representation called <em>bytecode</em>. This code can be executed on any computer platform that has an additional piece of software running on it called a <em>runtime</em>. The runtime interprets the bytecode and translates it into the binary representation of that computer, essentially compiling it on the fly. This ability to run on different hardware is what Sun Microsystems (the company where James Gosling was working when he created Java) called, “Write once, run anywhere.” Code would be compiled into bytecode that could then run on any target computer with a Java runtime.</p>
<figure>
<img alt="" class="" src="image_fi/502680c08/f08003.png"/>
<figcaption><p>Java code only needs to be compiled once. This produces a single executable that can run on all target machines that have a Java runtime. </p></figcaption>
</figure>
<p>Since the Android team wanted to use Java, they also needed a runtime. In fact, they went through several of them.</p>
<p>At first, the team simply used existing runtimes. The first of these was Waba.<sup class="FootnoteReference"><a href="#c08-footnote-9" id="c08-footnoteref-9">9</a></sup> Later on, the JamVM<sup class="FootnoteReference"><a href="#c08-footnote-10" id="c08-footnoteref-10">10</a></sup> virtual machine was substituted for Waba. <span epub:type="pagebreak" id="Page_80" title="80"/>Mike Fleming had joined by this time and helped get JamVM going: “Dan Bornstein’s VM wasn’t going to be ready for a while and we were going to write an awful lot of code. If we were going to be a Java platform, we needed to have something to run with for a while. Swetland and Fadden helped me out.” JamVM was used by Android until, in 2007, the Android runtime (Dalvik) was up and running.</p>
<h2 id="h1-502680c08-0003">Dan Bornstein and the Dalvik Runtime</h2>
<blockquote class="Epigraph" epub:type="epigraph">
<p class="Epigraph">Open a file, bang a few keys at random, then debug until complete.</p>
<p class="EpigraphSource">—Dan Bornstein (according to Andy McFadden)</p>
</blockquote>
<p class="BodyFirst">Although Waba and JamVM were sufficient for prototyping and early development, the team wanted their own runtime that they could control and customize as they needed. Brian Swetland was involved in the runtime that was written at Danger, but he had his hands full with kernel and systems work for Android. So the team hired Dan Bornstein, whom Brian had worked with at Danger.</p>
<p>Dan (known to the team as “danfuzz”) had taken over the runtime from Brian at Danger. “Not long after I was hired, I started referring to myself as ‘Brian Jr.’ He really didn’t like it . . . which is why I kept saying it.”</p>
<p>Dan was introduced to programming at the age of seven. He and his brother just wanted to play video games, so they eventually talked their parents into getting an Apple II, which the parents thought would be both a game and an education machine. The parents apparently won, because Dan didn’t just play games; he started programming them: “I totally wrote crappy video games, mostly text and low-res graphics.” Both Dan and his brother eventually became software engineers.</p>
<p>Dan worked at various companies in Silicon Valley through the 90s and early 2000s, including Danger, where he worked on (wait for it . . . ) a runtime for the Java programming language. So he was a natural candidate for that work on the Android team when he joined in October of 2005.</p>
<p>Dan’s first task was to evaluate the possible options. It wasn’t obvious to the small team on Android at that time whether they could simply use something that already existed (either open source or some technology that they could acquire) or whether they needed to build something in-house. <span epub:type="pagebreak" id="Page_81" title="81"/>Dan started working on both of these options in parallel, evaluating existing runtimes while also building a runtime from scratch.</p>
<p>Although Waba and JamVM worked well for quickly enabling the team’s use of Java, they were not seriously considered as long-term options. Both runtimes interpreted Java bytecode directly. But the team felt that there were performance and memory gains to be had by converting the Java code to another, more optimal format. A new bytecode format meant a new runtime, so Dan got busy making that happen. </p>
<p>Dan began work on a new runtime, which he named <em>Dalvik</em>: “I had just finished reading an issue [of <em>McSweeney’s</em>], which consisted of English translations of modern Icelandic fiction. So I had Iceland on the brain. I looked at a map of Iceland and tried to find something that was short and pronounceable, and didn’t have any of the weird characters, and I found Dalvík<sup class="FootnoteReference"><a href="#c08-footnote-11" id="c08-footnoteref-11">11</a></sup> (or ‘Dal-veek,’ as it’s pronounced). It sounded like a nice little town.”</p>
<figure>
<img alt="" class="" src="image_fi/502680c08/f08004.png"/>
<figcaption><p>Java code written for Android went through two compilation steps: one to create Java bytecode, and the next to convert that to Dalvik bytecode, which would then run on Android’s Dalvik runtime.</p></figcaption>
</figure>
<p>Instead of running Java bytecode, the Dalvik VM ran another form of bytecode compiled from Java bytecode. There were efficiencies in size to be gained in having their own bytecode format, and space on the device at that time was at a premium. The Dalvik bytecode required an additional <span epub:type="pagebreak" id="Page_82" title="82"/>compilation step (using another compiler, called DX) to get it into the form readable by Dalvik, called dex.<sup class="FootnoteReference"><a href="#c08-footnote-12" id="c08-footnoteref-12">12</a></sup></p>
<figure>
<img alt="" class="" src="image_fi/502680c08/f08005.png"/>
<figcaption><p>Dan Bornstein, outside of the town of Dalvík, Iceland. In the period between finishing work on the G1 and the device actually shipping, Dan took a break from working on Dalvik to visit Dalvík. (Picture courtesy Dan Bornstein.)</p></figcaption>
</figure>
<p>Eventually, Fadden pitched in to help with the runtime. “Danfuzz had the bytecode converter working reasonably well and needed someone to step up and write the VM. I volunteered, but pointed out that I knew very little about Java and VMs, and wasn’t quite sure where to start. He said, ‘Open a file, bang a few keys at random, then debug until complete.’”</p>
<p>Dave Bort, another engineer on the team, wrote the first version of the Dalvik garbage collector. That garbage collector shipped with the runtime in 1.0 and was the basis for several years of refinement and optimization.</p>
<p>Throughout this time, the runtime was constantly changing out from under all of the Java code being written for the platform. From Waba to JamVM to the nascent Dalvik runtime, major shifts were happening, but code kept running. Romain Guy remarked that even though the team was changing a huge and critical part of the system,<sup class="FootnoteReference"><a href="#c08-footnote-13" id="c08-footnoteref-13">13</a></sup> “I don’t remember running into showstopper <span epub:type="pagebreak" id="Page_83" title="83"/>bugs, or even bugs at all. I don’t remember anything else on Android being that stable.” Dan replied, “Some amount of the nature of that layer of the system helps with that—if the VM’s not working, shit just falls over.”</p>
<h2 id="h1-502680c08-0004">Zygote</h2>
<p class="BodyFirst">One of the things that the Dalvik team created to make Android work for 1.0 was (and still is) called Zygote.<sup class="FootnoteReference"><a href="#c08-footnote-14" id="c08-footnoteref-14">14</a></sup> Zygote is like the loaf of bread you slice when making a sandwich. You could, of course, bake the bread from scratch every time you made a sandwich, but that’s a lot of effort and time spent every time you want a sandwich. It’s obviously much faster and easier to have a loaf that you can just cut slices from to jump-start each sandwich. Zygote is like sandwich bread for applications.</p>
<p>Dan had this idea, which came from a feature of Emacs<sup class="FootnoteReference"><a href="#c08-footnote-15" id="c08-footnoteref-15">15</a></sup> (a popular text editor on Unix systems), where it would allow you to dump the state at any time and then start up Emacs later from this saved state (cleverly called <em>undump</em>). This meant that Emacs could start much faster because it just sucked in the state from disk instead of running a bunch of code logic at startup time. “My idea was that we implement an undumper-type system as made most ‘famous’ (at least to me) by Emacs. Mike [Fleming] said, ‘How about we skip the part where we dump to disk and reload?’ And he ran with it.” Mike got the system up and running, dramatically changing the way that applications started. Instead of each app loading in all of the code they required, and initializing it as it was loaded in, the Zygote system created a single process with much of the core platform code, essentially pre-loading and initializing all of it. Whenever an application launched, the Zygote process would be <em>forked</em> (duplicating itself into a new process), resulting in an almost immediate launch to that early stage of the new application.</p>
<p>Bob Lee (who worked on core libraries, the subject of the next chapter) said of Zygote, “It was just so simple! It’s like one API call! The reason we <span epub:type="pagebreak" id="Page_84" title="84"/>were able to do that was that the memory was copy-on-write.<sup class="FootnoteReference"><a href="#c08-footnote-16" id="c08-footnoteref-16">16</a></sup> So as long as you didn’t touch those memory pages from that initial Zygote process, all that memory would be shared across the whole OS. It was just such a clever, beautiful solution to leverage stuff that was already there.”</p>
<p>The system didn’t quite work as intended at first. Bob chased down a problem with the garbage collector: “After one garbage collection, I was like, ‘My app’s taking up so much memory again!’ It was because the garbage collector would touch every memory page.” That is, the normal efforts of the runtime would write to pages in memory that needed to stay read-only for the shared-memory approach of Zygote to work.</p>
<p>Fadden came in with a fix for this. Each new process would separate the heap from the garbage collector after the Zygote stage, excluding it from the memory that the garbage collector examined. The shared memory portion didn’t even exist in the new app, so it wouldn’t get touched.</p>
<p>After this, Bob and Fadden continued to work on Zygote, to figure out which classes<sup class="FootnoteReference"><a href="#c08-footnote-17" id="c08-footnoteref-17">17</a></sup> needed to live in Zygote to get optimal sharing out of all applications. Bob said, “I modified the VM and added some instrumentation, so I could say, like, how long every class initializer is taking, and figure out how much memory each class is allocating, and then an algorithm would decide which classes to preload. You don’t want to take up too much memory for the shared processes that’s only ever going to be used by one app.”</p>
<p>Bob credits Zygote for Android being at all functional at that time: “The Zygote thing helped a lot, just being able to share memory, going from having just a couple Java processes running to having dozens running on a really small device. And rather than having to wait for a whole VM to start up, our apps actually looked faster; they would launch instantly, because we’d just fork a process and start right there. Everything was already warmed up.” Eventually, Zygote contained not just code, but also shared data such as images, and continued providing memory and startup benefits to Android as the platform grew.</p>
</section>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-1" id="c08-footnote-1">1.</a></sup>  The concept of libraries is discussed in the Object-Oriented Programming section of the Jargon appendix.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-2" id="c08-footnote-2">2.</a></sup>  Hereafter written as simply <em>Java,</em> because “the Java programming language” is entirely too long and cumbersome. The distinction to understand, and the reason that we tend to use the longer form when we talk about the programming language of Android, is that there is a <em>Java platform</em> offered by Oracle, which includes the language, the Java runtime (<em>hotspot</em>), and the implementation for the set of libraries that Oracle (previously Sun Microsystems, which was acquired by Oracle) developed. But the only one of these used by Android is the language itself; the runtime is completely different, as is the set of libraries implemented in the Java language that developers can use in their applications. But rather than bog down the readability of the book, and artificially bulk up its word count, by writing the <em>Java Programming Language</em>™ everywhere, I’ll simply write Java. Just know that I mean the language.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-3" id="c08-footnote-3">3.</a></sup>  I always enjoy reading the foreword of a book, because I like the context that it provides about the author and the topic. My favorite sentence out of all of the tech book forewords I’ve read was this bit from Douglas Crockford in his preface to <em>JavaScript: The Good Parts</em>: “Thanks to XYZ [the inventor of JavaScript], without whom this book would not have been necessary.”</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-4" id="c08-footnote-4">4.</a></sup>  J2ME = Java 2 Platform, Micro Edition, also called <em>Java ME</em>. See the discussion about Java ME in the Jargon appendix.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-5" id="c08-footnote-5">5.</a></sup>  IDE = Integrated Development Environment, discussed in the Jargon appendix.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-6" id="c08-footnote-6">6.</a></sup>  Symbian was the operating system used by Nokia and some other manufacturers. There were different flavors of the platform available, which made it difficult to write applications for it, since it wasn’t clear which capabilities a given Symbian device would have.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-7" id="c08-footnote-7">7.</a></sup>  <em>Toolkit</em> is often used to refer to the visual/user-interface capabilities of a platform. The terms toolkit and framework are further described in the Jargon appendix at the end of the book.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-8" id="c08-footnote-8">8.</a></sup>  Android never ended up supporting J2ME applications. By the time Android was released, J2ME was no longer a factor (this was not related to Android, but there was simply no interest in that platform in the post-iPhone smartphone world).</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-9" id="c08-footnote-9">9.</a></sup>  Self-described on its open source website (<a class="LinkURL" href="http://waba.sourceforge.net">waba.sourceforge.net</a>) as “a small, efficient and reliable Java Virtual Machine (VM) aimed at portable devices (but also runnable on desktop computers), written by Rick Wild of Wabasoft.”</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-10" id="c08-footnote-10">10.</a></sup>  JamVM, by Robert Lougher, is also open source, available at <a class="LinkURL" href="http://jamvm.sourceforge.net">http://jamvm.sourceforge.net</a>, where it is described: “JamVM is an open source Java Virtual Machine that aims to support the latest version of the JVM specification, while at the same time being compact and easy to understand.”</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-11" id="c08-footnote-11">11.</a></sup>  Dan said, “An Icelandic guy once berated me for misspelling it. I told him the town is spelled ‘Dalvík’ but the VM is spelled ‘Dalvik.’”</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-12" id="c08-footnote-12">12.</a></sup>  dex = Dalvik Executable, the bytecode format understood by the Dalvik runtime on Android.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-13" id="c08-footnote-13">13.</a></sup>  Changing the runtime while the rest of the team is writing software that runs on it is somewhat like brain surgery, except instead of fixing the patient’s brain, you replace it with a different brain, sew them back up, and have them drive back to work immediately.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-14" id="c08-footnote-14">14.</a></sup>  Wikipedia defines zygote as, “A eukaryotic cell formed by a fertilization event between two gametes.” Which helps not at all. But it later says, “contains all of the genetic information necessary to form a new individual,” which is a little closer to its meaning in Android.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-15" id="c08-footnote-15">15.</a></sup>  Emacs is a classic text editor favored by a certain segment of programmers. Other programmers favor one called vi, and still others feel strongly about the one that comes with their IDE. A very tiny portion of programmers don’t care, and prefer to save their religious fervor for non-text-editor-related issues. Like the use of spaces versus tabs when indenting code. Don’t get me started.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-16" id="c08-footnote-16">16.</a></sup>  Copy-on-write is an optimization where a common resource can be shared by completely different clients as long as none of them writes to it (making a change). So as long as everyone was simply reading Zygote data/memory and not making changes to it (which was the general idea), it never needed to be duplicated, avoiding an expensive copy operation.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a href="#c08-footnoteref-17" id="c08-footnote-17">17.</a></sup>  The concept of classes is discussed in the Object-Oriented Programming section of the Jargon appendix.</p></aside>
</section>
</body>
</html>