<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_251"/><span class="big">14</span><br/>QUANTUM AND POST-QUANTUM</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Previous chapters focused on cryptography today, but in this chapter I’ll examine the future of cryptography over a time horizon of, say, a century or more—one in which <em>quantum computers</em> exist. Quantum computers are computers that leverage phenomena from quantum physics in order to run different kinds of algorithms than the ones we’re used to. Quantum computers don’t exist yet and look very hard to build, but if they do exist one day, then they’ll have the potential to break RSA, Diffie–Hellman, and elliptic curve cryptography—that is, all the public-key crypto deployed or standardized as of this writing.</p>
<p class="indent">To insure against the risk posed by quantum computers, crypto­graphy researchers have developed alternative public-key crypto algorithms called <em>post-quantum</em> algorithms that would resist quantum computers. In 2015, the NSA called for a transition to quantum-resistant algorithms designed to be <span epub:type="pagebreak" id="page_252"/>safe even in the face of quantum computers, and in 2017 the US standardization agency NIST began a process that will eventually standardize post-quantum algorithms.</p>
<p class="indent">This chapter will thus give you a nontechnical overview of the principles behind quantum computers as well as a glimpse of post-quantum algorithms. There’s some math involved, but nothing more than basic arithmetic and linear algebra, so don’t be scared by the unusual notations.</p>
<h3 class="h3" id="lev1sec92">How Quantum Computers Work</h3>
<p class="noindent">Quantum computing is a model of computing that uses quantum physics to compute differently and do things that classical computers can’t, such as breaking RSA and elliptic curve cryptography efficiently. But a quantum computer is not a super-fast normal computer. In fact, quantum computers can’t solve any problem that is too hard for a classical computer, such as brute force search or <strong>NP</strong>-complete problems.</p>
<p class="indent">Quantum computers are based on quantum mechanics, the branch of physics that studies the behavior of subatomic particles, which behave truly randomly. Unlike classical computers, which operate on bits that are either 0 or 1, quantum computers are based on <em>quantum bits</em> (or <em>qubits</em>), which can be both 0 and 1 simultaneously—a state of ambiguity called <em>superposition</em>. Physicists discovered that in this microscopic world, particles such as electrons and photons behave in a highly counterintuitive way: before you observe an electron, the electron is not at a definite location in space, but in several locations at the same time (that is, in a state of superposition). But once you observe it—an operation called <em>measurement</em> in quantum physics—then it stops at a fixed, random location and is no longer in superposition. This quantum magic is what enables the creation of qubits in a quantum computer.</p>
<p class="indent">But quantum computers only work because of a crazier phenomenon called <em>entanglement</em>: two particles can be connected (entangled) in a way that observing the value of one gives the value of the other, even if the two particles are widely separated (kilometers or even light-years away from each other). This behavior is illustrated by the <em>Einstein–Podolsky–Rosen (EPR)</em> <em>paradox</em> and is the reason why Albert Einstein initially dismissed quantum mechanics. (See <em><a href="https://plato.stanford.edu/entries/qt-epr/">https://plato.stanford.edu/entries/qt-epr/</a></em> for an in-depth explanation of why.)</p>
<p class="indent">To best explain how a quantum computer works, we should distinguish the actual quantum computer (the hardware, composed of quantum bits) from quantum algorithms (the software that runs on it, composed of <em>quantum gates</em>). The next two sections discuss these two notions.</p>
<h4 class="h4" id="lev2sec172"><em>Quantum Bits</em></h4>
<p class="noindent">Quantum bits (qubits), or groups thereof, are characterized with numbers called <em>amplitudes</em>, which are akin to probabilities but aren’t <em>exactly</em> probabilities. Whereas a probability is a number between 0 and 1, an amplitude is a complex number of the form <em>a</em> + <em>b</em> × <em>i</em>, or simply <em>a</em> + <em>bi</em>, where <em>a</em> and <em>b</em> are real <span epub:type="pagebreak" id="page_253"/>numbers, and <em>i</em> is an <em>imaginary unit</em>. The number <em>i</em> is used to form <em>imaginary numbers</em>, which are of the form <em>bi</em>, with <em>b</em> a real number. When <em>i</em> is multiplied by a real number, we get another imaginary number, and when it is multiplied by itself it gives –1; that is <em>i</em><sup>2</sup> = –1.</p>
<p class="indent">Unlike real numbers, which can be seen as belonging to a line (see <a href="ch14.xhtml#ch14fig1">Figure 14-1</a>), <em>complex numbers</em> can be seen as belonging to a plane (a space with two dimensions), as shown in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>. Here, the x-axis in the figure corresponds to the <em>a</em> in <em>a</em> + <em>bi</em>, the y-axis corresponds to the <em>b</em>, and the dotted lines correspond to the real and imaginary part of each number. For example, the vertical dotted line going from the point 3 + 2<em>i</em> down to 3 is two units long (the 2 in the imaginary part 2<em>i</em>).</p>
<div class="image"><img src="../images/f14-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig1"/><em>Figure 14-1: View of real numbers as points on an infinite straight line</em></p>
<div class="image"><img src="../images/f14-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig2"/><em>Figure 14-2: A view of complex numbers as points in a two-dimensional space</em></p>
<p class="indentt">As you can see in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>, you can use the Pythagorean theorem to compute the length of the line going from the origin (0) to the point <em>a</em> + <em>bi</em> by viewing this line as the diagonal of a triangle. The length of this diagonal is equal to the square root of the sum of the squared coordinates of the point, or √(<em>a</em><sup>2</sup> + <em>b</em><sup>2</sup>), which we call the <em>modulus</em> of the complex number <em>a</em> + <em>bi</em>. We denote the modulus as |<em>a</em> + <em>bi</em>| and can use it as the length of a complex number.</p>
<p class="indent">In a quantum computer, registers consist of 1 or more qubits in a state of superposition characterized by a set of such complex numbers. But as we’ll see, these complex numbers—the amplitudes—can’t be any numbers.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_254"/>Amplitudes of a Single Qubit</h5>
<p class="noindent">A single qubit is characterized by two amplitudes that I’ll call α (alpha) and β (beta). We can then express a qubit’s state as α |0<span class="ent">〉</span> + β |1<span class="ent">〉</span>, where the “| <span class="ent">〉</span>” notation is used to denote vectors in a quantum state. This notation then means that when you observe this qubit it will appear as 0 with a probability <span class="kiob">|α|<sup>2</sup></span> and 1 with a probability <span class="kiob">|β|<sup>2</sup></span>. Of course, in order for these to be actual probabilities, <span class="kiob">|α|<sup>2</sup></span> and <span class="kiob">|β|<sup>2</sup></span> must be numbers between 0 and 1, and <span class="kiob">|α|<sup>2</sup></span> + <span class="kiob">|β|<sup>2</sup></span> must be equal to 1.</p>
<p class="indent">For example, say we have the qubit <img src="../images/psi.jpg" alt="image"/> (psi) with amplitudes of α = <span class="kiob">1/√2</span> and β = <span class="kiob">1/√2</span>. We can express this as follows:</p>
<div class="image1"><img src="../images/f0254-01.jpg" alt="image"/></div>
<p class="indent">This notation means that in the qubit <img src="../images/psi.jpg" alt="image"/>, the value 0 has an amplitude of <span class="kiob">1/√2</span>, and the value 1 has the same amplitude, <span class="kiob">1/√2</span>. To get the actual probability from the amplitudes, we compute the modulus of <span class="kiob">1/√2</span> (which is equal to <span class="kiob">1/√2</span>, because it has no imaginary part), then square it: <span class="kiob">(1/√2)<sup>2</sup></span> = 1/2. That is, if you observe the qubit <img src="../images/psi.jpg" alt="image"/>, you’ll have a 1/2 chance of seeing a 0, and the same chance of seeing a 1.</p>
<p class="indentb">Now consider the qubit Φ (phi), where</p>
<div class="image1"><img src="../images/f0254-02.jpg" alt="image"/></div>
<p class="indent">The qubit Φ is fundamentally distinct from <img src="../images/psi.jpg" alt="image"/> because unlike <img src="../images/psi.jpg" alt="image"/>, where amplitudes have equal values, the qubit Φ has distinct amplitudes of α = <span class="kiob"><em>i</em>/√2</span> (a positive imaginary number) and β = <span class="kiob">–1/√2</span> (a negative real number). If, however, you observe Φ, the chance of your seeing a 0 or 1 is 1/2, the same as it is with <img src="../images/psi.jpg" alt="image"/>. Indeed, we can compute the probability of seeing a 0 as follows, based on the preceding rules:</p>
<div class="image1"><img src="../images/f0254-03.jpg" alt="image"/></div>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Because</em> α = <span class="kiob">i/√2</span>, α <em>can be written as</em> a + bi <em>with</em> a = 0 <em>and</em> b = <span class="kiob">1/√2</span>, <em>and computing</em> |α| = <span class="kiob">√(a<sup>2</sup> + b<sup>2</sup>)</span> <em>yields</em> <span class="kiob">1/√2</span>.</p>
</div>
<p class="indent">The upshot is that different qubits can behave similarly to an observer (with the same probability of seeing a 0 for both qubits) but have different amplitudes. This tells us that the actual probabilities of seeing a 0 or a 1 only partially characterize a qubit; just as when you observe the shadow of an object on a wall, the shape of the shadow will give you an idea of the object’s width and height, but not of its depth. In the case of qubits, this hidden dimension is the value of its amplitude: Is it positive or negative? Is it a real number or an imaginary number?</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_255"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>To simplify notations, a qubit is often simply written as its pair of amplitudes</em> (α, β). <em>Our previous example can then be written </em><span class="kiob">|<img src="../images/psi.jpg" alt="image"/><span class="ent">〉</span> = (1/√2, 1/√2)</span>.</p>
</div>
<h5 class="h5">Amplitudes of Groups of Qubits</h5>
<p class="noindentb">We’ve explored single qubits, but how do we understand multiple qubits? For example, a <em>quantum byte</em> can be formed with 8 qubits, when put into a state where the quantum states of these 8 qubits are somehow connected to each other (we say that the qubits are entangled, which is a complex physical phenomenon). Such a quantum byte can be described as follows, where the αs are the amplitudes associated with each of the 256 possible values of the group of 8 qubits:</p>
<div class="image1"><img src="../images/f0255-01.jpg" alt="image"/></div>
<p class="indentt">Note that we must have |α<sub>0</sub>|<sup>2</sup> + |α<sub>1</sub>|<sup>2</sup> + … + |α<sub>255</sub>|<sup>2</sup> = 1, so that all probabilities sum to 1.</p>
<p class="indent">Our group of 8 qubits can be viewed as a set of 2<sup>8</sup> = 256 amplitudes, because it has 256 possible configurations, each with its own amplitude. In physical reality, however, you’d only have eight physical objects, not 256. The 256 amplitudes are an implicit characteristic of the group of 8 qubits; each of these 256 numbers can take any of infinitely many different values. Generalizing, a group of <em>n</em> qubits is characterized by a set of 2<sup><em>n</em></sup> complex numbers, a number that grows exponentially with the numbers of qubits.</p>
<p class="indent">This encoding of exponentially many high-precision complex numbers is a core reason why a classical computer can’t simulate a quantum computer: in order to do so, it would need an unfathomably high amount of memory (of size around 2<sup><em>n</em></sup>) to store the same amount of information contained in only <em>n</em> qubits.</p>
<h4 class="h4" id="lev2sec173"><em>Quantum Gates</em></h4>
<p class="noindent">The concepts of amplitude and quantum gates are unique to quantum computing. Whereas a classical computer uses registers, memory, and a microprocessor to perform a sequence of instructions on data, a quantum computer transforms a group of qubits reversibly by applying a series of quantum gates, and then measures the value of one or more qubits. Quantum computers promise more computing power because with only <em>n</em> qubits, they can process 2<sup><em>n</em></sup> numbers (the qubits’ amplitudes). This property has profound implications.</p>
<p class="indent">From a mathematical standpoint, quantum algorithms are essentially a circuit of <em>quantum gates</em> that transforms a set of complex numbers (the amplitudes) before a final measurement where the value of 1 or more qubits is observed (see <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>). You’ll also see quantum algorithms referred to as <em>quantum gate arrays</em> or <em>quantum circuits</em>.</p>
<div class="image"><span epub:type="pagebreak" id="page_256"/><img src="../images/f14-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig3"/><em>Figure 14-3: Principle of a quantum algorithm</em></p>
<h5 class="h5">Quantum Gates as Matrix Multiplications</h5>
<p class="noindent">Unlike the Boolean gates of a classical computer (AND, XOR, and so on), a quantum gate acts on a group of amplitudes just as a matrix acts when multi­plied with a vector. For example, in order to apply the simplest quantum gate, the <em>identity</em> gate, to the qubit Φ, we see <em>I</em> as a 2 × 2 matrix and multiply it with the column vector consisting of the two amplitudes of Φ, as shown here:</p>
<div class="image1"><img src="../images/f0256-01.jpg" alt="image"/></div>
<p class="indent">The result of this matrix–vector multiplication is another column vector with two elements, where the top value is equal to the dot product of the <em>I</em> matrix’s first line with the input vector (the result of adding the product of the first elements 1 and <em>i</em>/√2 to the product of the second elements 0 and –1/√2), and likewise for the bottom value.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In practice, a quantum computer wouldn’t explicitly compute matrix–vector multiplications because the matrices would be way too large. (That’s why quantum computing can’t be simulated by a classical computer.) Instead, a quantum computer would transform qubits as physical particles through physical transformations that are equivalent to a matrix multiplication. Confused? Here’s what Richard Feynman had to say: “If you are not completely confused by quantum mechanics, you do not understand it.”</em></p>
</div>
<h5 class="h5">The Hadamard Quantum Gate</h5>
<p class="noindent">The only quantum gate we’ve seen so far, the identity gate <em>I</em>, is pretty useless because it doesn’t do anything and leaves a qubit unchanged. Now we’re going to see one of the most useful quantum gates, called the <em>Hadamard gate</em>, usually denoted <em>H</em>. The Hadamard gate is defined as follows (note the negative value in the bottom-right position):</p>
<div class="image1"><img src="../images/f0256-02.jpg" alt="image"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_257"/>Let’s see what happens if we apply this gate to the qubit |<img src="../images/psi.jpg" alt="image"/><span class="ent">〉</span> = (1/√2, 1/√2):</p>
<div class="image1"><img src="../images/f0257-01.jpg" alt="image"/></div>
<p class="indent">By applying the Hadamard gate <em>H</em> to |<img src="../images/psi.jpg" alt="image"/><span class="ent">〉</span>, we obtain the qubit |0<span class="ent">〉</span> for which the value |0<span class="ent">〉</span> has amplitude 1, and |1<span class="ent">〉</span> has amplitude 0. This tells us that the qubit will behave deterministically: that is, if you observe this qubit, you would always see a 0 and never a 1. In other words, we’ve lost the randomness of the initial qubit |<img src="../images/psi.jpg" alt="image"/><span class="ent">〉</span>.</p>
<p class="indent">What happens if we apply the Hadamard gate again to the qubit |0<span class="ent">〉</span>?</p>
<div class="image1"><img src="../images/f0257-02.jpg" alt="image"/></div>
<p class="indent">This brings us back to the qubit |<img src="../images/psi.jpg" alt="image"/><span class="ent">〉</span> and a randomized state. Indeed, the Hadamard gate is often used in quantum algorithms to go from a deterministic state to a uniformly random one.</p>
<h5 class="h5">Not All Matrices are Quantum Gates</h5>
<p class="noindent">Although quantum gates can be seen as matrix multiplications, not all matrices correspond to quantum gates. Recall that a qubit consists of the complex numbers α and β and the amplitudes of the qubit, such that they satisfy the condition |α|<sup>2</sup> + |β|<sup>2</sup> = 1. If after multiplying a qubit by a matrix we get two amplitudes that don’t match this condition, the result can’t be a qubit. Quantum gates can only correspond to matrices that preserve the property |α|<sup>2</sup> + |β|<sup>2</sup> = 1, and matrices that satisfy this condition are called <em>unitary matrices</em>.</p>
<p class="indent">Unitary matrices (and quantum gates by definition) are <em>invertible</em>, meaning that given the result of an operation, you can compute back the original qubit by applying the <em>inverse</em> matrix. This is the reason why quantum computing is said to be a kind of <em>reversible computing</em>.</p>
<h3 class="h3" id="lev1sec93">Quantum Speed-Up</h3>
<p class="noindent">A <em>quantum speed-up</em> occurs when a problem can be solved faster by a quantum computer than by a classical one. For example, in order to search for an item among <em>n</em> items of an unordered list on a classical computer, you need on average <em>n</em>/2 operations, because you need to look at each item in the list before finding the one you’re looking for. (On average, you’ll find that item after searching half of the list.) No classical algorithm can do better than <em>n</em>/2. However, a quantum algorithm exists to search for an item in only about √<em>n</em> operations, which is orders of magnitude smaller than <em>n</em>/2. For example, if <em>n</em> is equal to 1000000, then <em>n</em>/2 is 500000, whereas √<em>n</em> is 1000.</p>
<p class="indent">We attempt to quantify the difference between quantum and classical algorithms in terms of <em>time complexity</em>, which is represented by <em>O</em>() notation. <span epub:type="pagebreak" id="page_258"/>In the previous example, the quantum algorithm runs in time <em>O</em>(√<em>n</em>) but the classical algorithm can’t be faster than <em>O</em>(<em>n</em>). Because the difference in time complexity here is due to the square exponent, we call this <em>quadratic</em> <em>speed-up</em>. But while such a speed-up will likely make a difference, there are much more powerful ones.</p>
<h4 class="h4" id="lev2sec174"><em>Exponential Speed-Up and Simon’s Problem</em></h4>
<p class="noindent"><em>Exponential speed-ups</em> are the Holy Grail of quantum computing. They occur when a task that takes an exponential amount of time on a classical computer, such as <em>O</em>(2<sup><em>n</em></sup>), can be performed on a quantum computer with polynomial complexity—namely <em>O</em>(<em>n</em><sup><em>k</em></sup>) for some fixed number <em>k</em>. This exponential speed-up can turn a practically impossible task into a possible one. (Recall from <a href="ch09.xhtml#ch9">Chapter 9</a> that cryptographers and complexity theorists associate exponential time with the impossible, and they associate polynomial time with the practical.)</p>
<p class="indent">The poster child of exponential speed-ups is <em>Simon’s problem</em>. In this computational problem, a function, <strong>f</strong>(), transforms <em>n</em>-bit strings to <em>n</em>-bit strings, such that the output of <strong>f</strong>() looks random except that there is a value, <em>m</em>, such that any two values <em>x</em>, <em>y</em> that satisfies <strong>f</strong>(<em>x</em>) = <strong>f</strong>(<em>y</em>), then <em>y</em> = <em>x</em> ⊕ <em>m</em>. The way to solve this problem is to find <em>m</em>.</p>
<p class="indent">The route to take when solving Simon’s problem with a classical algorithm boils down to finding a collision, which takes approximately 2<sup><em>n</em>/2</sup> queries to <strong>f</strong>(). However, a quantum algorithm (shown in <a href="ch14.xhtml#ch14fig4">Figure 14-4</a>) can solve Simon’s problem in approximately <em>n</em> queries, with the extremely efficient time complexity of <em>O</em>(<em>n</em>).</p>
<div class="image"><img src="../images/f14-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig4"/><em>Figure 14-4: The circuit of the quantum algorithm that solves Simon’s problem efficiently</em></p>
<p class="indentt">As you can see in <a href="ch14.xhtml#ch14fig4">Figure 14-4</a>, you initialize 2<em>n</em> qubits to |0<span class="ent">〉</span>, apply Hadamard gates (<em>H</em>) to the first <em>n</em> qubits, then apply the gate <em>Q</em><strong>f</strong> to the two groups of all <em>n</em> qubits. Given two <em>n</em>-qubit groups <em>x</em> and <em>y</em>, the gate <em>Q</em><strong>f</strong> transforms the quantum state |<em>x</em><span class="ent">〉</span>|<em>y</em><span class="ent">〉</span> to the state |<em>x</em><span class="ent">〉</span>|<strong>f</strong>(<em>x</em>) ⊕ <em>y</em><span class="ent">〉</span>. That is, it computes the function <strong>f</strong>() on the quantum state reversibly, because you <span epub:type="pagebreak" id="page_259"/>can go from the new state to the old one by computing <strong>f</strong>(<em>x</em>) and XORing it to <strong>f</strong>(<em>x</em>) ⊕ <em>y</em>. (Unfortunately, explaining why all of this works is beyond the scope of this book.)</p>
<p class="indent">The exponential speed-up for Simon’s problem can be used against symmetric ciphers only in very specific cases, but in the next section you’ll see some real crypto-killer applications of quantum computing.</p>
<h4 class="h4" id="lev2sec175"><em>The Threat of Shor’s Algorithm</em></h4>
<p class="noindent">In 1995, AT&amp;T researcher Peter Shor published an eye-opening article titled “Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer.” <em>Shor’s algorithm</em> is a quantum algorithm that causes an exponential speed-up when solving the factoring, discrete logarithm (DLP), and elliptic curve discrete logarithm (ECDLP) problems. You can’t solve these problems with a classical computer, but you could with a quantum computer. That means that you could use a quantum computer to solve any cryptographic algorithm that relies on those problems, including RSA, Diffie–Hellman, elliptic curve crypto­graphy, and all currently deployed public-key cryptography mechanisms. In other words, you could reduce the security of RSA or elliptic curve crypto­graphy to that of Caesar’s cipher. (Shor might as well have titled his article “Breaking All Public-Key Crypto on a Quantum Computer.”) Shor’s algorithm has been called “one of the major scientific achievements of the late 20th century” by renowned complexity theorist Scott Aaronson.</p>
<p class="indent">Shor’s algorithm actually solves a more general class of problems than factoring and discrete logarithms. Specifically, if a function <strong>f</strong>() is <em>periodic</em>—that is, if there’s a ω (the period) such that <strong>f</strong>(<em>x</em> + ω) = <strong>f</strong>(<em>x</em>) for any <em>x</em>, Shor’s algorithm will efficiently find ω. (This looks very similar to Simon’s problem discussed previously, and indeed Simon’s algorithm was a major inspiration for Shor’s algorithm.) The ability of Shor’s algorithm to efficiently compute the period of a function is important to cryptographers because that ability can be used to attack public-key cryptography, as I’ll discuss next.</p>
<p class="indent">A discussion of the details of how Shor’s algorithm achieves its speed-up is far too technical for this book, but in this section I’ll show how you could use Shor’s algorithm to attack public-key cryptography. Let’s see how Shor’s algorithm could be used to solve the factoring and discrete logarithm problems (as discussed in <a href="ch09.xhtml#ch9">Chapter 9</a>), which are respectively the hard problems behind RSA and Diffie–Hellman.</p>
<h4 class="h4" id="lev2sec176"><em>Shor’s Algorithm Solves the Factoring Problem</em></h4>
<p class="noindent">Say you want to factor a large number, <em>N</em> = <em>pq</em>. It’s easy to factor <em>N</em> if you can compute the period of <em>a</em><sup><em>x</em></sup> mod <em>N</em>, a task that is hard to do with a classical computer but easy to do on a quantum one. You first pick a random number <em>a</em> less than <em>N</em>, and ask Shor’s algorithm to find the period ω of the function <strong>f</strong>(<em>x</em>) = <em>a</em><sup><em>x</em></sup> mod <em>N</em>. Once you’ve found the period, you’ll have <span epub:type="pagebreak" id="page_260"/><em>a</em><sup><em>x</em></sup> mod <em>N</em> = <em>a</em><sup><em>x</em> + ω</sup> mod <em>N</em> (that is, <em>a</em><sup><em>x</em></sup> mod <em>N</em> = <em>a</em><sup>x</sup><em>a</em><sup>ω</sup> mod <em>N</em>), which means that <em>a</em><sup>ω</sup> mod <em>N</em> = 1, or <em>a</em><sup>ω</sup> – 1 mod <em>N</em> = 0. In other words, <em>a</em><sup>ω</sup> – 1 is a multiple of <em>N</em>, or <em>a</em><sup>ω – 1</sup> = <em>kN</em> for some unknown number <em>k</em>.</p>
<p class="indent">The key observation here is that you can easily factor the number <em>a</em><sup>ω – 1</sup> as the product of two terms, where <em>a</em><sup>ω – 1</sup> = (<em>a</em><sup>ω / 2</sup> – 1)(<em>a</em><sup>ω / 2</sup> + 1). You can then compute the greatest common divisor (GCD) between (<em>a</em><sup>ω / 2</sup> – 1) and <em>N</em>, and check to see if you’ve obtained a nontrivial factor of <em>N</em> (that is, a value other than 1 or <em>N</em>). If not, you can just rerun the same algorithm with another value of <em>a</em>. After a few trials, you’ll get a factor of <em>N</em>. You’ve now recovered the private RSA key from its public key, which allows you to decrypt messages or forge signatures.</p>
<p class="indent">But just how easy is this computation? Note that the best classical algorithm to use to factor a number <em>N</em> runs in time exponential in <em>n</em>, the bit length of <em>N</em> (that is, <em>n</em> = log<sub>2</sub> <em>N</em>). However, Shor’s algorithm runs in time <em>polynomial</em> in <em>n</em>—namely, <em>O</em>(<em>n</em><sup>2</sup>(log <em>n</em>)(log log <em>n</em>)). This means that if we had a quantum computer, we could run Shor’s algorithm and see the result within a reasonable amount of time (days? weeks? months, maybe?) instead of thousands of years.</p>
<h4 class="h4" id="lev2sec177"><em>Shor’s Algorithm and the Discrete Logarithm Problem</em></h4>
<p class="noindent">The challenge in the discrete logarithm problem is to find <em>y</em>, given <em>y</em> = <em>g</em><sup><em>x</em></sup> mod <em>p</em>, for some known numbers <em>g</em> and <em>p</em>. Solving this problem takes an exponential amount of time on a classical computer, but Shor’s algorithm lets you find <em>y</em> easily thanks to its efficient period-finding technique.</p>
<p class="indent">For example, consider the function <strong>f</strong>(<em>a</em>, <em>b</em>) = <em>g</em><sup><em>a</em></sup><em>y</em><sup><em>b</em></sup>. Say we want to find the period of this function, the numbers ω and ω′, such that <strong>f</strong>(<em>a</em> + ω, <em>b</em> + ω′) = <strong>f</strong>(<em>a</em>, <em>b</em>) for any <em>a</em> and <em>b</em>. The solution we seek is then <em>x</em> = –ω / ω′ modulo <em>q</em>, the order of <em>g</em>, which is a known parameter. The equality <strong>f</strong>(<em>a</em> + ω, <em>b</em> + ω′) = <strong>f</strong>(<em>a</em>, <em>b</em>) implies <em>g</em><sup>ω</sup><em>y</em><sup>ω′</sup> mod <em>p</em> = 1. By substituting <em>y</em> with <em>g</em><sup><em>x</em></sup>, we have <em>g</em><sup>ω + xω′</sup> mod <em>p</em> = 1, which is equivalent to ω + <em>x</em>ω′ mod <em>q</em> = 0, from which we derive <em>x</em> = – ω / ω′.</p>
<p class="indent">Again, the overall complexity is <em>O</em>(<em>n</em><sup>2</sup>(log <em>n</em>)(log log <em>n</em>)), with <em>n</em> the bit length of <em>p</em>. This algorithm generalizes to find discrete logarithms in any commutative group, not just the group of numbers modulo a prime number.</p>
<h4 class="h4" id="lev2sec178"><em>Grover’s Algorithm</em></h4>
<p class="noindent">After Shor’s algorithm exponential speed-up for factoring, another important form of quantum speed-up is the ability to search among <em>n</em> items in time proportional to the square root of <em>n</em>, whereas any classical algorithm would take time proportional to <em>n</em>. This quadratic speed-up is possible thanks to <em>Grover’s algorithm</em>, a quantum algorithm discovered in 1996 (after Shor’s algorithm). I won’t cover the internals of Grover’s algorithm because they’re essentially a bunch of Hadamard gates, but I’ll explain what kind of problem Grover solves and its potential impact on cryptographic security. I’ll also show <span epub:type="pagebreak" id="page_261"/>why you can salvage a symmetric crypto algorithm from quantum computers by doubling the key or hash value size, whereas asymmetric algorithms are destroyed for good.</p>
<p class="indent">Think of Grover’s algorithm as a way to find the value <em>x</em> among <em>n</em> possible values, such that <strong>f</strong>(<em>x</em>) = 1, and where <strong>f</strong>(<em>x</em>) = 0 for most other values. If <em>m</em> values of <em>x</em> satisfy <strong>f</strong>(<em>x</em>) = 1, Grover will find a solution in time <em>O</em>(√(<em>n</em> / <em>m</em>)); that is, in time proportional to the square root of <em>n</em> divided by <em>m</em>. In comparison, a classical algorithm can’t do better than <em>O</em>(<em>n</em> / <em>m</em>).</p>
<p class="indent">Now consider the fact that <strong>f</strong>() can be any function. It could be, for example, “<strong>f</strong>(<em>x</em>) = 1 if and only if <em>x</em> is equal to the unknown secret key <em>K</em> such that <strong>E</strong>(<em>K</em>, <em>P</em>) = <em>C</em>” for some known plaintext <em>P</em> and ciphertext <em>C</em>, and where <strong>E</strong>() is some encryption function. In practice, this means that if you’re looking for a 128-bit AES key with a quantum computer, you’ll find the key in time proportional to 2<sup>64</sup>, rather than 2<sup>128</sup> if you had only classical computers. You would need a large enough plaintext to ensure the uniqueness of the key. (If the plaintext and ciphertext are, say, 32 bits, many candidate keys would map that plaintext to that ciphertext.) The complexity 2<sup>64</sup> is much smaller than 2<sup>128</sup>, meaning that a secret key would be much easier to recover. But there’s an easy solution: to restore 128-bit security, just use 256-bit keys! Grover’s algorithm will then reduce the complexity of searching a key to “only” 2<sup>256 / 2</sup> = 2<sup>128</sup> operations.</p>
<p class="indent">Grover’s algorithm can also find preimages of hash functions (a notion discussed in <a href="ch06.xhtml#ch6">Chapter 6</a>). To find a preimage of some value <em>h</em>, the <strong>f</strong>() function is defined as “<strong>f</strong>(<em>x</em>) = 1 if and only if <strong>Hash</strong>(<em>x</em>) = <em>h</em>, otherwise <strong>f</strong>(<em>x</em>) = 0.” Grover thus gets you preimages of <em>n</em>-bit hashes at the cost of the order of 2<sup><em>n</em>/2</sup> operations. As with encryption, to ensure 2<sup><em>n</em></sup> <em>post-quantum</em> security, just use hash values twice as large, since Grover’s algorithm will find a preimage of a 2<em>n</em>-bit value in at least 2<sup><em>n</em></sup> operations.</p>
<p class="indent">The bottom line is that you can salvage symmetric crypto algorithms from quantum computers by doubling the key or hash value size, whereas asymmetric algorithms are destroyed for good.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>There is a quantum algorithm that finds hash function collisions in time</em> O(2<sup>n/3</sup>), <em>instead of</em> O(2<sup>n/2</sup>), <em>as with the classic birthday attack. This would suggest that quantum computers can outperform classical computers for finding hash function collisions, except that the</em> O(2<sup>n/3</sup><em>)-time quantum algorithm also requires</em> O(2<sup>n/3</sup>) <em>space, or memory, in order to run. Give</em> O(2<sup>n/3</sup>) <em>worth of computer space to a classic algorithm and it can run a parallel collision search algorithm with a collision time of only</em> O(2<sup>n/6</sup>), <em>which is much faster than the</em> O(2<sup>n/3</sup>) <em>quantum algorithm. (For details of this attack, see “Cost Analysis of Hash Collisions” by Daniel J. Bernstein at</em> <a href="http://cr.yp.to/papers.html#collisioncost">http://cr.yp.to/papers.html#collisioncost</a>.)</p>
</div>
<h3 class="h3" id="lev1sec94">Why Is It So Hard to Build a Quantum Computer?</h3>
<p class="noindent">Although quantum computers can in principle be built, we don’t know how hard it will be or when that might happen, if at all. And so far, it looks really hard. As of early 2017, the record holder is a machine that <span epub:type="pagebreak" id="page_262"/>is able to keep 14 (fourteen!) qubits stable for only a few milliseconds, whereas we’d need to keep millions of qubits stable for weeks in order to break any crypto. The point is, we’re not there yet.</p>
<p class="indent">Why is it so hard to build a quantum computer? Because you need extremely small things to play the role of qubits—about the size of electrons or photons. And because qubits must be so small, they’re also extremely fragile.</p>
<p class="indent">Qubits must also be kept at extremely low temperatures (close to absolute zero) in order to remain stable. But even at such a freezing temperature, the state of the qubits decays, and they eventually become useless. As of this writing, we don’t yet know how to make qubits that will last for more than a couple of seconds.</p>
<p class="indent">Another challenge is that qubits can be affected by the environment, such as heat and magnetic fields, which can create noise in the system, and hence computation errors. In theory, it’s possible to deal with these errors (as long as the error rate isn’t too high), but it’s hard to do so. Correcting qubits’ errors requires specific techniques called quantum error-correcting codes, which in turn require additional qubits and a low enough rate of error. But we don’t know how to build systems with such a low error rate.</p>
<p class="indent">At the moment, there are two main approaches to forming qubits, and therefore to building quantum computers: superconducting circuits and ion traps. Using <em>superconducting circuits</em> is the approach championed by labs at Google and IBM. It’s based on forming qubits as tiny electrical circuits that rely on quantum phenomena from superconductor materials, where charge carriers are pairs of electrons. Qubits made of superconducting circuits need to be kept at temperatures close to absolute zero, and they have a very short lifetime. The record as of this writing is nine qubits kept stable for a few microseconds.</p>
<p class="indent"><em>Ion traps</em>, or trapped ions, are made up of ions (charged atoms) and are manipulated using lasers in order to prepare the qubits in specific initial states. Using ion traps was one of the first approaches to building qubits, and they tend to be more stable than superconducting circuits. The record as of this writing is 14 qubits stable for a few milliseconds. But ion traps are slower to operate and seem harder to scale than superconducting circuits.</p>
<p class="indent">Building a quantum computer is really a moonshot effort. The challenge comes down to 1) building a system with a handful of qubits that is stable, fault tolerant, and capable of applying basic quantum gates, and 2) scaling such a system to thousands or millions of qubits to make it useful. From a purely physical standpoint, and to the best of our knowledge, there is nothing to prevent the creation of large fault-tolerant quantum computers. But many things are possible in theory and prove hard or too costly to realize in practice (like secure computers). Of course, the future will tell who is right—the quantum optimists (who sometimes predict a large quantum computer in ten years) or the quantum skeptics (who argue that the human race will never see a quantum computer).</p>
<h3 class="h3" id="lev1sec95"><span epub:type="pagebreak" id="page_263"/>Post-Quantum Cryptographic Algorithms</h3>
<p class="noindent">The field of <em>post-quantum cryptography</em> is about designing public-key algorithms that cannot be broken by a quantum computer; that is, they would be quantum safe and able to replace RSA and elliptic curve–based algorithms in a future where off-the-shelf quantum computers could break 4096-bit RSA moduli in a snap.</p>
<p class="indent">Such algorithms should not rely on a hard problem known to be efficiently solvable by Shor’s algorithm, which kills the hardness in factoring and discrete logarithm problems. Symmetric algorithms such as block ciphers and hash functions would lose only half their theoretical security in the face of a quantum computer but would not be badly broken as RSA. They might constitute the basis for a post-quantum scheme.</p>
<p class="indent">In the following sections, I explain the four main types of post-quantum algorithms: code-based, lattice-based, multivariate, and hash-based. Of these, hash-based is my favorite because of its simplicity and strong security guarantees.</p>
<h4 class="h4" id="lev2sec179"><em>Code-Based Cryptography</em></h4>
<p class="noindent">Code-based post-quantum cryptographic algorithms are based on <em>error-correcting codes</em>, which are techniques designed to transmit bits over a noisy channel. The basic theory of error-correcting codes dates back to the 1950s. The first code-based encryption scheme (the <em>McEliece</em> cryptosystem) was developed in 1978 and is still unbroken. Code-based crypto schemes can be used for both encryption and signatures. Their main limitation is the size of their public key, which is typically on the order of a hundred kilobytes. But is that really a problem when the average size of a web page is around two megabytes?</p>
<p class="indent">Let me first explain what error-correcting codes are. Say you want to transmit a sequence of bits as a sequence of (say) 3-bit words, but the transmission is unreliable and you’re concerned that 1 or more bits may be incorrectly transmitted: you send 010, but the receiver gets 011. One simple way to address this would be to use a very basic error-correction code: instead of transmitting 010 you would transmit 000111000 (repeating each bit three times), and the receiver would decode the received word by taking the majority value for each of the three bits. For example, 100110111 would be decoded to 011 because that pattern appears twice. But as you can see, this particular error-correcting code would allow a receiver to correct only up to one error per 3-bit chunk, because if two errors occur in the same 3-bit chunk, the majority value would be the wrong one.</p>
<p class="indent"><em>Linear codes</em> are an example of less trivial error-correcting codes. In the case of linear codes, a word to encode is seen as an <em>n</em>-bit vector <em>v</em>, and encoding consists of multiplying <em>v</em> with an <em>m</em> × <em>n</em> matrix <em>G</em> to compute the code word <em>w</em> = <em>vG</em>. (In this example, <em>m</em> is greater than <em>n</em>, meaning that the code word is longer than the original word.) The value <em>G</em> can be structured such that for a given number <em>t</em>, any <em>t</em>-bit error in <em>w</em> allows the recipient to recover the correct <em>v</em>. In other words, <em>t</em> is the maximum number of errors that can be corrected.</p>
<p class="indent"><span epub:type="pagebreak" id="page_264"/>In order to encrypt data using linear codes, the McEliece cryptosystem constructs <em>G</em> as a secret combination of three matrices, and encrypts by computing <em>w</em> = <em>vG</em> plus some random value, <em>e</em>, which is a fixed number of 1 bit. Here, <em>G</em> is the public key, and the private key is composed of the matrices <em>A</em>, <em>B</em>, and <em>C</em> such that <em>G</em> = <em>ABC.</em> Knowing <em>A</em>, <em>B</em>, and <em>C</em> allows one to decode a message reliably and retrieve <em>w</em>. (You’ll find the decoding step described online.)</p>
<p class="indent">The security of the McEliece encryption scheme relies on the hardness of decoding a linear code with insufficient information, a problem known to be <strong>NP</strong>-complete and therefore out of reach of quantum computers.</p>
<h4 class="h4" id="lev2sec180"><em>Lattice-Based Cryptography</em></h4>
<p class="noindent"><em>Lattices</em> are mathematical structures that essentially consist of a set of points in an <em>n</em>-dimensional space, with some periodic structure. For example, in dimension two (<em>n</em> = 2), a lattice can be viewed as the set of points shown in <a href="ch14.xhtml#ch14fig5">Figure 14-5</a>.</p>
<div class="image"><img src="../images/f14-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch14fig5"/><em>Figure 14-5: Points of a two-dimensional lattice, where</em> v <em>and</em> w <em>are basis vectors of the lattice, and</em> s <em>is the closest vector to the star-shaped point</em></p>
<p class="indentt">Lattice theory has led to deceptively simple cryptography schemes. I’ll give you the gist of it.</p>
<p class="indent">A first hard problem found in lattice-based crypto is known as <em>short integer</em> <em>solution</em> (SIS). SIS consists of finding the secret vector <em>s</em> of <em>n</em> numbers given (<em>A</em>, <em>b</em>) such that <em>b</em> = <em>As</em> mod <em>q</em>, where <em>A</em> is a random <em>m</em> × <em>n</em> matrix and <em>q</em> is a prime number.</p>
<p class="indent">The second hard problem in lattice-based cryptography is called <em>learning</em> <em>with errors</em> (LWE). LWE consists of finding the secret vector <em>s</em> of <em>n</em> numbers given (<em>A</em>, <em>b</em>), where <em>b</em> = <em>As</em> + <em>e</em> mod <em>q</em>, with <em>A</em> being a random <em>m</em> × <em>n</em> matrix, <em>e</em> a random vector of noise, and <em>q</em> a prime number. This problem looks a lot like noisy decoding in code-based cryptography.</p>
<p class="indent">SIS and LWE are somewhat equivalent, and can be restated as instances of the <em>closest vector problem (CVP)</em> on a lattice, or the problem of finding the vector in a lattice closest to a given point, by combining a set of basis vectors. The dotted vector <em>s</em> in <a href="ch14.xhtml#ch14fig5">Figure 14-5</a> shows how we would find the closest vector to the star-shaped point by combining the basis vectors <em>v</em> and <em>w</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_265"/>CVP and other lattice problems are believed to be hard both for classical and quantum computers. But this doesn’t directly transfer to secure cryptosystems, because some problems are only hard in the worst case (that is, for their hardest instance) rather than the average case (which is what we need for crypto). Furthermore, while finding the exact solution to CVP is hard, finding an approximation of the solution can be considerably easier.</p>
<h4 class="h4" id="lev2sec181"><em>Multivariate Cryptography</em></h4>
<p class="noindent"><em>Multivariate cryptography</em> is about building cryptographic schemes that are as hard to break as it is to solve systems of multivariate equations, or equations involving multiple unknowns. Consider, for example, the following system of equations involving four unknowns <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, <em>x</em><sub>4</sub>:</p>
<div class="image1"><img src="../images/f0265-01.jpg" alt="image"/></div>
<p class="indent">These equations consist of the sum of terms that are either a single unknown, such as <em>x</em><sub>4</sub> (or terms of degree one), or the product of two unknown values, such as <em>x</em><sub>2</sub><em>x</em><sub>3</sub> (terms of degree two or <em>quadratic</em> terms). To solve this system, we need to find the values of <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, <em>x</em><sub>4</sub> that satisfy all four equations. Equations may be over all real numbers, integers only, or over finite sets of numbers. In cryptography, however, equations are typically over numbers modulo some prime numbers, or over binary values (0 and 1).</p>
<p class="indent">The problem here is to find a solution that is <strong>NP</strong>-hard given a <em>random</em> quadratic system of equations. This hard problem, known as <em>multivariate quadratics (MQ) equations</em>, is therefore a potential basis for post-quantum systems because quantum computers won’t solve <strong>NP</strong>-hard problems efficiently.</p>
<p class="indent">Unfortunately, building a cryptosystem on top on MQ isn’t so straightforward. For example, if we were to use MQ for signatures, the private key might consist of three systems of equations, <em>L</em><sub>1</sub>, <em>N</em>, and <em>L</em><sub>2</sub>, which when combined in this order would give another system of equations that we’ll call <em>P</em>, the public key. Applying the transformations <em>L</em><sub>1</sub>, <em>N</em>, and <em>L</em><sub>2</sub> consecutively (that is, transforming a group of values as per the system of equations) is then equivalent to applying <em>P</em> by transforming <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, <em>x</em><sub>4</sub> to <em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, <em>y</em><sub>3</sub>, <em>y</em><sub>4</sub>, defined as follows:</p>
<div class="image1"><img src="../images/f0265-02.jpg" alt="image"/></div>
<p class="indent">In such a cryptosystem, <em>L</em><sub>1</sub>, <em>N</em>, and <em>L</em><sub>2</sub> are chosen such that <em>L</em><sub>1</sub> and <em>L</em><sub>2</sub> are linear transformations (that is, having equations where terms are only added, not multiplied) that are invertible, and where <em>N</em> is a quadratic <span epub:type="pagebreak" id="page_266"/>system of equations that is also invertible. This makes the combination of the three a quadratic system that’s also invertible, but whose inverse is hard to determine without knowing the inverses of <em>L</em><sub>1</sub>, <em>N</em>, and <em>L</em><sub>2</sub>.</p>
<p class="indentb">Computing a signature then consists of computing the inverses of <em>L</em><sub>1</sub>, <em>N</em>, and <em>L</em><sub>2</sub> applied to some message, <em>M</em>, seen as a sequence of variables, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … .</p>
<p class="center"><em>S</em> = <em>L</em><sub>2</sub><sup>−1</sup>(<em>N</em><sup>−1</sup>(<em>L</em><sub>1</sub><sup>−1</sup>(<em>M</em>)))</p>
<p class="indentt">Verifying a signature then consists of verifying that <em>P</em>(<em>S</em>) = <em>M</em>.</p>
<p class="indent">Attackers could break such a cryptosystem if they manage to compute the inverse of <em>P</em>, or to determine <em>L</em><sub>1</sub>, <em>N</em>, and <em>L</em><sub>2</sub> from <em>P</em>. The actual hardness of solving such problems depends on the parameters of the scheme, such as the number of equations used, the size and type of the numbers, and so on. But choosing secure parameters is hard, and more than one multivariate scheme considered safe has been broken.</p>
<p class="indent">Multivariate cryptography isn’t used in major applications due to concerns about the scheme’s security and because it’s often slow or requires tons of memory. A practical benefit of multivariate signature schemes, however, is that it produces short signatures.</p>
<h4 class="h4" id="lev2sec182"><em>Hash-Based Cryptography</em></h4>
<p class="noindent">Unlike the previous schemes, hash-based cryptography is based on the well-established security of cryptographic hash functions rather than on the hardness of mathematical problems. Because quantum computers cannot break hash functions, they cannot break anything that relies on the difficulty of finding collisions, which is the key idea of hash function–based signature schemes.</p>
<p class="indent">Hash-based cryptographic schemes are pretty complex, so we’ll just take a look at their simplest building block: the one-time signature, a trick discovered around 1979, and known as <em>Winternitz one-time signature</em> (<em>WOTS</em>), after its inventor. Here “one-time” means that a private key can be used to sign only one message; otherwise, the signature scheme becomes insecure. (WOTS can be combined with other methods to sign multiple messages, as you’ll see in the subsequent section.)</p>
<p class="indent">But first, let’s see how WOTS works. Say you want to sign a message viewed as a number between 0 and <em>w</em> – 1, where <em>w</em> is some parameter of the scheme. The private key is a random string, <em>K</em>. To sign a message, <em>M</em>, with 0 ≤ <em>M</em> &lt; <em>w</em>, you compute <strong>Hash</strong>(<strong>Hash</strong>(…(<strong>Hash</strong>(<em>K</em>))), where the hash function <strong>Hash</strong> is repeated <em>M</em> times. We denote this value as <strong>Hash</strong><sup><em>M</em></sup>(<em>K</em>). The public key is <strong>Hash</strong><sup><em>w</em></sup>(<em>K</em>), or the result of <em>w</em> nested iterations of <strong>Hash</strong>, starting from <em>K</em>.</p>
<p class="indent">A WOTS signature, <em>S</em>, is verified by checking that <strong>Hash</strong><sup><em>w</em> – <em>M</em></sup>(<em>S</em>) is equal to the public key <strong>Hash</strong><sup><em>w</em></sup>(<em>K</em>). Note that <em>S</em> is <em>K</em> after <em>M</em> applications of <strong>Hash</strong>, so if we do another <em>w</em> – <em>M</em> applications of <strong>Hash</strong>, we’ll get a value equal to <em>K</em> hashed <em>M</em> + (<em>w</em> – <em>M</em>) = <em>w</em> times, which is the public key.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_267"/>This scheme looks rather dumb, and it has significant limitations:</p>
<p class="noindent"><strong>Signatures can be forged</strong></p>
<p class="hang2">From <strong>Hash</strong><sup><em>M</em></sup>(<em>K</em>), the signature of <em>M</em>, you can compute <strong>Hash</strong>(<strong>Hash</strong><sup><em>M</em></sup>(<em>K</em>)) = <strong>Hash</strong><sup><em>M</em> + 1</sup>(<em>K</em>), which is a valid signature of the message <em>M</em> + 1. This problem can be fixed by signing not only <em>M</em>, but also <em>w</em> – <em>M</em>, using a second key.</p>
<p class="noindent"><strong>It only works for short messages</strong></p>
<p class="hang2">If messages are 8 bits long, there are up to 2<sup>8</sup> – 1 = 255 possible messages, so you’ll have to compute <strong>Hash</strong> up to 255 times in order to create a signature. That might work for short messages, but not for longer ones: for example, with 128-bit messages, signing the message 2<sup>128</sup> – 1 would take forever. A workaround is to split longer messages into shorter ones.</p>
<p class="noindent"><strong>It works only once</strong></p>
<p class="hang2">If a private key is used to sign more than one message, an attacker can recover enough information to forge a signature. For example, if <em>w</em> = 8 and you sign the numbers 1 and 7 using the preceding trick to avoid trivial forgeries, the attacker gets <strong>Hash</strong><sup>1</sup>(<em>K</em>) and <strong>Hash</strong><sup>7</sup>(<em>K</em><em>′</em>) as a signature of 1, and <strong>Hash</strong><sup>7</sup>(<em>K</em>) and <strong>Hash</strong><sup>1</sup>(<em>K</em><em>′</em>) as a signature of 7. From these values, the attacker can compute <strong>Hash</strong><sup><em>x</em></sup>(<em>K</em>) and <strong>Hash</strong><sup><em>x</em></sup>(<em>K</em><em>′</em>) for any <em>x</em> in [1;7] and thus forge a signature on behalf of the owner of <em>K</em> and <em>K</em><em>′</em>. There is no simple way to fix this.</p>
<p class="indentt">State-of-the-art hash-based schemes rely on more complex versions of WOTS, combined with tree data structures and sophisticated techniques designed to sign different messages with different keys. Unfortunately, the resulting schemes produce large signatures (on the order of dozens of kilobytes, as with SPHINCS, a state-of-the-art scheme at the time of this writing), and they sometimes have a limit on the number of messages they can sign.</p>
<h3 class="h3" id="lev1sec96">How Things Can Go Wrong</h3>
<p class="noindent">Post-quantum cryptography may be fundamentally stronger than RSA or elliptic curve cryptography, but it’s not infallible or omnipotent. Our understanding of the security of post-quantum schemes and their implementations is more limited than for not-post-quantum cryptography, which brings with it increased risk, as summarized in the following sections.</p>
<h4 class="h4" id="lev2sec183"><em>Unclear Security Level</em></h4>
<p class="noindent">Post-quantum schemes can appear deceptively strong yet prove insecure against both quantum and classical attacks. Lattice-based algorithms, such as the ring-LWE family of computational problems (versions of the LWE problem that work with polynomials), are sometimes problematic. <span epub:type="pagebreak" id="page_268"/>Ring-LWE is attractive for cryptographers because it can be leveraged to build crypto­systems that are in principle as hard to break as it is to solve the hardest instances of Ring-LWE problems, which can be <strong>NP</strong>-hard. But when security looks too good to be true, it often is.</p>
<p class="indent">One problem with security proofs is that they are often asymptotic, meaning that they’re true only for a large number of parameters such as the dimension of the underlying lattice. However, in practice, a much smaller number of parameters is used.</p>
<p class="indent">Even when a lattice-based scheme looks to be as hard to break as some <strong>NP</strong>-hard problem, its security remains hard to quantify. In the case of lattice-based algorithms, we rarely have a clear picture of the best attacks against them and the cost of such an attack in terms of computation or hardware, because of our lack of understanding of these recent constructions. This uncertainty makes lattice-based schemes harder to compare against better-understood constructions such as RSA, and this scares potential users. However, researchers have been making progress on this front and hopefully in a few years, lattice problems will be as well understood as RSA. (For more technical details on the Ring-LWE problem, read Peikert’s excellent survey at <em><a href="https://eprint.iacr.org/2016/351/">https://eprint.iacr.org/2016/351/</a></em>.)</p>
<h4 class="h4" id="lev2sec184"><em>Fast Forward: What Happens if It’s Too Late?</em></h4>
<p class="noindent">Imagine this CNN headline: April 2, 2048: “ACME, Inc. reveals its secretly built quantum computer, launches break-crypto-as-a-service platform.” Okay, RSA and elliptic curve crypto are screwed. Now what?</p>
<p class="indent">The bottom line is that post-quantum encryption is way more critical than post-quantum signatures. Let’s look at the case of signatures first. If you were still using RSA-PSS or ECDSA as a signature scheme, you could just issue new signatures using a post-quantum signature scheme in order to restore your signatures’ trust. You would revoke your older, quantum-unsafe public keys and compute fresh signatures for every message you had signed. After a bit of work, you’d be fine.</p>
<p class="indent">You would only need to panic if you were encrypting data using quantum-<br/>unsafe schemes, such as RSA-OAEP. In this case all transmitted ciphertext could be compromised. Obviously, it would be pointless to encrypt that plaintext again with a post-quantum algorithm since your data’s confidentiality is already gone.</p>
<p class="indent">But what about key agreement, with Diffie–Hellman (DH) and its elliptic curve counterpart (ECDH)?</p>
<p class="indent">Well, at first glance, the situation looks to be as bad as with encryption: attackers who’ve collected public keys <em>g</em><sup><em>a</em></sup> and <em>g</em><sup><em>b</em></sup> could use their shiny new quantum computer to compute the secret exponent <em>a</em> or <em>b</em> and compute the shared secret <em>g</em><sup><em>ab</em></sup>, and then derive from it the keys used to encrypt your traffic. But in practice, Diffie–Hellman isn’t always used in such a simplistic fashion. The actual session keys used to encrypt your data may be derived from both the Diffie–Hellman shared secret and some internal state of your system.</p>
<p class="indent"><span epub:type="pagebreak" id="page_269"/>For example, that’s how state-of-the-art mobile messaging systems work, thanks to a protocol pioneered with the Signal application. When you send a new message to a peer with Signal, a new Diffie–Hellman shared secret is computed and combined with some internal secrets that depend on the previous messages sent within that session (which can span long periods of time). Such advanced use of Diffie–Hellman makes the work of an attacker much harder, even one with a quantum computer.</p>
<h4 class="h4" id="lev2sec185"><em>Implementation Issues</em></h4>
<p class="noindent">In practice, post-quantum schemes will be code, not algorithms; that is, software running on some physical processor. And however strong the algorithms may be on paper, they won’t be immune to implementation errors, software bugs, or side-channel attacks. An algorithm may be completely post-quantum in theory but may still be broken by a simple classical computer program because a programmer forgot to enter a semicolon.</p>
<p class="indent">Furthermore, schemes such as code-based and lattice-based algorithms rely heavily on mathematical operations, the implementation of which uses a variety of tricks to make those operations as fast as possible. But by the same token, the complexity of the code in these algorithms makes implementation more vulnerable to side-channel attacks, such as timing attacks, which infer information about secret values based on measurement of execution times. In fact, such attacks have already been applied to code-based encryption (see <em><a href="https://eprint.iacr.org/2010/479/">https://eprint.iacr.org/2010/479/</a></em>) and to lattice-based signature schemes (see <em><a href="https://eprint.iacr.org/2016/300/">https://eprint.iacr.org/2016/300/</a></em>).</p>
<p class="indent">The upshot is that, ironically, post-quantum schemes will be less secure in practice at first than non-post-quantum ones, due to vulnerabilities in their implementations.</p>
<h3 class="h3" id="lev1sec97">Further Reading</h3>
<p class="noindent">To learn the basics of quantum computation, read the classic <em>Quantum Computation and Quantum Information</em> by Nielsen and Chuang (Cambridge, 2000). Aaronson’s <em>Quantum Computing Since Democritus</em> (Cambridge, 2013), a less technical and more entertaining read, covers more than quantum computing.</p>
<p class="indent">Several software simulators will allow you to experiment with quantum computing. The Quantum Computing Playground at <em><a href="http://www.quantumplayground.net/">http://www.quantumplayground.net/</a></em> is particularly well designed, with a simple programming language and intuitive visualizations.</p>
<p class="indent">For the latest research in post-quantum cryptography, see <em><a href="https://pqcrypto.org/">https://pqcrypto.org/</a></em> and the associated conference PQCrypto.</p>
<p class="indent">The coming years promise to be particularly exciting for post-quantum crypto thanks to NIST’s Post-Quantum Crypto Project, a community effort to develop the future post-quantum standard. Be sure to check the project’s website <em><a href="http://csrc.nist.gov/groups/ST/post-quantum-crypto/">http://csrc.nist.gov/groups/ST/post-quantum-crypto/</a></em> for the related algorithms, research papers, and workshops.<span epub:type="pagebreak" id="page_270"/></p>
</body></html>