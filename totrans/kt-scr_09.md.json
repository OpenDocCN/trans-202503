["```\nfun main() {\n    // Find the factorial of a positive integer.\n    val n = 5\n    val factorial = getFactorial(n)\n    println(\"The factorial of $n is: $factorial\")\n}\n\nfun getFactorial(n: Int) : Int {\n    if (n <= 1) return 1\n      ❶ else return n * getFactorial(n - 1)\n}\n```", "```\nfun main() {\n    val n = 5\n    val factorial = getFactorial(n)\n    println(\"The factorial of $n is: $factorial\")\n}\n\n❶ tailrec fun getFactorial(n: Int, result: Int = 1): Int {\n    return if (n <= 1) {\n        result\n    } else {\n        getFactorial(n - 1, n * result)\n    }\n}\n```", "```\nval x = 50.0\nval y = 50.0\nval s = 400.0\n❶ val k = 0.15   // Reduce the side by 15%.\ngc.fill = Color.BLACK\n❷ gc.strokePolygon(doubleArrayOf(x, x, x + s, x + s),\n    doubleArrayOf(y, y + s, y + s, y), 4)\n\n// Call the resursive function.\ndrawSquares(x, y, s, k, gc)\n```", "```\nfun drawSquares(_x: Double, _y: Double, _s: Double,\n                k: Double, gc: GraphicsContext) {\n\n    if (iter <= ITER_MAX) {\n        val d = 0.5 * k * _s\n        val x = _x + d\n        val y = _y + d\n        val s = _s – 2 * d\n\n        gc.strokePolygon(doubleArrayOf(x, x, x + s, x + s),\n            doubleArrayOf(y, y + s, y + s, y), 4)\n\n        iter += 1\n      ❶ drawSquares(x, y, s, k, gc)\n    }\n}\n```", "```\nimport javafx.application.Application\nimport javafx.geometry.Pos\nimport javafx.scene.Scene\nimport javafx.scene.canvas.Canvas\nimport javafx.scene.canvas.GraphicsContext\nimport javafx.scene.layout.FlowPane\nimport javafx.scene.paint.Color\nimport javafx.stage.Stage\n\n// global variables\nval ITER_MAX = 22\nvar iter = 1\n\n// beginning of the Application class\nclass GeometricFractal : Application() {\n    override fun start(stage: Stage) {\n\n        val canvas = Canvas(600.0, 600.0)\n        val gc = canvas.graphicsContext2D\n\n        val rootNode = FlowPane()\n        rootNode.alignment = Pos.CENTER\n        rootNode.children.add(canvas)\n\n        val scene = Scene(rootNode, 600.0, 600.0)\n        stage.title = \"Geometric Fractal\"\n        stage.scene = scene\n        stage.show()\n\n        // problem-specific code segment\n        val x = 50.0\n        val y = 50.0\n        val s = 400.0\n        val k = 0.15\n        gc.fill = Color.BLACK\n\n        gc.strokePolygon(doubleArrayOf(x, x, x + s, x + s),\n            doubleArrayOf(y, y + s, y + s, y), 4)\n\n        drawSquares(x, y, s, k, gc)\n    }\n}\n\nfun main() {\n    Application.launch(GeometricFractal::class.java)\n}\n\nfun drawSquares(_x: Double, _y: Double, _s: Double,\n                k: Double, gc: GraphicsContext) {\n\n    if (iter <= ITER_MAX) {\n        val d = 0.5 * _s * k\n        val s = _s - 2 * d\n        val x = _x + d\n        val y = _y + d\n        gc.strokePolygon(\n            doubleArrayOf(x, x, x + s, x + s),\n            doubleArrayOf(y, y + s, y + s, y), 4)\n\n // Update counter.\n        iter += 1\n        // recursive call\n        drawSquares(x, y, s, k, gc)\n    }\n}\n```", "```\nimport kotlin.math.sin\nimport kotlin.math.PI\nimport kotlin.math.pow\n\n// global parameters\nval BASE = 500.0\nval DEPTH = 7\nval baseMin = BASE * ((0.5).pow(DEPTH))\n\ndata class Vertices(var p1: Double, var q1: Double,\n                    var p2: Double, var q2: Double,\n                    var p3: Double, var q3: Double)\n```", "```\n// problem-specific component inside the application class\nval b = BASE\nval h = b * sin(PI / 3.0)\nval x1 = 300.0\nval y1 = 50.0\n\nval x = doubleArrayOf(x1, x1 - b/2, x1 + b/2)\nval y = doubleArrayOf(y1, y1 + h, y1 + h)\n// Draw the outermost triangle.\ngc.strokePolygon(x, y, 3)\n// Call the recursive function.\ndrawTriangle(x1, y1, b, h, gc)\n```", "```\nfun drawTriangle(x1: Double, y1: Double, base: Double,\n                 height: Double, gc: GraphicsContext) {\n\n  ❶ if (base > baseMin) {\n        val (p1, q1, p2, q2, p3, q3) =\n            getVertices(x1, y1, base, height)\n\n        val p = doubleArrayOf(p1, p2, p3)\n        val q = doubleArrayOf(q1, q2, q3)\n        gc.strokePolygon(p, q, 3)\n\n        // recurse for nonempty child triangles\n      ❷ drawTriangle(x1, y1, base/2, height/2, gc)\n      ❸ drawTriangle(p1, q1, base/2, height/2, gc)\n      ❹ drawTriangle(p3, q3, base/2, height/2, gc)\n    }\n}\n\nfun getVertices(x1: Double, y1: Double, base: Double, height: Double) =\n                Vertices(x1 - base/4, y1 + height/2, x1, y1 + height,\n                         x1 + base/4, y1 + height/2)\n```", "```\nimport kotlin.math.PI\nimport kotlin.math.sin\nimport kotlin.math.cos\n```", "```\nval x = canvas.width / 2.0\nval y = canvas.height - 100\nval len = 55.0\nval angle = -PI / 2\nval phi = PI / 10\n\ngc.stroke = Color.GRAY\ndrawTree(x, y, angle, len, phi, gc)\n```", "```\nprivate fun drawTree(x1: Double, y1: Double, theta: Double,\n                     len: Double, phi: Double,\n                     gc: GraphicsContext) {\n\n  ❶ if (len > 10) {\n        val x2 = x1 + len * cos(theta)\n        val y2 = y1 + len * sin(theta)\n        gc.strokeLine(x1, y1, x2, y2)\n\n      ❷ drawTree(x2, y2, theta + phi, len - 4, phi, gc)\n      ❸ drawTree(x2, y2, theta - phi, len - 4, phi, gc)\n\n } else {\n        gc.fill = Color.BLACK\n        gc.fillOval(x1 - 2, y1 - 2, 4.0, 4.0)\n    }\n}\n```", "```\n// global declarations\ndata class Rule(val key: String, val apply: String)\ndata class State(val x: Double, val y: Double, val angle: Double)\nval stack = ArrayDeque<State>()\n```", "```\n// problem definition\n❶ val axiom = \"F++F++F\"\n❷ val rules: List<Rule> = listOf(\n    Rule(\"F\", \"F-F++F-F\"),\n    // Rule(),\n    // Rule()\n    )\n\nvar line = 100.0     // in pixels\nval scaling = .33    // shrinkage factor per iteration\nval ANGLE = 60.0     // turning angle in degrees (fixed)\nval depth = 5        // number of iterations\n\n❸ val turtle = Turtle(150.0, 200.0, 0.0)\n\nvar finalString = \"\"\n```", "```\n// function to generate final L-system string\nfun generate() {\n    var nextString = \"\"\n  ❶ for (letter in finalString) {\n        var match = false\n      ❷ for (rule in rules) {\n          ❸ if (letter.toString() == rule.key) {\n                match = true\n nextString += rule.apply\n                break\n            }\n        }\n      ❹ if (!match) nextString += letter\n    }\n  ❺ finalString = nextString\n}\n```", "```\n// function to draw per finalString instructions\nfun draw(gc: GraphicsContext) {\n  ❶ for (letter in finalString) {\n      ❷ when (letter.toString()) {\n            \"F\", \"G\" -> turtle.lineTo(line, gc)\n            \"J\" ->      turtle.moveTo(line)\n            \"+\" ->      turtle.turnRight(ANGLE)\n            \"-\" ->      turtle.turnLeft(ANGLE)\n            \"[\" ->      turtle.push()\n            \"]\" ->      turtle.pop()\n            \"X\" ->      {/* do nothing */}\n        }\n    }\n}\n```", "```\nimport javafx.scene.canvas.GraphicsContext\nimport kotlin.math.*\n\n❶ class Turtle (var x: Double, var y: Double, angle: Double) {\n    var angleRad = angle * PI /180\n    `--snip--`\n}\n```", "```\nfun lineTo(line: Double, gc: GraphicsContext) {\n    val xBegin = x\n    val yBegin = y\n    x += line * cos(angleRad)\n    y += line * sin(angleRad)\n    gc.strokeLine(xBegin, yBegin, x, y)\n}\n\nfun moveTo(line: Double) {\n    x += line * cos(angleRad)\n    y += line * sin(angleRad)\n}\n\nfun turnRight(delta: Double) {\n    // origin @ bottom left\n    angleRad += delta * PI /180\n}\n\nfun turnLeft(delta: Double) {\n    // origin @ bottom left\n    angleRad -= delta * PI /180\n}\n\nfun push() {\n    stack.addLast(State(x, y, angleRad))\n}\n\nfun pop() {\n    val (xPop, yPop, anglePop) = stack.removeLast()\n    x = xPop\n    y = yPop\n    angleRad = anglePop\n}\n\nfun printTurtle() {\n    print(\"x: ${round(x * 100) / 100.0}  y: ${round(y * 100) / 100.0}  \")\n    println(\"angle: ${round((angleRad * 180 / PI) * 100) / 100.0} degrees\")\n}\n```", "```\n// import statements\n`--snip--`\n\n// global declarations\n`--snip--`\n\n// problem definition\n`--snip--`\n\n// function to generate final L-system string\nfun generate() {\n`--snip--`\n}\n\n// function to draw per finalString instructions\nfun draw(gc: GraphicsContext) {\n`--snip--`\n}\n\n// JavaFX-Kotlin Application class\nclass LSystemApp : Application() {\n    override fun start(stage: Stage) {\n        val canvas = Canvas(600.0, 600.0)\n\n        val gc = canvas.graphicsContext2D\n        // Move the origin to bottom left.\n      ❶ gc.translate(0.0, canvas.height)\n        // Let positive y-axis point up.\n      ❷ gc.scale(1.0, -1.0)\n\n        val pane = Pane()\n        pane.children.add(canvas)\n        val scene = Scene(pane, 600.0, 600.0)\n        stage.title = \"L-system Simulator\"\n        stage.scene = scene\n        stage.show()\n\n        // ---L-system-related code---\n        finalString = axiom\n\n      ❸ if (depth > 0) {\n            for (i in 1..depth) {\n                generate()\n            }\n          ❹ line *= (scaling).pow(depth - 1.0)\n        }\n        draw(gc)\n    }\n}\n\nfun main() {\n    Application.launch(LSystemApp::class.java)\n}\n```", "```\n// problem definition and global parameters\nval xMin = -2.0\nval xMax = 1.0\nval yMin = -1.5\nval yMax = 1.5\nval xRange = xMax - xMin\nval yRange = yMax - yMin\n\nval canvasW = 600.0\nval canvasH = (canvasW / xRange) * yRange\nval increment = 0.003\nval iterMax = 400\n```", "```\n// function to iterate over the search space and draw\n// nonmembers using a grayscale and members as black points\n\nprivate fun drawMSet(gc: GraphicsContext) {\n    var y = yMin\n  ❶ while (y <= yMax) {\n        var x = xMin\n      ❷ while (x <= xMax) {\n          ❸ val cval = getConvergence(x, y)\n          ❹ val speed = cval.toDouble() / iterMax\n            val factor = 1.0 - speed\n            gc.fill = Color.color(factor, factor, factor)\n          ❺ gc.fillRect(canvasW * (x - xMin)/ xRange,\n                canvasH * (y - yMin)/ yRange, 1.0, 1.0)\n            x += increment\n        }\n        y += increment\n    }\n}\n```", "```\n// function to check for membership in the M-set\nprivate fun getConvergence(x: Double, y: Double): Int {\n    var zx = 0.0\n    var zy = 0.0\n  ❶ for (i in 1..iterMax) {\n        val X = zx * zx – zy * zy + x\n        val Y = 2 * zx * zy + y\n      ❷ if (X * X + Y * Y > 4.0) return i\n        zx = X\n zy = Y\n    }\n    return iterMax\n}\n```", "```\n// import statements\n`--snip--`\n\n// problem definition and global declarations\n`--snip--`\n\n// function to iterate over the search space and draw\n// nonmembers using a grayscale and members as black points\nfun drawMSet(gc: GraphicsContext) {\n`--snip--`\n}\n\n// function to check for membership in the M-set\nfun getConvergence(x: Double, y: Double): Int {\n`--snip--`\n}\n\n// Application class for drawing the M-set\nclass Mandelbrot : Application() {\n    override fun start(stage: Stage) {\n        val root = Pane()\n        val canvas = Canvas(canvasW, canvasH)\n        val gc = canvas.graphicsContext2D\n        root.children.add(canvas)\n\n        val scene = Scene(root, canvasW, canvasH)\n        scene.fill = Color.WHITE\n        stage.title = \"Mandelbrot Set\"\n        stage.scene = scene\n        stage.show()\n\n        // Search for M-set members and draw them on the canvas.\ndrawMSet(gc)\n    }\n}\n\n// the main function to launch the application\nfun main() {\n    Application.launch(Mandelbrot::class.java)\n}\n```"]