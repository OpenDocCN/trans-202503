["```\n❶ const newHeap = () => [];\n\n❷ const isEmpty = (heap) => heap.length === 0;\n\n❸ const top = (heap) => {\n  if (isEmpty(heap)) {\n    return undefined;\n  } else {\n    return heap[0];\n  }\n};\n```", "```\nconst add = (heap, keyToAdd) => {\n❶ heap.push(keyToAdd);\n❷ _bubbleUp(heap, heap.length – 1);\n  return heap;\n};\n```", "```\nconst _bubbleUp = (heap, i) => {\n❶ if (i > 0) {\n  ❷ const p = Math.floor((i - 1) / 2);\n  ❸ if (heap[i] > heap[p]) {\n    ❹ [heap[p], heap[i]] = [heap[i], heap[p]];\n ❺ _bubbleUp(heap, p);\n    }\n  }\n};\n```", "```\nconst _sinkDown = (heap, i, h) => {\n❶ const l = 2 * i + 1;\n❷ const r = l + 1;\n❸ let g = i;\n  if (l < h && heap[l] > heap[g]) {\n    g = l;\n  }\n  if (r < h && heap[r] > heap[g]) {\n    g = r;\n  }\n  if (g !== i) {\n  ❹ [heap[g], heap[i]] = [heap[i], heap[g]];\n  ❺ _sinkDown(heap, g, h);\n  }\n};\n```", "```\nconst remove = (heap) => {\n❶ const topKey = top(heap);\n❷ if (!isEmpty(heap)) {\n  ❸ heap[0] = heap[heap.length – 1];\n  ❹ heap.length--;\n  ❺ _sinkDown(heap, 0, heap.length);\n  }\n❻ return [heap, topKey];\n};\n```", "```\nfunction heapsort_original(v) {\n❶ for (let i = 1; i < v.length; i++) {\n    _bubbleUp(v, i);\n  }\n\n❷ for (let i = v.length - 1; i > 0; i--) {\n  ❸ [v[i], v[0]] = [v[0], v[i]];\n  ❹ _sinkDown(v, 0, i);\n  }\n\n  return v;\n}\n```", "```\nfunction heapsort_enhanced(v) {\n **for (let i = Math.floor((v.length - 1) / 2); i >= 0; i--) {**\n **_sinkDown(v, i, v.length);**\n **}**\n\n for (let i = v.length - 1; i > 0; i--) {\n    [v[i], v[0]] = [v[0], v[i]];\n    _sinkDown(v, 0, i);\n  }\n  return v;\n}\n```", "```\nconst {\n  find,\n  inOrder,\n  isEmpty,\n  maxKey,\n  minKey,\n  postOrder,\n  preOrder\n❶} = require(\"../binary_trees/binary_search_tree.func.js\");\n\nconst newTreap = () => null;\n\nconst newNode = (key) => ({\n  key,\n  left: null,\n  right: null,\n❷ **priority: Math.random()**\n});\n```", "```\nconst add = (tree, keyToAdd) => {\n  if (isEmpty(tree)) {\n    return newNode(keyToAdd);\n  } else {\n    const side = keyToAdd <= tree.key ? \"left\" : \"right\";\n    tree[side] = add(tree[side], keyToAdd);\n    **return tree[side].priority <= tree.priority ? tree : _rotate(tree, side);**\n  }\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n  if (isEmpty(tree)) {\n    // nothing to do\n  } else if (keyToRemove < tree.key) {\n    tree.left = remove(tree.left, keyToRemove);\n  } else if (keyToRemove > tree.key) {\n    tree.right = remove(tree.right, keyToRemove);\n  } else if (isEmpty(tree.left) && isEmpty(tree.right)) {\n    tree = null;\n  } else if (isEmpty(tree.left)) {\n    tree = tree.right;\n  } else if (isEmpty(tree.right)) {\n    tree = tree.left;\n❶} else {\n❷ **const [side, other] =**\n **tree.left.priority < tree.right.priority**\n **? [\"right\", \"left\"]**\n **: [\"left\", \"right\"];**\n❸ **tree = _rotate(tree, side);**\n❹ **tree[other] = remove(tree[other], keyToRemove);**\n  }\n  return tree;\n};\n```", "```\nconst {newHeap, isEmpty, top} = require(\"./heap.func.js\");\n\n❶ **const ORDER = 3;** // with ORDER===2, we get classic heaps\n\nconst _bubbleUp = (heap, i) => {\n  if (i > 0) {\n  ❷ **const p = Math.floor((i - 1) / ORDER);**\n    if (heap[i] > heap[p]) {\n      [heap[p], heap[i]] = [heap[i], heap[p]];\n      _bubbleUp(heap, p);\n    }\n  }\n};\n\nconst _sinkDown = (heap, i, h) => {\n❸ **const first = ORDER * i + 1;**\n❹ **const last = first + ORDER;**\n  let g = i;\n❺ **for (let j = first; j < last && j < h; j++)** {\n    if (heap[j] > heap[g]) {\n      g = j;\n    }\n  }\n  if (g !== i) {\n    [heap[g], heap[i]] = [heap[i], heap[g]];\n    _sinkDown(heap, g, h);\n  }\n};\n\nconst add = (heap, keyToAdd) => {...exactly as before...}\n\nconst remove = (heap) => {...exactly as before...}\n```", "```\nfor (let i = **v.length - 1**; i >= 0; i--) {\n  sinkDown(i, v.length);\n}\n```", "```\ntree[other] = remove(tree[other], keyToRemove);\n```", "```\ntree = remove(tree, keyToRemove);\n```", "```\nconst remove = (tree, keyToRemove) => {\n  if (isEmpty(tree)) {\n    // nothing to do\n  } else if (keyToRemove < tree.key) {\n    tree.left = remove(tree.left, keyToRemove);\n  } else if (keyToRemove > tree.key) {\n    tree.right = remove(tree.right, keyToRemove);\n  } else if (isEmpty(tree.left) && isEmpty(tree.right)) {\n    tree = null;\n } else if (isEmpty(tree.left)) {\n    tree = tree.right;\n  } else if (isEmpty(tree.right)) {\n    tree = tree.left;\n  } else {\n    const [side, other] =\n      tree.left.priority < tree.right.priority\n        ? [\"right\", \"left\"]\n        : [\"left\", \"right\"];\n    tree = _rotate(tree, side);\n    **tree = remove(tree, keyToRemove);**\n  }\n\n  return tree;\n};\n```"]