<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch26" epub:type="chapter" role="doc-chapter">
<span aria-label="497" epub:type="pagebreak" id="pg_497" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch26">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">26</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">ABSTRACT METHODS, INTERFACES, AND TRAITS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">In this chapter, we’ll move beyond the standard mechanism of inheritance from a superclass to a subclass and explore other strategies for sharing methods among classes. You’ll be introduced to abstract methods, interfaces, and traits.</p>
<p class="TX">As you’ll see, abstract methods and interfaces allow you to share just the signatures of methods across multiple classes, without specifying the details of how the methods should be implemented. In effect, these mechanisms act as <i>contracts</i>: to use abstract methods or interfaces, a class must agree to provide suitable implementations of those methods. Meanwhile, traits are a way to bypass inheritance and share fully implemented methods among classes in separate hierarchies. Interfaces, too, transcend class hierarchies, while abstract methods are still passed along between superclasses and subclasses through inheritance.</p>
<p class="TX">Together, abstract methods, interfaces, and traits can facilitate updating an application without breaking any code, since they provide assurances <span aria-label="498" epub:type="pagebreak" id="pg_498" role="doc-pagebreak"/>that certain methods will be present on a class for use by other parts of the application. Abstract methods and interfaces, in particular, promote class interchangeability. By enforcing method signatures while remaining agnostic about the implementations, they make it easy to substitute in classes that realize those methods differently as new project requirements arise (for example, having new types of files to write to, new database management systems to communicate with, or new destinations for logging events and exceptions). Traits, on the other hand, are helpful for avoiding redundancy and promoting code reusability, since they save you from having to declare the same method on several unrelated classes. In this sense, they’re somewhat similar to utility classes that are designed to make certain common operations available to all the classes in an application.</p>
<p class="TX">Of the topics covered in this chapter, interfaces especially are quite common in medium-to-large PHP projects. Even if you don’t write many interfaces yourself, you’ll probably use them, since they’re a feature of many third-party libraries for core web application components, including database communication and working with HTTP requests and responses.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="toc-link_338"/><span class="SANS_Futura_Std_Bold_B_11">From Inheritance to Interfaces</span></h3>
<p class="TNI1">In this section, we’ll progressively develop a sample network of classes to illustrate the features and merits of abstract methods and interfaces. We’ll start by reviewing the conventional process of a subclass inheriting methods from a superclass, then transition to using abstract methods and finally interfaces to standardize the features of unrelated classes. For simplicity, this will be a toy example. Once we’ve established the basics, however, we’ll turn to a more realistic and practical application for interfaces.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_339"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Inheriting a Fully Implemented Method from a Superclass</span></h4>
<p class="TNI1">As we discussed in <span class="Xref"><a href="chapter19.xhtml">Chapter 19</a></span>, inheritance makes it possible to pass down the definition of a superclass method to a related group of subclasses. If some of the subclasses need to implement the method differently, they can always override it with their own implementation, while other subclasses will simply inherit the default implementation from the superclass.</p>
<p class="TX">Sometimes the superclass may be abstract, meaning it will never be instantiated. In this case, one or more non-abstract subclasses must extend the abstract superclass in order for objects to be created and the superclass’s methods to be executed. As an example, <a href="#fig26-1">Figure 26-1</a> shows a simple class hierarchy of various animals, all of which will be able to return a string describing the type of sound they make.</p>
<span aria-label="499" epub:type="pagebreak" id="pg_499" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig26-1"/><img alt="" class="img100" height="684" src="../images/figure26-1.jpg" width="1360"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-1: A class hierarchy with an abstract superclass passing down a</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">getSound()</span> <span class="SANS_Futura_Std_Book_Oblique_11">method</span></p></figcaption>
</figure>
<p class="TX">At the top of this class hierarchy is the abstract <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> superclass. Its <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span> property is declared with a default value of <span class="SANS_TheSansMonoCd_W5Regular_11">'meow'</span> and protected (<span class="SANS_TheSansMonoCd_W5Regular_11">#</span>) visibility, meaning the property’s value can be accessed (and overridden) by a subclass if required. Its <span class="SANS_TheSansMonoCd_W5Regular_11">numLegs</span> property is public (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span>) and has a default value of <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>. In addition, a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method returns the string stored in <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span>.</p>
<p class="TX">At the next layer of the hierarchy, the <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> subclass extends <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> and so inherits the <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">numLegs</span> properties and the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method. This means <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> objects will produce a <span class="SANS_TheSansMonoCd_W5Regular_11">'meow'</span> sound. The <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> subclass also extends <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> but declares its own <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span> property of <span class="SANS_TheSansMonoCd_W5Regular_11">'bark'</span>, overriding the value inherited from the superclass.</p>
<p class="TX">Finally, let’s imagine that opinions vary about the sound a bird makes; sometimes <span class="SANS_TheSansMonoCd_W5Regular_11">'tweet tweet'</span> is more popular, and sometimes <span class="SANS_TheSansMonoCd_W5Regular_11">'chirp chirp'</span>. To account for this, the <span class="SANS_TheSansMonoCd_W5Regular_11">Bird</span> subclass declares a custom implementation of <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span>, overriding the inherited method from the superclass. At runtime, each <span class="SANS_TheSansMonoCd_W5Regular_11">Bird</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method will access a (fictional) API at <i><a href="http://www.mostPopularBirdSound.com">www.mostPopularBirdSound.com</a></i> to determine the most popular bird sound string, ignoring the value of its inherited <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span> property. In addition, since birds have only two legs, the <span class="SANS_TheSansMonoCd_W5Regular_11">Bird</span> class overrides the inherited number of legs.</p>
<p class="TX">Listing 26-1 shows the code for the <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> class.</p>
<span id="lis26-1"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
abstract class Animal&#13;
{&#13;
    protected string $sound = "meow";&#13;
    public int $numLegs = 4;&#13;
&#13;
<span aria-label="500" epub:type="pagebreak" id="pg_500" role="doc-pagebreak"/>  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> public function getSound(): string&#13;
    {&#13;
        return $this-&gt;sound;&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-1: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Animal</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> class to be <span class="SANS_TheSansMonoCd_W5Regular_11">abstract</span> so that it can never be instantiated and assign it <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">numLegs</span> properties. We also provide an implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method <span aria-label="annotation1" class="CodeAnnotation">❶</span>, which returns the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span> property. For any instance of a subclass inheriting this method, the value of the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">sound</span> property will be determined at runtime when the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method is invoked. For example, a <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> object will return <span class="SANS_TheSansMonoCd_W5Regular_11">'meow'</span>, a <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> object will return <span class="SANS_TheSansMonoCd_W5Regular_11">'bark'</span>, and a <span class="SANS_TheSansMonoCd_W5Regular_11">Bird</span> object will override this method and instead return whatever string is retrieved from the <i><a href="http://www.mostPopularBirdSound.com">www.mostPopularBirdSound.com</a></i> API.</p>
<p class="TX">The takeaway from this example is that a superclass (whether abstract or not) provides a way to offer a default method implementation that gets inherited by the subclasses in its class hierarchy. When required, however, this implementation can be overridden by individual subclasses.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="toc-link_340"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Inheriting an Abstract Method</span></h4>
<p class="TNI1">An <i>abstract method</i> is a method on a superclass that doesn’t have an implementation. Instead, all that’s declared is the method’s signature: its name, its parameters, and its return type. Any subclasses that inherit from the superclass must provide their own implementation of the abstract method. The exact details of how the method is implemented are left up to each subclass, as long as the implementation matches the method signature specified on the superclass.</p>
<p class="TX">Abstract methods can come into play when very different classes should exhibit the same behavior. For example, cars, like animals, make sound, and they should likely have a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method that returns a string, just like our <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> class does. However, cars are otherwise very different from animals, and even the way they make sounds is pretty different; cars might output a sound such as <span class="SANS_TheSansMonoCd_W5Regular_11">'putt-putt-putt'</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">'purr'</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">'vroom-vroom'</span>, depending on their engine size, fuel type, and so on. As such, the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method for cars will be different from that for animals, and yet they’ll still have the same signature, since in both cases the method is ultimately returning a string.</p>
<p class="TX">Let’s address this scenario by introducing a new abstract <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> superclass that declares an abstract <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method. Any subclasses inheriting from <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span>, such as <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span>, will have to provide an appropriate <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> implementation. <a href="#fig26-2">Figure 26-2</a> shows the new, modified class hierarchy.</p>
<span aria-label="501" epub:type="pagebreak" id="pg_501" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig26-2"/><img alt="" class="img100" height="1013" src="../images/figure26-2.jpg" width="1675"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-2: Sharing an abstract</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">getSound()</span> <span class="SANS_Futura_Std_Book_Oblique_11">method through the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">SoundMaker</span> <span class="SANS_Futura_Std_Book_Oblique_11">superclass</span></p></figcaption>
</figure>
<p class="TX">Listing 26-2 shows the declaration of the new <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> class. Notice that the class provides no implementation for the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method, just its signature.</p>
<span id="lis26-2"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
abstract class SoundMaker&#13;
{&#13;
    abstract public function getSound(): string;&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-2: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">SoundMaker</span> <span class="SANS_Futura_Std_Book_Oblique_11">class with an abstract method</span></p>
<p class="TX">We designate the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method <span class="SANS_TheSansMonoCd_W5Regular_11">abstract</span> and declare just its signature. The method declaration is considered a statement, since no implementation is provided, and so it must end with a semicolon.</p>
<p class="TX">The non-abstract <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> subclass must now provide an implementation for the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method in order to successfully inherit from <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span>. If it didn’t, we’d get a fatal error like the following:</p>
<pre><code>PHP Fatal error:  Class Mattsmithdev\Car contains 1 abstract method and must&#13;
therefore be declared abstract or implement the remaining methods</code></pre>
<p class="TX">We’ve already provided a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> implementation on the <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> class, so it can successfully inherit from <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Dog</span> subclasses inherit <span aria-label="502" epub:type="pagebreak" id="pg_502" role="doc-pagebreak"/>the method implementation from <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span>, so they also meet the requirements of the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> class. The <span class="SANS_TheSansMonoCd_W5Regular_11">Bird</span> class can still override the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> implementation inherited from <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> with its own implementation.</p>
<p class="TX">To see the benefit of making <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> an abstract method, say our application has a function that needs to know the sound an object makes. That function can require a <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> object (or one of its subclasses) as an argument, and know that whatever subclass of <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> is received will have a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method that can be invoked to return a string. It doesn’t matter whether it’s an <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> object or a <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> object; the method is guaranteed to be there. In this way, abstract methods maximize class interchangeability while still allowing for different classes to have quite distinct implementations of a method.</p>
<p class="TX">If a class declares one or more abstract methods, the class itself must also be abstract. This is because you can’t instantiate a class with an abstract method, since no implementation of the method is provided. The opposite isn’t necessarily true, however: a class may be declared abstract but not contain any abstract methods. For example, you might have an abstract class consisting of fully implemented, static members.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="toc-link_341"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Requiring Method Implementations with Interfaces</span></h4>
<p class="TNI1">An <i>interface</i> is a way to declare the signatures of one or more methods that a class should have. Classes then <i>implement</i> the interface by declaring methods with those specified signatures. Interfaces are similar to abstract methods in that both are ways of ensuring that one or more classes should have certain methods, without specifying exactly how those methods should be implemented. Both promote class interchangeability by guaranteeing the consistency of those methods’ signatures. The difference is that interfaces <i>aren’t</i> classes, and therefore are independent of any class hierarchy scheme, whereas abstract methods are declared as part of a class. As such, any classes that implement the abstract methods must fall within the hierarchy of the class that declares them.</p>
<p class="TX">Being independent of class hierarchies, interfaces are useful when you want to share a behavior among very different classes that wouldn’t belong in the same class hierarchy, or when you want to share multiple behaviors, in various combinations, among several very different classes.</p>
<p class="TX">Continuing with the example from the previous sections, pipe organs also make sounds, like cars and animals. Both pipe organs and cars require regular maintenance as well, whereas animals don’t. Let’s consider that subclasses of a <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> class must implement a <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> method that returns some kind of <span class="SANS_TheSansMonoCd_W5Regular_11">Date</span> object. The way a service date is calculated will be implemented differently for <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> objects and <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> objects. <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> service dates may be based on the type of engine and number of miles driven, while <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> objects may have service dates calculated based on, say, the length and material of the pipes.</p>
<p class="TX"><span aria-label="503" epub:type="pagebreak" id="pg_503" role="doc-pagebreak"/>We might be tempted to create a new abstract <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> class that declares an abstract <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> method. The <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> classes would inherit from <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> and provide their own <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> implementations, while also inheriting from the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> class, along with <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span>. This would be an example of <i>multiple inheritance</i>, the capability of a class to inherit from two or more superclasses at the same time. The class diagram in <a href="#fig26-3">Figure 26-3</a> illustrates this scheme.</p>
<figure class="IMG"><a id="fig26-3"/><img alt="" class="img100" height="781" src="../images/figure26-3.jpg" width="1686"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-3: A class hierarchy with multiple inheritance</span></p></figcaption>
</figure>
<p class="TX">This arrangement may seem appealing: the <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> classes inherit from two superclasses, thereby receiving the requirement for the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method from the abstract <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> class as before while also receiving the requirement for the <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> method from the abstract <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> class. However, although some computer languages allow multiple inheritance, PHP does not, to avoid problems of ambiguity. If a class inherits from more than one superclass, and two or more of those superclasses declare a constant or method of the same name, how does the inheriting class know which to use?</p>
<p class="TX">We could try to get around the prohibition against multiple inheritance by placing the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> superclasses at different levels of the same class hierarchy. That is, we could make <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> a subclass of <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> subclasses of <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span>, as in <a href="#fig26-4">Figure 26-4</a>.</p>
<span aria-label="504" epub:type="pagebreak" id="pg_504" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig26-4"/><img alt="" class="img100" height="743" src="../images/figure26-4.jpg" width="1545"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-4: A class hierarchy where</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Maintainable</span> <span class="SANS_Futura_Std_Book_Oblique_11">is a subclass of</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">SoundMaker</span></p></figcaption>
</figure>
<p class="TX">At first glance, this seems to work. Objects of any class in the hierarchy must have a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method, and <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> each must implement a <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> method as well. However, what if we identify further behaviors that some of these classes should have but not others? Those behaviors may not make sense anywhere in the proposed hierarchy. Also, what if we want to add a <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> subclass that doesn’t make sound? Chimneys, for example, require regular maintenance but are silent.</p>
<p class="TX">Clearly, we’ve created a fragile and artificial class hierarchy. Completely unrelated classes such as birds, cars, and chimneys may be forced into being subclasses of classes they have nothing to do with, all to enforce the inheritance of the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> method signatures. The solution is to use an interface to define a set of required method signatures that can be implemented by classes that aren’t all in the same hierarchy. This dodges the illegal solution of multiple inheritance while also skirting the requirement for a single class hierarchy.</p>
<p class="TX">To demonstrate, let’s first define <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> as an interface rather than a class. Then we can stipulate that the classes in our example should all implement the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface. This is illustrated in <a href="#fig26-5">Figure 26-5</a>.</p>
<p class="TX">At the lower left of the diagram, the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface declares the signature of the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method. With <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> reframed as an interface rather than a class, we’re free to break our classes into separate, more meaningful, and robust hierarchies: we have the abstract <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> class and its subclasses, and the abstract <span class="SANS_TheSansMonoCd_W5Regular_11">Vehicle</span> class with subclasses <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Helicopter</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> class, which has little to do with animals or vehicles, is off by itself. The classes that implement the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface are annotated with the interface name and <i>lollipop notation</i>.</p>
<span aria-label="505" epub:type="pagebreak" id="pg_505" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig26-5"/><img alt="" class="img100" height="1046" src="../images/figure26-5.jpg" width="1849"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-5: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">SoundMaker</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface, implemented by multiple classes</span></p></figcaption>
</figure>
<p class="TX">Notice that when an abstract class such as <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">Vehicle</span> implements an interface, it doesn’t have to provide full implementations of all (or any) of the methods declared on the interface. The implementation can be left to the non-abstract subclasses instead. Here <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> provides a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> implementation (although it’s overridden by the <span class="SANS_TheSansMonoCd_W5Regular_11">Bird</span> subclass), while <span class="SANS_TheSansMonoCd_W5Regular_11">Vehicle</span> doesn’t. In the latter case, the <span class="SANS_TheSansMonoCd_W5Regular_11">Car</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Helicopter</span> subclasses must each provide their own custom <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> implementation in order to fulfill the promise the <span class="SANS_TheSansMonoCd_W5Regular_11">Vehicle</span> class is making by declaring that it will implement the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface.</p>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Declaring an Interface</span></h5>
<p class="TNI1">The code declaring an interface goes in its own.<i>php</i> file with the same name as the interface, much like a class declaration. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface should be declared in a <i>SoundMaker.php</i> file. <a href="#lis26-3">Listing 26-3</a> shows its code.</p>
<span id="lis26-3"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
interface SoundMaker&#13;
{&#13;
    public function getSound(): string;&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-3: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">SoundMaker</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface</span></p>
<p class="TX"><span aria-label="506" epub:type="pagebreak" id="pg_506" role="doc-pagebreak"/>We declare <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">interface</span> keyword. Its body contains just the signature for the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method, without an actual implementation. Just as when declaring an abstract method, the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> signature must end with a semicolon to indicate the end of the statement. Notice that we give <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> public visibility. Including the <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> modifier explicitly is considered best practice, though it isn’t strictly necessary since all methods declared on an interface are automatically considered public so that other parts of the system can harness the behaviors of any interface-implementing classes.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>In addition to declaring method signatures, interfaces can also declare constants. A class that implements the interface will inherit the interface constant, although as of PHP 8.1, the class can override the interface constant if needed.</i></p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing an Interface</span></h5>
<p class="TNI1">Now let’s look at how a class can implement an interface. As an example, <a href="#lis26-4">Listing 26-4</a> shows the code for the <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> class, which implements the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface.</p>
<span id="lis26-4"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
class PipeOrgan implements SoundMaker&#13;
{&#13;
    public function getSound(): string&#13;
    {&#13;
        return 'dum, dum, dum-dum';&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-4: Implementing the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">SoundMaker</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface with the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">PipeOrgan</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">We declare that this class implements the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface by using the <span class="SANS_TheSansMonoCd_W5Regular_11">implements</span> keyword. Because the <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> class implements <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span>, the class is obligated to provide an implementation for the <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method: in this case, it returns the string <span class="SANS_TheSansMonoCd_W5Regular_11">'dum, dum, dum-dum'</span>. The method matches the signature declared by the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface. We would similarly declare <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> methods on the <span class="SANS_TheSansMonoCd_W5Regular_11">Animal</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Vehicle</span> classes. The details of each implementation don’t matter, as long as the method is called <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> and it returns a string.</p>
<p class="TX">If a (non-abstract) class doesn’t include a definition for a method required by an interface it’s implementing, you’d get a fatal error. For example, if the code for the <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> class didn’t declare a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method, you’d see the following when trying to create an object of this class:</p>
<pre><code>PHP Fatal error:  Class Mattsmithdev\PipeOrgan contains 1 abstract method and&#13;
must therefore be declared abstract or implement the remaining methods</code></pre>
<p class="BodyContinued"><span aria-label="507" epub:type="pagebreak" id="pg_507" role="doc-pagebreak"/>Notice that this is exactly the same fatal error as when a subclass fails to implement an abstract method declared in its superclass. The PHP engine processes the method signatures of an interface as if they were abstract methods; they must be realized in the class hierarchy implementing the interface before any object can be created.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing Multiple Interfaces with One Class</span></h5>
<p class="TNI1">A powerful feature of interfaces is that a single class may implement more than one of them. When a class implements an interface, it’s promising to provide a set of public methods with the signatures declared in that interface, and there’s no reason a class can’t do this for multiple interfaces.</p>
<p class="TX">Returning to our example, the <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> class can implement a <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> interface, promising to declare an implementation of <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span>, in addition to implementing the <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interface by declaring a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method. Likewise, if all vehicles require maintenance and make sounds, the <span class="SANS_TheSansMonoCd_W5Regular_11">Vehicle</span> class can implement both the <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> interfaces too. <a href="#fig26-6">Figure 26-6</a> shows how these classes can implement multiple interfaces.</p>
<figure class="IMG"><a id="fig26-6"/><img alt="" class="img100" height="933" src="../images/figure26-6.jpg" width="1687"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-6: Classes implementing multiple interfaces</span></p></figcaption>
</figure>
<p class="TX">The figure shows the <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> interface alongside <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span>, and the <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Vehicle</span> classes now have two “lollipops,” indicating that they implement both interfaces. This arrangement of classes and interfaces is much neater conceptually than the artificial class hierarchy shown in <a href="#fig26-4">Figure 26-4</a> or the multiple inheritance scheme shown in <a href="#fig26-3">Figure 26-3</a>.</p>
<p class="TX">To see how to declare that a class implements multiple interfaces, refer to <a href="#lis26-5">Listing 26-5</a>, which shows the updated code for the <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> class.</p>
<span id="lis26-5"/>
<pre><code><span aria-label="508" epub:type="pagebreak" id="pg_508" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">namespace Mattsmithdev;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class PipeOrgan implements SoundMaker,</span> Maintainable&#13;
{&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function getSound(): string</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return 'dum, dum, dum-dum';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
    public function nextService(): \DateTime&#13;
    {&#13;
        return new \DateTime('2030-01-01');&#13;
    }&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-5: Implementing multiple interfaces with the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">PipeOrgan</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">When a class implements multiple interfaces, you need to use the <span class="SANS_TheSansMonoCd_W5Regular_11">implements</span> keyword only once, followed by the interface names, separated by commas, as in <span class="SANS_TheSansMonoCd_W5Regular_11">implements SoundMaker, Maintainable</span> here. Beyond this, implementing multiple interfaces is as simple as providing definitions for all requisite methods. In this case, we’ve added the <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> method, which returns a <span class="SANS_TheSansMonoCd_W5Regular_11">DateTime</span> object as the <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> interface requires (we’ll discuss handling dates in <span class="Xref"><a href="chapter31.xhtml">Chapter 31</a></span>).</p>
<p class="TX">I mentioned earlier that an argument against multiple inheritance is the ambiguity of a class attempting to inherit the same member from multiple superclasses. This isn’t a problem for a class implementing multiple interfaces. Whether one, two, or any number of interfaces declare identical method signatures, all those interface contracts can be met by a single method of that signature implemented in a class. For example, if for some reason the <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> interface declared both a <span class="SANS_TheSansMonoCd_W5Regular_11">nextService()</span> and a <span class="SANS_TheSansMonoCd_W5Regular_11">getSound()</span> method, the code would still work fine provided the <span class="SANS_TheSansMonoCd_W5Regular_11">PipeOrgan</span> class declares implementations for both methods. As long as all methods coming from interfaces are defined in the classes that implement them, no ambiguity exists and the PHP engine will work consistently, correctly, and error-free.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing Interfaces and Abstract Classes</span></h5>
<p class="TNI1">At first glance, it may seem that interfaces are the same as abstract classes, as neither can be used to instantiate objects. However, while the concepts are related, key differences exist, and each is appropriate for different situations. Above all, an abstract class is a class, while an interface is not; it’s a promise, or contract, of method signatures that a class must implement. Another key difference is that a class can inherit from only one abstract class, whereas a class can implement multiple interfaces.</p>
<p class="TX">Interfaces can’t declare or work with instance-level members, so interfaces can’t have instance properties or implement methods that work with instance members. Indeed, interfaces can’t implement methods at all; they only specify requirements for instance methods. An abstract class, meanwhile, can be a fully implemented class, or it can be a partially completed <span aria-label="509" epub:type="pagebreak" id="pg_509" role="doc-pagebreak"/>class including instance variables, a constructor, and a combination of implemented instance methods and unimplemented abstract methods. In the latter case, a class extending an abstract class has to complete the implementation only by fleshing out the inherited abstract methods.</p>
<p class="TX">Interfaces and abstract classes also differ in terms of method visibility. Methods declared on interfaces must be public, whereas abstract classes have the option to declare protected methods that are available only for internal use by objects within the class hierarchy. Also, while declaring the signature of a constructor method on an interface is technically possible, it’s highly discouraged; but it’s perfectly fine for an abstract class to have a constructor. Finally, it should be noted that an interface can extend another interface, much like a subclass extending a superclass. Unlike with class inheritance, however, an interface can extend multiple interfaces.</p>
</section>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="toc-link_342"/><span class="SANS_Futura_Std_Bold_B_11">Real-World Applications of Interfaces</span></h3>
<p class="TNI1">Our <span class="SANS_TheSansMonoCd_W5Regular_11">SoundMaker</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Maintainable</span> scenario may have been a trivial example, but interfaces have significant real-world applications as well. They’re particularly useful for standardizing the method signatures of classes whose behavior may change as a web application evolves. Declaring the method signatures as an interface ensures that the application will still work; even if the details of the method implementations change, the way to call the methods won’t, so the rest of the application code will be unaffected.</p>
<p class="TX">We already used a practical, real-world interface in <span class="Xref"><a href="chapter24.xhtml">Chapter 24</a></span> when we discussed logging. The PSR-3 standard specifies a <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> interface, outlining several methods that any classes implementing the interface must provide, such as <span class="SANS_TheSansMonoCd_W5Regular_11">log()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">error()</span>, and so on. You can work with any class that implements this interface and feel confident that these methods will be present. In <span class="Xref"><a href="chapter24.xhtml">Chapter 24</a></span>, for example, we used the Monolog library’s <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> class, which implements the <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> interface, but classes from other third-party libraries implement it too. Any of these classes would work, and you could even switch between <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> implementations without having to change the code that uses the logging object provided.</p>
<p class="TX">Another functionality that interfaces can help with is the ability to temporarily cache (store) data, such as when processing form submissions or HTTP requests in a web application. Caching the data helps avoid having to pass lots of arguments between controller objects and methods; you can simply store the data to the cache in one part of the code and then retrieve it from the cache in another part.</p>
<p class="TX">Caching has many approaches, such as using browser sessions, a database, JSON or XML files, the PHP Extension Community Library (PECL) language extension, or perhaps an API to connect to another service. If you declare an interface for common caching operations, you can write code that will be compatible with any interface-compliant caching system. Then you can easily switch caching systems as the project requirements change. For example, you might use one caching system when developing a project and a different caching system for the live production website.</p>
<p class="TX"><span aria-label="510" epub:type="pagebreak" id="pg_510" role="doc-pagebreak"/>We’ll explore the approaches to caching in this section and illustrate how to standardize them through a caching interface. We’ll test everything through a web application designed to cache the ID of any incoming HTTP requests and display that ID on an About page.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>PHP already has the PSR-6 and PSR-16 standards recommendations for caching interfaces, but they’re too involved for our purposes. We’ll create our own simpler approach to caching to explore the benefits of interfaces through a more straightforward example.</i></p>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="toc-link_343"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Caching Approach 1: Using an Array</span></h4>
<p class="TNI1">First, let’s implement a cache as a class called <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> that uses a static (class-level) array for storing and retrieving values under string keys. We might use this simple approach to get the cache working quickly during the early stages of development. Besides getting and setting values, we’ll want the class to provide a <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> method that returns a Boolean indicating whether a value is currently stored for a given key.</p>
<p class="TX">Start a new project and give it the usual <i>composer.json</i> file declaring <i>src</i> as the location for classes in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace. Generate an autoloader with Composer, and create the usual <i>public/index.php</i> script that reads in and executes the autoloader, creates an <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> object, and invokes its <span class="SANS_TheSansMonoCd_W5Regular_11">run()</span> method. Once that’s written, you’re ready to declare the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> class in <i>src/CacheStatic.php</i>, as shown in <a href="#lis26-6">Listing 26-6</a>.</p>
<span id="lis26-6"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
class CacheStatic&#13;
{&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> private static array $dataItems = [];&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> public static function set(string $key, string $value): void&#13;
    {&#13;
        self::$dataItems[$key] = $value;&#13;
    }&#13;
&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> public static function get(string $key): ?string&#13;
    {&#13;
        if (self::has($key)) {&#13;
            return self::$dataItems[$key];&#13;
        }&#13;
&#13;
        return NULL;&#13;
    }&#13;
&#13;
  <span aria-label="annotation4" class="Code_CodeAnnotation">❹</span> public static function has(string $key): bool&#13;
    {&#13;
        return array_key_exists($key, self::$dataItems);&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-6: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">CacheStatic</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX"><span aria-label="511" epub:type="pagebreak" id="pg_511" role="doc-pagebreak"/>We initialize the private static <span class="SANS_TheSansMonoCd_W5Regular_11">dataItems</span> property as an empty array <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This will be our cache. Then we declare the <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span> static method, which takes in two string arguments, a key and a value, for storage in the cache <span aria-label="annotation2" class="CodeAnnotation">❷</span>. We next declare the <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span> static method, which takes in a string key and returns the value in the cache array stored for that key <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The method includes a test that returns <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> if no value exists for the given key. Finally, we declare the static <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> method <span aria-label="annotation4" class="CodeAnnotation">❹</span>, which returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> to indicate whether a value is cached for the given key.</p>
<p class="TX">Next, we’ll declare the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> class. Its <span class="SANS_TheSansMonoCd_W5Regular_11">run()</span> method will cache the ID from the HTTP request, then instantiate a <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> object (we’ll declare this class shortly) to respond to the request. Create the file <i>src/Application.php</i> with the code in <a href="#lis26-7">Listing 26-7</a>.</p>
<span id="lis26-7"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
class Application&#13;
{&#13;
    public function run()&#13;
    {&#13;
        $action = filter_input(INPUT_GET, 'action');&#13;
      <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> $id = filter_input(INPUT_GET, 'id');&#13;
        if (empty($id)) {&#13;
            $id = "(no id provided)";&#13;
        }&#13;
&#13;
        // Cache ID from URL&#13;
      <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> CacheStatic::set('id', $id);&#13;
&#13;
        $mainController = new MainController();&#13;
      <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> switch ($action) {&#13;
            case 'about':&#13;
                $mainController-&gt;aboutUs();&#13;
                break;&#13;
&#13;
            default:&#13;
                $mainController-&gt;homepage();&#13;
        }&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-7: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Application</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">After retrieving the URL-encoded <span class="SANS_TheSansMonoCd_W5Regular_11">action</span> variable as usual, we attempt to retrieve another URL-encoded variable called <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> and store its value in the <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If this query-string variable turns out to be empty, we set <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">'(no id provided)'</span> instead. Then we use the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span> static method to store the string in the <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> variable in the cache with a key of <span class="SANS_TheSansMonoCd_W5Regular_11">'id'</span> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. We can now retrieve the stored string with the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> public static method <span class="SANS_TheSansMonoCd_W5Regular_11">get('id')</span> if needed. The <span class="SANS_TheSansMonoCd_W5Regular_11">run()</span> method concludes with <span aria-label="512" epub:type="pagebreak" id="pg_512" role="doc-pagebreak"/>a typical <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement that invokes either the <span class="SANS_TheSansMonoCd_W5Regular_11">homepage()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">aboutUs()</span> method of the <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> object, depending on the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">action</span> variable <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p class="TX">Now we’ll declare the <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> class. Create <i>src/MainController.php</i> as shown in <a href="#lis26-8">Listing 26-8</a>.</p>
<span id="lis26-8"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
class MainController&#13;
{&#13;
    public function homepage()&#13;
    {&#13;
        require_once __DIR__ . '/../templates/homepage.php';&#13;
    }&#13;
&#13;
    public function aboutUs()&#13;
    {&#13;
      <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> $id = CacheStatic::get('id');&#13;
        require_once __DIR__ . '/../templates/aboutUs.php';&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-8: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">MainController</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">homepage()</span> method simply outputs the Home page template. In the <span class="SANS_TheSansMonoCd_W5Regular_11">aboutUs()</span> method, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span> method to retrieve the ID from the cache array, storing the result in the <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> variable <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we read in and execute the About page template, which will have access to <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span>.</p>
<p class="TX">Listing 26-9 shows the content of the Home page template. Enter this code into <i>templates/homepage.php</i>.</p>
<span id="lis26-9"/>
<pre><code>&lt;!DOCTYPE html&gt;&#13;
&lt;html lang="en"&gt;&#13;
&lt;head&gt;&#13;
    &lt;title&gt;home page&lt;/title&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
&lt;?php&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> require_once '_nav.php'&#13;
?&gt;&#13;
&#13;
&lt;h1&gt;home page&lt;/h1&gt;&#13;
&lt;p&gt;&#13;
    welcome to home page&#13;
&lt;/p&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-9: The</span> <span class="SANS_Futura_Std_Book_11">homepage.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">template</span></p>
<p class="TX"><span aria-label="513" epub:type="pagebreak" id="pg_513" role="doc-pagebreak"/>This basic HTML Home page template reuses some code by outputting the navigation bar from the partial template file <i>templates/_nav.php</i> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. <a href="#lis26-10">Listing 26-10</a> shows the content of that partial template.</p>
<span id="lis26-10"/>
<pre><code>&lt;ul&gt;&#13;
    &lt;li&gt;&#13;
        &lt;a href="/"&gt;&#13;
            Home&#13;
        &lt;/a&gt;&#13;
    &lt;/li&gt;&#13;
    &lt;li&gt;&#13;
        &lt;a href="/?action=about"&gt;&#13;
            About Us&#13;
        &lt;/a&gt;&#13;
    &lt;/li&gt;&#13;
    &lt;li&gt;&#13;
      <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> &lt;a href="/?action=about&amp;id=&lt;?= rand(1,99) ?&gt;"&gt;&#13;
            about (with ID in URL)&#13;
        &lt;/a&gt;&#13;
    &lt;/li&gt;&#13;
&lt;/ul&gt;&#13;
&lt;hr&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-10: The</span> <span class="SANS_Futura_Std_Book_11">_nav.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">partial template</span></p>
<p class="TX">The navigation bar starts with two simple links, with the <i>/</i> URL for the home page and <i>/?action=about</i> for the About page. We also provide an extra, more complex link to the About page <span aria-label="annotation1" class="CodeAnnotation">❶</span>, using PHP’s <span class="SANS_TheSansMonoCd_W5Regular_11">rand()</span> function to pick an integer from <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">99</span> and pass it as the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> query-string variable. This value will be cached and then displayed in the content of the About page to confirm that the cache is working.</p>
<p class="TX">Listing 26-11 shows the About page template in <i>templates/aboutUs.php</i>.</p>
<span id="lis26-11"/>
<pre><code>&lt;!DOCTYPE html&gt;&#13;
&lt;html lang="en"&gt;&#13;
&lt;head&gt;&#13;
    &lt;title&gt;about page&lt;/title&gt;&#13;
&lt;/head&gt;&#13;
&lt;body&gt;&#13;
&lt;?php&#13;
require_once '_nav.php'&#13;
?&gt;&#13;
&#13;
&lt;h1&gt;about page&lt;/h1&gt;&#13;
&lt;p&gt;&#13;
    welcome to about page&#13;
&#13;
    &lt;br&gt;&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> your ID = &lt;?= $id ?&gt;&#13;
&lt;/p&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-11: The</span> <span class="SANS_Futura_Std_Book_11">aboutUs.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">template</span></p>
<p class="TX"><span aria-label="514" epub:type="pagebreak" id="pg_514" role="doc-pagebreak"/>As for the home page, we draw on the partial <i>_nav.php</i> template to simplify the file at hand. Then we incorporate the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> variable into the body of the page <span aria-label="annotation1" class="CodeAnnotation">❶</span>. <a href="#fig26-7">Figure 26-7</a> shows the resulting web page.</p>
<figure class="IMG"><a id="fig26-7"/><img alt="" class="img70" height="600" src="../images/figure26-7.jpg" width="742"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-7: The About page, including the cached ID value</span></p></figcaption>
</figure>
<p class="TX">Notice that the value of the URL-encoded <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> variable has been printed to the page. This indicates that the ID was successfully cached by the <span class="SANS_TheSansMonoCd_W5Regular_11">run()</span> method in the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> class, then retrieved by the <span class="SANS_TheSansMonoCd_W5Regular_11">aboutUs()</span> method of the <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> class, and finally printed by the <i>aboutUs.php</i> template.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="toc-link_344"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Caching Approach 2: Using a JSON File</span></h4>
<p class="TNI1">Suppose we later decide to add a second caching approach that caches data in a JSON file. This JSON approach would, for example, make it much easier to log different states of the cache at different times to a logging API that accepts JSON data. Let’s declare a new caching class named <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> to implement this other approach. Create <i>src/CacheJson.php</i> containing the code in <a href="#lis26-12">Listing 26-12</a>.</p>
<span id="lis26-12"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
class CacheJson&#13;
{&#13;
    private const CACHE_PATH = __DIR__ . '/../var/cache.json';&#13;
&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> public function set(string $key, string $value): void&#13;
    {&#13;
        $dataItems = $this-&gt;readJson();&#13;
        $dataItems[$key] = $value;&#13;
        $this-&gt;writeJson($dataItems);&#13;
    }&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> public function get(string $key): ?string&#13;
    {&#13;
        $dataItems = $this-&gt;readJson();&#13;
<span aria-label="515" epub:type="pagebreak" id="pg_515" role="doc-pagebreak"/>        if ($this-&gt;has($key)) {&#13;
            return $dataItems[$key];&#13;
        }&#13;
&#13;
        return NULL;&#13;
    }&#13;
&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> public function has(string $key): bool&#13;
    {&#13;
        $dataItems = $this-&gt;readJson();&#13;
        return array_key_exists($key, $dataItems);&#13;
    }&#13;
&#13;
    private function readJson(): array&#13;
    {&#13;
        $jsonString = file_get_contents(self::CACHE_PATH);&#13;
        if (!$jsonString) {&#13;
            return [];&#13;
        }&#13;
&#13;
        $dataItems = json_decode($jsonString, true);&#13;
        return $dataItems;&#13;
    }&#13;
&#13;
    private function writeJson(array $dataItems): bool&#13;
    {&#13;
        $jsonString = json_encode($dataItems);&#13;
        return file_put_contents(self::CACHE_PATH, $jsonString);&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-12: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">CacheJson</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">Within <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span>, we declare public <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> <span aria-label="annotation3" class="CodeAnnotation">❸</span> methods. Outwardly, they’re similar to those in our <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> class, except they’re instance methods, belonging to each object of the class, rather than static methods belonging to the class as a whole. Internally, however, the method definitions are different from those of <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span>: they read and write information to a JSON file by using the private <span class="SANS_TheSansMonoCd_W5Regular_11">readJson()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">writeJson()</span> methods, which in turn use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">file_get_contents()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file_put_contents()</span> functions introduced in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>
<p class="TX">These details are hidden from the rest of the application, though, so the impact of these changes on our code is minimal. For example, <a href="#lis26-13">Listing 26-13</a> shows the only changes we need to make to the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> class.</p>
<span id="lis26-13"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
class Application&#13;
{&#13;
    public function run()&#13;
    {&#13;
        $action = filter_input(INPUT_GET, 'action');&#13;
        $id = filter_input(INPUT_GET, 'id');&#13;
<span aria-label="516" epub:type="pagebreak" id="pg_516" role="doc-pagebreak"/>        if (empty($id)) {&#13;
            $id = "(no id provided)";&#13;
        }&#13;
&#13;
<b>        </b>$cache = new CacheJson();&#13;
        $cache-&gt;set('id', $id);&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">    --snip--</span>&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-13: Updating the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Application</span> <span class="SANS_Futura_Std_Book_Oblique_11">class to use a</span> <span class="TheSansMonoCd_W5Regular_Italic_11">CacheJson</span> <span class="SANS_Futura_Std_Book_Oblique_11">object</span></p>
<p class="TX">We replace <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic::set('id', $id)</span> with two statements that create a <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> object and invoke its <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span> method. The <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> class requires a similar small tweak, shown in <a href="#lis26-14">Listing 26-14</a>.</p>
<span id="lis26-14"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">namespace Mattsmithdev;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class MainController</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function homepage()</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        require_once __DIR__ . '/../templates/homepage.php';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function aboutUs()</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
      <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span><b> </b>$cache = new CacheJson();&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $id = $cache-&gt;get('id');</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        require_once __DIR__ . '/../templates/aboutUs.php';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-14: Updating the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">MainController</span> <span class="SANS_Futura_Std_Book_Oblique_11">class to use a</span> <span class="TheSansMonoCd_W5Regular_Italic_11">CacheJson</span> <span class="SANS_Futura_Std_Book_Oblique_11">object</span></p>
<p class="TX">Instead of the <span class="SANS_TheSansMonoCd_W5Regular_11">$id = CacheStatic::get('id')</span> statement, we create a <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> object and invoke its <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span> method to retrieve the value cached under the '<span class="SANS_TheSansMonoCd_W5Regular_11">id'</span> key <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If you now test the application again, it should work just as it did before. The only difference is that the ID is being cached to a JSON file instead of an array.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="toc-link_345"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Caching Approach 3: Creating a Cacheable Interface</span></h4>
<p class="TNI1">We’ve already used two methods of caching for our application, and in the future we might want to use still others. This situation lends itself to abstracting the caching classes’ common operations as an interface, then writing classes that implement the interface. This way, as long as our code can create an object of any class that implements the interface, we know we’ll be able to use that class’s <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> methods without having to worry about which class the caching object is an instance of or how the class is doing the work.</p>
<p class="TX"><span aria-label="517" epub:type="pagebreak" id="pg_517" role="doc-pagebreak"/>To make this change, we’ll first declare a generic <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface. In addition to the <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> methods, we’ll also stipulate a fourth method, <span class="SANS_TheSansMonoCd_W5Regular_11">reset()</span>, that completely empties the cache of any stored values. Create <i>src/Cacheable.php</i> and enter the contents of <a href="#lis26-15">Listing 26-15</a>.</p>
<span id="lis26-15"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
interface Cacheable&#13;
{&#13;
    public function reset(): void;&#13;
    public function set(string $key, string $value): void;&#13;
    public function get(string $key): ?string;&#13;
    public function has(string $key): bool;&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-15: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Cacheable</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface with the signatures for the four methods that any class implementing the interface must have. These methods are all public instance methods, with appropriate typed arguments and return types. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span> takes in strings for the desired key and value being cached and returns <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>, while <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span> takes in a string key and returns a string or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>.</p>
<p class="TX">When we switched from using <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span>, we had to make some updates to the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> classes. We’ll now refactor those classes so that we can switch implementations of the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface without having to change anything. We’ll start with the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> class. <a href="#lis26-16">Listing 26-16</a> shows the updates to <i>src/Application.php</i>.</p>
<span id="lis26-16"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">namespace Mattsmithdev;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class Application</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> private Cacheable $cache;&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> public function __construct(Cacheable $cache)&#13;
    {&#13;
        $this-&gt;cache = $cache;&#13;
        $this-&gt;cache-&gt;reset();&#13;
    }&#13;
&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> public function getCache(): Cacheable&#13;
    {&#13;
        return $this-&gt;cache;&#13;
    }&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function run()</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $action = filter_input(INPUT_GET, 'action');</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $id = filter_input(INPUT_GET, 'id');</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        if (empty($id)) {</span>&#13;
<span aria-label="518" epub:type="pagebreak" id="pg_518" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">            $id = "(no id provided)";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        }</span>&#13;
&#13;
      <span aria-label="annotation4" class="Code_CodeAnnotation">❹</span> $this-&gt;cache-&gt;set('id', $id);&#13;
&#13;
      <span aria-label="annotation5" class="Code_CodeAnnotation">❺</span> <span class="TheSansMonoCd_W5Regular_Grey_11">$mainController = new MainController(</span>$this<span class="TheSansMonoCd_W5Regular_Grey_11">);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        switch ($action) {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">            case 'about':</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">                $mainController-&gt;aboutUs();</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">                break;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">            default:</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">                $mainController-&gt;homepage();</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        }</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-16: Refactoring the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Application</span> <span class="SANS_Futura_Std_Book_Oblique_11">class to use the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Cacheable</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface</span></p>
<p class="TX">We first add a private <span class="SANS_TheSansMonoCd_W5Regular_11">cache</span> property to the class, whose value is a reference to a <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> object <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This is a powerful feature of interfaces: we can provide an interface name as a data type for a variable, method parameter, or method return value, and any object from any class that implements the interface will work fine.</p>
<p class="TX">We next obtain a <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> object reference for this property as an argument passed to the constructor method <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Whatever object is passed as an argument when an <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> object is created must therefore be of a class that implements the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface. The constructor invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">reset()</span> method of the provided <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> object, so we know we’ll have an empty cache when we start processing the current HTTP request. Because the cache property is private, we declare a public getter method so that it can be accessed outside the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> class <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>
<p class="TX">Notice that all these new statements so far have been written in such a way that the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> class doesn’t need to know which implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface is referenced by the argument provided to the class’s constructor. You’ll see later how the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> object is created in the index script, so this is the only place where the code needs to change if we choose to use a different <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> implementation.</p>
<p class="TX">Inside <span class="SANS_TheSansMonoCd_W5Regular_11">run()</span>, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> object’s expected <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span> method to store the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> variable in the cache <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Then, when we create a <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> object, we provide <span class="SANS_TheSansMonoCd_W5Regular_11">$this</span> as an argument <span aria-label="annotation5" class="CodeAnnotation">❺</span>, meaning that the <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> object will have a reference back to this <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> object. By extension, the <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> object will also have access to the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> object through the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">cache</span> property.</p>
<p class="TX">Now let’s update the <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> class. <a href="#lis26-17">Listing 26-17</a> shows the revised <i>src/MainController.php</i> file.</p>
<span id="lis26-17"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">namespace Mattsmithdev;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class MainController</span>&#13;
<span aria-label="519" epub:type="pagebreak" id="pg_519" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> private Application $application;&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> public function __construct(Application $application)&#13;
    {&#13;
        $this-&gt;application = $application;&#13;
    }&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function homepage()</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        require_once __DIR__ . '/../templates/homepage.php';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function aboutUs()</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
      <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> $cache = $this-&gt;application-&gt;getCache();&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $id = $cache-&gt;get('id');</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        require_once __DIR__ . '/../templates/aboutUs.php';</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-17: Refactoring the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">MainController</span> <span class="SANS_Futura_Std_Book_Oblique_11">class to use the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Cacheable</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface</span></p>
<p class="TX">We declare a private <span class="SANS_TheSansMonoCd_W5Regular_11">application</span> property <span aria-label="annotation1" class="CodeAnnotation">❶</span> whose value is the reference to the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> object passed as an argument to the constructor method <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Then, in the <span class="SANS_TheSansMonoCd_W5Regular_11">aboutUs()</span> method, we use the public <span class="SANS_TheSansMonoCd_W5Regular_11">getCache()</span> method of the <span class="SANS_TheSansMonoCd_W5Regular_11">application</span> object to obtain a reference to the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> object <span aria-label="annotation3" class="CodeAnnotation">❸</span>. This way, we can call the <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span> method as before to retrieve the stored ID from the cache for use within the page template.</p>
<p class="TX">Next, we need to update the <i>public/index.php</i> script to create a caching object and pass it to the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> object when the latter is created. As mentioned earlier, this is the only part of the code that needs to know which implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface we want to use. Update the index script as shown in <a href="#lis26-18">Listing 26-18</a>.</p>
<span id="lis26-18"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/../vendor/autoload.php';&#13;
&#13;
use Mattsmithdev\Application;&#13;
use Mattsmithdev\CacheJson;&#13;
use Mattsmithdev\CacheStatic;&#13;
&#13;
$cache1 = new CacheJson();&#13;
$cache2 = new CacheStatic();&#13;
&#13;
app = new Application($cache2);&#13;
$app-&gt;run();</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-18: Choosing a</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Cacheable</span> <span class="SANS_Futura_Std_Book_Oblique_11">implementation in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">We create two objects: <span class="SANS_TheSansMonoCd_W5Regular_11">$cache1</span> is a <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> object, and <span class="SANS_TheSansMonoCd_W5Regular_11">$cache2</span> is a <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> object. Then we pass one of these variables when we construct <span aria-label="520" epub:type="pagebreak" id="pg_520" role="doc-pagebreak"/>the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> object. Try the code with both variables, and it should work the same way each time.</p>
<p class="TX">The final step is to revise our cache classes to implement the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface. <a href="#lis26-19">Listing 26-19</a> shows the updated <span class="SANS_TheSansMonoCd_W5Regular_11">CacheStatic</span> class. To meet the contractual obligations of the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface, we need to make <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> instance (rather than static) methods, and we also must add a public <span class="SANS_TheSansMonoCd_W5Regular_11">reset()</span> instance method. Update <i>src/CacheStatic.php</i> as shown in the listing.</p>
<span id="lis26-19"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">namespace Mattsmithdev;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class CacheStatic</span> implements Cacheable&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private static array $dataItems = [];</span>&#13;
&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> public function reset(): void&#13;
    {&#13;
        self::$dataItems = [];&#13;
    }&#13;
&#13;
    public function <span class="TheSansMonoCd_W5Regular_Grey_11">set(string $key, string $value): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        self::$dataItems[$key] = $value;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
    public <span class="TheSansMonoCd_W5Regular_Grey_11">function get(string $key): ?string</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        if (self::has($key)) {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">            return self::$dataItems[$key];</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return NULL;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
    public function <span class="TheSansMonoCd_W5Regular_Grey_11">has(string $key): bool</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return array_key_exists($key, self::$dataItems);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-19: Revising</span> <span class="TheSansMonoCd_W5Regular_Italic_11">CacheStatic</span> <span class="SANS_Futura_Std_Book_Oblique_11">to implement the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Cacheable</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface</span></p>
<p class="TX">We declare that the class implements the <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface, then provide an implementation for the requisite <span class="SANS_TheSansMonoCd_W5Regular_11">reset()</span> method that sets <span class="SANS_TheSansMonoCd_W5Regular_11">$dataItems</span> to an empty array <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> implementations are the same as before, except we’ve changed them all from static to instance methods. The <span class="SANS_TheSansMonoCd_W5Regular_11">$dataItems</span> array itself remains a static member.</p>
<p class="TX">Listing 26-20 shows the modified <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> class in <i>src/CacheJson.php</i>.</p>
<span id="lis26-20"/>
<pre><code><span aria-label="521" epub:type="pagebreak" id="pg_521" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">namespace Mattsmithdev;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class CacheJson</span> implements Cacheable&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private const CACHE_PATH = __DIR__ . '/../var/cache.json';</span>&#13;
&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> public function reset(): void&#13;
    {&#13;
        $directory = dirname(self::CACHE_PATH);&#13;
        $this-&gt;makeDirIfNotExists($directory);&#13;
        $this-&gt;makeEmptyFile(self::CACHE_PATH);&#13;
    }&#13;
&#13;
    private function makeDirIfNotExists(string $directory): bool&#13;
    {&#13;
        return is_dir($directory) || mkdir($directory);&#13;
    }&#13;
&#13;
    private function makeEmptyFile(string $path): bool&#13;
    {&#13;
        return file_put_contents($path, '');&#13;
    }&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function set(string $key, string $value): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-20: Our refactored</span> <span class="TheSansMonoCd_W5Regular_Italic_11">CacheJson</span> <span class="SANS_Futura_Std_Book_Oblique_11">class, implementing the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Cacheable</span> <span class="SANS_Futura_Std_Book_Oblique_11">interface</span></p>
<p class="TX">Again, we have to provide an implementation for the <span class="SANS_TheSansMonoCd_W5Regular_11">reset()</span> method <span aria-label="annotation1" class="CodeAnnotation">❶</span>. It uses the private <span class="SANS_TheSansMonoCd_W5Regular_11">makeDirIfNotExists()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">makeEmptyFile()</span> methods (declared next in the listing) to ensure that an empty file and directory exist after <span class="SANS_TheSansMonoCd_W5Regular_11">reset()</span> is invoked. The remainder of the code, including the <span class="SANS_TheSansMonoCd_W5Regular_11">set()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">get()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">has()</span> methods, is the same as it was in <a href="#lis26-12">Listing 26-12</a>.</p>
<p class="TX">As this example has illustrated, declaring a useful feature like caching as an interface means you can create different implementations of that feature while writing most of your code (in this case, the <span class="SANS_TheSansMonoCd_W5Regular_11">Application</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">MainController</span> classes) in a general way. This enables you to switch implementations of the interface, or create new ones later, without having to update all your code because of hardcoded references to the old way of doing things. All that has to change is the code that actually instantiates the class implementing the interface. We’ve conveniently located that code in the index script, where it can easily be updated without breaking the application.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="toc-link_346"/><span class="SANS_Futura_Std_Bold_B_11">Traits</span></h3>
<p class="TNI1">A <i>trait</i> is a way to provide default versions of methods that are shared among multiple, unrelated classes. This feature offers not just the method signatures, as with an interface or abstract method, but actual method implementations. When a class uses a trait, it’s called <i>insertion</i>, since the trait is <span aria-label="522" epub:type="pagebreak" id="pg_522" role="doc-pagebreak"/>essentially inserting a method into the class without the class having to define the method itself. That said, a trait can be inserted onto a class and then be overridden by the class’s own method implementations if necessary. This is useful when most, but not all, classes inserting a trait can use the same method implementation.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>In some other programming languages, traits are known as</i> <span class="note">mixins</span><i>, after the extra ingredients such as nuts or candy that can be mixed into ice cream.</i></p>
<p class="TX">Traits are a way of permitting code reuse across class hierarchies without resorting to multiple inheritance, a sort of copy-and-paste feature for methods that allows the methods to still be overridden if needed. This is helpful, for example, if you have several classes implementing the same interface, all with identical versions of some of the methods the interface calls for. In this case, a lot of code would be duplicated across the classes, a violation of the DRY principle. Declaring those methods as a trait would allow you to write the code once and then add it to all the relevant classes by telling them to use the trait.</p>
<p class="TX">More broadly, traits may come into play when classes in multiple class hierarchies need to perform common actions. For example, several classes may need the behaviors of <span class="SANS_TheSansMonoCd_W5Regular_11">makeDirIfNotExists()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">makeEmptyFile()</span>, methods we declared earlier as part of the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> class. One solution could be to make these methods public members of some kind of utility class (say, <span class="SANS_TheSansMonoCd_W5Regular_11">FileUtilities</span>), so each class needing that functionality could create a <span class="SANS_TheSansMonoCd_W5Regular_11">FileUtilities</span> object and invoke the methods; or we could declare the methods as public static members of the utility class to avoid having to create an object at all.</p>
<p class="TX">However, the application might change over time, and some of the classes may need specialized variations of the main method implementations. As such, instead of relegating the methods to a utility class, we can declare them as a trait. The methods will then be available for any class to use, but each class can replace them with custom implementations if required, without affecting any other part of the codebase.</p>
<p class="TX">Ultimately, traits and utility classes are similar concepts, in that both can provide the same fully implemented methods to classes from different class hierarchies. Traits are a little more sophisticated and flexible than utility classes, however, since they can be overridden if needed. A class’s reliance on a trait may be more obvious than its reliance on a utility class, since the trait must be referenced with a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement, whereas utility class method calls might be hidden within the implementation of a method; in this way, traits make code dependencies more transparent. On the other hand, traits can be harder to test directly since their methods are often private or protected, whereas utility class methods are typically public.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="toc-link_347"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Declaring Traits</span></h4>
<p class="TNI1">You declare a trait much like a class, but with the <span class="SANS_TheSansMonoCd_W5Regular_11">trait</span> rather than the <span class="SANS_TheSansMonoCd_W5Regular_11">class</span> keyword. To see how it works, let’s move the declarations of the <span aria-label="523" epub:type="pagebreak" id="pg_523" role="doc-pagebreak"/><span class="SANS_TheSansMonoCd_W5Regular_11">makeDirIfNotExists()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">makeEmptyFiles()</span> methods from the class to a <span class="SANS_TheSansMonoCd_W5Regular_11">FileSystemTrait</span> trait. Continuing the project from the previous section, create a new <i>src/FileSystemTrait.php</i> file and copy over the two method definitions, as shown in <a href="#lis26-21">Listing 26-21</a>.</p>
<span id="lis26-21"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
trait FileSystemTrait&#13;
{&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private function makeDirIfNotExists(string $directory): bool</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return is_dir($directory) || mkdir($directory);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private function makeEmptyFile(string $path): bool</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return file_put_contents($path, '');</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-21: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">FileSystemTrait</span> <span class="SANS_Futura_Std_Book_Oblique_11">trait</span></p>
<p class="TX">We use the <span class="SANS_TheSansMonoCd_W5Regular_11">trait</span> keyword to declare <span class="SANS_TheSansMonoCd_W5Regular_11">FileSystemTrait</span> as a trait. It contains method declarations for <span class="SANS_TheSansMonoCd_W5Regular_11">makeDirIfNotExists()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">makeEmptyFile()</span>. The implementation of these two methods is exactly as it was when they were in the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> class.</p>
<p class="TX">While we’re at it, let’s extract the two JSON file methods from the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> class, <span class="SANS_TheSansMonoCd_W5Regular_11">readJson()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">writeJson()</span>, and declare them as a second trait, <span class="SANS_TheSansMonoCd_W5Regular_11">JsonFileTrait</span>, since these methods also define functionality that several classes might need. Copy the method definitions into a new <i>src/JsonFileTrait.php</i> file and update them as shown in <a href="#lis26-22">Listing 26-22</a>.</p>
<span id="lis26-22"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
trait JsonFileTrait&#13;
{&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private function readJson(</span>string $path<span class="TheSansMonoCd_W5Regular_Grey_11">): array</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $jsonString = file_get_contents(</span>$path<span class="TheSansMonoCd_W5Regular_Grey_11">);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        if (!$jsonString) {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">            return [];</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $dataItems = json_decode($jsonString, true);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return $dataItems;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private function writeJson(</span>string $path, <span class="TheSansMonoCd_W5Regular_Grey_11">array $dataItems): bool</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $jsonString = json_encode($dataItems);</span>&#13;
<span aria-label="524" epub:type="pagebreak" id="pg_524" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">        return file_put_contents(</span>$path<span class="TheSansMonoCd_W5Regular_Grey_11">, $jsonString);</span>&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-22: The</span> <span class="TheSansMonoCd_W5Regular_Italic_11">JsonFileTrait</span> <span class="SANS_Futura_Std_Book_Oblique_11">trait</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">JsonFileTrait</span> trait with two methods, <span class="SANS_TheSansMonoCd_W5Regular_11">readJson()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">writeJson()</span>. Once again the method implementations are virtually identical to the original methods on the <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> class, but this time we use a string <span class="SANS_TheSansMonoCd_W5Regular_11">$path</span> parameter to indicate the JSON file that needs to be read or written to instead of a hardcoded class constant. This makes the methods more generally applicable.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="toc-link_348"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Inserting Traits</span></h4>
<p class="TNI1">Now let’s look at how to insert traits onto a class by refactoring <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> to use our two traits. <a href="#lis26-23">Listing 26-23</a> shows the modified <i>src/CacheJson.php</i> file.</p>
<span id="lis26-23"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">namespace Mattsmithdev;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class CacheJson implements Cacheable</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> use FileSystemTrait, JsonFileTrait;&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private const CACHE_PATH = __DIR__ . '/../var/cache.json';</span>&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> <span class="TheSansMonoCd_W5Regular_Grey_11">public function reset(): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $directory = dirname(self::CACHE_PATH);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;makeDirIfNotExists($directory);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;makeEmptyFile(self::CACHE_PATH);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function set(string $key, string $value): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $dataItems = $this-&gt;readJson(</span>self::CACHE_PATH);&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $dataItems[$key] = $value;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;writeJson(</span>self::CACHE_PATH<span class="TheSansMonoCd_W5Regular_Grey_11">, $dataItems);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function get(string $key): ?string</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $dataItems = $this-&gt;readJson(</span>self::CACHE_PATH<span class="TheSansMonoCd_W5Regular_Grey_11">);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        if($this-&gt;has($key)){</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">            return $dataItems[$key];</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return NULL;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span aria-label="525" epub:type="pagebreak" id="pg_525" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">    public function has(string $key): bool</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $dataItems = $this-&gt;readJson(</span>self::CACHE_PATH);&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return array_key_exists($key, $dataItems);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 26-23: Updating the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">CacheJson</span> <span class="SANS_Futura_Std_Book_Oblique_11">class to use traits</span></p>
<p class="TX">We start with a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement containing a comma-separated list of the traits to insert onto the class <span aria-label="annotation1" class="CodeAnnotation">❶</span>. In the <span class="SANS_TheSansMonoCd_W5Regular_11">reset()</span> method <span aria-label="annotation2" class="CodeAnnotation">❷</span>, notice how we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">makeDirIfNotExists()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">makeEmptyFile()</span> methods, which now come from the trait, just as we did before. We don’t need to mention the trait when using these methods; we simply call the methods by name, as usual. Similarly, we’re able to use the <span class="SANS_TheSansMonoCd_W5Regular_11">readJson()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">writeJson()</span> methods as before, but now we pass the <span class="SANS_TheSansMonoCd_W5Regular_11">CACHE_PATH</span> constant as an argument.</p>
<p class="TX">We now have a much simpler <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> class. The commonly used methods for filesystem and JSON file operations have been refactored as traits, which keeps <span class="SANS_TheSansMonoCd_W5Regular_11">CacheJson</span> itself focused on tasks related to caching. Meanwhile, the methods on the traits are also available for any other class to use.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="toc-link_349"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Resolving Trait Conflicts</span></h4>
<p class="TNI1">If a class uses two or more traits, the same member could be declared in multiple traits. This potential problem is similar to issues that occur in languages that allow multiple inheritance. In such cases, you’ll get a fatal error if you try to call that method, since the PHP engine won’t know which implementation to invoke.</p>
<p class="TX">To resolve the ambiguity and avoid the error, use the <span class="SANS_TheSansMonoCd_W5Regular_11">insteadof</span> keyword to specify which version of the method you want to use. Here’s an example:</p>
<pre><code>use TraitA, TraitB {&#13;
    TraitA::printHello insteadof TraitB;</code></pre>
<p class="BodyContinued">This code snippet specifies that if <span class="SANS_TheSansMonoCd_W5Regular_11">printHello()</span> is declared in both <span class="SANS_TheSansMonoCd_W5Regular_11">TraitA</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">TraitB</span>, it’s the <span class="SANS_TheSansMonoCd_W5Regular_11">TraitA</span> implementation that should be inserted into the class.</p>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H1" id="sec17"><span id="toc-link_350"/><span class="SANS_Futura_Std_Bold_B_11">What to Use When?</span></h3>
<p class="TNI1">The various strategies we’ve discussed in this chapter have considerable overlap. Deciding which to use in a given situation may be a matter of personal preference or the preference of a larger team. That said, <a href="#fig26-8">Figure 26-8</a> offers some guidance by summarizing the similarities and differences between the approaches we’ve discussed.</p>
<span aria-label="526" epub:type="pagebreak" id="pg_526" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig26-8"/><img alt="" class="img100" height="798" src="../images/figure26-8.jpg" width="1587"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 26-8: Comparing strategies for code reuse and class interchangeability</span></p></figcaption>
</figure>
<p class="TX">For basic class hierarchies, much can be achieved with simple inheritance, allowing subclasses to inherit fully implemented methods from concrete <span aria-label="annotation3" class="CodeAnnotation">❸</span> or abstract <span aria-label="annotation4" class="CodeAnnotation">❹</span> superclasses. If many subclasses will require custom implementations of the inherited methods, you might declare them on the superclass as abstract methods instead <span aria-label="annotation5" class="CodeAnnotation">❺</span>. This way, only the methods’ signatures will be specified, with the implementation details left up to the subclasses. Interfaces are another way to declare just the signatures of methods, but in this case the methods can be shared across class hierarchies <span aria-label="annotation6" class="CodeAnnotation">❻</span>.</p>
<p class="TX">Taken together, inheritance, abstract methods, and interfaces promote class interchangeability while also loosening the dependencies among the components in a software system. This greatly facilitates cooperative software development. By standardizing method signatures while allowing for flexibility in method implementation, interfaces in particular can be a contract between software components as well as a contract between cooperating developers, each with responsibilities for coding different parts of the system. The whole team can be confident that the system will behave as expected as long as the interface requirements are adhered to. This approach to software design is sometimes referred to as <i>loose coupling</i>: the number and form of breakable dependencies among software components are reduced, so changes in any one component are much less likely to affect performance or require refactoring of other components.</p>
<p class="TX">Meanwhile, if your goal is to reduce code duplication, you can use traits to offer sets of default method implementations that can be explicitly inserted into classes from different hierarchies <span aria-label="annotation2" class="CodeAnnotation">❷</span>. For small systems, utility classes, perhaps with public static methods, can be another way to offer the same functionality to different parts of the system <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Traits provide more flexibility (for example, a class that inserts a trait may still override a <span aria-label="527" epub:type="pagebreak" id="pg_527" role="doc-pagebreak"/>method from that trait with its own custom implementation), but the public methods on utility classes are more readily exposed for thorough testing.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="toc-link_351"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">In this chapter, we looked at several strategies for sharing methods among classes, both within and outside the confines of class hierarchies. You saw how abstract methods and interfaces enforce method signatures without providing implementations. The rest of the application can safely call the relevant methods, regardless of the implementation, since the signatures are guaranteed to always be the same. You saw this at work when we created a <span class="SANS_TheSansMonoCd_W5Regular_11">Cacheable</span> interface that allowed us to switch approaches to caching (using a static array versus an external JSON file) with virtually no impact on the rest of the application code.</p>
<p class="TX">You also saw how to use traits to insert fully implemented methods onto unrelated classes, while still having the flexibility to override those methods if necessary. We harnessed traits to make general-purpose filesystem and JSON-handling methods available for any class in our caching project to use. This promoted code reusability and allowed us to declare simpler, more narrowly focused classes.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H1" id="sec19"><span id="toc-link_352"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Declare a <span class="SANS_TheSansMonoCd_W5Regular_11">Book</span> class that has the following members:</p>
<p class="ListPlainSub">A private string <span class="SANS_TheSansMonoCd_W5Regular_11">title</span> property with get and set methods</p>
<p class="ListPlainSub">A private float <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property with get and set methods</p>
<p class="ListPlainSub">A public <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingSalesTax()</span> method that returns a float, calculated as <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> plus 5 percent sales tax</p>
<p class="ListContinued">Write a main script that creates a <span class="SANS_TheSansMonoCd_W5Regular_11">Book</span> object and prints its price with and without sales tax, like so:</p>
<pre><code>Book "Life of Pi"&#13;
  price (excl. tax) = $20.00&#13;
  price (incl. tax) = $21.00</code></pre>
<p class="ListNumber">2.   Refactor your project for Exercise 1 to declare an interface named <span class="SANS_TheSansMonoCd_W5Regular_11">SalesTaxable</span> requiring classes to implement a <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingSalesTax()</span> method that returns a float. The <span class="SANS_TheSansMonoCd_W5Regular_11">Book</span> class should implement the <span class="SANS_TheSansMonoCd_W5Regular_11">SalesTaxable</span> interface.</p>
<p class="ListBody">Next, declare a <span class="SANS_TheSansMonoCd_W5Regular_11">Donut</span> class that also implements the <span class="SANS_TheSansMonoCd_W5Regular_11">SalesTaxable</span> interface and has these members:</p>
<p class="ListPlainSub">A private string <span class="SANS_TheSansMonoCd_W5Regular_11">topping</span> property with get and set methods</p>
<p class="ListPlainSub">A private float <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property with get and set methods</p>
<p class="ListPlainSub">A public <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingSalesTax()</span> method implementing the <span class="SANS_TheSansMonoCd_W5Regular_11">SalesTaxable</span> interface and returning <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> plus 7 percent sales tax</p>
<p class="ListBody"><span aria-label="528" epub:type="pagebreak" id="pg_528" role="doc-pagebreak"/>Finally, write a main script that creates the following two objects and prints their price with and without sales tax:</p>
<pre><code>Book "Life of Pi"&#13;
  price (excl. tax) = $20.00&#13;
  price (incl. tax) = $21.00&#13;
&#13;
<span class="SANS_TheSansMonoCd_W5Regular_11">Donut "strawberry icing"</span>&#13;
  price (excl. tax) = $10.00&#13;
  price (incl. tax) = $10.70</code></pre>
<p class="ListNumber">3.   Write a <span class="SANS_TheSansMonoCd_W5Regular_11">TaxFunctions</span> utility class that declares a public static <span class="SANS_TheSansMonoCd_W5Regular_11">addTaxToPrice()</span> method that takes in a float price and float tax rate and returns the value of the price with the tax added. Refactor the implementations of the <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingSalesTax()</span> methods in the <span class="SANS_TheSansMonoCd_W5Regular_11">Book</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Donut</span> classes to use this utility class method, to avoid code duplication.</p>
<p class="ListNumber">4.   Change your <span class="SANS_TheSansMonoCd_W5Regular_11">TaxFunctions</span> utility class to a trait, declaring a (nonstatic) <span class="SANS_TheSansMonoCd_W5Regular_11">addTaxToPrice()</span> method. Refactor the <span class="SANS_TheSansMonoCd_W5Regular_11">Book</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Donut</span> classes to insert the trait and use its <span class="SANS_TheSansMonoCd_W5Regular_11">addTaxToPrice()</span> method in their implementations of <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingSalesTax()</span>.</p>
<p class="ListNumber">5.   Refactor your project as a class hierarchy, with an abstract <span class="SANS_TheSansMonoCd_W5Regular_11">SellableItem</span> superclass that declares a fully implemented <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingSalesTax()</span> method with protected visibility. Make <span class="SANS_TheSansMonoCd_W5Regular_11">Book</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Donut</span> subclasses of <span class="SANS_TheSansMonoCd_W5Regular_11">SellableItem</span>, and delete the interface and trait files; they aren’t needed in this design. Sometimes, for a simple situation, the simplest solution is the most appropriate.</p>
</section>
</section>
</div></body></html>