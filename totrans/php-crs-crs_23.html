<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch18" epub:type="chapter" role="doc-chapter">
<span aria-label="337" epub:type="pagebreak" id="pg_337" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch18">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">18</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">DECLARING CLASSES AND CREATING OBJECTS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">In this chapter, you’ll learn how to define the structure of a class by using a class-declaration file, and you’ll practice creating individual objects of that class. You’ll see that classes with public properties let you directly change an object’s data, while classes with private properties mean you can change an object’s data only via its methods, some of which can perform validation. You’ll also learn about PHP “magic” methods that make it easier to write object-oriented code.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="toc-link_253"/><span class="SANS_Futura_Std_Bold_B_11">Declaring a Class</span></h3>
<p class="TNI1">A <i>class declaration</i> defines a class: it lays out the properties (variables) each object of that class will have, as well as the methods (functions) that can act <span aria-label="338" epub:type="pagebreak" id="pg_338" role="doc-pagebreak"/>upon those properties. A class declaration also establishes any relationship that class has with other classes (such as inheritance, which you’ll learn about in <span class="Xref"><a href="chapter19.xhtml">Chapter 19</a></span>).</p>
<p class="TX">Like function declarations, class declarations are stored in PHP files in the <i>src</i> directory of a project. For all the projects in this book, each class will be declared in its own file; if a project has five classes, it will have five class-declaration files, and so on.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>In this book, we won’t explore the advanced topic of</i> <span class="note">anonymous classes</span><i>, which is one of the few cases where more than one class may be declared in a single file. You can learn more at</i> <span class="note_LinkURL"><a href="https://www.php.net/manual/en/language.oop5.anonymous.php">https://www.php.net/manual/en/language.oop5.anonymous.php</a></span><i>.</i></p>
<p class="TX">By a well-established convention in OOP, both class names and class-declaration filenames always start with a capital letter. If the name includes multiple words, each word should start with a capital letter, with no spaces between the words. This is known as <i>upper camel case</i>, or sometimes <i>Pascal case</i>. Examples of valid class names include <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">NetworkSupplier</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">DesktopComputer</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ReferenceBook</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">InventoryItem</span>.</p>
<p class="TX">Throughout this chapter, we’ll work with a class called <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> that can represent various items for sale through an e-commerce site. Let’s declare it now. Create a new directory for a new project, and in it create a <i>src</i> directory. In this <i>src</i> directory, create a <i>Product.php</i> file and enter the contents of <a href="#lis18-1">Listing 18-1</a>.</p>
<span id="lis18-1"/>
<pre><code>&lt;?php&#13;
class Product&#13;
{&#13;
    public string $name;&#13;
    public float $price;&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-1: The</span> <span class="SANS_Futura_Std_Book_11">Product.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">file to declare the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">We start with the standard PHP beginning code tag, since we use PHP code to declare classes. Then we use the <span class="SANS_TheSansMonoCd_W5Regular_11">class</span> keyword to state that we’re declaring a new class named <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span>. After the class name, enclosed in curly brackets, we define any properties or methods that will be associated with objects of that class. In this example, we declare two properties for each object of the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class: <span class="SANS_TheSansMonoCd_W5Regular_11">name</span>, which will be a string, and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span>, which will be a float. We declare both properties as <span class="SANS_TheSansMonoCd_W5Regular_11">public</span>, meaning any part of our program with access to a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object can read and change the values of its properties. We’ll explore the implications of public properties later in the chapter.</p>
<p class="TX">If we want all objects to have a <i>default value</i> for a property, we can assign a property a value in the class declaration. For example, if our system set an initial –1 price for every new <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object, we could have written <span class="SANS_TheSansMonoCd_W5Regular_11">public float $price = -1</span>.</p>
<p class="TX"><span aria-label="339" epub:type="pagebreak" id="pg_339" role="doc-pagebreak"/><a href="#fig18-1">Figure 18-1</a> shows a <i>Unified Modeling Language (UML)</i> class diagram visualizing the class we’ve just written. UML is a common tool for representing classes, objects, and their interactions through diagrams and text.</p>
<figure class="IMG"><a id="fig18-1"/><img alt="" class="img25" height="159" src="../images/figure18-1.jpg" width="281"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-1: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p></figcaption>
</figure>
<p class="TX">The top row of the diagram indicates the class name (<span class="SANS_TheSansMonoCd_W5Regular_11">Product</span>), and the second row lists the properties associated with that class, along with the data type expected for each property. The plus sign before each property name indicates that the properties have public visibility.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="toc-link_254"/><span class="SANS_Futura_Std_Bold_B_11">Creating an Object</span></h3>
<p class="TNI1">You use the PHP keyword <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> to create an object of a class. The <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword is followed by the name of the class for which an object is to be created, then a set of parentheses. Inside the parentheses, you may pass arguments for initialization, as we’ll discuss in <span class="Xref">“Initializing Values with a Constructor Method” on <a href="#pg_346">page 346</a></span>. The general form of a statement to create an object is thus <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ClassName</span><span class="SANS_TheSansMonoCd_W5Regular_11">()</span>. Creating an object is also called <i>instantiation</i>, since the object is an <i>instance</i> of the class.</p>
<p class="TX">By writing the <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword and a class name, you’re asking PHP to create a new object of the named class. When an object is created in the computer’s memory with the <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword, the PHP engine automatically returns a reference to the new object. In most cases, you’ll want to store the reference to that newly created object in a variable—for example, <span class="SANS_TheSansMonoCd_W5Regular_11">$myObject = new</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ClassName</span><span class="SANS_TheSansMonoCd_W5Regular_11">()</span>. It’s important to understand that with such statements, the variable <span class="SANS_TheSansMonoCd_W5Regular_11">$myObject</span> doesn’t actually contain the object itself, but rather a <i>reference to</i> the object. It’s possible for several variables, or none, to refer to a particular object in memory.</p>
<p class="TX">Once you have a reference to an object, use the <i>object operator</i> (<span class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</span>) to access properties and methods of that object. For example, you could write <span class="SANS_TheSansMonoCd_W5Regular_11">$myObject-&gt;description</span> to access the <span class="SANS_TheSansMonoCd_W5Regular_11">description</span> property of the object referred to by <span class="SANS_TheSansMonoCd_W5Regular_11">$myObject</span>. Likewise, you could invoke a <span class="SANS_TheSansMonoCd_W5Regular_11">setDescription()</span> method of an object by writing something like <span class="SANS_TheSansMonoCd_W5Regular_11">$myObject-&gt;setDescription('small carpet')</span>. The parentheses or lack thereof are important, since they tell the PHP engine (and people reading the code) whether a statement is attempting to access a property (no parentheses present) or a method (parentheses present).</p>
<p class="TX">With all this in mind, let’s create an object. We’ll write an <i>index.php</i> script to read in the <i>Product.php</i> class-declaration file, create a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object, and set the values of its properties. <a href="#fig18-2">Figure 18-2</a> shows our goal: a <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> variable that stores a reference to a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object whose properties have the values <span class="SANS_TheSansMonoCd_W5Regular_11">'hammer'</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">9.99</span>.</p>
<span aria-label="340" epub:type="pagebreak" id="pg_340" role="doc-pagebreak"/>
<figure class="IMG"><a id="fig18-2"/><img alt="" class="img25" height="151" src="../images/figure18-2.jpg" width="334"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-2: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$product1</span> <span class="SANS_Futura_Std_Book_Oblique_11">variable references an object of the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class.</span></p></figcaption>
</figure>
<p class="TX">For simplicity, we’ll start by creating a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object and setting only its <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property. To make sure our code is working, we’ll also print the value of the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property to the project’s home page. In your project directory, create a <i>public</i> folder, and in that folder create an <i>index.php</i> file containing the code in <a href="#lis18-2">Listing 18-2</a>.</p>
<span id="lis18-2"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/../src/Product.php';&#13;
&#13;
$product1 = new Product();&#13;
$product1-&gt;name = 'hammer';&#13;
&#13;
print 'product 1 name = ' . $product1-&gt;name;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-2: An</span> <span class="SANS_Futura_Std_Book_11">index.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script to create and manipulate a</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">object</span></p>
<p class="TX">We read in the declaration for the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class, using the <span class="SANS_TheSansMonoCd_W5Regular_11">__DIR__</span> magic constant to create a path from the location of this <i>index.php</i> file (in <i>public</i>) to the location of the <i>Product.php</i> file (in <i>src</i>). Then we use the <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword to create a new object of the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class. Since this class doesn’t require any initial values or options when creating objects, we don’t pass any arguments in the parentheses after the class name.</p>
<p class="TX">If you aren’t passing any arguments when you create a new object, PHP (unlike most object-oriented languages) allows you to omit the parentheses after the class name. Writing <span class="SANS_TheSansMonoCd_W5Regular_11">new Product()</span> is the same as writing <span class="SANS_TheSansMonoCd_W5Regular_11">new Product</span>. However, there are several good reasons to always include the parentheses, and so this is the style you’ll see throughout this book. Perhaps the most important reason to always use parentheses after the keyword <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> is to remind ourselves that a constructor method may be executed as the new object is created; we’ll look at such methods in <span class="note_Xref">“Initializing Values with a Constructor Method” on <a href="#pg_346">page 346</a></span>.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">new Product()</span> expression creates the new object and returns a reference to it, which we store in the <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> variable. To reiterate, <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> doesn’t contain the object itself, nor does it contain a copy of the object. It contains just a <i>reference to</i> the object created in the computer system’s memory. In <span class="Xref">“Object Variables as References” on <a href="#pg_351">page 351</a></span>, we’ll have two variables refer to the same object to help illustrate this concept.</p>
<p class="TX">Next, we set the value of the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property to the string <span class="SANS_TheSansMonoCd_W5Regular_11">'hammer'</span>; we can do this because the property was declared as <span class="SANS_TheSansMonoCd_W5Regular_11">public</span>. We use the object operator (<span class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</span>) after the <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> variable to refer to the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property of that object.</p>
<span aria-label="341" epub:type="pagebreak" id="pg_341" role="doc-pagebreak"/>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">WARNING</span></p>
</blockquote>
<p class="NOTE-TXT"><i>Do</i> <span class="note">not</span> <i>write a dollar sign after the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">-&gt;</span> <i>characters:</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$product-&gt;name</span> <i>is correct, and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$product-&gt;$name</span> <i>is wrong. The PHP engine won’t create a warning or error if you write the latter, but it will interpret the code as meaning there’s a variable called</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$name</span> <i>whose value is the name of a property you want to access on the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$product</span> <i>object. This is very different from accessing the value of the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">$product</span> <i>object’s</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <i>property. If your code is behaving strangely, check for this possible programming mistake.</i></p>
<p class="TX">Finally, the script ends by printing a message featuring the value retrieved from the <span class="SANS_TheSansMonoCd_W5Regular_11">$product</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property. If you run the web server and visit the project’s home page, you should see this line of text displayed:</p>
<pre><code>product 1 name = hammer</code></pre>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</span> operator lets you manipulate any of an object’s public properties by name. Let’s update our script to set and display the price of the object as well as its name. Modify the <i>index.php</i> file as shown in <a href="#lis18-3">Listing 18-3</a>.</p>
<span id="lis18-3"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../src/Product.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$product1 = new Product();</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$product1-&gt;name = 'hammer';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print 'product 1 name = ' . $product1-&gt;name;</span>&#13;
&#13;
$product1-&gt;price = 9.99;&#13;
print ", and price = {$product1-&gt;price}";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-3: Setting and displaying the product price in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">We set the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property to <span class="SANS_TheSansMonoCd_W5Regular_11">9.99</span> following the same format we used in <a href="#lis18-2">Listing 18-2</a> to set the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property. Then we display the value of the property. Notice that this time we use a double-quoted string to combine the message and property value. This illustrates that in double-quoted strings, a reference to a public property of an object, such as <span class="SANS_TheSansMonoCd_W5Regular_11">$product1-&gt;price</span>, will be parsed and the resulting value will be output, just as with a simple variable.</p>
<p class="TX">Visiting the home page again, you should see both the product name and price displayed:</p>
<pre><code>product 1 name = hammer, and price = 9.99</code></pre>
<p class="TX">We’ve now created an object of the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class, and since the class’s properties are public, we were able to set and retrieve the properties’ values directly. In practice, however, most classes are written with private rather than public properties.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H1" id="sec3"><span id="toc-link_255"/><span class="SANS_Futura_Std_Bold_B_11">Private Properties with Public Accessor Methods</span></h3>
<p class="TNI1">When properties are declared as <span class="SANS_TheSansMonoCd_W5Regular_11">private</span>, they can’t be accessed by code outside the class declaration itself. Instead, they’re available through public <span aria-label="342" epub:type="pagebreak" id="pg_342" role="doc-pagebreak"/><i>accessor methods</i>, functions that allow object property values to be retrieved (<i>getter methods</i>) or updated (<i>setter methods</i>). This mechanism of private properties with public accessor methods reduces the risk of invalid property values; when changes to a property must take place through a setter method, you can implement validation logic as part of the method (for example, preventing negative values or out-of-range values). Also, related properties or other objects might need to be updated together, such as the balance of one bank account being reduced by the same value that another account is increased. With setter methods and private properties, you can easily enforce such rules so that the data in the application stays correct and internally consistent.</p>
<p class="TX">The default visibility for class members is <span class="SANS_TheSansMonoCd_W5Regular_11">public</span>, so if no access modifier is provided for a property, the PHP engine will automatically declare it as having public visibility. Even with this default behavior, it’s still good practice to explicitly use the <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> access modifier in the class declaration when you want a class member to have public visibility. Otherwise, use the <span class="SANS_TheSansMonoCd_W5Regular_11">private</span> access modifier to make the member private.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>In addition to</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">public</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">private</span><i>, a third access modifier,</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">protected</span><i>, can be used in conjunction with inheritance. We’ll explore this topic in <a href="chapter19.xhtml">Chapter 19</a>.</i></p>
<p class="TX">For PHP and almost all OOP languages, a getter or setter method’s name usually starts with the word <i>get</i> or <i>set</i>, followed by the property name the method affects, with its first letter capitalized. According to this convention, the getter method for the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property of our <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class should be <span class="SANS_TheSansMonoCd_W5Regular_11">getName()</span>, and its setter method should be <span class="SANS_TheSansMonoCd_W5Regular_11">setName()</span>. For the <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property, the methods should be <span class="SANS_TheSansMonoCd_W5Regular_11">getPrice()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">setPrice()</span>. An exception to this convention is made when a property contains a Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">true/false</span> value. In this case, naming the getter method <span class="SANS_TheSansMonoCd_W5Regular_11">is</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">PropertyName</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">get</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">PropertyName</span> is customary. For example, if the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class had a <span class="SANS_TheSansMonoCd_W5Regular_11">dangerousItem</span> property that contained <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, its getter would be named <span class="SANS_TheSansMonoCd_W5Regular_11">isDangerousItem()</span>.</p>
<p class="TX">A getter method usually returns a value of the same data type as the property it’s paired with (although sometimes we have multiple getter methods for different representations of an object’s property, such as methods to return both rounded-up integer and float values of a float property). A setter method usually takes in a parameter of the same type and stores its value in the property, perhaps conducting validation checks in the process. Usually, setter methods don’t return any value and so are declared to return <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>.</p>
<p class="TX">Let’s revise the declaration for the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class, making its <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> properties private and adding four public accessor methods, two for each property. Update the <i>src/Product.php</i> file as shown in <a href="#lis18-4">Listing 18-4</a>.</p>
<span id="lis18-4"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class Product</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
    private <span class="TheSansMonoCd_W5Regular_Grey_11">string $name;</span>&#13;
    private <span class="TheSansMonoCd_W5Regular_Grey_11">float $price;</span>&#13;
&#13;
<span aria-label="343" epub:type="pagebreak" id="pg_343" role="doc-pagebreak"/>  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> public function getName(): string&#13;
    {&#13;
        return $this-&gt;name;&#13;
    }&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> public function setName(string $name): void&#13;
    {&#13;
      <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> $this-&gt;name = $name;&#13;
    }&#13;
&#13;
    public function getPrice(): float&#13;
    {&#13;
        return $this-&gt;price;&#13;
    }&#13;
&#13;
    public function setPrice(float $price): void&#13;
    {&#13;
        $this-&gt;price = $price;&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-4: Modifying the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class to use getter and setter methods</span></p>
<p class="TX">First, we change the declaration of the two properties to <span class="SANS_TheSansMonoCd_W5Regular_11">private</span>. Then we declare <span class="SANS_TheSansMonoCd_W5Regular_11">getName()</span>, the public getter method for the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Methods in classes can use the special pseudo-variable <span class="SANS_TheSansMonoCd_W5Regular_11">$this</span> to reference the calling object; that is, <span class="SANS_TheSansMonoCd_W5Regular_11">$this</span> is a stand-in for the object whose properties and methods we’re working with. Our <span class="SANS_TheSansMonoCd_W5Regular_11">getName()</span> method thus returns the value in the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property of whichever <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object the method is currently being called on. The method has a <span class="SANS_TheSansMonoCd_W5Regular_11">string</span> return type, since the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property is a string.</p>
<p class="TX">We next declare <span class="SANS_TheSansMonoCd_W5Regular_11">setName()</span>, the public setter method for the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property <span aria-label="annotation2" class="CodeAnnotation">❷</span>. This method takes in a new <span class="SANS_TheSansMonoCd_W5Regular_11">string</span> name value through the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> parameter and stores this value in the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property for the current object, again using <span class="SANS_TheSansMonoCd_W5Regular_11">$this</span> to reference the object. This setter method returns <span class="SANS_TheSansMonoCd_W5Regular_11">void</span>. The getter and setter methods for <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> follow the same pattern.</p>
<p class="TX">Notice in the body of <span class="SANS_TheSansMonoCd_W5Regular_11">setName()</span> how PHP distinguishes between the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> parameter and the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property for the current object <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The former is prefixed by a dollar sign, while the latter is attached to <span class="SANS_TheSansMonoCd_W5Regular_11">$this-&gt;</span> and doesn’t have a dollar sign to indicate it’s a property of the current object. In other words, <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> in the <span class="SANS_TheSansMonoCd_W5Regular_11">setName()</span> method unambiguously refers to the value of the argument passed to the method, while the private <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property of the object that has been sent the <span class="SANS_TheSansMonoCd_W5Regular_11">setName()</span> message is unambiguously referred to by <span class="SANS_TheSansMonoCd_W5Regular_11">$this-&gt;name</span>. The same goes for the <span class="SANS_TheSansMonoCd_W5Regular_11">float $price</span> parameter of the <span class="SANS_TheSansMonoCd_W5Regular_11">setPrice()</span> method versus the <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property of the object the method is being called on.</p>
<p class="TX">When you write methods in a class-declaration file, you must always keep in mind that the same methods may be executed on zero, one, or thousands of objects, in response to objects receiving a message with the name of the method (and any required arguments). Although you may plan to create and use only one instance (object) of a class when you first write <span aria-label="344" epub:type="pagebreak" id="pg_344" role="doc-pagebreak"/>the declaration, a well-written class encapsulates the data (properties) and behavior (methods) for <i>any</i> object of that class. When you keep the general use in mind while programming, you can often use a class in other parts of the same project, or different projects altogether, with few or no changes required to the class declaration. Well-written class declarations lend themselves to reuse.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>While you can type out accessor methods yourself, many code editors, including PhpStorm, offer an automated feature to generate simple getter and setter methods for you. Autogenerating code is faster than typing it out by hand, and it ensures error-free scripts that follow PHP programming conventions.</i></p>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="toc-link_256"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Getting and Setting Private Properties</span></h4>
<p class="TNI1">Since the two properties of any <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object are now declared <span class="SANS_TheSansMonoCd_W5Regular_11">private</span>, we can’t access them directly, such as by writing <span class="SANS_TheSansMonoCd_W5Regular_11">$product1-&gt;name</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">$product1-&gt;price</span>. If you run the existing <i>index.php</i> script, you’ll get a fatal error about not being able to access the private <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property. Instead, we have to read and modify these private properties by using their public accessor methods. <a href="#lis18-5">Listing 18-5</a> shows how to update <i>index.php</i> to make use of these new methods.</p>
<span id="lis18-5"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../src/Product.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$product1 = new Product();</span>&#13;
$product1-&gt;setName('hammer');&#13;
$product1-&gt;setPrice(9.99);&#13;
print 'product 1 name = ' . $product1-&gt;getName();&#13;
print ", and price = {$product1-&gt;getPrice()}";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-5: Using accessor methods in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">As in <a href="#lis18-3">Listing 18-3</a>, we create the <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> object, set its properties, and print out those properties. This time, however, we rely entirely on accessor methods. We use setter methods to update the values of the object properties, such as <span class="SANS_TheSansMonoCd_W5Regular_11">$product1-&gt;setName('hammer')</span>. Likewise, we use getter methods to retrieve values from the object, such as <span class="SANS_TheSansMonoCd_W5Regular_11">$product1-&gt;getName()</span>. Thanks to these methods, the data in the <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> object is safely encapsulated but still accessible.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="toc-link_257"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Screening for Invalid Data</span></h4>
<p class="TNI1">One of the advantages of protecting the data properties of objects is that you can add validation logic to the setter methods to prevent invalid values from being stored in the properties. For example, most businesses probably wouldn’t want to set a negative price for a product (although something might be a free gift, so we’ll allow for a price of 0). We should therefore add an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement to the <span class="SANS_TheSansMonoCd_W5Regular_11">setPrice()</span> method that updates the stored <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> only if the new value is greater than or equal to 0. <a href="#lis18-6">Listing 18-6</a> shows how to update the method in <i>src/Product.php</i>.</p>
<span id="lis18-6"/>
<pre><code><span aria-label="345" epub:type="pagebreak" id="pg_345" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">public function setPrice(float $price): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
    if ($price &gt;= 0) {&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;price = $price;</span>&#13;
<b>    </b>}&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-6: Adding validation logic to the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">setPrice()</span> <span class="SANS_Futura_Std_Book_Oblique_11">method of the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">In our validation logic, we confirm that the new <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> argument is greater than or equal to 0 before setting the value of the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property. To make sure the validation check works, we can update our <i>index.php</i> script to attempt to set an invalid, negative price value. We should see that the invalid values aren’t stored in the object. <a href="#lis18-7">Listing 18-7</a> adds extra statements to <i>index.php</i> for two tests of the validation logic.</p>
<span id="lis18-7"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../src/Product.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$product1 = new Product();</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$product1-&gt;setPrice(9.99);</span>&#13;
&#13;
print "(initial value) product 1 price = {$product1-&gt;getPrice()}\n";&#13;
&#13;
$product1-&gt;setPrice(-0.5);&#13;
print '&lt;br&gt;(test 1) trying -0.5: ';&#13;
print "product 1 price = {$product1-&gt;getPrice()}\n";&#13;
&#13;
$product1-&gt;setPrice(22);&#13;
print '&lt;br&gt;(test 2) trying 22: ';&#13;
print "product 1 price = {$product1-&gt;getPrice()}\n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-7: Testing the setter validation logic in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">As before, we create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object and set its <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">9.99</span>. Then we try to set the price to an invalid negative value, and then a valid positive value that’s different from its initial value, printing the product price each time. Here’s the output of this script in the browser:</p>
<pre><code>(initial value) product 1 price = 9.99&#13;
(test 1) trying -0.5: product 1 price = 9.99&#13;
(test 2) trying 22: product 1 price = 22</code></pre>
<p class="TX">For test 1 (a negative price of <span class="SANS_TheSansMonoCd_W5Regular_11">-0.5</span>), the stored price remains unchanged at <span class="SANS_TheSansMonoCd_W5Regular_11">9.99</span>. For test 2 (a nonnegative value of <span class="SANS_TheSansMonoCd_W5Regular_11">22</span>), the stored price is updated. Our validation logic has worked. In this example, we simply ignored the invalid value, but it’s generally better to somehow indicate that there was a problem. One option is for setters to return a Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> value when no value was set. Another option is to throw an <span class="SANS_TheSansMonoCd_W5Regular_11">Exception</span> object, as we’ll explore in <span class="Xref"><a href="chapter23.xhtml">Chapter 23</a></span>.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="346" epub:type="pagebreak" id="pg_346" role="doc-pagebreak"/>
<h3 class="H1" id="sec6"><span id="toc-link_258"/><span class="SANS_Futura_Std_Bold_B_11">Overriding Default Class Behavior with Magic Methods</span></h3>
<p class="TNI1">PHP offers several <i>magic methods</i> that override default behavior of an object. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">__construct()</span> magic method overrides the default way objects of a class are created, and the <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> magic method overrides the way objects are handled in <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements and other contexts requiring a string. We’ll explore each of these magic methods in this section.</p>
<p class="TX">Despite their name, magic methods are unrelated to PHP magic constants. <span class="note">Magic methods</span> are a feature of object-oriented PHP, allowing the default behavior of an object to be changed. All magic methods have names beginning with double underscore characters (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">__</span>); therefore, you should name methods with such a prefix only when declaring a magic method for a class. You can find a list of all the PHP magic methods at <i><a href="https://www.php.net/manual/en/language.oop5.magic.php">https://www.php.net/manual/en/language.oop5.magic.php</a></i>.</p>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="toc-link_259"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Initializing Values with a Constructor Method</span></h4>
<p class="TNI1">It’s common to want to set some (or all) of an object’s properties as soon as that object has been created. As shown in <a href="#lis18-5">Listing 18-5</a>, you can do this by first creating an object and then having a sequence of statements invoking setter methods to set values for each property. However, initializing object properties immediately after creating an object is such a common requirement that PHP enables you to combine these actions into a single step by writing a magic method called a <i>constructor</i> as part of the class declaration.</p>
<p class="TX">Every class-declaration file either declares no constructor method (as you’ve seen so far in this chapter) or declares a single constructor magic method named <span class="SANS_TheSansMonoCd_W5Regular_11">__construct()</span>. It’s magic in the sense that it overrides the default way of creating an object: creating it without setting any of its properties. The <span class="SANS_TheSansMonoCd_W5Regular_11">__construct()</span> method takes in a series of parameters and assigns them as initial values of the newly created object’s properties. Using a constructor method in an <i>index.php</i> file is as simple as providing the initial values as arguments in the parentheses after the class name: <span class="SANS_TheSansMonoCd_W5Regular_11">$myObject = new ClassName($value1, $value2)</span>, for example. Thanks to the use of the <span class="SANS_TheSansMonoCd_W5Regular_11">new</span> keyword, PHP automatically links the arguments with the constructor, even though <span class="SANS_TheSansMonoCd_W5Regular_11">__construct()</span> isn’t called explicitly.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>PHP is quite unusual as an object-oriented language in that the constructor method doesn’t have the same name as the class. In most other object-oriented languages, a</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Product()</span> <i>method in the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Product</span> <i>class would be a constructor method, but in PHP, there’s nothing special about a method that has the same name as the class in which it’s declared.</i></p>
<p class="TX">Setting properties as part of the constructor method can save some code when it comes to creating new objects. For example, if we know we’ll want to set the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> properties upon creation of a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object, we can add a constructor method to the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class that takes in <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> arguments to set these properties automatically. That way, when we create our <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> object in <i>index.php</i>, we can replace these three statements</p>
<pre><code><span aria-label="347" epub:type="pagebreak" id="pg_347" role="doc-pagebreak"/>$product1 = new Product();&#13;
$product1-&gt;setName('hammer');&#13;
$product1-&gt;setPrice(9.99);</code></pre>
<p class="BodyContinued">with just a single statement:</p>
<pre><code>$product1 = new Product('hammer', 9.99);</code></pre>
<p class="TX">Update <i>Product.php</i> as shown in <a href="#lis18-8">Listing 18-8</a> to add a constructor method that sets the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> properties.</p>
<span id="lis18-8"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class Product</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private string $name;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private float $price;</span>&#13;
&#13;
<b>  </b>  public function __construct(string $name, float $price)&#13;
    {&#13;
        $this-&gt;setName($name);&#13;
        $this-&gt;setPrice($price);&#13;
    }&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function getName()</span>&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-8: Adding a constructor method to the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">We declare a new <span class="SANS_TheSansMonoCd_W5Regular_11">__construct()</span> method. It replaces the default no-parameter creation of an object via <span class="SANS_TheSansMonoCd_W5Regular_11">new Product()</span> with a method requiring two parameters: the initial string name and float price values for the new <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object. Note that constructor methods don’t specify any return type. Within the <span class="SANS_TheSansMonoCd_W5Regular_11">__construct()</span> method definition, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">setName()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">setPrice()</span> methods, which we’ve already defined elsewhere in the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class declaration, feeding them the <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> parameters. This may not seem easier than calling those methods in the <i>index.php</i> script, but as you start creating more instances of the same object, setting properties through the constructor quickly becomes much more efficient. This approach also ensures that exactly the same validation is applied when values are set at the time of object construction as when values are changed at a later time with a direct call to a setter method.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>Many IDEs (such as PhpStorm) offer an interactive constructor method generator that enables you to add selected properties as parameters and have their values set by the generated constructor method code.</i></p>
<p class="TX">Listing 18-9 shows how to simplify <i>index.php</i> to take advantage of the new constructor method.</p>
<span id="lis18-9"/>
<pre><code><span aria-label="348" epub:type="pagebreak" id="pg_348" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../src/Product.php';</span>&#13;
&#13;
$product1 = new Product('hammer', 9.99);&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print 'product 1 name = ' . $product1-&gt;getName();</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print ", and price = {$product1-&gt;getPrice()}";</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-9: The simpler</span> <span class="SANS_Futura_Std_Book_11">index.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">script, using the constructor method</span></p>
<p class="TX">When we create the <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> object, we pass the desired initial values for the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> properties as arguments for the constructor. As noted previously, this collapses three lines of code (creating the object and setting each of its two properties) into a single line.</p>
<aside aria-labelledby="box-11" class="box">
<h5 class="BoxTitle" id="box-11"><span class="SANS_Dogma_OT_Bold_B_11">CONSTRUCTOR PROPERTY PROMOTION</span></h5>
<p class="BoxBodyFirst"><span class="SANS_Futura_Std_Book_11">PHP 8 introduced</span> <span class="SANS_Futura_Std_Book_Oblique_11">constructor property promotion</span><span class="SANS_Futura_Std_Book_11">, which allows you to declare a class’s properties and pass the initial values of those properties in the constructor method, both as a single step. This can make your class declaration files much more concise. This technique takes the place of separately declaring a private property and initializing it in the constructor method. Instead, you write just a constructor with a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">private</span> <span class="SANS_Futura_Std_Book_11">argument and no body.</span></p>
<p class="BoxBody"><span class="SANS_Futura_Std_Book_11">Without constructor property promotion, you’d have to set a class’s</span> <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> <span class="SANS_Futura_Std_Book_11">property through the constructor like this:</span></p>
<pre><code>private string $name;&#13;
&#13;
public function __construct(string $name)&#13;
{&#13;
   $this-&gt;name = $name;&#13;
}</code></pre>
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">With constructor property promotion, those lines become a single constructor declaration with no method body:</span></p>
<pre><code>public function __construct(private string $name){}</code></pre>
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">Until you’re very familiar with OOP, I recommend that you keep your class property declarations separate from your constructor method code. This separation helps you see at a glance which properties each object of the class will have, and if you want to, you can look at the code for the constructor to see which (if any) can be initialized when a new object is created. Constructor property promotion also isn’t appropriate when new object values should be validated through calls to setter methods, as in <a href="#lis18-8">Listing 18-8</a>.</span></p>
</aside>
</section>
<section aria-labelledby="sec8" epub:type="division">
<span aria-label="349" epub:type="pagebreak" id="pg_349" role="doc-pagebreak"/>
<h4 class="H2" id="sec8"><span id="toc-link_260"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Converting Objects to Strings</span></h4>
<p class="TNI1">It’s common to want to summarize the contents of an object as a string, sometimes to display details about the object, or sometimes for debugging and logging purposes. One common reason to convert objects to strings is to generate a list of objects for a web interface, such as a drop-down menu. <a href="#fig18-3">Figure 18-3</a> shows an example drop-down menu with a list of some of the courses I teach.</p>
<figure class="IMG"><a id="fig18-3"/><img alt="" class="img100" height="758" src="../images/figure18-3.jpg" width="1684"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-3: A list of courses summarized as strings</span></p></figcaption>
</figure>
<p class="TX">You can imagine that each of these courses is represented in PHP by a <span class="SANS_TheSansMonoCd_W5Regular_11">Course</span> object, which has properties like <span class="SANS_TheSansMonoCd_W5Regular_11">courseNumber</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">courseName</span>. To generate the drop-down menu, PHP converts each <span class="SANS_TheSansMonoCd_W5Regular_11">Course</span> object to a string in the form <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">courseNumber - courseName</span>, such as <span class="SANS_TheSansMonoCd_W5Regular_11">COMP H2029 - Web Development Server-Side</span>. These strings can then be fed into the HTML code for displaying the menu.</p>
<p class="TX">How does that conversion to a string happen? Most object-oriented languages, including PHP, offer a way to implement a special method to return a string when an object is used in an expression that requires a string (for example, something like <span class="SANS_TheSansMonoCd_W5Regular_11">print $course1</span>, where <span class="SANS_TheSansMonoCd_W5Regular_11">$course1</span> is a reference to a <span class="SANS_TheSansMonoCd_W5Regular_11">Course</span> object). In PHP, this functionality comes from another magic method prefixed with two underscore characters: <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span>.</p>
<p class="TX">You don’t <i>have</i> to implement a <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method for every class, but if you know you’ll need a string summary of an object (such as for a drop-down HTML menu), or if you want to log details about objects to a report, then <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> methods are useful. If a class has no <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method and you try to reference an object of that class in an expression requiring a string, you’ll get a <span class="SANS_TheSansMonoCd_W5Regular_11">could not be converted to string</span> fatal error. Let’s see this happen by replacing the <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements at the end of our <i>index.php</i> script with <span class="SANS_TheSansMonoCd_W5Regular_11">print $product1</span>. Update <i>index.php</i> to match <a href="#lis18-10">Listing 18-10</a>.</p>
<span id="lis18-10"/>
<pre><code><span aria-label="350" epub:type="pagebreak" id="pg_350" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../src/Product.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$product1 = new Product('hammer', 9.99);</span>&#13;
print $product1;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-10: Trying to output details of an object via</span> <span class="TheSansMonoCd_W5Regular_Italic_11">print</span> <span class="SANS_Futura_Std_Book_Oblique_11">in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">We pass the expression <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> to a <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statement. Because <span class="SANS_TheSansMonoCd_W5Regular_11">print</span> statements expect a string expression and <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> isn’t a string, PHP will try to convert it to one. Since the PHP engine can’t convert an object reference to a string without a <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method, a fatal error occurs.</p>
<p class="TX">Let’s now implement a <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method for our <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class, both to explore this common feature of OOP and to allow us to use the simplified <i>index.php</i> script in <a href="#lis18-10">Listing 18-10</a>. <a href="#lis18-11">Listing 18-11</a> shows the new <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method added to the <i>src/Product.php</i> file.</p>
<span id="lis18-11"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class Product</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private string $name;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private float $price;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function __construct(string $name, float $price)</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;setName($name);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;setPrice($price);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
    public function __toString(): string&#13;
    {&#13;
      <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> return '(Product) name = ' . $this-&gt;name&#13;
            . ', and price = ' . $this-&gt;price;&#13;
    }&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function getName(): void</span>&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-11: Adding a</span> <span class="TheSansMonoCd_W5Regular_Italic_11">__toString()</span> <span class="SANS_Futura_Std_Book_Oblique_11">method to the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">We add a new <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method to the class. It contains a single statement that builds and returns a string summarizing the object property values. Note that we generalized the string message to start with <span class="SANS_TheSansMonoCd_W5Regular_11">'(Product) '</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">'product 1 '</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Since this is a method of a class and therefore will potentially be used by many objects, we shouldn’t hardcode the name of the variable referring to a particular object into the general class declaration file.</p>
<p class="TX">Run the <i>index.php</i> script as it was updated in <a href="#lis18-10">Listing 18-10</a>, and you should see that the <span class="SANS_TheSansMonoCd_W5Regular_11">print $product1</span> statement works correctly, thanks to the new <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<span aria-label="351" epub:type="pagebreak" id="pg_351" role="doc-pagebreak"/>
<h3 class="H1" id="sec9"><span id="toc-link_261"/><span class="SANS_Futura_Std_Bold_B_11">Object Variables as References</span></h3>
<p class="TNI1">As noted earlier, the <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> variable used throughout this chapter is a reference to a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object in memory, not a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object itself. One implication of this distinction is that more than one variable can reference the same object in memory. This can occur in lots of ways. For example, it would happen when you need to loop through a collection of objects and perform actions on each. In this case, a temporary local variable would reference the current object being worked on, but the collection would also still have a separate reference to that object.</p>
<p class="TX">To see how object variables are just references to locations in memory, update <i>index.php</i> as shown in <a href="#lis18-12">Listing 18-12</a>. In this code, we create <span class="SANS_TheSansMonoCd_W5Regular_11">$variable2</span>, make it a reference to the same object as <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span>, and change one of the object’s properties through <span class="SANS_TheSansMonoCd_W5Regular_11">$variable2</span>. As you’ll see, this change impacts the object referenced by <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> as well, proving both variables are referencing the same object.</p>
<span id="lis18-12"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../src/Product.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$product1 = new Product('hammer', 5.00);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print $product1;</span>&#13;
print '&lt;br&gt;';&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $variable2 = $product1;&#13;
print 'changing price via $variable2';&#13;
print '&lt;br&gt;';&#13;
$variable2-&gt;setPrice(20.00);&#13;
print $product1;</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-12: Updating</span> <span class="SANS_Futura_Std_Book_11">index.php</span> <span class="SANS_Futura_Std_Book_Oblique_11">to illustrate how object variables are references</span></p>
<p class="TX">We make <span class="SANS_TheSansMonoCd_W5Regular_11">$variable2</span> a reference to the same object as <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then we call <span class="SANS_TheSansMonoCd_W5Regular_11">setPrice()</span> to the object that <span class="SANS_TheSansMonoCd_W5Regular_11">$variable2</span> refers to, changing the value of the object’s <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property to <span class="SANS_TheSansMonoCd_W5Regular_11">20.00</span>. We then print <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> a second time. Since <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> is a reference to an object, its <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method will be invoked. This produces the following output in the browser:</p>
<pre><code>(Product) name = hammer, and price = 9.99&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">Changing price via $variable2</span>&#13;
(Product) name = hammer, and price = 20</code></pre>
<p class="TX">The object referenced by <span class="SANS_TheSansMonoCd_W5Regular_11">$product1</span> has had its price changed to <span class="SANS_TheSansMonoCd_W5Regular_11">20</span>, even though we made the price change through <span class="SANS_TheSansMonoCd_W5Regular_11">$variable2</span>. Therefore, the two variables must be referencing the same object.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="toc-link_262"/><span class="SANS_Futura_Std_Bold_B_11">Handling Missing Objects</span></h3>
<p class="TNI1">Sometimes code is written in such a way that you expect a variable to refer to an object, but no such object is found. That variable would be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, so <span aria-label="352" epub:type="pagebreak" id="pg_352" role="doc-pagebreak"/>it’s often important to include checks for <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> when you’re writing object-oriented code.</p>
<p class="TX">Let’s consider an example. Imagine you’re writing code for a blog. To display a particular blog post, the code expects a valid ID of a blog post from an HTTP request, then uses that ID to retrieve data from a database and construct a <span class="SANS_TheSansMonoCd_W5Regular_11">Blog</span> object. If no ID is found in the request, if the ID is invalid, or if the ID doesn’t match any item in the database, then the application can’t create a <span class="SANS_TheSansMonoCd_W5Regular_11">Blog</span> object, and so the code would return <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> instead of an object reference.</p>
<p class="TX">To account for this situation, other code expecting to work with a <span class="SANS_TheSansMonoCd_W5Regular_11">Blog</span> object would first test for <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> and then decide whether to deal with an invalid ID (say 0 or negative) or with a successfully retrieved <span class="SANS_TheSansMonoCd_W5Regular_11">Blog</span> object. <a href="#lis18-13">Listing 18-13</a> shows an example method that might come from a database-driven blog website to illustrate this point.</p>
<span id="lis18-13"/>
<pre><code>&lt;?php&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span>&#13;
&#13;
public function blogFromId (int $id): ?Blog&#13;
{&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> if (is_numeric($id) &amp;&amp; $id &gt; 0) {&#13;
        return $this-&gt;blogRepository-&gt;find($id);&#13;
    }&#13;
&#13;
    return NULL;&#13;
}&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-13: Using a nullable return type</span></p>
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">blogFromId()</span> method takes in a value for an <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> and returns either a reference to a <span class="SANS_TheSansMonoCd_W5Regular_11">Blog</span> object or <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, using the nullable return type <span class="SANS_TheSansMonoCd_W5Regular_11">?Blog</span>. (We could also have written this as union return type <span class="SANS_TheSansMonoCd_W5Regular_11">Blog|NULL</span>.) The method tests whether <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> is numeric and greater than 0 <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If so, it passes the valid <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> method of the <span class="SANS_TheSansMonoCd_W5Regular_11">blogRepository</span> property and returns the value from this method (either <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> or the <span class="SANS_TheSansMonoCd_W5Regular_11">Blog</span> object found for this ID in the database). If the <span class="SANS_TheSansMonoCd_W5Regular_11">$id</span> isn’t valid, <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> is returned.</p>
<p class="TX">This example is making lots of assumptions, but the point is that the variable set to the result of calling the <span class="SANS_TheSansMonoCd_W5Regular_11">blogFromId()</span> method will either have a reference to an object or be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. Code like this is quite common in OOP (as you’ll see in <span class="Xref"><a href="part6.xhtml">Part VI</a></span>), which is why you often test for a <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> value of a variable you expect to be a reference to an object, to identify whether any object is being referred to. This compares to working with non-object-oriented PHP variables, where <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> can mean, for example, that a variable hasn’t been initialized or that no string value was received for a URL-encoded variable in an HTTP form submission.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<span aria-label="353" epub:type="pagebreak" id="pg_353" role="doc-pagebreak"/>
<h3 class="H1" id="sec11"><span id="toc-link_263"/><span class="SANS_Futura_Std_Bold_B_11">Custom Methods and Virtual Attributes</span></h3>
<p class="TNI1">You can write all sorts of custom methods for a class, beyond the standard getters and setters and the <span class="SANS_TheSansMonoCd_W5Regular_11">__construct()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> magic methods. Remember, methods are simply functions attached to a class of objects, so <i>custom methods</i> are functions to implement logic and calculations relating to objects of the class. For example, our <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class might come with a method for calculating the total price of a product, including tax. The tax rate will be a float value, such as 0.5 (for 50 percent). Such a method would still be functioning as a getter, but instead of simply returning a stored property value, it would be dynamically calculating a value each time it’s invoked.</p>
<p class="TX">To see how it works, we’ll add a <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingTax()</span> method to our <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class declaration. The method will retrieve the tax rate and the pretax price of a product from the appropriate object properties, perform the necessary calculation, and return the total price with tax. For a tax rate of <span class="SANS_TheSansMonoCd_W5Regular_11">0.1</span> (10 percent) and a price of <span class="SANS_TheSansMonoCd_W5Regular_11">5.00</span>, for instance, the method should return <span class="SANS_TheSansMonoCd_W5Regular_11">1.1 * 5.00 = 5.50</span>. To create the method, we also need to add a private <span class="SANS_TheSansMonoCd_W5Regular_11">taxRate</span> property to the class, along with accessor methods for setting and getting the tax rate for a product.</p>
<p class="TX">Listing 18-14 shows an updated <i>Product.php</i> class-declaration file. In addition to adding the <span class="SANS_TheSansMonoCd_W5Regular_11">taxRate</span> property, its accessors, and the custom method, we also modify the <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method to display the results of the tax calculation.</p>
<span id="lis18-14"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">class Product</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">{</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private string $name;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    private float $price;</span>&#13;
<b>  </b><span aria-label="annotation1" class="Code_CodeAnnotation">❶</span><b> </b>private float $taxRate;&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function __construct(string $name, float $price)</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;setName($name);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        $this-&gt;setPrice($price);</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    }</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function __toString(): string</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">        return '(Product) name = ' . $this-&gt;name</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">            . ', and price = ' . $this-&gt;price</span>&#13;
            . ', and price with Tax = ' . $this-&gt;getPriceIncludingTax();&#13;
    }&#13;
&#13;
  <span aria-label="annotation2" class="Code_CodeAnnotation">❷</span> public function getTaxRate(): float&#13;
    {&#13;
        return $this-&gt;taxRate;&#13;
    }&#13;
&#13;
    public function setTaxRate(float $taxRate): void&#13;
    {&#13;
<span aria-label="354" epub:type="pagebreak" id="pg_354" role="doc-pagebreak"/>        $this-&gt;taxRate = $taxRate;&#13;
    }&#13;
&#13;
  <span aria-label="annotation3" class="Code_CodeAnnotation">❸</span> public function getPriceIncludingTax(): float&#13;
    {&#13;
        return (1 + $this-&gt;taxRate) * $this-&gt;price;&#13;
    }&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    public function getName()</span>&#13;
<span class="TheSansMonoCd_W5Regular_Italic_11">--snip--</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 18-14: Adding the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">taxRate</span> <span class="SANS_Futura_Std_Book_Oblique_11">property and associated methods to the</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">taxRate</span> property <span aria-label="annotation1" class="CodeAnnotation">❶</span> along with its simple getter and setter methods <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Then we declare the <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingTax()</span> method <span aria-label="annotation3" class="CodeAnnotation">❸</span>. It returns the price with the tax rate factored in.</p>
<p class="TX">As you can see, our <span class="SANS_TheSansMonoCd_W5Regular_11">getPriceIncludingTax()</span> custom method is simply a function that performs a useful calculation for our class. In this case, it’s essentially an extra getter method that provides a variation on one of the class’s stored properties, <span class="SANS_TheSansMonoCd_W5Regular_11">price</span>. In fact, it’s quite common in OOP to see what amounts to multiple getter methods for the same property of an object: methods that return pre- and post-tax prices of a product, methods that return the same property with different levels of precision (rounded to the nearest whole number versus including up to two decimal places), methods that retrieve the same property converted to different currencies or units (dollars versus euros, feet versus meters), and so on.</p>
<p class="TX">In other cases, custom methods can act as <i>virtual attributes</i>: rather than provide a variation on an existing property, such methods perform calculations to arrive at a completely new piece of information. An example of a virtual attribute might be a method to calculate the age of a product. If products had a <span class="SANS_TheSansMonoCd_W5Regular_11">dateReceived</span> property, the age of a product could be dynamically calculated as part of a <span class="SANS_TheSansMonoCd_W5Regular_11">getProductAge()</span> method. The method would subtract <span class="SANS_TheSansMonoCd_W5Regular_11">dateReceived</span> from the current date. In this case, the product’s age isn’t actually stored as a property of the object, but thanks to the <span class="SANS_TheSansMonoCd_W5Regular_11">getProductAge()</span> method, the information is available as if it were a property.</p>
<p class="TX">Custom methods highlight some of the power of OOP: the person writing code that uses a public <span class="SANS_TheSansMonoCd_W5Regular_11">getProductAge()</span> method of a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object doesn’t need to worry about how that method is implemented. All that counts is that the method works. If the implementation of the method is changed (perhaps changing the data type of the <span class="SANS_TheSansMonoCd_W5Regular_11">dateReceived</span> property from stored MySQL datetime values to Linux timestamps) but its behavior remains correct and unchanged, it makes no difference to the parts of the system that are sending messages to <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> objects and using the values returned by those methods.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="toc-link_264"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">This chapter covered how to declare classes, how to read those declarations into an <i>index.php</i> file and use them to create objects, and how to invoke <span aria-label="355" epub:type="pagebreak" id="pg_355" role="doc-pagebreak"/>methods of objects to set and retrieve their property values. You saw how to protect an object’s data properties by declaring them as <span class="SANS_TheSansMonoCd_W5Regular_11">private</span>, and how to use getter and setter methods declared as <span class="SANS_TheSansMonoCd_W5Regular_11">public</span> to manage access to the object’s properties and perform validation where relevant. We also discussed how to perform common useful actions with PHP “magic” methods, such as creating new objects with some properties initialized via a constructor method and generating a string message representing an object’s properties by declaring a <span class="SANS_TheSansMonoCd_W5Regular_11">__toString()</span> method.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="toc-link_265"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Write a PHP class declaration for a <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> class, with public properties of <span class="SANS_TheSansMonoCd_W5Regular_11">name</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">breed</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">age</span>. Then write an <i>index.php</i> file to read in the class declaration and create a <span class="SANS_TheSansMonoCd_W5Regular_11">Cat</span> object. Store a reference to the new object in a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">$cat1</span> and set its properties as follows:</p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">name = 'Mr. Fluffy'</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">breed = 'long-haired mix'</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">age = 2</span></p>
<p class="ListBody1">Finally, add statements to print the data values for each property of <span class="SANS_TheSansMonoCd_W5Regular_11">$cat1</span>.</p>
<p class="ListNumber">2.   Write a PHP class declaration for a <span class="SANS_TheSansMonoCd_W5Regular_11">Pet</span> class, with a private <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> property and public get and set accessor methods for this <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> variable. Then write an <i>index.php</i> file to read in the class declaration and create a <span class="SANS_TheSansMonoCd_W5Regular_11">Pet</span> object referenced by a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">$pet1</span>. Use the setter to set its name to <span class="SANS_TheSansMonoCd_W5Regular_11">'Fifi'</span>, and add a statement to print the name stored in this object.</p>
<p class="ListNumber">3.   Add a constructor method to your <span class="SANS_TheSansMonoCd_W5Regular_11">Pet</span> class so you can create new <span class="SANS_TheSansMonoCd_W5Regular_11">Pet</span> objects with an initial value of the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> variable by using a statement like this:</p>
<pre><code>$pet1 = new Pet('Mr. Fluffy');</code></pre>
<p class="ListBody1">Update your <i>index.php</i> file to use this constructor method rather than setting the name with the setter method.</p>
<p class="ListNumber">4.   For the following properties and types, write their corresponding accessor (getter/setter) method names:</p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">age // integer</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">houseNumber // integer</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">color // string</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">length // float</span></p>
<p class="ListPlainSub"><span class="SANS_TheSansMonoCd_W5Regular_11">heavy // bool</span></p>
</section>
</section>
</div></body></html>