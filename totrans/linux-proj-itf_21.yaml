- en: 'Chapter 21. Signals: Signal Handlers'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第21章：信号：信号处理程序
- en: 'This chapter continues the description of signals begun in the previous chapter.
    It focuses on signal handlers, and extends the discussion started in Section 20.4\.
    Among the topics we consider are the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续描述在上一章中开始的信号部分。它重点讨论信号处理程序，并扩展了第20.4节中开始的讨论。我们考虑的主题包括以下内容：
- en: how to design a signal handler, which necessitates a discussion of reentrancy
    and async-signal-safe functions;
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计信号处理程序，这需要讨论可重入性和异步信号安全函数；
- en: alternatives to performing a normal return from a signal handler, in particular,
    the use of a nonlocal goto for this purpose;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行信号处理程序的正常返回的替代方法，特别是为此目的使用非本地跳转；
- en: handling of signals on an alternate stack;
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在备用栈上处理信号；
- en: the use of the *sigaction()* `SA_SIGINFO` flag to allow a signal handler to
    obtain more detailed information about the signal that caused its invocation;
    and
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *sigaction()* `SA_SIGINFO` 标志，允许信号处理程序获取有关触发其调用的信号的更多详细信息；
- en: how a blocking system call may be interrupted by a signal handler, and how the
    call can be restarted if desired.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过信号处理程序中断一个阻塞的系统调用，以及如何在需要时重新启动该调用。
- en: Designing Signal Handlers
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计信号处理程序
- en: 'In general, it is preferable to write simple signal handlers. One important
    reason for this is to reduce the risk of creating race conditions. Two common
    designs for signal handlers are the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编写简单的信号处理程序是更可取的。这样做的一个重要原因是减少产生竞争条件的风险。信号处理程序的两种常见设计如下：
- en: The signal handler sets a global flag and exits. The main program periodically
    checks this flag and, if it is set, takes appropriate action. (If the main program
    cannot perform such periodic checks because it needs to monitor one or more file
    descriptors to see if I/O is possible, then the signal handler can also write
    a single byte to a dedicated pipe whose read end is included among the file descriptors
    monitored by the main program. We show an example of this technique in [The Self-Pipe
    Trick](ch63.html#the_self-pipe_trick "The Self-Pipe Trick").)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序设置一个全局标志并退出。主程序定期检查此标志，如果标志被设置，则采取适当的行动。（如果主程序无法执行这样的定期检查，因为它需要监视一个或多个文件描述符以查看是否可以进行I/O操作，那么信号处理程序也可以向一个专用管道写入一个字节，该管道的读取端包含在主程序监控的文件描述符中。我们在[自管道技巧](ch63.html#the_self-pipe_trick
    "自管道技巧")中展示了这个技术的一个示例。）
- en: The signal handler performs some type of cleanup and then either terminates
    the process or uses a nonlocal goto ([Performing a Nonlocal Goto from a Signal
    Handler](ch21.html#performing_a_nonlocal_goto_from_a_signal "Performing a Nonlocal
    Goto from a Signal Handler")) to unwind the stack and return control to a predetermined
    location in the main program.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序执行某种类型的清理，然后终止进程，或使用非本地跳转（[从信号处理程序执行非本地跳转](ch21.html#performing_a_nonlocal_goto_from_a_signal
    "从信号处理程序执行非本地跳转")）来展开栈并将控制权返回到主程序中的预定位置。
- en: In the following sections, we explore these ideas, as well as other concepts
    that are important in the design of signal handlers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨这些想法，以及在信号处理程序设计中重要的其他概念。
- en: Signals Are Not Queued (Revisited)
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号不是排队的（重访）
- en: In [The Signal Mask (Blocking Signal Delivery)](ch20.html#the_signal_mask_open_parenthesis_blockin
    "The Signal Mask (Blocking Signal Delivery)"), we noted that delivery of a signal
    is blocked during the execution of its handler (unless we specify the `SA_NODEFER`
    flag to *sigaction()*). If the signal is (again) generated while the handler is
    executing, then it is marked as pending and later delivered when the handler returns.
    We also already noted that signals are not queued. If the signal is generated
    more than once while the handler is executing, then it is still marked as pending,
    and it will later be delivered only once.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[信号掩码（阻塞信号传递）](ch20.html#the_signal_mask_open_parenthesis_blockin "信号掩码（阻塞信号传递）")中，我们提到在执行信号处理程序时，信号的传递会被阻塞（除非我们在
    *sigaction()* 中指定 `SA_NODEFER` 标志）。如果在处理程序执行期间再次生成该信号，则该信号将被标记为待处理，并在处理程序返回时传递。我们还已经提到，信号不会排队。如果在处理程序执行期间生成多次信号，则它仍然会被标记为待处理，并且只会在稍后传递一次。
- en: That signals can “disappear” in this way has implications for how we design
    signal handlers. To begin with, we can’t reliably count the number of times a
    signal is generated. Furthermore, we may need to code our signal handlers to deal
    with the possibility that multiple events of the type corresponding to the signal
    have occurred. We’ll see an example of this when we consider the use of the `SIGCHLD`
    signal in [Establishing a Handler for `SIGCHLD`](ch26.html#establishing_a_handler_for_sigchld
    "Establishing a Handler for SIGCHLD").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可能以这种方式“消失”，这对我们设计信号处理器有重要影响。首先，我们无法可靠地计算信号生成的次数。此外，我们可能需要编写信号处理器代码，以应对可能发生多次与该信号对应的事件的情况。我们将在[《为SIGCHLD建立处理器》](ch26.html#establishing_a_handler_for_sigchld
    "为SIGCHLD建立处理器")中看到一个例子。
- en: Reentrant and Async-Signal-Safe Functions
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可重入函数与异步信号安全函数
- en: 'Not all system calls and library functions can be safely called from a signal
    handler. To understand why requires an explanation of two concepts: reentrant
    functions and async-signal-safe functions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的系统调用和库函数都可以在信号处理器中安全地调用。要理解原因，需要解释两个概念：可重入函数和异步信号安全函数。
- en: Reentrant and nonreentrant functions
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可重入函数和非可重入函数
- en: 'To explain what a reentrant function is, we need to first distinguish between
    single-threaded and multithreaded programs. Classical UNIX programs have a single
    *thread of execution*: the CPU processes instructions for a single logical flow
    of execution through the program. In a multithreaded program, there are multiple,
    independent, concurrent logical flows of execution within the same process.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释什么是可重入函数，我们需要首先区分单线程程序和多线程程序。经典的UNIX程序只有一个*执行线程*：CPU处理程序中单一逻辑执行流的指令。在多线程程序中，同一个进程内有多个独立的并发逻辑执行流。
- en: 'In [Chapter 29](ch29.html "Chapter 29. Threads: Introduction"), we’ll see how
    to explicitly create programs that contain multiple threads of execution. However,
    the concept of multiple threads of execution is also relevant for programs that
    employ signal handlers. Because a signal handler may asynchronously interrupt
    the execution of a program at any point in time, the main program and the signal
    handler in effect form two independent (although not concurrent) threads of execution
    within the same process.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第29章](ch29.html "第29章. 线程：简介")中，我们将看到如何显式地创建包含多个执行线程的程序。然而，多线程执行的概念对于使用信号处理器的程序也同样重要。因为信号处理器可能在程序的任何时刻异步中断程序的执行，主程序和信号处理器实际上形成了同一个进程内两个独立的（尽管不是并发的）执行线程。
- en: A function is said to be *reentrant* if it can safely be simultaneously executed
    by multiple threads of execution in the same process. In this context, “safe”
    means that the function achieves its expected result, regardless of the state
    of execution of any other thread of execution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数能够被同一进程中的多个执行线程同时安全执行，则称该函数为*可重入*。在这个上下文中，“安全”意味着无论其他执行线程的状态如何，该函数都能达到预期的结果。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SUSv3 definition of a reentrant function is one “whose effect, when called
    by two or more threads, is guaranteed to be as if the threads each executed the
    function one after the other in an undefined order, even if the actual execution
    is interleaved.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3对可重入函数的定义是：“当两个或多个线程调用时，其效果保证就像这些线程一个接一个按不确定顺序执行该函数，即使实际执行是交替进行的。”
- en: A function may be *nonreentrant* if it updates global or static data structures.
    (A function that employs only local variables is guaranteed to be reentrant.)
    If two invocations of (i.e., two threads executing) the function simultaneously
    attempt to update the same global variable or data structure, then these updates
    are likely to interfere with each other and produce incorrect results. For example,
    suppose that one thread of execution is in the middle of updating a linked list
    data structure to add a new list item when another thread also attempts to update
    the same linked list. Since adding a new item to the list requires updating multiple
    pointers, if another thread interrupts these steps and updates the same pointers,
    chaos will result.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数更新了全局或静态数据结构，那么它可能是*不可重入*的。（一个仅使用局部变量的函数是保证可重入的。）如果两个函数调用（即两个线程同时执行）试图同时更新相同的全局变量或数据结构，那么这些更新很可能会相互干扰并产生错误结果。例如，假设一个线程正在更新一个链表数据结构以添加一个新的列表项，而另一个线程也试图更新同一个链表。由于向列表中添加新项需要更新多个指针，如果另一个线程中断这些步骤并更新相同的指针，就会导致混乱。
- en: Such possibilities are in fact rife within the standard C library. For example,
    we already noted in [Implementation of *malloc()* and *free()*](ch07.html#implementation_of_malloc_open_parenthesi
    "Implementation of malloc() and free()") that *malloc()* and *free()* maintain
    a linked list of freed memory blocks available for reallocation from the heap.
    If a call to *malloc()* in the main program is interrupted by a signal handler
    that also calls *malloc()*, then this linked list can be corrupted. For this reason,
    the *malloc()* family of functions, and other library functions that use them,
    are nonreentrant.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的可能性实际上在标准 C 库中很常见。例如，我们在[《*malloc()* 和 *free()* 的实现》](ch07.html#implementation_of_malloc_open_parenthesi
    "Implementation of malloc() and free()")中已经提到，*malloc()* 和 *free()* 会维护一个已经释放的内存块的链表，这些内存块可以从堆中重新分配。如果主程序中的
    *malloc()* 调用被一个信号处理程序中也调用 *malloc()* 的中断，那么这个链表可能会被破坏。因此，*malloc()* 系列函数，以及使用它们的其他库函数，是不可重入的。
- en: Other library functions are nonreentrant because they return information using
    statically allocated memory. Examples of such functions (described elsewhere in
    this book) include *crypt()*, *getpwnam()*, *gethostbyname()*, and *getservbyname()*.
    If a signal handler also uses one of these functions, then it will overwrite information
    returned by any earlier call to the same function from within the main program
    (or vice versa).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些库函数之所以不可重入，是因为它们通过静态分配的内存返回信息。这类函数的例子（本书中其他地方有描述）包括 *crypt()*、*getpwnam()*、*gethostbyname()*
    和 *getservbyname()*。如果信号处理程序也使用这些函数中的某个函数，那么它将覆盖先前从主程序中调用相同函数返回的信息（反之亦然）。
- en: Functions can also be nonreentrant if they use static data structures for their
    internal bookkeeping. The most obvious examples of such functions are the members
    of the *stdio* library (*printf()*, *scanf()*, and so on), which update internal
    data structures for buffered I/O. Thus, when using *printf()* from within a signal
    handler, we may sometimes see strange output—or even a program crash or data corruption—if
    the handler interrupts the main program in the middle of executing a call to *printf()*
    or another *stdio* function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数使用静态数据结构进行内部管理，它也可能是不可重入的。最明显的这类函数是 *stdio* 库的成员（*printf()*、*scanf()*
    等），它们会更新用于缓冲输入输出的内部数据结构。因此，当在信号处理程序中使用 *printf()* 时，如果该处理程序在主程序执行 *printf()* 或其他
    *stdio* 函数调用的过程中被中断，我们有时会看到奇怪的输出，甚至程序崩溃或数据损坏。
- en: Even if we are not using nonreentrant library functions, reentrancy issues can
    still be relevant. If a signal handler updates programmer-defined global data
    structures that are also updated within the main program, then we can say that
    the signal handler is nonreentrant with respect to the main program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有使用不可重入的库函数，重入问题仍然可能相关。如果信号处理程序更新了程序员定义的全局数据结构，而这些数据结构也在主程序中被更新，那么我们可以说信号处理程序在主程序中的作用是不可重入的。
- en: If a function is nonreentrant, then its manual page will normally provide an
    explicit or implicit indication of this fact. In particular, watch out for statements
    that the function uses or returns information in statically allocated variables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数是不可重入的，那么它的手册页通常会明确或隐含地指出这一点。特别要注意那些说明该函数使用或返回静态分配变量信息的语句。
- en: Example program
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 21-1](ch21.html#calling_a_nonreentrant_function_from_bot "Example 21-1. Calling
    a nonreentrant function from both main() and a signal handler") demonstrates the
    nonreentrant nature of the *crypt()* function ([Password Encryption and User Authentication](ch08.html#password_encryption_and_user_authenticat
    "Password Encryption and User Authentication")). As command-line arguments, this
    program accepts two strings. The program performs the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-1](ch21.html#calling_a_nonreentrant_function_from_bot "示例 21-1. 从 main()
    和信号处理程序中调用一个非重入函数") 展示了 *crypt()* 函数的非重入特性（[密码加密和用户认证](ch08.html#password_encryption_and_user_authenticat
    "密码加密和用户认证")）。作为命令行参数，该程序接受两个字符串。程序执行以下步骤：'
- en: Call *crypt()* to encrypt the string in the first command-line argument, and
    copy this string to a separate buffer using *strdup()*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 *crypt()* 对第一个命令行参数中的字符串进行加密，并使用 *strdup()* 将该字符串复制到一个单独的缓冲区中。
- en: Establish a handler for `SIGINT` (generated by typing *Control-C*). The handler
    calls *crypt()* to encrypt the string supplied in the second command-line argument.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `SIGINT`（通过键入 *Control-C* 生成）设置一个处理程序。该处理程序调用 *crypt()* 对第二个命令行参数中的字符串进行加密。
- en: Enter an infinite `for` loop that uses *crypt()* to encrypt the string in the
    first command-line argument and check that the returned string is the same as
    that saved in step 1.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入一个无限的 `for` 循环，使用 *crypt()* 对第一个命令行参数中的字符串进行加密，并检查返回的字符串是否与第 1 步中保存的字符串相同。
- en: 'In the absence of a signal, the strings will always match in step 3. However,
    if a `SIGINT` signal arrives and the execution of the signal handler interrupts
    the main program just after the execution of the *crypt()* call in the `for` loop,
    but before the check to see if the strings match, then the main program will report
    a mismatch. When we run the program, this is what we see:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有信号的情况下，第 3 步中的字符串始终匹配。然而，如果 `SIGINT` 信号到达并且信号处理程序的执行在 `for` 循环中执行 *crypt()*
    调用之后，但在检查字符串是否匹配之前中断了主程序，那么主程序将报告不匹配。当我们运行该程序时，会看到如下结果：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Comparing the *mismatch* and *handled* values in the above output, we see that
    in the majority of cases where the signal handler is invoked, it overwrites the
    statically allocated buffer between the call to *crypt()* and the string comparison
    in *main()*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 比较上述输出中的 *mismatch* 和 *handled* 值，我们看到在大多数调用信号处理程序的情况下，它会覆盖在 *crypt()* 调用和 *main()*
    中字符串比较之间的静态分配缓冲区。
- en: Example 21-1. Calling a nonreentrant function from both *main()* and a signal
    handler
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 21-1. 从 *main()* 和信号处理程序中调用一个非重入函数
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Standard async-signal-safe functions
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准异步信号安全函数
- en: An *async-signal-safe* function is one that the implementation guarantees to
    be safe when called from a signal handler. A function is async-signal-safe either
    because it is reentrant or because it is not interruptible by a signal handler.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步信号安全* 函数是指在从信号处理程序中调用时，实施保证其安全的函数。一个函数是异步信号安全的，要么因为它是可重入的，要么因为它不会被信号处理程序中断。'
- en: '[Table 21-1](ch21.html#functions_required_to_be_async-signal-sa "Table 21-1. Functions
    required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3") lists the
    functions that various standards require to be async-signal-safe. In this table,
    the functions whose names are not followed by a *v2* or *v3* were specified as
    async-signal-safe in POSIX.1-1990\. SUSv2 added the functions marked *v2* to the
    list, and those marked *v3* were added by SUSv3\. Individual UNIX implementations
    may make other functions async-signal-safe, but all standards-conformant UNIX
    implementations must ensure that at least these functions are async-signal-safe
    (if they are provided by the implementation; not all of these functions are provided
    on Linux).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 21-1](ch21.html#functions_required_to_be_async-signal-sa "表 21-1. POSIX.1-1990、SUSv2
    和 SUSv3 要求的异步信号安全函数") 列出了各个标准要求的异步信号安全函数。在此表中，函数名称后没有 *v2* 或 *v3* 的函数是 POSIX.1-1990
    中指定为异步信号安全的。SUSv2 将标记为 *v2* 的函数添加到列表中，而标记为 *v3* 的函数是 SUSv3 添加的。各个 UNIX 实现可能会使其他函数变为异步信号安全，但所有符合标准的
    UNIX 实现必须确保至少这些函数是异步信号安全的（如果它们由实现提供；并非所有这些函数都在 Linux 上提供）。'
- en: 'SUSv4 makes the following changes to [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa
    "Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2,
    and SUSv3"):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv4 对 [表 21-1](ch21.html#functions_required_to_be_async-signal-sa "表 21-1.
    POSIX.1-1990、SUSv2 和 SUSv3 要求的异步信号安全函数") 做了以下更改：
- en: 'The following functions are removed: *fpathconf()*, *pathconf()*, and *sysconf()*.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数已被移除：*fpathconf()*, *pathconf()*, 和 *sysconf()*。
- en: 'The following functions are added: *execl()*, *execv()*, *faccessat()*, *fchmodat()*,
    *fchownat()*, *fexecve()*, *fstatat()*, *futimens()*, *linkat()*, *mkdirat()*,
    *mkfifoat()*, *mknod()*, *mknodat()*, *openat()*, *readlinkat()*, *renameat()*,
    *symlinkat()*, *unlinkat()*, *utimensat()*, and *utimes()*.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下函数被添加：*execl()*，*execv()*，*faccessat()*，*fchmodat()*，*fchownat()*，*fexecve()*，*fstatat()*，*futimens()*，*linkat()*，*mkdirat()*，*mkfifoat()*，*mknod()*，*mknodat()*，*openat()*，*readlinkat()*，*renameat()*，*symlinkat()*，*unlinkat()*，*utimensat()*，以及*utimes()*。
- en: Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2,
    and SUSv3
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-1. POSIX.1-1990、SUSv2 和 SUSv3 要求具备异步信号安全的函数
- en: '| *_Exit()(v3)**_exit()**abort() (v3)**accept() (v3)**access()**aio_error()
    (v2)**aio_return()(v2)**aio_suspend() (v2)**alarm()**bind()(v3)**cfgetispeed()**cfgetospeed()**cfsetispeed()**cfsetospeed()**chdir()**chmod()**chown()**clock_gettime()
    (v2)**close()**connect() (v3)**creat()**dup()**dup2()**execle()**execve()**fchmod()
    (v3)**fchown() (v3)**fcntl()**fdatasync() (v2)**fork()**fpathconf() (v2)**fstat()**fsync()
    (v2)**ftruncate() (v3)**getegid()**geteuid()**getgid()**getgroups()**getpeername()
    (v3)**getpgrp()* | *getpid()**getppid()**getsockname() (v3)**getsockopt() (v3)**getuid()**kill()**link()**listen()
    (v3)**lseek()**lstat() (v3)**mkdir()**mkfifo()**open()**pathconf()**pause()**pipe()**poll()
    (v3)**posix_trace_event() (v3)**pselect() (v3)**raise() (v2)**read()**readlink()
    (v3)**recv() (v3)**recvfrom() (v3)**recvmsg() (v3)**rename()**rmdir()**select()
    (v3)**sem_post() (v2)**send() (v3)**sendmsg() (v3)**sendto() (v3)**setgid()**setpgid()**setsid()**setsockopt()
    (v3)**setuid()**shutdown() (v3)**sigaction()**sigaddset()* | *sigdelset()**sigemptyset()**sigfillset()**sigismember()**signal()
    (v2)**sigpause() (v2)**sigpending()**sigprocmask()**sigqueue() (v2)**sigset()
    (v2)**sigsuspend()**sleep()**socket() (v3)**sockatmark() (v3)**socketpair() (v3)**stat()**symlink()
    (v3)**sysconf()**tcdrain()**tcflow()**tcflush()**tcgetattr()**tcgetpgrp()**tcsendbreak()**tcsetattr()**tcsetpgrp()**time()**timer_getoverrun()
    (v2)**timer_gettime() (v2)**timer_settime() (v2)**times()**umask()**uname()**unlink()**utime()**wait()**waitpid()**write()*
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| *_Exit()(v3)**_exit()**abort() (v3)**accept() (v3)**access()**aio_error()
    (v2)**aio_return()(v2)**aio_suspend() (v2)**alarm()**bind()(v3)**cfgetispeed()**cfgetospeed()**cfsetispeed()**cfsetospeed()**chdir()**chmod()**chown()**clock_gettime()
    (v2)**close()**connect() (v3)**creat()**dup()**dup2()**execle()**execve()**fchmod()
    (v3)**fchown() (v3)**fcntl()**fdatasync() (v2)**fork()**fpathconf() (v2)**fstat()**fsync()
    (v2)**ftruncate() (v3)**getegid()**geteuid()**getgid()**getgroups()**getpeername()
    (v3)**getpgrp()* | *getpid()**getppid()**getsockname() (v3)**getsockopt() (v3)**getuid()**kill()**link()**listen()
    (v3)**lseek()**lstat() (v3)**mkdir()**mkfifo()**open()**pathconf()**pause()**pipe()**poll()
    (v3)**posix_trace_event() (v3)**pselect() (v3)**raise() (v2)**read()**readlink()
    (v3)**recv() (v3)**recvfrom() (v3)**recvmsg() (v3)**rename()**rmdir()**select()
    (v3)**sem_post() (v2)**send() (v3)**sendmsg() (v3)**sendto() (v3)**setgid()**setpgid()**setsid()**setsockopt()
    (v3)**setuid()**shutdown() (v3)**sigaction()**sigaddset()* | *sigdelset()**sigemptyset()**sigfillset()**sigismember()**signal()
    (v2)**sigpause() (v2)**sigpending()**sigprocmask()**sigqueue() (v2)**sigset()
    (v2)**sigsuspend()**sleep()**socket() (v3)**sockatmark() (v3)**socketpair() (v3)**stat()**symlink()
    (v3)**sysconf()**tcdrain()**tcflow()**tcflush()**tcgetattr()**tcgetpgrp()**tcsendbreak()**tcsetattr()**tcsetpgrp()**time()**timer_getoverrun()
    (v2)**timer_gettime() (v2)**timer_settime() (v2)**times()**umask()**uname()**unlink()**utime()**wait()**waitpid()**write()*
    |'
- en: 'SUSv3 notes that all functions not listed in [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa
    "Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2,
    and SUSv3") are considered to be unsafe with respect to signals, but points out
    that a function is unsafe only when invocation of a signal handler interrupts
    the execution of an unsafe function, and the handler itself also calls an unsafe
    function. In other words, when writing signal handlers, we have two choices:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 指出，所有未在[表 21-1](ch21.html#functions_required_to_be_async-signal-sa "表
    21-1. POSIX.1-1990、SUSv2 和 SUSv3 要求具备异步信号安全的函数")中列出的函数都被认为与信号处理相关的不安全函数，但指出只有在信号处理程序的调用中断了不安全函数的执行，并且处理程序本身也调用了不安全函数时，函数才被认为是不安全的。换句话说，在编写信号处理程序时，我们有两种选择：
- en: Ensure that the code of the signal handler itself is reentrant and that it calls
    only async-signal-safe functions.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保信号处理程序本身的代码是可重入的，并且仅调用异步信号安全的函数。
- en: Block delivery of signals while executing code in the main program that calls
    unsafe functions or works with global data structures also updated by the signal
    handler.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行主程序中调用不安全函数或与由信号处理程序更新的全局数据结构一起工作的代码时，阻止信号的传递。
- en: The problem with the second approach is that, in a complex program, it can be
    difficult to ensure that a signal handler will never interrupt the main program
    while it is calling an unsafe function. For this reason, the above rules are often
    simplified to the statement that we must not call unsafe functions from within
    a signal handler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法的问题在于，在一个复杂的程序中，确保信号处理程序在调用不安全函数时永远不会中断主程序可能会很困难。因此，上述规则通常简化为我们不能在信号处理程序中调用不安全函数的声明。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we set up the same handler function to deal with several different signals
    or use the `SA_NODEFER` flag to *sigaction()*, then a handler may interrupt itself.
    As a consequence, the handler may be nonreentrant if it updates global (or static)
    variables, even if they are not used by the main program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置相同的处理程序函数来处理多个不同的信号，或者使用`SA_NODEFER`标志来设置*sigaction()*，那么一个处理程序可能会中断自身。因此，如果处理程序更新全局（或静态）变量，即使这些变量没有被主程序使用，它也可能变得不可重入。
- en: Use of *errno* inside signal handlers
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在信号处理程序中使用*errno*
- en: 'Because they may update *errno*, use of the functions listed in [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa
    "Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2,
    and SUSv3") can nevertheless render a signal handler nonreentrant, since they
    may overwrite the *errno* value that was set by a function called from the main
    program. The workaround is to save the value of *errno* on entry to a signal handler
    that uses any of the functions in [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa
    "Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2,
    and SUSv3") and restore the *errno* value on exit from the handler, as in the
    following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们可能会更新*errno*，使用[表21-1](ch21.html#functions_required_to_be_async-signal-sa
    "表21-1。POSIX.1-1990，SUSv2和SUSv3要求异步信号安全的函数")中列出的函数仍然可能使信号处理程序变得不可重入，因为它们可能会覆盖由主程序中调用的函数设置的*errno*值。解决方法是在进入使用[表21-1](ch21.html#functions_required_to_be_async-signal-sa
    "表21-1。POSIX.1-1990，SUSv2和SUSv3要求异步信号安全的函数")中任何函数的信号处理程序时保存*errno*的值，并在从处理程序退出时恢复*errno*值，如下例所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use of unsafe functions in example programs in this book
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 本书示例程序中不安全函数的使用
- en: Although *printf()* is not async-signal-safe, we use it in signal handlers in
    various example programs in this book. We do so because *printf()* provides an
    easy and concise way to demonstrate that a signal handler has been called, and
    to display the contents of relevant variables within the handler. For similar
    reasons, we occasionally use a few other unsafe functions in signal handlers,
    including other *stdio* functions and *strsignal()*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*printf()*不是异步信号安全的，但我们在本书中的各种示例程序中仍在信号处理程序中使用它。我们这样做是因为*printf()*提供了一种简单而简洁的方式来演示信号处理程序已经被调用，并显示处理程序中相关变量的内容。出于类似的原因，我们偶尔会在信号处理程序中使用一些其他不安全的函数，包括其他*stdio*函数和*strsignal()*。
- en: 'Real-world applications should avoid calling non-async-signal-safe functions
    from signal handlers. To make this clear, each signal handler in the example programs
    that uses one of these functions is marked with a comment indicating that the
    usage is unsafe:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界的应用应该避免在信号处理程序中调用非异步信号安全的函数。为了明确这一点，本书中的每个使用这些函数的信号处理程序都会标注一个注释，表明这种用法是不安全的：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Global Variables and the *sig_atomic_t* Data Type
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量和*sig_atomic_t*数据类型
- en: 'Notwithstanding reentrancy issues, it can be useful to share global variables
    between the main program and a signal handler. This can be safe as long as the
    main program correctly handles the possibility that the signal handler may change
    the global variable at any time. For example, one common design is to make a signal
    handler’s sole action the setting of a global flag. This flag is periodically
    checked by the main program, which then takes appropriate action in response to
    the delivery of the signal (and clears the flag). When global variables are accessed
    in this way from a signal handler, we should always declare them using the `volatile`
    attribute (see [Performing a Nonlocal Goto: *setjmp()* and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "Performing a Nonlocal Goto: setjmp() and long jmp()")) in order to prevent the
    compiler from performing optimizations that result in the variable being stored
    in a register.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在重入问题，在主程序和信号处理程序之间共享全局变量可能是有用的。只要主程序正确处理信号处理程序可能随时更改全局变量的情况，这种做法是安全的。例如，一种常见的设计是让信号处理程序的唯一操作是设置一个全局标志。这个标志会被主程序定期检查，然后根据信号的传递采取适当的行动（并清除标志）。当全局变量通过信号处理程序以这种方式访问时，我们应始终使用`volatile`属性声明它们（见[执行非局部跳转：*setjmp()*
    和 *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp "执行非局部跳转：setjmp()
    和 long jmp()")），以防止编译器进行优化，导致变量被存储在寄存器中。
- en: 'Reading and writing global variables may involve more than one machine-language
    instruction, and a signal handler may interrupt the main program in the middle
    of such an instruction sequence. (We say that access to the variable is *nonatomic*.)
    For this reason, the C language standards and SUSv3 specify an integer data type,
    *sig_atomic_t*, for which reads and writes are guaranteed to be atomic. Thus,
    a global flag variable that is shared between the main program and a signal handler
    should be declared as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入全局变量可能涉及多条机器语言指令，并且信号处理程序可能在这些指令序列的中间中断主程序。（我们称访问该变量为*非原子性*的。）因此，C语言标准和SUSv3规定了一种整数数据类型，*sig_atomic_t*，它保证对该类型的读取和写入是原子的。因此，共享在主程序和信号处理程序之间的全局标志变量应按如下方式声明：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We show an example of the use of the *sig_atomic_t* data type in [Example 22-5](ch22.html#using_sigsuspend_open_parenthesis_close
    "Example 22-5. Using sigsuspend()"), in [Example program](ch22.html#example_program-id26
    "Example program").
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了在[示例 22-5](ch22.html#using_sigsuspend_open_parenthesis_close "示例 22-5.
    使用 sigsuspend()")和[示例程序](ch22.html#example_program-id26 "示例程序")中使用*sig_atomic_t*数据类型的例子。
- en: 'Note that the C increment (`++`) and decrement (`--`) operators don’t fall
    within the guarantee provided for *sig_atomic_t*. On some hardware architectures,
    these operations may not be atomic (refer to [Protecting Accesses to Shared Variables:
    Mutexes](ch30.html#protecting_accesses_to_shared_variables "Protecting Accesses
    to Shared Variables: Mutexes") for more details). All that we are guaranteed to
    be safely allowed to do with a *sig_atomic_t* variable is set it within the signal
    handler, and check it in the main program (or vice versa).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C的自增（`++`）和自减（`--`）运算符不在*sig_atomic_t*提供的保证范围内。在某些硬件架构中，这些操作可能不是原子性的（有关更多细节，请参阅[保护对共享变量的访问：互斥锁](ch30.html#protecting_accesses_to_shared_variables
    "保护对共享变量的访问：互斥锁")）。我们唯一被保证安全地允许对*sig_atomic_t*变量执行的操作是，在信号处理程序中设置它，并在主程序中检查它（或反之）。
- en: C99 and SUSv3 specify that an implementation should define two constants (in
    `<stdint.h>`), `SIG_ATOMIC_MIN` and `SIG_ATOMIC_MAX`, that define the range of
    values that may be assigned to variables of type *sig_atomic_t*. The standards
    require that this range be at least -127 to 127 if *sig_atomic_t* is represented
    as a signed value, or 0 to 255 if it is represented as an unsigned value. On Linux,
    these two constants equate to the negative and positive limits for signed 32-bit
    integers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C99和SUSv3规定实现应定义两个常量（在`<stdint.h>`中），`SIG_ATOMIC_MIN`和`SIG_ATOMIC_MAX`，用于定义可以分配给*sig_atomic_t*类型变量的值范围。标准要求，如果*sig_atomic_t*表示为带符号值，则该范围至少应为-127到127；如果表示为无符号值，则应为0到255。在Linux上，这两个常量等同于带符号32位整数的负数和正数极限。
- en: Other Methods of Terminating a Signal Handler
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他终止信号处理程序的方法
- en: All of the signal handlers that we have looked at so far complete by returning
    to the main program. However, simply returning from a signal handler sometimes
    isn’t desirable, or in some cases, isn’t even useful. (We’ll see an example of
    where returning from a signal handler isn’t useful when we discuss hardware-generated
    signals in Section 22.4.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所查看的所有信号处理程序通过返回到主程序来完成。然而，简单地从信号处理程序返回有时并不理想，或者在某些情况下，甚至没有用处。（当我们讨论硬件生成的信号时，在第22.4节中会看到一个返回信号处理程序无用的例子。）
- en: 'There are various other ways of terminating a signal handler:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有各种其他终止信号处理程序的方法：
- en: Use *_exit()* to terminate the process. Beforehand, the handler may carry out
    some cleanup actions. Note that we can’t use *exit()* to terminate a signal handler,
    because it is not one of safe functions listed in [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa
    "Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2,
    and SUSv3"). It is unsafe because it flushes *stdio* buffers prior to calling
    *_exit()*, as described in Section 25.1.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *_exit()* 终止进程。在此之前，处理程序可以执行一些清理操作。请注意，我们不能使用 *exit()* 来终止信号处理程序，因为它不是在 [表
    21-1](ch21.html#functions_required_to_be_async-signal-sa "表 21-1. POSIX.1-1990、SUSv2
    和 SUSv3 要求的异步信号安全函数") 中列出的安全函数之一。它不安全，因为它会在调用 *_exit()* 之前刷新 *stdio* 缓冲区，如第25.1节所述。
- en: Use *kill()* or *raise()* to send a signal that kills the process (i.e., a signal
    whose default action is process termination).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *kill()* 或 *raise()* 发送一个终止进程的信号（即一个默认操作是终止进程的信号）。
- en: Perform a nonlocal goto from the signal handler.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从信号处理程序执行非局部跳转。
- en: Use the *abort()* function to terminate the process with a core dump.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *abort()* 函数通过核心转储终止进程。
- en: The last two of these options are described in further detail in the following
    sections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项的最后两个将在以下章节中进一步详细描述。
- en: Performing a Nonlocal Goto from a Signal Handler
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从信号处理程序执行非局部跳转
- en: '[Performing a Nonlocal Goto: *setjmp()* and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "Performing a Nonlocal Goto: setjmp() and long jmp()") described the use of *setjmp()*
    and *longjmp()* to perform a nonlocal goto from a function to one of its callers.
    We can also use this technique from a signal handler. This provides a way to recover
    after delivery of a signal caused by a hardware exception (e.g., a memory access
    error), and also allows us to catch a signal and return control to a particular
    point in a program. For example, upon receipt of a `SIGINT` signal (normally generated
    by typing *Control-C*), the shell performs a nonlocal goto to return control to
    its main input loop (and thus read a new command).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[执行非局部跳转：*setjmp()* 和 *longjmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp
    "执行非局部跳转：setjmp() 和 longjmp()") 描述了使用 *setjmp()* 和 *longjmp()* 从函数到其调用者之间执行非局部跳转。我们也可以在信号处理程序中使用这种技术。这提供了一种在硬件异常（例如内存访问错误）引发信号后进行恢复的方法，并且还允许我们捕获信号并将控制权返回到程序中的特定位置。例如，在接收到
    `SIGINT` 信号（通常由输入 *Control-C* 生成）时，shell 执行非局部跳转，将控制权返回到其主输入循环（从而读取新命令）。'
- en: However, there is a problem with using the standard *longjmp()* function to
    exit from a signal handler. We noted earlier that, upon entry to the signal handler,
    the kernel automatically adds the invoking signal, as well as any signals specified
    in the *act.sa_mask* field, to the process signal mask, and then removes these
    signals from the mask when the handler does a normal return.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用标准的 *longjmp()* 函数从信号处理程序退出时存在一个问题。我们之前提到过，在进入信号处理程序时，内核会自动将调用信号以及 *act.sa_mask*
    字段中指定的任何信号添加到进程信号屏蔽中，并在处理程序正常返回时将这些信号从屏蔽中移除。
- en: What happens to the signal mask if we exit the signal handler using *longjmp()*?
    The answer depends on the genealogy of the particular UNIX implementation. Under
    System V, *longjmp()* doesn’t restore the signal mask, so that blocked signals
    are not unblocked upon leaving the handler. Linux follows the System V behavior.
    (This is usually not what we want, since it leaves the signal that caused invocation
    of the handler blocked.) Under BSD-derived implementations, *setjmp()* saves the
    signal mask in its *env* argument, and the saved signal mask is restored by *longjmp()*.
    (BSD-derived implementations also provide two other functions, *_setjmp()* and
    *_longjmp()*, which have the System V semantics.) In other words, we can’t portably
    use *longjmp()* to exit a signal handler.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 *longjmp()* 退出信号处理程序，信号屏蔽字会发生什么？答案取决于特定 UNIX 实现的血统。在 System V 下，*longjmp()*
    不会恢复信号屏蔽字，因此在退出处理程序时，阻塞的信号不会被解除阻塞。Linux 遵循 System V 的行为。（这通常不是我们想要的，因为它会将导致调用处理程序的信号保持阻塞。）在
    BSD 派生的实现中，*setjmp()* 将信号屏蔽字保存在其 *env* 参数中，并且 *longjmp()* 会恢复保存的信号屏蔽字。（BSD 派生的实现还提供了两个其他函数，*_setjmp()*
    和 *_longjmp()*，它们遵循 System V 语义。）换句话说，我们不能在移植时使用 *longjmp()* 退出信号处理程序。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we define the `_BSD_SOURCE` feature test macro when compiling a program,
    then (the *glibc*) *setjmp()* follows the BSD semantics.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在编译程序时定义了 `_BSD_SOURCE` 特性测试宏，那么 (*glibc*) *setjmp()* 将遵循 BSD 语义。
- en: Because of this difference in the two main UNIX variants, POSIX.1-1990 chose
    not to specify the handling of the signal mask by *setjmp()* and *longjmp()*.
    Instead, it defined a pair of new functions, *sigsetjmp()* and *siglongjmp()*,
    that provide explicit control of the signal mask when performing a nonlocal goto.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个主要 UNIX 变种之间的差异，POSIX.1-1990 选择不指定 *setjmp()* 和 *longjmp()* 处理信号屏蔽字的方式。相反，它定义了一对新函数
    *sigsetjmp()* 和 *siglongjmp()*，这些函数在执行非局部跳转时提供对信号屏蔽字的显式控制。
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on initial call, nonzero on return via *siglongjmp()*
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 初始调用时返回 0，通过 *siglongjmp()* 返回时返回非零值
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *sigsetjmp()* and *siglongjmp()* functions operate similarly to *setjmp()*
    and *longjmp()*. The only differences are in the type of the *env* argument (*sigjmp_buf*
    instead of *jmp_buf*) and the extra *savesigs* argument to *sigsetjmp()*. If *savesigs*
    is nonzero, then the process signal mask that is current at the time of the *sigsetjmp()*
    call is saved in *env* and restored by a later *siglongjmp()* call specifying
    the same *env* argument. If *savesigs* is 0, then the process signal mask is not
    saved and restored.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigsetjmp()* 和 *siglongjmp()* 函数的操作类似于 *setjmp()* 和 *longjmp()*。唯一的不同在于 *env*
    参数的类型（*sigjmp_buf* 替代了 *jmp_buf*）以及 *sigsetjmp()* 的额外 *savesigs* 参数。如果 *savesigs*
    非零，则在调用 *sigsetjmp()* 时，当前进程的信号屏蔽字将保存在 *env* 中，并在稍后的 *siglongjmp()* 调用时通过相同的 *env*
    参数恢复。如果 *savesigs* 为 0，则信号屏蔽字不会被保存和恢复。'
- en: The *longjmp()* and *siglongjmp()* functions are not listed among the async-signal-safe
    functions in [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa "Table 21-1. Functions
    required to be async-signal-safe by POSIX.1-1990, SUSv2, and SUSv3"). This is
    because calling any non-async-signal-safe function after performing a nonlocal
    goto carries the same risks as calling that function from within the signal handler.
    Furthermore, if a signal handler interrupts the main program while it is part-way
    through updating a data structure, and the handler exits by performing a nonlocal
    goto, then the incomplete update may leave that data structure in an inconsistent
    state. One technique that can help to avoid problems is to use *sigprocmask()*
    to temporarily block the signal while sensitive updates are being performed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*longjmp()* 和 *siglongjmp()* 函数没有列在 [表 21-1](ch21.html#functions_required_to_be_async-signal-sa
    "表 21-1. POSIX.1-1990、SUSv2 和 SUSv3 要求是异步信号安全的函数") 中。这是因为在执行非局部跳转后调用任何非异步信号安全的函数，存在与从信号处理程序中调用该函数相同的风险。此外，如果信号处理程序在主程序更新数据结构的过程中被中断，并且处理程序通过非局部跳转退出，那么未完成的更新可能会导致数据结构处于不一致的状态。一个可以帮助避免问题的技术是使用
    *sigprocmask()* 暂时阻塞信号，以便在执行敏感更新时保护数据。'
- en: Example program
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 21-2](ch21.html#performing_a_nonlocal_goto_from_a_si "Example 21-2. Performing
    a nonlocal goto from a signal handler") demonstrates the difference in signal
    mask handling for the two types of nonlocal gotos. This program establishes a
    handler for `SIGINT`. The program is designed to allow either *setjmp()* plus
    *longjmp()* or *sigsetjmp()* plus *siglongjmp()* to be used to exit the signal
    handler, depending on whether the program is compiled with the `USE_SIGSETJMP`
    macro defined. The program displays the current settings of the signal mask both
    on entry to the signal handler and after the nonlocal goto has transferred control
    from the handler back to the main program.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-2](ch21.html#performing_a_nonlocal_goto_from_a_si "示例 21-2. 从信号处理程序执行非局部跳转")演示了两种非局部跳转在信号屏蔽处理上的区别。该程序为
    `SIGINT` 建立了一个信号处理程序。程序设计允许使用 *setjmp()* 加 *longjmp()* 或 *sigsetjmp()* 加 *siglongjmp()*
    来退出信号处理程序，具体取决于程序是否在编译时定义了 `USE_SIGSETJMP` 宏。该程序在进入信号处理程序时以及非局部跳转将控制从处理程序转回主程序后，显示信号屏蔽的当前设置。'
- en: 'When we build the program so that *longjmp()* is used to exit the signal handler,
    this is what we see when we run the program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建程序，使得*longjmp()*用于退出信号处理程序时，这是我们运行程序时看到的输出：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the program output, we can see that, after a *longjmp()* from the signal
    handler, the signal mask remains set to the value to which it was set on entry
    to the signal handler.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序输出中，我们可以看到，在从信号处理程序执行*longjmp()*后，信号屏蔽保持为进入信号处理程序时所设置的值。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the above shell session, we built the program using the makefile supplied
    with the source code distribution for this book. The *-s* option tells *make*
    not to echo the commands that it is executing. We use this option to avoid cluttering
    the session log. ([Mecklenburg, 2005] provides a description of the GNU *make*
    program.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的 shell 会话中，我们使用本书随附的源代码分发包中的 makefile 构建了程序。* -s* 选项告诉*make*不要回显它正在执行的命令。我们使用此选项来避免使会话日志杂乱无章。（[Mecklenburg,
    2005] 提供了关于 GNU *make* 程序的描述。）
- en: 'When we compile the same source file to build an executable that uses *siglongjmp()*
    to exit the handler, we see the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译相同的源文件，构建一个使用 *siglongjmp()* 来退出处理程序的可执行文件时，我们看到如下输出：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, `SIGINT` is not blocked, because *siglongjmp()* restored the
    signal mask to its original state. Next, we type *Control-C* again, so that the
    handler is once more invoked:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`SIGINT`没有被阻塞，因为 *siglongjmp()* 恢复了信号屏蔽到原始状态。接下来，我们再次输入 *Control-C*，以便信号处理程序再次被调用：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the above output, we can see that *siglongjmp()* restores the signal mask
    to the value it had at the time of the *sigsetjmp()* call (i.e., an empty signal
    set).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们可以看到 *siglongjmp()* 将信号屏蔽恢复为在 *sigsetjmp()* 调用时的值（即一个空的信号集）。
- en: '[Example 21-2](ch21.html#performing_a_nonlocal_goto_from_a_si "Example 21-2. Performing
    a nonlocal goto from a signal handler") also demonstrates a useful technique for
    use with a signal handler that performs a nonlocal goto. Because a signal can
    be generated at any time, it may actually occur before the target of the goto
    has been set up by *sigsetjmp()* (or *setjmp()*). To prevent this possibility
    (which would cause the handler to perform a nonlocal goto using an uninitialized
    *env* buffer), we employ a guard variable, *canJump*, to indicate whether the
    *env* buffer has been initialized. If *canJump* is false, then instead of doing
    a nonlocal goto, the handler simply returns. An alternative approach is to arrange
    the program code so that the call to *sigsetjmp()* (or *setjmp()*) occurs before
    the signal handler is established. However, in complex programs, it may be difficult
    to ensure that these two steps are performed in that order, and the use of a guard
    variable may be simpler.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-2](ch21.html#performing_a_nonlocal_goto_from_a_si "示例 21-2. 从信号处理程序执行非局部跳转")还演示了一种用于信号处理程序的有用技术，该处理程序执行非局部跳转。由于信号可以在任何时候产生，它实际上可能在目标跳转尚未由
    *sigsetjmp()*（或 *setjmp()*) 设置之前就发生。为了防止这种情况（这会导致处理程序使用未初始化的 *env* 缓冲区执行非局部跳转），我们使用一个守卫变量
    *canJump* 来指示 *env* 缓冲区是否已初始化。如果 *canJump* 为 false，则处理程序会简单地返回，而不是执行非局部跳转。另一种方法是安排程序代码，使得调用
    *sigsetjmp()*（或 *setjmp()*）发生在建立信号处理程序之前。然而，在复杂程序中，确保这两个步骤按顺序执行可能比较困难，使用守卫变量可能会更简单。'
- en: 'Note that using `#ifdef` was the simplest way of writing the program in [Example 21-2](ch21.html#performing_a_nonlocal_goto_from_a_si
    "Example 21-2. Performing a nonlocal goto from a signal handler") in a standards-conformant
    fashion. In particular, we could not have replaced the `#ifdef` with the following
    run-time check:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[示例 21-2](ch21.html#performing_a_nonlocal_goto_from_a_si "示例 21-2. 从信号处理程序执行非本地跳转")中，使用`#ifdef`是以符合标准的方式编写程序的最简单方法。特别是，我们无法将`#ifdef`替换为以下运行时检查：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is not permitted because SUSv3 doesn’t allow *setjmp()* and *sigsetjmp()*
    to be used within an assignment statement (see [Performing a Nonlocal Goto: *setjmp()*
    and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp "Performing
    a Nonlocal Goto: setjmp() and long jmp()")).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不允许的，因为SUSv3不允许在赋值语句中使用*setjmp()*和*sigsetjmp()*（参见[执行非本地跳转：*setjmp()*和*long
    jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp "执行非本地跳转：setjmp()和long
    jmp()")）。
- en: Example 21-2. Performing a nonlocal goto from a signal handler
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 21-2. 从信号处理程序执行非本地跳转
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Terminating a Process Abnormally: *abort()*'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常终止进程：*abort()*
- en: The *abort()* function terminates the calling process and causes it to produce
    a core dump.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*abort()*函数终止调用进程并生成核心转储。'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The *abort()* function terminates the calling process by raising a `SIGABRT`
    signal. The default action for `SIGABRT` is to produce a core dump file and terminate
    the process. The core dump file can then be used within a debugger to examine
    the state of the program at the time of the *abort()* call.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*abort()*函数通过触发`SIGABRT`信号终止调用进程。`SIGABRT`的默认操作是生成核心转储文件并终止进程。然后可以在调试器中使用核心转储文件检查程序在*abort()*调用时的状态。'
- en: 'SUSv3 requires that *abort()* override the effect of blocking or ignoring `SIGABRT`.
    Furthermore, SUSv3 specifies that *abort()* must terminate the process unless
    the process catches the signal with a handler that doesn’t return. This last statement
    requires a moment’s thought. Of the methods of terminating a signal handler described
    in [Other Methods of Terminating a Signal Handler](ch21.html#other_methods_of_terminating_a_signal_ha
    "Other Methods of Terminating a Signal Handler"), the one that is relevant here
    is the use of a nonlocal goto to exit the handler. If this is done, then the effect
    of *abort()* will be nullified; otherwise, *abort()* always terminates the process.
    In most implementations, termination is guaranteed as follows: if the process
    still hasn’t terminated after raising `SIGABRT` once (i.e., a handler catches
    the signal and returns, so that execution of *abort()* is resumed), *abort()*
    resets the handling of `SIGABRT` to `SIG_DFL` and raises a second `SIGABRT`, which
    is guaranteed to kill the process.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求*abort()*覆盖阻塞或忽略`SIGABRT`信号的效果。此外，SUSv3规定，除非进程通过一个不会返回的处理程序捕获信号，否则*abort()*必须终止进程。最后这一点值得深思。在[终止信号处理程序的其他方法](ch21.html#other_methods_of_terminating_a_signal_ha
    "终止信号处理程序的其他方法")中描述的终止信号处理程序的方法中，相关的方法是使用非本地跳转退出处理程序。如果这样做，*abort()*的效果将被取消；否则，*abort()*始终会终止进程。在大多数实现中，终止是通过以下方式保证的：如果进程在第一次触发`SIGABRT`信号后仍未终止（即，处理程序捕获信号并返回，导致*abort()*的执行继续），则*abort()*会将`SIGABRT`的处理恢复为`SIG_DFL`，并触发第二次`SIGABRT`，从而保证终止进程。
- en: If *abort()* does successfully terminate the process, then it also flushes and
    closes *stdio* streams.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*abort()*确实成功终止进程，它还会刷新并关闭*stdio*流。
- en: An example of the use of *abort()* is provided in the error-handling functions
    of [Example 3-3](ch03.html#error-handling_functions_used_by_all_pro "Example 3-3. Error-handling
    functions used by all programs"), in [Functions for parsing numeric command-line
    arguments](ch03.html#functions_for_parsing_numeric_command-li "Functions for parsing
    numeric command-line arguments").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 3-3](ch03.html#error-handling_functions_used_by_all_pro "示例 3-3. 所有程序使用的错误处理函数")中提供了*abort()*使用的示例，在[解析数字命令行参数的函数](ch03.html#functions_for_parsing_numeric_command-li
    "解析数字命令行参数的函数")中也有示例。
- en: 'Handling a Signal on an Alternate Stack: *sigaltstack()*'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在备用栈上处理信号：*sigaltstack()*
- en: Normally, when a signal handler is invoked, the kernel creates a frame for it
    on the process stack. However, this may not be possible if a process attempts
    to extend the stack beyond the maximum possible size. For example, this may occur
    because the stack grows so large that it encounters a region of mapped memory
    ([Location of Shared Memory in Virtual Memory](ch48.html#location_of_shared_memory_in_virtual_mem
    "Location of Shared Memory in Virtual Memory")) or the upwardly growing heap,
    or it reaches the `RLIMIT_STACK` resource limit ([Details of Specific Resource
    Limits](ch36.html#details_of_specific_resource_limits "Details of Specific Resource
    Limits")).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当信号处理程序被调用时，内核会在进程栈上为其创建一个栈帧。然而，如果进程试图将栈扩展到超过最大可能大小，这可能不可行。例如，这可能是由于栈增长过大，导致其遇到映射内存区域（[虚拟内存中的共享内存位置](ch48.html#location_of_shared_memory_in_virtual_mem
    "虚拟内存中的共享内存位置")）或向上增长的堆，或者达到 `RLIMIT_STACK` 资源限制（[具体资源限制详情](ch36.html#details_of_specific_resource_limits
    "具体资源限制详情")）。
- en: When a process attempts to grow its stack beyond the maximum possible size,
    the kernel generates a `SIGSEGV` signal for the process. However, since the stack
    space is exhausted, the kernel can’t create a frame for any `SIGSEGV` handler
    that the program may have established. Consequently, the handler is not invoked,
    and the process is terminated (the default action for `SIGSEGV`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程试图将其栈扩展到超过最大可能大小时，内核会为该进程生成 `SIGSEGV` 信号。然而，由于栈空间已耗尽，内核无法为程序可能已建立的任何 `SIGSEGV`
    处理程序创建栈帧。因此，处理程序不会被调用，进程会被终止（`SIGSEGV` 的默认行为）。
- en: 'If we instead need to ensure that the `SIGSEGV` signal is handled in these
    circumstances, we can do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要确保在这些情况下处理 `SIGSEGV` 信号，可以执行以下操作：
- en: Allocate an area of memory, called an *alternate signal stack*, to be used for
    the stack frame of a signal handler.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一块内存区域，称为 *备用信号栈*，用于信号处理程序的栈帧。
- en: Use the *sigaltstack()* system call to inform the kernel of the existence of
    the alternate signal stack.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *sigaltstack()* 系统调用通知内核存在备用信号栈。
- en: When establishing the signal handler, specify the `SA_ONSTACK` flag, to tell
    the kernel that the frame for this handler should be created on the alternate
    stack.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在建立信号处理程序时，指定 `SA_ONSTACK` 标志，以告诉内核此处理程序的栈帧应创建在备用栈上。
- en: The *sigaltstack()* system call both establishes an alternate signal stack and
    returns information about any alternate signal stack that is already established.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigaltstack()* 系统调用既建立备用信号栈，又返回有关已建立的备用信号栈的相关信息。'
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'The *sigstack* argument points to a structure specifying the location and attributes
    of the new alternate signal stack. The *old_sigstack* argument points to a structure
    used to return information about the previously established alternate signal stack
    (if there was one). Either one of these arguments can be specified as `NULL`.
    For example, we can find out about the existing alternate signal stack, without
    changing it, by specifying `NULL` for the *sigstack* argument. Otherwise, each
    of these arguments points to a structure of the following type:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigstack* 参数指向一个结构，指定新备用信号栈的位置和属性。*old_sigstack* 参数指向一个结构，用于返回有关先前建立的备用信号栈的信息（如果存在）。这两个参数中的任何一个都可以指定为
    `NULL`。例如，我们可以通过指定 *sigstack* 参数为 `NULL`，在不更改现有备用信号栈的情况下获取相关信息。否则，这些参数中的每一个都指向以下类型的结构：'
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The *ss_sp* and *ss_size* fields specify the size and location of the alternate
    signal stack. When actually using the alternate signal stack, the kernel automatically
    takes care of aligning the value given in *ss_sp* to an address boundary that
    is suitable for the hardware architecture.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*ss_sp* 和 *ss_size* 字段指定备用信号栈的大小和位置。在实际使用备用信号栈时，内核会自动将 *ss_sp* 中给定的值对齐到适合硬件架构的地址边界。'
- en: Typically, the alternate signal stack is either statically allocated or dynamically
    allocated on the heap. SUSv3 specifies the constant `SIGSTKSZ` to be used as a
    typical value when sizing the alternate stack, and `MINSIGSTKSZ` as the minimum
    size required to invoke a signal handler. On Linux/x86-32, these constants are
    defined with the values 8192 and 2048, respectively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，备用信号栈要么是静态分配的，要么是动态分配在堆上的。SUSv3 指定常量 `SIGSTKSZ` 作为确定备用栈大小的典型值，`MINSIGSTKSZ`
    作为调用信号处理程序所需的最小大小。在 Linux/x86-32 上，这些常量的值分别定义为 8192 和 2048。
- en: The kernel doesn’t resize an alternate signal stack. If the stack overflows
    the space we have allocated for it, then chaos results (e.g., overwriting of variables
    beyond the limits of the stack). This is not usually a problem—because we normally
    use an alternate signal stack to handle the special case of the standard stack
    overflowing, typically only one or a few frames are allocated on the stack. The
    job of the `SIGSEGV` handler is either to perform some cleanup and terminate the
    process or to unwind the standard stack using a nonlocal goto.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内核不会调整备用信号栈的大小。如果栈溢出我们为其分配的空间，将会导致混乱（例如，栈外的变量被覆盖）。这通常不是一个问题——因为我们通常使用备用信号栈来处理标准栈溢出的特殊情况，通常只会为栈分配一两个帧。`SIGSEGV`处理程序的工作是执行一些清理工作并终止进程，或者使用非局部跳转解开标准栈。
- en: 'The *ss_flags* field contains one of the following values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*ss_flags*字段包含以下值之一：'
- en: '`SS_ONSTACK`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`SS_ONSTACK`'
- en: If this flag is set when retrieving information about the currently established
    alternate signal stack (*old_sigstack*), it indicates that the process is currently
    executing on the alternate signal stack. Attempts to establish a new alternate
    signal stack while the process is already running on an alternate signal stack
    result in an error (`EPERM`) from *sigaltstack()*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在获取当前已建立的备用信号栈信息（*old_sigstack*）时设置此标志，表示进程当前正在备用信号栈上执行。在进程已经在备用信号栈上运行时，尝试建立新的备用信号栈将导致*sigaltstack()*返回错误（`EPERM`）。
- en: '`SS_DISABLE`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`SS_DISABLE`'
- en: Returned in *old_sigstack*, this flag indicates that there is no currently established
    alternate signal stack. When specified in *sigstack*, this disables a currently
    established alternate signal stack.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*old_sigstack*中返回的这个标志表示当前没有建立备用信号栈。当在*sigstack*中指定时，它会禁用当前已建立的备用信号栈。
- en: '[Example 21-3](ch21.html#using_sigaltstack_open_parenthesis_close "Example 21-3. Using
    sigaltstack()") demonstrates the establishment and use of an alternate signal
    stack. After establishing an alternate signal stack and a handler for `SIGSEGV`,
    this program calls a function that infinitely recurses, so that the stack overflows
    and the process is sent a `SIGSEGV` signal. When we run the program, this is what
    we see:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-3](ch21.html#using_sigaltstack_open_parenthesis_close "示例 21-3. 使用 sigaltstack()")展示了备用信号栈的建立和使用。在建立备用信号栈和`SIGSEGV`的处理程序后，这个程序调用一个无限递归的函数，导致栈溢出并向进程发送`SIGSEGV`信号。运行该程序时，我们看到如下输出：'
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this shell session, the *ulimit* command is used to remove any `RLIMIT_STACK`
    resource limit that may have been set in the shell. We explain this resource limit
    in Section 36.3.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 shell 会话中，使用*ulimit*命令移除了任何可能在 shell 中设置的`RLIMIT_STACK`资源限制。我们将在第36.3节解释这个资源限制。
- en: Example 21-3. Using *sigaltstack()*
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 21-3. 使用*sigaltstack()*
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `SA_SIGINFO` Flag
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SA_SIGINFO` 标志'
- en: 'Setting the `SA_SIGINFO` flag when establishing a handler with *sigaction()*
    allows the handler to obtain additional information about a signal when it is
    delivered. In order to obtain this information, we must declare the handler as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*sigaction()*建立处理程序时设置`SA_SIGINFO`标志，可以使处理程序在信号传递时获取附加的信号信息。为了获取这些信息，我们必须按如下方式声明处理程序：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first argument, *sig*, is the signal number, as for a standard signal handler.
    The second argument, *siginfo*, is a structure used to provide the additional
    information about the signal. We describe this structure below. The last argument,
    *ucontext*, is also described below.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，*sig*，是信号号码，类似于标准信号处理程序中的信号号码。第二个参数，*siginfo*，是一个结构体，用于提供有关信号的附加信息。我们将在下文描述这个结构。最后一个参数，*ucontext*，也将在下文描述。
- en: 'Since the above signal handler has a different prototype from a standard signal
    handler, C typing rules mean that we can’t use the *sa_handler* field of the *sigaction*
    structure to specify the address of the handler. Instead, we must use an alternative
    field: *sa_sigaction*. In other words, the definition of the *sigaction* structure
    is somewhat more complex than was shown in [Changing Signal Dispositions: *sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "Changing Signal Dispositions: sigaction()"). In full, the structure is defined
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述信号处理程序与标准信号处理程序的原型不同，C语言的类型规则意味着我们不能使用*sigaction*结构的*sa_handler*字段来指定处理程序的地址。相反，我们必须使用一个替代字段：*sa_sigaction*。换句话说，*sigaction*结构的定义比在[改变信号处理：*sigaction*()](ch20.html#changing_signal_dispositions_colon_sigac
    "改变信号处理：sigaction()")中显示的更为复杂。完整的结构定义如下：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The *sigaction* structure uses a union to combine the *sa_sigaction* and *sa_handler*
    fields. (Most other UNIX implementations similarly use a union for this purpose.)
    Using a union is possible because only one of these fields is required during
    a particular call to *sigaction()*. (However, this can lead to strange bugs if
    we naively expect to be able to set the *sa_handler* and *sa_sigaction* fields
    independently of one another, perhaps because we reuse a single *sigaction* structure
    in multiple *sigaction()* calls to establish handlers for different signals.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigaction*结构使用联合体将*sa_sigaction*和*sa_handler*字段组合起来。（大多数其他UNIX实现也类似地使用联合体来实现这一目的。）使用联合体是可能的，因为在对*sigaction()*的特定调用中，仅需要其中一个字段。（然而，如果我们天真地期望能够独立设置*sa_handler*和*sa_sigaction*字段，可能会导致奇怪的错误，尤其是在我们在多个*sigaction()*调用中重用同一个*sigaction*结构来为不同的信号建立处理程序时。）'
- en: 'Here is an example of the use of `SA_SIGINFO` to establish a signal handler:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`SA_SIGINFO`建立信号处理程序的一个示例：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For complete examples of the use of the `SA_SIGINFO` flag, see [Example 22-3](ch22.html#handling_realtime_signals-id1
    "Example 22-3. Handling realtime signals") (page 462) and [Example 23-5](ch23.html#posix_timer_notification_using_a_signal
    "Example 23-5. POSIX timer notification using a signal") (page 500).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_SIGINFO`标志的完整使用示例，请参见[示例 22-3](ch22.html#handling_realtime_signals-id1
    "示例 22-3. 处理实时信号")（第462页）和[示例 23-5](ch23.html#posix_timer_notification_using_a_signal
    "示例 23-5. 使用信号的POSIX定时器通知")（第500页）。'
- en: The *siginfo_t* structure
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*siginfo_t*结构'
- en: 'The *siginfo_t* structure passed as the second argument to a signal handler
    that is established with `SA_SIGINFO` has the following form:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SA_SIGINFO`建立的信号处理程序中作为第二个参数传递的*siginfo_t*结构具有以下形式：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `_POSIX_C_SOURCE` feature test macro must be defined with a value greater
    than or equal to 199309 in order to make the declaration of the *siginfo_t* structure
    visible from `<signal.h>`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 必须定义`_POSIX_C_SOURCE`功能测试宏，并且其值必须大于或等于199309，以便使*siginfo_t*结构的声明在`<signal.h>`中可见。
- en: On Linux, as on most UNIX implementations, many of the fields in the *siginfo_t*
    structure are combined into a union, since not all of the fields are needed for
    each signal. (See `<bits/siginfo.h>` for details.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，与大多数UNIX实现一样，*siginfo_t*结构中的许多字段被组合成一个联合体，因为并非所有字段都需要用于每个信号。（有关详细信息，请参见`<bits/siginfo.h>`。）
- en: 'Upon entry to a signal handler, the fields of the *siginfo_t* structure are
    set as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 进入信号处理程序时，*siginfo_t*结构的字段设置如下：
- en: '*si_signo*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_signo*'
- en: This field is set for all signals. It contains the number of the signal causing
    invocation of the handler—that is, the same value as the *sig* argument to the
    handler.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段对所有信号都设置。它包含导致调用处理程序的信号的编号——即与传递给处理程序的*sig*参数相同的值。
- en: '*si_code*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_code*'
- en: This field is set for all signals. It contains a code providing further information
    about the origin of the signal, as shown in [Table 21-2](ch21.html#values_returned_in_the_si_underscore_cod
    "Table 21-2. Values returned in the si_code field of the siginfo_t structure").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段对所有信号都设置。它包含一个代码，提供有关信号来源的进一步信息，如[表 21-2](ch21.html#values_returned_in_the_si_underscore_cod
    "表 21-2. siginfo_t结构中的si_code字段返回的值")所示。
- en: '*si_value*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_value*'
- en: This field contains the accompanying data for a signal sent via *sigqueue()*.
    We describe *sigqueue()* in [Limits on the number of queued realtime signals](ch22.html#limits_on_the_number_of_queued_real-id1
    "Limits on the number of queued realtime signals").
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含通过*sigqueue()*发送的信号的附加数据。我们在[排队实时信号的数量限制](ch22.html#limits_on_the_number_of_queued_real-id1
    "排队实时信号的数量限制")中描述了*sigqueue()*。
- en: '*si_pid*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_pid*'
- en: For signals sent via *kill()* or *sigqueue()*, this field is set to the process
    ID of the sending process.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过*kill()*或*sigqueue()*发送的信号，该字段设置为发送进程的进程ID。
- en: '*si_uid*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_uid*'
- en: 'For signals sent via *kill()* or *sigqueue()*, this field is set to the real
    user ID of the sending process. The system provides the real user ID of the sending
    process because that is more informative than providing the effective user ID.
    Consider the permission rules for sending signals described in [Sending Signals:
    *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe "Sending Signals:
    kill()"): if the effective user ID grants the sender permission to send the signal,
    then that user ID must either be 0 (i.e., a privileged process), or be the same
    as the real user ID or saved set-user-ID of the receiving process. In this case,
    it could be useful for the receiver to know the sender’s real user ID, which may
    be different from the effective user ID (e.g., if the sender is a set-user-ID
    program).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过 *kill()* 或 *sigqueue()* 发送的信号，此字段设置为发送进程的实际用户 ID。系统提供发送进程的实际用户 ID，因为它比提供有效用户
    ID 更具信息性。考虑发送信号时的权限规则，如[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "发送信号：kill()")中所述：如果有效用户 ID 授予发送者发送信号的权限，那么该用户 ID 必须是 0（即具有特权的进程），或者与接收进程的实际用户
    ID 或保存的设置用户 ID 相同。在这种情况下，对于接收者来说，知道发送者的实际用户 ID 可能会有帮助，因为它可能与有效用户 ID 不同（例如，如果发送者是设置用户
    ID 的程序）。
- en: '*si_errno*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_errno*'
- en: If this field is set to a nonzero value, then it contains an error number (like
    *errno*) that identifies the cause of the signal. This field is generally unused
    on Linux.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此字段设置为非零值，则它包含一个错误号（类似于 *errno*），用于标识信号的原因。此字段通常在 Linux 上未使用。
- en: '*si_addr*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_addr*'
- en: This field is set only for hardware-generated `SIGBUS`, `SIGSEGV`, `SIGILL`,
    and `SIGFPE` signals. For the `SIGBUS` and `SIGSEGV` signals, this field contains
    the address that caused the invalid memory reference. For the `SIGILL` and `SIGFPE`
    signals, this field contains the address of the program instruction that caused
    the signal.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段仅在硬件生成的 `SIGBUS`、`SIGSEGV`、`SIGILL` 和 `SIGFPE` 信号的情况下设置。对于 `SIGBUS` 和 `SIGSEGV`
    信号，此字段包含导致无效内存引用的地址。对于 `SIGILL` 和 `SIGFPE` 信号，此字段包含导致信号的程序指令的地址。
- en: 'The following fields, which are nonstandard Linux extensions, are set only
    on the delivery of a signal generated on expiration of a POSIX timer (see [POSIX
    Interval Timers](ch23.html#posix_interval_timers "POSIX Interval Timers")):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字段为非标准 Linux 扩展，仅在 POSIX 定时器到期时生成的信号传递时设置（参见[POSIX 间隔定时器](ch23.html#posix_interval_timers
    "POSIX 间隔定时器")）：
- en: '*si_timerid*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_timerid*'
- en: This field contains an ID that the kernel uses internally to identify the timer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含内核用于内部标识定时器的 ID。
- en: '*si_overrun*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_overrun*'
- en: This field is set to the overrun count for the timer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段设置为定时器的溢出计数。
- en: 'The following two fields are set only for the delivery of a `SIGIO` signal
    ([Signal-Driven I/O](ch63.html#signal-driven_i_solidus_o "Signal-Driven I/O")):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个字段仅在发送 `SIGIO` 信号时设置（[信号驱动 I/O](ch63.html#signal-driven_i_solidus_o "信号驱动
    I/O")）：
- en: '*si_band*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_band*'
- en: This field contains the “band event” value associated with the I/O event. (In
    versions of *glibc* up until 2.3.2, *si_band* was typed as *int*.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含与 I/O 事件关联的“带事件”值。（在 *glibc* 版本 2.3.2 之前，*si_band* 的类型为 *int*。）
- en: '*si_fd*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_fd*'
- en: This field contains the number of the file descriptor associated with the I/O
    event. This field is not specified in SUSv3, but it is present on many other implementations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含与 I/O 事件关联的文件描述符的编号。此字段在 SUSv3 中没有定义，但在许多其他实现中存在。
- en: 'The following fields are set only for the delivery of a `SIGCHLD` signal ([The
    `SIGCHLD` Signal](ch26.html#the_sigchld_signal "The SIGCHLD Signal")):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字段仅在发送 `SIGCHLD` 信号时设置（[`SIGCHLD` 信号](ch26.html#the_sigchld_signal "SIGCHLD
    信号")）：
- en: '*si_status*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_status*'
- en: This field contains either the exit status of the child (if *si_code* is `CLD_EXITED`)
    or the number of the signal sent to the child (i.e., the number of the signal
    that terminated or stopped the child, as described in [The Wait Status Value](ch26.html#the_wait_status_value
    "The Wait Status Value")).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含子进程的退出状态（如果 *si_code* 为 `CLD_EXITED`），或者发送到子进程的信号的编号（即终止或暂停子进程的信号的编号，如[等待状态值](ch26.html#the_wait_status_value
    "等待状态值")中所述）。
- en: '*si_utime*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_utime*'
- en: This field contains the user CPU time used by the child process. In kernels
    before 2.6, and since 2.6.27, this is measured in system clock ticks (divide by
    *sysconf(_SC_CLK_TCK)*). In 2.6 kernels before 2.6.27, a bug meant that this field
    reported times measured in (user-configurable) jiffies (see [The Software Clock
    (Jiffies)](ch10.html#the_software_clock_open_parenthesis_jiff "The Software Clock
    (Jiffies)")). This field is not specified in SUSv3, but it is present on many
    other implementations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含子进程使用的用户 CPU 时间。在 2.6 版本之前的内核中，以及 2.6.27 版本以来，使用系统时钟刻度（除以 *sysconf(_SC_CLK_TCK)*）。在
    2.6 内核的 2.6.27 之前版本中，由于一个 bug，此字段报告以（用户可配置的）时钟滴答（参见 [软件时钟（时钟滴答）](ch10.html#the_software_clock_open_parenthesis_jiff
    "软件时钟（时钟滴答）")）为单位的时间。此字段在 SUSv3 中没有指定，但它在许多其他实现中存在。
- en: '*si_stime*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_stime*'
- en: This field contains the system CPU time used by the child process. See the description
    of the *si_utime* field. This field is not specified in SUSv3, but it is present
    on many other implementations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含子进程使用的系统 CPU 时间。请参见 *si_utime* 字段的描述。此字段在 SUSv3 中没有指定，但它在许多其他实现中存在。
- en: The *si_code* field provides further information about the origin of the signal,
    using the values shown in [Table 21-2](ch21.html#values_returned_in_the_si_underscore_cod
    "Table 21-2. Values returned in the si_code field of the siginfo_t structure").
    Not all of the signal-specific values shown in the second column of this table
    occur on all UNIX implementations and hardware architectures (especially in the
    case of the four hardware-generated signals `SIGBUS`, `SIGSEGV`, `SIGILL`, and
    `SIGFPE`), although all of these constants are defined on Linux and most appear
    in SUSv3.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*si_code* 字段提供有关信号来源的进一步信息，使用的值显示在 [表 21-2](ch21.html#values_returned_in_the_si_underscore_cod
    "表 21-2. 在 siginfo_t 结构体的 si_code 字段中返回的值") 中。并非表中第二列中显示的所有信号特定值都出现在所有 UNIX 实现和硬件架构中（尤其是在四个硬件生成的信号
    `SIGBUS`、`SIGSEGV`、`SIGILL` 和 `SIGFPE` 的情况下），尽管这些常量在 Linux 上都已定义，并且大多数出现在 SUSv3
    中。'
- en: 'Note the following additional points about the values shown in [Table 21-2](ch21.html#values_returned_in_the_si_underscore_cod
    "Table 21-2. Values returned in the si_code field of the siginfo_t structure"):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下关于 [表 21-2](ch21.html#values_returned_in_the_si_underscore_cod "表 21-2.
    在 siginfo_t 结构体的 si_code 字段中返回的值") 中显示的值的附加说明：
- en: The values `SI_KERNEL` and `SI_SIGIO` are Linux-specific. They are not specified
    in SUSv3 and do not appear on other UNIX implementations.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 `SI_KERNEL` 和 `SI_SIGIO` 是 Linux 特有的。它们在 SUSv3 中没有指定，并且在其他 UNIX 实现中没有出现。
- en: '`SI_SIGIO` is employed only in Linux 2.2\. From kernel 2.4 onward, Linux instead
    employs the `POLL_*` constants shown in the table.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SI_SIGIO` 仅在 Linux 2.2 中使用。从内核 2.4 版本起，Linux 使用表中显示的 `POLL_*` 常量。'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'SUSv4 specifies the *psiginfo()* function, whose purpose is similar to *psignal()*
    ([Displaying Signal Descriptions](ch20.html#displaying_signal_descriptions "Displaying
    Signal Descriptions")). The *psiginfo()* function takes two arguments: a pointer
    to a *siginfo_t* structure and a message string. It prints the message string
    on standard error, followed by information about the signal described in the *siginfo_t*
    structure. The *psiginfo()* function is provided by *glibc* since version 2.10\.
    The *glibc* implementation prints the signal description, the origin of the signal
    (as indicated by the *si_code* field), and, for some signals, other fields from
    the *siginfo_t* structure. The *psiginfo()* function is new in SUSv4, and it is
    not available on all systems.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv4 指定了 *psiginfo()* 函数，其作用与 *psignal()* 相似（参见 [显示信号描述](ch20.html#displaying_signal_descriptions
    "显示信号描述")）。*psiginfo()* 函数接受两个参数：一个指向 *siginfo_t* 结构体的指针和一个消息字符串。它将在标准错误上打印消息字符串，接着打印
    *siginfo_t* 结构体中描述的信号信息。*psiginfo()* 函数自 glibc 2.10 版本以来由 *glibc* 提供。*glibc* 实现打印信号描述、信号来源（由
    *si_code* 字段指示），以及对于某些信号，*siginfo_t* 结构体中的其他字段。*psiginfo()* 函数在 SUSv4 中新增，并非所有系统都支持该函数。
- en: Table 21-2. Values returned in the *si_code* field of the *siginfo_t* structure
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-2. 在 *siginfo_t* 结构体的 *si_code* 字段中返回的值
- en: '| Signal | *si_code* value | Origin of signal |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 信号 | *si_code* 值 | 信号来源 |'
- en: '| --- | --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Any | `SI_ASYNCIO` | Completion of an asynchronous I/O (AIO) operation |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 任意 | `SI_ASYNCIO` | 异步 I/O（AIO）操作完成 |'
- en: '|   | `SI_KERNEL` | Sent by the kernel (e.g., a signal from terminal driver)
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|   | `SI_KERNEL` | 由内核发送（例如，来自终端驱动程序的信号） |'
- en: '|   | `SI_MESGQ` | Message arrival on POSIX message queue (since Linux 2.6.6)
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|   | `SI_MESGQ` | POSIX 消息队列上的消息到达（自 Linux 2.6.6 起） |'
- en: '|   | `SI_QUEUE` | A realtime signal from a user process via *sigqueue()* |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|   | `SI_QUEUE` | 通过 *sigqueue()* 发送的实时信号来自用户进程 |'
- en: '|   | `SI_SIGIO` | `SIGIO` signal (Linux 2.2 only) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|   | `SI_SIGIO` | `SIGIO` 信号（仅适用于 Linux 2.2） |'
- en: '|   | `SI_TIMER` | Expiration of a POSIX (realtime) timer |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|   | `SI_TIMER` | POSIX（实时）定时器到期 |'
- en: '|   | `SI_TKILL` | A user process via *tkill()* or *tgkill()* (since Linux
    2.4.19) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|   | `SI_TKILL` | 通过 *tkill()* 或 *tgkill()* 终止的用户进程（自 Linux 2.4.19 起） |'
- en: '|   | `SI_USER` | A user process via *kill()* or *raise()* |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|   | `SI_USER` | 通过 *kill()* 或 *raise()* 终止的用户进程 |'
- en: '| `SIGBUS` | `BUS_ADRALN` | Invalid address alignment |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `SIGBUS` | `BUS_ADRALN` | 无效的地址对齐 |'
- en: '|   | `BUS_ADRERR` | Nonexistent physical address |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|   | `BUS_ADRERR` | 不存在的物理地址 |'
- en: '|   | `BUS_MCEERR_AO` | Hardware memory error; action optional (since Linux
    2.6.32) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|   | `BUS_MCEERR_AO` | 硬件内存错误；操作可选（自 Linux 2.6.32 起） |'
- en: '|   | `BUS_MCEERR_AR` | Hardware memory error; action required (since Linux
    2.6.32) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|   | `BUS_MCEERR_AR` | 硬件内存错误；操作要求（自 Linux 2.6.32 起） |'
- en: '|   | `BUS_OBJERR` | Object-specific hardware error |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|   | `BUS_OBJERR` | 对象特定的硬件错误 |'
- en: '| `SIGCHLD` | `CLD_CONTINUED` | Child continued by `SIGCONT` (since Linux 2.6.9)
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `SIGCHLD` | `CLD_CONTINUED` | 子进程被 `SIGCONT` 信号继续执行（自 Linux 2.6.9 起） |'
- en: '|   | `CLD_DUMPED` | Child terminated abnormally, with core dump |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|   | `CLD_DUMPED` | 子进程异常终止，并生成核心转储 |'
- en: '|   | `CLD_EXITED` | Child exited |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|   | `CLD_EXITED` | 子进程退出 |'
- en: '|   | `CLD_KILLED` | Child terminated abnormally, without core dump |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|   | `CLD_KILLED` | 子进程异常终止，无核心转储 |'
- en: '|   | `CLD_STOPPED` | Child stopped |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|   | `CLD_STOPPED` | 子进程已停止 |'
- en: '|   | `CLD_TRAPPED` | Traced child has stopped |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|   | `CLD_TRAPPED` | 被跟踪的子进程已停止 |'
- en: '| `SIGFPE` | `FPE_FLTDIV` | Floating-point divide-by-zero |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `SIGFPE` | `FPE_FLTDIV` | 浮点除以零 |'
- en: '|   | `FPE_FLTINV` | Invalid floating-point operation |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|   | `FPE_FLTINV` | 无效的浮点操作 |'
- en: '|   | `FPE_FLTOVF` | Floating-point overflow |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|   | `FPE_FLTOVF` | 浮点溢出 |'
- en: '|   | `FPE_FLTRES` | Floating-point inexact result |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|   | `FPE_FLTRES` | 浮点不精确结果 |'
- en: '|   | `FPE_FLTUND` | Floating-point underflow |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|   | `FPE_FLTUND` | 浮点下溢 |'
- en: '|   | `FPE_INTDIV` | Integer divide-by-zero |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|   | `FPE_INTDIV` | 整数除以零 |'
- en: '|   | `FPE_INTOVF` | Integer overflow |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|   | `FPE_INTOVF` | 整数溢出 |'
- en: '|   | `FPE_SUB` | Subscript out of range |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|   | `FPE_SUB` | 下标越界 |'
- en: '| `SIGILL` | `ILL_BADSTK` | Internal stack error |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `SIGILL` | `ILL_BADSTK` | 内部堆栈错误 |'
- en: '|   | `ILL_COPROC` | Coprocessor error |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|   | `ILL_COPROC` | 协处理器错误 |'
- en: '|   | `ILL_ILLADR` | Illegal addressing mode |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|   | `ILL_ILLADR` | 非法寻址模式 |'
- en: '|   | `ILL_ILLOPC` | Illegal opcode |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|   | `ILL_ILLOPC` | 非法操作码 |'
- en: '|   | `ILL_ILLOPN` | Illegal operand |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|   | `ILL_ILLOPN` | 非法操作数 |'
- en: '|   | `ILL_ILLTRP` | Illegal trap |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|   | `ILL_ILLTRP` | 非法陷阱 |'
- en: '|   | `ILL_PRVOPC` | Privileged opcode |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|   | `ILL_PRVOPC` | 特权操作码 |'
- en: '|   | `ILL_PRVREG` | Privileged register |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|   | `ILL_PRVREG` | 特权寄存器 |'
- en: '| `SIGPOLL` | `POLL_ERR` | I/O error |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `SIGPOLL` | `POLL_ERR` | I/O 错误 |'
- en: '| `SIGIO` | `POLL_HUP` | Device disconnected |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `SIGIO` | `POLL_HUP` | 设备断开连接 |'
- en: '|   | `POLL_IN` | Input data available |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|   | `POLL_IN` | 输入数据可用 |'
- en: '|   | `POLL_MSG` | Input message available |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|   | `POLL_MSG` | 输入消息可用 |'
- en: '|   | `POLL_OUT` | Output buffers available |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|   | `POLL_OUT` | 输出缓冲区可用 |'
- en: '|   | `POLL_PRI` | High-priority input available |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|   | `POLL_PRI` | 高优先级输入可用 |'
- en: '| `SIGSEGV` | `SEGV_ACCERR` | Invalid permissions for mapped object |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSEGV` | `SEGV_ACCERR` | 对映射对象的权限无效 |'
- en: '|   | `SEGV_MAPERR` | Address not mapped to object |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|   | `SEGV_MAPERR` | 地址未映射到对象 |'
- en: '| `SIGTRAP` | `TRAP_BRANCH` | Process branch trap |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTRAP` | `TRAP_BRANCH` | 进程分支陷阱 |'
- en: '|   | `TRAP_BRKPT` | Process breakpoint |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|   | `TRAP_BRKPT` | 进程断点 |'
- en: '|   | `TRAP_HWBKPT` | Hardware breakpoint/watchpoint |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|   | `TRAP_HWBKPT` | 硬件断点/监视点 |'
- en: '|   | `TRAP_TRACE` | Process trace trap |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|   | `TRAP_TRACE` | 进程跟踪陷阱 |'
- en: The *ucontext* argument
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ucontext* 参数'
- en: The final argument passed to a handler established with the `SA_SIGINFO` flag,
    *ucontext*, is a pointer to a structure of type *ucontext_t* (defined in `<ucontext.h>`).
    (SUSv3 uses a *void* pointer for this argument because it doesn’t specify any
    of the details of the argument.) This structure provides so-called user-context
    information describing the process state prior to invocation of the signal handler,
    including the previous process signal mask and saved register values (e.g., program
    counter and stack pointer). This information is rarely used in signal handlers,
    so we don’t go into further details.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给使用 `SA_SIGINFO` 标志设置的处理程序的最终参数，*ucontext*，是指向 *ucontext_t* 类型结构体的指针（定义在 `<ucontext.h>`
    中）。(SUSv3 使用 *void* 指针作为此参数，因为它未指定该参数的任何细节。）该结构提供所谓的用户上下文信息，描述了信号处理程序调用前的进程状态，包括先前的进程信号屏蔽和保存的寄存器值（例如程序计数器和堆栈指针）。这些信息在信号处理程序中很少使用，因此我们不再进一步讨论。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Another use of *ucontext_t* structures is with the functions *getcontext()*,
    *makecontext()*, *setcontext()*, and *swapcontext()*, which allow a process to
    retrieve, create, change, and swap execution contexts, respectively. (These operations
    are somewhat like *setjmp()* and *longjmp()*, but more general.) These functions
    can be used to implement coroutines, where the thread of execution of a process
    alternates between two (or more) functions. SUSv3 specifies these functions, but
    marks them obsolete. SUSv4 removes the specifications, and suggests that applications
    should be rewritten to use POSIX threads instead. The *glibc* manual provides
    further information about these functions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*ucontext_t*结构的另一个用途是与*getcontext()*、*makecontext()*、*setcontext()*和*swapcontext()*函数一起使用，这些函数允许进程检索、创建、更改和交换执行上下文，分别。
    （这些操作有些像*setjmp()*和*longjmp()*，但更通用。）这些函数可用于实现协程，其中进程的执行线程在两个（或更多）函数之间交替。 SUSv3指定了这些函数，但将其标记为过时。
    SUSv4删除了这些规范，并建议应用程序应重新编写以使用POSIX线程。 *glibc*手册提供了关于这些函数的更多信息。'
- en: Interruption and Restarting of System Calls
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用的中断和重新启动
- en: 'Consider the following scenario:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景：
- en: We establish a handler for some signal.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为某些信号建立了处理程序。
- en: We make a blocking system call, for example, a *read()* from a terminal device,
    which blocks until input is supplied.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行阻塞系统调用，例如从终端设备读取*read()*，该调用会一直阻塞，直到输入被提供。
- en: While the system call is blocked, the signal for which we established a handler
    is delivered, and its signal handler is invoked.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当系统调用被阻塞时，传递了我们为其建立处理程序的信号，并调用了其信号处理程序。
- en: What happens after the signal handler returns? By default, the system call fails
    with the error `EINTR` (“Interrupted function”). This can be a useful feature.
    In [Setting Timeouts on Blocking Operations](ch23.html#setting_timeouts_on_blocking_operations
    "Setting Timeouts on Blocking Operations"), we’ll see how to use a timer (which
    results in the delivery of a `SIGALRM` signal) to set a timeout on a blocking
    system call such as *read()*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序返回后会发生什么？默认情况下，系统调用失败，返回错误`EINTR`（“中断函数”）。这可以是一个有用的特性。在[阻塞操作设置超时](ch23.html#setting_timeouts_on_blocking_operations
    "设置阻塞操作超时")中，我们将看到如何使用计时器（导致传递`SIGALRM`信号）为诸如*read()*之类的阻塞系统调用设置超时。
- en: 'Often, however, we would prefer to continue the execution of an interrupted
    system call. To do this, we could use code such as the following to manually restart
    a system call in the event that it is interrupted by a signal handler:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们希望继续执行被中断的系统调用。为了做到这一点，我们可以使用以下代码来在信号处理程序中手动重新启动系统调用：
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we frequently write code such as the above, it can be useful to define a
    macro such as the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们经常编写如上所示的代码，定义以下宏可能会很有用：
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using this macro, we can rewrite the earlier *read()* call as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此宏，我们可以将之前的*read()*调用重写为以下形式：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GNU C library provides a (nonstandard) macro with the same purpose as our
    `NO_EINTR()` macro in `<unistd.h>`. The macro is called `TEMP_FAILURE_RETRY()`
    and is made available if the `_GNU_SOURCE` feature test macro is defined.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C库在`<unistd.h>`中提供了与我们的`NO_EINTR()`宏相同目的的（非标准）宏。如果定义了`_GNU_SOURCE`特性测试宏，则会提供名为`TEMP_FAILURE_RETRY()`的宏。
- en: Even if we employ a macro like `NO_EINTR()`, having signal handlers interrupt
    system calls can be inconvenient, since we must add code to each blocking system
    call (assuming that we want to restart the call in each case). Instead, we can
    specify the `SA_RESTART` flag when establishing the signal handler with *sigaction()*,
    so that system calls are automatically restarted by the kernel on the process’s
    behalf. This means that we don’t need to handle a possible `EINTR` error return
    for these system calls.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用类似`NO_EINTR()`的宏，由于信号处理程序必须在每个阻塞系统调用中添加代码（假设我们要在每种情况下重新启动调用），中断系统调用可能会很不方便。相反，我们可以在使用*sigaction()*建立信号处理程序时指定`SA_RESTART`标志，以便内核代表进程自动重新启动系统调用。这意味着我们不需要为这些系统调用处理可能的`EINTR`错误返回。
- en: The `SA_RESTART` flag is a per-signal setting. In other words, we can allow
    handlers for some signals to interrupt blocking system calls, while others permit
    automatic restarting of system calls.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_RESTART`标志是每个信号的设置。换句话说，我们可以允许一些信号的处理程序中断阻塞系统调用，而其他信号则允许自动重新启动系统调用。'
- en: System calls (and library functions) for which `SA_RESTART` is effective
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对于有效的`SA_RESTART`系统调用（及库函数）
- en: 'Unfortunately, not all blocking system calls automatically restart as a result
    of specifying `SA_RESTART`. The reasons for this are partly historical:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有阻塞系统调用在指定了 `SA_RESTART` 后都会自动重新启动。部分原因是历史原因：
- en: 'Restarting of system calls was introduced in 4.2BSD, and covered interrupted
    calls to *wait()* and *waitpid()*, as well as the following I/O system calls:
    *read()*, *readv()*, *write()*, *writev()*, and blocking *ioctl()* operations.
    The I/O system calls are interruptible, and hence automatically restarted by `SA_RESTART`
    only when operating on a “slow” device. Slow devices include terminals, pipes,
    FIFOs, and sockets. On these file types, various I/O operations may block. (By
    contrast, disk files don’t fall into the category of slow devices, because disk
    I/O operations generally can be immediately satisfied via the buffer cache. If
    a disk I/O is required, the kernel puts the process to sleep until the I/O completes.)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用的重新启动功能是在 4.2BSD 中引入的，涵盖了对 *wait()* 和 *waitpid()* 的中断调用，以及以下 I/O 系统调用：*read()*、*readv()*、*write()*、*writev()*
    和阻塞 *ioctl()* 操作。这些 I/O 系统调用是可中断的，因此仅当操作“慢”设备时，才会通过 `SA_RESTART` 自动重新启动。慢设备包括终端、管道、FIFO
    和套接字。在这些文件类型上，各种 I/O 操作可能会阻塞。（相比之下，磁盘文件不属于慢设备类别，因为磁盘 I/O 操作通常可以通过缓存区快速完成。如果需要磁盘
    I/O，内核会将进程挂起，直到 I/O 完成。）
- en: A number of other blocking system calls are derived from System V, which did
    not initially provide for restarting of system calls.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他阻塞系统调用源自 System V，最初并未提供系统调用的重新启动功能。
- en: 'On Linux, the following blocking system calls (and library functions layered
    on top of system calls) are automatically restarted if interrupted by a signal
    handler established using the `SA_RESTART` flag:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，如果通过 `SA_RESTART` 标志使用信号处理程序中断，则以下阻塞系统调用（以及其上层的库函数）会自动重新启动：
- en: 'The system calls used to wait for a child process ([Waiting on a Child Process](ch26.html#waiting_on_a_child_process
    "Waiting on a Child Process")): *wait()*, *waitpid()*, *wait3()*, *wait4()*, and
    *waitid()*.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于等待子进程的系统调用（[等待子进程](ch26.html#waiting_on_a_child_process "Waiting on a Child
    Process")）：*wait()*、*waitpid()*、*wait3()*、*wait4()* 和 *waitid()*。
- en: 'The I/O system calls *read()*, *readv()*, *write()*, *writev()*, and *ioctl()*
    when applied to “slow” devices. In cases where data has already been partially
    transferred at the time of signal delivery, the input and output system calls
    will be interrupted, but return a success status: an integer indicating how many
    bytes were successfully transferred.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 系统调用 *read()*、*readv()*、*write()*、*writev()* 和 *ioctl()* 在应用于“慢”设备时。如果数据在信号传递时已经部分传输，输入输出系统调用将被中断，但会返回成功状态：一个整数，表示成功传输的字节数。
- en: The *open()* system call, in cases where it can block (e.g., when opening FIFOs,
    as described in [FIFOs](ch44.html#fifos "FIFOs")).
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*open()* 系统调用，在可能发生阻塞的情况下（例如，打开 FIFO 时，如 [FIFOs](ch44.html#fifos "FIFOs") 中描述的那样）。'
- en: 'Various system calls used with sockets: *accept()*, *accept4()*, *connect()*,
    *send()*, *sendmsg()*, *sendto()*, *recv()*, *recvfrom()*, and *recvmsg()*. (On
    Linux, these system calls are not automatically restarted if a timeout has been
    set on the socket using *setsockopt()*. See the *signal(7)* manual page for details.)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与套接字一起使用的各种系统调用：*accept()*、*accept4()*、*connect()*、*send()*、*sendmsg()*、*sendto()*、*recv()*、*recvfrom()*
    和 *recvmsg()*。 （在 Linux 上，如果使用 *setsockopt()* 设置了套接字超时，则这些系统调用不会自动重新启动。详情请参见 *signal(7)*
    手册页。）
- en: 'The system calls used for I/O on POSIX message queues: *mq_receive()*, *mq_timedreceive()*,
    *mq_send()*, and *mq_timedsend()*.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 POSIX 消息队列上进行 I/O 的系统调用：*mq_receive()*、*mq_timedreceive()*、*mq_send()* 和
    *mq_timedsend()*。
- en: 'The system calls and library functions used to place file locks: *flock()*,
    *fcntl()*, and *lockf()*.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于放置文件锁的系统调用和库函数：*flock()*、*fcntl()* 和 *lockf()*。
- en: The `FUTEX_WAIT` operation of the Linux-specific *futex()* system call.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 特有的 *futex()* 系统调用的 `FUTEX_WAIT` 操作。
- en: The *sem_wait()* and *sem_timedwait()* functions used to decrement a POSIX semaphore.
    (On some UNIX implementations, *sem_wait() is* restarted if the `SA_RESTART` flag
    is specified.)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sem_wait()* 和 *sem_timedwait()* 函数用于递减一个 POSIX 信号量。 （在某些 UNIX 实现中，如果指定了`SA_RESTART`标志，*sem_wait()*
    将会重新启动。）'
- en: 'The functions used to synchronize POSIX threads: *pthread_mutex_lock()*, *pthread_mutex_trylock()*,
    *pthread_mutex_timedlock()*, *pthread_cond_wait()*, and *pthread_cond_timedwait()*.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于同步 POSIX 线程的函数：*pthread_mutex_lock()*、*pthread_mutex_trylock()*、*pthread_mutex_timedlock()*、*pthread_cond_wait()*
    和 *pthread_cond_timedwait()*。
- en: In kernels before 2.6.22, *futex()*, *sem_wait()*, and *sem_timedwait()* always
    failed with the error `EINTR` when interrupted, regardless of the setting of the
    `SA_RESTART` flag.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.6.22版本之前的内核中，*futex()*、*sem_wait()*和*sem_timedwait()*在中断时总是返回`EINTR`错误，无论`SA_RESTART`标志的设置如何。
- en: 'The following blocking system calls (and library functions layered on top of
    system calls) are never automatically restarted (even if `SA_RESTART` is specified):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下阻塞系统调用（以及建立在系统调用之上的库函数）即使指定了`SA_RESTART`，也不会自动重新启动：
- en: The *poll()*, *ppoll()*, *select()*, and *pselect()* I/O multiplexing calls.
    (SUSv3 explicitly states that the behavior of *select()* and *pselect()* when
    interrupted by a signal handler is unspecified, regardless of the setting of `SA_RESTART`.)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*poll()*、*ppoll()*、*select()*和*pselect()* I/O多路复用调用。 (SUSv3明确指出，*select()*和*pselect()*在被信号处理程序中断时的行为未指定，无论`SA_RESTART`的设置如何。)'
- en: The Linux-specific *epoll_wait()* and *epoll_pwait()* system calls.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux特有的*epoll_wait()*和*epoll_pwait()*系统调用。
- en: The Linux-specific *io_getevents()* system call.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux特有的*io_getevents()*系统调用。
- en: 'The blocking system calls used with System V message queues and semaphores:
    *semop()*, *semtimedop()*, *msgrcv()*, and *msgsnd()*. (Although System V did
    not originally provide automatic restarting of system calls, on some UNIX implementations,
    these system calls *are* restarted if the `SA_RESTART` flag is specified.)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于System V消息队列和信号量的阻塞系统调用：*semop()*、*semtimedop()*、*msgrcv()*和*msgsnd()*。 (尽管System
    V最初未提供自动重启系统调用的功能，但在某些UNIX实现中，如果指定了`SA_RESTART`标志，这些系统调用*会*被重启。)
- en: A *read()* from an *inotify* file descriptor.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*inotify*文件描述符的*read()*操作。
- en: 'The system calls and library functions designed to suspend execution of a program
    for a specified period: *sleep()*, *nanosleep()*, and *clock_nanosleep()*.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旨在暂停程序执行一段指定时间的系统调用和库函数：*sleep()*、*nanosleep()*和*clock_nanosleep()*。
- en: 'The system calls designed specifically to wait until a signal is delivered:
    *pause()*, *sigsuspend()*, *sigtimedwait()*, and *sigwaitinfo()*.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门设计用于等待信号传递的系统调用：*pause()*、*sigsuspend()*、*sigtimedwait()*和*sigwaitinfo()*。
- en: Modifying the `SA_RESTART` flag for a signal
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改`SA_RESTART`标志以处理信号
- en: The *siginterrupt()* function changes the `SA_RESTART` setting associated with
    a signal.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*siginterrupt()*函数改变与信号相关的`SA_RESTART`设置。'
- en: '[PRE24]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: If *flag* is true (1), then a handler for the signal *sig* will interrupt blocking
    system calls. If *flag* is false (0), then blocking system calls will be restarted
    after execution of a handler for *sig*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*flag*为真（1），则信号*sig*的处理程序会中断阻塞系统调用。如果*flag*为假（0），则在执行*sig*的处理程序后，阻塞系统调用会重新启动。
- en: The *siginterrupt()* function works by using *sigaction()* to fetch a copy of
    the signal’s current disposition, tweaking the `SA_RESTART` flag in the returned
    *oldact* structure, and then calling *sigaction()* once more to update the signal’s
    disposition.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*siginterrupt()*函数通过使用*sigaction()*获取信号当前处理方式的副本，修改返回的*oldact*结构中的`SA_RESTART`标志，然后再次调用*sigaction()*来更新信号的处理方式。'
- en: SUSv4 marks *siginterrupt()* obsolete, recommending the use of *sigaction()*
    instead for this purpose.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv4标记*siginterrupt()*为废弃，推荐改用*sigaction()*来完成此任务。
- en: Unhandled stop signals can generate `EINTR` for some Linux system calls
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 某些Linux系统调用在未处理的停止信号下可能会生成`EINTR`错误。
- en: On Linux, certain blocking system calls can return `EINTR` even in the absence
    of a signal handler. This can occur if the system call is blocked and the process
    is stopped by a signal (`SIGSTOP`, `SIGTSTP`, `SIGTTIN`, or `SIGTTOU`), and then
    resumed by delivery of a `SIGCONT` signal.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，某些阻塞系统调用即使没有信号处理程序，也可能返回`EINTR`错误。如果系统调用被阻塞且进程被信号（`SIGSTOP`、`SIGTSTP`、`SIGTTIN`或`SIGTTOU`）停止，然后通过`SIGCONT`信号恢复执行，就可能发生这种情况。
- en: 'The following system calls and functions exhibit this behavior: *epoll_pwait()*,
    *epoll_wait()*, *read()* from an *inotify* file descriptor, *semop()*, *semtimedop()*,
    *sigtimedwait()*, and *sigwaitinfo()*.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下系统调用和函数展示了此行为：*epoll_pwait()*、*epoll_wait()*、*inotify*文件描述符的*read()*、*semop()*、*semtimedop()*、*sigtimedwait()*和*sigwaitinfo()*。
- en: In kernels before 2.6.24, *poll()* also exhibited this behavior, as did *sem_wait(),
    sem_timedwait(), futex(FUTEX_WAIT*), in kernels before 2.6.22, *msgrcv()* and
    *msgsnd()* in kernels before 2.6.9, and *nanosleep()* in Linux 2.4 and earlier.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.6.24版本之前的内核中，*poll()*也表现出这种行为，*sem_wait()*、*sem_timedwait()*、futex(FUTEX_WAIT*)在2.6.22版本之前的内核中也存在类似行为，2.6.9版本之前的内核中，*msgrcv()*和*msgsnd()*以及Linux
    2.4及更早版本中的*nanosleep()*也有类似行为。
- en: In Linux 2.4 and earlier, *sleep()* can also be interrupted in this manner,
    but, instead of returning an error, it returns the number of remaining unslept
    seconds.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.4及更早版本中，*sleep()*也可以以这种方式中断，但它不会返回错误，而是返回剩余未睡眠的秒数。
- en: The upshot of this behavior is that if there is a chance that our program may
    be stopped and restarted by signals, then we may need to include code to restart
    these system calls, even in a program that doesn’t install handlers for the stop
    signals.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的结果是，如果我们的程序有可能被信号停止并重新启动，那么我们可能需要在程序中加入代码，以便在程序没有安装停止信号的处理程序时，也能重新启动这些系统调用。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we considered a range of factors that affect the operation
    and design of signal handlers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了影响信号处理程序操作和设计的多种因素。
- en: Because signals are not queued, a signal handler must sometimes be coded to
    deal with the possibility that multiple events of a particular type have occurred,
    even though only one signal was delivered. The issue of reentrancy affects how
    we can update global variables and limits the set of functions that we can safely
    call from a signal handler.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信号不被排队处理，信号处理程序有时必须编写成处理多次相同类型事件的可能性，即使只有一个信号被传递。重入性问题影响我们如何更新全局变量，并限制我们可以安全调用的函数集合。
- en: Instead of returning, a signal handler can terminate in a variety of other ways,
    including calling *_exit()*, terminating the process by sending a signal (*kill()*,
    *raise()*, or *abort()*), or performing a nonlocal goto. Using *sigsetjmp()* and
    *siglongjmp()* provides a program with explicit control of the treatment of the
    process signal mask when a nonlocal goto is performed.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序可以以多种方式终止，而不是返回，包括调用*exit()*，通过发送信号终止进程（*kill()*, *raise()*, 或 *abort()*），或者执行非局部跳转。使用*sigsetjmp()*和*siglongjmp()*提供了程序对非局部跳转时进程信号掩码处理的显式控制。
- en: We can use *sigaltstack()* to define an alternate signal stack for a process.
    This is an area of memory that is used instead of the standard process stack when
    invoking a signal handler. An alternate signal stack is useful in cases where
    the standard stack has been exhausted by growing too large (at which point the
    kernel sends a `SIGSEGV` signal to the process).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*sigaltstack()*为进程定义一个备用信号栈。这是一个内存区域，在调用信号处理程序时，会替代标准的进程栈。备用信号栈在标准栈因过度增长而耗尽时特别有用（此时内核会向进程发送`SIGSEGV`信号）。
- en: The *sigaction()* `SA_SIGINFO` flag allows us to establish a signal handler
    that receives additional information about a signal. This information is supplied
    via a *siginfo_t* structure whose address is passed as an argument to the signal
    handler.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigaction()* `SA_SIGINFO`标志允许我们建立一个信号处理程序，接收关于信号的附加信息。此信息通过一个*siginfo_t*结构提供，其地址作为参数传递给信号处理程序。'
- en: When a signal handler interrupts a blocked system call, the system call fails
    with the error `EINTR`. We can take advantage of this behavior to, for example,
    set a timer on a blocking system call. Interrupted system calls can be manually
    restarted if desired. Alternatively, establishing the signal handler with the
    *sigaction()* `SA_RESTART` flag causes many (but not all) system calls to be automatically
    restarted.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号处理程序中断一个阻塞的系统调用时，系统调用会失败并返回错误`EINTR`。我们可以利用这一行为，例如在一个阻塞的系统调用上设置定时器。如果需要，中断的系统调用可以手动重新启动。或者，使用带有*sigaction()*
    `SA_RESTART`标志的信号处理程序可以导致许多（但不是所有）系统调用自动重新启动。
- en: Further information
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: See the sources listed in [Summary](ch20.html#summary-id19 "Summary").
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[总结](ch20.html#summary-id19 "Summary")中列出的来源。
- en: Exercise
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Implement *abort()*.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现*abort()*。
