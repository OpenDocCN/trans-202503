- en: '24'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '24'
- en: API Hacking
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: API 黑客技术
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Application programming interfaces (**APIs)* are a way for programs to communicate
    with each other, and they power a wide variety of applications. As applications
    become more complex, developers are increasingly using APIs to combine components
    of an application or multiple applications belonging to the same organization.
    And more and more, APIs have the ability to execute important actions or communicate
    sensitive information.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用程序编程接口（**APIs**）* 是程序之间进行通信的一种方式，它们为各种应用程序提供动力。随着应用程序变得越来越复杂，开发者越来越多地使用
    API 来组合应用程序的组件或属于同一组织的多个应用程序。并且，越来越多的 API 具备执行重要操作或传输敏感信息的能力。'
- en: In this chapter, we’ll talk about what APIs are, how they work, and how you
    can find and exploit API vulnerabilities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论什么是 API，API 如何工作，以及你如何发现和利用 API 漏洞。
- en: What Are APIs?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 API？
- en: In simple terms, an API is a set of rules that allow one application to communicate
    with another. They enable applications to share data in a controlled way. Using
    APIs, applications on the internet can take advantage of other applications’ resources
    to build more complex features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，API 是一组规则，允许一个应用程序与另一个应用程序进行通信。它们使得应用程序能够以受控的方式共享数据。通过使用 API，互联网上的应用程序可以利用其他应用程序的资源，构建更复杂的功能。
- en: 'For example, consider Twitter’s API ([https://developer.twitter.com/en/docs/twitter-api/](https://developer.twitter.com/en/docs/twitter-api/)).
    This public API allows outside developers to access Twitter’s data and actions.
    For example, if a developer wants their code to retrieve the contents of a tweet
    from Twitter’s database, they can use a Twitter API endpoint that returns tweet
    information by sending a GET request to the Twitter API server located at *api.twitter.com*:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下 Twitter 的 API（[https://developer.twitter.com/en/docs/twitter-api/](https://developer.twitter.com/en/docs/twitter-api/)）。这个公共
    API 允许外部开发者访问 Twitter 的数据和操作。例如，如果开发者希望他们的代码从 Twitter 的数据库中检索推文内容，他们可以使用一个 Twitter
    API 端点，通过向位于 *api.twitter.com* 的 Twitter API 服务器发送 GET 请求来返回推文信息：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This URL indicates that the developer is using Twitter’s API version 1.1 and
    requesting the resource called `statuses` (which is what Twitter calls its tweets)
    with the ID 210462857140252672\. The `id` field in the URL is a request parameter
    required by the API endpoint. API endpoints often require certain parameters to
    determine which resource to return.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 表示开发者正在使用 Twitter 的 API 版本 1.1，并请求一个名为 `statuses`（即 Twitter 的推文）的资源，ID
    为 210462857140252672。URL 中的 `id` 字段是 API 端点所要求的请求参数。API 端点通常需要某些参数来确定返回哪个资源。
- en: 'Twitter’s API server would then return the data in JSON format to the requesting
    application (this example is taken from Twitter’s public API documentation):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Twitter 的 API 服务器会以 JSON 格式将数据返回给请求的应用程序（这个示例取自 Twitter 的公共 API 文档）：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: APIs usually return data in JSON or XML format. JSON is a way to represent data
    in plaintext, and it’s commonly used to transport data within web messages. You’ll
    often see JSON messages when you’re testing applications, so it’s helpful to learn
    how to read them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: API 通常以 JSON 或 XML 格式返回数据。JSON 是一种以明文形式表示数据的方式，通常用于在 web 消息中传输数据。当你在测试应用程序时，经常会看到
    JSON 消息，因此学会阅读它们非常有用。
- en: JSON objects start and end with a curly bracket 1. Within these curly brackets,
    the properties of the represented object are stored in key-value pairs. For example,
    in the preceding data block representing a tweet, the `created_at` property has
    the value `Wed Oct 10 20:19:24 +0000 2018`. This indicates that the tweet was
    created on Wednesday, October 10, 2018 at 8:19 PM 2.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 对象以大括号1开始和结束。在这些大括号内，表示对象的属性以键值对的形式存储。例如，在前面的数据块中，表示一条推文，`created_at` 属性的值为
    `Wed Oct 10 20:19:24 +0000 2018`。这表示该推文是在 2018 年 10 月 10 日星期三晚上 8:19 创建的2。
- en: JSON objects can also contain lists or other objects. Curly brackets denote
    objects. The preceding tweet contains a `user` object indicating the user who
    created the tweet 4. Lists are denoted with square brackets. Twitter returned
    an empty list of hashtags in the preceding JSON block, which means no hashtags
    were used in the tweet 3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 对象还可以包含列表或其他对象。大括号表示对象。前面的推文包含一个 `user` 对象，表示创建该推文的用户4。列表用方括号表示。Twitter
    在前面的 JSON 块中返回了一个空的标签列表，这意味着该推文中没有使用任何标签3。
- en: You might be wondering how the API server decides who can access data or execute
    actions. APIs often require users to authenticate before accessing their services.
    Typically, users include access tokens in their API requests to prove their identities.
    Other times, users are required to use special authentication headers or cookies.
    The server would then use the credentials presented in the request to determine
    which resources and actions the user should access.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道 API 服务器是如何决定谁可以访问数据或执行操作的。API 通常要求用户在访问其服务之前进行身份验证。通常，用户会在 API 请求中包含访问令牌以证明他们的身份。其他时候，用户需要使用特殊的认证头或
    Cookies。服务器随后会使用请求中提供的凭证来决定用户应访问哪些资源和操作。
- en: REST APIs
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REST API
- en: There are multiple kinds of APIs. The Twitter API discussed here is called a
    *Representational State Transfer (**REST**)* API. REST is one of the most commonly
    used API structures. Most of the time, REST APIs return data in either JSON or
    plaintext format. REST API users send requests to specific resource endpoints
    to access that resource. In Twitter’s case, you send GET requests to *https://api.twitter.com/1.1/statuses/show/*
    to retrieve tweet information, and GET requests to *https://api.twitter.com/1.1/users/show/*
    to retrieve user information.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种类型的 API。此处讨论的 Twitter API 被称为*表述性状态转移（**REST**）* API。REST 是最常用的 API 结构之一。大多数情况下，REST
    API 返回 JSON 或纯文本格式的数据。REST API 用户向特定的资源端点发送请求以访问该资源。在 Twitter 的案例中，您可以向 *https://api.twitter.com/1.1/statuses/show/*
    发送 GET 请求以检索推文信息，向 *https://api.twitter.com/1.1/users/show/* 发送 GET 请求以检索用户信息。
- en: 'REST APIs usually have defined structures for queries that make it easy for
    users to predict the specific endpoints to which they should send their requests.
    For example, to delete a tweet via the Twitter API, users can send a POST request
    to *https://api.twitter.com/1.1/statuses/destroy/*, and to retweet a tweet, users
    can send a POST request to *https://api.twitter.com/1.1/statuses/retweet/*. You
    can see here that all of Twitter’s API endpoints are structured in the same way
    (*https://api.twitter.com/1.1/RESOURCE/ACTION*):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 通常为查询定义了结构，方便用户预测应将请求发送到哪个具体的端点。例如，要通过 Twitter API 删除推文，用户可以向 *https://api.twitter.com/1.1/statuses/destroy/*
    发送 POST 请求，要转发推文，用户可以向 *https://api.twitter.com/1.1/statuses/retweet/* 发送 POST
    请求。你可以看到，Twitter 的所有 API 端点都采用相同的结构（*https://api.twitter.com/1.1/RESOURCE/ACTION*）：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: REST APIs can also use various HTTP methods. For example, GET is usually used
    to retrieve resources, POST is used to update or create resources, PUT is used
    to update resources, and DELETE is used to delete them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 也可以使用多种 HTTP 方法。例如，GET 通常用于检索资源，POST 用于更新或创建资源，PUT 用于更新资源，DELETE 用于删除资源。
- en: SOAP APIs
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SOAP API
- en: '*SOAP* is an API architecture that is less commonly used in modern applications.
    But plenty of older apps and IoT apps still use SOAP APIs. SOAP APIs use XML to
    transport data, and their messages have a header and a body. A simple SOAP request
    looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*SOAP* 是一种在现代应用中较少使用的 API 架构，但许多老旧应用和物联网应用仍然使用 SOAP API。SOAP API 使用 XML 来传输数据，且其消息包含头部和主体。一个简单的
    SOAP 请求如下所示：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example request is taken from Amazon S3’s SOAP API documentation. It deletes
    an S3 bucket named *quotes*. As you can see, API request parameters are passed
    to the server as tags within the XML document.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例请求来自 Amazon S3 的 SOAP API 文档。它删除了一个名为 *quotes* 的 S3 桶。如你所见，API 请求参数作为 XML
    文档中的标签传递给服务器。
- en: 'The SOAP response looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 响应如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This response indicates that the bucket is successfully deleted and no longer
    found.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该响应表示桶已成功删除，并且不再可用。
- en: SOAP APIs have a service called *Web Services Description Language (**WSDL)*,
    used to describe the structure of the API and how to access it. If you can find
    the WSDL of a SOAP API, you can use it to understand the API before hacking it.
    You can often find WSDL files by adding *.wsdl* or *?wsdl* to the end of an API
    endpoint or searching for URL endpoints containing the term *wsdl*. In the WSDL,
    you will be able to find a list of API endpoints you can test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP API 有一个名为 *Web 服务描述语言（**WSDL**）* 的服务，用于描述 API 的结构及如何访问它。如果你能找到一个 SOAP API
    的 WSDL 文件，你就可以在对其进行破解前了解该 API。你通常可以通过在 API 端点后面添加 *.wsdl* 或 *?wsdl* 来找到 WSDL 文件，或者通过搜索包含
    *wsdl* 词汇的 URL 端点。在 WSDL 中，你将能够找到可以测试的 API 端点列表。
- en: GraphQL APIs
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL API
- en: '*GraphQL*is a newer API technology that allows developers to request the precise
    resource fields they need, and to fetch multiple resources with just a single
    API call. GraphQL is becoming increasingly common because of these benefits.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*GraphQL* 是一种较新的 API 技术，允许开发者请求所需的精确资源字段，并通过一次 API 调用获取多个资源。由于这些优点，GraphQL
    正变得越来越普及。'
- en: 'GraphQL APIs use a custom query language and a single endpoint for all the
    API’s functionality. These endpoints are commonly located at /graphql, */gql*,
    or */g*. GraphQL has two main kinds of operations: queries and mutations. *Queries*
    fetch data, just like the GET requests in REST APIs. *Mutations* create, update,
    and delete data, just like the POST, PUT, and DELETE requests in REST APIs.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 使用自定义查询语言和单一端点来处理所有 API 功能。这些端点通常位于 /graphql、*/gql* 或 */g*。GraphQL
    主要有两种操作类型：查询和变更。*查询* 用于获取数据，就像 REST API 中的 GET 请求一样。*变更* 用于创建、更新和删除数据，就像 REST
    API 中的 POST、PUT 和 DELETE 请求一样。
- en: 'As an example, take a look at the following API requests to Shopify’s GraphQL
    API. Shopify is an e-commerce platform that allows users to interact with their
    online stores via a GraphQL API. To access Shopify’s GraphQL API, developers need
    to send POST requests to the endpoint *https://SHOPNAME.myshopify.com/admin/api/API_VERSION/graphql.json*
    with the GraphQL query in the POST request body. To retrieve information about
    your shop, you can send this request:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，看看以下 Shopify 的 GraphQL API 请求。Shopify 是一个电子商务平台，允许用户通过 GraphQL API 与他们的在线商店进行互动。要访问
    Shopify 的 GraphQL API，开发者需要向端点 *https://SHOPNAME.myshopify.com/admin/api/API_VERSION/graphql.json*
    发送 POST 请求，并将 GraphQL 查询放在 POST 请求体中。要检索关于你的商店的信息，你可以发送以下请求：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This GraphQL query indicates that we want to retrieve the name and `primaryDomain`
    of the shop, and that we need only the `primaryDomain`’s URL and host properties.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 GraphQL 查询表示我们想要检索商店的名称和 `primaryDomain`，并且我们只需要 `primaryDomain` 的 URL 和主机属性。
- en: 'Shopify’s server will return the requested information in JSON format:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify 的服务器将以 JSON 格式返回请求的信息：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that the response doesn’t contain all the object’s fields, but instead
    the exact fields the user has requested. Depending on your needs, you can request
    either more or fewer fields of the same data object. Here is an example that requests
    fewer:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应中并不包含对象的所有字段，而是仅包含用户请求的精确字段。根据需求，你可以请求相同数据对象的更多或更少字段。以下是一个请求更少字段的例子：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also request the precise subfields of a resource’s properties and other
    nested properties. For example, here, you request only the URL of the `primaryDomain`
    of a shop:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以请求资源属性的精确子字段和其他嵌套属性。例如，在这里，你只请求商店的 `primaryDomain` 的 URL：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These queries are all used to retrieve data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询都是用来检索数据的。
- en: 'Mutations, used to edit data, can have arguments and return values. Let’s take
    a look at an example of a mutation taken from *graphql.org*. This mutation creates
    a new customer record and takes three input parameters: `firstName`, `lastName`,
    and `email`. It then returns the ID of the newly created customer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 变更操作用于编辑数据，可以带有参数并返回值。让我们来看一个来自 *graphql.org* 的变更示例。这个变更操作创建了一个新的客户记录，并需要三个输入参数：`firstName`、`lastName`
    和 `email`。然后它会返回新创建客户的 ID：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: GraphQL’s unique syntax might make testing it hard at first, but once you understand
    it, you can test these APIs the same way that you test other types of APIs. To
    learn more about GraphQL’s syntax, visit [https://graphql.org/](https://graphql.org/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 独特的语法可能一开始会让测试变得困难，但一旦你理解了它，你可以像测试其他类型的 API 一样测试这些 API。要了解更多关于 GraphQL
    语法的信息，请访问 [https://graphql.org/](https://graphql.org/)。
- en: 'GraphQL APIs also include a great reconnaissance tool for bug hunters: a feature
    called *introspection* that allows API users to ask a GraphQL system for information
    about itself. In other words, they’re queries that return information about how
    to use the API. For example, `__schema` is a special field that will return all
    the types available in the API; the following query will return all the type names
    in the system. You can use it to find data types you can query for:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 还包括一个非常好的侦察工具，供漏洞猎人使用：一种叫做 *introspection* 的功能，允许 API 用户向 GraphQL
    系统请求有关其自身的信息。换句话说，它们是返回如何使用 API 的信息的查询。例如，`__schema` 是一个特殊的字段，将返回 API 中所有可用的类型；以下查询将返回系统中的所有类型名称。你可以用它来查找可以查询的数据类型：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also use the `__type` query to find the associated fields of a particular
    type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `__type` 查询来查找特定类型的相关字段：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will get the fields of a type returned like this. You can then use this
    information to query the API:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会得到如下的类型字段返回。你可以使用这些信息来查询API：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Introspection makes recon a breeze for the API hacker. To prevent malicious
    attackers from enumerating their APIs, many organizations disable introspection
    in their GraphQL APIs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 内省使得API黑客的侦察变得轻松。为了防止恶意攻击者枚举其API，许多组织在其GraphQL API中禁用了内省功能。
- en: API-Centric Applications
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API驱动的应用程序
- en: Increasingly, APIs aren’t used as simply a mechanism to share data with outside
    developers. You’ll also encounter *API-centric applications*, or applications
    built using APIs. Instead of retrieving complete HTML documents from the server,
    API-centric apps consist of a client-side component that requests and renders
    data from the server by using API calls.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的API不再仅仅作为与外部开发者共享数据的机制。你还会遇到*API驱动的应用程序*，即通过API构建的应用程序。API驱动的应用程序不再从服务器获取完整的HTML文档，而是由客户端组件通过API调用向服务器请求并呈现数据。
- en: For example, when a user views Facebook posts, Facebook’s mobile application
    uses API calls to retrieve data about the posts from the server instead of retrieving
    entire HTML documents containing embedded data. The application then renders that
    data on the client side to form web pages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户查看Facebook帖子时，Facebook的移动应用使用API调用从服务器检索关于这些帖子的数据显示，而不是获取包含嵌入数据的完整HTML文档。然后，应用程序在客户端渲染这些数据，形成网页。
- en: 'Many mobile applications are built this way. When a company already has a web
    app, using an API-centric approach to build mobile apps saves time. APIs allow
    developers to separate the app’s rendering and data-transporting tasks: developers
    can use API calls to transport data and then build a separate rendering mechanism
    for mobile, instead of reimplementing the same functionalities.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多移动应用程序都是以这种方式构建的。当公司已经有了一个Web应用时，使用API驱动的方法来构建移动应用可以节省时间。API允许开发者将应用程序的渲染和数据传输任务分开：开发者可以使用API调用来传输数据，然后为移动设备构建一个独立的渲染机制，而不是重新实现相同的功能。
- en: Yet the rise of API-centric applications means that companies and applications
    expose more and more of their data and functionalities through APIs. APIs often
    leak sensitive data and the application logic of the hosting application. As you’ll
    see, this makes API bugs a widespread source of security breaches and a fruitful
    target for bug hunters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，API驱动的应用程序的兴起意味着公司和应用程序通过API暴露出越来越多的数据和功能。API常常泄露敏感数据和托管应用程序的应用逻辑。如你所见，这使得API漏洞成为普遍的安全漏洞来源，并成为漏洞猎人重要的攻击目标。
- en: Hunting for API Vulnerabilities
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找API漏洞
- en: Let’s explore some of the vulnerabilities that affect APIs and the steps you
    can take to discover them. API vulnerabilities are similar to the ones that affect
    non-API web applications, so make sure you have a good understanding of the bugs
    we’ve discussed up to this point. That said, when testing APIs, you should focus
    your testing on the vulnerabilities listed in this section, because they are prevalent
    in API implementations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些影响API的漏洞，以及你可以采取的步骤来发现它们。API漏洞与影响非API Web应用程序的漏洞类似，因此请确保你对我们至今讨论的漏洞有充分的理解。话虽如此，在测试API时，你应该把测试重点放在本节中列出的漏洞上，因为它们在API实现中非常普遍。
- en: Before we dive in, there are many open source API development and testing tools
    that you can use to make the API testing process more efficient. Postman ([https://www.postman.com/](https://www.postman.com/))
    is a handy tool that will help you test APIs. You can use Postman to craft complex
    API requests from scratch and manage the large number of test requests that you
    will be sending. GraphQL Playground ([https://github.com/graphql/graphql-playground/](https://github.com/graphql/graphql-playground/))
    is an IDE for crafting GraphQL queries that has autocompletion and error highlighting.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，有许多开源API开发和测试工具可以帮助你提高API测试过程的效率。Postman（[https://www.postman.com/](https://www.postman.com/)）是一个非常方便的工具，可以帮助你测试API。你可以使用Postman从头开始创建复杂的API请求，并管理你将发送的大量测试请求。GraphQL
    Playground（[https://github.com/graphql/graphql-playground/](https://github.com/graphql/graphql-playground/)）是一个用来编写GraphQL查询的IDE，具有自动补全和错误高亮功能。
- en: ZAP has a GraphQL add-on ([https://www.zaproxy.org/blog/2020-08-28-introducing-the-graphql-add-on-for-zap/](https://www.zaproxy.org/blog/2020-08-28-introducing-the-graphql-add-on-for-zap/))
    that automates GraphQL introspection and test query generation. Clairvoyance ([https://github.com/nikitastupin/clairvoyance/](https://github.com/nikitastupin/clairvoyance/))
    helps you gain insight into a GraphQL API’s structure when introspection is disabled.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ZAP有一个GraphQL插件（[https://www.zaproxy.org/blog/2020-08-28-introducing-the-graphql-add-on-for-zap/](https://www.zaproxy.org/blog/2020-08-28-introducing-the-graphql-add-on-for-zap/)），可以自动化GraphQL自省和测试查询生成。Clairvoyance（[https://github.com/nikitastupin/clairvoyance/](https://github.com/nikitastupin/clairvoyance/)）帮助你在自省被禁用时深入了解GraphQL
    API的结构。
- en: Performing Recon
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行侦察
- en: First, hunting for API vulnerabilities is very much like hunting for vulnerabilities
    in regular web applications in that it requires recon. The most difficult aspect
    of API testing is knowing what the application expects and then tailoring payloads
    to manipulate its functionality.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，寻找API漏洞与寻找常规Web应用程序的漏洞非常相似，都需要进行侦察。API测试中最困难的方面是了解应用程序的预期，然后调整有效载荷以操控其功能。
- en: If you’re hacking a GraphQL API, you might start by sending introspection queries
    to figure out the API’s structure. If you are testing a SOAP API, start by looking
    for the WSDL file. If you’re attacking a REST or SOAP API, or if introspection
    is disabled on the GraphQL API you’re attacking, start by enumerating the API.
    *API enumeration* refers to the process of identifying as many of the API’s endpoints
    as you can so you can test as many endpoints as possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在攻击GraphQL API，你可以通过发送自省查询来了解API的结构。如果你正在测试SOAP API，可以先寻找WSDL文件。如果你攻击的是REST或SOAP
    API，或者你攻击的GraphQL API禁用了自省功能，首先从枚举API开始。*API枚举*是指识别尽可能多的API端点，以便你可以测试尽可能多的端点的过程。
- en: To enumerate the API, start by reading the API’s public documentation if it
    has one. Companies with public APIs often publish detailed documentation about
    the API’s endpoints and their parameters. You should be able to find public API
    documentations by searching the internet for *company_name API* or *company_name
    developer docs*. This documentation provides a good start for enumerating API
    endpoints, but don’t be fooled into thinking that the official documentation contains
    all the endpoints you can test! APIs often have public and private endpoints,
    and only the public ones will be found in these developer guides.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要枚举API，首先阅读API的公共文档（如果有的话）。拥有公共API的公司通常会发布关于API端点及其参数的详细文档。你可以通过在互联网上搜索*公司名称
    API* 或 *公司名称 开发者文档* 来找到公共API文档。这些文档是枚举API端点的一个良好起点，但不要被误导，以为官方文档包含了你可以测试的所有端点！API通常有公共和私有端点，只有公共端点会出现在这些开发者指南中。
- en: Try using Swagger ([https://swagger.io/](https://swagger.io/)), a toolkit developers
    use for developing APIs. Swagger includes a tool for generating and maintaining
    API documentation that developers often use to document APIs internally. Sometimes
    companies don’t publicly publish their API documentation but forget to lock down
    internal documentation hosted on Swagger. In this case, you can find the documentation
    by searching the internet for *company_name inurl:swagger*. This documentation
    often includes all API endpoints, their input parameters, and sample responses.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Swagger（[https://swagger.io/](https://swagger.io/)），这是开发人员用于开发API的工具包。Swagger包含一个用于生成和维护API文档的工具，开发人员通常用它来内部记录API。有时候公司不会公开发布API文档，但忘记了锁定托管在Swagger上的内部文档。在这种情况下，你可以通过搜索互联网中的*公司名称
    inurl:swagger*来找到文档。这些文档通常包括所有API端点、它们的输入参数以及示例响应。
- en: The next thing you can do is go through all the application workflows to capture
    API calls. You can do this by browsing the company’s applications with an intercepting
    proxy recording HTTP traffic in the background. You might find API calls used
    in the application’s workflow that aren’t in public documentation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以浏览所有应用程序的工作流，以捕捉API调用。你可以通过使用拦截代理记录后台HTTP流量来浏览公司的应用程序。在应用程序的工作流中，你可能会发现一些没有出现在公共文档中的API调用。
- en: Using the endpoints you’ve found, you can try to deduce other endpoints. For
    instance, REST APIs often have a predictable structure, so you can deduce new
    endpoints by studying existing ones. If both */posts/POST_ID/read* and /*posts/POST_ID/delete*
    exist, is there an endpoint called */posts/POST_ID/edit*? Similarly, if you find
    blog posts located at */posts/1234* and */posts/1236*, does /*posts/1235* also
    exist?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你找到的端点，你可以尝试推测其他端点。例如，REST API 通常具有可预测的结构，因此你可以通过研究现有端点来推测新的端点。如果 */posts/POST_ID/read*
    和 /*posts/POST_ID/delete* 都存在，那么是否也有一个名为 */posts/POST_ID/edit* 的端点？类似地，如果你发现博客文章位于
    */posts/1234* 和 */posts/1236*，那么 /*posts/1235* 是否也存在？
- en: Next, search for other API endpoints by using recon techniques from Chapter
    5, such as studying JavaScript source code or the company’s public GitHub repositories.
    You can also try to generate error messages in hopes that the API leaks information
    about itself. For example, try to provide unexpected data types or malformed JSON
    code to the API endpoints. Fuzzing techniques can also help you find additional
    API endpoints by using a wordlist. Many online wordlists are tailored for fuzzing
    API endpoints; one example wordlist is at [https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d/](https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d/).
    We will talk more about how to fuzz an endpoint in Chapter 25.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用第 5 章中的侦查技术，寻找其他 API 端点，例如研究 JavaScript 源代码或公司的公开 GitHub 仓库。你还可以尝试生成错误消息，希望
    API 泄露关于它本身的信息。例如，尝试向 API 端点提供意外的数据类型或格式不正确的 JSON 代码。模糊测试技术也可以通过使用单词列表帮助你找到其他
    API 端点。许多在线单词列表专门用于模糊测试 API 端点；一个示例单词列表可以在[https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d/](https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d/)找到。我们将在第
    25 章中进一步讨论如何模糊测试端点。
- en: 'Also note that APIs are often updated. While the application might not actively
    use older versions of the API, these versions might still elicit a response from
    the server. For every endpoint you find in a later version of the API, you should
    test whether an older version of the endpoint works. For example, if the */api/****v2****/user_emails/52603991338963203244*
    endpoint exists, does this one: /*api/****v1****/user_emails/52603991338963203244*?
    Older versions of an API often contain vulnerabilities that have been fixed in
    newer versions, so make sure to include finding older API endpoints in your recon
    strategy.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，API 经常会更新。虽然应用程序可能不再积极使用旧版本的 API，但这些版本可能仍会向服务器发出响应。对于你在 API 后续版本中发现的每个端点，你应该测试旧版本的端点是否可用。例如，如果
    */api/****v2****/user_emails/52603991338963203244* 端点存在，那么 */api/****v1****/user_emails/52603991338963203244*
    是否也存在？ API 的旧版本通常包含已在新版本中修复的漏洞，因此请确保将查找旧版本的 API 端点纳入你的侦查策略中。
- en: 'Finally, take the time to understand each API endpoint’s functionality, parameters,
    and query structure. The more you can learn about how an API works, the more you’ll
    understand how to attack it. Identify all the possible user data input locations
    for future testing. Look out for any authentication mechanisms, including these:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，花时间理解每个 API 端点的功能、参数和查询结构。你对 API 工作原理的了解越深入，就越能理解如何攻击它。识别所有可能的用户数据输入位置，以便未来测试。注意任何认证机制，包括以下内容：
- en: What access tokens are needed?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要哪些访问令牌？
- en: Which endpoints require tokens and which do not?
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些端点需要令牌，哪些不需要？
- en: How are access tokens generated?
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌是如何生成的？
- en: Can users use the API to generate a valid token without logging in?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在不登录的情况下使用 API 生成有效的令牌吗？
- en: Do access tokens expire when updating or resetting passwords?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新或重置密码时，访问令牌会过期吗？
- en: Throughout your recon process, make sure to take lots of notes. Document the
    endpoints you find and their parameters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个侦查过程中，一定要记下大量笔记。记录你找到的端点及其参数。
- en: Testing for Broken Access Control and Info Leaks
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试访问控制漏洞和信息泄露
- en: After recon, I like to start by testing for access-control issues and info leaks.
    Most APIs use access tokens to determine the rights of the client; they issue
    access tokens to each API client, and clients use these to perform actions or
    retrieve data. If these API tokens aren’t properly issued and validated, attackers
    might bypass authentication and access data illegally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在侦查后，我喜欢从测试访问控制问题和信息泄露开始。大多数 API 使用访问令牌来确定客户端的权限；它们为每个 API 客户端颁发访问令牌，客户端使用这些令牌来执行操作或检索数据。如果这些
    API 令牌没有正确发放和验证，攻击者可能绕过认证，非法访问数据。
- en: For example, sometimes API tokens aren’t validated after the server receives
    them. Other times, API tokens are not randomly generated and can be predicted.
    Finally, some API tokens aren’t invalidated regularly, so attackers who’ve stolen
    tokens maintain access to the system indefinitely.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有时API令牌在服务器接收后没有进行验证。其他时候，API令牌没有随机生成，可以被预测。最后，一些API令牌没有定期失效，因此攻击者在窃取令牌后可以无限期地访问系统。
- en: Another issue is broken resource or function-level access control. Sometimes
    API endpoints don’t have the same access-control mechanisms as the main application.
    For example, say a user with a valid API key can retrieve data about themselves.
    Can they also read data about other users? Or can they perform actions on another’s
    behalf through the API? Finally, can a regular user without admin privileges read
    data from endpoints restricted to admins? Separately from REST or SOAP APIs, the
    GraphQL API of an application may have its own authorization mechanisms and configuration.
    This means that you can test for access-control issues on GraphQL endpoints even
    though the web or REST API of an application is secure. These issues are similar
    to the IDOR vulnerabilities discussed in Chapter 10.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是资源或功能级别的访问控制问题。有时，API端点并没有与主应用程序相同的访问控制机制。例如，假设一个拥有有效API密钥的用户可以检索关于自己的数据。他们是否也能读取其他用户的数据？或者他们能否通过API代表他人执行操作？最后，没有管理员权限的普通用户是否可以读取仅限管理员访问的端点数据？与REST或SOAP
    API不同，应用程序的GraphQL API可能有自己独立的授权机制和配置。这意味着，即使应用程序的Web或REST API是安全的，你也可以在GraphQL端点上测试访问控制问题。这些问题类似于第10章中讨论的IDOR漏洞。
- en: 'Other times still, an API offers multiple ways to perform the same action,
    and access control isn’t implemented across all of them. For example, let’s say
    that a REST API has two ways of deleting a blog post: sending a POST request to
    */posts/POST_ID/delete* and sending a DELETE request to */posts/POST_ID*. You
    should ask yourself: are the two endpoints subject to the same access controls?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，有时一个API提供多种方式来执行相同的操作，而访问控制并未在所有方式中实现。例如，假设一个REST API有两种方式来删除博客文章：发送POST请求到*/posts/POST_ID/delete*，或者发送DELETE请求到*/posts/POST_ID*。你应该问自己：这两个端点是否受到相同的访问控制？
- en: Another common API vulnerability is information leaks. API endpoints often return
    more information than they should, or than is needed to render the web page. For
    example, I once found an API endpoint that populated a user’s profile page. When
    I visited someone else’s profile page, an API call was used to return the profile
    owner’s information. At first glance, the profile page didn’t leak any sensitive
    information, but the API response used to fetch the user’s data actually returned
    the profile owner’s private API token as well! After an attacker steals the victim’s
    API token by visiting their profile page, they could impersonate the victim by
    using this access token.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的API漏洞是信息泄露。API端点常常返回比必要的更多的信息，或者返回不需要的内容来渲染网页。例如，我曾经发现一个API端点，用于填充用户的个人资料页面。当我访问其他人的个人资料页面时，API调用返回了该资料主人的信息。乍一看，个人资料页面似乎没有泄露任何敏感信息，但实际上，获取用户数据的API响应却返回了该资料主人的私人API令牌！当攻击者通过访问受害者的个人资料页面窃取其API令牌后，他们可以使用该访问令牌冒充受害者。
- en: 'Make a list of the endpoints that should be restricted by some form of access
    control. For each of these endpoints, create two user accounts with different
    levels of privilege: one that should have access to the functionality and one
    that shouldn’t. Test whether you can access the restricted functionality with
    the lower-privileged account.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一份应该由某种形式的访问控制限制的端点列表。对于每个端点，创建两个不同权限级别的用户帐户：一个应该能够访问该功能，另一个不应该。测试是否能够使用低权限帐户访问受限功能。
- en: If your lower-privileged user can’t access the restricted functionality, try
    removing access tokens, or adding additional parameters like the cookie `admin=1`
    to the API call. You can also switch out the HTTP request methods, including GET,
    POST, PUT, PATCH, and DELETE, to see if access control is properly implemented
    across all methods. For example, if you can’t edit another user’s blog posts via
    a POST request to an API endpoint, can you bypass the protection by using a PUT
    request instead?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果权限较低的用户无法访问受限功能，可以尝试移除访问令牌，或者添加额外的参数，如在API调用中加入cookie `admin=1`。你还可以切换HTTP请求方法，包括GET、POST、PUT、PATCH和DELETE，看看是否在所有方法中都正确实施了访问控制。例如，如果你不能通过POST请求到API端点来编辑其他用户的博客文章，那么你是否能通过使用PUT请求绕过保护？
- en: Try to view, modify, and delete other users’ info by switching out user IDs
    or other user identification parameters found in the API calls. If IDs used to
    identify users and resources are unpredictable, try to leak IDs through info leaks
    from other endpoints. For example, I once found an API endpoint that returned
    user information; it revealed the user’s ID as well as all of the user’s friends’
    IDs. With the ID of both the user and their friend, I was able to access messages
    sent between the two users. By combining two info leaks and using just the user
    IDs, I was able to read a user’s private messages!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过更换用户ID或API调用中找到的其他用户识别参数，查看、修改和删除其他用户的信息。如果用于标识用户和资源的ID不可预测，尝试通过其他端点的信息泄露来泄露ID。例如，我曾经找到一个API端点，它返回了用户信息，暴露了用户的ID以及所有用户朋友的ID。通过获取用户和朋友的ID，我能够访问两者之间发送的消息。通过结合两个信息泄露，仅使用用户ID，我成功读取了用户的私人消息！
- en: In GraphQL, a common misconfiguration is allowing lower-privileged users to
    modify a piece of data that they should not via a mutation request. Try to capture
    GraphQL queries allowed from one user’s account, and see if you can send the same
    query and achieve the same results from another who shouldn’t have permission.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中，一个常见的错误配置是允许权限较低的用户通过变更请求修改他们不应该修改的数据。尝试捕捉一个用户账户允许的GraphQL查询，并查看你是否可以通过另一个不应拥有权限的用户发送相同的查询并获得相同的结果。
- en: While hunting for access control issues, closely study the data being sent back
    by the server. Don’t just look at the resulting HTML page; dive into the raw API
    response, as APIs often return data that doesn’t get displayed on the web page.
    You might be able to find sensitive information disclosures in the response body.
    Is the API endpoint returning any private user information, or sensitive information
    about the organization? Should the returned information be available to the current
    user? Does the returned information pose a security risk to the company?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找访问控制问题时，仔细研究服务器返回的数据。不要仅仅查看结果HTML页面；深入分析原始API响应，因为API通常返回未显示在网页上的数据。你可能会在响应体中发现敏感信息泄露。API端点是否返回了任何私人用户信息，或者关于组织的敏感信息？返回的信息是否应该对当前用户可用？返回的信息是否对公司构成安全风险？
- en: Testing for Rate-Limiting Issues
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试速率限制问题
- en: APIs often lack rate limiting; in other words, the API server doesn’t restrict
    the number of requests a client or user account can send within a short time frame.
    A lack of rate limiting in itself is a low-severity vulnerability unless it’s
    proven to be exploitable by attackers. But on critical endpoints, a lack of rate
    limiting means that malicious users can send large numbers of requests to the
    server to harvest database information or brute-force credentials.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: API通常缺乏速率限制；换句话说，API服务器没有限制客户端或用户账户在短时间内可以发送的请求数量。缺乏速率限制本身是一个低严重性的漏洞，除非它被证明能够被攻击者利用。但是，在关键的端点上，缺乏速率限制意味着恶意用户可以向服务器发送大量请求，从而窃取数据库信息或暴力破解凭证。
- en: 'Endpoints that can be dangerous when not rate limited include authentication
    endpoints, endpoints not protected by access control, and endpoints that return
    large amounts of sensitive data. For example, I once encountered an API endpoint
    that allows users to retrieve their emails via an email ID, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有速率限制的情况下，可能会很危险的端点包括认证端点、没有访问控制保护的端点以及返回大量敏感数据的端点。例如，我曾经遇到过一个API端点，允许用户通过电子邮件ID检索他们的电子邮件，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This endpoint isn’t protected by any access control. Since this endpoint isn’t
    rate limited, either, an attacker can essentially guess the email ID field by
    sending numerous requests. Once they’ve guessed a valid ID, they can access another
    user’s private email.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点没有受到任何访问控制的保护。由于这个端点没有速率限制，攻击者实际上可以通过发送大量请求来猜测电子邮件ID字段。一旦猜到有效的ID，他们就能访问另一个用户的私人电子邮件。
- en: To test for rate-limiting issues, make large numbers of requests to the endpoint.
    You can use the Burp intruder or `curl` to send 100 to 200 requests in a short
    time. Make sure you repeat the test in different authentication stages, because
    users with different privilege levels can be subject to different rate limits.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 测试速率限制问题时，可以向端点发送大量请求。你可以使用Burp Intruder或`curl`在短时间内发送100到200个请求。确保在不同的认证阶段重复测试，因为不同权限级别的用户可能会受到不同的速率限制。
- en: Be really careful when you are testing for rate-limiting issues because it’s
    very possible to accidentally launch a DoS attack on the app by drowning it with
    requests. You should obtain written permission before conducting rate-limiting
    tests and time-throttle your requests according to the company’s policies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试速率限制问题时要格外小心，因为很容易因为请求过多而意外地对应用程序发起DoS攻击。在进行速率限制测试之前，应该获得书面许可，并根据公司的政策按时限来控制你的请求。
- en: Also keep in mind that applications could have rate limits that are higher than
    your testing tools’ capabilities. For instance, applications could set a rate
    limit of 400 requests a second, and your tooling may not be capable of reaching
    that limit.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，应用程序可能设置的速率限制高于你的测试工具的能力。例如，应用程序可能设置每秒400个请求的速率限制，而你的工具可能无法达到这一限制。
- en: Testing for Technical Bugs
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术漏洞测试
- en: Many of the bugs that we’ve discussed in this book so far—such as SQL injection,
    deserialization issues, XXEs, template injections, SSRF, and RCEs—are caused by
    improper input validation. Sometimes developers forget to implement proper input
    validation mechanisms for APIs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 书中我们讨论过的许多漏洞——如SQL注入、反序列化问题、XXE、模板注入、SSRF和RCE——都是由于输入验证不当造成的。有时，开发人员会忘记为API实现适当的输入验证机制。
- en: APIs are therefore susceptible to many of the other vulnerabilities that affect
    regular web applications too. Since APIs are another way applications accept user
    input, they become another way for attackers to smuggle malicious input into the
    application’s workflow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，API也容易受到许多影响常规Web应用程序的其他漏洞的攻击。由于API是应用程序接受用户输入的另一种方式，它们成为攻击者将恶意输入传递到应用程序工作流中的另一种途径。
- en: If an API endpoint can access external URLs, it might be vulnerable to SSRF,
    so you should check whether its access to internal URLs isn’t restricted. Race
    conditions can also happen within APIs. If you can use API endpoints to access
    application features affected by race conditions, these endpoints can become an
    alternative way to trigger the race condition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API端点可以访问外部URL，则可能存在SSRF漏洞，因此你应该检查其对内部URL的访问是否受到限制。API中也可能发生竞态条件。如果你能够利用API端点访问受竞态条件影响的应用程序功能，这些端点可能成为触发竞态条件的另一种方式。
- en: Other vulnerabilities, like path traversal, file inclusion, insecure deserialization
    issues, XXE, and XSS can also happen. If an API endpoint returns internal resources
    via a filepath, attackers might use that endpoint to read sensitive files stored
    on the server. If an API endpoint used for file uploads doesn’t limit the data
    type that users can upload, attackers might upload malicious files, such as web
    shells or other malware, to the server. APIs also commonly accept user input in
    serialized formats such as XML. In this case, insecure deserialization or XXEs
    can happen. RCEs via file upload or XXEs are commonly seen in API endpoints. Finally,
    if an API’s URL parameters are reflected in the response, attackers can use that
    API endpoint to trigger reflected XSS on victims’ browsers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其他漏洞，如路径遍历、文件包含、不安全的反序列化问题、XXE和XSS也可能发生。如果API端点通过文件路径返回内部资源，攻击者可能利用该端点读取存储在服务器上的敏感文件。如果用于文件上传的API端点没有限制用户可以上传的数据类型，攻击者可能会上传恶意文件，如Web
    Shell或其他恶意软件到服务器。API通常还会接受以XML等序列化格式提供的用户输入。在这种情况下，不安全的反序列化或XXE问题可能会发生。通过文件上传或XXE的RCE通常在API端点中见到。最后，如果API的URL参数在响应中被反射，攻击者可以利用该API端点触发受害者浏览器上的反射型XSS攻击。
- en: The process of testing for these issues will be similar to testing for them
    in a regular web app. You’ll simply supply the payloads to the application in
    API form.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这些问题的过程将类似于常规Web应用程序的测试。你只需要以API的形式将有效载荷提供给应用程序。
- en: For example, for vulnerabilities like path traversals and file-inclusion attacks,
    look out for absolute and relative filepaths in API endpoints and try to mess
    with the path parameters. If an API endpoint accepts XML input, try to insert
    an XXE payload into the request. And if the endpoint’s URL parameters are reflected
    in the response, see if you can trigger a reflected XSS by placing a payload in
    the URL.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于路径遍历和文件包含攻击等漏洞，注意API端点中的绝对路径和相对路径，并尝试修改路径参数。如果API端点接受XML输入，尝试将XXE有效载荷插入请求中。如果该端点的URL参数在响应中被反射，查看是否可以通过在URL中放置有效载荷来触发反射型XSS。
- en: You can also utilize fuzz-testing techniques, which we’ll discuss in Chapter
    25, to find these vulnerabilities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以利用模糊测试技术（我们将在第25章讨论），来发现这些漏洞。
- en: Applications are becoming increasingly reliant on APIs, even as APIs aren’t
    always as well protected as their web application counterparts. Pay attention
    to the APIs used by your targets, and you might find issues not present in the
    main application. If you are interested in learning more about hacking APIs and
    web applications in general, the OWASP Web Security Testing Guide ([https://github.com/OWASP/wstg/](https://github.com/OWASP/wstg/))
    is a great resource to learn from.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序越来越依赖于API，即使API的保护措施往往不如其Web应用程序的同类那样完善。注意观察你目标使用的API，你可能会发现一些在主应用程序中不存在的问题。如果你有兴趣了解更多关于API和Web应用程序的黑客攻击方法，OWASP
    Web安全测试指南（[https://github.com/OWASP/wstg/](https://github.com/OWASP/wstg/)）是一个很好的学习资源。
