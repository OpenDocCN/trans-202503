<html><head></head><body><section class="chapter" title="Chapter&#xA0;5.&#xA0;Working With Arrays and Strings" epub:type="chapter" id="working_with_arrays_and_strings"><div class="titlepage"><div><div><h2 class="title">Chapter 5. Working With Arrays and Strings</h2></div></div></div><p><a id="idx00042" class="indexterm"/><a id="idx00065" class="indexterm"/><a id="idx00284" class="indexterm"/><a id="idx00370" class="indexterm"/><a id="idx00447" class="indexterm"/><a id="idx00522" class="indexterm"/><a id="idx00569" class="indexterm"/>In this chapter, we’ll look at various one-liners for creating strings and arrays, for doing things like generating passwords, creating strings of certain length, finding the numeric values of characters, and creating arrays of numbers. You’ll also learn about the range operator <code class="literal">..</code>, the <code class="literal">x</code> operator, the <code class="literal">$</code>, special variable, and the <code class="literal">@ARGV</code> array.</p><div class="sect1" title="5.1 Generate and print the alphabet"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_1_generate_and_print_the_alphabet">5.1 Generate and print the alphabet</h2></div></div></div><a id="I_programlisting5_id308289"/><pre class="programlisting">perl -le 'print a..z'</pre><p>This one-liner prints all letters from <code class="literal">a</code> to <code class="literal">z</code> in the English alphabet as <code class="literal">abcdefghijklmnopqrstuvwxyz</code>. The letters are generated by the range operator <code class="literal">..</code>, which, when used on strings in the list context (provided here by <code class="literal">print</code>), applies the magical auto-increment algorithm that advances the string to the next character. Therefore, in this one-liner, the auto-increment algorithm on the range <code class="literal">a..z</code> produces all letters from <code class="literal">a</code> to <code class="literal">z</code>.</p><p><a id="idx00261" class="indexterm"/><a id="idx00292" class="indexterm"/><a id="idx00331" class="indexterm"/><a id="idx00568" class="indexterm"/>I really golfed this one-liner. If I had used <code class="literal">strict</code>, it wouldn’t have worked because of the bare words <code class="literal">a</code> and <code class="literal">z</code>. This version is more correct semantically:</p><a id="I_programlisting5_id308378"/><pre class="programlisting">perl -le 'print ("a".."z")'</pre><p>Remember that the range operator <code class="literal">..</code> produces a list of values. If you wish, you could print the values with comma separations by setting the <code class="literal">$</code>, special variable:</p><a id="I_programlisting5_id308393"/><pre class="programlisting">perl -le '$, = ","; print ("a".."z")'</pre><p>The <code class="literal">$</code>, is the field separator. It’s output by <code class="literal">print</code> between each field. Semantically, though, using <code class="literal">join</code> to separate the list of letters with a comma is more appealing because it works even when not using <code class="literal">print</code> directly:</p><a id="I_programlisting5_id308417"/><pre class="programlisting">perl -le '$alphabet = join ",", ("a".."z"); print $alphabet'</pre><p>Here, the list <code class="literal">a..z</code> is joined by a comma before printing, and the output is</p><a id="I_programlisting5_id308428"/><pre class="programlisting">a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z</pre></div><div class="sect1" title="5.2 Generate and print all the strings from “a” to “zz”"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_2_generate_and_print_all_the_string">5.2 Generate and print all the strings from “a” to “zz”</h2></div></div></div><a id="I_programlisting5_id308443"/><pre class="programlisting">perl -le 'print join ",", ("a".."zz")'</pre><p>This one-liner uses the range operator <code class="literal">..</code> again, but this time, it doesn’t stop at <code class="literal">z</code> as in the previous one-liner. Instead, it advances <code class="literal">z</code> by one character, producing <code class="literal">aa</code>. Then it keeps going, producing <code class="literal">ab</code>, <code class="literal">ac</code>, and so on, until it hits <code class="literal">az</code>. At that point, it advances the string to <code class="literal">ba</code>, continues with <code class="literal">bb</code>, <code class="literal">bc</code>, and so on, until eventually it reaches <code class="literal">zz</code>.</p><p>You could also generate all strings from <code class="literal">aa</code> to <code class="literal">zz</code> by doing this:</p><a id="I_programlisting5_id308504"/><pre class="programlisting">perl -le 'print join ",", "aa".."zz"'</pre><p>The output from this one-liner is</p><a id="I_programlisting5_id308512"/><pre class="programlisting">aa, ab, ..., az, ba, bb, ..., bz, ca, ..., zz</pre></div><div class="sect1" title="5.3 Create a hex lookup table"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_3_create_a_hex_lookup_table">5.3 Create a hex lookup table</h2></div></div></div><a id="I_programlisting5_id308526"/><pre class="programlisting">@hex = (0..9, "a".."f")</pre><p><a id="idx00275" class="indexterm"/><a id="idx00289" class="indexterm"/><a id="idx00301" class="indexterm"/><a id="idx00303" class="indexterm"/><a id="idx00384" class="indexterm"/><a id="idx00455" class="indexterm"/><a id="idx00483" class="indexterm"/><a id="idx00518" class="indexterm"/><a id="idx00520" class="indexterm"/><a id="idx00573" class="indexterm"/><a id="idx00671" class="indexterm"/>In this one-liner, the <code class="literal">@hex</code> array is filled with the numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 and the letters a, b, c, d, e, f. You could use this array to convert a number (in variable <code class="literal">$num</code>) from decimal to hex with the following base conversion formula. (This isn’t a one-liner; I include it to illustrate how to use the <code class="literal">@hex</code> lookup array.)</p><a id="I_programlisting5_id308627"/><pre class="programlisting">perl -le '
  $num = 255;
  @hex = (0..9, "a".."f");
  while ($num) {
    $s = $hex[($num % 16)].$s;
    $num = int $num/16;
  }
  print $s
'</pre><p>But surely, converting a number to hex is much easier if I use <code class="literal">printf</code> (or <code class="literal">sprintf</code>) with the <code class="literal">%x</code> format specifier.</p><a id="I_programlisting5_id308647"/><pre class="programlisting">perl -le 'printf("%x", 255)'</pre><p>To convert the number back from hex to dec, use the <code class="literal">hex</code> operator:</p><a id="I_programlisting5_id308658"/><pre class="programlisting">perl -le '$num = "ff"; print hex $num'</pre><p>The <code class="literal">hex</code> operator takes a hex string (beginning with or without <code class="literal">0x</code>) and converts it to decimal.</p></div><div class="sect1" title="5.4 Generate a random eight-character password"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_4_generate_a_random_eight-character">5.4 Generate a random eight-character password</h2></div></div></div><a id="I_programlisting5_id308685"/><pre class="programlisting">perl -le 'print map { ("a".."z")[rand 26] } 1..8'</pre><p>Here, the <code class="literal">map</code> operator executes the code <code class="literal">("a".."z")[rand 26]</code> eight times because it iterates over the range <code class="literal">1..8</code>. In each iteration, the code chooses a random letter from the alphabet. When <code class="literal">map</code> has finished iterating, it returns the generated list of characters, and <code class="literal">print</code> prints it, thereby concatenating all the characters.</p><p><a id="idx00338" class="indexterm"/><a id="idx00369" class="indexterm"/><a id="idx00466" class="indexterm"/><a id="idx00471" class="indexterm"/><a id="idx00558" class="indexterm"/><a id="idx00563" class="indexterm"/><a id="idx00572" class="indexterm"/><a id="idx00676" class="indexterm"/>To also include numbers in the password, add <code class="literal">0..9</code> to the list of characters to choose from and change <code class="literal">26</code> to <code class="literal">36</code> because you now have <code class="literal">36</code> possible characters:</p><a id="I_programlisting5_id308796"/><pre class="programlisting">perl -le 'print map { ("a".."z", 0..9)[rand 36] } 1..8'</pre><p>If you need a longer password, change <code class="literal">1..8</code> to <code class="literal">1..20</code> to generate one that’s 20 characters long.</p></div><div class="sect1" title="5.5 Create a string of specific length"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_5_create_a_string_of_specific_lengt">5.5 Create a string of specific length</h2></div></div></div><a id="I_programlisting5_id308822"/><pre class="programlisting">perl -le 'print "a"x50'</pre><p>This one-liner creates a string of 50 letters <code class="literal">a</code> and prints it. Operator <code class="literal">x</code> is the repetition operator. Here, the letter <code class="literal">a</code> is repeated 50 times by <code class="literal">x50</code>. This one-liner is handy when you need to generate a specific amount of data for debugging or other tasks. For example, if you need 1KB of data, just do this:</p><a id="I_programlisting5_id308845"/><pre class="programlisting">perl -e 'print "a"x1024'</pre><p>I removed the <code class="literal">-l</code> argument because it would have output an additional newline symbol, producing 1025 bytes of data.</p><p>When you use the repetition operator in the list context, with a list as its first operand, you create a list with the given elements repeated, like this:</p><a id="I_programlisting5_id308861"/><pre class="programlisting">perl -le '@list = (1,2)x20; print "@list"'</pre><p>This one-liner creates a list of 20 repetitions of <code class="literal">(1, 2)</code> that looks like <code class="literal">(1, 2, 1, 2, 1, 2, ...)</code>. (The parentheses to the left of <code class="literal">x</code> make a list.)</p></div><div class="sect1" title="5.6 Create an array from a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_6_create_an_array_from_a_string">5.6 Create an array from a string</h2></div></div></div><a id="I_programlisting5_id308891"/><pre class="programlisting">@months = split ' ', "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"</pre><p>Here, <code class="literal">@months</code> is filled with values from the string containing month names. Because all month names are separated by a space, the <code class="literal">split</code> operator splits them and puts them in <code class="literal">@months</code>. As a result, <code class="literal">$months[0]</code> contains <code class="literal">Jan</code>, <code class="literal">$months[1]</code> contains <code class="literal">Feb</code>, … , and <code class="literal">$months[11]</code> contains <code class="literal">Dec</code>.</p><p><a id="idx00013" class="indexterm"/><a id="idx00066" class="indexterm"/><a id="idx00067" class="indexterm"/><a id="idx00109" class="indexterm"/><a id="idx00431" class="indexterm"/><a id="idx00457" class="indexterm"/><a id="idx00461" class="indexterm"/><a id="idx00474" class="indexterm"/><a id="idx00516" class="indexterm"/><a id="idx00566" class="indexterm"/><a id="idx00571" class="indexterm"/><a id="idx00579" class="indexterm"/><a id="idx00625" class="indexterm"/><a id="idx00626" class="indexterm"/>You could do the same thing with the <code class="literal">qw/.../</code> operator:</p><a id="I_programlisting5_id309046"/><pre class="programlisting">@months = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/</pre><p>The <code class="literal">qw/.../</code> operator takes a space-separated string and creates an array in which each word is an array element.</p><p>Although not a one-liner per se, this is a useful, idiomatic way to create arrays that can come in handy when writing one-liners.</p></div><div class="sect1" title="5.7 Create a string from the command-line arguments"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_7_create_a_string_from_the_command-">5.7 Create a string from the command-line arguments</h2></div></div></div><a id="I_programlisting5_id309074"/><pre class="programlisting">perl -le 'print "(", (join ",", @ARGV), ")"' <span class="emphasis"><em>val1 val2 val3</em></span></pre><p>This one-liner uses the <code class="literal">@ARGV</code> array, which contains all the arguments that have been passed to Perl. In this one-liner, the values passed to Perl are <code class="literal">val1</code>, <code class="literal">val2</code>, and <code class="literal">val3</code>, so <code class="literal">@ARGV</code> contains the strings <code class="literal">val1</code>, <code class="literal">val2</code>, and <code class="literal">val3</code>. This one-liner prints the string <code class="literal">(val1,val2,val3)</code> and would be useful, for example, to generate a SQL query.</p><p>If you’re familiar with the INSERT query in SQL, you know its most basic form looks like <code class="literal">INSERT INTO table VALUES (val1, val2, val3, ...)</code>. As you can see, this one-liner generates the <code class="literal">VALUES</code> part of the SQL query.</p><p>You can easily modify this one-liner to print the whole INSERT query:</p><a id="I_programlisting5_id309135"/><pre class="programlisting">perl -le '
  print "INSERT INTO table VALUES (", (join ",", @ARGV), ")"
' val1 val2 val3</pre><p>Here’s what the one-liner prints:</p><a id="I_programlisting5_id309143"/><pre class="programlisting">INSERT INTO <span class="emphasis"><em>table</em></span> VALUES (<span class="emphasis"><em>val1,val2,val3</em></span>)</pre></div><div class="sect1" title="5.8 Find the numeric values for characters in a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_8_find_the_numeric_values_for_chara">5.8 Find the numeric values for characters in a string</h2></div></div></div><a id="I_programlisting5_id309167"/><pre class="programlisting">perl -le 'print join ", ", map { ord } split //, "hello world"'</pre><p>This one-liner takes the string <code class="literal">"hello world"</code> and splits it into a list of characters with <code class="literal">split //, "hello world"</code>. It then maps the <code class="literal">ord</code> operator onto each of the characters, which returns each character’s numeric value. Finally, all of the numeric values are joined together by a comma and printed. Here’s the output:</p><a id="I_programlisting5_id309187"/><pre class="programlisting">104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100</pre><p><a id="idx00276" class="indexterm"/><a id="idx00282" class="indexterm"/><a id="idx00559" class="indexterm"/><a id="idx00617" class="indexterm"/>You could also do this with the <code class="literal">unpack</code> operator by specifying <code class="literal">C*</code> as the unpacking template:</p><a id="I_programlisting5_id309231"/><pre class="programlisting">perl -le 'print join ", ", unpack("C*", "hello world")'</pre><p>The <code class="literal">C</code> in the template means “unsigned character” and <code class="literal">*</code> means “all characters.”</p><p>To find the hexadecimal values of the characters, you could do this:</p><a id="I_programlisting5_id309250"/><pre class="programlisting">perl -le '
  print join ", ", map { sprintf "0x%x", ord $_ } split //, "hello world"
'</pre><p>Here, the <code class="literal">map</code> operator executes <code class="literal">sprintf "0x%x", ord $_</code> for every character, which returns the character’s hexadecimal value prepended with <code class="literal">'0x'</code>. Here’s the output:</p><a id="I_programlisting5_id309269"/><pre class="programlisting">0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64</pre><p>Similarly, to get the octal values of characters, you do this:</p><a id="I_programlisting5_id309277"/><pre class="programlisting">perl -le '
  print join ", ", map { sprintf "%o", ord $_ } split //, "hello world"
'</pre><p>Here’s the output:</p><a id="I_programlisting5_id309285"/><pre class="programlisting">150, 145, 154, 154, 157, 40, 167, 157, 162, 154, 144</pre><p>And finally, to generate proper octal values that begin with <code class="literal">0</code>, you can specify the <code class="literal">%#o</code> format to the <code class="literal">sprintf</code> function:</p><a id="I_programlisting5_id309305"/><pre class="programlisting">perl -le '
  print join ", ", map { sprintf "%#o", ord $_ } split //, "hello world"
'</pre><p>And here’s the output:</p><a id="I_programlisting5_id309313"/><pre class="programlisting">0150, 0145, 0154, 0154, 0157, 040, 0167, 0157, 0162, 0154, 0144</pre></div><div class="sect1" title="5.9 Convert a list of numeric ASCII values into a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_9_convert_a_list_of_numeric_ascii_v">5.9 Convert a list of numeric ASCII values into a string</h2></div></div></div><a id="I_programlisting5_id309327"/><pre class="programlisting">perl -le '
  @ascii = (99, 111, 100, 105, 110, 103);
  print pack("C*", @ascii)
'</pre><p><a id="idx00072" class="indexterm"/><a id="idx00111" class="indexterm"/><a id="idx00162" class="indexterm"/><a id="idx00271" class="indexterm"/><a id="idx00287" class="indexterm"/><a id="idx00368" class="indexterm"/><a id="idx00372" class="indexterm"/><a id="idx00428" class="indexterm"/><a id="idx00451" class="indexterm"/><a id="idx00480" class="indexterm"/><a id="idx00570" class="indexterm"/>Just as I unpacked a string into a list of values with the <code class="literal">C*</code> template in the previous one-liner, I can pack them into a string by using the same template. Here’s the output from the one-liner:</p><a id="I_programlisting5_id309434"/><pre class="programlisting">coding</pre><p>Another way to convert a list of numeric ASCII values into a string is to use the <code class="literal">chr</code> operator, which takes the code point value and returns the corresponding character:</p><a id="I_programlisting5_id309446"/><pre class="programlisting">perl -le '
  @ascii = (99, 111, 100, 105, 110, 103);
  $str = join "", map chr, @ascii;
  print $str
'</pre><p>Here, you simply <code class="literal">map</code> the <code class="literal">chr</code> operator onto each numeric value in the <code class="literal">@ascii</code> array, which produces a list of characters that correspond to the numeric values. Next, you <code class="literal">join</code> the characters together and produce the <code class="literal">$str</code>, and then you print it out.</p><p>You can also golf this one-liner and come up with the following:</p><a id="I_programlisting5_id309477"/><pre class="programlisting">perl -le 'print map chr, 99, 111, 100, 105, 110, 103'</pre><p>You can also use the <code class="literal">@ARGV</code> array and pass the ASCII values as arguments to the one-liner:</p><a id="I_programlisting5_id309490"/><pre class="programlisting">perl -le 'print map chr, @ARGV' 99 111 100 105 110 103</pre></div><div class="sect1" title="5.10 Generate an array with odd numbers from 1 to 100"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_10_generate_an_array_with_odd_numbe">5.10 Generate an array with odd numbers from 1 to 100</h2></div></div></div><a id="I_programlisting5_id309503"/><pre class="programlisting">perl -le '@odd = grep {$_ % 2 == 1} 1..100; print "@odd"'</pre><p>This one-liner generates an array of odd numbers from 1 to 99 (that is, 1, 3, 5, 7, 9, 11, … , 99). It uses <code class="literal">grep</code> to evaluate the code <code class="literal">$_ % 2 == 1</code> for each element in the list <code class="literal">1..100</code> and returns only those elements for which the given code evaluates to true. In this case, the code tests to see if the remainder when dividing by 2 is 1. If it is, the number is odd, and it’s put in the <code class="literal">@odd</code> array.</p><p><a id="idx00087" class="indexterm"/><a id="idx00095" class="indexterm"/><a id="idx00196" class="indexterm"/><a id="idx00264" class="indexterm"/><a id="idx00286" class="indexterm"/><a id="idx00342" class="indexterm"/><a id="idx00344" class="indexterm"/><a id="idx00371" class="indexterm"/><a id="idx00374" class="indexterm"/><a id="idx00419" class="indexterm"/><a id="idx00427" class="indexterm"/><a id="idx00577" class="indexterm"/>You could also write this using the fact that odd numbers have the least significant bit set and test for the least significant bit:</p><a id="I_programlisting5_id309636"/><pre class="programlisting">perl -le '@odd = grep { $_ &amp; 1 } 1..100; print "@odd"'</pre><p>The expression <code class="literal">$_ &amp; 1</code> isolates the least significant bit, and <code class="literal">grep</code> selects only those numbers with the least significant bit set—that is, all odd numbers.</p></div><div class="sect1" title="5.11 Generate an array with even numbers from 1 to 100"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_11_generate_an_array_with_even_numb">5.11 Generate an array with even numbers from 1 to 100</h2></div></div></div><a id="I_programlisting5_id309661"/><pre class="programlisting">perl -le '@even = grep {$_ % 2 == 0} 1..100; print "@even"'</pre><p>This one-liner is almost the same as the one in 5.10, except that <code class="literal">grep</code> tests for the condition “is the number even (remainder after dividing by two is 0)?”</p></div><div class="sect1" title="5.12 Find the length of a string"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_12_find_the_length_of_a_string">5.12 Find the length of a string</h2></div></div></div><a id="I_programlisting5_id309684"/><pre class="programlisting">perl -le 'print length "one-liners are great"'</pre><p>The <code class="literal">length</code> subroutine finds the length of a string.</p></div><div class="sect1" title="5.13 Find the number of elements in an array"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="five_13_find_the_number_of_elements_in_a">5.13 Find the number of elements in an array</h2></div></div></div><a id="I_programlisting5_id309708"/><pre class="programlisting">perl -le '@array = ("a".."z"); print scalar @array'</pre><p>Evaluating an array in the scalar context returns its number of elements.</p><p>You could also do this by adding <code class="literal">1</code> to the last index of an array:</p><a id="I_programlisting5_id309724"/><pre class="programlisting">perl -le '@array = ("a".."z"); print $#array + 1'</pre><p>Here, <code class="literal">$#array</code> returns the last index in <code class="literal">@array</code>. Because that number is one less than the number of elements in the array, you add <code class="literal">1</code> to the result to find the total number of elements in the array.</p><p>For example, say you want to find out how many text files are in the current directory. You can use <code class="literal">@ARGV</code> and pass the <code class="literal">*.txt</code> wildcard to Perl. The shell expands the <code class="literal">*.txt</code> wildcard to a list of filenames that match <code class="literal">*.txt</code>, and Perl puts them into the <code class="literal">@ARGV</code> array and prints the array in the scalar context. The output will be the number of text files in the current directory:</p><a id="I_programlisting5_id309769"/><pre class="programlisting">perl -le 'print scalar @ARGV' *.txt</pre><p><a id="idx00010" class="indexterm"/><a id="idx00180" class="indexterm"/><a id="idx00237" class="indexterm"/><a id="idx00293" class="indexterm"/><a id="idx00439" class="indexterm"/>If your shell doesn’t support filename expansion (also known as <span class="emphasis"><em>globbing</em></span>) or if you’re on Windows, you can use the diamond operator with the <code class="literal">*.txt</code> argument:</p><a id="I_programlisting5_id309816"/><pre class="programlisting">perl -le 'print scalar (@ARGV=&lt;*.txt&gt;)'</pre><p>In this case, the diamond operator does the globbing and returns a list of filenames that match <code class="literal">*.txt</code>. Evaluating this list in the scalar context returns the number of files that matched.</p></div></section></body></html>