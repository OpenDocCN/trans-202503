- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PREPROCESSOR</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*with Aaron Ballman*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: The preprocessor is the part of the C compiler that runs at an early phase of
    compilation and transforms the source code before it’s translated, such as inserting
    code from one file (typically a header) into another (typically a source file).
    The preprocessor also allows you to specify that an identifier should be automatically
    substituted by a source code segment during macro expansion. In this chapter,
    you’ll learn how to use the preprocessor to include files, define object- and
    function-like macros, conditionally include code based on implementation-specific
    features, and embed binary resources into your program.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">The Compilation Process</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, the compilation process consists of a pipeline of eight phases,
    as shown in [Figure 9-1](chapter9.xhtml#fig9-1). We call these *translation phases*
    because each phase translates the code for processing by the next phase.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f09001.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Translation phases</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessor runs before the translator translates the source code into
    object code, which allows the preprocessor to modify the source code the user
    wrote *before* the translator operates on it. Consequently, the preprocessor has
    a limited amount of semantic information about the program being compiled. It
    doesn’t understand functions, variables, or types. Only basic elements, such as
    header names, identifiers, literals, and punctuation characters like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>
    are meaningful to the preprocessor. These basic elements, called *tokens*, are
    the smallest elements of a computer program that have meaning to a compiler.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessor operates on *preprocessing directives* that you include in
    the source code to program the behavior of the preprocessor. You spell preprocessing
    directives with a leading <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    token followed by a directive name, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>. Each preprocessing
    directive is terminated by a newline character. You can indent directives by including
    whitespace between the beginning of the line and the <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'or between the <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp> and the
    directive:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Preprocessing directives instruct the preprocessor to alter the resulting translation
    unit. If your program contains preprocessing directives, the code the translator
    consumes is not the same code you wrote. Compilers usually provide a way to view
    the preprocessor output, called a *translation unit*, passed to the translator.
    Viewing the preprocessor output is unnecessary, but you may find it informative
    to see the actual code given to the translator. [Table 9-1](chapter9.xhtml#tab9-1)
    lists flags that common compilers use to output a translation unit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-1:</samp> <samp class="SANS_Futura_Std_Book_11">Outputting
    a Translation Unit</samp>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Compiler</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example
    command line</samp> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Clang</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-E -o</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i
    tu.c</samp> |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GCC</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-E -o</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i
    tu.c</samp> |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Visual C++</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cl</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/P /Fi</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i
    tu.c</samp> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: 'Preprocessed output files are commonly given a *.i* file extension.  ## <samp
    class="SANS_Futura_Std_Bold_B_11">File Inclusion</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: A powerful feature of the preprocessor is the ability to insert the contents
    of one source file into the contents of another source file by using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> preprocessing directive.
    The included files are called *headers* to distinguish them from other source
    files. Headers typically contain declarations for use by other programs. This
    is the most common way to share external declarations of functions, objects, and
    data types with other parts of the program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen many examples of including the headers for C standard library
    functions in the examples in this book. For instance, the program in [Table 9-2](chapter9.xhtml#tab9-2)
    is separated into a header named *bar.h* and a source file named *foo.c*. The
    source file *foo.c* does not directly contain a declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>,
    yet the function is successfully referenced by name within <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    During preprocessing, the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directive inserts the contents of *bar.h* into *foo.c* in the place of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-2:</samp> <samp class="SANS_Futura_Std_Book_11">Header
    Inclusion</samp>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    func(void);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">return
    func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "bar.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: 'The preprocessor executes <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directives as it encounters them. Therefore, inclusion has transitive properties:
    if a source file includes a header that itself includes another header, the preprocessed
    output will contain the contents of both headers. For example, given the *baz.h*
    and *bar.h* headers and the *foo.c* source file, the output after running the
    preprocessor on the *foo.c* source code is shown in [Table 9-3](chapter9.xhtml#tab9-3).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-3:</samp> <samp class="SANS_Futura_Std_Book_11">Transitive
    Header Inclusion</samp>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">baz.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    other_func(void);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int other_func(void);</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    main(void) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">baz.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    other_func(void);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int other_func(void);</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    main(void) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "baz.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp>
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "baz.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "bar.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">   return func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "bar.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">   return func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
- en: Compiling the *foo.c* source file causes the preprocessor to include the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp> header. The preprocessor
    then finds the include directive for the <samp class="SANS_TheSansMonoCd_W5Regular_11">"baz.h"</samp>
    header and includes it as well, bringing the declaration for <samp class="SANS_TheSansMonoCd_W5Regular_11">other_func</samp>
    into the resulting translation unit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 *foo.c* 源文件时，预处理器会包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp>
    头文件。然后，预处理器会找到 <samp class="SANS_TheSansMonoCd_W5Regular_11">"baz.h"</samp> 头文件的包含指令，并将其也包含进来，从而把
    <samp class="SANS_TheSansMonoCd_W5Regular_11">other_func</samp> 的声明引入到生成的翻译单元中。
- en: A best practice is to avoid relying on transitive includes because they make
    your code brittle. Consider using tools like include-what-you-use (*[https://<wbr>include<wbr>-what<wbr>-you<wbr>-use<wbr>.org](https://include-what-you-use.org)*)
    to automatically remove reliance on transitive includes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是避免依赖传递式包含，因为它们会让你的代码变得脆弱。可以考虑使用像 include-what-you-use (*[https://<wbr>include<wbr>-what<wbr>-you<wbr>-use<wbr>.org](https://include-what-you-use.org)*)
    这样的工具来自动移除对传递式包含的依赖。
- en: 'Starting with C23, you can test for the presence of an include file before
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive is
    executed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    preprocessor operator. It takes a header name as the only operand. The operator
    returns true if the specified file can be found and false otherwise. You can use
    it with conditional inclusion to provide an alternative implementation if a file
    cannot be included. For example, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    preprocessor operator to test for C standard library threading or POSIX threads
    support as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C23 开始，你可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    指令执行之前，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp> 预处理器操作符来检测一个包含文件是否存在。它只接受一个头文件名作为操作数。如果指定的文件能够找到，操作符返回
    true，否则返回 false。你可以与条件包含一起使用它，以便在文件无法包含时提供替代的实现。例如，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    预处理器操作符来检测 C 标准库线程或 POSIX 线程支持，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can use either a quoted include string (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "foo.h"</samp>) or an angle-bracketed include string (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    <foo.h></samp>) to specify the file to include. The difference between these syntaxes
    is implementation defined, but they typically influence the search path used to
    find the included files. For example, both Clang and GCC attempt to find files
    included with:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用带引号的包含字符串（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">#include "foo.h"</samp>）或尖括号的包含字符串（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include <foo.h></samp>）来指定要包含的文件。这两种语法的区别由实现定义，但它们通常会影响用于查找包含文件的搜索路径。例如，Clang
    和 GCC 都会尝试找到使用以下语法包含的文件：
- en: Angle brackets on the *system include path*, specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-isystem</samp>
    flag
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoted strings on the *quoted include path*, specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-iquote</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-isystem</samp> flags
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to your compiler’s documentation for the specific differences between
    these two syntaxes. Normally, headers for standard or system libraries are found
    on the default system include path, and your own project headers are found on
    the quoted include path.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The header operand passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    preprocessor operator is specified with either quotes or angle brackets. The operator
    uses the same search path heuristics as the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directive. Consequently, you should use the same form for both the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directive and corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    operator to ensure a consistent result.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conditional Inclusion</samp>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frequently, you’ll need to write different code to support different implementations.
    For example, you may want to provide alternative implementations of a function
    for different target architectures. One solution to this problem is to maintain
    two files with slight variations between them and compile the appropriate file
    for a particular implementation. A better solution is to either translate or refrain
    from translating the target-specific code based on a preprocessor definition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: You can conditionally include source code using a preprocessing directive such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp> with a predicate
    condition. A *predicate condition* is the controlling constant expression that’s
    evaluated to determine which branch of the program the preprocessor should take.
    They’re typically used along with the preprocessor <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp>
    operator, which determines whether a given identifier is the name of a defined
    macro.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The conditional inclusion directives are similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statements. When
    the predicate condition is evaluated to a nonzero preprocessor value, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#if</samp> branch is processed, and all
    other branches are not. When the predicate condition evaluates to zero, the next
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp> branch, if any, has
    its predicate tested for inclusion. If none of the predicate conditions evaluate
    to nonzero, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp>
    branch, if there is one, is processed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#endif</samp>
    preprocessing directive indicates the end of the conditionally included code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> operator evaluates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the given identifier
    is defined as a macro or <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    otherwise. For example, the preprocessing directives shown in [Listing 9-1](chapter9.xhtml#Lis9-1)
    conditionally determine which header contents to include in the resulting translation
    unit. The preprocessed output depends on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">_WIN32</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">__ANDROID__</samp> is a defined
    macro. If neither is a defined macro, the preprocessor output will be empty.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: An example of
    conditional inclusion</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> keywords, preprocessor
    conditional inclusion cannot use braces to denote the block of statements controlled
    by the predicate. Instead, preprocessor conditional inclusion will include all
    the tokens from the <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp>
    directive (following the predicate) to the next balanced <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#endif</samp>
    token found, while skipping any tokens in a conditional inclusion branch not taken.
    Conditional inclusion directives can be nested. You can write
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'as shorthand for:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similarly, you can write
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'as shorthand for:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting in C23, you can write
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: as shorthand for
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: and you can write
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: as shorthand for
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'or, equivalently:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The parentheses around the identifier are optional.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Diagnostics</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A conditional inclusion directive may need to generate an error if the preprocessor
    can’t take any of the conditional branches because no reasonable fallback behavior
    exists. Consider the example in [Listing 9-2](chapter9.xhtml#Lis9-2), which uses
    conditional inclusion to select between including the C standard library header
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp> or the POSIX
    threading library header <samp class="SANS_TheSansMonoCd_W5Regular_11"><pthread.h></samp>.
    If neither option is available, you should alert the programmer porting the system
    that the code must be repaired.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预处理器无法执行任何条件分支，因为没有合理的回退行为，那么可能需要生成一个错误信息。考虑[示例 9-2](chapter9.xhtml#Lis9-2)中的例子，它使用条件包含来选择是否包含
    C 标准库头文件 <samp class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp> 或 POSIX
    线程库头文件 <samp class="SANS_TheSansMonoCd_W5Regular_11"><pthread.h></samp>。如果两者都不可用，应该提醒移植系统的程序员，代码必须修复。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Inducing a compilation
    error</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 9-2：引发编译错误</samp>
- en: Here, the code generates a diagnostic but doesn’t describe the actual problem.
    For this reason, C has the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    preprocessing directive, which causes the implementation to produce a compile-time
    diagnostic message. You can optionally follow this directive with one or more
    preprocessor tokens to include in the resulting diagnostic message. Using these,
    we can replace the erroneous array declaration from [Listing 9-2](chapter9.xhtml#Lis9-2)
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> directive
    such as the one shown in [Listing 9-3](chapter9.xhtml#Lis9-3).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，代码生成了诊断信息，但没有描述实际的问题。为此，C 提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    预处理指令，导致实现生成编译时的诊断消息。你可以选择在该指令后跟一个或多个预处理器标记，以包含在生成的诊断消息中。通过这些，我们可以将[示例 9-2](chapter9.xhtml#Lis9-2)中的错误数组声明替换为如[示例
    9-3](chapter9.xhtml#Lis9-3)所示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    指令。
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: An</samp> <samp
    class="I">#error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">directive</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 9-3：一个</samp> <samp class="I">#error</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">指令</samp>
- en: 'This code generates the following error message if neither threading library
    header is available:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有线程库头文件可用，以下代码将生成错误消息：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    directive, C23 added the <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp>
    directive. This directive is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    directive in that they both cause the implementation to generate a diagnostic.
    However, instead of terminating compilation, the diagnostic message is generated,
    and compilation continues as normal (unless other command line options disable
    the warnings or upgrade them into errors). The <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    directive should be used for *fatal* problems such as a missing library with no
    fallback implementation, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp>
    directive should be used for *nonfatal* problems such as a missing library with
    a low-quality fallback implementation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> 指令，C23 还增加了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp> 指令。这个指令和 <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    指令类似，它们都会导致实现生成诊断信息。然而，不同的是，生成诊断消息后，编译继续进行（除非其他命令行选项禁用警告或将其升级为错误）。<samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    指令应当用于*致命*问题，例如没有回退实现的缺失库，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp>
    指令应当用于*非致命*问题，例如缺失库但有低质量回退实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Header Guards</samp>
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用头文件保护</samp>
- en: One problem you’ll encounter when writing headers is preventing programmers
    from including the same file twice in a translation unit. Given that you can transitively
    include headers, you could easily include the same header multiple times by accident
    (possibly even leading to infinite recursion between headers).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 编写头文件时，你会遇到的一个问题是防止程序员在一个翻译单元中多次包含同一文件。由于可以传递性地包含头文件，你可能会不小心多次包含同一头文件（甚至可能导致头文件之间的无限递归）。
- en: '*Header guards* ensure that a header is included only once per translation
    unit. A header guard is a design pattern that conditionally includes the contents
    of a header based on whether a header-specific macro is defined. If the macro
    is not already defined, you define it so that a subsequent test of the header
    guard won’t conditionally include the code. In the program shown in [Table 9-4](chapter9.xhtml#tab9-4),
    *bar.h* uses a header guard (shown in bold) to prevent its (accidental) duplicate
    inclusion from *foo.c*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-4:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Header Guard</samp>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#ifndef
    BAR_H</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#define BAR_H</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">inline</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    func() { return 1; }</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#endif
    /* BAR_H */</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">inline</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int func() { return 1; }</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    inline int func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main()
    {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "bar.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "bar.h" //
    repeated inclusion is</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">                 //
    usually not this obvious</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    inline int func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main()
    {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: The first time that <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp>
    is included, the <samp class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</samp>
    test to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp> is
    not defined will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
    We then define the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp>
    with an empty replacement list, which is sufficient to define <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp>,
    and the function definition for <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>
    is included. The second time that <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp>
    is included, the preprocessor won’t generate any tokens because the conditional
    inclusion test will return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
    Consequently, <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp> is defined
    only once in the resulting translation unit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: A common practice when picking the identifier to use as a header guard is to
    use the salient parts of the file path, filename, and extension, separated by
    an underscore and written in all capital letters. For example, if you had a header
    that would be included with <samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "foo/bar/baz.h"</samp>, you might choose <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO_BAR_BAZ_H</samp>
    as the header guard identifier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Some IDEs will automatically generate the header guard for you. Avoid using
    a reserved identifier as your header guard’s identifier, which could introduce
    undefined behavior. Identifiers that begin with an underscore followed by a capital
    letter are reserved. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">_FOO_H</samp>
    is a reserved identifier and a bad choice for a user-chosen header guard identifier,
    even if you’re including a file named *_foo.h*. Using a reserved identifier can
    result in a collision with a macro defined by the implementation, leading to a
    compilation error or incorrect code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Macro Definitions</samp>
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> preprocessing
    directive defines a macro. You can use *macros* to define constant values or function-like
    constructs with generic parameters. The macro definition contains a (possibly
    empty) *replacement list*—a code pattern that’s injected into the translation
    unit when the preprocessor expands the macro:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> preprocessing
    directive is terminated with a newline. In the following example, the replacement
    list for <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp> identifier
    is replaced by <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>. If no
    replacement list is specified, the preprocessor simply removes the macro name.
    You can typically specify a macro definition on your compiler’s command line—for
    example, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-D</samp> flag
    in Clang and GCC or the <samp class="SANS_TheSansMonoCd_W5Regular_11">/D</samp>
    flag in Visual C++. For Clang and GCC, the command line option <samp class="SANS_TheSansMonoCd_W5Regular_11">-DARRAY_SIZE=100</samp>
    specifies that the macro identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp>
    is replaced by <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, producing
    the same result as the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>
    preprocessing directive from the previous example. If you don’t specify the macro
    replacement list on the command line, compilers will typically provide a replacement
    list. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">-DFOO</samp>
    is typically identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">#define
    FOO 1</samp>.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a macro lasts until the preprocessor encounters either an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#undef</samp> preprocessing directive
    specifying that macro or the end of the translation unit. Unlike variable or function
    declarations, a macro’s scope is independent of any block structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>
    directive to define either an object-like macro or a function-like macro. A *function-like*
    macro is parameterized and requires passing a (possibly empty) set of arguments
    when you invoke it, similar to how you would invoke a function. Unlike functions,
    macros let you perform operations using the program’s symbols, which means you
    can create a new variable name or reference the source file and line number at
    which the macro is being invoked. An *object-like* macro is a simple identifier
    that will be replaced by a code fragment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-5](chapter9.xhtml#tab9-5) illustrates the difference between function-like
    and object-like macros. <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO</samp>
    is an object-like macro that is replaced by the tokens <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)</samp>
    during macro expansion, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR</samp>
    is a function-like macro that is replaced by the tokens <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(x))</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is whatever parameter
    is specified when invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR</samp>.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-5:</samp> <samp class="SANS_Futura_Std_Book_11">Macro
    Definition</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define FOO (1</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">)</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define
    BAR(x) (1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(x))</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO;</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int j</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR(10);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    k</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR(2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2);</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    j</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(10));</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int k</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2));</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: 'The opening parenthesis of a function-like macro definition must immediately
    follow the macro name, with no intervening whitespace. If a space appears between
    the macro name and the opening parenthesis, the parenthesis simply becomes part
    of the replacement list, as is the case with the object-like <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO</samp>
    macro. The macro replacement list terminates with the first newline character
    in the macro definition. However, you can join multiple source lines with the
    backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) character followed
    by a newline to make your macro definitions easier to understand. For example,
    consider the following definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">cbrt</samp>
    type-generic macro that computes the cube root of its floating-point argument:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That definition is equivalent to, but easier to read, than the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One danger when defining a macro is you can no longer use the macro’s identifier
    in the rest of the program without inducing a macro replacement. For example,
    because of macro expansion, the following invalid program won’t compile:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is because the tokens the preprocessor receives from the translator result
    in the following invalid code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can solve this problem by consistently adhering to an idiom throughout your
    program, such as defining macro names with all uppercase letters or prefixing
    all macro names with a mnemonic, as you might find in some styles of Hungarian
    notation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hungarian notation *is an identifier-naming convention in which the name of
    a variable or function indicates its intention or kind and, in some dialects,
    its type.*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve defined a macro, the only way to redefine it is to invoke the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#undef</samp> directive for the macro.
    Once you’ve undefined it, the named identifier no longer represents a macro. For
    example, the program shown in [Table 9-6](chapter9.xhtml#tab9-6) defines a function-like
    macro, includes a header that uses the macro, and then undefines the macro so
    that it can be redefined later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-6:</samp> <samp class="SANS_Futura_Std_Book_11">Undefining
    Macros</samp>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">header.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NAME(first)</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NAME(second)</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NAME(third)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">enum Names {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  first,</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  second,</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  third,</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">};</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">void
    func(enum Names Name) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  switch
    (Name){</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">    case first:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">    case second:</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">    case
    third:</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  }</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">file.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">enum
    Names {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define NAME(X) X,</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include "header.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#undef
    NAME</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">void
    func(enum Names Name) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  switch
    (Name) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define NAME(X) case
    X:</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "header.h"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">#undef NAME</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  }</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: The first use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp>
    macro declares the names of enumerators within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Names</samp>
    enumeration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> macro
    is undefined and then redefined to generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    labels in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Undefining a macro is safe even when the named identifier isn’t the name of
    a macro. This macro definition works regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp>
    is already defined. To keep examples short, we don’t normally follow this practice
    in this book.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Macro Replacement</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function-like macros look like functions but behave differently. When the preprocessor
    encounters a macro identifier, it invokes the macro, which expands the identifier
    to replace it with the tokens from the replacement list, if any, specified in
    the macro’s definition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: For function-like macros, the preprocessor replaces all parameters in the replacement
    list with the corresponding arguments in the macro invocation after expanding
    them. Any parameter in the replacement list preceded by a <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    token is replaced with a string literal preprocessing token that contains the
    text of the argument preprocessing tokens (a process sometimes called *stringizing*).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">STRINGIZE</samp> macro in [Table
    9-7](chapter9.xhtml#tab9-7) stringizes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-7:</samp> <samp class="SANS_Futura_Std_Book_11">Stringizing</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define STRINGIZE(x) #x</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">const char *str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STRINGIZE(12);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    char *str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"12";</samp> |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: The preprocessor also deletes all instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">##</samp>
    preprocessing token in the replacement list, concatenating the preceding preprocessing
    token with the following token, which is called *token pasting*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">PASTE</samp>
    macro in [Table 9-8](chapter9.xhtml#tab9-8) is used to create a new identifier
    by concatenating <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, the
    underscore character (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>),
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-8:</samp> <samp class="SANS_Futura_Std_Book_11">Token
    Pasting</samp>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define PASTE(x, y) x ## _
    ## y</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int PASTE(foo, bar)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12;</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int foo_bar</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12;</samp> |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: After expanding the macro, the preprocessor rescans the replacement list to
    expand additional macros within it. If the preprocessor finds the name of the
    macro being expanded while rescanning—including the rescanning of nested macro
    expansions within the replacement list—it won’t expand the name again. Furthermore,
    if macro expansion results in a fragment of program text that’s identical to a
    preprocessing directive, that fragment won’t be treated as a preprocessing directive.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: During macro expansion, a repeated parameter name in the replacement list will
    be replaced multiple times by the argument given in the invocation. This can have
    surprising effects if the argument to the macro invocation involves side effects,
    as shown in [Table 9-9](chapter9.xhtml#tab9-9). This problem is explained in detail
    in CERT C rule PRE31-C, “Avoid side effects in arguments to unsafe macros.”
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-9:</samp> <samp class="SANS_Futura_Std_Book_11">Unsafe
    Macro Expansion</samp>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define bad_abs(x) (x >=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? x : -x)</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    func(int i) {</samp><samp class="SANS_Futura_Std_Book_11">  </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  return bad_abs(i++);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int func(int i) {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  return (i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:
    -i++);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: 'In the macro definition in [Table 9-9](chapter9.xhtml#tab9-9), each instance
    of the macro parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is replaced by the macro invocation argument <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp>,
    causing <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to be incremented
    twice in a way that a programmer or reviewer reading the original source code
    can easily overlook. Parameters like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the replacement list, as well as the replacement list itself, should usually
    be fully parenthesized as in <samp class="SANS_TheSansMonoCd_W5Regular_11">((x)
    >=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? (x) : -(x))</samp>
    to prevent portions of the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    from associating with other elements of the replacement list in unexpected ways.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU *statement expressions* allow you to use loops, switches, and local variables
    within an expression. Statement expressions are a nonstandard compiler extension
    supported by GCC, Clang, and other compilers. Using statement expressions, you
    can rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_abs(x)</samp>
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can safely invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">abs(x)</samp>
    macro with side-effecting operands.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Another potential surprise is that a comma in a function-like macro invocation
    is always interpreted as a macro argument delimiter. The C standard <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp>
    macro (removed in C23) demonstrates the danger ([Table 9-10](chapter9.xhtml#tab9-10)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-10:</samp> <samp class="SANS_Futura_Std_Book_11">The</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp> <samp class="SANS_Futura_Std_Book_11">Macro</samp>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">stdatomic.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define
    ATOMIC_VAR_INIT(value) (value)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><error></samp>
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    <stdatomic.h></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">struct S {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  int x, y;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Atomic struct S val</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT({1, 2});</samp>
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: This code fails to translate because the comma in <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT({1,
    2})</samp> is treated as a function-like macro argument delimiter, causing the
    preprocessor to interpret the macro as having two syntactically invalid arguments
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2}</samp>
    instead of a single valid argument <samp class="SANS_TheSansMonoCd_W5Regular_11">{1,
    2}</samp>. This usability issue is one of the reasons the <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp>
    macro was deprecated in C17 and removed in C23.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type-Generic Macros</samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C programming language doesn’t allow you to overload functions based on
    the types of the parameters passed to the function, as you can in other languages
    such as Java and C++. However, you might sometimes need to alter the behavior
    of an algorithm based on the argument types. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>
    has three <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp> functions (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>) because each of
    the three floating-point types (<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>, respectively) has a different precision. Using generic selection
    expressions, you can define a single function-like identifier that delegates to
    the correct underlying implementation based on the argument type when called.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A *generic selection expression* maps the type of its unevaluated operand expression
    to an associated expression. If none of the associated types match, it can optionally
    map to a default expression. You can use *type-generic macros* (macros that include
    generic selection expressions) to make your code more readable. In [Table 9-11](chapter9.xhtml#tab9-11),
    we define a type-generic macro to select the correct variant of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>
    function from <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-11:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Generic Selection Expression as a Macro</samp>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">_Generic</samp> <samp class="SANS_Futura_Std_Heavy_B_11">resolution</samp>
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The controlling expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(X)</samp>
    of the generic selection expression is unevaluated; the type of the expression
    selects a function from the list of <samp class="SANS_TheSansMonoCd_W5Regular_11">type
    : expr</samp> mappings. The generic selection expression picks one of these function
    designators (either <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>)
    and then executes it. In this example, the argument type in the first call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    so the generic selection resolves to <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>,
    and the argument type in the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, so this resolves
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>. Because this generic
    selection expression has no <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    association, an error occurs if the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">(X)</samp>
    doesn’t match any of the associated types. If you include a default association
    for a generic selection expression, it will match every type not already used
    as an association, including types you might not expect, such as pointers or structure
    types.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Type-generic macro expansion can be difficult to use when the resulting value
    type depends on the type of an argument to the macro, as with the <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp>
    example in [Table 9-11](chapter9.xhtml#tab9-11). For instance, it can be a mistake
    to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> macro
    and assign the result to an object of a specific type or pass its result as an
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> because
    the necessary object type or format specifier will depend on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>
    is called. You can find examples of type-generic macros for math functions in
    the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11"><tgmath.h></samp>
    header.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: C23 partially addressed this problem with the introduction of automatic type
    inference using the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier, described in [Chapter 2](chapter2.xhtml). Consider using automatic
    type inference when initializing an object with a type-generic macro to avoid
    unintentional conversions on initialization. For example, the following file scope
    definitions
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'are interpreted as if they had been written as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Effectively, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is a float
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is a float <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 9-12](chapter9.xhtml#tab9-12), we replace the types of the two variables
    declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> from [Table
    9-11](chapter9.xhtml#tab9-11) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier. This makes it easier to invoke a type-generic macro, although
    it is not strictly necessary as the programmer can also deduce the types. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> type specifier is useful
    when invoking a type-generic function-like macro where the type of the resulting
    value depends on a macro parameter to avoid accidental type conversion on initialization.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-12:</samp> <samp class="SANS_Futura_Std_Book_11">Type-Generic
    Macros with Automatic Type Inference</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">_Generic</samp> <samp class="SANS_Futura_Std_Heavy_B_11">resolution</samp>
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier for declaring variables in type-generic macros where you don’t
    know the type of the arguments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Embedded Binary Resources</samp>
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find that you need to dynamically load digital resources, such as images,
    sounds, video, text files, or other binary data, at runtime. It may instead be
    beneficial to load those resources at compile time so they can be stored as part
    of the executable rather than dynamically loaded.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C23, there were two common approaches to embedding binary resources
    into your program. For limited amounts of binary data, the data could be specified
    as an initializer for a constant-size array. However, for larger binary resources,
    this approach could introduce significant compile-time overhead, so the use of
    a linker script or other postprocessing was necessary to keep compile times reasonable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: C23 added the <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> preprocessor
    directive to embed a digital resource directly into source code as if it were
    a comma-delimited list of integer constants. The new directive allows an implementation
    to optimize for better compile time efficiency when using the embedded constant
    data as an array initializer. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp>,
    the implementation does not need to parse each integer constant and comma token
    separately; it can inspect the bytes directly and use a more efficient mapping
    of the resource.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-13](chapter9.xhtml#tab9-13) shows an example of embedding the binary
    resource *file.txt* as the initializer for the <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>
    array declaration. For this example, *file.txt* contains the ASCII text <samp
    class="SANS_TheSansMonoCd_W5Regular_11">meow</samp> to keep the code listing short.
    Significantly larger binary resources are typically embedded.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-13:</samp> <samp class="SANS_Futura_Std_Book_11">Embedding
    Binary Resources</samp>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char buffer[]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">#embed <file.txt></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char buffer[]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">109, 101, 111, 119</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp>
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: Like <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>, the filename
    specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive
    can be listed within either angle brackets or double quotes. Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>,
    there is no notion of *system* or *user* embedded resources, so the only difference
    between the two forms is that the double-quoted form will start searching for
    the resource from the same directory as the source file before trying other search
    paths. Compilers have a command line option to specify search paths for embedded
    resources; see your compiler documentation for more details.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive supports
    several parameters to control what data is embedded into the source file: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">limit</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">suffix</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">if_empty</samp>.
    The most useful of those parameters is the <samp class="SANS_TheSansMonoCd_W5Regular_11">limit</samp>
    parameter, which specifies how much data to embed (in bytes). This can be helpful
    if the only data needed at compile time is in the header of the file or if the
    file is an *infinite* resource like */dev/urandom* in some operating systems.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">suffix</samp>
    parameters insert tokens before or after the embedded resource, respectively,
    if the resource is found and is not empty. The <samp class="SANS_TheSansMonoCd_W5Regular_11">if_empty</samp>
    parameter inserts tokens if the embedded resource is found but has no content
    (including when the <samp class="SANS_TheSansMonoCd_W5Regular_11">limit</samp>
    parameter is explicitly set to 0).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Like <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>, you
    can test whether an embedded resource can be found using the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_embed</samp>
    preprocessor operator. This operator returns:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_FOUND__</samp> if
    the resource can be found and isn’t empty
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_EMPTY__</samp> if
    the resource can be found and is empty
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_NOT_FOUND__</samp>
    if the resource cannot be found
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Predefined Macros</samp>
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation defines some macros without requiring you to include a header.
    These macros are called *predefined macros* because they’re implicitly defined
    by the preprocessor rather than explicitly defined by the programmer. For example,
    the C standard defines various macros that you can use to interrogate the compilation
    environment or provide basic functionality. Some other aspects of the implementation
    (such as the compiler or the compilation target operating system) also automatically
    define macros. [Table 9-14](chapter9.xhtml#tab9-14) lists some of the common macros
    the C standard defines. You can obtain a full list of predefined macros from Clang
    or GCC by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">-E -dM</samp>
    flags to those compilers. Check your compiler documentation for more information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-14:</samp> <samp class="SANS_Futura_Std_Book_11">Predefined
    Macros</samp>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Macro name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Replacement
    and purpose</samp> |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__DATE__</samp> | <samp class="SANS_Futura_Std_Book_11">A
    string literal of the date of translation of the preprocessing translation unit
    in the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Mmm
    dd yyyy</samp><samp class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__TIME__</samp> | <samp class="SANS_Futura_Std_Book_11">A
    string literal of the time of translation for the preprocessing translation unit
    in the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">hh:mm:ss</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__FILE__</samp> | <samp class="SANS_Futura_Std_Book_11">A
    string literal representing the presumed filename of the current source file.</samp>
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__LINE__</samp> | <samp class="SANS_Futura_Std_Book_11">An
    integer constant representing the presumed line number of the current source line.</samp>
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC__</samp> | <samp class="SANS_Futura_Std_Book_11">The
    integer constant 1 if the implementation conforms to the C standard.</samp> |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_HOSTED__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation is
    a hosted implementation or the integer constant 0 if it is stand-alone. This macro
    is conditionally defined by the implementation.</samp> |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_VERSION__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant representing the version
    of the C standard the compiler is targeting, such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">202311L</samp>
    <samp class="SANS_Futura_Std_Book_11">for the C23 standard.</samp> |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if values of type</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> <samp class="SANS_Futura_Std_Book_11">are
    UTF-16</samp> <samp class="SANS_Futura_Std_Book_11">encoded. This macro is conditionally
    defined by the</samp> <samp class="SANS_Futura_Std_Book_11">implementation.</samp>
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if values of type</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> <samp class="SANS_Futura_Std_Book_11">are
    UTF-32</samp> <samp class="SANS_Futura_Std_Book_11">encoded. This macro is conditionally
    defined by the</samp> <samp class="SANS_Futura_Std_Book_11">implementation.</samp>
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_ATOMICS__</samp>
    | <samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation
    doesn’t support atomic types, including the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp>
    <samp class="SANS_Futura_Std_Book_11">type qualifier, and the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdatomic.h></samp>
    <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined
    by the implementation.</samp> |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_COMPLEX__</samp>
    | <samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation
    doesn’t support complex types or the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><complex.h></samp>
    <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined
    by the implementation.</samp> |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_THREADS__</samp>
    | <samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation
    doesn’t support the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp>
    <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined
    by the implementation.</samp> |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_VLA__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation doesn’t
    support variable-length arrays. This macro is conditionally defined by the implementation.</samp>
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about some of the features provided by the preprocessor.
    You learned how to include fragments of program text in a translation unit, conditionally
    compile code, embed binary resources into your program, and generate diagnostics
    on demand. You then learned how to define and undefine macros, how macros are
    invoked, and about macros that are predefined by the implementation. The preprocessor
    is popular in C language programming but shunned in C++ programming. Use of the
    preprocessor can be error prone, so it is best to follow the recommendations and
    rules from *The CERT C Coding Standard*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to structure your program into more than
    one translation unit to create more maintainable programs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
