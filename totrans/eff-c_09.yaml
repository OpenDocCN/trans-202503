- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PREPROCESSOR</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '*with Aaron Ballman*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preprocessor is the part of the C compiler that runs at an early phase of
    compilation and transforms the source code before it’s translated, such as inserting
    code from one file (typically a header) into another (typically a source file).
    The preprocessor also allows you to specify that an identifier should be automatically
    substituted by a source code segment during macro expansion. In this chapter,
    you’ll learn how to use the preprocessor to include files, define object- and
    function-like macros, conditionally include code based on implementation-specific
    features, and embed binary resources into your program.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">The Compilation Process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, the compilation process consists of a pipeline of eight phases,
    as shown in [Figure 9-1](chapter9.xhtml#fig9-1). We call these *translation phases*
    because each phase translates the code for processing by the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f09001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Translation phases</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessor runs before the translator translates the source code into
    object code, which allows the preprocessor to modify the source code the user
    wrote *before* the translator operates on it. Consequently, the preprocessor has
    a limited amount of semantic information about the program being compiled. It
    doesn’t understand functions, variables, or types. Only basic elements, such as
    header names, identifiers, literals, and punctuation characters like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>
    are meaningful to the preprocessor. These basic elements, called *tokens*, are
    the smallest elements of a computer program that have meaning to a compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The preprocessor operates on *preprocessing directives* that you include in
    the source code to program the behavior of the preprocessor. You spell preprocessing
    directives with a leading <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    token followed by a directive name, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>. Each preprocessing
    directive is terminated by a newline character. You can indent directives by including
    whitespace between the beginning of the line and the <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'or between the <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp> and the
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Preprocessing directives instruct the preprocessor to alter the resulting translation
    unit. If your program contains preprocessing directives, the code the translator
    consumes is not the same code you wrote. Compilers usually provide a way to view
    the preprocessor output, called a *translation unit*, passed to the translator.
    Viewing the preprocessor output is unnecessary, but you may find it informative
    to see the actual code given to the translator. [Table 9-1](chapter9.xhtml#tab9-1)
    lists flags that common compilers use to output a translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-1:</samp> <samp class="SANS_Futura_Std_Book_11">Outputting
    a Translation Unit</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Compiler</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Example
    command line</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Clang</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">clang</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-E -o</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i
    tu.c</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">GCC</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-E -o</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i
    tu.c</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Visual C++</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">cl</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">other-options</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/P /Fi</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tu.i
    tu.c</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Preprocessed output files are commonly given a *.i* file extension.  ## <samp
    class="SANS_Futura_Std_Bold_B_11">File Inclusion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A powerful feature of the preprocessor is the ability to insert the contents
    of one source file into the contents of another source file by using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> preprocessing directive.
    The included files are called *headers* to distinguish them from other source
    files. Headers typically contain declarations for use by other programs. This
    is the most common way to share external declarations of functions, objects, and
    data types with other parts of the program.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen many examples of including the headers for C standard library
    functions in the examples in this book. For instance, the program in [Table 9-2](chapter9.xhtml#tab9-2)
    is separated into a header named *bar.h* and a source file named *foo.c*. The
    source file *foo.c* does not directly contain a declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>,
    yet the function is successfully referenced by name within <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    During preprocessing, the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directive inserts the contents of *bar.h* into *foo.c* in the place of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive itself.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-2:</samp> <samp class="SANS_Futura_Std_Book_11">Header
    Inclusion</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    func(void);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">return
    func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "bar.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'The preprocessor executes <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directives as it encounters them. Therefore, inclusion has transitive properties:
    if a source file includes a header that itself includes another header, the preprocessed
    output will contain the contents of both headers. For example, given the *baz.h*
    and *bar.h* headers and the *foo.c* source file, the output after running the
    preprocessor on the *foo.c* source code is shown in [Table 9-3](chapter9.xhtml#tab9-3).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-3:</samp> <samp class="SANS_Futura_Std_Book_11">Transitive
    Header Inclusion</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">baz.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    other_func(void);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int other_func(void);</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    main(void) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "baz.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int func(void);</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "bar.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">   return func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Compiling the *foo.c* source file causes the preprocessor to include the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp> header. The preprocessor
    then finds the include directive for the <samp class="SANS_TheSansMonoCd_W5Regular_11">"baz.h"</samp>
    header and includes it as well, bringing the declaration for <samp class="SANS_TheSansMonoCd_W5Regular_11">other_func</samp>
    into the resulting translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: A best practice is to avoid relying on transitive includes because they make
    your code brittle. Consider using tools like include-what-you-use (*[https://<wbr>include<wbr>-what<wbr>-you<wbr>-use<wbr>.org](https://include-what-you-use.org)*)
    to automatically remove reliance on transitive includes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with C23, you can test for the presence of an include file before
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directive is
    executed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    preprocessor operator. It takes a header name as the only operand. The operator
    returns true if the specified file can be found and false otherwise. You can use
    it with conditional inclusion to provide an alternative implementation if a file
    cannot be included. For example, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    preprocessor operator to test for C standard library threading or POSIX threads
    support as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use either a quoted include string (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "foo.h"</samp>) or an angle-bracketed include string (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    <foo.h></samp>) to specify the file to include. The difference between these syntaxes
    is implementation defined, but they typically influence the search path used to
    find the included files. For example, both Clang and GCC attempt to find files
    included with:'
  prefs: []
  type: TYPE_NORMAL
- en: Angle brackets on the *system include path*, specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-isystem</samp>
    flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoted strings on the *quoted include path*, specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-iquote</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-isystem</samp> flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to your compiler’s documentation for the specific differences between
    these two syntaxes. Normally, headers for standard or system libraries are found
    on the default system include path, and your own project headers are found on
    the quoted include path.
  prefs: []
  type: TYPE_NORMAL
- en: The header operand passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    preprocessor operator is specified with either quotes or angle brackets. The operator
    uses the same search path heuristics as the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directive. Consequently, you should use the same form for both the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    directive and corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>
    operator to ensure a consistent result.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conditional Inclusion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frequently, you’ll need to write different code to support different implementations.
    For example, you may want to provide alternative implementations of a function
    for different target architectures. One solution to this problem is to maintain
    two files with slight variations between them and compile the appropriate file
    for a particular implementation. A better solution is to either translate or refrain
    from translating the target-specific code based on a preprocessor definition.
  prefs: []
  type: TYPE_NORMAL
- en: You can conditionally include source code using a preprocessing directive such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp> with a predicate
    condition. A *predicate condition* is the controlling constant expression that’s
    evaluated to determine which branch of the program the preprocessor should take.
    They’re typically used along with the preprocessor <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp>
    operator, which determines whether a given identifier is the name of a defined
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: The conditional inclusion directives are similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statements. When
    the predicate condition is evaluated to a nonzero preprocessor value, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#if</samp> branch is processed, and all
    other branches are not. When the predicate condition evaluates to zero, the next
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp> branch, if any, has
    its predicate tested for inclusion. If none of the predicate conditions evaluate
    to nonzero, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp>
    branch, if there is one, is processed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#endif</samp>
    preprocessing directive indicates the end of the conditionally included code.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> operator evaluates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> if the given identifier
    is defined as a macro or <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    otherwise. For example, the preprocessing directives shown in [Listing 9-1](chapter9.xhtml#Lis9-1)
    conditionally determine which header contents to include in the resulting translation
    unit. The preprocessed output depends on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">_WIN32</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">__ANDROID__</samp> is a defined
    macro. If neither is a defined macro, the preprocessor output will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: An example of
    conditional inclusion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> keywords, preprocessor
    conditional inclusion cannot use braces to denote the block of statements controlled
    by the predicate. Instead, preprocessor conditional inclusion will include all
    the tokens from the <samp class="SANS_TheSansMonoCd_W5Regular_11">#if</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp>
    directive (following the predicate) to the next balanced <samp class="SANS_TheSansMonoCd_W5Regular_11">#elif</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">#else</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">#endif</samp>
    token found, while skipping any tokens in a conditional inclusion branch not taken.
    Conditional inclusion directives can be nested. You can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'as shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'as shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Starting in C23, you can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: as shorthand for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: and you can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: as shorthand for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'or, equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses around the identifier are optional.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Diagnostics</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A conditional inclusion directive may need to generate an error if the preprocessor
    can’t take any of the conditional branches because no reasonable fallback behavior
    exists. Consider the example in [Listing 9-2](chapter9.xhtml#Lis9-2), which uses
    conditional inclusion to select between including the C standard library header
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp> or the POSIX
    threading library header <samp class="SANS_TheSansMonoCd_W5Regular_11"><pthread.h></samp>.
    If neither option is available, you should alert the programmer porting the system
    that the code must be repaired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: Inducing a compilation
    error</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the code generates a diagnostic but doesn’t describe the actual problem.
    For this reason, C has the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    preprocessing directive, which causes the implementation to produce a compile-time
    diagnostic message. You can optionally follow this directive with one or more
    preprocessor tokens to include in the resulting diagnostic message. Using these,
    we can replace the erroneous array declaration from [Listing 9-2](chapter9.xhtml#Lis9-2)
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> directive
    such as the one shown in [Listing 9-3](chapter9.xhtml#Lis9-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: An</samp> <samp
    class="I">#error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">directive</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code generates the following error message if neither threading library
    header is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    directive, C23 added the <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp>
    directive. This directive is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    directive in that they both cause the implementation to generate a diagnostic.
    However, instead of terminating compilation, the diagnostic message is generated,
    and compilation continues as normal (unless other command line options disable
    the warnings or upgrade them into errors). The <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp>
    directive should be used for *fatal* problems such as a missing library with no
    fallback implementation, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp>
    directive should be used for *nonfatal* problems such as a missing library with
    a low-quality fallback implementation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Header Guards</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem you’ll encounter when writing headers is preventing programmers
    from including the same file twice in a translation unit. Given that you can transitively
    include headers, you could easily include the same header multiple times by accident
    (possibly even leading to infinite recursion between headers).
  prefs: []
  type: TYPE_NORMAL
- en: '*Header guards* ensure that a header is included only once per translation
    unit. A header guard is a design pattern that conditionally includes the contents
    of a header based on whether a header-specific macro is defined. If the macro
    is not already defined, you define it so that a subsequent test of the header
    guard won’t conditionally include the code. In the program shown in [Table 9-4](chapter9.xhtml#tab9-4),
    *bar.h* uses a header guard (shown in bold) to prevent its (accidental) duplicate
    inclusion from *foo.c*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-4:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Header Guard</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">bar.h</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#ifndef
    BAR_H</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#define BAR_H</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">inline</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    func() { return 1; }</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">#endif
    /* BAR_H */</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">inline</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int func() { return 1; }</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    inline int func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main()
    {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "bar.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "bar.h" //
    repeated inclusion is</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">                 //
    usually not this obvious</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    inline int func();</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int main()
    {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  return func();</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  prefs: []
  type: TYPE_TB
- en: The first time that <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp>
    is included, the <samp class="SANS_TheSansMonoCd_W5Regular_11">#ifndef</samp>
    test to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp> is
    not defined will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
    We then define the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp>
    with an empty replacement list, which is sufficient to define <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR_H</samp>,
    and the function definition for <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>
    is included. The second time that <samp class="SANS_TheSansMonoCd_W5Regular_11">"bar.h"</samp>
    is included, the preprocessor won’t generate any tokens because the conditional
    inclusion test will return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
    Consequently, <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp> is defined
    only once in the resulting translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: A common practice when picking the identifier to use as a header guard is to
    use the salient parts of the file path, filename, and extension, separated by
    an underscore and written in all capital letters. For example, if you had a header
    that would be included with <samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    "foo/bar/baz.h"</samp>, you might choose <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO_BAR_BAZ_H</samp>
    as the header guard identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Some IDEs will automatically generate the header guard for you. Avoid using
    a reserved identifier as your header guard’s identifier, which could introduce
    undefined behavior. Identifiers that begin with an underscore followed by a capital
    letter are reserved. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">_FOO_H</samp>
    is a reserved identifier and a bad choice for a user-chosen header guard identifier,
    even if you’re including a file named *_foo.h*. Using a reserved identifier can
    result in a collision with a macro defined by the implementation, leading to a
    compilation error or incorrect code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Macro Definitions</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> preprocessing
    directive defines a macro. You can use *macros* to define constant values or function-like
    constructs with generic parameters. The macro definition contains a (possibly
    empty) *replacement list*—a code pattern that’s injected into the translation
    unit when the preprocessor expands the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> preprocessing
    directive is terminated with a newline. In the following example, the replacement
    list for <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp> identifier
    is replaced by <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>. If no
    replacement list is specified, the preprocessor simply removes the macro name.
    You can typically specify a macro definition on your compiler’s command line—for
    example, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-D</samp> flag
    in Clang and GCC or the <samp class="SANS_TheSansMonoCd_W5Regular_11">/D</samp>
    flag in Visual C++. For Clang and GCC, the command line option <samp class="SANS_TheSansMonoCd_W5Regular_11">-DARRAY_SIZE=100</samp>
    specifies that the macro identifier <samp class="SANS_TheSansMonoCd_W5Regular_11">ARRAY_SIZE</samp>
    is replaced by <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, producing
    the same result as the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>
    preprocessing directive from the previous example. If you don’t specify the macro
    replacement list on the command line, compilers will typically provide a replacement
    list. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">-DFOO</samp>
    is typically identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">#define
    FOO 1</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The scope of a macro lasts until the preprocessor encounters either an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#undef</samp> preprocessing directive
    specifying that macro or the end of the translation unit. Unlike variable or function
    declarations, a macro’s scope is independent of any block structure.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp>
    directive to define either an object-like macro or a function-like macro. A *function-like*
    macro is parameterized and requires passing a (possibly empty) set of arguments
    when you invoke it, similar to how you would invoke a function. Unlike functions,
    macros let you perform operations using the program’s symbols, which means you
    can create a new variable name or reference the source file and line number at
    which the macro is being invoked. An *object-like* macro is a simple identifier
    that will be replaced by a code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-5](chapter9.xhtml#tab9-5) illustrates the difference between function-like
    and object-like macros. <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO</samp>
    is an object-like macro that is replaced by the tokens <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)</samp>
    during macro expansion, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR</samp>
    is a function-like macro that is replaced by the tokens <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(x))</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is whatever parameter
    is specified when invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-5:</samp> <samp class="SANS_Futura_Std_Book_11">Macro
    Definition</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define FOO (1</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">)</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define
    BAR(x) (1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(x))</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO;</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int j</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR(10);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    k</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">BAR(2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2);</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int i</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    j</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(10));</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">int k</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2));</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'The opening parenthesis of a function-like macro definition must immediately
    follow the macro name, with no intervening whitespace. If a space appears between
    the macro name and the opening parenthesis, the parenthesis simply becomes part
    of the replacement list, as is the case with the object-like <samp class="SANS_TheSansMonoCd_W5Regular_11">FOO</samp>
    macro. The macro replacement list terminates with the first newline character
    in the macro definition. However, you can join multiple source lines with the
    backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) character followed
    by a newline to make your macro definitions easier to understand. For example,
    consider the following definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">cbrt</samp>
    type-generic macro that computes the cube root of its floating-point argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That definition is equivalent to, but easier to read, than the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One danger when defining a macro is you can no longer use the macro’s identifier
    in the rest of the program without inducing a macro replacement. For example,
    because of macro expansion, the following invalid program won’t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the tokens the preprocessor receives from the translator result
    in the following invalid code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can solve this problem by consistently adhering to an idiom throughout your
    program, such as defining macro names with all uppercase letters or prefixing
    all macro names with a mnemonic, as you might find in some styles of Hungarian
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hungarian notation *is an identifier-naming convention in which the name of
    a variable or function indicates its intention or kind and, in some dialects,
    its type.*
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve defined a macro, the only way to redefine it is to invoke the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">#undef</samp> directive for the macro.
    Once you’ve undefined it, the named identifier no longer represents a macro. For
    example, the program shown in [Table 9-6](chapter9.xhtml#tab9-6) defines a function-like
    macro, includes a header that uses the macro, and then undefines the macro so
    that it can be redefined later.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-6:</samp> <samp class="SANS_Futura_Std_Book_11">Undefining
    Macros</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">header.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NAME(first)</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">NAME(second)</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">NAME(third)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">enum Names {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  first,</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  second,</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  third,</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">};</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">void
    func(enum Names Name) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  switch
    (Name){</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">    case first:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">    case second:</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">    case
    third:</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  }</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">file.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">enum
    Names {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define NAME(X) X,</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include "header.h"</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#undef
    NAME</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">void
    func(enum Names Name) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  switch
    (Name) {</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define NAME(X) case
    X:</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include "header.h"</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">#undef NAME</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">  }</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  prefs: []
  type: TYPE_TB
- en: The first use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp>
    macro declares the names of enumerators within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Names</samp>
    enumeration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp> macro
    is undefined and then redefined to generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    labels in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.
  prefs: []
  type: TYPE_NORMAL
- en: Undefining a macro is safe even when the named identifier isn’t the name of
    a macro. This macro definition works regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">NAME</samp>
    is already defined. To keep examples short, we don’t normally follow this practice
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Macro Replacement</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function-like macros look like functions but behave differently. When the preprocessor
    encounters a macro identifier, it invokes the macro, which expands the identifier
    to replace it with the tokens from the replacement list, if any, specified in
    the macro’s definition.
  prefs: []
  type: TYPE_NORMAL
- en: For function-like macros, the preprocessor replaces all parameters in the replacement
    list with the corresponding arguments in the macro invocation after expanding
    them. Any parameter in the replacement list preceded by a <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    token is replaced with a string literal preprocessing token that contains the
    text of the argument preprocessing tokens (a process sometimes called *stringizing*).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">STRINGIZE</samp> macro in [Table
    9-7](chapter9.xhtml#tab9-7) stringizes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-7:</samp> <samp class="SANS_Futura_Std_Book_11">Stringizing</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define STRINGIZE(x) #x</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">const char *str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STRINGIZE(12);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">const
    char *str</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"12";</samp> |'
  prefs: []
  type: TYPE_TB
- en: The preprocessor also deletes all instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">##</samp>
    preprocessing token in the replacement list, concatenating the preceding preprocessing
    token with the following token, which is called *token pasting*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">PASTE</samp>
    macro in [Table 9-8](chapter9.xhtml#tab9-8) is used to create a new identifier
    by concatenating <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, the
    underscore character (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>),
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-8:</samp> <samp class="SANS_Futura_Std_Book_11">Token
    Pasting</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define PASTE(x, y) x ## _
    ## y</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int PASTE(foo, bar)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">12;</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int foo_bar</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">12;</samp> |'
  prefs: []
  type: TYPE_TB
- en: After expanding the macro, the preprocessor rescans the replacement list to
    expand additional macros within it. If the preprocessor finds the name of the
    macro being expanded while rescanning—including the rescanning of nested macro
    expansions within the replacement list—it won’t expand the name again. Furthermore,
    if macro expansion results in a fragment of program text that’s identical to a
    preprocessing directive, that fragment won’t be treated as a preprocessing directive.
  prefs: []
  type: TYPE_NORMAL
- en: During macro expansion, a repeated parameter name in the replacement list will
    be replaced multiple times by the argument given in the invocation. This can have
    surprising effects if the argument to the macro invocation involves side effects,
    as shown in [Table 9-9](chapter9.xhtml#tab9-9). This problem is explained in detail
    in CERT C rule PRE31-C, “Avoid side effects in arguments to unsafe macros.”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-9:</samp> <samp class="SANS_Futura_Std_Book_11">Unsafe
    Macro Expansion</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">#define bad_abs(x) (x >=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? x : -x)</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">int
    func(int i) {</samp><samp class="SANS_Futura_Std_Book_11">  </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  return bad_abs(i++);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int func(int i) {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  return (i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? i++</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:
    -i++);</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'In the macro definition in [Table 9-9](chapter9.xhtml#tab9-9), each instance
    of the macro parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is replaced by the macro invocation argument <samp class="SANS_TheSansMonoCd_W5Regular_11">i++</samp>,
    causing <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> to be incremented
    twice in a way that a programmer or reviewer reading the original source code
    can easily overlook. Parameters like <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the replacement list, as well as the replacement list itself, should usually
    be fully parenthesized as in <samp class="SANS_TheSansMonoCd_W5Regular_11">((x)
    >=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0 ? (x) : -(x))</samp>
    to prevent portions of the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    from associating with other elements of the replacement list in unexpected ways.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU *statement expressions* allow you to use loops, switches, and local variables
    within an expression. Statement expressions are a nonstandard compiler extension
    supported by GCC, Clang, and other compilers. Using statement expressions, you
    can rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">bad_abs(x)</samp>
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can safely invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">abs(x)</samp>
    macro with side-effecting operands.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential surprise is that a comma in a function-like macro invocation
    is always interpreted as a macro argument delimiter. The C standard <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp>
    macro (removed in C23) demonstrates the danger ([Table 9-10](chapter9.xhtml#tab9-10)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-10:</samp> <samp class="SANS_Futura_Std_Book_11">The</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp> <samp class="SANS_Futura_Std_Book_11">Macro</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original sources</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Resulting translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">stdatomic.h</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#define
    ATOMIC_VAR_INIT(value) (value)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11"><error></samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">foo.c</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">#include
    <stdatomic.h></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">struct S {</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">  int x, y;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Atomic struct S val</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT({1, 2});</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: This code fails to translate because the comma in <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT({1,
    2})</samp> is treated as a function-like macro argument delimiter, causing the
    preprocessor to interpret the macro as having two syntactically invalid arguments
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2}</samp>
    instead of a single valid argument <samp class="SANS_TheSansMonoCd_W5Regular_11">{1,
    2}</samp>. This usability issue is one of the reasons the <samp class="SANS_TheSansMonoCd_W5Regular_11">ATOMIC_VAR_INIT</samp>
    macro was deprecated in C17 and removed in C23.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type-Generic Macros</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C programming language doesn’t allow you to overload functions based on
    the types of the parameters passed to the function, as you can in other languages
    such as Java and C++. However, you might sometimes need to alter the behavior
    of an algorithm based on the argument types. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>
    has three <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp> functions (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>) because each of
    the three floating-point types (<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>, respectively) has a different precision. Using generic selection
    expressions, you can define a single function-like identifier that delegates to
    the correct underlying implementation based on the argument type when called.
  prefs: []
  type: TYPE_NORMAL
- en: A *generic selection expression* maps the type of its unevaluated operand expression
    to an associated expression. If none of the associated types match, it can optionally
    map to a default expression. You can use *type-generic macros* (macros that include
    generic selection expressions) to make your code more readable. In [Table 9-11](chapter9.xhtml#tab9-11),
    we define a type-generic macro to select the correct variant of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>
    function from <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-11:</samp> <samp class="SANS_Futura_Std_Book_11">A
    Generic Selection Expression as a Macro</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">_Generic</samp> <samp class="SANS_Futura_Std_Heavy_B_11">resolution</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The controlling expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(X)</samp>
    of the generic selection expression is unevaluated; the type of the expression
    selects a function from the list of <samp class="SANS_TheSansMonoCd_W5Regular_11">type
    : expr</samp> mappings. The generic selection expression picks one of these function
    designators (either <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>)
    and then executes it. In this example, the argument type in the first call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    so the generic selection resolves to <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>,
    and the argument type in the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, so this resolves
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>. Because this generic
    selection expression has no <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    association, an error occurs if the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">(X)</samp>
    doesn’t match any of the associated types. If you include a default association
    for a generic selection expression, it will match every type not already used
    as an association, including types you might not expect, such as pointers or structure
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Type-generic macro expansion can be difficult to use when the resulting value
    type depends on the type of an argument to the macro, as with the <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp>
    example in [Table 9-11](chapter9.xhtml#tab9-11). For instance, it can be a mistake
    to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">singen</samp> macro
    and assign the result to an object of a specific type or pass its result as an
    argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> because
    the necessary object type or format specifier will depend on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">sin</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sinf</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">sinl</samp>
    is called. You can find examples of type-generic macros for math functions in
    the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11"><tgmath.h></samp>
    header.
  prefs: []
  type: TYPE_NORMAL
- en: C23 partially addressed this problem with the introduction of automatic type
    inference using the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier, described in [Chapter 2](chapter2.xhtml). Consider using automatic
    type inference when initializing an object with a type-generic macro to avoid
    unintentional conversions on initialization. For example, the following file scope
    definitions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'are interpreted as if they had been written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Effectively, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is a float
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is a float <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 9-12](chapter9.xhtml#tab9-12), we replace the types of the two variables
    declared in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> from [Table
    9-11](chapter9.xhtml#tab9-11) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier. This makes it easier to invoke a type-generic macro, although
    it is not strictly necessary as the programmer can also deduce the types. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> type specifier is useful
    when invoking a type-generic function-like macro where the type of the resulting
    value depends on a macro parameter to avoid accidental type conversion on initialization.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-12:</samp> <samp class="SANS_Futura_Std_Book_11">Type-Generic
    Macros with Automatic Type Inference</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">_Generic</samp> <samp class="SANS_Futura_Std_Heavy_B_11">resolution</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp>
    type specifier for declaring variables in type-generic macros where you don’t
    know the type of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Embedded Binary Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find that you need to dynamically load digital resources, such as images,
    sounds, video, text files, or other binary data, at runtime. It may instead be
    beneficial to load those resources at compile time so they can be stored as part
    of the executable rather than dynamically loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C23, there were two common approaches to embedding binary resources
    into your program. For limited amounts of binary data, the data could be specified
    as an initializer for a constant-size array. However, for larger binary resources,
    this approach could introduce significant compile-time overhead, so the use of
    a linker script or other postprocessing was necessary to keep compile times reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: C23 added the <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> preprocessor
    directive to embed a digital resource directly into source code as if it were
    a comma-delimited list of integer constants. The new directive allows an implementation
    to optimize for better compile time efficiency when using the embedded constant
    data as an array initializer. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp>,
    the implementation does not need to parse each integer constant and comma token
    separately; it can inspect the bytes directly and use a more efficient mapping
    of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-13](chapter9.xhtml#tab9-13) shows an example of embedding the binary
    resource *file.txt* as the initializer for the <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>
    array declaration. For this example, *file.txt* contains the ASCII text <samp
    class="SANS_TheSansMonoCd_W5Regular_11">meow</samp> to keep the code listing short.
    Significantly larger binary resources are typically embedded.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-13:</samp> <samp class="SANS_Futura_Std_Book_11">Embedding
    Binary Resources</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Original source</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Resulting
    translation unit</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char buffer[]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">#embed <file.txt></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char buffer[]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">109, 101, 111, 119</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">};</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Like <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>, the filename
    specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive
    can be listed within either angle brackets or double quotes. Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>,
    there is no notion of *system* or *user* embedded resources, so the only difference
    between the two forms is that the double-quoted form will start searching for
    the resource from the same directory as the source file before trying other search
    paths. Compilers have a command line option to specify search paths for embedded
    resources; see your compiler documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive supports
    several parameters to control what data is embedded into the source file: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">limit</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">suffix</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">if_empty</samp>.
    The most useful of those parameters is the <samp class="SANS_TheSansMonoCd_W5Regular_11">limit</samp>
    parameter, which specifies how much data to embed (in bytes). This can be helpful
    if the only data needed at compile time is in the header of the file or if the
    file is an *infinite* resource like */dev/urandom* in some operating systems.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">suffix</samp>
    parameters insert tokens before or after the embedded resource, respectively,
    if the resource is found and is not empty. The <samp class="SANS_TheSansMonoCd_W5Regular_11">if_empty</samp>
    parameter inserts tokens if the embedded resource is found but has no content
    (including when the <samp class="SANS_TheSansMonoCd_W5Regular_11">limit</samp>
    parameter is explicitly set to 0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp>, you
    can test whether an embedded resource can be found using the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_embed</samp>
    preprocessor operator. This operator returns:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_FOUND__</samp> if
    the resource can be found and isn’t empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_EMPTY__</samp> if
    the resource can be found and is empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_EMBED_NOT_FOUND__</samp>
    if the resource cannot be found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Predefined Macros</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation defines some macros without requiring you to include a header.
    These macros are called *predefined macros* because they’re implicitly defined
    by the preprocessor rather than explicitly defined by the programmer. For example,
    the C standard defines various macros that you can use to interrogate the compilation
    environment or provide basic functionality. Some other aspects of the implementation
    (such as the compiler or the compilation target operating system) also automatically
    define macros. [Table 9-14](chapter9.xhtml#tab9-14) lists some of the common macros
    the C standard defines. You can obtain a full list of predefined macros from Clang
    or GCC by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">-E -dM</samp>
    flags to those compilers. Check your compiler documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-14:</samp> <samp class="SANS_Futura_Std_Book_11">Predefined
    Macros</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Macro name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Replacement
    and purpose</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__DATE__</samp> | <samp class="SANS_Futura_Std_Book_11">A
    string literal of the date of translation of the preprocessing translation unit
    in the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Mmm
    dd yyyy</samp><samp class="SANS_Futura_Std_Book_11">.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__TIME__</samp> | <samp class="SANS_Futura_Std_Book_11">A
    string literal of the time of translation for the preprocessing translation unit
    in the form</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">hh:mm:ss</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__FILE__</samp> | <samp class="SANS_Futura_Std_Book_11">A
    string literal representing the presumed filename of the current source file.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__LINE__</samp> | <samp class="SANS_Futura_Std_Book_11">An
    integer constant representing the presumed line number of the current source line.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC__</samp> | <samp class="SANS_Futura_Std_Book_11">The
    integer constant 1 if the implementation conforms to the C standard.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_HOSTED__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation is
    a hosted implementation or the integer constant 0 if it is stand-alone. This macro
    is conditionally defined by the implementation.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_VERSION__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant representing the version
    of the C standard the compiler is targeting, such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">202311L</samp>
    <samp class="SANS_Futura_Std_Book_11">for the C23 standard.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if values of type</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> <samp class="SANS_Futura_Std_Book_11">are
    UTF-16</samp> <samp class="SANS_Futura_Std_Book_11">encoded. This macro is conditionally
    defined by the</samp> <samp class="SANS_Futura_Std_Book_11">implementation.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if values of type</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> <samp class="SANS_Futura_Std_Book_11">are
    UTF-32</samp> <samp class="SANS_Futura_Std_Book_11">encoded. This macro is conditionally
    defined by the</samp> <samp class="SANS_Futura_Std_Book_11">implementation.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_ATOMICS__</samp>
    | <samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation
    doesn’t support atomic types, including the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp>
    <samp class="SANS_Futura_Std_Book_11">type qualifier, and the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdatomic.h></samp>
    <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined
    by the implementation.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_COMPLEX__</samp>
    | <samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation
    doesn’t support complex types or the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><complex.h></samp>
    <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined
    by the implementation.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_THREADS__</samp>
    | <samp class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation
    doesn’t support the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><threads.h></samp>
    <samp class="SANS_Futura_Std_Book_11">header. This macro is conditionally defined
    by the implementation.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_NO_VLA__</samp> | <samp
    class="SANS_Futura_Std_Book_11">The integer constant 1 if the implementation doesn’t
    support variable-length arrays. This macro is conditionally defined by the implementation.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about some of the features provided by the preprocessor.
    You learned how to include fragments of program text in a translation unit, conditionally
    compile code, embed binary resources into your program, and generate diagnostics
    on demand. You then learned how to define and undefine macros, how macros are
    invoked, and about macros that are predefined by the implementation. The preprocessor
    is popular in C language programming but shunned in C++ programming. Use of the
    preprocessor can be error prone, so it is best to follow the recommendations and
    rules from *The CERT C Coding Standard*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to structure your program into more than
    one translation unit to create more maintainable programs.
  prefs: []
  type: TYPE_NORMAL
