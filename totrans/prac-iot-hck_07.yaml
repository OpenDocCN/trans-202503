- en: '# 5'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Network Protocols
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Analyzing protocols is important for tasks such as fingerprinting, obtaining
    information, and even exploitation. But in the IoT world, you’ll frequently have
    to work with proprietary, custom, or new network protocols. These protocols can
    be challenging, because even if you can capture network traffic, packet analyzers
    like Wireshark often can’t identify what you’ve found. Sometimes, you’ll need
    to write new tools to communicate with the IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explain the process of analyzing network communications,
    focusing specifically on the challenges you’ll face when working with unusual
    protocols. We start by walking through a methodology for performing security assessments
    of unfamiliar network protocols and implementing custom tools to analyze them.
    Next, we extend the most popular traffic analyzer, Wireshark, by writing our own
    protocol dissector. Then we write custom modules for Nmap to fingerprint and even
    attack any new network protocol that dares to cross your path.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter target the DICOM protocol, one of the most common
    protocols in medical devices and clinical systems, rather than an unusual protocol.
    Even so, almost no security tools support DICOM, so this chapter should help you
    work with any unusual network protocol you might encounter in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Network Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re working with unusual protocols, it’s best to analyze them according
    to a methodology. Follow the process we describe in this section when assessing
    a network protocol’s security. We attempt to cover the most important tasks, including
    information gathering, analysis, prototyping, and security auditing.
  prefs: []
  type: TYPE_NORMAL
- en: Information Gathering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the information-gathering phase, you’ll try to find all relevant resources
    available to you. But first, figure out whether the protocol is well documented
    by searching for the protocol’s official and unofficial documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating and Installing Clients
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you have access to the documentation, find all the clients that can communicate
    with the protocol and install them. You can use these to replicate and generate
    traffic at will. Different clients might implement the protocol with small variations,
    so note these differences! Also, check whether programmers have written implementations
    in different programming languages. The more clients and implementations you find,
    the higher your chances are of finding better documentation and replicating network
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Dependent Protocols
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, figure out whether the protocol depends on other protocols. For example,
    the Server Message Block (SMB) protocol generally works with NetBios over TCP/IP
    (NBT). If you’re writing new tools, you need to know any protocol dependencies
    to read and understand messages and to create and send new messages. Be sure to
    figure out which transport protocol your protocol is using. Is it TCP or UDP?
    Or is it something else: SCTP, maybe?'
  prefs: []
  type: TYPE_NORMAL
- en: Figuring Out the Protocol’s Port
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Figure out the protocol’s default port number and whether the protocol ever
    runs on alternate ports. Identifying the default port and whether that number
    can change is helpful information that you’ll use when writing scanners or information-gathering
    tools. For example, Nmap reconnaissance scripts might not run if we write an inaccurate
    execution rule, and Wireshark might not use the correct dissector. Although there
    are workarounds for these issues, it’s best to have robust execution rules from
    the start.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Additional Documentation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Check Wireshark’s website for additional documentation or capture samples. The
    Wireshark project often includes packet captures and is an overall great source
    of information. The project uses a wiki ([https://gitlab.com/wireshark/wireshark/-/wikis/home/](https://gitlab.com/wireshark/wireshark/-/wikis/home/))
    to allow contributors to add new information to every page.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice which areas lack documentation. Can you identify functions that
    aren’t well described? A lack of documentation can point you toward interesting
    findings.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Wireshark Dissectors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Test whether all the Wireshark dissectors work properly against the protocol
    in use. Can Wireshark interpret and read all fields correctly in the protocol
    messages?
  prefs: []
  type: TYPE_NORMAL
- en: To do this, first check whether Wireshark has a dissector for the protocol and
    if it’s enabled. You can do that by clicking **Analyze**▶**Enabled Protocols**,
    as shown in [Figure 5-1](#figure5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](Images/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: The Enabled Protocols window in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: If the protocol specifications are public, check that all fields are identified
    correctly. Especially with complex protocols, dissectors often have errors. If
    you spot any, pay close attention to them. To get more ideas, review the list
    of Common Vulnerabilities and Exposures (CVEs) assigned to Wireshark dissectors.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the analysis phase, generate and replay traffic to understand how the protocol
    works. The objective is to get a clear idea of the overall structure of the protocol,
    including its transport layer, messages, and available operations.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a Copy of the Network Traffic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on the type of device, there are different ways of obtaining the network
    traffic you need to analyze. Some might support proxy configurations out of the
    box! Determine whether you need to perform active or passive network traffic sniffing.
    (You can find several examples of how to do this in James Forshaw’s *Attacking
    Network Protocols* [No Starch Press, 2018].) Try to generate traffic for every
    use case available, and generate as much traffic as possible. Having different
    clients helps you understand the differences and quirks in existing implementations.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first steps in the analysis phase should be looking at the traffic
    capture and examining the packets sent and received. Some obvious issues might
    pop up, so it’s useful to do this before moving on with active analysis. The website
    [https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures/](https://gitlab.com/wireshark/wireshark/-/wikis/SampleCaptures/)
    is an excellent resource for finding public captures.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Network Traffic with Wireshark
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If Wireshark has a dissector that can parse the traffic you generated, enable
    it by clicking the checkbox by its name in the Enabled Protocols window, as shown
    in [Figure 5-2](#figure5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](Images/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: Disabled protocol dissector in Enabled Protocols window in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try looking for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The first bytes in the message.** Sometimes the first bytes in the initial
    connection handshake or messages are magic bytes that provide a way to quickly
    identify the service.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The initial connection handshake.** This is an important function of any
    protocol. It’s usually during this step that you learn about the protocol’s version
    and supported features, including security features like encryption. Replicating
    this step will also help you develop scanners to easily find these devices and
    services on networks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Any TCP/UDP streams and common data structures used in the protocol.** Sometimes,
    you’ll identify strings in plaintext, or common data structures, such as packets
    with the length appended to the beginning of the message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The endianness of the protocol.** Some protocols use mixed endianness, which
    can cause problems if not identified early. Endianness varies a lot from protocol
    to protocol, but it’s necessary for creating correct packets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The structure of the messages.** Identify different headers and message structures
    and how to initialize and close the connection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prototyping and Tool Development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve analyzed the protocol, you can start *prototyping*, or transforming
    the notes you gathered from your analysis into actual software that you can use
    to communicate with a service using the protocol. The prototype will confirm that
    you correctly understood the packet structure of each message type. In this phase,
    it’s important to choose a programming language that allows you to work very quickly.
    For that reason, we prefer dynamically typed scripting languages, such as Lua
    or Python. Check whether any libraries and frameworks are available that you could
    leverage to speed up development.
  prefs: []
  type: TYPE_NORMAL
- en: If Wireshark doesn’t support the protocol, develop a dissector to help you with
    the analysis. We’ll discuss this process in the “Developing a Lua Wireshark Dissector
    for the DICOM Protocol” section later in this chapter. We’ll also use Lua for
    prototyping an Nmap Scripting Engine module to communicate with the service.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting a Security Assessment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you’ve concluded the analysis, confirmed your conjectures about the protocol,
    and created a working prototype to communicate with the DICOM service, you need
    to assess the protocol’s security. In addition to the general security assessment
    process described in Chapter 3, check for the following key points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test server and client impersonation attacks.** Ideally, the client and server
    should authenticate each other, a process known as mutual authentication. If they
    don’t, it might be possible to impersonate either the client or the server. This
    behavior can have serious consequences; for example, we once performed a client-impersonation
    attack to spoof a drug library component and feed a drug infusion pump with rogue
    drug libraries. Although the two endpoints communicated over Transport Layer Security
    (TLS), this couldn’t prevent the attack, because no mutual authentication took
    place.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fuzz the protocol and check for flooding attacks.** Also, attempt to replicate
    crashes and identify bugs. Fuzzing is the process of automatically supplying malformed
    input to a system with the end goal of finding implementation bugs. Most of the
    time, this will cause the system to crash. The more complex the protocol, the
    higher the chances of finding memory corruption flaws. DICOM (analyzed later in
    this chapter) is a perfect example. Given its complexity, it’s possible to find
    buffer overflows and other security problems in different implementations. In
    flooding attacks, attackers send the system a large number of requests to exhaust
    the system’s resources, causing the system to become unresponsive. A typical example
    of this is the TCP SYN flood attack, which you can mitigate using SYN cookies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Check for encryption and signing.** Is the data confidential? Can we assure
    the data integrity? How strong are the cryptographic algorithms used? We’ve seen
    cases where vendors implemented their own custom cryptographic algorithms, and
    it was always a disaster. In addition, many network protocols don’t require any
    digital signing, which provides message authentication, data integrity, and nonrepudiation.
    For example, DICOM doesn’t employ digital signing unless it’s used over a secure
    protocol like Transport Layer Security (TLS), which is susceptible to man-in-the-middle
    attacks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test for downgrade attacks.** These are cryptographic attacks on the protocol
    that force the system to use a lower-quality, more insecure mode of operation
    (for example, one that sends cleartext data). Examples include the Padding Oracle
    on Downgraded Legacy Encryption (POODLE) attack on Transport Layer Security/Secure
    Sockets Layer (TLS/SSL). In this attack, a man-in-the-middle attacker forces clients
    to fall back on SSL 3.0 and exploits a design flaw to steal cookies or passwords.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test for amplification attacks.** These attacks are caused when the protocol
    has functions whose response is considerably larger than the request, because
    attackers can abuse these functions to cause a denial of service. An example of
    this is the mDNS reflection DDoS attack, where some mDNS implementations responded
    to unicast queries that originated from sources outside the local-link network.
    We’ll explore mDNS in Chapter 6\.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developing a Lua Wireshark Dissector for the DICOM Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section shows you how to write a dissector that you can use with Wireshark.
    When auditing network protocols used by IoT devices, it’s crucial we understand
    how the communication is happening, how the messages are formed, and what functions,
    operations, and security mechanisms are involved. Then we can start altering data
    flows to find vulnerabilities. To write our dissector, we’ll use Lua; it allows
    us to quickly analyze captured network communications with a small amount code.
    We’ll go from seeing blobs of information to readable messages by contributing
    just a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, we’ll only focus on the subset of functions needed to process
    DICOM A-type messages (discussed in the next section). Another detail to note
    when writing Wireshark dissectors for TCP in Lua is that packets can be fragmented.
    Also, depending on factors like packet retransmissions, out of order errors, or
    Wireshark configurations limiting the packet size captures (the default capture
    packet size limit is 262,144 bytes), we might have less or more than one message
    in a TCP segment. Let’s ignore this for now and focus on the A-ASSOCIATE requests,
    which will be enough to identify DICOM services when we write a scanner. If you
    want to learn more about how to deal with TCP fragmentation, see the full resulting
    example file *orthanc.lua* distributed with this book’s materials or go to [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/).
  prefs: []
  type: TYPE_NORMAL
- en: Working with Lua
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lua is a scripting language for creating expandable or scriptable modules in
    many important security projects, such as Nmap, Wireshark, and even commercial
    security products like NetMon from LogRhythm. Some of the products you use daily
    are likely running Lua. Many IoT devices also use Lua because of its small binary
    size and well-documented API, which makes it easy to use to extend projects in
    other languages like C, C++, Erlang, and even Java. This makes Lua perfect for
    embedding into applications. You’ll learn how to represent and work with data
    in Lua, and how popular software such as Wireshark and Nmap use Lua to extend
    their capabilities for traffic analysis, network discovery, and exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the DICOM Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DICOM is a nonproprietary protocol developed by the American College of Radiology
    and National Electrical Manufacturers Association. It has become the international
    standard for transferring, storing, and processing medical imaging information.
    Although DICOM isn’t proprietary, it’s a good example of a network protocol implemented
    in many medical devices, and traditional network security tools don’t support
    it very well. DICOM over TCP/IP communications are two-way: a client requests
    an action and the server performs it, but they can switch their roles, if necessary.
    In DICOM terminology, the client is called Service Call User (SCU) and the server
    is called the Service Call Provider (SCP).'
  prefs: []
  type: TYPE_NORMAL
- en: Before writing any code, let’s examine some important DICOM messages and the
    protocol structure.
  prefs: []
  type: TYPE_NORMAL
- en: C-ECHO Messages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*DICOM C-ECHO* messages exchange information about the calling and called applications,
    entities, versions, UIDs, names, and roles, among other details. We commonly call
    them DICOM *pings*, because they’re used to determine whether a DICOM service
    provider is online. A C-ECHO message uses several *A-type messages*, so we’ll
    be looking for these in this section. The first packet a C-ECHO operation sends
    is an *A-ASSOCIATE request message*, which is sufficient to identify a DICOM service
    provider. From the A-ASSOCIATE response, you can obtain information about the
    service.'
  prefs: []
  type: TYPE_NORMAL
- en: A-Type Protocol Data Units (PDUs)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are seven kinds of A-type messages used in C-ECHO messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A-ASSOCIATE request (A-ASSOCIATE-RQ):** Requests sent by the client to establish
    a DICOM connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A-ASSOCIATE accept (A-ASSOCIATE-AC):** Responses sent by the server to accept
    a DICOM A-ASSOCIATE request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A-ASSOCIATE reject (A-ASSOCIATE-RJ):** Responses sent by the server to reject
    a DICOM A-ASSOCIATE request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(P-DATA-TF):** Data packets sent by server and client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A-RELEASE request (A-RELEASE-RQ):** Requests sent by the client to close
    a DICOM connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A-RELEASE response (A-RELEASE-RP PDU):** Responses sent by the server to
    acknowledge the A-RELEASE request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A-ASSOCIATE abort (A-ABORT PDU):** Responses sent by the server to cancel
    the A-ASSOCIATE operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These PDUs all start with a similar packet structure. The first part is a one-byte
    unsigned integer in Big Endian that indicates the PDU type. The second part is
    a one-byte reserved section set to 0x0\. The third part is the PDU length information,
    a four-byte unsigned integer in Little Endian. The fourth part is a variable-length
    data field. [Figure 5-3](#figure5-3) shows this structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](Images/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The structure of a DICOM PDU'
  prefs: []
  type: TYPE_NORMAL
- en: Once we know the message structure, we can start reading and parsing DICOM messages.
    Using the size of each field, we can calculate offsets when defining fields in
    our prototypes to analyze and communicate with DICOM services.
  prefs: []
  type: TYPE_NORMAL
- en: Generating DICOM Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To follow along with this exercise, you need to set up a DICOM server and client.
    *Orthanc* is a robust, open source DICOM server that runs on Windows, Linux, and
    macOS. Install it on your system, make sure the configuration file has the `DicomServerEnabled`
    flag enabled, and run the Orthanc binary. If everything goes smoothly, you should
    then have a DICOM server running on TCP port 4242 (the default port). Enter the
    `orthanc` command to see the following logs describing configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t want to install Orthanc to follow along, you can find sample packet
    captures in the online resources for this book or at the Wireshark Packet Sample
    Page for DICOM.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Lua in Wireshark
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before jumping into the code, make sure you’ve installed Lua and enabled it
    in your Wireshark installation. You can check whether it’s available in the “About
    Wireshark” window, as shown in [Figure 5-4](#figure5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](Images/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: The About Wireshark window shows that Lua is supported'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lua engine is disabled by default. To enable it, set the boolean variable
    `disable_lua` to `false` in the *init.lua* file in your Wireshark installation
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking whether it’s available and enabling Lua, double-check that Lua
    support is working correctly by writing a test script and then running it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we include a simple print statement (like the line `print "Hello from Lua")`
    in the test file, we should see the output before the capture begins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, you might not see output if you use a regular print statement. But
    the `report_failure()` function will open a window containing your message, so
    it’s a good alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Dissector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s define our new protocol dissector using the `Proto(name, description)`
    function. As mentioned earlier, this dissector will specifically identify DICOM
    A-type messages (one of the seven messages listed earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the header fields in Wireshark to match the DICOM PDU structure
    discussed previously with the help of the `ProtoField` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use these ProtoFields to add items to the dissection tree. For our dissector,
    we’ll call `ProtoField` twice: once to create the one-byte unsigned integer to
    store the PDU type 1 and a second time for two bytes to store the message length
    2. Note how we assigned a table of values for PDU types. Wireshark will automatically
    display this information. Then we set our protocol dissector fields 3 to a Lua
    table containing our ProtoFields.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Main Protocol Dissector Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we declare our main protocol dissector function, `dissector()`, which
    has three arguments: a buffer for Wireshark to dissect, packet information, and
    a tree that displays protocol information.'
  prefs: []
  type: TYPE_NORMAL
- en: In this `dissector()` function, we’ll dissect our protocol and add the ProtoFields
    we defined earlier to the tree containing our protocol information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We set the `protocol` field to the protocol name we defined in `dicom_protocol.name`
    1. For each item we want to add, we use either `add_le()` for Big-Endian data
    or `add()` for Little Endian, along with a `ProtoField` and the buffer range to
    dissect.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the Dissector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `DissectorTable` holds a table of subdissectors for the protocol, shown
    through the Decode dialog in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To complete the dissector, we simply add our dissector to the `DissectorTable`
    for TCP ports at port 4242\.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-1](#listing5-1) shows the dissector in its entirety.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: The completed DICOM A-type message dissector'
  prefs: []
  type: TYPE_NORMAL
- en: We enable this dissector by putting the *.lua* file inside Wireshark’s plug-in
    directory and then reloading Wireshark. Then, when we analyze a DICOM capture,
    we should see the `pduType` byte and message length displayed under the DICOM
    PDU column we defined in our `tree:add()` call. [Figure 5-5](#figure5-5) shows
    this in Wireshark. You can use the `dicom-a.message_length` and `dicom-a.pdu_type`
    filters we defined 1 to filter traffic, too.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05005](Images/f05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: The DICOM dissector in Lua for A-type messages in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can clearly identify the PDU type and message length in DICOM packets.
  prefs: []
  type: TYPE_NORMAL
- en: Building a C-ECHO Requests Dissector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we analyze a C-ECHO request with our new dissector, we should see that
    it’s composed of different A-type messages, like those shown in [Figure 5-5](#figure5-5).
    The next step is to analyze the data contained in these DICOM packets.
  prefs: []
  type: TYPE_NORMAL
- en: To show how we can handle strings in our Lua dissector, let’s add some code
    to our dissector to parse an A-ASSOCIATE message. [Figure 5-6](#figure5-6) shows
    the structure of an A-ASSOCIATE request.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05006](Images/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: The structure of an A-ASSOCIATE request'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the 16-byte-long called and calling application entity titles. An *application
    entity title* is a label that identifies a service provider. The message also
    includes a 32-byte-long reserved section that should be set to 0x0 and variable-length
    items, including an Application Context item, Presentation Context items, and
    a User Info item.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the String Values of the Application Entity Titles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by extracting the message’s fixed-length fields, including the
    string values of the calling and called application entity titles. This is useful
    information; often, services lack authentication, so if you have the correct application
    entity title, you can connect and start issuing DICOM commands. We can define
    new ProtoField objects for our A-ASSOCIATE request message with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To extract the string values of called and calling application entity titles,
    we use the ProtoField `ProtoField.string` function.``We pass it a name to use
    in the filters 1, an optional name to display in the tree 2, the display format
    (either `base.ASCII` or `base.UNICODE`), and an optional description field.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
