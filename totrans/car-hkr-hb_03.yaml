- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**VEHICLE COMMUNICATION WITH SOCKETCAN**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you begin using a CAN for vehicle communications, you may well find it
    to be a hodgepodge of different drivers and software utilities. The ideal would
    be to unify the CAN tools and their different interfaces into a common interface
    so we could easily share information between tools.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there’s a set of tools with a common interface, and it’s free! If you
    have Linux or install Linux on a virtual machine (VM), you already have this interface.
    The interface, called SocketCAN, was created on the Open Source development site
    BerliOS in 2006\. Today, the term *SocketCAN* is used to refer to the implementation
    of CAN drivers as network devices, like Ethernet cards, and to describe application
    access to the CAN bus via the network socket–programming interface. In this chapter
    we’ll set up SocketCAN so that we’re more easily able to communicate with the
    vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: Volkswagen Group Research contributed the original SocketCAN implementation,
    which supports built-in CAN chips and card drivers, external USB and serial CAN
    devices, and virtual CAN devices. The `can-utils` package provides several applications
    and tools to interact with the CAN network devices, CAN-specific protocols, and
    the ability to set up a virtual CAN environment. In order to test many of the
    examples in this book, install a recent version in a Linux VM on your system.
    The newest versions of Ubuntu have `can-utils` in their standard repositories.
  prefs: []
  type: TYPE_NORMAL
- en: SocketCAN ties into the Linux networking stack, which makes it very easy to
    create tools to support CAN. SocketCAN applications can use standard C socket
    calls with a custom network protocol family, `PF_CAN`. This functionality allows
    the kernel to handle CAN device drivers and to interface with existing networking
    hardware to provide a common interface and user-space utilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](ch03.html#ch3fig1) compares the implementation of traditional
    CAN software with that of a unified SocketCAN.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: SocketCAN layout (left) and traditional CAN software (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: With traditional CAN software, the application has its own protocol that typically
    talks to a character device, like a serial driver, and then the actual hardware
    driver. On the left of the figure, SocketCAN is implemented in the Linux kernel.
    By creating its own CAN protocol family, SocketCAN can integrate with the existing
    network device drivers, thus enabling applications to treat a CAN bus interface
    as if it’s a generic network interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up can-utils to Connect to CAN Devices**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to install `can-utils`, you must be running a Linux distribution from
    2008 or later or one running the 2.6.25 Linux kernel or higher. First we’ll install
    `can-utils`, then cover how to configure it for your particular setup.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing can-utils***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You should be able to use your package manager to install `can-utils`. Here’s
    a Debian/Ubuntu example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t have `can-utils` in your package manager, install it from source
    with the `git` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, `can-utils` has *configure*, *make*, and *make install*
    files, but in older versions, you’d just enter `make` to install from source.
  prefs: []
  type: TYPE_NORMAL
- en: '***Configuring Built-In Chipsets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next step depends on your hardware. If you’re looking for a CAN sniffer,
    you should check the list of supported Linux drivers to ensure your device is
    compatible. As of this writing, the Linux built-in CAN drivers support the following
    chipsets:'
  prefs: []
  type: TYPE_NORMAL
- en: • Atmel AT91SAM SoCs
  prefs: []
  type: TYPE_NORMAL
- en: • Bosch CC770
  prefs: []
  type: TYPE_NORMAL
- en: • ESD CAN-PCI/331 cards
  prefs: []
  type: TYPE_NORMAL
- en: • Freescale FlexCAN
  prefs: []
  type: TYPE_NORMAL
- en: • Freescale MPC52xx SoCs (MSCAN)
  prefs: []
  type: TYPE_NORMAL
- en: • Intel AN82527
  prefs: []
  type: TYPE_NORMAL
- en: • Microchip MCP251x
  prefs: []
  type: TYPE_NORMAL
- en: • NXP (Philips) SJA1000
  prefs: []
  type: TYPE_NORMAL
- en: • TI’s SoCs
  prefs: []
  type: TYPE_NORMAL
- en: CAN controllers, like the SJA1000, are usually built into ISA, PCI, and PCMCIA
    cards or other embedded hardware. For example, the EMS PCMCIA card driver implements
    access to its SJA1000 chip. When you insert the EMS PCMCIA card into a laptop,
    the `ems_pcmcia` module loads into the kernel, which then requires the `sja1000`
    module and the `can_dev` module to be loaded. The `can_dev` module provides standard
    configuration interfaces—for example, for setting bit rates for the CAN controllers.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel’s modular concept also applies to CAN hardware drivers that
    attach CAN controllers via bus hardware, such as the `kvaser_pci`, `peak_pci`,
    and so on. When you plug in a supported device, these modules should automatically
    load, and you should see them when you enter the `lsmod` command. USB drivers,
    like `usb8dev`, usually implement a proprietary USB communication protocol and,
    therefore, do not load a CAN controller driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you plug in a PEAK-System PCAN-USB adapter, the `can_dev`
    module loads and the `peak_usb` module finalizes its initialization. Using the
    display message command `dmesg`, you should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the interface loaded properly with `ifconfig` and ensure a `can0`
    interface is now present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now set the CAN bus speed. (You’ll find more information on bus speeds in [Chapter
    5](ch05.html#ch05).) The key component you need to set is the bit rate. This is
    the speed of the bus. A typical value for high-speed CAN (HS-CAN) is 500Kbps.
    Values of 250Kbps or 125Kbps are typical for lower-speed CAN buses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you bring up the `can0` device, you should be able to use the tools from
    `can-utils` on this interface. Linux uses netlink to communicate between the kernel
    and user-space tools. You can access netlink with the `ip link` command. To see
    all the netlink options, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you begin to see odd behavior, such as a lack of packet captures and packet
    errors, the interface may have stopped. If you’re working with an external device,
    just unplug or reset. If the device is internal, run these commands to reset it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***Configuring Serial CAN Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: External CAN devices usually communicate via serial. In fact, even USB devices
    on a vehicle often communicate through a serial interface—typically an FTDI chip
    from Future Technology Devices International, Ltd.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following devices are known to work with SocketCAN:'
  prefs: []
  type: TYPE_NORMAL
- en: • Any device that supports the LAWICEL protocol
  prefs: []
  type: TYPE_NORMAL
- en: • CAN232/CANUSB serial adapters (*[http://www.can232.com/](http://www.can232.com/)*)
  prefs: []
  type: TYPE_NORMAL
- en: • VSCOM USB-to-serial adapter (*[http://www.vscom.de/usb-to-can.htm](http://www.vscom.de/usb-to-can.htm)*)
  prefs: []
  type: TYPE_NORMAL
- en: • CANtact (*[http://cantact.io](http://cantact.io)*)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re using an Arduino or building your own sniffer, you must implement
    the LAWICEL protocol—also known as the SLCAN protocol—in your firmware in order
    for your device to work. For details, see* [http://www.can232.com/docs/canusb_manual.pdf](http://www.can232.com/docs/canusb_manual.pdf)
    *and* [https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf](https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use one of the USB-to-serial adapters, you must first initialize
    both the serial hardware and the baud rate on the CAN bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `slcand` daemon provides the interface needed to translate serial communication
    to the network driver, `slcan0`. The following options can be passed to `slcand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-o` Opens the device'
  prefs: []
  type: TYPE_NORMAL
- en: '`-s6` Sets the CAN bus baud rate and speed (see [Table 3-1](ch03.html#ch3tab1))'
  prefs: []
  type: TYPE_NORMAL
- en: '`-t hw` Specifies the serial flow control, either `HW` (hardware) or `SW` (software)'
  prefs: []
  type: TYPE_NORMAL
- en: '`-S 3000000` Sets the serial baud, or bit rate, speed'
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/ttyUSB0` Your USB FTDI device'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](ch03.html#ch3tab1) lists the numbers passed to `-s` and the corresponding
    baud rates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Numbers and Corresponding Baud Rates'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number** | **Baud** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 10Kbps |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 20Kbps |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 50Kbps |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 100Kbps |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 125Kbps |'
  prefs: []
  type: TYPE_TB
- en: '|  5  | 250Kbps |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 500Kbps |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 800Kbps |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1Mbps |'
  prefs: []
  type: TYPE_TB
- en: As you can see, entering `-s6` prepares the device to communicate with a 500Kbps
    CAN bus network.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these options set, you should now have an `slcan0` device. To confirm,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Most of the information returned by `ifconfig` is set to generic default values,
    which may be all 0s. This is normal. We’re simply making sure that we can see
    the device with `ifconfig`. If we see an `slcan0` device, we know that we should
    be able to use our tools to communicate over serial with the CAN controller.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*At this point, it may be good to see whether your physical sniffer device
    has additional lights. Often a CAN sniffer will have green and red lights to signify
    that it can communicate correctly with the CAN bus. Your CAN device must be plugged
    in to your computer and the vehicle in order for these lights to function properly.
    Not all devices have these lights. (Check your device’s manual.)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Up a Virtual CAN Network***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t have CAN hardware to play with, fear not. You can set up a virtual
    CAN network for testing. To do so, simply load the `vcan` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check `dmesg`, you shouldn’t see much more than a message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now you just set up the interface as discussed in “[Configuring Built-In Chipsets](ch03.html#ch03lev2sec2)”
    on [page 37](ch03.html#page_37) but without specifying a baud rate for the virtual
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify your setup, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As long as you see a `vcan0` in the output, you’re ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: '**The CAN Utilities Suite**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our CAN device up and running, let’s take a high-level look at the `can-utils`.
    They’re listed and described briefly here; we’ll use them throughout the book,
    and we’ll explore them in greater detail as we use them.
  prefs: []
  type: TYPE_NORMAL
- en: '`asc2log` This tool parses ASCII CAN dumps in the following form into a standard
    SocketCAN logfile format:'
  prefs: []
  type: TYPE_NORMAL
- en: 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00
  prefs: []
  type: TYPE_NORMAL
- en: '`bcmserver` Jan-Niklas Meier’s proof-of-concept (PoC) broadcast manager server
    takes commands like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: vcan1 A 1 0 123 8 11 22 33 44 55 66 77 88
  prefs: []
  type: TYPE_NORMAL
- en: By default, it listens on port 28600\. It can be used to handle some busy work
    when dealing with repetitive CAN messages.
  prefs: []
  type: TYPE_NORMAL
- en: '`canbusload` This tool determines which ID is most responsible for putting
    the most traffic on the bus and takes the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: interface@bitrate
  prefs: []
  type: TYPE_NORMAL
- en: You can specify as many interfaces as you like and have `canbusload` display
    a bar graph of the worst bandwidth offenders.
  prefs: []
  type: TYPE_NORMAL
- en: '`can-calc-bit-timing` This command calculates the bit rate and the appropriate
    register values for each CAN chipset supported by the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: '`candump` This utility dumps CAN packets. It can also take filters and log
    packets.'
  prefs: []
  type: TYPE_NORMAL
- en: '`canfdtest` This tool performs send and receive tests over two CAN buses.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cangen` This command generates CAN packets and can transmit them at set intervals.
    It can also generate random packets.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cangw` This tool manages gateways between different CAN buses and can also
    filter and modify packets before forwarding them on to the next bus.'
  prefs: []
  type: TYPE_NORMAL
- en: '`canlogserver` This utility listens on port 28700 (by default) for CAN packets
    and logs them in standard format to `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`canplayer` This command replays packets saved in the standard SocketCAN “compact”
    format.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cansend` This tool sends a single CAN frame to the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cansniffer` This interactive sniffer groups packets by ID and highlights changed
    bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`isotpdump` This tool dumps ISO-TP CAN packets, which are explained in “[Sending
    Data with ISO-TP and CAN](ch04.html#ch04lev2sec4)” on [page 55](ch04.html#page_55).'
  prefs: []
  type: TYPE_NORMAL
- en: '`isotprecv` This utility receives ISO-TP CAN packets and outputs to `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`isotpsend` This command sends ISO-TP CAN packets that are piped in from `stdin`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`isotpserver` This tool implements TCP/IP bridging to ISO-TP and accepts data
    packets in the format `1122334455667788`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`isotpsniffer` This interactive sniffer is like `cansniffer` but designed for
    ISO-TP packets.'
  prefs: []
  type: TYPE_NORMAL
- en: '`isotptun` This utility creates a network tunnel over the CAN network.'
  prefs: []
  type: TYPE_NORMAL
- en: '`log2asc` This tool converts from standard compact format to the following
    ASCII format:'
  prefs: []
  type: TYPE_NORMAL
- en: 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00
  prefs: []
  type: TYPE_NORMAL
- en: '`log2long` This command converts from standard compact format to a user readable
    format.'
  prefs: []
  type: TYPE_NORMAL
- en: '`slcan_attach` This is a command line tool for serial-line CAN devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '`slcand` This daemon handles serial-line CAN devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '`slcanpty` This tool creates a Linux psuedoterminal interface (PTY) to communicate
    with a serial-based CAN interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing Additional Kernel Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some of the more advanced and experimental commands, such as the ISO-TP–based
    ones, require you to install additional kernel modules, such as `can-isotp`, before
    they can be used. As of this writing, these additional modules haven’t been included
    with the standard Linux kernels, and you’ll likely have to compile them separately.
    You can grab the additional CAN kernel modules like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once `make` finishes, it should create a *can-isotp.ko* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `make` in the root folder of the repository, it’ll try to compile
    some out-of-sync modules, so it’s best to compile only the module that you need
    in the current directory. To load the newly compiled `can-isotp.ko` module, run
    `insmod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`dmesg` should show that it loaded properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Once the ISO-TP driver has proven to be stable, it should be moved into the
    stable kernel branch in Linux. Depending on when you’re reading this, it may already
    have been moved, so be sure to check whether it’s already installed before compiling
    your own.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The can-isotp.ko Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `can-isotp.ko` module is a CAN protocol implementation inside the Linux
    network layer that requires the system to load the `can.ko` core module. The `can.ko`
    module provides the network layer infrastructure for all in-kernel CAN protocol
    implementations, like `can_raw.ko`, `can_bcm.ko`, and `can-gw.ko`. If it’s working
    correctly, you should see this output in response to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When `can.ko` is not loaded, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve forgotten to attach your CAN device or load the CAN kernel module,
    this is the strange error message you’ll see. If you were to enter `dmesg` for
    more information, you’d see a series of missing symbols referenced in the error
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `dmesg` output shows a lot of `Unknown symbol` messages, especially around
    `can_``x` methods. (Ignore the `(err 0)` messages.) These messages tell us that
    the `_isotop` module can’t find methods related to standard CAN functions. These
    messages indicate that you need to load the `can.ko` module. Once loaded, everything
    should work fine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coding SocketCAN Applications**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While `can-utils` is very robust, you’ll find that you want to write custom
    tools to perform specific actions. (If you’re not a developer, you may want to
    skip this section.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Connecting to the CAN Socket***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to write your own utilities, you first need to connect to the CAN socket.
    Connecting to a CAN socket on Linux is the same as connecting to any networking
    socket that you might know from TCP/IP network programming. The following shows
    C code that’s specific to CAN as well as the minimum required code to connect
    to a CAN socket. This code snippet will bind to `can0` as a raw CAN socket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s dissect the sections that are specific to CAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This line specifies the protocol family, `PF_CAN`, and defines the socket as
    `CAN_RAW`. You can also use `CAN_BCM` if you plan on making a broadcast manager
    (BCM) service. A BCM service is a more complex structure that can monitor for
    byte changes and the queue of cyclic CAN packet transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two lines name the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines set up the CAN family for `sockaddr` and then bind to the socket,
    allowing you to read packets off the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '***Setting Up the CAN Frame***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next we want to setup the CAN frame and read the bytes off the CAN network
    into our newly defined structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `can_frame` is defined in *linux/can.h* as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Writing to the CAN network is just like the `read` command but in reverse. Simple,
    eh?
  prefs: []
  type: TYPE_NORMAL
- en: '***The Procfs Interface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The SocketCAN network-layer modules implement a *procfs* interface as well.
    Having access to information in *proc* can make bash scripting easier and also
    provide a quick way to see what the kernel is doing. You’ll find the provided
    network-layer information in */proc/net/can/* and */proc/net/can-bcm/*. You can
    see a list of hooks into the CAN receiver by searching the *rcvlist_all* file
    with `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Some other useful *procfs* files include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '***stats*** CAN network-layer stats'
  prefs: []
  type: TYPE_NORMAL
- en: '***reset_stats*** Resets the stats (for example, for measurements)'
  prefs: []
  type: TYPE_NORMAL
- en: '***version*** SocketCAN version'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can limit the maximum length of transmitted packets in *proc*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Set this value to whatever you feel will be the maximum packet length for your
    application. You typically won’t need to change this value, but if you find that
    you’re having throttling issues, you may want to fiddle with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Socketcand Daemon**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Socketcand (*[https://github.com/dschanoeh/socketcand](https://github.com/dschanoeh/socketcand)*)
    provides a network interface into a CAN network. Although it doesn’t include `can-utils`,
    it can still be very useful, especially when developing an application in a programming
    language like Go that can’t set the CAN low-level socket options described in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Socketcand includes a full protocol to control its interaction with the CAN
    bus. For example, you can send the following line to socketcand to open a loopback
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The protocol for socketcand is essentially the same as that of Jan-Niklas Meier’s
    BCM server mentioned earlier; it’s actually a fork of the BCM server. (Socketcand,
    however, is a bit more robust than the BCM server.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Kayak**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kayak (*[http://kayak.2codeornot2code.org/](http://kayak.2codeornot2code.org/)*),
    a Java-based GUI for CAN diagnostics and monitoring (see [Figure 3-2](ch03.html#ch3fig2)),
    is one of the best tools for use with socketcand. Kayak links with OpenStreetMaps
    for mapping and can handle CAN definitions. As a Java-based application, it’s
    platform independent, so it leans on socketcand to handle communication to the
    CAN transceivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download a binary package for Kayak or compile from source. In order
    to compile Kayak, install the latest version of Apache Maven, and clone the Kayak
    git repository (*[git://github.com/dschanoeh/Kayak](http://git://github.com/dschanoeh/Kayak)*).
    Once the clone is complete, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You should find your binary in the *Kayak/application/target/kayak/bin* folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: The Kayak GUI*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you launch Kayak, start socketcand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can attach as many CAN devices as you want to socketcand, separated by
    commas.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start Kayak and take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project with CTRL-N and give it a name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the project and choose **Newbus**; then, give your bus a name (see
    [Figure 3-3](ch03.html#ch3fig3)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f03-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 3-3: Creating a name for the CAN bus*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Connections** tab at the right; your socketcand should show up under
    Auto Discovery (see [Figure 3-4](ch03.html#ch3fig4)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f03-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 3-4: Finding Auto Discovery under the Connections tab*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Drag the socketcand connection to the bus connection. (The bus connection should
    say *Connection: None* before it’s set up.) To see the bus, you may have to expand
    it by clicking the drop-down arrow next to the bus name, as shown in [Figure 3-5](ch03.html#ch3fig5).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f03-05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 3-5: Setting up the bus connection*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click the bus and choose **Open RAW view**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the play button (circled in [Figure 3-6](ch03.html#ch3fig6)); you should
    start to see packets from the CAN bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f03-06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 3-6: Open RAW view and press the play button to see packets from the
    CAN bus.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Choose **Colorize** from the toolbar to make it easier to see and read the changing
    packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kayak can easily record and play back packet capture sessions, and it supports
    CAN definitions (stored in an open KDC format). As of this writing, the GUI doesn’t
    support creating definitions, but I’ll show how to create definitions later.
  prefs: []
  type: TYPE_NORMAL
- en: Kayak is a great open source tool that can work on any platform. In addition,
    it has a friendly GUI with advanced features that allow you to define the CAN
    packets you see and view them graphically.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use SocketCAN as a unified interface for
    CAN devices and how to set up your device and apply the appropriate bit rate for
    your CAN bus. I reviewed all of the default CAN utilities in the `can-utils` package
    that come with SocketCAN support, and I showed you how to write low-level C code
    to directly interface with the CAN sockets. Finally, you learned how to use socketcand
    to allow remote interaction with your CAN devices and set up Kayak to work with
    socketcand. Now that you’ve set up communication with your vehicle, you’re just
    about ready to try out some attacks.
  prefs: []
  type: TYPE_NORMAL
