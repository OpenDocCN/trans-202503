["```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, statement body)\nstatement = Return(exp)\nexp = Constant(int)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\nunary_operator = Complement | Negate **| Not**\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder **| And | Or**\n                **| Equal | NotEqual | LessThan | LessOrEqual**\n                **| GreaterThan | GreaterOrEqual**\n```", "```\n<program> ::= <function>\n<function> ::= \"int\" <identifier> \"(\" \"void\" \")\" \"{\" <statement> \"}\"\n<statement> ::= \"return\" <exp> \";\"\n<exp> ::= <factor> | <exp> <binop> <exp>\n<factor> ::= <int> | <unop> <factor> | \"(\" <exp> \")\"\n<unop> ::= \"-\" | \"~\" **| \"!\"**\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" **| \"&&\" | \"||\"**\n          **| \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\"**\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\n`<instructions for e1>`\nv1 = `<result of e1>`\n`<instructions for e2>`\nv2 = `<result of e2>`\nBinary(LessThan, v1, v2, result)\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier, instruction* body)\ninstruction = Return(val)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            **| Copy(val src, val dst)**\n            **| Jump(identifier target)**\n            **| JumpIfZero(val condition, identifier target)**\n            **| JumpIfNotZero(val condition, identifier target)**\n            **| Label(identifier)**\nval = Constant(int) | Var(identifier)\nunary_operator = Complement | Negate **| Not**\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder **| Equal | NotEqual**\n                **| LessThan | LessOrEqual | GreaterThan | GreaterOrEqual**\n```", "```\nUnary(Negate, Constant(1), Var(\"tmp\"))\nJump(\"there\")\n‚ù∂ Unary(Negate, Constant(2), Var(\"tmp\"))\nLabel(\"there\")\nReturn(Var(\"tmp\"))\n```", "```\n`<instructions for e1>`\nv1 = `<result of e1>`\nJumpIfZero(v1, false_label)\n`<instructions for e2>`\nv2 = `<result of e2>`\nJumpIfZero(v2, false_label)\nresult = 1\nJump(end)\nLabel(false_label)\nresult = 0\nLabel(end)\n```", "```\n11111111111111111111111111111011\n```", "```\nmovl    $2, %edx\ncmpl    $1, %edx\nsete    %al\n```", "```\n11111111111111111111111100000000\n```", "```\n addl    $1, %eax\n    jmp     foo\n    movl    $0, %eax\nfoo:\n    ret\n```", "```\n cmpl    %eax, %edx\n    je      return3\n    movl    $0, %eax\n    ret\nreturn3:\n    movl    $3, %eax\n    ret\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, instruction* instructions)\ninstruction = Mov(operand src, operand dst)\n            | Unary(unary_operator, operand)\n            | Binary(binary_operator, operand, operand)\n            **| Cmp(operand, operand)**\n            | Idiv(operand)\n            | Cdq\n            **| Jmp(identifier)**\n            **| JmpCC(cond_code, identifier)**\n            **| SetCC(cond_code, operand)**\n            **| Label(identifier)**\n            | AllocateStack(int)\n            | Ret\nunary_operator = Neg | Not\nbinary_operator = Add | Sub | Mult\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int)\n**cond_code = E | NE | G | GE | L | LE**\nreg = AX | DX | R10 | R11\n```", "```\nJumpIfZero(val, target)\n```", "```\nCmp(Imm(0), val)\nJmpCC(E, target)\n```", "```\nBinary(GreaterThan, src1, src2, dst)\n```", "```\nCmp(src2, src1)\nMov(Imm(0), dst)\nSetCC(G, dst)\n```", "```\nUnary(Not, src, dst)\n```", "```\nCmp(Imm(0), src)\nMov(Imm(0), dst)\nSetCC(E, dst)\n```", "```\ncmpl    -4(%rbp), -8(%rbp)\n```", "```\nmovl    -4(%rbp), %r10d\ncmpl    %r10d, -8(%rbp)\n```", "```\ncmpl    %eax, $5\n```", "```\nmovl    $5, %r11d\ncmpl    %eax, %r11d\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">cmpl   </samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><operand>,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><operand></samp></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">jmp     .L</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><label></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">j</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><cond_code></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.L</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><label></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">set</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><cond_code></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><operand></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.L</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><label></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp>\n```"]