- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AssemblyScript
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: AssemblyScript is a high-level language explicitly designed to compile to WebAssembly
    or WAT. AssemblyScript is more expressive than WAT but can compile to it. When
    you use AssemblyScript, you lose some of the fine optimization control that you
    have with WAT, but it’s much faster to write.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter by creating a simple `AddInt``s` function, like the
    `AddInt` one we created in Chapter 1. We’ll write an AssemblyScript hello world
    app and compile it into WAT to see the WebAssembly that the AssemblyScript compiler
    generates. We’ll examine AssemblyScript’s use of length-prefixed strings, and
    then install the AssemblyScript loader to see how it can make it easier to transfer
    strings between AssemblyScript and JavaScript. We’ll pass strings into AssemblyScript
    by writing a string concatenation app. We’ll also explore OOP in AssemblyScript.
    We’ll create a couple of classes to demonstrate class inheritance and discuss
    `private` attributes that prevent AssemblyScript from exporting attributes to
    the embedding environment. Next, we’ll write JavaScript that allows us to create
    `public`, `private`, and `protected`members directly, as well as use the AssemblyScript
    loader. Then we’ll compare the performance of direct and loader function calls.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The AssemblyScript team designed it to be similar to TypeScript and JavaScript.
    Unlike WAT, AssemblyScript is a high-level language with features such as classes,
    strings, and arrays. Along with high-level features, AssemblyScript allows users
    to code with low-level WAT-like memory commands. AssemblyScript has a *Command
    Line Interface (CLI)* that can compile AssemblyScript into a WebAssembly module
    for use from within JavaScript applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: For JavaScript developers interested in using WebAssembly to improve the performance
    of their JavaScript applications, AssemblyScript is a great tool. Unfortunately,
    as with everything in WebAssembly, merely tweaking your TypeScript until it compiles
    with the AssemblyScript compiler might not result in a considerable performance
    boost. Understanding what AssemblyScript does under the hood allows you to write
    code in a language that looks like JavaScript but runs like C++. To gain this
    understanding, we’ll compile AssemblyScript code to WAT to explore the AssemblyScript
    compiler’s output.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: AssemblyScript CLI
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install AssemblyScript using the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `npm` command installs AssemblyScript globally, which allows you to use
    the AssemblyScript compiler `asc` command from the command line. Running `asc
    -h` provides a list of compiler command examples and options.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: I won’t explain all the command line arguments but will mention a few that are
    useful. The `-O` option optimizes in the same way as `wasm-opt` in Chapter 9.
    You follow `-O` with a number 0 to 3, s, or z, instructing the compiler to optimize
    for size or performance and how much optimization to apply. The `-o` flag when
    followed by the name of a *.wat* file will generate WAT code from the AssemblyScript,
    and when followed by the name of a *.wasm* file will generate a binary WebAssembly
    module. The `--sourceMap` flag creates a source map file to help you debug your
    AssemblyScript from the browser.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会解释所有的命令行参数，但会提到一些有用的参数。`-O`选项与第9章中的`wasm-opt`优化方式相同。你在`-O`后跟一个数字0至3、s或z，指示编译器进行优化，优化目标是大小还是性能，以及应用多少优化。`-o`标志后跟*.wat*文件的名称时，会从AssemblyScript生成WAT代码；而后跟*.wasm*文件的名称时，会生成WebAssembly二进制模块。`--sourceMap`标志创建一个源映射文件，帮助你从浏览器调试AssemblyScript。
- en: We’ll first create a simple AssemblyScript module. Create the file *as_add.ts*
    and add the code in [Listing 11-1](#listing11-1). This is a much simpler version
    of the `AddInt` function in Chapter 1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个简单的AssemblyScript模块。创建文件*as_add.ts*并添加[清单11-1](#listing11-1)中的代码。这是第一章中`AddInt`函数的一个简化版本。
- en: '**as_add.ts**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_add.ts**'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-1: Adding two integers'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-1：两个整数相加
- en: We make the `function` available to the embedding JavaScript using the `export`
    1 keyword. It takes two `i32` parameters `a` 2 and `b` 3, and returns `a + b`
    4 as an `i32`. Compile *as_add.ts* using the command in [Listing 11-2](#listing11-2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`export` 1关键字将`function`暴露给嵌入的JavaScript。它接受两个`i32`类型的参数`a` 2和`b` 3，并返回`a
    + b` 4，作为`i32`类型。使用[清单11-2](#listing11-2)中的命令编译 *as_add.ts*。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-2: Compiling `AddInt``s` to WAT'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-2：将`AddInt`s`编译为WAT
- en: The `-Oz` flag makes the size of the output binary as small as possible. The
    final flag, `-o` `as_add.wat`, tells the compiler to output WAT. Alternatively,
    we could have compiled a *.wasm* file, such as *as_add.wasm*, which would output
    a WebAssembly binary. When we look at the *as_add.wat* file that is output, we
    see the WAT code in [Listing 11-3](#listing11-3).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Oz`标志使输出的二进制文件尽可能小。最后一个标志`-o` `as_add.wat`告诉编译器输出WAT代码。或者，我们也可以编译一个*.wasm*文件，比如*as_add.wasm*，它将输出WebAssembly二进制文件。当我们查看输出的*as_add.wat*文件时，会看到[清单11-3](#listing11-3)中的WAT代码。'
- en: '**as_add.wat**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_add.wat**'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-3: AssemblyScript `AddInts` function compiled to WAT'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-3：编译为WAT的AssemblyScript `AddInts`函数
- en: Writing code in AssemblyScript is much easier than writing code directly in
    WAT. This code produces the `AddInts` 1 function that exports a function 2 that
    takes two `i32` parameters and returns an `i32`. The output function uses a `local.get`
    to retrieve the first 3 and second 4 parameters, and uses an `i32.add`5 to add
    those two values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在AssemblyScript中编写代码比直接在WAT中编写代码要容易得多。这段代码生成了`AddInts` 1函数，它导出了一个接受两个`i32`参数并返回一个`i32`的函数。输出函数使用`local.get`来获取第一个3和第二个4参数，并使用`i32.add`5来将这两个值相加。
- en: AssemblyScript is a beautiful little language that is relatively easy to learn
    for anyone familiar with TypeScript or JavaScript. Understanding WAT is a great
    way to get the most from your AssemblyScript or whichever high-level language
    you choose for WebAssembly development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript是一种美丽的小语言，对于熟悉TypeScript或JavaScript的人来说，相对容易学习。理解WAT是从你的AssemblyScript或你选择的任何高级语言中获取最大收益的好方法，尤其是用于WebAssembly开发时。
- en: Hello World AssemblyScript
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello World AssemblyScript
- en: Next, we’ll build an AssemblyScript version of the WAT hello world application
    from Chapter 2. Create a new AssemblyScript file named *as_hello.ts* and add the
    code in [Listing 11-4](#listing11-4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个AssemblyScript版本的WAT Hello World应用程序，参考第二章的示例。创建一个名为*as_hello.ts*的新AssemblyScript文件，并添加[清单11-4](#listing11-4)中的代码。
- en: '**as_hello.ts**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_hello.ts**'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-4: A hello world AssemblyScript app'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-4：一个Hello World的AssemblyScript应用
- en: The function declaration in AssemblyScript must correspond with a JavaScript
    function passed into the WebAssembly module. So we’ll need to pass in a function
    through the `importObject` that logs our string to the console. The `declare`
    `function` 1 imports the `console_log` function from the JavaScript. This function
    will pass a string from the AssemblyScript back to the calling JavaScript app.
    We create an `export` `function` called `HelloWorld` 2 that calls the imported
    `console_log` 3 function, passing in the string `"hello world!"`. Before we compile
    this into a WebAssembly module, we’ll use `asc` to compile a WAT file so we can
    look at the WebAssembly created ([Listing 11-5](#listing11-5)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 中的函数声明必须与传入 WebAssembly 模块的 JavaScript 函数相对应。因此，我们需要通过 `importObject`
    传入一个将字符串记录到控制台的函数。`declare` `function` 1 从 JavaScript 导入了 `console_log` 函数。这个函数将把一个字符串从
    AssemblyScript 传回调用的 JavaScript 应用程序。我们创建了一个 `export` `function`，名为 `HelloWorld`
    2，它调用导入的 `console_log` 3 函数，并传入字符串 `"hello world!"`。在将其编译成 WebAssembly 模块之前，我们将使用
    `asc` 编译一个 WAT 文件，这样我们就可以查看创建的 WebAssembly（[列表 11-5](#listing11-5)）。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-5: Compile the *as_hello.ts* AssemblyScript file into *as_hello.wat*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-5：将 *as_hello.ts* AssemblyScript 文件编译为 *as_hello.wat*。
- en: Then we can open *as_hello.wat* in [Listing 11-6](#listing11-6) to see the WebAssembly
    that AssemblyScript generated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以打开 *as_hello.wat* 文件，在 [列表 11-6](#listing11-6) 中查看 AssemblyScript 生成的
    WebAssembly。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-6: The *as_hello.wat* file generated from the *as_hello.ts* AssemblyScript'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：从 *as_hello.ts* AssemblyScript 生成的 *as_hello.wat* 文件。
- en: I’ve added comments to clarify the code 1. This module imports `console_log`
    2 wrapped in the object `as_hello`, the name of our AssemblyScript file without
    the *.ts* extension. This is the naming convention AssemblyScript uses for its
    `importObject`; when you write your JavaScript, you must name your object inside
    the imported object accordingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已添加注释以澄清代码 1。这个模块导入了 `console_log` 2，并将其包装在对象 `as_hello` 中，这是我们 AssemblyScript
    文件的名称（不包括 *.ts* 扩展名）。这是 AssemblyScript 对 `importObject` 使用的命名约定；当你编写 JavaScript
    时，必须在导入的对象中相应地命名你的对象。
- en: AssemblyScript creates a `memory` 3 expression to hold the string data. The
    string has a prefixed header that includes the length of the string, which AssemblyScript
    uses to manipulate the data from within WebAssembly. The string `data` 4 uses
    two bytes per character, and because AssemblyScript uses UTF-16, every character
    in this example is separated by a null byte `\00`. UTF-16 is the 16-bit version
    of the Unicode character set that allows for many additional characters not available
    in ASCII.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 创建了一个 `memory` 3 表达式来存储字符串数据。字符串有一个前缀头部，包含了字符串的长度，AssemblyScript
    使用它来在 WebAssembly 内部操作数据。字符串 `data` 4 每个字符使用两个字节，因为 AssemblyScript 使用的是 UTF-16
    编码，在这个例子中，每个字符之间由一个空字节 `\00` 分隔。UTF-16 是 Unicode 字符集的 16 位版本，允许使用许多 ASCII 中不可用的附加字符。
- en: After the data expression, the WAT exports 5 the function with the name we gave
    it in the AssemblyScript, prefixed with the `$` character and excluding the *.ts*
    extension. The `HelloWorld` 6function calls `console_log` 8, passing in the location
    of the first character in our `hello world!` string in linear memory, which is
    `32` 7.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据表达式之后，WAT 导出了 5 个函数，函数的名称是我们在 AssemblyScript 中为其指定的，前面加上了 `$` 字符，并去掉了 *.ts*
    扩展名。`HelloWorld` 6 函数调用了 `console_log` 8，传入了我们 `hello world!` 字符串在线性内存中的第一个字符的位置，即
    `32` 7。
- en: With our WAT file compiled, we can use the `asc` command in [Listing 11-7](#listing11-7)
    to compile our WebAssembly module.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们编译好的 WAT 文件，我们可以在 [列表 11-7](#listing11-7) 中使用 `asc` 命令来编译我们的 WebAssembly
    模块。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 11-7: Compiling our AssemblyScript to WebAssembly binary'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-7：将我们的 AssemblyScript 编译为 WebAssembly 二进制文件。
- en: Next, we create our JavaScript.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写我们的 JavaScript。
- en: JavaScript for Our Hello World App
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的 Hello World 应用的 JavaScript
- en: Currently, we have a WebAssembly module named *as_hello.wasm*. Next, we’ll write
    a Node.js app that will load and run this module. In this section, we’ll decode
    the string data the way we did in Chapter 5 to understand how AssemblyScript transfers
    strings to JavaScript. Then we’ll use the AssemblyScript loader tool to do much
    of this work for us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，我们有一个名为 *as_hello.wasm* 的 WebAssembly 模块。接下来，我们将编写一个 Node.js 应用程序来加载并运行这个模块。在本节中，我们将像在第
    5 章中那样解码字符串数据，以了解 AssemblyScript 如何将字符串传输到 JavaScript。然后，我们将使用 AssemblyScript
    加载工具为我们完成这项工作。
- en: First, we’ll write a function to pull the string out of linear memory using
    the index passed from the WebAssembly module. AssemblyScript places the length
    of the string in the four bytes immediately preceding the string data. We can
    use `Uint32Array` to obtain the string length integer and use that length to create
    our string in JavaScript. Create a file named *as_hello.js* and add the code in
    [Listing 11-8](#listing11-8).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**as_hello.js**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: // module's file name without extension is used as the outer object name
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-8: Calling the AssemblyScript `HelloWorld` from JavaScript'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly modules that AssemblyScript generates always create and export their
    own memory unless they’re compiled with the `--importMemory` flag. By default,
    AssemblyScript creates its own linear memory in the WebAssembly module. Therefore,
    in the JavaScript, we don’t create a linear memory object. Instead, we create
    a `var` called `memory` 1, which we’ll later set to the linear memory object that
    the WebAssembly module exports.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `importObject`, the object that holds the data for import must have
    the same name as the AssemblyScript file importing it: `as_hello` 2 for our AssemblyScript
    file *as_hello.ts*. Inside `as_hello` is `console_log` 3, which is passed a string
    parameter when called from the AssemblyScript. When the WebAssembly module calls
    `as_hello`, the JavaScript function receives just a single numeric index into
    WebAssembly linear memory, which is the location of the string data portion of
    the length prefixed string that AssemblyScript uses to define its string type.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The length is a 32-bit integer in the four bytes that precede the `index`. To
    get the index of the length integer, we subtract four from the string index. We
    use the value for the length located in linear memory by creating a new `Uint32Array`,
    passing in the `memory.buffer`, the `len_index` 4, and a value of `4` for the
    number of bytes. Because `Uint32Array` 5 is an array of 32-bit integers, we need
    to get the first and only item in the array using `[0]`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve the string byte data from linear memory using `new Uint16Array`
    6 and convert that byte array into a JavaScript string by using a new `TextDecoder`
    that decodes for `utf-16` text data. The code calls the `TextDecoder` 7 `decode`
    function, passing in the string data, which returns a JavaScript string we then
    log to the console. We use an IIFE to instantiate the AssemblyScript WebAssembly
    module. Note that we must set the `memory` 8 object to the memory object exported
    from the WebAssembly module before calling the `HelloWorld` 9 function. The `console_log`
    function uses the `memory` object, and if it isn’t set, calling `HelloWorld` will
    do nothing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is an easier way to move string data between AssemblyScript
    and JavaScript, which is by using the AssemblyScript loader. This code is provided
    by the AssemblyScript team. In the “Performance of Loader vs. Direct WebAssembly
    Calls*”* section, we’ll see whether we can improve the performance of the AssemblyScript
    loader with code we’ve written.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更简单的方法可以在 AssemblyScript 和 JavaScript 之间传递字符串数据，那就是使用 AssemblyScript
    加载器。这个代码是由 AssemblyScript 团队提供的。在“加载器与直接 WebAssembly 调用的性能对比”*部分，我们将看到是否能通过我们编写的代码来提升
    AssemblyScript 加载器的性能。
- en: Hello World with the AssemblyScript Loader
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AssemblyScript 加载器的 Hello World
- en: The AssemblyScript loader is a set of helper functions from the AssemblyScript
    team designed to make it easier to make calls to AssemblyScript from JavaScript.
    We’ll compare the code we wrote earlier with code written using the AssemblyScript
    loader. Initially, we’ll consider ease of use and later look into the performance
    implications of using or not using the loader.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 加载器是一组来自 AssemblyScript 团队的助手函数，旨在简化从 JavaScript 调用 AssemblyScript
    的过程。我们将比较之前编写的代码与使用 AssemblyScript 加载器编写的代码。最初，我们将考虑易用性，之后再探讨使用或不使用加载器的性能影响。
- en: 'We use the AssemblyScript loader to send a string back to the JavaScript from
    the AssemblyScript. The loader helper function converts the index coming from
    WebAssembly into a JavaScript string. Now we will install the loader using `npm`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 AssemblyScript 加载器将一个字符串从 AssemblyScript 传回 JavaScript。加载器助手函数将来自 WebAssembly
    的索引转换为 JavaScript 字符串。现在，我们将使用 `npm` 安装加载器：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we’ll create a JavaScript file to load and run our WebAssembly module. Create
    a file named *as_hello_loader.js* and add the code in [Listing 11-9](#listing11-9).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 JavaScript 文件来加载和运行我们的 WebAssembly 模块。创建一个名为 *as_hello_loader.js*
    的文件，并添加 [Listing 11-9](#listing11-9) 中的代码。
- en: '**as_hello_loader.js**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_hello_loader.js**'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-9: Using the AssemblyScript loader to call the WebAssembly module'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-9: 使用 AssemblyScript 加载器调用 WebAssembly 模块'
- en: This JavaScript function first requires 1 the AssemblyScript loader. We use
    this loader object to load the `module` 2 object, which we declare globally. The
    `module` object is an AssemblyScript loader module that includes additional AssemblyScript
    loader helper functions. Inside the `importObject` is a child object with the
    `as_hello` 3 name of our AssemblyScript module. That is where the AssemblyScript
    code expects to locate the imported functions. Inside the `as_hello` object is
    `console_log` 4, which takes the string index `str_index` as its only parameter.
    This function uses the `__getString` 5 function on the `module` object created
    by the loader. When given the string index, the `__getString` function retrieves
    a JavaScript string from linear memory. This string is printed to the console
    with `console.log`. The IIFE function loads an AssemblyScript module using the
    AssemblyScript `loader` 6 object. Finally, the IIFE calls the `HelloWorld` 7 function.
    When you run this JavaScript file using `node`, you’ll see the output in [Listing
    11-10](#listing11-10).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JavaScript 函数首先需要 1 个 AssemblyScript 加载器。我们使用这个加载器对象来加载声明为全局的 `module` 2
    对象。`module` 对象是一个 AssemblyScript 加载器模块，其中包含额外的 AssemblyScript 加载器助手函数。在 `importObject`
    中是一个子对象，命名为 `as_hello` 3，代表我们的 AssemblyScript 模块。这里是 AssemblyScript 代码期望找到导入函数的位置。在
    `as_hello` 对象中有一个 `console_log` 4 函数，它将字符串索引 `str_index` 作为唯一参数。这个函数使用由加载器创建的
    `module` 对象上的 `__getString` 5 函数。当传入字符串索引时，`__getString` 函数从线性内存中检索一个 JavaScript
    字符串。这个字符串通过 `console.log` 打印到控制台。IIFE 函数使用 AssemblyScript `loader` 6 对象加载一个 AssemblyScript
    模块。最后，IIFE 调用 `HelloWorld` 7 函数。当你使用 `node` 运行这个 JavaScript 文件时，你会在 [Listing 11-10](#listing11-10)
    中看到输出。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-10: Output from the AssemblyScript hello world app'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-10: AssemblyScript hello world 应用的输出'
- en: Using the AssemblyScript loader makes the JavaScript code significantly simpler.
    Later, in the “Performance of Loader vs. Direct WebAssembly Calls” section, we’ll
    explore the performance implications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AssemblyScript 加载器使得 JavaScript 代码显著简化。稍后，在“加载器与直接 WebAssembly 调用的性能对比”部分，我们将探讨性能影响。
- en: AssemblyScript String Concatenation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AssemblyScript 字符串拼接
- en: Now that we know how to receive strings from AssemblyScript, we’ll send a string
    to an AssemblyScript module. This next function concatenates two strings separated
    by a pipe character (`|`). We’ll use the loader to make it easier to write the
    code on the JavaScript side. String concatenation is the kind of functionality
    that is challenging to implement directly in WAT but is very simple in AssemblyScript.
    Create a new file named *as_concat.ts* and add the code in [Listing 11-11](#listing11-11).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**as_concat.ts**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 11-11: Concatenating strings using AssemblyScript'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We export 1 `cat`, which takes two string parameters and returns a string. This
    function concatenates 2 the string with a pipe character (`|`) separating them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Now we can compile *as_concat.ts* using the `asc` command in [Listing 11-12](#listing11-12).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-12: Compiling the *as_concat.ts* file using `asc`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the `--exportRuntime` flag, which is necessary for passing strings
    into the WebAssembly module. Compiling with `--exportRuntime` adds code that allows
    you to call the `__allocString` function from JavaScript. If we fail to export
    the runtime, the following error occurs when the application executes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you compile *as_concat.ts* into WAT, notice that the WAT file is much larger
    than our *as_hello.ts* file. The reason is that the runtime adds several string
    functions that perform necessary tasks, such as copy memory, concatenate strings,
    and get/set string length methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write our JavaScript app. The code in [Listing 11-13](#listing11-13)
    creates two strings in linear memory and calls the WebAssembly function `cat`.
    Create a new JavaScript file named *as_concat.js* and add the code in [Listing
    11-13](#listing11-13).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**as_concat.js**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11-13: JavaScript uses the AssemblyScript loader to call the `cat`
    AssemblyScript function.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` function we defined in the WebAssembly module doesn’t take a string
    as a parameter directly, so it needs an index into linear memory for the string
    location. The `module.exports.__newString` loader helper function takes a JavaScript
    string, copies it into linear memory, and returns an index to pass into `module.cat`.
    We call `module.exports.__newString` twice, passing `"first string"` 1 and then
    passing `"second string"` 2. Each of these calls returns an index that we store
    in `first_str_index` and `second_str_index`. Next, we call `module.exports.cat`,
    passing in these indexes, from which we receive a JavaScript string index that
    we store in `cat_str_index` 3. Then we call `module.exports.__getString` 4, passing
    in `cat_str_index`, and storing that string in `cat_string` 5, which we log to
    the console.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our JavaScript and WebAssembly, we can run our application
    using `node`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here’s the output to your console:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is a lot more to AssemblyScript to explore. As you can see, it’s much
    simpler to write code that works with strings in AssemblyScript than it is in
    WAT. That doesn’t necessarily tell you when you should work with string data in
    WebAssembly, but it exposes it as an option. AssemblyScript, like WebAssembly
    more broadly, is a quickly developing project. Taking the time to learn more about
    it from the project home page at [assemblyscript.org](http://assemblyscript.org)
    is worth the time spent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript还有很多内容值得探索。如你所见，AssemblyScript在处理字符串时比WAT更加简单。虽然这并不能直接告诉你何时应该在WebAssembly中处理字符串数据，但它提供了这一选项。AssemblyScript，像WebAssembly一样，是一个快速发展的项目。花时间从项目主页[assemblyscript.org](http://assemblyscript.org)了解更多内容是值得的。
- en: Object Oriented Programming in AssemblyScript
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AssemblyScript中使用面向对象编程（OOP）
- en: OOP is almost impossible to use in WAT format, but because AssemblyScript is
    modeled on TypeScript, it offers significantly more options for OOP. In this section,
    we’ll cover some of the basics of OOP in AssemblyScript, as well as some of its
    limitations, which might no longer apply in future releases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在WAT格式中几乎不可能使用OOP，但由于AssemblyScript是基于TypeScript的，它提供了更多的OOP选项。在本节中，我们将介绍AssemblyScript中OOP的一些基础知识，以及一些它的限制，这些限制可能会在未来的版本中不再适用。
- en: Let’s begin by creating a new AssemblyScript file named *vector.ts*. Right now,
    AssemblyScript is piggybacking on top of TypeScript file formatting, which works
    in most cases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个名为*vector.ts*的AssemblyScript文件开始。目前，AssemblyScript是基于TypeScript文件格式的，这在大多数情况下都能正常工作。
- en: Saule Cabrera has created an AssemblyScript language server plug-in for VS Code,
    which is available at [https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.](https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Saule Cabrera为VS Code创建了一个AssemblyScript语言服务器插件，插件可通过[https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.](https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.)下载。
- en: Next, we’ll write an AssemblyScript `Vector2D` class to hold the coordinates
    of the collider objects that are similar to what we wrote for the collision detection
    app in Chapter 8. We’ll compile the code to WAT so we can explore the output of
    the AssemblyScript compiler. Gaining a better understanding of the compiler and
    its output can be extremely beneficial when optimizing WebAssembly code. Add [Listing
    11-14](#listing11-14) to your file to create the class `Vector2D`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个AssemblyScript的`Vector2D`类，用于存储类似于第8章碰撞检测应用程序中所写的碰撞器对象的坐标。我们将代码编译成WAT，以便查看AssemblyScript编译器的输出。更好地理解编译器及其输出，在优化WebAssembly代码时非常有帮助。将[清单11-14](#listing11-14)添加到你的文件中，以创建`Vector2D`类。
- en: '**vector.ts**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.ts**'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-14: Creating a vector class in AssemblyScript'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-14：在AssemblyScript中创建一个向量类
- en: We export a class called `Vector2D` 1 that has two attributes, `x` 2 and `y`
    3. It also has a `constructor` 4 that creates a new `Vector2D` object from the
    `x` and `y` parameters. The `Magnitude` 5 method calculates the magnitude of the
    vector by summing the squares of `x` and `y` and taking the square root of that
    sum.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出了一个名为`Vector2D`的类，它有两个属性，`x`和`y`。它还有一个`constructor`，用于从`x`和`y`参数创建一个新的`Vector2D`对象。`Magnitude`方法通过对`x`和`y`的平方求和并对该和取平方根来计算向量的大小。
- en: If you’re familiar with TypeScript, you’ll notice that this code looks just
    like the `class` structures in TypeScript. However, rather than using the TypeScript
    `number` type, we’re using `f32` types for 32-bit floating-point numbers. If you
    use the `number` type in your AssemblyScript, it’s the same as using an `f64`
    64-bit floating-point, which has the poorest performance of the WebAssembly types
    in most circumstances.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉TypeScript，你会注意到这段代码看起来与TypeScript中的`class`结构非常相似。然而，我们并没有使用TypeScript中的`number`类型，而是使用了`f32`类型来表示32位浮动点数。如果你在AssemblyScript中使用`number`类型，它实际上相当于使用`f64`类型的64位浮动点数，而在大多数情况下，`f64`的性能是WebAssembly类型中最差的。
- en: 'The following command compiles *vector.ts* into a WAT file using `asc`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用`asc`将*vector.ts*编译成WAT文件：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This creates a WAT file we can examine in VS Code. To `asc` we pass the name
    of the AssemblyScript file and then we pass the `-o`flag with the filename for
    the output file, `vector.wat`. The extension determines whether the output will
    be WAT or the WebAssembly binary file. Open *vector.wat* and scroll down a bit
    until you get to the exports shown in [Listing 11-15](#listing11-15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个我们可以在 VS Code 中查看的 WAT 文件。要进行 `asc` 编译，我们传递 AssemblyScript 文件的名称，然后传递
    `-o` 标志并指定输出文件的文件名 `vector.wat`。扩展名决定了输出是 WAT 文件还是 WebAssembly 二进制文件。打开 *vector.wat*
    文件并稍微向下滚动，直到看到在 [清单 11-15](#listing11-15) 中显示的导出内容。
- en: '**vector.wat**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.wat**'
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-15: The exported functions in our WAT file'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-15：我们 WAT 文件中导出的函数
- en: Notice how the compiler generated `get` 1 and `set` 2 accessor functions for
    the `x` 2 and `y` 3 attributes, and exported them so you can access them from
    the embedding environment. This indicates that when the user sets an object attribute
    using the loader, it calls a function in the WebAssembly module. One implication
    of this is that if you’re setting several attributes at once, you might want to
    consider creating a function to do this all at once for performance reasons. That
    way, you’re not making multiple function calls to the WebAssembly module. You
    can also see that the WebAssembly module exported the `constructor` 4 and `Magnitude`
    5 functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意编译器如何为 `x` 2 和 `y` 3 属性生成 `get` 1 和 `set` 2 访问函数，并将它们导出，以便你可以从嵌入环境访问它们。这表明，当用户通过加载器设置对象属性时，它会调用
    WebAssembly 模块中的一个函数。这意味着，如果你一次设置多个属性，可能需要考虑创建一个函数来一次性完成这一操作，以提高性能。这样，你就不需要多次调用
    WebAssembly 模块的函数。你还可以看到 WebAssembly 模块导出了 `constructor` 4 和 `Magnitude` 5 函数。
- en: The naming conventions are important to understand if you want to call functions
    in the WebAssembly module from JavaScript. The methods are all prefixed with the
    name of the class and a hash mark (`#`) character (`Vector2D#`). The `set` and
    `get` methods have a suffix that indicates which attribute they’re setting and
    getting, such as `:x` or `:y`. To access these functions and attributes from our
    JavaScript without using the AssemblyScript loader, we need to use this naming
    convention.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从 JavaScript 中调用 WebAssembly 模块的函数，命名约定是非常重要的。所有方法都以类名和哈希符号（`#`）作为前缀（`Vector2D#`）。`set`
    和 `get` 方法有一个后缀，表示它们设置或获取的属性，例如 `:x` 或 `:y`。要在不使用 AssemblyScript 加载器的情况下从 JavaScript
    访问这些函数和属性，我们需要遵循这种命名约定。
- en: Using Private Attributes
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用私有属性
- en: If you don’t want to export all the attributes to the embedding environment,
    you need to use the `private` keyword before the `x` and `y` attributes. Do that
    now in your AssemblyScript and recompile with the `asc` command. [Listing 11-16](#listing11-16)
    shows the new version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想将所有属性导出到嵌入环境中，需要在 `x` 和 `y` 属性前使用 `private` 关键字。现在在你的 AssemblyScript 中进行此操作，并使用
    `asc` 命令重新编译。[清单 11-16](#listing11-16) 显示了新版本。
- en: '**vector.ts**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.ts**'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-16: Creating private functions in AssemblyScript'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-16：在 AssemblyScript 中创建私有函数
- en: The `private` 1 modifier before `x` 1 and `y` 2 tells the AssemblyScript compiler
    that these attributes shouldn’t be publicly accessible. Recompile the WebAssembly
    module, which no longer exports the accessor methods that set and get the `x`
    and `y` variables to the embedding environment, as shown in [Listing 11-17](#listing11-17).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `x` 1 和 `y` 2 前面的 `private` 修饰符告诉 AssemblyScript 编译器，这些属性不应该对外部公开访问。重新编译 WebAssembly
    模块，该模块不再导出设置和获取 `x` 和 `y` 变量的访问方法到嵌入环境，如 [清单 11-17](#listing11-17) 所示。
- en: '**vector.wat**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.wat**'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-17: Exports in the WAT file'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-17：WAT 文件中的导出
- en: TypeScript has three modifiers, `public`, `private`, and `protected`, to define
    how attributes can be accessed. These modifiers behave a little differently in
    AssemblyScript than in other languages, such as TypeScript. In most languages,
    protected attributes are available to classes that extend the class but cannot
    be accessed outside the parent or child class. The `protected`method in AssemblyScript
    isn’t implemented fully and behaves the same as the `public` modifier. For now,
    you should avoid using it to prevent confusion. The keywords may eventually work
    as they do in TypeScript, but be aware that these limitations still exist in AssemblyScript
    version 0.17.7\.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The `private` modifier prevents AssemblyScript from exporting the `get` and
    `set` methods when it compiles the module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in other OOP languages, the `private` modifier in AssemblyScript doesn’t
    prevent classes that extend the original from accessing that attribute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following command to compile our AssemblyScript into a WebAssembly
    module so we can call it from our JavaScript:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we change the `-o` flag to *vector.wasm*, we tell the `asc` compiler to
    output a WebAssembly binary file. That will allow us to load and run the module
    from a JavaScript embedding environment. Next, let’s look at how to load and call
    WebAssembly functions using Node.js.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Embedding Environment
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use Node.js to load and execute the WebAssembly module. If we instead
    use a browser, the JavaScript would use `WebAssembly.instantiateStreaming` [PRE25]
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
