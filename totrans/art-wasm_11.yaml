- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AssemblyScript
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: AssemblyScript is a high-level language explicitly designed to compile to WebAssembly
    or WAT. AssemblyScript is more expressive than WAT but can compile to it. When
    you use AssemblyScript, you lose some of the fine optimization control that you
    have with WAT, but it’s much faster to write.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter by creating a simple `AddInt``s` function, like the
    `AddInt` one we created in Chapter 1. We’ll write an AssemblyScript hello world
    app and compile it into WAT to see the WebAssembly that the AssemblyScript compiler
    generates. We’ll examine AssemblyScript’s use of length-prefixed strings, and
    then install the AssemblyScript loader to see how it can make it easier to transfer
    strings between AssemblyScript and JavaScript. We’ll pass strings into AssemblyScript
    by writing a string concatenation app. We’ll also explore OOP in AssemblyScript.
    We’ll create a couple of classes to demonstrate class inheritance and discuss
    `private` attributes that prevent AssemblyScript from exporting attributes to
    the embedding environment. Next, we’ll write JavaScript that allows us to create
    `public`, `private`, and `protected`members directly, as well as use the AssemblyScript
    loader. Then we’ll compare the performance of direct and loader function calls.
  prefs: []
  type: TYPE_NORMAL
- en: The AssemblyScript team designed it to be similar to TypeScript and JavaScript.
    Unlike WAT, AssemblyScript is a high-level language with features such as classes,
    strings, and arrays. Along with high-level features, AssemblyScript allows users
    to code with low-level WAT-like memory commands. AssemblyScript has a *Command
    Line Interface (CLI)* that can compile AssemblyScript into a WebAssembly module
    for use from within JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: For JavaScript developers interested in using WebAssembly to improve the performance
    of their JavaScript applications, AssemblyScript is a great tool. Unfortunately,
    as with everything in WebAssembly, merely tweaking your TypeScript until it compiles
    with the AssemblyScript compiler might not result in a considerable performance
    boost. Understanding what AssemblyScript does under the hood allows you to write
    code in a language that looks like JavaScript but runs like C++. To gain this
    understanding, we’ll compile AssemblyScript code to WAT to explore the AssemblyScript
    compiler’s output.
  prefs: []
  type: TYPE_NORMAL
- en: AssemblyScript CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install AssemblyScript using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `npm` command installs AssemblyScript globally, which allows you to use
    the AssemblyScript compiler `asc` command from the command line. Running `asc
    -h` provides a list of compiler command examples and options.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t explain all the command line arguments but will mention a few that are
    useful. The `-O` option optimizes in the same way as `wasm-opt` in Chapter 9.
    You follow `-O` with a number 0 to 3, s, or z, instructing the compiler to optimize
    for size or performance and how much optimization to apply. The `-o` flag when
    followed by the name of a *.wat* file will generate WAT code from the AssemblyScript,
    and when followed by the name of a *.wasm* file will generate a binary WebAssembly
    module. The `--sourceMap` flag creates a source map file to help you debug your
    AssemblyScript from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first create a simple AssemblyScript module. Create the file *as_add.ts*
    and add the code in [Listing 11-1](#listing11-1). This is a much simpler version
    of the `AddInt` function in Chapter 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**as_add.ts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-1: Adding two integers'
  prefs: []
  type: TYPE_NORMAL
- en: We make the `function` available to the embedding JavaScript using the `export`
    1 keyword. It takes two `i32` parameters `a` 2 and `b` 3, and returns `a + b`
    4 as an `i32`. Compile *as_add.ts* using the command in [Listing 11-2](#listing11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-2: Compiling `AddInt``s` to WAT'
  prefs: []
  type: TYPE_NORMAL
- en: The `-Oz` flag makes the size of the output binary as small as possible. The
    final flag, `-o` `as_add.wat`, tells the compiler to output WAT. Alternatively,
    we could have compiled a *.wasm* file, such as *as_add.wasm*, which would output
    a WebAssembly binary. When we look at the *as_add.wat* file that is output, we
    see the WAT code in [Listing 11-3](#listing11-3).
  prefs: []
  type: TYPE_NORMAL
- en: '**as_add.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-3: AssemblyScript `AddInts` function compiled to WAT'
  prefs: []
  type: TYPE_NORMAL
- en: Writing code in AssemblyScript is much easier than writing code directly in
    WAT. This code produces the `AddInts` 1 function that exports a function 2 that
    takes two `i32` parameters and returns an `i32`. The output function uses a `local.get`
    to retrieve the first 3 and second 4 parameters, and uses an `i32.add`5 to add
    those two values.
  prefs: []
  type: TYPE_NORMAL
- en: AssemblyScript is a beautiful little language that is relatively easy to learn
    for anyone familiar with TypeScript or JavaScript. Understanding WAT is a great
    way to get the most from your AssemblyScript or whichever high-level language
    you choose for WebAssembly development.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World AssemblyScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll build an AssemblyScript version of the WAT hello world application
    from Chapter 2. Create a new AssemblyScript file named *as_hello.ts* and add the
    code in [Listing 11-4](#listing11-4).
  prefs: []
  type: TYPE_NORMAL
- en: '**as_hello.ts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-4: A hello world AssemblyScript app'
  prefs: []
  type: TYPE_NORMAL
- en: The function declaration in AssemblyScript must correspond with a JavaScript
    function passed into the WebAssembly module. So we’ll need to pass in a function
    through the `importObject` that logs our string to the console. The `declare`
    `function` 1 imports the `console_log` function from the JavaScript. This function
    will pass a string from the AssemblyScript back to the calling JavaScript app.
    We create an `export` `function` called `HelloWorld` 2 that calls the imported
    `console_log` 3 function, passing in the string `"hello world!"`. Before we compile
    this into a WebAssembly module, we’ll use `asc` to compile a WAT file so we can
    look at the WebAssembly created ([Listing 11-5](#listing11-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-5: Compile the *as_hello.ts* AssemblyScript file into *as_hello.wat*.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we can open *as_hello.wat* in [Listing 11-6](#listing11-6) to see the WebAssembly
    that AssemblyScript generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-6: The *as_hello.wat* file generated from the *as_hello.ts* AssemblyScript'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve added comments to clarify the code 1. This module imports `console_log`
    2 wrapped in the object `as_hello`, the name of our AssemblyScript file without
    the *.ts* extension. This is the naming convention AssemblyScript uses for its
    `importObject`; when you write your JavaScript, you must name your object inside
    the imported object accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: AssemblyScript creates a `memory` 3 expression to hold the string data. The
    string has a prefixed header that includes the length of the string, which AssemblyScript
    uses to manipulate the data from within WebAssembly. The string `data` 4 uses
    two bytes per character, and because AssemblyScript uses UTF-16, every character
    in this example is separated by a null byte `\00`. UTF-16 is the 16-bit version
    of the Unicode character set that allows for many additional characters not available
    in ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: After the data expression, the WAT exports 5 the function with the name we gave
    it in the AssemblyScript, prefixed with the `$` character and excluding the *.ts*
    extension. The `HelloWorld` 6function calls `console_log` 8, passing in the location
    of the first character in our `hello world!` string in linear memory, which is
    `32` 7.
  prefs: []
  type: TYPE_NORMAL
- en: With our WAT file compiled, we can use the `asc` command in [Listing 11-7](#listing11-7)
    to compile our WebAssembly module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-7: Compiling our AssemblyScript to WebAssembly binary'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript for Our Hello World App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, we have a WebAssembly module named *as_hello.wasm*. Next, we’ll write
    a Node.js app that will load and run this module. In this section, we’ll decode
    the string data the way we did in Chapter 5 to understand how AssemblyScript transfers
    strings to JavaScript. Then we’ll use the AssemblyScript loader tool to do much
    of this work for us.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll write a function to pull the string out of linear memory using
    the index passed from the WebAssembly module. AssemblyScript places the length
    of the string in the four bytes immediately preceding the string data. We can
    use `Uint32Array` to obtain the string length integer and use that length to create
    our string in JavaScript. Create a file named *as_hello.js* and add the code in
    [Listing 11-8](#listing11-8).
  prefs: []
  type: TYPE_NORMAL
- en: '**as_hello.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: // module's file name without extension is used as the outer object name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-8: Calling the AssemblyScript `HelloWorld` from JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly modules that AssemblyScript generates always create and export their
    own memory unless they’re compiled with the `--importMemory` flag. By default,
    AssemblyScript creates its own linear memory in the WebAssembly module. Therefore,
    in the JavaScript, we don’t create a linear memory object. Instead, we create
    a `var` called `memory` 1, which we’ll later set to the linear memory object that
    the WebAssembly module exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `importObject`, the object that holds the data for import must have
    the same name as the AssemblyScript file importing it: `as_hello` 2 for our AssemblyScript
    file *as_hello.ts*. Inside `as_hello` is `console_log` 3, which is passed a string
    parameter when called from the AssemblyScript. When the WebAssembly module calls
    `as_hello`, the JavaScript function receives just a single numeric index into
    WebAssembly linear memory, which is the location of the string data portion of
    the length prefixed string that AssemblyScript uses to define its string type.'
  prefs: []
  type: TYPE_NORMAL
- en: The length is a 32-bit integer in the four bytes that precede the `index`. To
    get the index of the length integer, we subtract four from the string index. We
    use the value for the length located in linear memory by creating a new `Uint32Array`,
    passing in the `memory.buffer`, the `len_index` 4, and a value of `4` for the
    number of bytes. Because `Uint32Array` 5 is an array of 32-bit integers, we need
    to get the first and only item in the array using `[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve the string byte data from linear memory using `new Uint16Array`
    6 and convert that byte array into a JavaScript string by using a new `TextDecoder`
    that decodes for `utf-16` text data. The code calls the `TextDecoder` 7 `decode`
    function, passing in the string data, which returns a JavaScript string we then
    log to the console. We use an IIFE to instantiate the AssemblyScript WebAssembly
    module. Note that we must set the `memory` 8 object to the memory object exported
    from the WebAssembly module before calling the `HelloWorld` 9 function. The `console_log`
    function uses the `memory` object, and if it isn’t set, calling `HelloWorld` will
    do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is an easier way to move string data between AssemblyScript
    and JavaScript, which is by using the AssemblyScript loader. This code is provided
    by the AssemblyScript team. In the “Performance of Loader vs. Direct WebAssembly
    Calls*”* section, we’ll see whether we can improve the performance of the AssemblyScript
    loader with code we’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World with the AssemblyScript Loader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The AssemblyScript loader is a set of helper functions from the AssemblyScript
    team designed to make it easier to make calls to AssemblyScript from JavaScript.
    We’ll compare the code we wrote earlier with code written using the AssemblyScript
    loader. Initially, we’ll consider ease of use and later look into the performance
    implications of using or not using the loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the AssemblyScript loader to send a string back to the JavaScript from
    the AssemblyScript. The loader helper function converts the index coming from
    WebAssembly into a JavaScript string. Now we will install the loader using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll create a JavaScript file to load and run our WebAssembly module. Create
    a file named *as_hello_loader.js* and add the code in [Listing 11-9](#listing11-9).
  prefs: []
  type: TYPE_NORMAL
- en: '**as_hello_loader.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-9: Using the AssemblyScript loader to call the WebAssembly module'
  prefs: []
  type: TYPE_NORMAL
- en: This JavaScript function first requires 1 the AssemblyScript loader. We use
    this loader object to load the `module` 2 object, which we declare globally. The
    `module` object is an AssemblyScript loader module that includes additional AssemblyScript
    loader helper functions. Inside the `importObject` is a child object with the
    `as_hello` 3 name of our AssemblyScript module. That is where the AssemblyScript
    code expects to locate the imported functions. Inside the `as_hello` object is
    `console_log` 4, which takes the string index `str_index` as its only parameter.
    This function uses the `__getString` 5 function on the `module` object created
    by the loader. When given the string index, the `__getString` function retrieves
    a JavaScript string from linear memory. This string is printed to the console
    with `console.log`. The IIFE function loads an AssemblyScript module using the
    AssemblyScript `loader` 6 object. Finally, the IIFE calls the `HelloWorld` 7 function.
    When you run this JavaScript file using `node`, you’ll see the output in [Listing
    11-10](#listing11-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-10: Output from the AssemblyScript hello world app'
  prefs: []
  type: TYPE_NORMAL
- en: Using the AssemblyScript loader makes the JavaScript code significantly simpler.
    Later, in the “Performance of Loader vs. Direct WebAssembly Calls” section, we’ll
    explore the performance implications.
  prefs: []
  type: TYPE_NORMAL
- en: AssemblyScript String Concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how to receive strings from AssemblyScript, we’ll send a string
    to an AssemblyScript module. This next function concatenates two strings separated
    by a pipe character (`|`). We’ll use the loader to make it easier to write the
    code on the JavaScript side. String concatenation is the kind of functionality
    that is challenging to implement directly in WAT but is very simple in AssemblyScript.
    Create a new file named *as_concat.ts* and add the code in [Listing 11-11](#listing11-11).
  prefs: []
  type: TYPE_NORMAL
- en: '**as_concat.ts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-11: Concatenating strings using AssemblyScript'
  prefs: []
  type: TYPE_NORMAL
- en: We export 1 `cat`, which takes two string parameters and returns a string. This
    function concatenates 2 the string with a pipe character (`|`) separating them.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can compile *as_concat.ts* using the `asc` command in [Listing 11-12](#listing11-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-12: Compiling the *as_concat.ts* file using `asc`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass the `--exportRuntime` flag, which is necessary for passing strings
    into the WebAssembly module. Compiling with `--exportRuntime` adds code that allows
    you to call the `__allocString` function from JavaScript. If we fail to export
    the runtime, the following error occurs when the application executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When you compile *as_concat.ts* into WAT, notice that the WAT file is much larger
    than our *as_hello.ts* file. The reason is that the runtime adds several string
    functions that perform necessary tasks, such as copy memory, concatenate strings,
    and get/set string length methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write our JavaScript app. The code in [Listing 11-13](#listing11-13)
    creates two strings in linear memory and calls the WebAssembly function `cat`.
    Create a new JavaScript file named *as_concat.js* and add the code in [Listing
    11-13](#listing11-13).
  prefs: []
  type: TYPE_NORMAL
- en: '**as_concat.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-13: JavaScript uses the AssemblyScript loader to call the `cat`
    AssemblyScript function.'
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` function we defined in the WebAssembly module doesn’t take a string
    as a parameter directly, so it needs an index into linear memory for the string
    location. The `module.exports.__newString` loader helper function takes a JavaScript
    string, copies it into linear memory, and returns an index to pass into `module.cat`.
    We call `module.exports.__newString` twice, passing `"first string"` 1 and then
    passing `"second string"` 2. Each of these calls returns an index that we store
    in `first_str_index` and `second_str_index`. Next, we call `module.exports.cat`,
    passing in these indexes, from which we receive a JavaScript string index that
    we store in `cat_str_index` 3. Then we call `module.exports.__getString` 4, passing
    in `cat_str_index`, and storing that string in `cat_string` 5, which we log to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our JavaScript and WebAssembly, we can run our application
    using `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output to your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot more to AssemblyScript to explore. As you can see, it’s much
    simpler to write code that works with strings in AssemblyScript than it is in
    WAT. That doesn’t necessarily tell you when you should work with string data in
    WebAssembly, but it exposes it as an option. AssemblyScript, like WebAssembly
    more broadly, is a quickly developing project. Taking the time to learn more about
    it from the project home page at [assemblyscript.org](http://assemblyscript.org)
    is worth the time spent.
  prefs: []
  type: TYPE_NORMAL
- en: Object Oriented Programming in AssemblyScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OOP is almost impossible to use in WAT format, but because AssemblyScript is
    modeled on TypeScript, it offers significantly more options for OOP. In this section,
    we’ll cover some of the basics of OOP in AssemblyScript, as well as some of its
    limitations, which might no longer apply in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by creating a new AssemblyScript file named *vector.ts*. Right now,
    AssemblyScript is piggybacking on top of TypeScript file formatting, which works
    in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Saule Cabrera has created an AssemblyScript language server plug-in for VS Code,
    which is available at [https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.](https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write an AssemblyScript `Vector2D` class to hold the coordinates
    of the collider objects that are similar to what we wrote for the collision detection
    app in Chapter 8. We’ll compile the code to WAT so we can explore the output of
    the AssemblyScript compiler. Gaining a better understanding of the compiler and
    its output can be extremely beneficial when optimizing WebAssembly code. Add [Listing
    11-14](#listing11-14) to your file to create the class `Vector2D`.
  prefs: []
  type: TYPE_NORMAL
- en: '**vector.ts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-14: Creating a vector class in AssemblyScript'
  prefs: []
  type: TYPE_NORMAL
- en: We export a class called `Vector2D` 1 that has two attributes, `x` 2 and `y`
    3. It also has a `constructor` 4 that creates a new `Vector2D` object from the
    `x` and `y` parameters. The `Magnitude` 5 method calculates the magnitude of the
    vector by summing the squares of `x` and `y` and taking the square root of that
    sum.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with TypeScript, you’ll notice that this code looks just
    like the `class` structures in TypeScript. However, rather than using the TypeScript
    `number` type, we’re using `f32` types for 32-bit floating-point numbers. If you
    use the `number` type in your AssemblyScript, it’s the same as using an `f64`
    64-bit floating-point, which has the poorest performance of the WebAssembly types
    in most circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command compiles *vector.ts* into a WAT file using `asc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This creates a WAT file we can examine in VS Code. To `asc` we pass the name
    of the AssemblyScript file and then we pass the `-o`flag with the filename for
    the output file, `vector.wat`. The extension determines whether the output will
    be WAT or the WebAssembly binary file. Open *vector.wat* and scroll down a bit
    until you get to the exports shown in [Listing 11-15](#listing11-15).
  prefs: []
  type: TYPE_NORMAL
- en: '**vector.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-15: The exported functions in our WAT file'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the compiler generated `get` 1 and `set` 2 accessor functions for
    the `x` 2 and `y` 3 attributes, and exported them so you can access them from
    the embedding environment. This indicates that when the user sets an object attribute
    using the loader, it calls a function in the WebAssembly module. One implication
    of this is that if you’re setting several attributes at once, you might want to
    consider creating a function to do this all at once for performance reasons. That
    way, you’re not making multiple function calls to the WebAssembly module. You
    can also see that the WebAssembly module exported the `constructor` 4 and `Magnitude`
    5 functions.
  prefs: []
  type: TYPE_NORMAL
- en: The naming conventions are important to understand if you want to call functions
    in the WebAssembly module from JavaScript. The methods are all prefixed with the
    name of the class and a hash mark (`#`) character (`Vector2D#`). The `set` and
    `get` methods have a suffix that indicates which attribute they’re setting and
    getting, such as `:x` or `:y`. To access these functions and attributes from our
    JavaScript without using the AssemblyScript loader, we need to use this naming
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: Using Private Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don’t want to export all the attributes to the embedding environment,
    you need to use the `private` keyword before the `x` and `y` attributes. Do that
    now in your AssemblyScript and recompile with the `asc` command. [Listing 11-16](#listing11-16)
    shows the new version.
  prefs: []
  type: TYPE_NORMAL
- en: '**vector.ts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-16: Creating private functions in AssemblyScript'
  prefs: []
  type: TYPE_NORMAL
- en: The `private` 1 modifier before `x` 1 and `y` 2 tells the AssemblyScript compiler
    that these attributes shouldn’t be publicly accessible. Recompile the WebAssembly
    module, which no longer exports the accessor methods that set and get the `x`
    and `y` variables to the embedding environment, as shown in [Listing 11-17](#listing11-17).
  prefs: []
  type: TYPE_NORMAL
- en: '**vector.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 11-17: Exports in the WAT file'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript has three modifiers, `public`, `private`, and `protected`, to define
    how attributes can be accessed. These modifiers behave a little differently in
    AssemblyScript than in other languages, such as TypeScript. In most languages,
    protected attributes are available to classes that extend the class but cannot
    be accessed outside the parent or child class. The `protected`method in AssemblyScript
    isn’t implemented fully and behaves the same as the `public` modifier. For now,
    you should avoid using it to prevent confusion. The keywords may eventually work
    as they do in TypeScript, but be aware that these limitations still exist in AssemblyScript
    version 0.17.7\.
  prefs: []
  type: TYPE_NORMAL
- en: The `private` modifier prevents AssemblyScript from exporting the `get` and
    `set` methods when it compiles the module.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in other OOP languages, the `private` modifier in AssemblyScript doesn’t
    prevent classes that extend the original from accessing that attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following command to compile our AssemblyScript into a WebAssembly
    module so we can call it from our JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When we change the `-o` flag to *vector.wasm*, we tell the `asc` compiler to
    output a WebAssembly binary file. That will allow us to load and run the module
    from a JavaScript embedding environment. Next, let’s look at how to load and call
    WebAssembly functions using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Embedding Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use Node.js to load and execute the WebAssembly module. If we instead
    use a browser, the JavaScript would use `WebAssembly.instantiateStreaming` [PRE25]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
