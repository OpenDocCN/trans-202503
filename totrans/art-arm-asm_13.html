<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_605" aria-label="605"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch10">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">10</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">TABLE LOOKUPS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">In the early days of assembly language programming, replacing expensive computations with table lookups was a common way to improve program performance. Today, memory speeds in modern systems limit the performance gains that can be obtained by using table lookups. However, for very complex calculations, this is still a viable technique for writing high-performance code.</p>&#13;
<p class="TX">This chapter discusses how to use table lookups to speed up or reduce the complexity of computations, demonstrating the space and speed trade-offs involved.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-111"/><span class="SANS_Futura_Std_Bold_B_11">10.1 Using Tables in Assembly Language</span></h3>&#13;
<p class="TNI1">To an assembly language programmer, a <i>table</i> is an array containing initialized values that do not change after they’re created. In assembly language, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_606" aria-label="606"/>you can use tables for a variety of purposes: computing functions, controlling program flow, or simply looking up data. In general, tables provide a fast mechanism for performing an operation, at the expense of space in your program (the extra space holds the tabular data).</p>&#13;
<p class="TX">In this section, we’ll explore some of the many possible uses of tables in an assembly language program. Keep in mind that because tables typically contain initialized data that does not change during program execution, the <span class="SANS_TheSansMonoCd_W5Regular_11">.section .rodata, ""</span> section is a good place to put your table objects.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-180"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">10.1.1 Function Computation via Table Lookup</span></h4>&#13;
<p class="TNI1">A simple-looking HLL arithmetic expression can be equivalent to a considerable amount of ARM assembly language code and may therefore be expensive to compute. Assembly language programmers often precompute many values and use a table lookup of those values to speed up their programs, which is easier and often more efficient.</p>&#13;
<p class="TX">Consider the following Pascal statement:</p>&#13;
<pre id="pre-780"><code>if (character &gt;= 'a') and (character &lt;= 'z') then&#13;
    character := chr(ord(character) - 32);</code></pre>&#13;
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement converts the character variable’s value from lowercase to uppercase if the character is in the range <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">z</span>. Comparable assembly code requires a total of seven machine instructions, as follows:</p>&#13;
<pre id="pre-781"><code>    mov  w1, #'z'&#13;
    ldrb w0, [fp, #character]  // Assume "character" is local.&#13;
    cmp  w0, #'a'&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> ccmp w0, w1, #0b0010, hs&#13;
    bhi  notLower&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> eor  w0, w0, #0x20&#13;
notLower:&#13;
    strb w0, [fp, #character]</code></pre>&#13;
<p class="TX">The NZCV constant 0b0010 sets the carry flag and clears the 0 so that the branch will be taken if W0 is less than <span class="SANS_TheSansMonoCd_W5Regular_11">'a'</span> (if W0 is less than <span class="SANS_TheSansMonoCd_W5Regular_11">'a'</span>, the carry is set and the zero flag is clear, which is “higher or same” without the same component, so just higher) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Note that the conditional compare instruction allows only 5-bit immediate constants; this is why the code loads the character constant <span class="SANS_TheSansMonoCd_W5Regular_11">'z'</span> into W1 and conditionally compares against W1.</p>&#13;
<p class="TX">The usual method for converting lowercase to uppercase is to clear bit 5 of the ASCII character code. However, <span class="SANS_TheSansMonoCd_W5Regular_11">and w0, w0, #0x5F</span> is not a legal instruction because 0x5F is not a legal logical constant. This code uses the <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> (exclusive-OR) instruction to invert bit 5 <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Because this bit is guaranteed to be set at this point (bit 5 is set for all lowercase characters), the <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instruction will clear this bit.</p>&#13;
<p class="TX">The lookup table solution uses only four instructions:</p>&#13;
<pre id="pre-782"><code>lea  x1, xlatTbl&#13;
ldrb w0, [fp, #character]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_607" aria-label="607"/>ldrb w0, [x1, w0, uxt2 #0]&#13;
strb w0, [fp, #character]</code></pre>&#13;
<p class="TX">The conversion logic is completely buried in the lookup table (<span class="SANS_TheSansMonoCd_W5Regular_11">xlatTbl</span>). This is a 256-byte array; each index contains the index value (element 0 contains the value 0, element 1 contains the value 1, and so on) except for the indices corresponding to the ASCII codes for the lowercase characters (indices 97 through 122). Those particular array elements contain the ASCII codes for the uppercase characters (values 65 through 90).</p>&#13;
<p class="TX">Note that if you can guarantee that you’ll load only 7-bit ASCII characters into this code, you can get by with a 128-byte (rather than a 256-byte) array.</p>&#13;
<p class="TX">Here’s a typical (128-byte) lookup table that converts lowercase characters to uppercase:</p>&#13;
<pre id="pre-783"><code>xlatTbl:    .byte       0,1,2,3,4,5,6,7&#13;
            .byte       8,9,10,11,12,13,14,15&#13;
            .byte       16,17,18,19,20,21,22,23&#13;
            .byte       24,25,26,27,28,29,30,31&#13;
            .byte       32,33,34,35,36,37,38,39&#13;
            .byte       40,41,42,43,44,45,46,47&#13;
            .byte       48,49,50,51,52,53,54,55&#13;
            .byte       56,57,58,59,60,61,62,63&#13;
            .byte       64&#13;
            .ascii      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"&#13;
            .byte       91,92,93,94,95,96&#13;
            .ascii      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"&#13;
            .byte       123,124,125,126,127</code></pre>&#13;
<p class="Continued1">If you want a full 256-byte table, elements 128 through 255 would contain the values 128 through 255.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldrb w0, [x1, w0, uxtw #0]</span> instruction loads W0 with the byte at the index specified by the (original) value held in W0, assuming X1 holds the address of <span class="SANS_TheSansMonoCd_W5Regular_11">xlatTbl</span>. If W0 holds a non-lowercase character code, that index into the table will load the same value into W0 (so this instruction does not change W0’s value if it is not a lowercase letter). If W0 contains a lowercase letter, the index into this table fetches the ASCII code of the corresponding uppercase character.</p>&#13;
<p class="TX">Listing 10-1 demonstrates these two forms of case conversion: <span class="SANS_TheSansMonoCd_W5Regular_11">if...eor</span> and table lookup.</p>&#13;
<pre id="pre-784"><code>// Listing10-1.S&#13;
//&#13;
// Lowercase-to-uppercase conversion&#13;
&#13;
            #include    "aoaa.inc"&#13;
&#13;
            .section    .rodata, ""&#13;
&#13;
ttlStr:     .asciz      "Listing 10-1"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_608" aria-label="608"/>textStr:    .ascii      "abcdefghijklmnopqrstuvwxyz\n"&#13;
            .ascii      "ABCDEFGHIJKLMNOPQRSTUVWXYZ\n"&#13;
            .asciz      "0123456789\n"&#13;
&#13;
// Translation table to convert lowercase to uppercase:&#13;
&#13;
xlatTbl:    .byte       0, 1, 2, 3, 4, 5, 6, 7&#13;
            .byte       8, 9, 10, 11, 12, 13, 14, 15&#13;
            .byte       16, 17, 18, 19, 20, 21, 22, 23&#13;
            .byte       24, 25, 26, 27, 28, 29, 30, 31&#13;
            .byte       32, 33, 34, 35, 36, 37, 38, 39&#13;
            .byte       40, 41, 42, 43, 44, 45, 46, 47&#13;
            .byte       48, 49, 50, 51, 52, 53, 54, 55&#13;
            .byte       56, 57, 58, 59, 60, 61, 62, 63&#13;
            .byte       64&#13;
            .ascii      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"&#13;
            .byte       91, 92, 93, 94, 95, 96&#13;
            .ascii      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"&#13;
            .byte       123, 124, 125, 126, 127&#13;
&#13;
// Various printf format strings this program uses:&#13;
&#13;
fmtStr1:    .asciz      "Standard conversion:\n"&#13;
fmtStr2:    .asciz      "\nConversion via lookup table:\n"&#13;
fmtStr:     .asciz      "%c"&#13;
&#13;
            .code&#13;
            .extern     printf&#13;
&#13;
&#13;
////////////////////////////////////////////////////////////////////&#13;
//&#13;
// Return program title to C++ program:&#13;
&#13;
            proc        getTitle, public&#13;
            lea         x0, ttlStr&#13;
            ret&#13;
            endp        getTitle&#13;
&#13;
////////////////////////////////////////////////////////////////////&#13;
//&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            dword   am.x20&#13;
            dword   am.x21&#13;
            byte    am.shadow, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
            str     x20, [fp, #am.x20]&#13;
            str     x21, [fp, #am.x21]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_609" aria-label="609"/>// Print first title string:&#13;
&#13;
            lea     x0, fmtStr1&#13;
            bl      printf&#13;
&#13;
// Convert textStr to uppercase using&#13;
// standard "if and EOR" operation:&#13;
&#13;
            lea     x20, textStr    // String to convert&#13;
            mov     x21, #'z'       // CCMP doesn't like #'z'.&#13;
            b.al    testNot0&#13;
&#13;
// Check to see if W1 is in the range 'a'..'z'. If so,&#13;
// invert bit 5 to convert it to uppercase:&#13;
&#13;
stdLoop:    cmp     w1, #'a'&#13;
            ccmp    w1, w21, #0b0010, hs&#13;
            bhi     notLower&#13;
            eor     w1, w1, #0x20&#13;
notLower:&#13;
&#13;
// Print the converted character:&#13;
&#13;
            lea     x0, fmtStr&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
// Fetch the next character from the string:&#13;
&#13;
testNot0:   ldrb    w1, [x20], #1&#13;
            cmp     w1, #0&#13;
            bne     stdLoop&#13;
&#13;
// Convert textStr to uppercase by using&#13;
// a lookup table. Begin by printing&#13;
// an explanatory string before the&#13;
// output:&#13;
&#13;
            lea x0, fmtStr2&#13;
            bl      printf&#13;
&#13;
// textStr is the string to convert.&#13;
// xlatTbl is the lookup table that will convert&#13;
// lowercase characters to uppercase:&#13;
&#13;
            lea     x20, textStr&#13;
            lea     x21, xlatTbl&#13;
            b.al    testNot0a&#13;
&#13;
// Convert the character from lowercase to&#13;
// uppercase via a lookup table:&#13;
&#13;
xlatLoop:   ldrb    w1, [x21, w1, uxtw #0]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_610" aria-label="610"/>// Print the character:&#13;
&#13;
            lea     x0, fmtStr&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
// Fetch the next character from the string:&#13;
&#13;
testNot0a:  ldrb    w1, [x20], #1&#13;
            cmp     w1, #0&#13;
            bne     xlatLoop&#13;
&#13;
&#13;
allDone:    ldr     x20, [fp, #am.x20]&#13;
            ldr     x21, [fp, #am.x21]&#13;
            leave   // Returns to caller&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 10-1:</p>&#13;
<pre id="pre-785"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing10-1</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing10-1</span>&#13;
Calling Listing10-1:&#13;
Standard conversion:&#13;
ABCDEFGHIJKLMNOPQRSTUVWXYZ&#13;
ABCDEFGHIJKLMNOPQRSTUVWXYZ&#13;
0123456789&#13;
&#13;
Conversion via lookup table:&#13;
ABCDEFGHIJKLMNOPQRSTUVWXYZ&#13;
ABCDEFGHIJKLMNOPQRSTUVWXYZ&#13;
0123456789&#13;
Listing10-1 terminated</code></pre>&#13;
<p class="TX">I didn’t attempt to time the two versions, because the call to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> dominates the execution time of the two algorithms. However, because the table-lookup algorithm accesses memory on each character (to fetch a byte from the lookup table), the process is no shorter even though it uses fewer instructions. The lookup table adds 128 bytes (or 256 bytes) to the size of the program’s code.</p>&#13;
<p class="TX">Using a lookup table for a simple computation such as lowercase-to-uppercase conversion carries little benefit. But as the complexity of the computation increases, the table lookup algorithm could become faster. Consider the following code that swaps cases (converts lowercase to uppercase and uppercase to lowercase):</p>&#13;
<pre id="pre-786"><code>// If it's lowercase, convert it to uppercase:&#13;
&#13;
    mov  w1, #'z'&#13;
    ldrb w0, [fp, #character]  // Assume "character" is local.&#13;
    cmp  w0, #'a'&#13;
    ccmp w0, w1, #0b0010, hs&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_611" aria-label="611"/>    bhi  notLower&#13;
    eor  w0, w0, #0x20&#13;
    b.al allDone&#13;
&#13;
// If it's uppercase, convert it to lowercase:&#13;
&#13;
notLower:&#13;
    mov  w1, #'Z'&#13;
    cmp  w0, #'A'&#13;
    ccmp w0, w1, #0b0010, hs&#13;
    bhi  allDone&#13;
    eor  w0, w0, #0x20&#13;
&#13;
allDone:&#13;
    strb w0, [fp, #character]</code></pre>&#13;
<p class="TX">The lookup-table version is almost identical to Listing 10-1. Only the values in the lookup table change:</p>&#13;
<pre id="pre-787"><code>    lea  x1, xlatTbl2&#13;
    ldrb w0, [fp, #character]&#13;
    ldrb w0, [x1, w0, uxtw #0]&#13;
    strb w0, [fp, #character]</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">xlatTbl2</span> array will contain the lowercase ASCII codes at the indices corresponding to the uppercase characters, in addition to having the uppercase ASCII codes at the indices corresponding to the lowercase ASCII codes.</p>&#13;
<p class="TX">This case-conversion algorithm still might not be complex enough to justify using a lookup table to improve performance. However, it demonstrates that as the complexity of the algorithm increases (taking longer to execute without a lookup table), the lookup table algorithm’s execution time remains constant.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-181"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">10.1.2 Function Domains and Ranges</span></h4>&#13;
<p class="TNI1">Functions computed via table lookup have a limited <i>domain</i>, the set of possible input values they accept. This is because each element in the domain of a function requires an entry in the lookup table. For example, the previous uppercase/lowercase conversion functions have the 256-character extended ASCII character set as their domain. A function such as <span class="SANS_TheSansMonoCd_W5Regular_11">sin()</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">cos()</span> accepts the (infinite) set of real numbers as possible input values. You won’t find it very practical to implement a function via table lookup whose domain is the set of real numbers, because you must limit the domain to a small set.</p>&#13;
<p class="TX">Most lookup tables are quite small, usually 10 to 256 entries. Rarely do they grow beyond 1,000 entries. Most programmers don’t have the patience to create and verify the correctness of a 1,000-entry table (but see section 10.1.4, <span class="Xref">“Table Generation,”</span> on <span class="Xref"><a href="chapter10.xhtml#pg_615">page 615</a></span> for a discussion of generating tables programmatically).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_612" aria-label="612"/>Another limitation of functions based on lookup tables is that the elements in the domain must be fairly contiguous. Table lookups use the input value to a function as an index into the table and return the value at that entry in the table. A function that accepts values 0, 100, 1,000, and 10,000 would require 10,001 elements in the lookup table because of the range of input values. You cannot, therefore, efficiently create such a function via a table lookup. This section on tables assumes throughout that the domain of the function is a fairly contiguous set of values.</p>&#13;
<p class="TX">The <i>range</i> of a function is the set of possible output values it produces. From the perspective of a table lookup, a function’s range determines the size of each table entry. For example, if a function’s range is the integer values 0 through 255, each table entry requires a single byte; if the range is 0 through 65,535, each table entry requires 2 bytes, and so on.</p>&#13;
<p class="TX">The best functions you can implement via table lookups are those whose domain and range are always 0 to 255 (or a subset of this range). Any such function can be computed using the same two instructions:</p>&#13;
<pre id="pre-788"><code>lea x1, table&#13;
ldrb w0, [x1, w0, uxtw #0]</code></pre>&#13;
<p class="Continued1">The only thing that changes is the lookup table. The uppercase/lowercase conversion routines presented earlier are good examples of such functions.</p>&#13;
<p class="TX">Lookup tables become slightly less efficient if the domain or range is not 0 to 255. If the domain of a function is outside 0 to 255 but the range of the function falls within this set of values, your lookup table will require more than 256 entries, but you can represent each entry with a single byte. Therefore, the lookup table can be an array of bytes. The C/C++ function invocation</p>&#13;
<pre id="pre-789"><code>B = Func(X);</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_11">Func</span> is</p>&#13;
<pre id="pre-790"><code>byte Func(word <var>parm)</var> {...}</code></pre>&#13;
<p class="Continued1">which is easily converted to the following ARM code:</p>&#13;
<pre id="pre-791"><code>lea  x1, FuncTbl&#13;
ldr  w0, X       // Using appropriate addressing mode&#13;
ldrb w0, [x1, w0, uxtw #0]&#13;
strb w0, B       // Using appropriate addressing mode</code></pre>&#13;
<p class="TX">This code loads the function parameter into W0, uses this value (in the range 0 to <i>maxParmValue</i>) as an index into the <span class="SANS_TheSansMonoCd_W5Regular_11">FuncTbl</span> table, fetches the byte at that location, and stores the result into <span class="SANS_TheSansMonoCd_W5Regular_11">B</span>. Obviously, the table must contain a valid entry for each possible value of <span class="SANS_TheSansMonoCd_W5Regular_11">X</span> (up to <i>maxParmValue</i>). For example, suppose you want to map a cursor position on an 80 × 25 text-based video display in the range 0 to 1,999 (an 80 × 25 video display has 2,000 character positions) to its <span class="SANS_TheSansMonoCd_W5Regular_11">X</span> (0 to 79) or <span class="SANS_TheSansMonoCd_W5Regular_11">Y</span> (0 to 24) coordinate on the screen.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_613" aria-label="613"/>You could compute the <span class="SANS_TheSansMonoCd_W5Regular_11">X</span> coordinate via this function</p>&#13;
<pre id="pre-792"><code>X = Posn % 80;</code></pre>&#13;
<p class="Continued1">and the <span class="SANS_TheSansMonoCd_W5Regular_11">Y</span> coordinate with this formula:</p>&#13;
<pre id="pre-793"><code>Y = Posn / 25;</code></pre>&#13;
<p class="TX">The following code, which realizes these two functions via table lookup, may improve the performance of your code, particularly if you access the table frequently and it is sitting in the processor’s cache:</p>&#13;
<pre id="pre-794"><code>lea  x2, xTbl&#13;
lea  x3, yTbl&#13;
ldr  w4, Posn   // Using an appropriate addressing mode&#13;
ldrb w0, [x2, w4, uxtw #0] // Get X.&#13;
ldrb w1, [x3, w4, uxtw #0] // Get Y.</code></pre>&#13;
<p class="Continued1">Given appropriate values in <span class="SANS_TheSansMonoCd_W5Regular_11">xTbl</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">yTbl</span>, this will leave the x-coordinate in W0 and the y-coordinate in W1.</p>&#13;
<p class="TX">If the domain of a function is within 0 to 255 but the range is outside this set, the lookup table will contain 256 or fewer entries, but each entry will require 2 or more bytes. If both the range and domains of the function are outside 0 to 255, each entry will require 2 or more bytes, and the table will contain more than 256 entries.</p>&#13;
<p class="TX">Recall from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> that the formula for indexing into a single-dimensional array (of which a table is a special case) is as follows:</p>&#13;
<pre id="pre-795"><code><var>Element_Address</var> = <var>Base</var> + <var>Index</var> × <var>Element_Size</var></code></pre>&#13;
<p class="TX">If elements in the range of the function require 2 bytes, you must multiply the index by 2 before indexing into the table. Likewise, if each entry requires 3, 4, or more bytes, the index must be multiplied by the size of each table entry before being used as an index into the table. For example, suppose you have a function <span class="SANS_TheSansMonoCd_W5Regular_11">F(x)</span>, defined by the following C/C++ declaration:</p>&#13;
<pre id="pre-796"><code>short F(word x) {...} // short is a half word (16 bits).</code></pre>&#13;
<p class="TX">You can create this function by using the following ARM code (and, of course, the appropriate table named <span class="SANS_TheSansMonoCd_W5Regular_11">F</span>):</p>&#13;
<pre id="pre-797"><code>lea  x1, F&#13;
ldrh w0, x    // Using an appropriate addressing mode&#13;
ldrh w0, [x1, w0, uxtw #1] // Shift left does multiply by 2.</code></pre>&#13;
<p class="TX">Any function whose domain is small and mostly contiguous is a good candidate for computation via table lookup. In some cases, noncontiguous domains are acceptable as well, as long as the domain can be coerced into an appropriate set of values (a previously discussed example is processing <span role="doc-pagebreak" epub:type="pagebreak" id="pg_614" aria-label="614"/><span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement expressions). Such operations are called <i>conditioning</i> and are the subject of the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-182"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">10.1.3 Domain Conditioning</span></h4>&#13;
<p class="TNI1"><i>Domain conditioning</i> is taking a set of values in the domain of a function and massaging them so that they are more acceptable as inputs to that function. Consider the following function:</p>&#13;
<pre id="pre-798"><code>sin x = sin x|(x∈[-2π,2π])</code></pre>&#13;
<p class="TX">This says that the (computer) function <span class="SANS_TheSansMonoCd_W5Regular_11">sin(x)</span> is equivalent to the (mathematical) function sin <i>x</i> where:</p>&#13;
<pre id="pre-799"><code>-2π &lt;= x &lt;= 2π</code></pre>&#13;
<p class="TX">As you know, sine is a circular function, which will accept any real-value input. The formula used to compute sine, however, accepts only a small set of these values. This range limitation doesn’t present any real problems; by simply computing <span class="SANS_TheSansMonoCd_W5Regular_11">sin(y mod (2<span xml:lang="el" lang="el">π</span>))</span>, you can compute the sine of any input value. Modifying an input value so that you can easily compute a function is called <i>conditioning the input</i>. The preceding example computed <span class="SANS_TheSansMonoCd_W5Regular_11">(x % 2) * pi</span> and used the result as the input to the <span class="SANS_TheSansMonoCd_W5Regular_11">sin()</span> function. This truncates <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> to the domain <span class="SANS_TheSansMonoCd_W5Regular_11">sin()</span> needs without affecting the result.</p>&#13;
<p class="TX">You can apply input conditioning to table lookups as well. In fact, scaling the index to handle word entries is a form of input conditioning. Consider the following C/C++ function:</p>&#13;
<pre id="pre-800"><code>short val(short x)&#13;
{&#13;
    switch (x)&#13;
    {&#13;
        case 0: return 1;&#13;
        case 1: return 1;&#13;
        case 2: return 4;&#13;
        case 3: return 27;&#13;
        case 4: return 256;&#13;
    }&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="TX">This function computes a value for <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> in the range 0 to 4 and returns 0 if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is outside this range. Since <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> can take on 65,536 values (being a 16-bit hword), creating a table containing 65,536 hwords where only the first five entries are nonzero seems to be quite wasteful. However, you can still compute this function by using a table lookup if you use input conditioning. The following assembly language code presents this principle:</p>&#13;
<pre id="pre-801"><code>    mov  w0, #0       // Result = 0, assume x &gt; 4&#13;
    ldrh w1, [fp, #x] // Assume x is local.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_615" aria-label="615"/>    cmp  w1, #4       // See if in the range 0 to 4.&#13;
    bhi  outOfRange&#13;
    lea  x2, valTbl   // Address of lookup table&#13;
    ldrh w0, [x2, w1, uxtw #1] // index * 2 (half-word table)&#13;
outOfRange:</code></pre>&#13;
<p class="TX">This code checks whether <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is outside the range 0 to 4. If so, it manually sets W0 to 0; otherwise, it looks up the function value through the <span class="SANS_TheSansMonoCd_W5Regular_11">valTbl</span> table. With input conditioning, you can implement several functions that would otherwise be impractical to do via table lookup.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-183"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">10.1.4 Table Generation</span></h4>&#13;
<p class="TNI1">One big problem with using table lookups is creating the table in the first place. This is particularly true if the table has many entries. Figuring out the data to place in the table, then laboriously entering the data, and finally checking that data to make sure it is valid is a time-consuming and boring process.</p>&#13;
<p class="TX">For many tables, there is no way around this. For other tables, however, you can use the computer to generate the table for you. I’ll explain this by example. Consider the following modification to the sine function:</p>&#13;
<p class="Equation"><span class="epub"><math display="inline" alttext="Equation"><mrow><mi>sin</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>×</mo><mi>r</mi><mo>=</mo><mo>〈</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>×</mo><mo stretchy="false">(</mo><mn>1000</mn><mtext> </mtext><mo>×</mo><mtext> </mtext><mi>sin</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mn>1000</mn></mrow></mfrac><mo stretchy="false">[</mo><mi>x</mi><mo>∈</mo><mn>0</mn><mo>,</mo><mn>359</mn><mo stretchy="false">]</mo><mo>〉</mo></mrow></math></span><span class="mobi"><img class="img1" src="../images/pg615.jpg" alt="" width="1392" height="107"/></span></p>&#13;
<p class="TX">This states that <i>x</i> is an integer in the range 0 to 359 (degrees) and that <i>r</i> must be an integer. The computer can easily compute this with the following code:</p>&#13;
<pre id="pre-802"><code>lea   x1, Sines     // Table of 16-bit values&#13;
ldr   w0, [fp, #x]  // Assume x is local.&#13;
ldrh  w0, [x1, w0, uxtw #1]  // index * 2 for half words&#13;
ldrh  w2, [fp, #r]  // Assume r is local.&#13;
sxth  x0, w0&#13;
sxth  x2, w2&#13;
smul  w0, w0, w2    // r *(1000 * sin(x))&#13;
mov   w2, #1000&#13;
sdiv  x0, x0, x2    // r *(1000 * sin(x))/ 1000</code></pre>&#13;
<p class="TX">Note that integer multiplication and division are not associative. You cannot remove the multiplication by 1,000 and the division by 1,000 because they appear to cancel each other out. Furthermore, this code must compute this function in exactly this order.</p>&#13;
<p class="TX">All you need to complete this function is <span class="SANS_TheSansMonoCd_W5Regular_11">Sines</span>, a table containing 360 values corresponding to the sine of the angle (in degrees) times 1,000. The C/C++ program in Listing 10-2 generates this table.</p>&#13;
<pre id="pre-803"><code>// Listing10-2.cpp&#13;
//&#13;
// g++ -o Listing10-2 Listing10-2.c -lm&#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_616" aria-label="616"/>// GenerateSines&#13;
//&#13;
// A C program that generates a table of sine values for&#13;
// an assembly language lookup table&#13;
&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;math.h&gt;&#13;
&#13;
int main(int argc, char **argv)&#13;
{&#13;
    FILE *outFile;&#13;
    int angle;&#13;
    int r;&#13;
&#13;
    // Open the file:&#13;
&#13;
    outFile = fopen("sines.inc", "w");&#13;
&#13;
    // Emit the initial part of the declaration to&#13;
    // the output file:&#13;
&#13;
    fprintf&#13;
    (&#13;
        outFile,&#13;
        "Sines:"  // sin(0) = 0&#13;
    );&#13;
&#13;
&#13;
    // Emit the Sines table:&#13;
&#13;
    for(angle = 0; angle &lt;= 359; ++angle)&#13;
    {&#13;
        // Convert angle in degrees to an angle in&#13;
        // radians using:&#13;
        //&#13;
        // radians = angle * 2.0 * pi / 360.0;&#13;
        //&#13;
        // Multiply by 1000 and store the rounded&#13;
        // result into the integer variable r.&#13;
&#13;
        double theSine =&#13;
            sin&#13;
            (&#13;
                angle * 2.0 *&#13;
                3.14159265358979323846 /&#13;
                360.0&#13;
            );&#13;
        r = (int) (theSine * 1000.0);&#13;
&#13;
        // Write out the integers eight per line to the&#13;
        // source file.&#13;
        // Note: If (angle AND %111) is 0, then angle&#13;
        // is divisible by 8 and you should output a&#13;
        // newline first.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_617" aria-label="617"/>        if((angle &amp; 7) == 0)&#13;
        {&#13;
            fprintf(outFile, "\n\t.hword\t");&#13;
        }&#13;
        fprintf(outFile, "%5d", r);&#13;
        if ((angle &amp; 7) != 7)&#13;
        {&#13;
            fprintf(outFile, ",");&#13;
        }&#13;
&#13;
    } // endfor&#13;
    fprintf(outFile, "\n");&#13;
&#13;
    fclose(outFile);&#13;
    return 0;&#13;
&#13;
} // end main</code></pre>&#13;
<p class="TX">Compiling and running the program in Listing 10-2 produces the file <i>sines.inc</i> containing the following text (truncated for brevity):</p>&#13;
<pre id="pre-804"><code>Sines:&#13;
     .hword      0,   17,   34,   52,   69,   87,  104,  121&#13;
     .hword    139,  156,  173,  190,  207,  224,  241,  258&#13;
     .hword    275,  292,  309,  325,  342,  358,  374,  390&#13;
     .hword    406,  422,  438,  453,  469,  484,  499,  515&#13;
     .hword    529,  544,  559,  573,  587,  601,  615,  629&#13;
     .hword    642,  656,  669,  681,  694,  707,  719,  731&#13;
     .hword    743,  754,  766,  777,  788,  798,  809,  819&#13;
        .&#13;
        .&#13;
        .&#13;
     .hword   -529, -515, -500, -484, -469, -453, -438, -422&#13;
     .hword   -406, -390, -374, -358, -342, -325, -309, -292&#13;
     .hword   -275, -258, -241, -224, -207, -190, -173, -156&#13;
     .hword   -139, -121, -104,  -87,  -69,  -52,  -34,  -17</code></pre>&#13;
<p class="TX">Obviously, writing the C program that generated this data is much easier than entering and verifying this data by hand. You can also use Pascal/Delphi, Java, C#, Swift, or another HLL to write the table-generation program. Because the program will execute only once, its performance is not an issue.</p>&#13;
<p class="TX">Once you run the table-generation program, the only step left is to cut and paste the table from the file (<i>sines.inc</i> in this example) into the program that will actually use the table (or, alternatively, use the <span class="SANS_TheSansMonoCd_W5Regular_11">#include "sines.inc"</span> directive to include the text in your source file).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-112"/><span class="SANS_Futura_Std_Bold_B_11">10.2 Table-Lookup Performance</span></h3>&#13;
<p class="TNI1">In the early days of PCs, table lookups were a preferred way to do high-performance computations. Today, it is common for a CPU to be 10 to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_618" aria-label="618"/>100 times faster than main memory. As a result, using a table lookup may not be faster than doing the same calculation with machine instructions. However, the on-chip CPU cache memory subsystems operate at near-CPU speeds. Therefore, table lookups can be cost-effective if your table resides in cache memory on the CPU. This means that the way to get good performance from table lookups is to use small tables (because the cache has only so much room) and to use tables whose entries you reference frequently (so the tables stay in the cache).</p>&#13;
<p class="TX">Ultimately, the best way to determine whether a table lookup is faster than a calculation is to write both versions of the code and time them. Although the “10 million loop and time” approach is probably good enough for coarse measurements, you might also want to find and use a decent profiler program that will produce much better timing results. See <span class="Xref">“For More Information”</span> for additional details.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-113"/><span class="SANS_Futura_Std_Bold_B_11">10.3 Moving On</span></h3>&#13;
<p class="TNI1">Using table lookups to optimize applications has grown out of favor as CPU speeds have increased and memory access times have not kept pace. Nevertheless, this short chapter covered the instances when table lookups are still useful. It began with a discussion of basic table lookup operations, then covered domain conditioning and using software to automatically generate tables. It concluded with a few notes on how to decide whether table lookups are the right choice for a particular project.</p>&#13;
<p class="TX">On modern CPUs, multiple cores and SIMD instruction sets are the common way of improving application performance. The next chapter discusses the ARM Neon/SIMD instruction set and how you can use it to improve program performance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-114"/><span class="SANS_Futura_Std_Bold_B_11">10.4 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">Donald Knuth’s <i>The Art of Computer Programming, Volume 3: Searching and Sorting</i>, 2nd edition (Addison-Wesley Professional, 1998), contains a lot of useful information about searching for data in tables.</li>&#13;
<li class="BL">See my book <i>Write Great Code</i>, Volume 1, 2nd edition (No Starch Press, 2020) or the electronic version of <i>The Art of Assembly Language</i> at <i><a href="https://www.randallhyde.com">https://<wbr/>www<wbr/>.randallhyde<wbr/>.com</a></i> for details concerning the operation of cache memory and how you can optimize its use.</li>&#13;
<li class="BL">For information on profiler programs, see “Getting Started with dotTrace on macOS and Linux” by Maarten Balliauw at <i><a href="https://blog.jetbrains.com/dotnet/2023/02/22/getting-started-with-dottrace-on-macos-and-linux">https://<wbr/>blog<wbr/>.jetbrains<wbr/>.com<wbr/>/dotnet<wbr/>/2023<wbr/>/02<wbr/>/22<wbr/>/getting<wbr/>-started<wbr/>-with<wbr/>-dottrace<wbr/>-on<wbr/>-macos<wbr/>-and<wbr/>-linux</a></i>. You can also check out “13 Profiling Software to Debug Application Performance Issue” by Amrita Pathak at <i><a href="https://geekflare.com/application-profiling-software/">https://<wbr/>geekflare<wbr/>.com<wbr/>/application<wbr/>-profiling<wbr/>-software<wbr/>/</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-28">&#13;
<p class="BH" id="box-28"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_619" aria-label="619"/><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What is the domain of a function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  What is the range of a function?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  Provide the code that implements the following functions (using pseudo-C prototypes and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f</span> <span class="SANS_Futura_Std_Book_11">as the table name):</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">byte f(byte input)</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">halfword f(byte input)</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">byte f(word input)</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">word f(word input)</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What is domain conditioning?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  Why might table lookups not be effective on modern processors?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>