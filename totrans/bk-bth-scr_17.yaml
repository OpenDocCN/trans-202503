- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 16 CODE BLOCKS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A *code block* can sometimes be a rather generic term, referring to some amorphous
    section of a program or a few lines of code. In Batch, it’s a well-defined entity:
    one or more commands in between a set of open and close parentheses. A prominent
    example is the code often executed when an if command is true.'
  prefs: []
  type: TYPE_NORMAL
- en: That seems simple enough, but it’s far more difficult to use a code block properly
    and wisely than it is to define it. A very powerful feature of Batch is that delayed
    expansion allows you to resolve variables in two distinct ways inside a code block,
    but the uninitiated often misinterpret that functionality as a bug. In this chapter,
    I’ll detail all the intricacies involved, and you’ll also learn how code blocks,
    specifically naked code blocks, provide an interesting technique for allowing
    a variable to survive code of limited scope. If that doesn’t yet sound impressive,
    I’m confident that it will soon.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Variables in a Code Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I discussed in detail the process of setting and resolving a variable in [Chapter
    2](chapter2.xhtml), but those rules change inside of a code block. As I’ll soon
    demonstrate, this is a great feature of Batch, but it’s often misunderstood and
    can result in a perplexed and cranky coder. Even after many years of Batch coding,
    it’s still easy to stumble into this particular issue from time to time. While
    I usually find and fix the issue relatively quickly (after letting out an audible
    “D’oh!”), it can lead to hours of frustration for more novice coders. This batveat
    is best described with an example.
  prefs: []
  type: TYPE_NORMAL
- en: On many occasions, co-workers have presented me with an apparently simple code
    snippet such as the one in [Listing 16-1](#Lis16-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-1: A variable set and resolved in a code block ... and a mystery'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code block is accompanied by an exasperated query:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable has an initial setting, but I’m resetting it to something else and
    it doesn’t seem to “take.” I’m setting the price of a 50-inch TV to $450, and
    I know that the bSale boolean is true because the echo to the console happens,
    but the variable’s not being reset to $350\. The echo command writes out $450\.
    It’s as if the first command inside the code block doesn’t execute while the second
    one does. Crazy, huh? To test this theory, I moved only the echo command from
    inside the if command code block to just after it. Suddenly, I get the sale price
    to display like I wanted, but that’s not a solution because I want to execute
    the command only if there’s a sale. I even tried not setting the variable prior
    to the if command, but then it resolved to nothing at all. Ugh! This makes no
    sense. What’s going on?
  prefs: []
  type: TYPE_NORMAL
- en: 'The quick and much too brief reply is, “Replace the percent signs with exclamation
    marks.” The only change needed to [Listing 16-1](#Lis16-1) is the resolution of
    price at the end of the echo command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is what the confounded coder had expected all along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the coder incredulously tries and sees the exclamation marks work, they
    typically return more peeved than relieved and with the combination of another
    query and a new complaint: “Sometimes you use percent signs to resolve a variable,
    and at other times, you use exclamation marks. What kind of a programmatical sadist
    would dream this up? Isn’t Batch esoteric enough? When I set a variable, I expect
    it to be set. Period. What possible use could this have?” The only variations
    in this diatribe are in its intensity and level of vulgarity. These comments are
    from a very subdued and pious co-worker. Before addressing the question of this
    feature’s use, I owe you a far better explanation of what’s going on with the
    price variable.'
  prefs: []
  type: TYPE_NORMAL
- en: The coexistence of two values of a variable is another application of delayed
    expansion, first introduced in [Chapter 3](chapter3.xhtml), which allows for the
    resolution of variables at either parse time or execution time. When a variable
    is set inside a code block, you can think of it as having two values at one time.
    One is the current value to which it was set in the code block, resolved at execution
    time. The other is the value assigned to it as it entered the code block, resolved
    at parse time.
  prefs: []
  type: TYPE_NORMAL
- en: If a variable simultaneously has two distinct values, we need two different
    means of resolving the variable. To that end, *percent signs are the delimiter
    for revealing its value as it entered the code block*, and *exclamation marks
    are the delimiter for retrieving its current value inside of the code block*.
    The code can reset a variable multiple times in the code block, and percent sign
    delimiters will still resolve it to its state before entering the code block.
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is that at the time of the echo command in [Listing 16-1](#Lis16-1),
    %price% resolves to $450, and !price! resolves to $350.
  prefs: []
  type: TYPE_NORMAL
- en: Despite my co-worker’s protestation, this isn’t sadistic at all; it actually
    represents a fascinating feature that’s lacking in most programming languages.
    The ability for a single variable to hold two values may be hard to grasp, but
    once understood, it offers many possibilities. To demonstrate, I’ll alter the
    message written to the console in [Listing 16-1](#Lis16-1). Instead of just giving
    the sale price, it would be easier to see the savings by showing both the original
    and sale prices. I’m using the same price variable for both values in [Listing
    16-2](#Lis16-2)—once resolved with percent signs and once with exclamation marks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-2: A variable resolved to two distinct values'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes a great deal of sense intrinsically because both values are in fact
    a *price*; one is the original price, and the other is the sale price. You could
    have used two different variables, perhaps origPrice and salePrice, but coders
    with a discerning eye might describe [Listing 16-2](#Lis16-2) as elegant, the
    greatest of all possible praises of its author, especially after seeing the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This feature allows the imaginative coder many possibilities. You might have
    a counter or a variable tallying up numbers, both updated inside of a loop. (In
    the next few chapters, I’ll finally get to the for command and looping.) While
    inside that loop, you might want access to the original counter or tally value
    for comparison. A data condition in some iterations of the loop might alert you
    to the fact that the loop shouldn’t have been processed. Without this feature,
    you’ll need to execute the loop once for validation and another time for the core
    logic. With delayed expansion, you’ll need only one loop, and at any point you
    can restore all variables to their original values and abandon the loop.
  prefs: []
  type: TYPE_NORMAL
- en: This does beg the question as to what happens in nested code blocks. Are there
    three active values for a variable defined inside an if command code block nested
    inside another if command code block? No. There are exactly two values; one is
    its value before entering the outermost code block, and the other is its current
    value inside the code blocks, regardless of the level of nesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'F. Scott Fitzgerald famously wrote, “The test of a first-rate intelligence
    is the ability to hold two opposing ideas in mind at the same time and still retain
    the ability to function.” I’ve insulted the interpreter’s intelligence in past
    chapters, but Batch’s ability to function in this duality does suggest that I
    may have been too harsh. Maybe the interpreter can handle advanced topics, even
    theoretical physics. The SchrodingersCat variable can simultaneously hold two
    values: alive and dead.'
  prefs: []
  type: TYPE_NORMAL
- en: The Naked Code Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the prior examples, I dealt only with variables inside the code block of
    an if command, but everything previously discussed in this chapter applies to
    any code block. Remember that a code block is really just one or more commands
    inside a set of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a code block is the code that comes after the else keyword
    of an if command. I’ve already hinted that the for command uses code blocks, and
    those code blocks can become very complex with nesting and with multiple variables
    being assigned and reassigned often. That’s why this chapter is the final prerequisite
    to the upcoming discussion on the most significant Batch command. But code blocks
    don’t have to be associated with a command at all.
  prefs: []
  type: TYPE_NORMAL
- en: A *naked code block* is created as its own entity and not associated with a
    command such as the if or for. For instance, we can rewrite the if command from
    [Listing 16-2](#Lis16-2) without the if and the conditional clause. The naked
    code block in [Listing 16-3](#Lis16-3) looks a bit odd at first, but notice that
    everything is identical except that I have removed the text if %bSale%.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-3: A naked code block where price has two values'
  prefs: []
  type: TYPE_NORMAL
- en: This code is still setting the price variable to the original price before entering
    the code block, where we reset the variable to the sale price.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output we see the same text including both prices, with the only difference
    being that the code always writes the following to the console, because what was
    conditional logic now executes unconditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To truly demonstrate the power of these parentheses, simply remove them and
    examine the effect. That’s exactly what I’ve done here, and I didn’t even realign
    the indenting, although doing so would have absolutely no effect on the result.
    Compare this to [Listing 16-3](#Lis16-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, this code makes no sense. The fact that we’re setting the variable
    on one line and resetting it on the very next completely obviates the first set
    command, which might as well be commented out or deleted. The price variable now
    has a single value, and percent signs and exclamation marks both resolve the variable
    to its sole value of $350, resulting in the nonsensical output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The set of parentheses had a marked effect on the code listing. They created
    a naked code block, allowing the variable to have two values, each accessible
    with different delimiters. Without the parentheses, the code is junk.
  prefs: []
  type: TYPE_NORMAL
- en: When using a naked code block, it’s good form to always line up the open and
    close parentheses in the same column on unadulterated lines with the code in the
    code block indented as if it followed an if command. You could rewrite [Listing
    16-3](#Lis16-3) with the second set command on the same line as the open parenthesis
    and the close parenthesis trailing the echo command, but doing so would make the
    code very difficult to read. (I don’t even want to show it.) If you’re coding
    a naked code block, there’s probably a good reason for it, and if you hide its
    existence, an elegant solution suddenly turns cryptic.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good reason for using a naked code block is to swap the values of two variables
    without an intermediate variable. This code turns fact into fiction and fiction
    into fact better than any politician:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first set command is simply resetting the fact variable, but the second
    set command isn’t using this updated value when it resets fiction. Instead, the
    percent signs resolve fact to its value before entering the naked code block.
    The interpreter reads and parses both set commands—and resolves both variables—before
    setting either variable. If you were to remove the parentheses, both variables
    would take on the value initially defined as fiction, completely defeating the
    value swap.
  prefs: []
  type: TYPE_NORMAL
- en: Surviving an endlocal Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any code block, but specifically the naked code block, has another very useful
    purpose: allowing a variable to survive an endlocal command. In [Chapter 3](chapter3.xhtml),
    you learned that all variables between a setlocal command and an endlocal command
    will revert to their prior state once the endlocal executes. This wonderful Batch
    feature ensures that a called routine doesn’t step on variables that might be
    used by the caller, but it raises a very pertinent question. How can that called
    routine return a result if nothing can survive its endlocal command?'
  prefs: []
  type: TYPE_NORMAL
- en: The “Problem” with the endlocal Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To demonstrate the problem, the routine shown in [Listing 16-4](#Lis16-4) accepts
    a monetary amount as dollars and cents as its first parameter and attempts to
    pass back that amount with a 6 percent sales tax added as its second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-4: Some good math wasted'
  prefs: []
  type: TYPE_NORMAL
- en: For now, don’t get bogged down in the math. (See the “An Arithmetic Digression
    for My Fellow Math Geeks” box for those details.) Pertinent to this discussion,
    the :AddTax routine starts with a setlocal command, followed by six set commands.
    The last set command ❶ assigns the result of the arithmetic to the second parameter,
    but the endlocal command ❷ immediately wipes it out. Nothing’s returned. I’m trying
    to protect or hide changes to the first five variables from being seen by the
    code outside of the routine, but I also want to let this last variable through.
    As of yet, I’m unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some contemplation, it might make sense to reverse the commands before
    the goto :eof:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But alas, that doesn’t work either. Now, the wTaxDec variable doesn’t survive
    the endlocal, so this logic most likely sets the return parameter to nothing at
    all (or whatever value wTaxDec was set to prior to the routine). It’s a different
    manifestation of the same issue; nothing set between the setlocal and the endlocal
    survives.
  prefs: []
  type: TYPE_NORMAL
- en: The Naked Code Block Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simple addition of two parentheses (and some indentation for readability)
    creates a code block starting with an endlocal command—and solves the problem.
    Compare this to [Listing 16-4](#Lis16-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The open parenthesis starts the code block. The endlocal command wipes out the
    *current* state of the five variables, returning them to their pre-setlocal states.
    Now it gets interesting. Exclamation marks resolve a variable to its current state
    inside the code block, but percent signs resolve a variable to its state at the
    beginning of the code block before the endlocal executed. Hence, !wTaxDec! resolves
    to nothing (or junk), but %wTaxDec% resolves to the value to which it was assigned
    just before the code block, and that’s the value I’m assigning to the second parameter
    just before getting out of the routine.
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is that there’s a narrow window inside the naked code block—between
    the endlocal and the close parenthesis—where we can resolve these five variables
    with percent signs. I’ve capitalized on this window by using percent signs to
    resolve the only one that I want, assigning its value to the return parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to call the routine to see it work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows the 6 percent sales tax successfully added to the
    original amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This example sets a parameter being returned by a routine, but a routine isn’t
    a requirement of this technique. At any point in a bat file, you can hide variables
    by invoking a setlocal command. In the following example, two variables, survive
    and persist, survive the endlocal in the code block, but extinct does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code block is similar to the prior example, but there are two pertinent
    differences. First, it’s preserving multiple variables. Second, the set commands
    look redundant—each variable is being set to its own resolved value. The current
    value of each variable is null after the endlocal, but the last two set commands
    are restoring the variable’s own values from just before the code block.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is simple yet unintuitive. An endlocal command starts a naked
    code block, followed by one or more set commands assigning variables, often to
    themselves. The world outside of the naked code block can now use the shared variables,
    but not any unshared variables. If you want to do this assignment conditionally,
    simply place an if command with the conditional clause of your choosing around
    the set command inside the naked code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'I must admit that there’s an alternative solution for this task not involving
    the naked code block. Part of me regrets even sharing it, but I will because you
    might just run across it someday. You can also make these two variables survive
    an endlocal by replacing the prior naked code block with these three commands
    on this one very ugly line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding a space or two after each command separator (&) might make this a bit
    more readable, but not nearly enough. Use the naked code block.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned exactly how variables are resolved in code blocks.
    The next time you hear someone say, “Use exclamation marks inside and percent
    signs outside of a code block,” I hope that you’ll have the knowledge to add a
    little more depth to the conversation. Now that you’ve learned the nuances concerning
    delayed expansion and variable resolution in a code block, you won’t just manage
    to make something work; you’ll be able to use both values contained in a variable
    where appropriate. I also introduced the naked code block and demonstrated its
    crucial role in allowing variables to survive an endlocal command.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the long-awaited for command. We now have everything in place to
    explore this greatly important Batch command in [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
