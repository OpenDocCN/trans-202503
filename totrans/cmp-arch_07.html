<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="chn"><span epub:type="pagebreak" id="page_113"/><strong>5</strong></h2>&#13;
<h2 class="cht"><strong>DIGITAL LOGIC</strong></h2>&#13;
<div class="image1"><img src="../images/f0113-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq">Switches such as the semiconductor transistors seen in the previous chapter are the most basic building block of modern electronic computation. But architects don’t usually think in terms of switches. Instead, they build up a hierarchy of more complex structures from them, eventually forming a CPU. The next layer of this hierarchy consists of logic gates: devices formed from a few switches in standard circuits representing basic Boolean functions, such as AND and OR. Logic gates, in turn, can be used to build up larger structures such as simple machines for arithmetic and memory.</p>&#13;
<p class="indent">In this chapter, we’ll examine some common types of logic gates and see how they’re constructed from switches. We’ll discuss how universal gates such as NAND can replace all the others and how Boolean logic can model and simplify circuits made from logic gates. But first, a little history.</p>&#13;
<h3 class="h3" id="lev104"><span epub:type="pagebreak" id="page_114"/>Claude Shannon and Logic Gates</h3>&#13;
<p class="noindent">By 1936, complex electronic switching circuits were in heavy use in telephone exchanges. These circuits automated the work previously performed by human telephone operators, making and breaking connections between users’ telephone wires to enable their calls. For example, a circuit might calculate functions such as, “If the caller has sent us a sequence of pulses encoding number 024 680 2468, and there is an available wire from here to the exchange managing 024 numbers, then connect the caller to the available wire and transmit 680 2468 in binary on it until the exchange replies with a connection code, and start billing them. Otherwise, connect the caller to a line-busy signal.” These call-routing functions grew in complexity as more telephones, wires, exchanges, and companies connected to the network. There was an urgent economic need to reduce their wiring and complexity if at all possible. Many hacks existed for replacing complex groups of switches with simpler ones that seemed to have the same function, but how to do this reliably or optimally wasn’t understood.</p>&#13;
<p class="indent">As we saw in the last chapter, switching devices use energy, so the energy of their outputs is less than that of their inputs; this made it difficult to reuse an output of one switch as an input to the next. For example, an electrical implementation using 0 V and 5 V to represent binary 0 and 1 as inputs will produce something like 0 V and 4.9999 V as outputs, because the switching mechanism loses some of the energy and voltage. If you build a large system from many switches, these voltage drops will accumulate until the output is no longer recognizable as representing the binary code.</p>&#13;
<p class="indent">All this changed in the great computing year of 1936, when Claude Shannon began his master’s degree at MIT, which produced arguably the greatest master’s thesis of all time. Shannon’s thesis introduced two innovations to computer architecture that solved the switch simplification problem.</p>&#13;
<p class="indent">First, it defined a method to organize groups of switches into a new higher-level abstraction, the <em>logic gate</em>. Logic gates are defined as devices that take a representation of one or more binary variables as inputs, and produce one or more binary outputs using the <em>same representation</em>. Simple switches are <em>not</em> logic gates because they lose energy, so the output representation has lower energy and is different from the input representation. In contrast, a logic gate must top up any energy lost from switching so that its output coding is exactly the same as its input coding. This property enables the output of one gate to be cleanly used as the input to the next gate, and thus for arbitrarily long sequences of gates to be connected together without having to worry about noise introduced by the energy loss at each step.</p>&#13;
<p class="indent">It’s much easier for a circuit designer to think in terms of logic gates because they no longer have to keep track of the lower-level energy considerations. Shannon showed how to implement logic gates from the switch technology of his day (electromechanical relays), but they can be implemented using many technologies, including water switches and modern metal-oxide-semiconductor field-effect transistors (MOSFETs).</p>&#13;
<p class="indent">Second, Shannon showed that any computation could be performed by combining instances of small sets of standard logic gates, such as AND, OR, <span epub:type="pagebreak" id="page_115"/>and NOT. He showed how to map these gates and their connections onto the mathematical logic of George Boole, <em>Boolean algebra</em>, which had been discovered 100 years earlier, around 1836. Boole’s theory can be used to find equivalent expressions to complex circuits to simplify them and retain the same functionality using fewer gates and switches.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>As if this work weren’t enough for one lifetime, Shannon also went on to invent communication theory, an entirely separate and equally brilliant contribution to computer science. Smart guy.</em></p>&#13;
<h3 class="h3" id="lev105">Logic Gates</h3>&#13;
<p class="noindent">In modern terms, a logic gate is any device that has some binary inputs and some binary outputs and doesn’t contain any memory, where the inputs and outputs use exactly the same physical representations for two symbols, 0 and 1. A logic gate’s function can be completely and deterministically described by a <em>truth table</em>, which lists the resulting outputs for each configuration of the inputs. You’ll see some examples soon.</p>&#13;
<p class="indent">It’s possible to invent infinitely many different logic gates, but the most common ones today, and those studied by Shannon, are those with only one or two inputs and only one output. These standard gates include AND, OR, NOT, XOR, NOR, and NAND gates. <a href="ch05.xhtml#ch05fig1">Figures 5-1</a> to <a href="ch05.xhtml#ch05fig6">5-6</a> show these gates and their truth tables.</p>&#13;
<div class="image"><img id="ch05fig1" src="../images/f0115-01.jpg" alt="Image" width="502" height="168"/></div>&#13;
<p class="figcap"><em>Figure 5-1: An AND gate and its truth table</em></p>&#13;
<div class="image"><img id="ch05fig2" src="../images/f0115-02.jpg" alt="Image" width="530" height="167"/></div>&#13;
<p class="figcap"><em>Figure 5-2: An OR gate and its truth table</em></p>&#13;
<div class="image"><img id="ch05fig3" src="../images/f0115-03.jpg" alt="Image" width="438" height="109"/></div>&#13;
<p class="figcap"><em>Figure 5-3: A NOT (inverter) gate and its truth table</em></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_116"/><img id="ch05fig4" src="../images/f0116-01.jpg" alt="Image" width="529" height="168"/></div>&#13;
<p class="figcap"><em>Figure 5-4: An XOR (exclusive OR) gate and its truth table</em></p>&#13;
<div class="image"><img id="ch05fig5" src="../images/f0116-02.jpg" alt="Image" width="531" height="172"/></div>&#13;
<p class="figcap"><em>Figure 5-5: A NOR gate and its truth table</em></p>&#13;
<div class="image"><img id="ch05fig6" src="../images/f0116-03.jpg" alt="Image" width="497" height="173"/></div>&#13;
<p class="figcap"><em>Figure 5-6: A NAND gate and its truth table</em></p>&#13;
<p class="indent">Each gate’s truth table lists every possible combination of inputs in the left-hand columns, and shows the corresponding output in the rightmost column. For example, the AND gate’s output is 1 if and only if both of its inputs X and Y are 1. For any other combination of inputs its output is 0.</p>&#13;
<p class="indent">The names and functions of these gates are intended to mimic our human sense of logical combinations, with 1 corresponding to truth and 0 to falsehood. For example, the AND gate says that X AND Y is true if and only if X is true and Y is true. An XOR gate, short for “exclusive OR,” requires <em>exactly</em> one of its two inputs to be true; the output is false if both inputs are true. This is distinct from regular OR, which is true if <em>either or both</em> of its inputs are true. (Students of digital logic have been known to reply “yes” to questions such as “Would you like beer or wine?”) NOR stands for “neither X nor Y,” and the output is true only when both inputs are false. NAND can be read as “not X and Y,” and its truth table is the opposite of AND.</p>&#13;
<p class="indent">Logic gates can be connected together into networks to represent more complex expressions. For example, <a href="ch05.xhtml#ch05fig7">Figure 5-7</a> represents X OR (Z AND NOT Y), and will set the output to 1 if X is 1, or if Z is 1 and Y is 0. Note that “or” here is inclusive.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_117"/><img id="ch05fig7" src="../images/f0117-01.jpg" alt="Image" width="553" height="174"/></div>&#13;
<p class="figcap"><em>Figure 5-7: The logic gates for F(X, Y, Z) = X + <span class="ob">YZ</span></em></p>&#13;
<p class="indent">The network of gates in <a href="ch05.xhtml#ch05fig7">Figure 5-7</a> may be used, for example, in Shannon’s telephone switching application, where it might be a circuit that disconnects a call if the receiver hasn’t picked up after 30 seconds (X), or if the call previously began (Z) and the caller has no remaining credit (Y).</p>&#13;
<h4 class="h4" id="lev106"><em>Identifying Universal Gates</em></h4>&#13;
<p class="noindent">In his research, Shannon wanted to identify a set of <em>universal gates</em>, a group of different types of logic gates that could be reconfigured to build any machine at the hardware level. He showed that several universal sets exist. For example, if you have a drawer containing an infinite number of AND and NOT gates, you can build anything from them. You could also do this with an infinite number of OR and NOT gates, but you can’t build arbitrary functions from only a drawer of AND and OR gates. Most interestingly, a drawer containing only NAND gates, or only NOR gates, is universal. For example, <a href="ch05.xhtml#ch05fig8">Figure 5-8</a> shows how to build the standard NOT, AND, and OR gates from only NANDs. You’ll get a chance to explore this figure more in an exercise at the end of the chapter.</p>&#13;
<div class="image"><img id="ch05fig8" src="../images/f0117-02.jpg" alt="Image" width="917" height="152"/></div>&#13;
<p class="figcap"><em>Figure 5-8: Building NOT, AND, and OR gates from universal NAND gates</em></p>&#13;
<p class="indent">Universal gates are important because they allow us to reduce the number of types of physical gates we need to manufacture down to just one. This is what we do in modern integrated circuits (ICs).</p>&#13;
<h4 class="h4" id="lev107"><em>Making Logic Gates from Transistors</em></h4>&#13;
<p class="noindent">You might initially think that we could just use a single electrical switch, such as a transistor, as an AND gate. After all, a switch takes two inputs, its emitter and a base, and turns on one output, the collector, if and only if both <span epub:type="pagebreak" id="page_118"/>inputs are on, which is the definition of logical AND. However, we’ve seen that a switch must convert some of the incoming energy to heat, so the output is not quite in the same form as the inputs and can’t be used directly as an input to the next logic gate. To keep the output in the same form as the inputs, we instead combine several switches, while using an external power source to keep topping up the energy that they lose as heat.</p>&#13;
<p class="indent">There are many different ways to do this. Shannon’s original designs were optimized for electromagnetic relay switches rather than transistors. Modern chips use so-called <em>CMOS (complementary metal-oxide semiconductor)</em> style, which forms NAND gates from two positive-type and two negative-type transistors, as shown in <a href="ch05.xhtml#ch05fig9">Figure 5-9</a>. With NAND as a universal gate, you can make all the other gates out of these CMOS NAND gates.</p>&#13;
<div class="image"><img id="ch05fig9" src="../images/f0118-01.jpg" alt="Image" width="551" height="424"/></div>&#13;
<p class="figcap"><em>Figure 5-9: A NAND gate made from p-type and n-type transistors</em></p>&#13;
<p class="indent">An electrical <em>circuit</em> is a concept that exists at the transistor level, where electrons flow from the power source to ground, then are pumped back from ground to power by a power source, creating a closed loop. While it’s common to informally refer to networks of logic gates as “digital logic circuits,” this is technically incorrect because at that higher level of abstraction, the networks don’t usually form closed circuits and instead can have arbitrary network topologies. If we were to implement the same networks using non-electronic implementations of logic gates, there might not be any circuit even at lower abstraction levels. When we draw diagrams and build systems made from logic gates, we should therefore more properly call them “digital logic networks” rather than “digital logic circuits.”</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><span epub:type="pagebreak" id="page_119"/><strong>MAKING LOGIC GATES FROM BILLIARD BALLS</strong></p>&#13;
<p class="stext">Logic gates don’t have to be made from transistors or even electricity. For example, billiard-ball computers are a theoretical invention where computation is done with balls in a complex geometric maze environment, in which versions of logic gates such as AND and OR are implemented through geometric structures and mechanics. The gates are arranged so that, for example, an AND gate tests for the collisions of two balls and directs one of them to the positive output only if the collision occurred, as in the following figure.</p>&#13;
<div class="imagec"><img src="../images/f0119-01.jpg" alt="Image" width="302" height="279"/></div>&#13;
<p class="stext">Due to the mechanical laws of conservation of energy, the billiard-ball computer models can be used to show that computation needs the same amount of energy and therefore the same number of bits of information to exit and enter. This isn’t the case for a normal AND gate, which has two inputs and one output. The model shows that we should add a second “garbage” output for the exhausted second bit. This has the interesting property that it makes the computation <em>reversible</em> in the sense that the input could be reconstructed if we know the output. This allows us to run the machine backward. If that sounds strange, consider that there are many programming situations where it would be nice to have a reverse debugger that could undo the effects of recent lines of code.</p>&#13;
<p class="stext">The billiard-ball computer was intended to enable us to think clearly about the role of energy usage and heat in computation. This has become a big topic recently as the rise of portable computers dependent on small batteries has increased the need to conserve computational energy, and as concerns have mounted about the environment, fuel resources and costs, carbon emissions, and heat pollution. A conventional AND gate has two inputs and only one output, so one billiard ball’s worth of energy is lost as physical heat every time we do an AND operation. The billiard-ball model suggests that we could build electric AND gates that don’t waste energy if we were to keep track of a second output bit from the gate—the same bit needed to make it reversible. Heat is actually energy that we’ve lost track of, in this case by throwing information away. This is why your phone gets hot when doing heavy computation, and it’s why your processor needs a large fan. The fan is pumping waste information in bits out of your computer’s vents. (In this sense, the world running out of fuel isn’t an energy crisis, but rather an information crisis. Energy can’t be created or destroyed, but we can lose the information about where the energy is—information we’d need to make the energy do useful work for us.)</p>&#13;
</div>&#13;
<h4 class="h4" id="lev108"><span epub:type="pagebreak" id="page_120"/><em>Putting Logic Gates on Chips</em></h4>&#13;
<p class="noindent">When you first look at a chip through a microscope, or at any computer built from any kind of logic gates, you won’t be able to point to a single component and say, “That’s a logic gate.” What you’ll actually see is a whole load of transistors, organized into gates. For example, take a look at <a href="ch05.xhtml#ch05fig10">Figure 5-10</a>, which shows a microscope photo (“die shot”) of a very simple silicon chip containing only four CMOS NAND gates, each formed from four transistors (as you saw in <a href="ch05.xhtml#ch05fig9">Figure 5-9</a>).</p>&#13;
<div class="image"><img id="ch05fig10" src="../images/f0120-01.jpg" alt="Image" width="651" height="800"/></div>&#13;
<p class="figcap"><em>Figure 5-10: A die shot of a simple silicon chip containing four CMOS NAND gates</em></p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05fig11">Figure 5-11</a> is a mask set for a single CMOS NAND gate, showing how to physically lay out the p- and n-doping regions along with the copper wiring.</p>&#13;
<p class="indent">Modern processors may have billions of transistors grouped into logic gates. But older-style ICs containing just a few logic gates are still manufactured and are very useful for building your own circuits. The 7400 TTL series is a famous example of such simple chips. Originally produced by Texas Instruments in the 1960s, they’re now widely manufactured as generic products. Most chips in this series contain just a handful of logic gates of a single type, such as four AND gates, four NAND gates, or four NOR gates, as shown in <a href="ch05.xhtml#ch05fig12">Figure 5-12</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_121"/><img id="ch05fig11" src="../images/f0121-01.jpg" alt="Image" width="905" height="869"/></div>&#13;
<p class="figcap"><em>Figure 5-11: A CMOS NAND gate made from transistors and copper wire as a chip layout</em></p>&#13;
<div class="image"><img id="ch05fig12" src="../images/f0121-02.jpg" alt="Image" width="650" height="363"/></div>&#13;
<p class="figcap"><em>Figure 5-12: Some 7400 TTL series chips, each containing a few logic gates</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_122"/>These diagrams show the physical layouts and pinouts of the chips; to connect the logic gates you attach physical wires to the appropriate pins. You can buy bags of these chips for a few dollars on eBay and wire them up on a breadboard with a 5 V power source and ground, as in <a href="ch05.xhtml#ch05fig13">Figure 5-13</a>, to make your own physical digital logic networks.</p>&#13;
<div class="image"><img id="ch05fig13" src="../images/f0122-01.jpg" alt="Image" width="552" height="495"/></div>&#13;
<p class="figcap"><em>Figure 5-13: Building a digital logic network (forming a 4-bit CPU) using the logic gates on TTL 7400 series chips on a breadboard</em></p>&#13;
<p class="indent">You can see from <a href="ch05.xhtml#ch05fig13">Figure 5-13</a> that the wiring for digital logic networks can get quite complicated. Wouldn’t it be nice if we had a way to simplify networks to use fewer gates and wires, while still performing the same functionality? This is where the next part of Shannon’s innovation comes in: how to use George Boole’s logic to perform such simplifications.</p>&#13;
<h3 class="h3" id="lev109">Boolean Logic</h3>&#13;
<p class="noindent">Logic allows us to formalize statements and inferences about truth and falsehood. It was developed by the ancient Greeks and remained largely unchanged until George Boole’s work around 1836. Boole’s work was picked up by Shannon in 1936, who realized that it could be used to model, simplify, and verify circuits built from his logic gates.</p>&#13;
<p class="indent">Boolean logic uses variable <em>names</em> to represent conceptual statements whose <em>values</em> are either true or false. It then provides connective symbols for AND, OR, and NOT, and rules that give truth values to expressions built from variables and these connectives.</p>&#13;
<p class="indent">Consider the following example. We have two variables: X represents the statement “God exists” and Y represents “snow is white.” We can then <span epub:type="pagebreak" id="page_123"/>represent “God exists and snow is white” with X AND Y. Or we can represent “Either God doesn’t exist and snow is white, or God does exist and snow is white” with (NOT X AND Y) OR (X AND Y).</p>&#13;
<p class="indent">Now let’s see how to work with these statements.</p>&#13;
<h4 class="h4" id="lev110"><em>Logic as Arithmetic</em></h4>&#13;
<p class="noindent">Boole discovered a structural similarity between logic and arithmetic. Previously, these had been two entirely different fields of study. Logic was an “arts subject” performed using natural language text and by studying rules to analyze arguments. Arithmetic was a “STEM subject” made of numbers and equations. As mathematicians had managed to unify geometry and algebra, so Boole managed to unify logic and arithmetic.</p>&#13;
<p class="indent">He did this by noticing that truth, represented by the symbol T, behaves like the number 1, and falsehood, represented by the symbol F, behaves like the number 0, if we replace AND with multiplication, OR with addition, and NOT with inversion about 1.</p>&#13;
<p class="indent">As we write <em>x</em> + <em>y</em> for addition and <em>xy</em> for multiplication in arithmetic, we can thus use these same notations for OR and AND. When using this notation, it’s common to also write <em><span class="ob">x</span></em> for NOT <em>x</em>, which corresponds to the arithmetic operation (1 – <em>x</em>).</p>&#13;
<p class="indent">The similarity isn’t quite perfect, because 1 + 1 = 2 in arithmetic but we need 1 + 1 = 1 in logic. Boole worked around this by choosing to work in a number system with only two numbers, 0 and 1, and by defining 1 plus anything to equal 1 within this system.</p>&#13;
<p class="indent">Using Boole’s system, logical arguments can be converted into simple arithmetic. The advantage of doing this is that we know a lot about arithmetic already, in particular how to use laws such as associativity, commutativity, and others listed in <a href="ch05.xhtml#ch05tab1">Table 5-1</a> to simplify expressions.</p>&#13;
<p class="tabcap" id="ch05tab1"><strong>Table 5-1:</strong> Useful Arithmetic Theorems for Simplifying Boolean Logic</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Name</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>AND form</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>OR form</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Identity law</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">1<em>A</em> = <em>A</em></p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">0 + <em>A</em> = <em>A</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">Null law</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">0<em>A</em> = 0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">1 + <em>A</em> = 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Idempotent law</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><em>AA</em> = <em>A</em></p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><em>A</em> + <em>A</em> = <em>A</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">Inverse law</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><em>A<span class="ob">A</span></em> = 0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><em>A</em> + <em><span class="ob">A</span></em> = 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Commutative law</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><em>AB</em> = <em>BA</em></p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><em>A</em> + <em>B</em> = <em>B</em> + <em>A</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">Associative law</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">(<em>AB</em>)<em>C</em> = <em>A</em> (<em>BC</em>)</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">(<em>A</em> + <em>B</em>) + <em>C</em> = <em>A</em> + (<em>B</em> + <em>C</em>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Distributive law</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><em>A</em> + <em>BC</em> = (<em>A</em> + <em>B</em>)(<em>A</em> + <em>C</em>)</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><em>A</em>(<em>B</em> + <em>C</em>) = <em>AB</em> + <em>AC</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">Absorption law</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><em>A</em>(<em>A</em> + <em>B</em>) = <em>A</em></p></td>&#13;
<td style="vertical-align: top"><p class="tabtext"><em>A</em> + <em>AB</em> = <em>A</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">De Morgan’s law</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><em><span class="ob">AB</span></em> = <em><span class="ob">A</span></em> + <em><span class="ob">B</span></em></p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"><span class="ob">(<em>A</em> + <em>B</em>)</span> = <em><span class="ob">AB</span></em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For example, say we want to calculate the truth value of:</p>&#13;
<p class="equ">(F AND (T OR F)) OR ((F OR NOT T) AND T)</p>&#13;
<p class="noindentb"><span epub:type="pagebreak" id="page_124"/>We can do it by converting the logic to arithmetic, then using standard arithmetic rules to simplify the expression:</p>&#13;
<p class="indent5">(0(1) + 0(0)) + ((0)1 + (1 – 1)1)</p>&#13;
<p class="indent5">= (0 + 0) + (0 + (0)1)</p>&#13;
<p class="indent5">= (0) + (0 + 0)</p>&#13;
<p class="indent5">= 0 + 0</p>&#13;
<p class="indent5">= 0</p>&#13;
<p class="noindenta">Finally, we convert the resulting number, 0, back to the logical value false.</p>&#13;
<p class="indentb">This also works using variables rather than particular values; for example, the previous statement about God and snow can be written and then manipulated arithmetically as:</p>&#13;
<p class="indent5">((1 – <em>x</em>)<em>y</em>) + (<em>xy</em>)</p>&#13;
<p class="indent5">= (<em>y</em> – <em>xy</em>) + (<em>xy</em>)</p>&#13;
<p class="indent5">= <em>y</em> – <em>xy</em> + <em>xy</em></p>&#13;
<p class="indent5">= <em>y</em></p>&#13;
<p class="noindenta">This can then be converted from the arithmetical number <em>y</em> back to the logical value <em>Y</em>. This shows that the truth of the statement is actually independent of the existence of God (<em>X</em>) and depends only on whether snow is white (<em>Y</em>). So assuming that snow is indeed white, the statement is true.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>The ability to move back and forth between logical truth values and integer 0s and 1s is now often used (or arguably misused) in languages such as C that play fast and loose with these types.</em></p>&#13;
<h4 class="h4" id="lev111"><em>Model Checking vs. Proof</em></h4>&#13;
<p class="noindent">We often want to know whether two Boolean expressions are equal. There are two main ways to go about determining this.</p>&#13;
<p class="indent">The first is called <em>model checking</em>. Given a potential equality, we simply compute truth tables for both the left side and the right side of the potential equation. If the truth tables match completely, then the expressions are equal. As an example, let’s check that the AND form of the distributive law from <a href="ch05.xhtml#ch05tab1">Table 5-1</a> always holds. First, we calculate and compute the table for the left side of the equality, <em>A</em> + <em>BC</em>. We begin with three columns for our variables: <em>A</em>, <em>B</em>, and <em>C</em>. We then add a column for our intermediate term, <em>BC</em>, and use this to compute the value of the whole expression in the rightmost column, as in <a href="ch05.xhtml#ch05tab2">Table 5-2</a>.</p>&#13;
<p class="tabcap" id="ch05tab2"><span epub:type="pagebreak" id="page_125"/><strong>Table 5-2:</strong> The Truth Table for <em>A</em> + <em>BC</em></p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>A</em></strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>B</em></strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>C</em></strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>BC</em></strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>A</em></strong> + <strong><em>BC</em></strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Next, we do the same for the right side of the equality, <em>(A</em> + <em>B</em>)(<em>A</em> + <em>C</em>), in <a href="ch05.xhtml#ch05tab3">Table 5-3</a>.</p>&#13;
<p class="tabcap" id="ch05tab3"><strong>Table 5-3:</strong> The Truth Table for (<em>A</em> + <em>B</em>)(<em>A</em> + <em>C</em>)</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:23%"/>&#13;
<col style="width:23%"/>&#13;
<col style="width:24%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>A</em></strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>B</em></strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc"><strong><em>C</em></strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc">(<strong><em>A</em></strong> + <strong><em>B</em></strong>)</p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc">(<strong><em>A</em></strong> + <strong><em>C</em></strong>)</p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtextc">(<strong><em>A</em></strong> + <strong><em>B</em></strong>)(<strong><em>A</em></strong> + <strong><em>C</em></strong>)</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">0</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
<td style="vertical-align: top"><p class="tabtextc">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Finally, we compare the tables. Here we can see that for every possible assignment of values to the variables, the resulting value is the same in both tables. Therefore, by model checking, the left side equals the right side.</p>&#13;
<p class="indent">Model checking makes use of the <em>values</em> of the terms. If an equality has been shown by model checking, we say that it has been <em>entailed</em>, and that it is <em>true</em>, and we write ⊧ <em>A</em> + <em>BC</em> = (<em>A</em> + <em>B</em>)(<em>A</em> + <em>C</em>).</p>&#13;
<p class="indent">The second way to show equalities is by <em>proof</em>. If some equalities have already been established, such as the laws of <a href="ch05.xhtml#ch05tab1">Table 5-1</a>, we can make use of their results symbolically without having to grind through the truth tables of everything. A proof is a list of transformations from the first to the second expression, where each transformation is justified by stating which law has been applied. If an equality has been shown by proof, we say it is <em>proved</em> and write ⊢ <em>A</em> + <em>BC</em> = (<em>A</em> + <em>B</em>)(<em>A</em> + <em>C</em>).</p>&#13;
<p class="indent">For example, here’s one way to prove that <em>A</em> + <em>BC</em> = (<em>A</em> + <em>B</em>)(<em>A</em> + <em>C</em>):</p>&#13;
<table>&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td><p class="noindent"><em>A</em> + <em>BC</em></p></td>&#13;
<td><p class="noindent">= (1<em>A</em>) + (<em>BC</em>)</p></td>&#13;
<td><p class="noindent">: by AND identity law</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="noindent"> </p></td>&#13;
<td><p class="noindent">= (<em>A</em>(1 + <em>B</em>)) + (<em>BC</em>)</p></td>&#13;
<td><p class="noindent">: by OR null law</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="noindent"> </p></td>&#13;
<td><p class="noindent">= (<em>A</em>1) + (<em>AB</em>) + (<em>BC</em>)</p></td>&#13;
<td><p class="noindent">: by OR distributive law</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="noindent"> </p></td>&#13;
<td><p class="noindent">= (<em>A</em>(1 + <em>C</em>)) + (<em>AB</em>) + (<em>BC</em>)</p></td>&#13;
<td><p class="noindent">: by OR null law</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="noindent"> </p></td>&#13;
<td><p class="noindent">= (<em>A</em>(<em>A</em> + <em>C</em>)) + <em>B</em>(<em>A</em> + <em>C</em>)</p></td>&#13;
<td><p class="noindent">: by OR distributive law</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="noindent"> </p></td>&#13;
<td><p class="noindent">= (<em>A</em> + <em>C</em>)(<em>A</em> + <em>B</em>)</p></td>&#13;
<td><p class="noindent">: by OR distributive law</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="notes"><span epub:type="pagebreak" id="page_126"/><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>For Boolean logic it can be shown that any equality established through model checking can also be proved, and vice versa, so you can use either method according to taste. It may seem obvious that model checking and proof give the same answers in Boolean logic, but this isn’t always the case for other logics, as found later by Gödel.</em></p>&#13;
<p class="indenta">The ability to check whether two expressions are equal isn’t purely academic. Shannon recognized its value in simplifying his digital logic networks.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>GEORGE BOOLE</strong></p>&#13;
<p class="stext">George Boole published his books <em>The Mathematical Analysis of Logic</em> (1847) and <em>The Laws of Thought</em> (1854) a few years after Babbage’s Engines. Boole grew up and formed his ideas in Lincoln, England. Unlike most historical academic heroes from rich families able to buy their way into Cambridge—such as Babbage and Turing—Boole came from an ordinary, poor family. His father was a shoemaker. Boole had no formal education, going instead to the public library and reading books to teach himself, <em>like you can do today</em>.</p>&#13;
<p class="stext">Boole created many new ideas outside the academic system, without that system’s constraints on his thinking. In particular, no one told him that arts and sciences were supposed to be kept separate, so he would physically wander between both sections of the library, making comparisons between them. While his name is strongly associated with Boolean logic and the boolean or bool data types in modern programming languages, he also worked on probabilistic and other forms of reasoning, and was motivated by trying to understand and model human intelligence, as in modern AI and cognitive science. His real motivation for studying logic and other forms of reasoning was to formalize, analyze, and check the many arguments from classical philosophy, especially concerning the existence of God. He wanted to find out if these arguments were valid, breaking them down into their parts and testing each step so he could find out which of their conclusions were true and what to believe.</p>&#13;
<p class="stextb">For example, here’s part of Boole’s logic for the existence of God (from <em>The Laws of Thought</em>, <a href="ch13.xhtml">Chapter 13</a>):</p>&#13;
<p class="stext1">Let <em>x</em> = Something has always existed.</p>&#13;
<p class="stext1"><em>y</em> = There has existed some one unchangeable and independent being.</p>&#13;
<p class="stext1"><em>z</em> = There has existed a succession of changeable and dependent beings.</p>&#13;
<p class="stext1"><em>p</em> = That series has had a cause from without.</p>&#13;
<p class="stext1"><em>q</em> = That series has had a cause from within.</p>&#13;
<p class="stext1">Then we have the following system of equations, viz.: 1st. <em>x</em> = 1;</p>&#13;
<p class="stext1">2nd. <em>x</em> = <em>v</em>{<em>y</em>(1 –<em>z</em>) + <em>z</em> (1 –<em>y</em>)};</p>&#13;
<p class="stext1">3rd. <em>z</em> = <em>v</em>{<em>p</em>(1 –<em>q</em>) + (1 –<em>p</em>)<em>q</em>};</p>&#13;
<p class="stext1">4th. <em>p</em> = 0;</p>&#13;
<p class="stext1">5th. <em>q</em> = 0:</p>&#13;
<p class="stext"><span epub:type="pagebreak" id="page_127"/>Boole’s short life—the founder of modern logic was killed by his homeopathic wife’s theory of wrapping him in ice-cold blankets to cure pneumonia—was a subset of Babbage’s, so they would likely have read each other’s work. Boole wasn’t interested in computer science, however. His ultimate interests were philosophical, and his work understanding and modeling intelligence was primarily intended as a contribution to the philosophical method. Still, he would have been aware that creating such formalisms would also enable them to be mechanized as AI, as discussed by Lovelace. It’s a great shame the two never got together to develop this idea.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev112">Simplifying Logic Circuits Using Boolean Logic</h3>&#13;
<p class="noindent">Shannon discarded Boole’s conceptual interpretations of the variables, and instead showed that Boole’s algebra could be used to simplify physical digital logic networks composed of logic gates. Simplification can include reducing both the number of gates and also the number of <em>types</em> of gates, such as reduction to all NAND gates.</p>&#13;
<p class="indent">This is done by translating a logic gate network into a Boolean expression, simplifying the expression using the laws of arithmetic, then translating the result back into a smaller logic gate network. Simplifying networks is useful because it reduces the number of transistors needed, which in turn reduces manufacturing costs and energy usage. Nowadays, CAD software is available that performs simplifications automatically: you input your digital logic network, click an icon, and get back a smaller and more efficient version.</p>&#13;
<p class="indent">For example, suppose we’ve designed the digital logic network on the left-hand side of <a href="ch05.xhtml#ch05fig14">Figure 5-14</a>. Using Boole’s theory this can be converted to an arithmetic expression and simplified to obtain <em>(A</em> + <em>B</em>)(<em>A</em> + <em>C</em>) = <em>A</em> + <em>BC</em>. This corresponds to the smaller network on the right side of <a href="ch05.xhtml#ch05fig14">Figure 5-14</a>.</p>&#13;
<div class="image"><img id="ch05fig14" src="../images/f0127-01.jpg" alt="Image" width="814" height="259"/></div>&#13;
<p class="figcap"><em>Figure 5-14: A logic network for (A + B)(A + C) (left) and reduced A + BC form (right)</em></p>&#13;
<p class="indent">We can use Boolean logic to further simplify the logic network to use only universal NAND gates, then reduce the number of NAND gates, as in <a href="ch05.xhtml#ch05fig15">Figure 5-15</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_128"/><img id="ch05fig15" src="../images/f0128-01.jpg" alt="Image" width="836" height="184"/></div>&#13;
<p class="figcap"><em>Figure 5-15: The Boolean logic converting A + BC to NAND gates (left) and then reducing them (right)</em></p>&#13;
<p class="indent">This allows us to convert any network into one that can be built more easily, using just one type of gate and as few of them as possible.</p>&#13;
<h3 class="h3" id="lev113">Laying Out Digital Logic</h3>&#13;
<p class="noindent">Once you’ve designed and simplified a digital logic network, you’ll usually want to transfer it to real hardware. There are several ways to do this, which we’ll examine here.</p>&#13;
<h4 class="h4" id="lev114"><em>7400 Chips</em></h4>&#13;
<p class="noindent">One way to implement a simple logic network has remained unchanged since the 1960s: lay it out across a bunch of 7400 chips and connect them together with a rat’s nest of wires.</p>&#13;
<p class="indent">As you saw earlier, each 7400 series chip contains a number of gates, usually all of the same type. Unfortunately, a single chip doesn’t usually correspond to any particular topological region of your circuit. You need to consider each gate in your circuit and choose a specific gate on a specific chip to instantiate it. You can choose what goes where completely arbitrarily and your circuit will still work, but if you apply a bit of cleverness to the layout you’ll be able to considerably reduce the length of wire needed to connect it.</p>&#13;
<p class="indent">For example, suppose you want to build the network shown on the upper left of <a href="ch05.xhtml#ch05fig16">Figure 5-16</a> and you have two TTL chips available in your electronics drawer: one containing four XORs and one containing four NANDs. The upper right of <a href="ch05.xhtml#ch05fig16">Figure 5-16</a> shows the result of using Boolean logic to convert the network to use the available gates, and the lower part of the figure shows one possible way to lay this out across the two TTL chips.</p>&#13;
<p class="indent">You can buy the TTL chips, plus a breadboard, switches, LEDs, 9 V battery, and resistors to drop the battery down to the 5 V used by the TTL chips (plus a resistor for each LED to prevent them exploding), and wire them up as in <a href="ch05.xhtml#ch05fig17">Figure 5-17</a> to implement your design.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_129"/><img id="ch05fig16" src="../images/f0129-01.jpg" alt="Image" width="594" height="583"/></div>&#13;
<p class="figcap"><em>Figure 5-16: A plan for converting a network to NANDs and laying it out using TTL chips</em></p>&#13;
<p class="indent">It’s possible to build a whole CPU from TTL chips in this way, and indeed this is how many early CPUs were built.</p>&#13;
<div class="image"><img id="ch05fig17" src="../images/f0129-02.jpg" alt="Image" width="670" height="279"/></div>&#13;
<p class="figcap"><em>Figure 5-17: The TTL plan laid out on a breadboard (using Fritzing)</em></p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>The “bit of cleverness” required to optimize the wiring will very quickly grow in size as you try to do it for larger circuits. Similar cleverness is needed to optimize the physical layouts for the other hardware methods we’ll discuss next. Designing algorithms to do this automatically and at scale is a major area of computer science and is heavily used, researched, and developed by chip companies.</em></p>&#13;
<h4 class="h4" id="lev115"><em>Photolithography</em></h4>&#13;
<p class="noindent">The ASIC process described in <a href="ch04.xhtml">Chapter 4</a> is the most heavyweight method for implementing digital logic networks, costing $5 million to make a mask set. Here, masks are prepared containing the transistor layouts needed to form the logic gates. This process gives the smallest, fastest hardware, but it’s economical only at large scales to justify the setup costs.</p>&#13;
<h4 class="h4" id="lev116"><span epub:type="pagebreak" id="page_130"/><em>Programmable Logic Arrays</em></h4>&#13;
<p class="noindent">A <em>programmable logic array (PLA)</em> is a chip with many inputs and many outputs, made with photolithography, such that every input and every input’s negation are connected to a series of AND and OR gates by fuses. <a href="ch05.xhtml#ch05fig18">Figure 5-18</a> shows a small example of a PLA structure. The plane in the figure is stacked multiple times, with each layer sharing the same AND and OR gates. The circles are fuses.</p>&#13;
<div class="image"><img id="ch05fig18" src="../images/f0130-01.jpg" alt="Image" width="470" height="796"/></div>&#13;
<p class="figcap"><em>Figure 5-18: A PLA schematic showing the interconnectivity of inputs and outputs</em></p>&#13;
<p class="indent">Beginning with this structure, you can make any Boolean logic function by blowing out some subset of the fuses to effectively remove those wires. If you have a big enough PLA, you can take any digital logic design, perform some Boolean logic transformations to get it into the best form, then “burn” it into the PLA by blowing the fuses. This is nice because instead of having to custom-design your chip and spend $5 million on making a set of photolithography masks, only one set of masks is ever needed—the one to make the generic PLAs. You can then buy generic PLAs from a mass-producer and turn them into your own chips.</p>&#13;
<h4 class="h4" id="lev117"><span epub:type="pagebreak" id="page_131"/><em>Field Programmable Gate Arrays</em></h4>&#13;
<p class="noindent">A <em>field programmable gate array (FPGA)</em> is similar to a PLA, but you can rewrite it whenever you like with new digital logic rather than only being able to burn it once. This is because rather than physically blowing fuses, FPGAs operate by electronically switching on and off connections between blocks of standard logic. Each of these blocks can be configured to act as some small simple machine. <a href="ch05.xhtml#ch05fig19">Figure 5-19</a> shows an example of this design.</p>&#13;
<div class="image"><img id="ch05fig19" src="../images/f0131-01.jpg" alt="Image" width="350" height="388"/></div>&#13;
<p class="figcap"><em>Figure 5-19: The structure of an FPGA chip, made from configurable blocks and connections between them</em></p>&#13;
<p class="indent">Boolean logic is again used to transform any initial digital logic design into a collection of such simple machines and connections between them. This is almost a software approach, with a list of the connections to enable and disable sent to some firmware memory on the FPGA board, then used to make the electronic configurations.</p>&#13;
<p class="indent">FPGAs are often sold on a development board with extra hardware around the FPGA chip to help connect it to a PC and program it. You can buy cheap, maker-friendly consumer FPGA boards starting at around $30. There are two main manufacturers of FPGAs: Xilinx and Altera (the former is now part of AMD; the latter is now part of Intel). Alternatively, FPGAs intended for use in production can be obtained without any supporting structure, in which case an external programmer machine is needed. FPGAs come in a variety of sizes; the larger of these chips are used for prototyping CPU designs before more expensive ASIC photolithography, while the smaller ones are intended for embedded systems.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05fig20">Figure 5-20</a> shows a typical example layout of some digital logic on a physical FPGA surface, and the development board used to place it there.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_132"/><img id="ch05fig20" src="../images/f0132-01.jpg" alt="Image" width="990" height="429"/></div>&#13;
<p class="figcap"><em>Figure 5-20: A display of the logic configuration inside an FPGA (left) and an FPGA (the large, central chip) on its development board (right)</em></p>&#13;
<p class="indent">When humans lay out digital logic manually, they tend to organize it spatially so that different regions correspond to different structures. Automated layouts, as seen inside the FPGA, tend to be visually unstructured and thus hard or impossible for humans to understand.</p>&#13;
<h3 class="h3" id="lev118">Summary</h3>&#13;
<p class="noindent">Logic gates are abstractions: they’re one way to organize small groups of switches, such as transistors, into functional units. Human designers like to think at this level rather than at the level of switches, so they design circuits using logic gates. Each logic gate is then “compiled” into small groups of switches. (A few professional chip designers really can “see” the logic gates on the silicon. They get so used to looking at the standard patterns of transistors created by the gates that these patterns jump out in their perception. But for the rest of us, we see only the transistors.)</p>&#13;
<p class="indent">Unlike simple switches, logic gates have the key property that their output preserves the same representation as their input. For example, transistor-based logic gates don’t produce lower voltages on their outputs than they receive as input. This means they can be combined into complex logic networks.</p>&#13;
<p class="indent">Claude Shannon showed us that we can use George Boole’s algebra to simplify circuits of logic gates, often reducing the number of gates needed, and replacing all other types of gates with only NAND gates. This reduces the number of transistors that we need to fit onto silicon and simplifies the design.</p>&#13;
<h3 class="h3" id="lev119"><span epub:type="pagebreak" id="page_133"/>Exercises</h3>&#13;
<h4 class="h4a"><strong>Universal Gates</strong></h4>&#13;
<p class="noindent">Work out the truth tables for each of the NAND gate–based circuits in <a href="ch05.xhtml#ch05fig8">Figure 5-8</a>, or otherwise convince yourself that they are equivalent to the standard NOT, AND, and OR gates.</p>&#13;
<h4 class="h4a"><strong>Setting up LogiSim Evolution</strong></h4>&#13;
<p class="noindent">LogiSim Evolution is a graphical digital logic simulator. It was used to create the digital logic circuit figures in this book. It can simulate circuits that you design, and later also transfer them onto real chips.</p>&#13;
<ol class="number">&#13;
<li class="tm">Install and run LogiSim Evolution from <em><a href="https://github.com/logisim-evolution/logisim-evolution">https://github.com/logisim-evolution/logisim-evolution</a></em>.</li>&#13;
<li class="tm">Create a project and play around to create some gates and wires connecting them. Components are connected by clicking the output of one and then the input of another. Activate a component or wire by clicking it. Delete components with the <small>DEL</small> key and the latest wire with <small>ESC</small>. Press the Simulation button to run the simulation. Voltages on the wires are shown as black for 0 and red for 1. Some components can be right-clicked to edit their properties.</li>&#13;
<li class="tm">Use constant inputs and LED outputs to build and test the circuits in <a href="ch05.xhtml#ch05fig14">Figure 5-14</a>.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Simplifying Circuits</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">In LogiSim, use only NAND gates to build each of the other gate types.</li>&#13;
<li class="tm">Use model checking or proof to show why the circuits in the section “Simplifying Logic Circuits Using Boolean Logic” are all equivalent. How would you find the forms on the right of the figures from those on the left? Is there an algorithm guaranteed to give the minimal NAND form?</li>&#13;
<li class="tm">Calculate the truth table for a Boolean function such as <em>W</em>(<em>Y<span class="ob">Z</span></em> + <em><span class="ob">X</span>Y</em>) and check it by building and simulating an equivalent circuit in LogiSim.</li>&#13;
<li class="tm">Use Boolean identities to simplify the function from the previous problem, and build a new LogiSim circuit of the simplified version. Simulate it to check that the truth table remains the same.</li>&#13;
</ol>&#13;
<h3 class="h3" id="lev120"><span epub:type="pagebreak" id="page_134"/>Further Reading</h3>&#13;
<ul class="bullet">&#13;
<li class="tm">To learn about Boole’s logic (and theology) straight from the source, see George Boole, <em>The Laws of Thought</em> (1854), <em><a href="https://www.gutenberg.org/ebooks/15114">https://www.gutenberg.org/ebooks/15114</a></em>.</li>&#13;
<li class="tm">For arguably the greatest master’s thesis of all time, see Claude Shannon, “A Symbolic Analysis of Relay and Switching Circuits” (master’s thesis, MIT, 1940), <em><a href="https://dspace.mit.edu/handle/1721.1/11173#files-area">https://dspace.mit.edu/handle/1721.1/11173#files-area</a></em>.</li>&#13;
</ul>&#13;
</div>
</div>
</body></html>