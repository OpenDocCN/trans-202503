["```\n\n\t\t\twhile( a < b ) do begin\n\n  << Statements to execute if a is less than b.\n     Presumably, these statements modify the value\n     of either a or b so that this loop ultimately\n     terminates. >>\n\nend; (* while *)\n<< statements that execute when a is not less than b >>\n```", "```\n\n\t\t\t// while loop:\n\nwhile( x < y )\n{\n  arr[x] = y;\n  ++x;\n}\n\n// Conversion to an if and a goto:\n\nwhlLabel:\nif( x < y )\n{\n  arr[x] = y;\n  ++x;\n  goto whlLabel;\n}\n```", "```\n\n\t\t\t  // while( x < y )\n\nwhlLabel:\n    mov( x, eax );\n    cmp( eax, y );\n    jnl exitWhile;  // jump to exitWhile label if\n                    // x is not less than y\n\n    mov( y, edx );\n    mov( edx, arr[ eax*4 ] );\n    inc( x );\n    jmp whlLabel;\nexitWhile:\n```", "```\n\n\t\t\t// while( x < y )\n\n    // Skip over the while loop's body.\n\n    jmp testExpr;\n\nwhlLabel:\n    // This is the body of the while loop (same as\n    // before, except moved up a few instructions).\n\n    mov( y, edx );\n    mov( edx, arr[ eax*4 ] );\n    inc( x );\n\n// Here is where we test the expression to\n// determine if we should repeat the loop body.\n\ntestExpr:\n    mov( x, eax );\n    cmp( eax, y );\n    jl whlLabel;    // Transfer control to loop body if x < y.\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\n/*\n** Complete Boolean evaluation\n** for the expression:\n** i < g(y) || k > f(x)\n*/\n\nint func( void )\n{\n    int temp;\n    int temp2;\n\n    temp = i < g(y);\n    temp2 = k > f(x);\n    return temp || temp2;\n}\n\nint main( void )\n{\n    /*\n    ** The following while loop\n    ** uses complete Boolean evaluation\n    */\n\n    while( func() )\n    {\n      IntoIF:\n\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tfunc:\n.LFB0:\n        pushq   %rbp\n        movq    %rsp, %rbp\n        subq    $16, %rsp\n        movl    y(%rip), %eax\n        movl    %eax, %edi\n        call    g\n        movl    %eax, %edx\n        movl    i(%rip), %eax\n        cmpl    %eax, %edx\n        setg    %al\n        movzbl  %al, %eax\n        movl    %eax, -8(%rbp)\n        movl    x(%rip), %eax\n        movl    %eax, %edi\n        call    f\n        movl    %eax, %edx\n        movl    k(%rip), %eax\n        cmpl    %eax, %edx\n        setl    %al\n        movzbl  %al, %eax\n        movl    %eax, -4(%rbp)\n        cmpl    $0, -8(%rbp)\n        jne     .L2\n        cmpl    $0, -4(%rbp)\n        je      .L3\n.L2:\n        movl    $1, %eax\n        jmp     .L4\n.L3:\n        movl    $0, %eax\n.L4:\n        leave\n        ret\n.LFE0:\n        .size   func, .-func\n        .section        .rodata\n.LC0:\n        .string \"Hello\"\n        .text\n        .globl  main\n        .type   main, @function\nmain:\n.LFB1:\n        pushq   %rbp\n        movq    %rsp, %rbp\n        jmp     .L7\n.L8:\n        movl    $.LC0, %edi\n        movl    $0, %eax\n        call    printf\n.L7:\n        call    func\n        testl   %eax, %eax\n        jne     .L8\n        movl    $0, %eax\n        popq    %rbp\n        ret\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\ninline int func( void )\n{\n    int temp;\n    int temp2;\n\n    temp = i < g(y);\n    temp2 = k > f(x);\n    return temp || temp2;\n}\n\nint main( void )\n{\n    while( func() )\n    {\n      IntoIF:\n\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain:\n        pushl   %ebp\n        movl    %esp, %ebp\n        pushl   %ebx\n        pushl   %ecx\n        andl    $-16, %esp\n        .p2align 2,,3\n.L2:\n        subl    $12, %esp\n\n; while( i < g(y) || k > f(x) )\n;\n; Compute g(y) into %EAX:\n\n        pushl   y\n        call    g\n        popl    %edx\n        xorl    %ebx, %ebx\n        pushl   x\n\n; See if i < g(y) and leave Boolean result\n; in %EBX:\n\n        cmpl    %eax, i\n        setl    %bl\n\n; Compute f(x) and leave result in %EAX:\n\n        call    f                ; Note that we call f, even if the\n        addl    $16, %esp        ; above evaluates to true\n\n; Compute k > f(x), leaving the result in %EAX.\n\n        cmpl    %eax, k\n        setg    %al\n\n; Compute the logical OR of the above two expressions.\n\n        xorl    %edx, %edx\n        testl   %ebx, %ebx\n        movzbl  %al, %eax\n        jne     .L6\n        testl   %eax, %eax\n        je      .L7\n.L6:\n        movl    $1, %edx\n.L7:\n        testl   %edx, %edx\n        je      .L10\n.L8:\n\n; Loop body:\n\n        subl    $12, %esp\n        pushl   $.LC0\n        call    printf\n        addl    $16, %esp\n        jmp     .L2\n.L10:\n        xorl    %eax, %eax\n        movl    -4(%ebp), %ebx\n        leave\n        ret\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    // Use \"|\" rather than \"||\"\n    // to force complete Boolean\n    // evaluation here.\n\n    while( i < g(y) | k > f(x) )\n    {\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\t_main   proc    near\n?live1@0:\n   ;\n   ;    int main( void )\n   ;\n@1:\n        push      ebx\n        jmp       short @3 ; Skip to expr test.\n   ;\n   ;    {\n   ;            while( i < g(y) | k > f(x) )\n   ;            {\n   ;                    printf( \"Hello\" );\n   ;\n@2:\n        ; Loop body.\n\n        push      offset s@\n        call      _printf\n        pop       ecx\n\n; Here's where the test of the expression\n; begins:\n\n@3:\n        ; Compute \"i < g(y)\" into ebx:\n\n        mov       eax,dword ptr [_y]\n        push      eax\n        call      _g\n        pop       ecx\n        cmp       eax,dword ptr [_i]\n        setg      bl\n        and       ebx,1\n\n        ;  Compute \"k > f(x)\" into EDX:\n\n        mov       eax,dword ptr [_x]\n        push      eax\n        call      _f\n        pop       ecx\n        cmp       eax,dword ptr [_k]\n        setl      dl\n        and       edx,1\n        ; Compute the logical OR of\n        ; the two results above:\n\n        or        ebx,edx\n\n        ; Repeat loop body if true:\n\n        jne       short @2\n   ;\n   ;            }\n   ;\n   ;            return( 0 );\n   ;\n        xor       eax,eax\n   ;\n   ;    }\n   ;\n@5:\n@4:\n        pop       ebx\n        ret\n_main   endp\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i;\nstatic int k;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    int temp;\n    int temp2;\n for( ;; )                 //Infinite loop in C/C++\n    {\n        temp = i < g(y);\n        temp2 = k > f(x);\n        if( !temp && !temp2 ) break;\n        printf( \"Hello\" );\n    }\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tmain    PROC\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 16\n$LN9:\n        sub     rsp, 56                                 ; 00000038H\n\n; Infinite loop jumps here:\n\n$LN2@main:\n; Line 21\n;\n; temp = i < g(y);\n;\n        mov     ecx, DWORD PTR ?y@@3HA                  ; y\n        call    ?g@@YAHH@Z                              ; g\n\n; compute i < g(y) and leave result in eax:\n\n        cmp     DWORD PTR ?i@@3HA, eax\n        jge     SHORT $LN5@main\n        mov     DWORD PTR tv67[rsp], 1\n        jmp     SHORT $LN6@main\n$LN5@main:\n        mov     DWORD PTR tv67[rsp], 0\n\n$LN6@main:\n\n; temp2 = k > f(x);\n\n        mov     ecx, DWORD PTR ?x@@3HA                  ; x\n        call    ?f@@YAHH@Z                              ; f\n\n; compute k > f(x) and leave result in eax:\n\n        cmp     DWORD PTR ?k@@3HA, eax\n        jle     SHORT $LN7@main\n        mov     DWORD PTR tv71[rsp], 1\n        jmp     SHORT $LN8@main\n$LN7@main:\n        mov     DWORD PTR tv71[rsp], 0\n$LN8@main:\n\n; if( !temp && !temp2 ) break;\n\n        or      ecx, eax\n        mov     eax, ecx\n        test    eax, eax\n        je      SHORT $LN3@main\n; Line 23\n        lea     rcx, OFFSET FLAT:$SG6924\n        call    printf\n\n; Jump back to beginning of for(;;) loop.\n;\n; Line 24\n        jmp     SHORT $LN2@main\n\n$LN3@main:\n; Line 26\n        xor     eax, eax\n; Line 27\n        add     rsp, 56                                 ; 00000038H\n        ret     0\nmain    ENDP\n```", "```\n\n\t\t\twhile( ptr != NULL && ptr->data != 0 )\n{\n    << loop body >>\n    ptr = ptr->Next; // Step through a linked list.\n}\n```", "```\n\n\t\t\tprogram shortcircuit;\n{$APPTYPE CONSOLE}\nuses SysUtils;\nvar\n    ptr     :Pchar;\n\n    function shortCir( thePtr:Pchar ):boolean;\n    begin\n\n        shortCir := false;\n        if( thePtr <> NIL ) then begin\n\n            shortCir := thePtr^ <> #0;\n\n        end; //if\n\n    end;  // shortCircuit\n\nbegin\n\n    ptr := 'Hello world';\n    while( shortCir( ptr )) do begin\n\n        write( ptr^ );\n        inc( ptr );\n\n    end; // while\n    writeln;\n\nend.\n```", "```\n\n\t\t\t; function shortCir( thePtr:Pchar ):boolean\n;\n; Note: thePtr is passed into this function in\n; the EAX register.\n\nsub_408570  proc near\n\n            ; EDX holds function return\n            ; result (assume false).\n            ;\n            ; shortCir := false;\n\n            xor     edx, edx\n\n            ; if( thePtr <> NIL ) then begin\n\n            test    eax, eax\n            jz      short loc_40857C    ; branch if NIL\n\n            ; shortCir := thePtr^ <> #0;\n\n            cmp     byte ptr [eax], 0\n            setnz   dl  ; DL = 1 if not #0\n\nloc_40857C:\n\n            ; Return result in EAX:\n\n            mov     eax, edx\n            retn\nsub_408570  endp\n\n; Main program (pertinent section):\n;\n; Load EBX with the address of the global \"ptr\" variable and\n; then enter the \"while\" loop (Delphi moves the test for the\n; while loop to the physical end of the loop's body):\n\n                mov     ebx, offset loc_408628\n                jmp     short loc_408617\n; --------------------------------------------------------\n\nloc_408600:\n                ; Print the current character whose address\n                ; \"ptr\" contains:\n\n                mov     eax, ds:off_4092EC  ; ptr pointer\n                mov     dl, [ebx]           ; fetch char\n                call    sub_404523          ; print char\n                call    sub_404391\n                call    sub_402600\n\n                inc     ebx                 ; inc( ptr )\n\n; while( shortCir( ptr )) do ...\n\nloc_408617:\n                mov     eax, ebx         ; Pass ptr in EAX\n                call    sub_408570       ; shortCir\n                test    al, al           ; Returns true/false\n                jnz     short loc_408600 ; branch if true\n```", "```\n\n\t\t\t    while( true ) do begin\n\n        if( ptr = NIL ) then goto 2;\n        if( ptr^.data = 0 ) then goto 2;\n        << loop body >>\n        ptr := ptr^.Next;\n\n    end;\n2:\n```", "```\n\n\t\t\trepeat\n\n      write( 'Enter a value (negative quits): ');\n      readln( i );\n      // do something with i's value\n\nuntil( i < 0 );\n```", "```\n\n\t\t\trepeat\n\n    (* Read a raw character from the \"input\" file, which in this case is the keyboard *)\n\n    ch := rawInput( input );\n\n    (* Save the character away. *)\n\n    inputArray[ i ] := ch;\n    i := i + 1;\n\n    (* Repeat until the user hits the enter key *)\n\nuntil( ch = chr( 13 ));\n```", "```\n\n\t\t\tdo\n{\n    /* Read a raw character from the \"input\" file, which in this case is the keyboard */\n\n    ch = getKbd();\n\n    /* Save the character away. */\n inputArray[ i++ ] = ch;\n\n    /* Repeat until the user hits the enter key */\n}\nwhile( ch != '\\r' );\n```", "```\n\n\t\t\trepeat\n\n    // Read a character from the standard input device.\n\n    stdin.getc();\n\n    // Save the character away.\n\n    mov( al, inputArray[ ebx ] );\n    inc( ebx );\n\n    // Repeat until the user hits the enter key.\n\nuntil( al = stdio.cr );\n```", "```\n\n\t\t\trptLoop:\n\n    // Read a character from the standard input.\n\n    call stdin.getc;\n\n    // Store away the character.\n\n    mov( al, inputArray[ ebx ] );\n    inc( ebx );\n\n    // Repeat the loop if the user did not hit\n    // the enter key.\n\n    cmp( al, stdio.cr );\n    jne rptLoop;\n```", "```\n\n\t\t\ti = 0;\nwhile( i < 100 )\n{\n      printf( \"i: %d\\n\", i );\n      i = i * 2 + 1;\n      if( i < 50 )\n      {\n            i += j;\n      }\n}\n```", "```\n\n\t\t\ti = 0;\ndo\n{\n      printf( \"i: %d\\n\", i );\n      i = i * 2 + 1;\n      if( i < 50 )\n      {\n            i += j;\n      }\n} while( i < 100 );\n```", "```\n\n\t\t\textern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\nextern int a;\nextern int b;\nint main( void )\n{\n\n    do\n        {\n            ++a;\n            --b;\n        }while( a < f(x) && b > g(y));\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tL2:\n        // ++a\n        // --b\n\n        lwz r9,0(r30)  ; get a\n        lwz r11,0(r29) ; get b\n        addi r9,r9,-1  ; --a\n        lwz r3,0(r27)  ; Set up x parm for f\n        stw r9,0(r30)  ; store back into a\n        addi r11,r11,1 ; ++b\n        stw r11,0(r29) ; store back into b\n\n        ; compute f(x)\n\n        bl L_f$stub    ; call f, result to R3\n\n        ; is a >= f(x)? If so, quit loop\n\n        lwz r0,0(r29)  ; get a\n        cmpw cr0,r0,r3 ; Compare a with f's value\n        bge- cr0,L3\n\n        lwz r3,0(r28)  ; Set up y parm for g\n        bl L_g$stub    ; call g\n\n        lwz r0,0(r30)  ; get b\n        cmpw cr0,r0,r3 ; Compare b with g's value\n        bgt+ cr0,L2    ; Repeat if b > g's value\nL3:\n```", "```\n\n\t\t\tstatic int a;\nstatic int b;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    int temp1;\n    int temp2;\n\n    do\n        {\n            ++a;\n            --b;\n            temp1 = a < f(x);\n            temp2 = b > g(y);\n        }while( temp1 && temp2 );\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tL2:\n        lwz r9,0(r30)    ; r9 = b\n        li r28,1         ; temp1 = true\n        lwz r11,0(r29)   ; r11 = a\n        addi r9,r9,-1    ; --b\n        lwz r3,0(r26)    ; r3 = x (set up f's parm)\n        stw r9,0(r30)    ; Save b\n        addi r11,r11,1   ; ++a\n        stw r11,0(r29)   ; Save a\n        bl L_f$stub      ; Call f\n        lwz r0,0(r29)    ; Fetch a\n        cmpw cr0,r0,r3   ; Compute temp1 = a < f(x)\n        blt- cr0,L5      ; Leave temp1 true if a < f(x)\n        li r28,0         ; temp1 = false\nL5:\n        lwz r3,0(r27)    ; r3 = y, set up g's parm\n        bl L_g$stub      ; Call g\n        li r9,1          ; temp2 = true\n        lwz r0,0(r30)    ; Fetch b\n        cmpw cr0,r0,r3   ; Compute b > g(y)\n        bgt- cr0,L4      ; Leave temp2 true if b > g(y)\n        li r9,0          ; Else set temp2 false\nL4:\n        ; Here's the actual termination test in\n        ; the while clause:\n\n        cmpwi cr0,r28,0\n        beq- cr0,L3\n        cmpwi cr0,r9,0\n        bne+ cr0,L2\nL3:\n```", "```\n\n\t\t\tdo\n{\n    ++a;\n    --b;\n    temp1 = a < f(x);\n    temp2 = b > g(y);\n\n}while( temp1 && temp2 );\n```", "```\n\n\t\t\tstatic int a;\nstatic int b;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    do\n    {\n        ++a;\n        --b;\n\n        if( !( a < f(x) )) break;\n    } while( b > g(y) );\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tL2:\n        lwz r9,0(r30)   ; r9 = b\n        lwz r11,0(r29)  ; r11 = a\n        addi r9,r9,-1   ; --b\n        lwz r3,0(r27)   ; Set up f(x) parm\n        stw r9,0(r30)   ; Save b\n        addi r11,r11,1  ; ++a\n        stw r11,0(r29)  ; Save a\n        bl L_f$stub     ; Call f\n\n        ; break if !(a < f(x)):\n\n        lwz r0,0(r29)\n        cmpw cr0,r0,r3\n        bge- cr0,L3\n\n        ; while( b > g(y) ):\n\n        lwz r3,0(r28)   ; Set up y parm\n        bl L_g$stub     ; Call g\n        lwz r0,0(r30)   ; Compute b > g(y)\n        cmpw cr0,r0,r3\n        bgt+ cr0,L2     ; Branch if true\nL3:\n```", "```\n\n\t\t\tstatic int a;\nstatic int b;\n\nextern int x;\nextern int y;\nextern int f( int );\nextern int g( int );\n\nint main( void )\n{\n    int temp;\n\n    do\n    {\n        ++a;\n        --b;\n        temp = a < f(x);\n        if( temp )\n        {\n            temp = b > g(y);\n        };\n    }while( temp );\n\n    return( 0 );\n}\n```", "```\n\n\t\t\tL2:\n        lwz r9,0(r30)   ; r9 = b\n        lwz r11,0(r29)  ; r11 = a\n        addi r9,r9,-1   ; --b\n        lwz r3,0(r27)   ; Set up f(x) parm\n        stw r9,0(r30)   ; Save b\n        addi r11,r11,1  ; ++a\n        stw r11,0(r29)  ; Save a\n        bl L_f$stub     ; Call f\n        li r9,1         ; Assume temp is true\n        lwz r0,0(r29)   ; Set temp false if\n        cmpw cr0,r0,r3  ; a < f(x)\n        blt- cr0,L5\n        li r9,0\nL5:\n        cmpwi cr0,r9,0  ; If !(a < f(x)) then bail\n        beq- cr0,L10    ; on the do..while loop\n        lwz r3,0(r28)   ; Compute temp = b > f(y)\n        bl L_g$stub     ; using a code sequence\n        li r9,1         ; that is comparable to\n        lwz r0,0(r30)   ; the above.\n        cmpw cr0,r0,r3\n        bgt- cr0,L9\n        li r9,0\nL9:\n        ; Test the while termination expression:\n\n        cmpwi cr0,r9,0\n        bne+ cr0,L2\nL10:\n```", "```\n\n\t\t\trepeat\n\n      a := a + 1;\n      b := b - 1;\n\nuntil( (a < f(x)) OR (b > g(y)) );\n```", "```\n\n\t\t\trepeat\n\n      a := a + 1;\n      b := b - 1;\n      temp := a < f(x);\n      if( not temp ) then begin\n\n            temp := b > g(y);\n\n    end;\nuntil( temp );\n```", "```\n\n\t\t\t;    repeat\n;\n;        a := a + 1;\n;        b := b - 1;\n;\n;    until( (a < f(x)) or (b > g(y)));\n\nloc_4085F8:\n                inc     ebx                  ; a := a + 1;\n                dec     esi                  ; b := b - 1;\n                mov     eax, [edi]           ; EDI points at x\n                call    locret_408570\n                cmp     ebx, eax             ; Set AL to 1 if\n                setl    al                   ; a < f(x)\n                push    eax                  ; Save Boolean result.\n\n                mov     eax, ds:dword_409288 ; y\n                call    locret_408574        ; g(6)\n\n                cmp     esi, eax             ; Set AL to 1 if\n                setnle  al                   ; b > g(y)\n                pop     edx                  ; Retrieve last value.\n                or      dl, al               ; Compute their OR\n                jz      short loc_4085F8     ; Repeat if false.\n\n;    repeat\n;\n;        a := a + 1;\n;        b := b - 1;\n;        temp := a < f(x);\n;        if( not temp ) then begin\n;\n;            temp := b > g(y);\n;\n;        end;\n;\n;    until( temp );\nloc_40861B:\n                inc     ebx                  ; a := a + 1;\n                dec     esi                  ; b := b - 1;\n                mov     eax, [edi]           ; Fetch x\n                call    locret_408570        ; call f\n                cmp     ebx, eax             ; is a < f(x)?\n                setl    al                   ; Set AL to 1 if so.\n\n            ; If the result of the above calculation is\n            ; true, then don't bother with the second\n            ; test (that is, short-circuit evaluation)\n\n                test    al, al\n                jnz     short loc_40863C\n\n            ; Now check to see if b > g(y)\n\n                mov     eax, ds:dword_409288\n                call    locret_408574\n\n            ; Set AL = 1 if b > g(y):\n\n                cmp     esi, eax\n                setnle  al\n\n; Repeat loop if both conditions were false:\n\nloc_40863C:\n                test    al, al\n                jz      short loc_40861B\n```", "```\n\n\t\t\tloc_4085F8:\n                inc     ebx\n                dec     esi\n                mov     eax, [edi]\n                call    nullsub_1 ;f\n                cmp     ebx, eax\n                jl      short loc_408613\n                mov     eax, ds:dword_409288\n                call    nullsub_2 ;g\n                cmp     esi, eax\n                jle     short loc_4085F8\n```", "```\n\n\t\t\tconst\n    forever = true;\n        .\n        .\n        .\n    while( forever ) do begin\n\n        << code to execute in an infinite loop >>\n\n    end;\n```", "```\n\n\t\t\tfor(;;)\n{\n    << code to execute in an infinite loop >>\n}\n```", "```\n\n\t\t\tfor(;;)\n{\n    << Code to execute (at least once)\n       prior to the termination test >>\n\n    if( termination_expression ) break;\n\n    << Code to execute after the loop termination test >>\n}\n```", "```\n\n\t\t\tforever\n\n    << Code to execute (at least once) prior to\n       the termination test >>\n\n    breakif( termination_expression );\n\n    << Code to execute after the loop termination test >>\n\nendfor;\n```", "```\n\n\t\t\t// High-level forever statement in HLA:\n\nforever\n\n    stdout.put\n    (\n     \"Enter an unsigned integer less than five:\"\n    );\n    stdin.get( u );\n    breakif( u < 5);\n    stdout.put\n    (\n      \"Error: the value must be between zero and five\" nl\n    );\nendfor;\n\n// Low-level coding of the forever loop in HLA:\n\nforeverLabel:\n    stdout.put\n    (\n      \"Enter an unsigned integer less than five:\"\n    );\n    stdin.get( u );\n    cmp( u, 5 );\n    jbe endForeverLabel;\n    stdout.put\n    (\n      \"Error: the value must be between zero and five\" nl\n    );\n    jmp foreverLabel;\n\nendForeverLabel:\n```", "```\n\n\t\t\t// Low-level coding of the forever loop in HLA\n// using code rotation:\n\njmp foreverEnter;\nforeverLabel:\n        stdout.put\n        (\n          \"Error: the value must be between zero and five\"\n          nl\n        );\n    foreverEnter:\n        stdout.put\n        (\n          \"Enter an unsigned integer less \"\n          \"than five:\"\n        );\n        stdin.get( u );\n        cmp( u, 5 );\n        ja foreverLabel;\n```", "```\n\n\t\t\tfor variable := expr1 to expr2 do\n        statement\n```", "```\n\n\t\t\tfor variable := expr1 downto expr2 do\n        statement\n```", "```\n\n\t\t\tfor i := 1 to 10 do\n    writeln( 'hello world');\n```", "```\n\n\t\t\twrite( 'Enter an integer:');\nreadln( cnt );\nfor i := 1 to cnt do\n    writeln( 'Hello World');\n```", "```\n\n\t\t\tfor i := 1 to j do begin\n\n    << some statements >>\n    i := <<some value>>;\n    << some other statements >>\n\nend;\n```"]