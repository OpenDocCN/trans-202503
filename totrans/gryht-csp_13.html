<html><head></head><body>
<p id="filepos895366" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">14</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">READING OFFLINE REGISTRY HIVES</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">The Windows NT registry is a gold mine of information for useful data such as patch levels and password hashes. And that information isn’t just useful for offensive pentesters looking to exploit a network; it’s also useful for anyone in the incident response or data forensics area of information security.</p><p class="calibre_6">Say, for example, you’re handed the hard drive of a computer that has been breached and you need to find out what happened. What do you do? Being able to read key information from the hard drive regardless of whether Windows can run is imperative. The Windows registry is actually a collection of files on the disk, called <span class="italic">registry hives</span>, and learning your way around the registry hives will allow you to better use these hives that hold so much useful information. Registry hives are also a great introduction to parsing binary file formats, which are made to store data efficiently for computers but are not so great for human consumption.</p><p class="calibre_6"> In this chapter, we discuss the Windows NT registry hive data structure, and we write a small library with a few classes to read offline hives from which we can extract useful information, such as the boot key. This is useful if you want to extract password hashes from the registry later.</p><p id="filepos897053" class="calibre_10"><span class="calibre3"><span class="bold">The Registry Hive Structure</span></span></p><p class="calibre_11">At a high level, the registry hive is a tree of nodes. Each node may have key/value pairs, and it may have child nodes. We’ll use the terms <span class="italic">node key</span> and <span class="italic">value key</span> to classify the two types of data in the registry hive and create classes for both key types. Node keys contain information about the structure of the tree and its subkeys, whereas value keys hold value information that applications access. Visually, the tree looks a bit like <a href="#filepos897813">Figure 14-1</a>.</p><p class="calibre_22"><img src="images/00002.jpg" class="calibre_41"/></p><p id="filepos897813" class="calibre_15"><span class="calibre4"><span class="italic">Figure 14-1: A visual representation of a simple registry tree with nodes, keys, and values</span></span></p><p class="calibre_6">Every node key has some specific metadata stored alongside it, such as the last time its value keys were modified and other system-level information. All of this data is stored very efficiently for a computer to read—but not for a human. While we implement our library, we’ll skip over some of this metadata in order to make the end result simpler, but I will call these instances out as we go.</p><p class="calibre_6">As you can see in <a href="#filepos897813">Figure 14-1</a>, after the registry header, the node tree begins with the root node key. The root node key has two child nodes, which in this example we call <span class="calibre4">Foo</span> and <span class="calibre4">Bar</span>. The <span class="calibre4">Foo</span> node key contains two value keys, <span class="calibre4">Baz</span> and <span class="calibre4">Bat</span>, which have values of <span class="calibre4">true</span> and <span class="calibre4">"AHA"</span>, respectively. <span class="calibre4">Bar</span>, on the other hand, only has child node <span class="calibre4">BarBuzz</span>, which has a single value key. This example of a registry hive tree is very contrived and simple. The registry hives on your machine are more complex and likely have millions of keys!</p><p id="filepos899222" class="calibre_10"><span class="calibre3"><span class="bold">Getting the Registry Hives</span></span></p><p class="calibre_11">During normal operation, Windows locks the registry hives to prevent tampering. Altering the Windows registry can have potentially devastating results, such as an unbootable computer, so it’s not something to take lightly. You can, however, use <span class="calibre4">cmd.exe</span> to export a given registry hive if you have Administrator access to the machine. Windows ships with <span class="calibre4">reg.exe</span>, which is a useful command line utility for reading and writing to the registry. We can use this tool to copy the hives that we’re interested in so that we can read them offline, as shown in <a href="#filepos900511">Listing 14-1</a>. This will prevent any accidental catastrophes.</p><blockquote class="calibre_14"><span class="calibre4"> Microsoft Windows [Version 6.1.7601]</span><br class="calibre5"/><span class="calibre4">Copyright (c) 2009 Microsoft Corporation. All rights reserved.</span><br class="calibre5"/><span class="calibre4">C:\Windows\system32&gt;</span><span class="calibre4"><span class="bold">reg</span></span><span class="calibre4"> ➊</span><span class="calibre4"><span class="bold">save HKLM\System C:\system.hive</span></span><br class="calibre5"/><span class="calibre4">The operation completed successfully.</span></blockquote><p id="filepos900511" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-1: Using</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">reg.exe</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">to copy a registry hive</span></span></p><p class="calibre_6">Using the <span class="calibre4">save</span> subcommand ➊, we specify the registry path we want to save as well as the file to save to. The first argument is the <span class="calibre4">HKLM\System</span> path, which is the root registry node for the system registry hive (where information such as the boot key resides). By choosing this registry path, we save a copy of the system’s registry hive off the machine for further analysis later. This same technique can be used for <span class="calibre4">HKLM\Sam</span> (where usernames and hashes are stored) and <span class="calibre4">HKLM\Software</span> (where patch levels and other software information are stored). But remember, saving these nodes requires administrator access!</p><p class="calibre_6">There’s also another method for getting the registry hives if you have a hard drive you can mount on your machine. You can simply copy the registry hives from the <span class="italic">System32</span> folder where the raw hives are stored by the operating system. If Windows isn’t running, the hives won’t be locked, and you should be able to copy them to another system. You can find the raw hives currently in use by the operating system in the directory <span class="italic">C:\Windows\ System32\config</span> (see <a href="#filepos903808">Listing 14-2</a>).</p><blockquote class="calibre_14"><span class="calibre4">Microsoft Windows [Version 6.1.7601]</span><br class="calibre5"/><span class="calibre4">Copyright (c) 2009 Microsoft Corporation. All rights reserved.</span><br class="calibre5"/><span class="calibre4">C:\Windows\system32&gt;</span><span class="calibre4"><span class="bold">cd config</span></span><br class="calibre5"/><span class="calibre4">C:\Windows\System32\config&gt;</span><span class="calibre4"><span class="bold">dir</span></span><br class="calibre5"/><span class="calibre4">Volume in drive C is BOOTCAMP</span><br class="calibre5"/><span class="calibre4">Volume Serial Number is B299-CCD5</span><br class="calibre5"/><span class="calibre4">Directory of C:\Windows\System32\config</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:17 PM &lt;DIR&gt; .</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:17 PM &lt;DIR&gt; ..</span><br class="calibre5"/><span class="calibre4">05/23/2014 03:19 AM 28,672 BCD-Template</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:24 PM 60,555,264 COMPONENTS</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:24 PM 4,456,448 DEFAULT</span><br class="calibre5"/><span class="calibre4">07/13/2009 08:34 PM &lt;DIR&gt; Journal</span><br class="calibre5"/><span class="calibre4">09/21/2015 05:56 PM 42,909,696 prl_boot</span><br class="calibre5"/><span class="calibre4">01/19/2016 12:17 AM &lt;DIR&gt; RegBack</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:13 PM 262,144 SAM</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:24 PM 262,144 SECURITY ➊</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:36 PM 115,867,648 SOFTWARE ➋</span><br class="calibre5"/><span class="calibre4">01/24/2016 02:33 PM 15,728,640 SYSTEM ➌</span><br class="calibre5"/><span class="calibre4">06/22/2014 06:13 PM &lt;DIR&gt; systemprofile</span><br class="calibre5"/><span class="calibre4">05/24/2014 10:45 AM &lt;DIR&gt; TxR</span><br class="calibre5"/><span class="calibre4">8 File(s) 240,070,656 bytes</span><br class="calibre5"/><span class="calibre4">6 Dir(s) 332,737,015,808 bytes free</span><br class="calibre5"/><span class="calibre4">C:\Windows\System32\config&gt;</span></blockquote><p id="filepos903808" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-2: The contents of the</span></span><span class="calibre4"> C:\Windows\System32\config </span><span class="calibre4"><span class="italic">folder with registry hives</span></span></p><p class="calibre_6">
<a href="#filepos903808">Listing 14-2</a> shows the registry hives in the directory. The <span class="calibre4">SECURITY</span> ➊, <span class="calibre4">SOFTWARE</span> ➋, and <span class="calibre4">SYSTEM</span> ➌ hives are the ones with the most commonly sought information. Once hives are copied onto your system, you can easily verify that you have saved the registry hives you want to read with the <span class="calibre4">file</span> command if you are using Linux or OS X, as shown in <a href="#filepos904821">Listing 14-3</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">file system.hive</span></span><br class="calibre5"/><span class="calibre4">system.hive: MS Windows registry file, NT/2000 or above</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos904821" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-3: Confirming which registry hive you saved in Linux or OS X</span></span></p><p class="calibre_6">Now we’re ready to start digging into a hive.</p><p id="filepos905061" class="calibre_10"><span class="calibre3"><span class="bold">Reading the Registry Hive</span></span></p><p class="calibre_11">We’ll start by reading the registry hive header, a 4,096-byte chunk of data at the beginning of the registry hive. Don’t worry, only the first 20 bytes or so are actually useful for parsing, and we’ll only read the first four to verify the file is a registry hive. The remaining 4,000+ bytes are just buffer.</p><p id="filepos905522" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a Class to Parse a Registry Hive File</span></span></span></p><p class="calibre_11">We’ll create a new class to begin parsing the file: the <span class="calibre4">RegistryHive</span> class. This is one of the simpler classes we’ll implement in order to read offline registry hives. It has only a constructor and a few properties, as shown in <a href="#filepos907483">Listing 14-4</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class RegistryHive</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public ➊RegistryHive(string file)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (!➋File.Exists(file))</span><br class="calibre5"/><span class="calibre4"> throw new FileNotFoundException();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.Filepath = file;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (FileStream stream = ➌File.OpenRead(file))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (BinaryReader reader = new ➍BinaryReader(stream))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> byte[] buf = reader.ReadBytes(4);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if ➎(buf[0] != 'r' || buf[1] != 'e' || buf[2] != 'g' || buf[3] != 'f')</span><br class="calibre5"/><span class="calibre4"> throw new NotSupportedException("File not a registry hive.");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> //fast-forward</span><br class="calibre5"/><span class="calibre4"> ➏reader.BaseStream.Position = 4096 + 32 + 4;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.RootKey = new ➐NodeKey(reader);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Filepath { get; set; }</span><br class="calibre5"/><span class="calibre4"> public NodeKey RootKey { get; set; }</span><br class="calibre5"/><span class="calibre4"> public bool WasExported { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos907483" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-4: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">RegistryHive</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Let’s look at the constructor where the magic first happens. The constructor ➊ accepts a single argument, which is the file path to the offline registry hive on the filesystem. We check whether the path exists using <span class="calibre4">File.Exists()</span> ➋, and we throw an exception if it doesn’t.</p><p class="calibre_6">Once we have determined the file exists, we need to make sure it is a registry file. But this is not hard. The first four magic bytes of any registry hive should be <span class="calibre4">r</span>, <span class="calibre4">e</span>, <span class="calibre4">g</span>, and <span class="calibre4">f</span>. To check whether our file matches, we open a stream to read the file using <span class="calibre4">File.OpenRead()</span> ➌. Then we create a new <span class="calibre4">BinaryReader</span> ➍ by passing the file stream to the <span class="calibre4">BinaryReader</span> constructor. We use this to read the first four bytes of the file and store them in a byte array. Then, we check whether they match ➎. If they don’t, we throw an exception: the hive is either too damaged to be read normally or is not a hive at all!</p><p class="calibre_6">If the header checks out, though, we fast-forward ➏ to the end of the registry header block to the root node key (skipping some metadata we don’t need at the moment). In the next section, we create a <span class="calibre4">NodeKey</span> class to handle our node keys so we can read the key by passing the <span class="calibre4">BinaryReader</span> to a <span class="calibre4">NodeKey</span> constructor ➐, and we assign the new <span class="calibre4">NodeKey</span> to the <span class="calibre4">RootKey</span> property for later use.</p><p id="filepos909411" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a Class for Node Keys</span></span></span></p><p class="calibre_11">The <span class="calibre4">NodeKey</span> class is the most complex class we need to implement to read the offline registry hive. There is a bit of metadata stored in the registry hive for node keys that we can skip, but there’s a lot that we can’t. However, the constructor for the <span class="calibre4">NodeKey</span> class is quite simple, though it has quite a few properties, as <a href="#filepos911598">Listing 14-5</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">public class NodeKey</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public ➊NodeKey(BinaryReader hive)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ReadNodeStructure(hive);</span><br class="calibre5"/><span class="calibre4"> ReadChildrenNodes(hive);</span><br class="calibre5"/><span class="calibre4"> ReadChildValues(hive);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public List&lt;NodeKey&gt; ➋ChildNodes { get; set; }</span><br class="calibre5"/><span class="calibre4"> public List&lt;ValueKey&gt; ➌ChildValues { get; set; }</span><br class="calibre5"/><span class="calibre4"> public DateTime ➍Timestamp { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ParentOffset { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int SubkeysCount { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int LFRecordOffset { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ClassnameOffset { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int SecurityKeyOffset { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ValuesCount { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ValueListOffset { get; set; }</span><br class="calibre5"/><span class="calibre4"> public short NameLength { get; set; }</span><br class="calibre5"/><span class="calibre4"> public bool IsRootKey { get; set; }</span><br class="calibre5"/><span class="calibre4"> public short ClassnameLength { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public byte[] ClassnameData { get; set; }</span><br class="calibre5"/><span class="calibre4"> public NodeKey ParentNodeKey { get; set; }</span></blockquote><p id="filepos911598" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-5: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">NodeKey</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class constructor and properties</span></span></p><p class="calibre_6">The <span class="calibre4">NodeKey</span> class constructor ➊ takes a single argument, which is a <span class="calibre4">BinaryReader</span> for the registry hive. The constructor calls three methods that read and parse specific parts of the node, which we’ll implement next. After the constructor, we define several properties that will be used throughout the next three methods. The first three properties are particularly useful: <span class="calibre4">ChildNodes</span> ➋, <span class="calibre4">ChildValues</span> ➌, and <span class="calibre4">Timestamp</span> ➍.</p><p class="calibre_6">The first method called in the <span class="calibre4">NodeKey</span> constructor is <span class="calibre4">ReadNodeStructure()</span>, which reads the node key data from the registry hive but not any of its child nodes or values. This is detailed in <a href="#filepos914845">Listing 14-6</a>.</p><blockquote class="calibre_14"><span class="calibre4">private void ReadNodeStructure(BinaryReader hive)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> byte[] buf = hive.➊ReadBytes(4);</span><br class="calibre5"/><span class="calibre4"> if (buf[0] != 0x6e || buf[1] != 0x6b) //nk</span><br class="calibre5"/><span class="calibre4"> throw new NotSupportedException("Bad nk header");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> long startingOffset = ➋hive.BaseStream.Position;</span><br class="calibre5"/><span class="calibre4"> this.➌IsRootKey = (buf[2] == 0x2c) ? true : false;</span><br class="calibre5"/><span class="calibre4"> this.➍Timestamp = DateTime.FromFileTime(hive.ReadInt64());</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position += ➎4; //skip metadata</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.ParentOffset = hive.➏ReadInt32();</span><br class="calibre5"/><span class="calibre4"> this.SubkeysCount = hive.ReadInt32();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position += 4; //skip metadata</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.LFRecordOffset = hive.ReadInt32();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position += 4; //skip metadata</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.ValuesCount = hive.ReadInt32();</span><br class="calibre5"/><span class="calibre4"> this.ValueListOffset = hive.ReadInt32();</span><br class="calibre5"/><span class="calibre4"> this.SecurityKeyOffset = hive.ReadInt32();</span><br class="calibre5"/><span class="calibre4"> this.ClassnameOffset = hive.ReadInt32();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = startingOffset + 68;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.NameLength = hive.➐ReadInt16();</span><br class="calibre5"/><span class="calibre4"> this.ClassnameLength = hive.ReadInt16();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> buf = hive.➑ReadBytes(this.NameLength);</span><br class="calibre5"/><span class="calibre4"> this.Name = System.Text.Encoding.UTF8.GetString(buf);</span><br class="calibre5"/><span class="calibre4">
</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = this.ClassnameOffset + 4 + 4096;</span><br class="calibre5"/><span class="calibre4"> this.➒ClassnameData = hive.ReadBytes(this.ClassnameLength);</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/></blockquote><p id="filepos914845" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-6: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ReadNodeStructure()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">NodeKey</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">To begin the <span class="calibre4">ReadNodeStructure()</span> method, we read the next four bytes of the node key with <span class="calibre4">ReadBytes()</span> ➊ to check that we are at the beginning of a node key (note that the second two bytes are junk that we can ignore for our purposes; we only care about the first two bytes). We compare the first two of these bytes to <span class="calibre4">0x6e</span> and <span class="calibre4">0x6b</span>, respectively. We are looking for the two hexadecimal byte values that represent the ASCII characters <span class="calibre4">n</span> and <span class="calibre4">k</span> (for node key). Every node key in the registry hive starts with these two bytes, so we can always be sure that we are parsing what we expect. After determining we are reading a node key, we save our current position ➋ in the file stream so that we can easily return to it.</p><p class="calibre_6">Next, we begin assigning values to some of the <span class="calibre4">NodeKey</span> properties, starting with the <span class="calibre4">IsRootKey</span> ➌ and <span class="calibre4">Timestamp</span> ➍ properties. Notice that every few lines, we skip ahead by four in the current stream position ➎ without reading anything. We’re skipping pieces of metadata that aren’t necessary for our purposes.</p><p class="calibre_6">Then, we use the <span class="calibre4">ReadInt32()</span> method ➏ to read four bytes and return an integer representing them that C# can read. This is what makes the <span class="calibre4">BinaryReader</span> class so useful. It has many convenient methods that will cast bytes for you. As you can see, most of the time, we will use the <span class="calibre4">ReadInt32()</span> method, but occasionally we will use <span class="calibre4">ReadInt16()</span> ➐ or other methods to read specific types of integers, such as unsigned and really long integers.</p><p class="calibre_6">Finally, we read the name of the <span class="calibre4">NodeKey</span> ➑ and assign the string to the <span class="calibre4">Name</span> property. We also read the class name data ➒, which we will use later when dumping the boot key.</p><p class="calibre_6">Now we need to implement the <span class="calibre4">ReadChildrenNodes()</span> method. This method iterates over each child node and adds the node to the <span class="calibre4">ChildNodes</span> property so that we can analyze it later, as <a href="#filepos919727">Listing 14-7</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">private void ReadChildrenNodes(➊BinaryReader hive)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> this.ChildNodes = new ➋List&lt;NodeKey&gt;();</span><br class="calibre5"/><span class="calibre4"> if (this.LFRecordOffset != -1)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = 4096 + this.LFRecordOffset + 4;</span><br class="calibre5"/><span class="calibre4"> byte[] buf = hive.ReadBytes(2);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> //ri</span><br class="calibre5"/><span class="calibre4"> if ➌(buf[0] == 0x72 &amp;&amp; buf[1] == 0x69)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> int count = hive.ReadInt16();</span><br class="calibre5"/><span class="calibre4"> ➍for (int i = 0; i &lt; count; i++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> long pos = hive.BaseStream.Position;</span><br class="calibre5"/><span class="calibre4"> int offset = hive.ReadInt32();</span><br class="calibre5"/><span class="calibre4">
</span><br class="calibre5"/><span class="calibre4"> ➎hive.BaseStream.Position = 4096 + offset + 4;</span><br class="calibre5"/><span class="calibre4"> buf = hive.ReadBytes(2);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (!(buf[0] == 0x6c &amp;&amp; (buf[1] == 0x66 || buf[1] == 0x68)))</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Bad LF/LH record at:"</span><br class="calibre5"/><span class="calibre4"> + hive.BaseStream.Position);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➏ParseChildNodes(hive);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➐hive.BaseStream.Position = pos + 4; //go to next record list</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> //lf or lh</span><br class="calibre5"/><span class="calibre4"> else if ➑(buf[0] == 0x6c &amp;&amp; (buf[1] == 0x66 || buf[1] == 0x68))</span><br class="calibre5"/><span class="calibre4"> ➒ParseChildNodes(hive);</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Bad LF/LH/RI record at: "</span><br class="calibre5"/><span class="calibre4"> + hive.BaseStream.Position);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/></blockquote><p id="filepos919727" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-7: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ReadChildrenNodes()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">NodeKey</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Like most of the methods we will be implementing for the <span class="calibre4">NodeKey</span> class, the <span class="calibre4">ReadChildrenNodes()</span> method takes a single argument, which is the <span class="calibre4">BinaryReader</span> ➊ for the registry hive. We create an empty list ➋ of node keys for the <span class="calibre4">ChildNodes</span> property to read to. Then we must parse any child nodes in the current node key. This gets a bit tricky because there are three different ways to point to child node keys, and one type is read differently than the other two. The three types are the <span class="calibre4">ri</span> (for index root), <span class="calibre4">lf</span> (for fast leaf), and <span class="calibre4">lh</span> (for hash leaf) structures.</p><p class="calibre_6">We check whether we are on an <span class="calibre4">ri</span> structure ➌ first. The <span class="calibre4">ri</span> structure is a container and is stored slightly differently. It is used for pointing to multiple <span class="calibre4">lf</span> or <span class="calibre4">lh</span> records and allows a node key to have more child nodes than a single <span class="calibre4">lf</span> or <span class="calibre4">lh</span> record can handle. As we loop over each set of child nodes in a <span class="calibre4">for</span> loop ➍, we jump to each child record ➎ and call <span class="calibre4">ParseChildNodes()</span> ➏, which we will implement next, by passing the <span class="calibre4">BinaryReader</span> for the hive as the only argument. After parsing the child nodes, we can see that our stream position has changed (we’ve moved around in the registry hive), so we set the stream position back to the <span class="calibre4">ri</span> list ➐, where we were before reading the children, in order to read the next record in the list.</p><p class="calibre_6">If we are dealing with an <span class="calibre4">lf</span> or <span class="calibre4">lh</span> record ➑, we just pass the <span class="calibre4">BinaryReader</span> to the <span class="calibre4">ParseChildNodes()</span> method ➒ and let it read the nodes directly.</p><p class="calibre_6">Luckily, once the child nodes have been read, they can all be parsed in the same way, regardless of the structure used to point to them. The method to do all of the actual parsing is relatively easy, as shown in <a href="#filepos923496">Listing 14-8</a>.</p><blockquote class="calibre_14"><span class="calibre4">private void ParseChildNodes(➊BinaryReader hive)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> int count = hive.➋ReadInt16();</span><br class="calibre5"/><span class="calibre4"> long topOfList = hive.BaseStream.Position;</span><br class="calibre5"/><span class="calibre4">
</span><br class="calibre5"/><span class="calibre4"> ➌for (int i = 0; i &lt; count; i++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = topOfList + (i*8);</span><br class="calibre5"/><span class="calibre4"> int newoffset = hive.ReadInt32();</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position += 4; //skip over registry metadata</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = 4096 + newoffset + 4;</span><br class="calibre5"/><span class="calibre4"> NodeKey nk = new ➍NodeKey(hive) { ParentNodeKey = this };</span><br class="calibre5"/><span class="calibre4"> this.ChildNodes.➎Add(nk);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = topOfList + (count * 8);</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/></blockquote><p id="filepos923496" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-8: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ParseChildNodes()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method for the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">NodeKey</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6"><span class="calibre4">ParseChildNodes()</span> takes a single argument, the <span class="calibre4">BinaryReader</span> ➊ for the hive. The number of nodes we need to iterate over and parse is stored in a 16-bit integer, which we read from the hive ➋. After storing our position so we can return to it later, we begin iterating in a <span class="calibre4">for</span> loop ➌, jumping to each new node and passing the <span class="calibre4">BinaryReader</span> to the <span class="calibre4">NodeKey</span> class constructor ➍. Once the child <span class="calibre4">NodeKey</span> is created, we add ➎ the node to the <span class="calibre4">ChildNodes</span> list and begin the process again, until no more nodes are available to be read.</p><p class="calibre_6">The last method, called in the <span class="calibre4">NodeKey</span> constructor, is the <span class="calibre4">ReadChildValues()</span> method. This method call, detailed in <a href="#filepos925913">Listing 14-9</a>, populates the <span class="calibre4">ChildValues</span> property list with all the key/value pairs we have found in the node key.</p><blockquote class="calibre_14"><span class="calibre4">private void ReadChildValues(BinaryReader hive)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.ChildValues = new ➊List&lt;ValueKey&gt;();</span><br class="calibre5"/><span class="calibre4"> if (this.ValueListOffset != ➋-1)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➌hive.BaseStream.Position = 4096 + this.ValueListOffset + 4;</span><br class="calibre5"/><span class="calibre4"> for (int i = 0; i &lt; this.ValuesCount; i++)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = 4096 + this.ValueListOffset + 4 + (i*4);</span><br class="calibre5"/><span class="calibre4"> int offset = hive.ReadInt32();</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = 4096 + offset + 4;</span><br class="calibre5"/><span class="calibre4"> this.ChildValues.➍Add(new ValueKey(hive));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/></blockquote><p id="filepos925913" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-9: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ReadChildValues()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method for the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">NodeKey</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Within the <span class="calibre4">ReadChildValues()</span> method, we first instantiate a new list ➊ to store the <span class="calibre4">ValueKey</span>s in and assign it to the <span class="calibre4">ChildValues</span> property. If the <span class="calibre4">ValueListOffset</span> doesn’t equal <span class="calibre4">-1</span> ➋ (which is a magic value that means there are no child values), we jump to the <span class="calibre4">ValueKey</span> list ➌ and begin reading each value key in a <span class="calibre4">for</span> loop, adding ➍ each new key to the <span class="calibre4">ChildValues</span> property so we can access it later.</p><p class="calibre_6">With this step, the <span class="calibre4">NodeKey</span> class is complete. The last class to implement is the <span class="calibre4">ValueKey</span> class.</p><p id="filepos927078" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Making a Class to Store Value Keys</span></span></span></p><p class="calibre_11">The <span class="calibre4">ValueKey</span> class is much simpler and shorter than the <span class="calibre4">NodeKey</span> class. Most of the <span class="calibre4">ValueKey</span> class is just the constructor, as <a href="#filepos929682">Listing 14-10</a> shows, though there are a handful of properties as well. This is all that is left to implement before we can start reading the offline registry hive.</p><blockquote class="calibre_14"><span class="calibre4">public class ValueKey</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public ➊ValueKey(BinaryReader hive)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> byte[] buf = hive.➋ReadBytes(2);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (buf[0] != 0x76 || buf[1] != 0x6b) //vk</span><br class="calibre5"/><span class="calibre4"> throw new NotSupportedException("Bad vk header");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.NameLength = hive.➌ReadInt16();</span><br class="calibre5"/><span class="calibre4"> this.DataLength = hive.➍ReadInt32();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> byte[] ➎databuf = hive.ReadBytes(4);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.ValueType = hive.ReadInt32();</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position += 4; //skip metadata</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> buf = hive.ReadBytes(this.NameLength);</span><br class="calibre5"/><span class="calibre4"> this.Name = (this.NameLength == 0) ? "Default" :</span><br class="calibre5"/><span class="calibre4"> System.Text.Encoding.UTF8.GetString(buf);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (➏this.DataLength &lt; 5)</span><br class="calibre5"/><span class="calibre4"> ➐this.Data = databuf;</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> hive.BaseStream.Position = 4096 + BitConverter.➑ToInt32(databuf, 0) + 4;</span><br class="calibre5"/><span class="calibre4"> this.Data = hive.ReadBytes(this.DataLength);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public short NameLength { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int DataLength { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int DataOffset { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ValueType { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public byte[] Data { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string String { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos929682" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-10: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ValueKey</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">In the constructor ➊, we read ➋ the first two bytes and make sure that we are reading a value key by comparing the two bytes to <span class="calibre4">0x76</span> and <span class="calibre4">0x6b</span>, as we did earlier. In this case, we are looking for <span class="calibre4">vk</span> in ASCII. We also read the lengths of the name ➌ and data ➍ and assign those values to their respective properties.</p><p class="calibre_6"> Something to note is that the <span class="calibre4">databuf</span> variable ➎ can hold either a pointer to the value key data or the value key data itself. If the data length is five or more, the data is generally in a four-byte pointer. We use the <span class="calibre4">DataLength</span> property ➏ to check whether the <span class="calibre4">ValueKey</span> length is less than five. If so, we assign the data in the <span class="calibre4">databuf</span> variable directly to the <span class="calibre4">Data</span> property ➐ and finish up. Otherwise, we turn the <span class="calibre4">databuf</span> variable into a 32-bit integer ➑, which is an offset from the current position in the file stream to the actual data to read, and then jump to that position in the stream and read the data with <span class="calibre4">ReadBytes()</span>, assigning it to the <span class="calibre4">Data</span> property.</p><p id="filepos931226" class="calibre_10"><span class="calibre3"><span class="bold">Testing the Library</span></span></p><p class="calibre_11">Once we’ve finished writing the classes, we can write a quick <span class="calibre4">Main()</span> method, shown in <a href="#filepos931941">Listing 14-11</a>, to test that we are successfully parsing the registry hive.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> RegistryHive hive = new ➊RegistryHive(args[0]);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("The rootkey's name is " + hive.RootKey.Name);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos931941" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-11: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method to print the root key name of a registry hive</span></span></p><p class="calibre_6">In the <span class="calibre4">Main()</span> method, we instantiate a new <span class="calibre4">RegistryHive</span> class ➊ by passing the first argument of the program as the file path to the offline registry hive on the filesystem. Then, we print the name of the registry hive root <span class="calibre4">NodeKey</span>, which is stored in the <span class="calibre4">RegistryHive</span> class <span class="calibre4">RootKey</span> property:</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch14_reading_offline_hives.exe /Users/bperry/system.hive</span></span><br class="calibre5"/><span class="calibre4">The rootkey's name is CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p class="calibre_6">Once we have confirmed that we are successfully parsing the hive, we are ready to search the registry for the information we’re interested in.</p><p id="filepos933150" class="calibre_10"><span class="calibre3"><span class="bold">Dumping the Boot Key</span></span></p><p class="calibre_11">Usernames are nice, but password hashes are probably a lot more useful. Therefore, we’ll look at how to find these now. In order to access the password hashes in the registry, we must first retrieve the <span class="italic">boot key</span> from the <span class="calibre4">SYSTEM</span> hive. The password hashes in the Windows registry are encrypted with the boot key, which is unique to most Windows machines (unless they are images or virtual machine clones). Adding four more methods to the class with our <span class="calibre4">Main()</span> method will allow us to dump the boot key from a <span class="calibre4">SYSTEM</span> registry hive.</p><p id="filepos933895" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The GetBootKey() Method</span></span></span></p><p class="calibre_11">The first method is the <span class="calibre4">GetBootKey()</span> method, which takes a registry hive and returns an array of bytes. The boot key is broken up across multiple node keys in the registry hive, which we must first read and then decode using a special algorithm that will give us the final boot key. The beginning of this method is shown in <a href="#filepos935364">Listing 14-12</a>.</p><blockquote class="calibre_14"><span class="calibre4">static byte[] GetBootKey(RegistryHive hive)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ValueKey controlSet = ➊GetValueKey(hive, "Select\\Default");</span><br class="calibre5"/><span class="calibre4"> int cs = BitConverter.ToInt32(controlSet.Data, 0);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> StringBuilder scrambledKey = new StringBuilder();</span><br class="calibre5"/><span class="calibre4"> foreach (string key in new string[] ➋{"JD", "Skew1", "GBG", "Data"})</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> NodeKey nk = ➌GetNodeKey(hive, "ControlSet00" + cs +</span><br class="calibre5"/><span class="calibre4"> "\\Control\\Lsa\\" + key);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> for (int i = 0; i &lt; nk.ClassnameLength &amp;&amp; i &lt; 8; i++)</span><br class="calibre5"/><span class="calibre4"> scrambledKey.➍Append((char)nk.ClassnameData [i*2]);</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos935364" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-12: Beginning of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetBootKey()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method to read the scrambled boot key</span></span></p><p class="calibre_6">The <span class="calibre4">GetBootKey()</span> method starts by grabbing the <span class="calibre4">\Select\Default</span> value key with the <span class="calibre4">GetValueKey()</span> method ➊ (which we’ll implement shortly). It holds the current control set being used by the registry. We need this so that we read the correct boot key registry values from the correct control set. <span class="italic">Control sets</span> are sets of operating system configurations kept in the registry. Copies are kept for backup purposes in case the registry is corrupted, so we want to pick the control set that is selected by default at boot, which is dictated by the <span class="calibre4">\Select\Default</span> registry value key.</p><p class="calibre_6">Once we’ve found the correct default control set, we iterate over the four value keys—<span class="calibre4">JD</span>, <span class="calibre4">Skew1</span>, <span class="calibre4">GBG</span>, and <span class="calibre4">Data</span>—that contain the encoded boot key data ➋. As we iterate, we find each key with <span class="calibre4">GetNodeKey()</span> ➌ (which we’ll also implement shortly), iterate over the boot key data byte by byte, and append ➍ it to the total scrambled boot key.</p><p class="calibre_6">Once we have the scrambled boot key, we need to descramble it, and we can use a straightforward algorithm. <a href="#filepos937780">Listing 14-13</a> shows how we can turn our scrambled boot key into the key used to decrypt the password hashes.</p><blockquote class="calibre_14"><span class="calibre4"> byte[] skey = ➊StringToByteArray(scrambledKey.ToString());</span><br class="calibre5"/><span class="calibre4"> byte[] descramble = ➋new byte[] { 0x8, 0x5, 0x4, 0x2, 0xb, 0x9, 0xd, 0x3,</span><br class="calibre5"/><span class="calibre4"> 0x0, 0x6, 0x1, 0xc, 0xe, 0xa, 0xf, 0x7 };</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> byte[] bootkey = new ➌byte[16];</span><br class="calibre5"/><span class="calibre4"> ➍for (int i = 0; i &lt; bootkey.Length; i++)</span><br class="calibre5"/><span class="calibre4"> bootkey[i] = skey[➎descramble[i]];</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return ➏bootkey;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos937780" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-13: Finishing the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetBootKey()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method to descramble the boot key</span></span></p><p class="calibre_6"> After converting the scrambled key into a byte array for further processing with <span class="calibre4">StringToByteArray()</span> ➊, which we’ll implement soon, we create a new byte array ➋ to descramble our current value. We then create another new byte array ➌ to store the final product and begin iterating over the scrambled key in a <span class="calibre4">for</span> loop ➍, using the <span class="calibre4">descramble</span> byte array ➎ to find the correct values for the final <span class="calibre4">bootkey</span> byte array. The final key is then returned to the caller ➏.</p><p id="filepos938645" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The GetValueKey() Method</span></span></span></p><p class="calibre_11">The <span class="calibre4">GetValueKey()</span> method, shown in <a href="#filepos939416">Listing 14-14</a>, simply returns a value for a given path in the hive.</p><blockquote class="calibre_14"><span class="calibre4">static ValueKey GetValueKey(➊RegistryHive hive, ➋string path)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string keyname = path.➌Split('\\').➍Last();</span><br class="calibre5"/><span class="calibre4"> NodeKey node = ➎GetNodeKey(hive, path);</span><br class="calibre5"/><span class="calibre4"> return node.ChildValues.➏SingleOrDefault(v =&gt; v.Name == keyname);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos939416" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-14: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetValueKey()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">This simple method accepts a registry hive ➊ and the registry path ➋ to find in the hive. Using the backslash character to separate the nodes in the registry path, we split ➌ the path and take the last segment ➍ of the path as the value key to find. We then pass the registry hive and registry path to <span class="calibre4">GetNodeKey()</span> ➎ (implemented next), which will return the node that contains the key. Finally, we use the LINQ method <span class="calibre4">SingleOrDefault()</span> ➏ to return the value key from the node’s child values.</p><p id="filepos940229" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The GetNodeKey() Method</span></span></span></p><p class="calibre_11">The <span class="calibre4">GetNodeKey()</span> method is a bit more complicated than the <span class="calibre4">GetValueKey()</span> method. Shown in <a href="#filepos941760">Listing 14-15</a>, the <span class="calibre4">GetNodeKey()</span> method iterates through a hive until it finds a given node key path and returns the node key.</p><blockquote class="calibre_14"><span class="calibre4">static NodeKey GetNodeKey(➊RegistryHive hive, ➋string path)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> NodeKey ➌node = null;</span><br class="calibre5"/><span class="calibre4"> string[] paths = path.➍Split('\\');</span><br class="calibre5"/><span class="calibre4"> foreach (string ch in ➎paths)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (node == null)</span><br class="calibre5"/><span class="calibre4"> node = hive.RootKey;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➏foreach (NodeKey child in node.ChildNodes)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (child.Name == ch)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> node = child;</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> throw new Exception("No child found with name: " + ch);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➐return node;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos941760" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-15: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetNodeKey()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">GetNodeKey()</span> method accepts two arguments—the registry hive ➊ to search and the path of the node ➋ to return—separated by backslash characters. We start by declaring a null node ➌ for keeping track of our position while traversing the registry tree paths; then we split ➍ the path at each backslash character, returning an array of path segment strings. We then iterate over each path segment, traversing the registry tree until we find the node at the end of the path. We start traversing using a <span class="calibre4">foreach</span> loop that will progressively loop over each path segment in the <span class="calibre4">paths</span> array ➎. As we iterate over each segment, we use a <span class="calibre4">foreach</span> loop ➏ inside the <span class="calibre4">for</span> loop to find the next segment in the path until we have found the last node. Finally, we return ➐ the node we found.</p><p id="filepos942927" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The StringToByteArray() Method</span></span></span></p><p class="calibre_11">Finally, we implement the <span class="calibre4">StringToByteArray()</span> method used in <a href="#filepos937780">Listing 14-13</a>. This very simple method is detailed in <a href="#filepos943743">Listing 14-16</a>.</p><blockquote class="calibre_14"><span class="calibre4">static byte[] StringToByteArray(string s)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> return ➊Enumerable.Range(0, s.Length)</span><br class="calibre5"/><span class="calibre4"> .➋Where(x =&gt; x % 2 == 0)</span><br class="calibre5"/><span class="calibre4"> .➌Select(x =&gt; Convert.ToByte(s.Substring(x, 2), 16))</span><br class="calibre5"/><span class="calibre4"> .ToArray();</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos943743" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-16: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">StringToByteArray()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method used by</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetBootKey()</span></span></p><p class="calibre_6">The <span class="calibre4">StringToByteArray()</span> method uses LINQ to convert each two-character string into a single byte. For example, if the string <span class="calibre4">"FAAF"</span> were passed in, a byte array of <span class="calibre4">{ 0xFA, 0xAF }</span> would be returned by the method. Using <span class="calibre4">Enumerable.Range()</span> ➊ to iterate over each character in the string, we skip the odd-numbered characters with <span class="calibre4">Where()</span> ➋ and then use <span class="calibre4">Select()</span> ➌ to convert each pair of characters into the byte the pair represents.</p><p id="filepos944651" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Getting the Boot Key</span></span></span></p><p class="calibre_11">We can finally try dumping the boot key from the system hive. By calling our new <span class="calibre4">GetBootKey()</span> method, we can rewrite the <span class="calibre4">Main()</span> method we used previously to print the root key name to print the boot key instead. <a href="#filepos945565">Listing 14-17</a> shows this.</p><blockquote class="calibre_14"><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> RegistryHive systemHive = new ➊RegistryHive(args[0]);</span><br class="calibre5"/><span class="calibre4"> byte[] bootKey = ➋GetBootKey(systemHive);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">➌Console.WriteLine("Boot key: " + BitConverter.ToString(bootKey));</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos945565" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-17: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method testing the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetBootKey()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">This <span class="calibre4">Main()</span> method will open the registry hive ➊, which is passed as the only argument to the program. Then the new hive is passed to the <span class="calibre4">GetBootKey()</span> method ➋. With the new boot key saved, we print the boot key with <span class="calibre4">Console.WriteLine()</span> ➌.</p><p class="calibre_6">Then, we can run the test code to print the boot key, shown in <a href="#filepos946699">Listing 14-18</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch14_reading_offline_hives.exe ~/system.hive</span></span><br class="calibre5"/><span class="calibre4">Boot key: F8-C7-0D-21-3E-9D-E8-98-01-45-63-01-E4-F1-B4-1E</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos946699" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-18: Running the final</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">It worked! But how can we be sure this is the actual boot key?</p><p id="filepos947031" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Verifying the Boot Key</span></span></span></p><p class="calibre_11">We can verify that our code is working correctly by comparing it to the result of <span class="calibre4">bkhive</span>, a popular tool used to dump the boot key of a system hive, just as we have done. Included in the repository of code for this book (linked from the book’s page at <a href="https://www.nostarch.com/grayhatcsharp/"><span class="italic">https://www.nostarch.com/grayhatcsharp/</span></a>) is a copy of the source code for the <span class="calibre4">bkhive</span> tool. Compiling and running this tool on the same registry hive we have been testing on should verify our results, as <a href="#filepos948543">Listing 14-19</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">cd bkhive-1.1.1</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">make</span></span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./bkhive ~/system.hive /dev/null</span></span><br class="calibre5"/><span class="calibre4">bkhive 1.1.1 by Objectif Securite</span><br class="calibre5"/><span class="calibre4">http://www.objectif-securite.ch</span><br class="calibre5"/><span class="calibre4">original author: ncuomo@studenti.unina.it</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">Root Key : CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}</span><br class="calibre5"/><span class="calibre4">Default ControlSet: 001</span><br class="calibre5"/><span class="calibre4">Bootkey: ➊f8c70d213e9de89801456301e4f1b41e</span><br class="calibre5"/><span class="calibre4">$</span></blockquote><p id="filepos948543" class="calibre_15"><span class="calibre4"><span class="italic">Listing 14-19: Verifying that the boot key returned by our code is what</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">bkhive</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">prints</span></span></p><p class="calibre_6"> The <span class="calibre4">bkhive</span> tool verifies that our own boot key dumper works like a charm! Although <span class="calibre4">bkhive</span> prints the boot key ➊ in a slightly different form than we do (all lowercase with no hyphens), the data it prints is still the same (<span class="calibre4">F8C70D21</span>...) as ours.</p><p class="calibre_6">You might wonder why go through all the effort with the C# classes to dump the boot key when we could just use <span class="calibre4">bkhive</span>. The <span class="calibre4">bkhive</span> tool is highly specialized and will read a specific part of the registry hive, but the classes we implemented can be used to read any part of the registry hive, such as the password hashes (which are encrypted with the boot key!) and patch-level information. Our classes are much more flexible than the <span class="calibre4">bkhive</span> tool, and you’ll be able to use them as starting points if you want to expand your application.</p><p id="filepos949816" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">The obvious next step for an offensive or incident response–focused registry library is to dump the actual usernames and password hashes. Getting the boot key is the most difficult part of this, but it’s also the only step that requires the <span class="calibre4">SYSTEM</span> registry hive. Dumping the usernames and password hashes requires the <span class="calibre4">SAM</span> registry hive instead.</p><p class="calibre_6">Reading registry hives (and other binary file formats in general) is an important C# skill to develop. Incident response and offensive security professionals often must be able to implement code that reads and parses binary data in a variety of formats, either over the wire or on disk. In this chapter, you first learned how to export the registry hives so that we could copy them to other machines and read them offline. We then implemented classes to read the registry hives using <span class="calibre4">BinaryReader</span>. With these classes built, we were able to read the offline hive and print the root key name. Then, we took it a step further and dumped the boot key, used to encrypt the password hashes stored in the Windows registry, from the system hive.</p><div class="mbp_pagebreak" id="calibre_pb_19"/>
</body></html>