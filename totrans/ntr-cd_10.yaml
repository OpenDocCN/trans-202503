- en: '**9 Evolutionary Computing**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9 进化计算**'
- en: '*Time flies like an arrow; fruit flies like a banana.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*光阴似箭；果蝇爱香蕉。*'
- en: —Unknown
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —未知
- en: '![Image](../images/pg477_Image_739.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg477_Image_739.jpg)'
- en: '**Pueblo pottery (photo courtesy of the National Park Service)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**普韦布洛陶器（图片由国家公园管理局提供）**'
- en: For centuries, pottery created by the Ancestral Puebloans and Mogollon cultures
    of the southwestern United States and northern Mexico has held great significance
    in both ceremonial and everyday contexts. Techniques and design elements like
    those used to create this Chaco Ancestral Pueblo bowl are passed down through
    generations, with each potter learning, preserving, and subtly adapting these
    designs. This ongoing process gives rise to a continually evolving tapestry of
    familial and cultural expression.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几个世纪以来，美国西南部和墨西哥北部的祖先普韦布洛人和莫戈永文化所创造的陶器在仪式和日常生活中都具有重要意义。像制作这个查科祖先普韦布洛碗所使用的技术和设计元素一样，这些传统代代相传，每一位陶艺家都在学习、保存并微妙地调整这些设计。这一持续的过程孕育了一个不断发展的家族和文化表达的画卷。
- en: Take a moment to think back to a simpler time, when you wrote your first p5.js
    sketches and life was free and easy. Which fundamental programming concept did
    you likely use in those first sketches and continue to use over and over again
    to this day? *Variables*. Variables allow you to save data and reuse it while
    a program runs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间回想一下那个简单的时光，当时你编写了第一个 p5.js 草图，生活自由且轻松。你在这些第一个草图中可能使用了哪个基本的编程概念，并且一直反复使用到今天呢？*变量*。变量允许你在程序运行时保存数据并重用它。
- en: 'Of course, this is nothing new. In this book, you’ve moved far beyond sketches
    with just one or two simple variables, working up to sketches organized around
    more complex data structures: variables holding custom objects that include both
    data and functionality. You’ve used these complex data structures—classes—to build
    your own little worlds of movers and particles and vehicles and cells and trees.
    But there’s been a catch: in each and every example in this book, you’ve had to
    worry about initializing the properties of these objects. Perhaps you made a whole
    set of particles with random colors and sizes, or a list of vehicles all starting
    at the same (*x*, *y*) position.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是什么新鲜事。在这本书中，你已经远远超越了仅有一两个简单变量的草图，逐渐过渡到围绕更复杂数据结构组织的草图：变量持有包含数据和功能的自定义对象。你已经使用这些复杂的数据结构——类——构建了属于你自己的小世界，包括移动物体、粒子、车辆、细胞和树木。但有一个问题：在本书的每个例子中，你都必须担心初始化这些对象的属性。也许你创建了一组具有随机颜色和大小的粒子，或者一个所有车辆都从相同的
    (*x*, *y*) 位置开始的列表。
- en: What if, instead of acting as an intelligent designer, assigning the properties
    of the objects through randomness or thoughtful consideration, you could let a
    process found in nature—**evolution***—*decide the values for you? Can you think
    of the variables of a JavaScript object as the object’s DNA? Can objects give
    birth to other objects and pass down their DNA to a new generation? Can a p5.js
    sketch evolve?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再充当智能设计师，通过随机或深思熟虑的方式赋予物体属性，而是让自然界中的一个过程——**进化**——*为你决定这些值呢？你能将 JavaScript
    对象的变量看作该对象的 DNA 吗？对象能否生成其他对象并将它们的 DNA 传递给新一代？一个 p5.js 草图能进化吗？*
- en: The answer to all these questions is a resounding yes, and getting to that answer
    is the focus of this chapter. After all, this book would hardly be complete without
    tackling a simulation of one of the most powerful algorithmic processes found
    in nature itself, biological evolution. This chapter is dedicated to examining
    the principles behind evolutionary processes and finding ways to apply those principles
    in code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题的答案都是响亮的“是”，而得出这个答案正是本章的重点。毕竟，如果不处理一个自然界中最强大的算法过程——生物进化的模拟，这本书几乎不可能完整。本章致力于研究进化过程背后的原理，并寻找将这些原理应用于代码中的方法。
- en: '**Genetic Algorithms: Inspired by Actual Events**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**遗传算法：灵感来自现实事件**'
- en: The primary means for developing code systems that evolve are **genetic algorithms**
    (**GAs** for short), which are inspired by the core principles of Darwinian evolutionary
    theory. In these algorithms, populations of potential solutions to a problem evolve
    over generations through processes that mimic natural selection in biological
    evolution. While computer simulations of evolutionary processes date back to the
    1950s, much of our contemporary understanding of GAs stems from the work of John
    Holland, a professor at the University of Michigan whose 1975 book *Adaptation
    in Natural and Artificial Systems* (MIT Press) pioneered GA research. Today, GAs
    are part of a wider field that’s often referred to as **evolutionary computing**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 发展进化型代码系统的主要手段是**遗传算法**（简称**GA**），它们受到达尔文进化论核心原则的启发。在这些算法中，问题的潜在解决方案群体通过模拟生物进化中的自然选择过程，在几代人中逐步演化。尽管进化过程的计算机模拟可以追溯到20世纪50年代，但我们对遗传算法的现代理解大多源于密歇根大学的约翰·霍兰德教授，他在1975年出版的《自然与人工系统中的适应》（MIT出版社）一书中开创了遗传算法研究。今天，遗传算法已经成为一个更广泛领域的一部分，这个领域通常被称为**进化计算**。
- en: To be clear, GAs are only *inspired* by genetics and evolutionary theory, and
    aren’t intended to precisely implement the science behind these fields. As I explore
    GAs in this chapter, I won’t be making Punnett squares (sorry to disappoint),
    and there will be no discussion of nucleotides, protein synthesis, RNA, or other
    topics related to the biological processes of evolution. I don’t care so much
    about creating a scientifically accurate simulation of evolution as it happens
    in the physical world; rather, I care about methods for applying evolutionary
    strategies in software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，遗传算法只是受到遗传学和进化理论的*启发*，并不打算精确实现这些领域背后的科学原理。在本章探讨遗传算法时，我不会制作庞内特方格（抱歉让你失望），也不会讨论核苷酸、蛋白质合成、RNA或其他与生物进化过程相关的主题。我更关心的不是如何创造一个科学上精确模拟物理世界中的进化过程，而是如何将进化策略应用于软件开发。
- en: This isn’t to say that a project with more scientific depth wouldn’t have value.
    In fact, a whole field of computational biology research *does* take on the challenge
    of more accurately simulating biological evolutionary processes! I encourage readers
    with a particular interest in this topic to explore possibilities for expanding
    the examples provided with additional evolutionary features. Nevertheless, for
    the sake of keeping the projects manageable, I’m going to stick to the basics.
    And as it happens, the basics will be plenty complex and exciting.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说具有更高科学深度的项目就没有价值。事实上，计算生物学研究领域*确实*承担着更准确地模拟生物进化过程的挑战！我鼓励那些对这个主题特别感兴趣的读者，探索如何在提供的示例中增加更多进化特征。然而，为了确保项目可管理，我将坚持基础知识。而且，正如实际情况所示，基础知识将足够复杂且充满趣味。
- en: 'I should also note that, strictly speaking, the term *genetic algorithm* refers
    to a specific algorithm implemented in a specific way to solve specific sorts
    of problems, and not all those specifics are important to this book. While the
    formal GA will serve as the foundation for the examples in this chapter, I won’t
    make a fuss about implementing the algorithm with perfect accuracy, given that
    I’m looking for creative applications of evolutionary theory in code. As such,
    this chapter will be broken into the following three parts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该指出，严格来说，*遗传算法*一词指的是一种以特定方式实现的特定算法，用来解决特定类型的问题，而这些具体细节并不是本书关注的重点。虽然正式的遗传算法将作为本章示例的基础，但由于我更注重在代码中创造性地应用进化理论，所以我不会过分强调算法实现的精确度。因此，本章将分为以下三个部分：
- en: '**Traditional genetic algorithm:** I’ll begin with the traditional, textbook
    GA. This algorithm was developed to solve problems in computer science for which
    the solution space is so vast that a *brute-force* algorithm would take too long.
    Here’s an example: I’m thinking of a number between one and one billion. How long
    will it take you to guess it? With a brute-force approach, you’d have to check
    every possible solution. Is it one? Is it two? Is it three? Is it four? . . .
    Luck plays a factor here (maybe I happened to pick five!), but on average, you
    would end up spending years counting up from one before hitting the correct answer.
    However, what if I could tell you whether your answer was good or bad? Warm or
    cold? Very warm? Hot? Ice frigid? If you could evaluate how close (or *fit*) your
    guesses are, you could start picking numbers accordingly and arrive at the answer
    more quickly. Your answer would *evolve*.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统遗传算法：** 我将从传统的教材中介绍遗传算法（GA）。该算法是为了处理计算机科学中那些解空间非常庞大、采用*暴力搜索*方法需要过长时间的问题而开发的。举个例子：我在想一个介于一和十亿之间的数字。你需要多长时间才能猜出来？采用暴力搜索的方法，你必须检查每一个可能的答案。是1吗？是2吗？是3吗？是4吗？。。。运气也起到了一定作用（也许我碰巧选了5！），但平均下来，你会在从1开始数起的过程中花费数年时间才能找到正确答案。然而，如果我能告诉你你的答案是对是错？是温暖还是冷？非常温暖？热？冰冷？如果你能评估你猜测的接近程度（或*适应度*），你就能相应地调整你的选择，更快地得到正确答案。你的答案将会*进化*。'
- en: '**Interactive selection:** After exploring the traditional computer science
    version, I’ll examine other applications of GAs in the visual arts. *Interactive
    selection* refers to the process of evolving something (often a computer-generated
    image) through user interaction. Let’s say you walk into a museum gallery and
    see 10 paintings. With interactive selection, you might pick your favorites and
    allow an algorithmic process to generate (or *evolve*) new paintings based on
    your preferences.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式选择：** 在探索了传统的计算机科学版本之后，我将探讨遗传算法在视觉艺术中的其他应用。*交互式选择*指的是通过用户互动来进化某种事物（通常是计算机生成的图像）的过程。假设你走进一个博物馆的展厅，看到10幅画。通过交互式选择，你可能会挑选出你最喜欢的几幅，然后让算法根据你的偏好生成（或*进化*）新的画作。'
- en: '**Ecosystem simulation:** The traditional computer science GA and interactive
    selection technique are what you’ll likely find if you search online or read a
    textbook about artificial intelligence. But as you’ll soon see, they don’t really
    simulate the process of evolution as it happens in the physical world. In this
    chapter, I’ll also explore techniques for simulating evolution in an ecosystem
    of artificial creatures. How can the objects that move about a canvas meet each
    other, mate, and pass their genes on to a new generation? This could apply directly
    to the Ecosystem Project outlined at the end of each chapter. It will also be
    particularly relevant as I explore neuroevolution in [Chapter 11](ch11.xhtml#ch11).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生态系统模拟：** 传统的计算机科学遗传算法和交互式选择技术是你在网上搜索或阅读人工智能教科书时常见的内容。但正如你将很快看到的，它们并没有真正模拟物理世界中进化的过程。在本章中，我还将探讨模拟人工生物生态系统进化的技术。如何让在画布上移动的物体相遇、交配并将基因传递给下一代？这可以直接应用于每章结尾处提到的生态系统项目。在我探讨[第11章](ch11.xhtml#ch11)中的神经进化时，这也将特别相关。'
- en: '**Why Use Genetic Algorithms?**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么使用遗传算法？**'
- en: To help illustrate the utility of the traditional GA, I’m going to start with
    cats. No, not just your everyday feline friends. I’m going to start with some
    purr-fect cats that paw-sess a talent for typing, with the goal of producing the
    complete works of Shakespeare ([Figure 9.1](ch09.xhtml#ch9fig1)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助说明传统遗传算法的实用性，我将从猫咪开始。不，不是你每天看到的那些猫咪。我将从一些“嗡嗡叫”的猫咪开始，它们具备打字的天赋，目标是生成完整的莎士比亚作品集（见[图9.1](ch09.xhtml#ch9fig1)）。
- en: '![Image](../images/pg480_Image_740.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg480_Image_740.jpg)'
- en: 'Figure 9.1: Infinite cats typing at infinite keyboards'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：无限只猫在无限键盘上打字
- en: 'This is my meow-velous twist on the **infinite monkey theorem**, which is stated
    as follows: a monkey hitting keys randomly on a typewriter will eventually type
    the complete works of Shakespeare, given an infinite amount of time. It’s only
    a theory because in practice the number of possible combinations of letters and
    words makes the likelihood of the monkey *actually* typing Shakespeare minuscule.
    To put it in perspective, even if the monkey had started typing at the beginning
    of the universe, the probability that by now it would have produced just *Hamlet*,
    to say nothing of the *entire works* of Shakespeare, is still absurdly unlikely.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我对**无限猴子定理**的妙趣横生的解读，定理内容如下：一只猴子在打字机上随机敲击键盘，最终会打出莎士比亚的完整作品，前提是有无限的时间。之所以只是一个理论，是因为在实际情况下，字母和单词的可能组合数量使得猴子*实际上*打出莎士比亚作品的可能性微乎其微。为了让你理解，即便这只猴子从宇宙诞生之初开始打字，到现在，它打出*哈姆雷特*的概率，别说打出莎士比亚的*完整作品*，依然是极为不可能的。
- en: 'Consider a cat named Clawdius. Clawdius types on a reduced typewriter containing
    only 27 characters: the 26 English letters plus the spacebar. The probability
    of Clawdius hitting any given key is 1 in 27.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一只名叫Clawdius的猫。Clawdius在一个简化的打字机上打字，这台打字机只有27个字符：26个英文字母和空格键。Clawdius按下任意一个键的概率是1/27。
- en: Next, consider the phrase “to be or not to be that is the question” (for simplicity,
    I’m ignoring capitalization and punctuation). The phrase is 39 characters long,
    including spaces. If Clawdius starts typing, the chance he’ll get the first character
    right is 1 in 27\. Since the probability he’ll get the second character right
    is also 1 in 27, he has a 1 in 729 (27 × 27) chance of landing the first two characters
    in correct order. (This follows directly from our discussion of probability in
    [Chapter 0](ch00.xhtml#ch00).) Therefore, the probability that Clawdius will type
    the full phrase is 1 in 27 multiplied by itself 39 times, or (1/27)^(39). That
    equals a probability of . . .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑短语“to be or not to be that is the question”（为了简单起见，我忽略了大小写和标点符号）。这个短语包含39个字符，包括空格。如果Clawdius开始打字，他按下第一个字符正确的概率是1/27。由于他按下第二个字符正确的概率也是1/27，他成功输入前两个字符正确的概率是1/729（27
    × 27）。(这一点直接来自我们在[第0章](ch00.xhtml#ch00)中关于概率的讨论。)因此，Clawdius输入完整短语的概率是1/27乘以自身39次，或者(1/27)^(39)。这等于一个概率值……
- en: 1 in 66,555,937,033,867,822,607,895,549,241,096,482,953,017,615,834,735,226,163
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 1 in 66,555,937,033,867,822,607,895,549,241,096,482,953,017,615,834,735,226,163
- en: Needless to say, even hitting just this one phrase, let alone an entire play,
    let alone all of Shakespeare’s 38 plays (yes, even *The Two Noble Kinsmen*) is
    highly unlikely. Even if Clawdius were a computer simulation and could type a
    million random phrases per second, for Clawdius to have a 99 percent probability
    of eventually getting just the one phrase right, he would have to type for 9,719,096,182,010,563,073,125,591,133,903,305,625,605,017
    years. (For comparison, the universe is estimated to be a mere 13,750,000,000
    years old.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，连打对这一个短语，更不用说打出整部戏剧，甚至是莎士比亚的38部戏剧（没错，甚至是*《两位贵族亲戚》*）都是极不可能的。即便Clawdius是一个计算机模拟，每秒能打出一百万个随机短语，要使Clawdius最终以99%的概率打出这一短语，他需要打字9,719,096,182,010,563,073,125,591,133,903,305,625,605,017年。（为了做个对比，宇宙的估计年龄仅为137.5亿年。）
- en: The point of all these unfathomably large numbers isn’t to give you a headache,
    but to demonstrate that a brute-force algorithm (typing every possible random
    phrase) isn’t a reasonable strategy for arriving randomly at “to be or not to
    be that is the question.” Enter GAs, which start with random phrases and swiftly
    find the solution through simulated evolution, leaving plenty of time for Clawdius
    to savor a cozy catnap.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些无法想象的大数字的意义，并不是让你头疼，而是为了说明暴力破解算法（打出每一个可能的随机短语）并不是一个合理的随机生成“to be or not to
    be that is the question”短语的策略。于是，遗传算法（GAs）应运而生，它们从随机短语开始，通过模拟进化迅速找到解决方案，让Clawdius有足够的时间享受一场舒适的小猫午睡。
- en: 'To be fair, this particular problem (to arrive at the phrase “to be or not
    to be that is the question”) is a ridiculous one. Since you know the answer already,
    all you need to do is type it. Here’s a p5.js sketch that solves the problem:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 公正地说，这个问题（要得到短语“to be or not to be that is the question”）本身是荒谬的。因为你已经知道答案了，所有你需要做的就是打出来。这里有一个p5.js的示例程序，能解决这个问题：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Nevertheless, it’s a terrific problem to start with since having a known answer
    will allow you to easily test the code and evaluate the success of the GA. Once
    you’ve successfully solved the problem, you can feel more confident in using GAs
    to do something actually useful: solving problems with *unknown* answers. This
    first example serves no real purpose other than to demonstrate how GAs work. If
    you test the GA results against the known answer and get “to be or not to be,”
    then you’ve succeeded in writing a GA.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个很好的起步问题，因为有了已知的答案，你可以轻松测试代码并评估遗传算法的成功。一旦你成功解决了这个问题，就可以更有信心地使用遗传算法做一些真正有用的事情：解决*未知*答案的问题。这个第一个示例除了演示遗传算法的工作原理外并没有其他实际用途。如果你将遗传算法的结果与已知答案进行对比，得到“生存还是毁灭”，那你就成功编写了一个遗传算法。
- en: '![Image](../images/pencil.jpg) **Exercise 9.1**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 9.1**'
- en: Create a sketch that generates random strings. You’ll need to know how to do
    this in order to implement the GA example that will shortly follow. How long does
    it take for p5.js to randomly generate the string `cat`? How might you adapt this
    to generate a random design using p5.js’s shape-drawing functions?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个生成随机字符串的草图。你需要知道如何做到这一点，才能实现接下来的遗传算法示例。p5.js生成字符串`cat`需要多长时间？你如何使用p5.js的形状绘制函数将其改编为生成一个随机设计？
- en: '**How Genetic Algorithms Work**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**遗传算法的工作原理**'
- en: 'Before I get to any code, I’d like to walk through the steps of the classic
    GA in a more general way. I’ll illustrate how a population of *creatures* (a generic
    term for the elements of a simulation) can evolve over a series of generations.
    To understand how this works, it’s important to outline three core principles
    of Darwinian evolution. If natural selection is to occur in code as it does in
    nature, all three of these elements must be present:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我介绍任何代码之前，我想先以一种更通用的方式讲解经典遗传算法的步骤。我将展示如何通过一系列的世代演变，一个*生物群体*（模拟中的元素的通用术语）是如何进化的。为了理解这一过程，首先需要概述达尔文进化论的三个核心原则。如果自然选择要像自然界中那样在代码中发生，必须具备以下三种要素：
- en: '**Heredity:** There must be a mechanism that allows *parent* creatures in one
    generation to pass their traits down to *child* creatures in the next generation.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗传性：** 必须有一种机制，让某一代的*父母*生物将它们的特征传递给下一代的*子代*生物。'
- en: '**Variation:** There must be a variety of traits present in the population
    of creatures or a means to introduce variation for evolution to take place. Imagine
    a population of beetles that were exactly the same: same color, same size, same
    wingspan, same everything. Without any variety in the population, the children
    would always be identical to the parents and to each other. New combinations of
    traits could never occur, and nothing could evolve.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变异：** 在生物群体中必须存在各种不同的特征，或者需要引入某种变异机制，以便进化得以发生。想象一个甲虫群体，它们完全相同：相同的颜色、相同的大小、相同的翼展、相同的一切。如果群体中没有任何变异，那么子代总是与父母以及彼此完全相同。新的特征组合永远不会出现，也无法发生进化。'
- en: '**Selection:** There must be a mechanism by which some creatures have the opportunity
    to be parents and pass on their genetic information, while others don’t. This
    is commonly referred to as *survival of the fittest*. Take, for example, a population
    of gazelles that are chased by lions. The faster gazelles have a better chance
    of escaping the lions, increasing their chances of living longer, reproducing,
    and passing on their genetic information to offspring. The term *fittest* can
    be misleading, however. It’s often thought to mean biggest, fastest, or strongest,
    but while it can sometimes encompass physical attributes like size, speed, or
    strength, it doesn’t have to. The core of natural selection lies in whatever traits
    best suit an organism’s environment and increase its likelihood of survival and
    ultimately reproduction. Instead of asserting superiority, *fittest* can be better
    understood as “able to reproduce.” Take the *Dolania americana* (aka the American
    sand-burrowing mayfly), which is believed to have the shortest life span of any
    insect. An adult female lives for only five minutes, but as long as it has managed
    to deposit its egg in the water, it will pass its genetic information to the next
    generation. For the typing cats, a more *fit* cat, one that I will assign as more
    likely to reproduce, is one that has typed more characters present in a given
    phrase of Shakespeare.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择：** 必须有一个机制，使得某些生物有机会成为父母并传递其遗传信息，而其他生物则没有机会。这个过程通常被称为*适者生存*。举个例子，假设有一群羚羊被狮子追逐。更快速的羚羊有更大的机会逃脱狮子的追击，从而增加其生存的机会，延长寿命，繁殖并将遗传信息传递给后代。然而，*适者*一词可能会产生误导。人们通常认为它意味着最大、最快或最强壮，但虽然它有时可以包括体型、速度或力量等身体特征，它并不一定非要如此。自然选择的核心在于任何最适应生物环境的特征，并增加其生存几率，最终促进繁殖。与其说是“优越性”，不如说*适者*更好理解为“能够繁殖”。以*Dolania
    americana*（即美国沙穴蜉蝣）为例，它被认为是寿命最短的昆虫之一。成年雌性只活五分钟，但只要它成功地将卵产入水中，它就能将遗传信息传递给下一代。对于打字猫来说，一个更*适应*的猫——我将其定义为更可能繁殖的猫——是那种输入了莎士比亚某一短语中更多字符的猫。'
- en: 'I want to emphasize the context in which I’m applying these Darwinian concepts:
    a simulated, artificial environment where specific goals can be quantified, all
    for the sake of creative exploration. Throughout history, the principles of genetics
    have been used to harm those who have been marginalized and oppressed by dominant
    societal structures. I believe it is essential to approach projects involving
    GAs with careful consideration of the language used, and to ensure that the documentation
    and descriptions of the work are framed inclusively.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调的是，我应用这些达尔文概念的背景：一个模拟的人工环境，在这个环境中，特定的目标可以量化，所有这一切都是为了创造性的探索。纵观历史，遗传学原理曾被用来伤害那些被主导社会结构边缘化和压迫的人群。我认为，在处理涉及遗传算法（GAs）的项目时，必须小心谨慎地使用语言，并确保工作文档和描述以包容性框架呈现。
- en: 'With these concepts established, I’ll begin walking through the GA narrative.
    I’ll do this in the context of typing cats. The algorithm will be divided into
    several steps that unfold over two parts: a set of conditions for initialization,
    and the steps that are repeated over and over again until the correct phrase is
    found.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些概念建立之后，我将开始讲解遗传算法的叙述。我会在打字猫的背景下进行讲解。该算法将分为几个步骤，分为两部分展开：初始化条件集，以及在找到正确短语之前反复进行的步骤。
- en: '**Step 1: Population Creation**'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 1: 种群创建**'
- en: For typing cats, the first step of the GA is to create a population of phrases.
    I’m using the term *phrase* rather loosely to mean any string of characters. These
    phrases are the creatures of this example, though of course they aren’t very creature-like.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于打字猫，遗传算法的第一步是创建一个短语种群。我使用*短语*这个词比较宽泛，指的是任何字符的字符串。这些短语就是这个例子中的生物，尽管它们当然不像生物。
- en: 'In creating the population of phrases, the Darwinian principle of **variation**
    applies. Let’s say for the sake of simplicity that I’m trying to evolve the phrase
    *cat* and that I have a population of three phrases:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建短语种群时，达尔文原理中的**变异**适用。为了简单起见，假设我正在进化短语*cat*，并且我有一个包含三个短语的种群：
- en: '| rid |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| rid |'
- en: '| won |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| won |'
- en: '| hug |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| hug |'
- en: 'Sure, these phrases have variety, but try to mix and match the characters every
    which way and you’ll never get *cat*. There isn’t *enough* variety here to evolve
    the optimal solution. However, if I had a population of thousands of phrases,
    all generated randomly, chances are that at least one phrase would have a *c*
    as the first character, one would have an *a* as the second, and one a *t* as
    the third. A large population will most likely provide enough variety to generate
    the desired phrase. (In step 3 of the algorithm, I’ll also demonstrate another
    mechanism to introduce more variation in case there isn’t enough in the first
    place.) Step 1 can therefore be described as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些短语有各种各样的变化，但尝试将字符随意混合搭配，你永远也得不到*cat*。这里的变化*不足*以进化出最佳解。然而，如果我有一个包含数千个随机生成短语的种群，至少有一个短语的第一个字符是*c*，第二个是*a*，第三个是*t*。一个大规模的种群很可能提供足够的变化来生成所需的短语。（在算法的第3步中，我还将展示另一种机制，以便在第一步没有足够变化时引入更多变化。）因此，步骤1可以描述如下：
- en: Create a population of randomly generated elements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个随机生成元素的种群。
- en: '*Element* is perhaps a better, more general-purpose term than *creature*. But
    what is the element? As you move through the examples in this chapter, you’ll
    see several scenarios; you might have a population of images or a population of
    vehicles à la [Chapter 5](ch05.xhtml#ch05). The part that’s new in this chapter
    is that each element, each member of the population, has *virtual DNA*, a set
    of properties (you could also call them *genes*) that describe how a given element
    looks or behaves. For the typing cats, for example, the DNA could be a string
    of characters. With this in mind, I can be even more specific and describe step
    1 of the GA as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*元素*可能是比*生物*更好的、更通用的术语。但什么是元素呢？当你在本章中浏览示例时，你会看到几种不同的场景；你可能有一个图像的种群，或者像[第5章](ch05.xhtml#ch05)那样有一个交通工具的种群。本章的新内容是，每个元素，每个种群成员，都有*虚拟DNA*，一组属性（你也可以称之为*基因*），描述一个元素的外观或行为。例如，对于打字的猫来说，DNA可能是一串字符。考虑到这一点，我可以更具体地描述遗传算法的第1步如下：'
- en: Create a population of *N* elements, each with randomly generated DNA.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含*N*个元素的种群，每个元素都有随机生成的DNA。
- en: The field of genetics makes an important distinction between the concepts of
    genotype and phenotype. The actual genetic code—the particular sequence of molecules
    in the DNA—is an organism’s **genotype**. This is what gets passed down from generation
    to generation. The **phenotype**, by contrast, is the *expression* of that data—this
    cat will be big, that cat will be small, that other cat will be a particularly
    fast and effective typist.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传学领域对基因型和表现型这两个概念做出了重要的区分。实际的基因代码——DNA中分子序列的特定排列——是一个生物体的**基因型**。这就是从一代传到下一代的东西。相比之下，**表现型**是这些数据的*表达*——这只猫会很大，那只猫会很小，另一只猫则会是一个特别快速且高效的打字员。
- en: The genotype/phenotype distinction is key to creatively using GAs. What are
    the objects in your world? How will you design the genotype for those objects—the
    data structure to store each object’s properties, and the values those properties
    take on? And how will you use that information to design the phenotype? That is,
    what do *you* want these variables to actually express?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基因型/表现型的区分对于创造性地使用遗传算法至关重要。你的世界中的对象是什么？你将如何为这些对象设计基因型——存储每个对象属性的数据结构，以及这些属性可能具有的值？你将如何利用这些信息来设计表现型？也就是说，*你*希望这些变量实际表达什么？
- en: 'We do this all the time in graphics programming, taking values (the genotype)
    and interpreting them in a visual way (the phenotype). The simplest example is
    probably color:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图形编程中经常做这件事，将值（基因型）以可视化的方式呈现（表现型）。最简单的例子可能就是颜色：
- en: '| **Genotype** | **Phenotype** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **基因型** | **表现型** |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | ![Image](../images/pg484_Image_741.jpg) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ![Image](../images/pg484_Image_741.jpg) |'
- en: '| 127 | ![Image](../images/pg484_Image_742.jpg) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 127 | ![Image](../images/pg484_Image_742.jpg) |'
- en: '| 255 | ![Image](../images/pg484_Image_743.jpg) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 255 | ![Image](../images/pg484_Image_743.jpg) |'
- en: 'Think of the genotype as the digital information, the data that represents
    color—in the case of grayscale values, an integer from 0 to 255\. The way you
    choose to express the data is arbitrary: a red value, a green value, and a blue
    value. It doesn’t even need to be color at all—in a different approach, you could
    use the same values to describe the length of a line, the weight of a force, and
    so on:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 把基因型看作是数字信息，表示颜色的数据——在灰度值的情况下，是从0到255的整数。你选择如何表达这些数据是任意的：一个红色值，一个绿色值，和一个蓝色值。甚至不需要是颜色——在不同的方案中，你也可以用这些值来描述线的长度、力的重量等等：
- en: '| **Same Genotype** | **Different Phenotype (Line Length)** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **相同基因型** | **不同表型（行长）** |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 |  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0 |  |'
- en: '| 127 | ___________________________ |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 127 | ___________________________ |'
- en: '| 255 | ______________________________________________ |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 255 | ______________________________________________ |'
- en: A nice aspect of the cat-typing example is that there’s no difference between
    genotype and phenotype. The DNA data is a string of characters, and the expression
    of that data is that very string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打字猫示例的一个好处是，基因型和表型之间没有区别。DNA 数据是一个字符串，而这些数据的表现形式就是这个字符串本身。
- en: '**Step 2: Selection**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤2：选择**'
- en: 'The second step of the GA is to apply the Darwinian principle of **selection**.
    This involves evaluating the population and determining which members are fit
    to be selected as parents for the next generation. The process of selection can
    be divided into two steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法的第二步是应用达尔文的**选择**原则。这包括评估种群并确定哪些成员适合被选为下一代的父母。选择过程可以分为两步：
- en: '**Evaluate fitness.**'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**评估适应度。**'
- en: '**Create a mating pool.**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建配对池。**'
- en: For the first of these steps, I’ll need to design a **fitness function**, a
    function that produces a numeric score to describe the fitness of a given element
    of the population. This, of course, isn’t how the real world works at all. Creatures
    aren’t given a score; rather, they simply reproduce or they don’t reproduce. A
    traditional GA, however, aims to evolve an optimal solution to a problem, so a
    mechanism to numerically evaluate any given possible solution is required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些步骤中的第一个，我需要设计一个**适应度函数**，一个生成数值评分的函数，用来描述种群中某个元素的适应度。当然，这并不是现实世界中的运作方式。生物体并不会被赋予一个分数；它们只是繁殖或不繁殖。然而，传统的遗传算法旨在进化出问题的最佳解决方案，因此需要一个机制来数值化地评估任何给定的可能解决方案。
- en: 'Consider the current scenario, the typing cats. Again, for simplicity, I’ll
    say the target phrase is *cat*. Assume three members of the population: *hut*,
    *car*, and *box*. *Car* is obviously the most fit, given that it has two correct
    characters in the correct positions, *hut* has only one, and *box* has zero. And
    there it is, a fitness function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当前的场景——打字猫。为了简便起见，我假设目标短语是*cat*。假设种群中有三个成员：*hut*、*car* 和 *box*。显然，*car* 是最适合的，因为它在正确的位置上有两个正确的字符，*hut*
    只有一个，*box* 则没有正确的字符。就这样，适应度函数如下：
- en: fitness = the number of correct characters
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: fitness = 正确字符的数量
- en: '| **DNA** | **Fitness** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **DNA** | **适应度** |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| car | 2 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| car | 2 |'
- en: '| hut | 1 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| hut | 1 |'
- en: '| box | 0 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| box | 0 |'
- en: I’ll eventually want to look at examples with more sophisticated fitness functions,
    but this is a good place to start.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我最终会希望看到更多具有复杂适应度函数的例子，但这是一个很好的起点。
- en: Once the fitness has been calculated for all members of the population, the
    next part of the selection process is to choose which members are fit to become
    parents and place them in a mating pool. This step has several approaches. For
    example, I could employ the **elitist** method and say, “Which two members of
    the population scored the highest? You two will make all the children for the
    next generation.” This is probably one of the easier methods to code, but it flies
    in the face of the principle of variation. If two members of the population (out
    of perhaps thousands) are the only ones available to reproduce, the next generation
    will have little variety, and this may stunt the evolutionary process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出所有种群成员的适应度，选择过程的下一步就是选择哪些成员适合成为父母，并将他们放入配对池中。这个步骤有多种方法。例如，我可以使用**精英主义**方法，假设，“种群中得分最高的两位成员是谁？你们俩将为下一代繁殖所有的后代。”这是编程中最简单的方法之一，但它违背了变异的原则。如果种群中的两名成员（可能只有几千个成员中的两位）是唯一能够繁殖的个体，那么下一代将缺乏多样性，这可能会阻碍进化过程。
- en: I could instead make a mating pool out of a larger number of elements—for example,
    the top 50 percent of the population. This is another easy one to code, but it
    also won’t produce optimal results. In this case, the highest-scoring elements
    would have the same chance of being selected as the ones toward the middle. In
    a population of 1,000 phrases, why should the phrase ranked 500th have the same
    chance of reproducing as the phrase ranked 1st? For that matter, why should phrase
    500 have a solid shot of reproducing, while phrase 501 has no shot at all?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: A better solution for the mating pool is to use a **probabilistic** method,
    which I’ll call the *wheel of fortune* (aka the *roulette wheel*). To illustrate
    this method, let’s say a population has five elements, each with a fitness score.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '|  **Element**  | **Fitness** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| A | 3 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| B | 4 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| C | 0.5 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| D | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| E | 1.5 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: 'The first step is to **normalize** all the scores. Remember normalizing a vector?
    That involved taking a vector and standardizing its length, setting it to 1\.
    Normalizing a set of fitness scores standardizes their range from 0 to 1, as a
    percentage of total fitness. For that, first add up all the fitness scores:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: total fitness = 3 + 4 + 0.5 + 1 + 1.5 = 10
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Next, divide each score by the total fitness, resulting in the normalized fitness.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **Fitness** | **Normalized Fitness** | **Expressed as a Percentage**
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| A | 3 | 0.3 | 30% |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| B | 4 | 0.4 | 40% |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| C | 0.5 | 0.05 | 5% |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| D | 1 | 0.1 | 10% |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| E | 1.5 | 0.1 | 15% |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: Now it’s time for the wheel of fortune, shown in [Figure 9.2](ch09.xhtml#ch9fig2).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg486_Image_744.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: In this wheel of fortune, each slice of the wheel is sized according
    to a fitness value.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Spin the wheel and you’ll notice that element B has the highest chance of being
    selected, followed by A, then E, then D, and finally C. This probability-based
    selection according to fitness is an excellent approach. It guarantees that the
    highest-scoring elements will be most likely to reproduce, while also not entirely
    eliminating any variation from the population. Unlike with the elitist method,
    even the lowest-scoring element (in this case, C) has at least some chance of
    passing its information to the next generation. This is important because it’s
    quite possible (and often the case) that some low-scoring elements have tiny nuggets
    of genetic code that are truly useful and shouldn’t be removed from the population.
    For example, in the case of evolving “to be or not to be,” we might have the following
    elements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **DNA** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| A | to be or not to go |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| B | to be or not to pi |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| C | purrrrrrrrrrrrr be |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: As you can see, elements A and B are clearly the most fit and would have the
    highest score. But neither contains the correct characters for the end of the
    phrase. Element C, even though it would receive a very low score, happens to have
    the genetic data for the end of the phrase. While I might want A and B to be picked
    to generate the majority of the next generation, I still want C to have a small
    chance to participate in the reproductive process too.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Reproduction**'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that I’ve demonstrated a strategy for picking parents, the last step is
    to use **reproduction** to create the population’s next generation, keeping in
    mind the Darwinian principle of heredity—that children inherit properties from
    their parents. Again, numerous techniques could be employed here. For example,
    one reasonable (and easy-to-program) strategy is **cloning**, meaning just one
    parent is picked and an exact copy of that parent is created as a child element.
    As with the elitist approach to selection, however, this runs counter to the goal
    of variation. Instead, the standard approach with GAs is to pick two parents and
    create a child according to two steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**Crossover**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mutation**'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step, **crossover**, creates a child out of the genetic code of two
    parents. For the cat-typing example, say I’ve picked the following two parent
    phrases from the mating pool, as outlined in the selection step (I’m simplifying
    and using strings of length 6, instead of the 18 characters required for “to be
    or not to be”):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| Parent A | coding |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| Parent B | nature |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: The task at hand is now to create a child phrase from these two. Perhaps the
    most obvious way (call it the *50/50 method*) would be to take the first three
    characters from A and the second three from B, as shown in [Figure 9.3](ch09.xhtml#ch9fig3).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg488_Image_745.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: A 50/50 crossover'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: A variation of this technique is to pick a random midpoint. In other words,
    I don’t always have to pick exactly half of the characters from each parent. I
    could use a combination of 1 and 5, or 2 and 4\. This is preferable to the 50/50
    approach, since it increases the variety of possibilities for the next generation
    (see [Figure 9.4](ch09.xhtml#ch9fig4)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg488_Image_746.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Two examples of crossover from a random midpoint'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility is to randomly select a parent for each character in the
    child string, as in [Figure 9.5](ch09.xhtml#ch9fig5). You can think of this as
    flipping a coin six times: heads, take a character from parent A; tails, from
    parent B. This yields even more possible outcomes: *codurg*, *natine*, *notune*,
    and so on.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This strategy won’t significantly change the outcome from the random midpoint
    method; however, if the order of the genetic information plays a role in the fitness
    function, you may prefer one solution over the other. Other problems may benefit
    more from the randomness introduced by the coin-flipping approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg489_Image_747.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg489_Image_747.jpg)'
- en: 'Figure 9.5: Crossover with a coin-flipping approach'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：使用抛硬币的方法进行交叉
- en: 'Once the child DNA has been created via crossover, an extra, optional process
    can be applied before adding the child to the next generation: **mutation**. This
    second reproduction stage is unnecessary in some cases, but it exists to further
    uphold the Darwinian principle of variation. The initial population was created
    randomly, ensuring a variety of elements at the outset. However, this variation
    is limited by the size of the population, and the variation narrows over time
    by virtue of selection. Mutation introduces additional variety throughout the
    evolutionary process.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过交叉创建了子代DNA，在将子代加入到下一代之前，可以应用一个额外的可选过程：**变异**。这个第二次繁殖阶段在某些情况下是没有必要的，但它的存在是为了进一步维持达尔文的变异原则。最初的人口是随机创建的，确保了开头有各种不同的元素。然而，这种变异会受到人口规模的限制，随着选择的进行，变异会逐渐缩小。变异在整个进化过程中引入了额外的多样性。
- en: Mutation is described in terms of a *rate*. A given GA might have a mutation
    rate of 5 percent, or 1 percent, or 0.1 percent, for example. Say I’ve arrived
    through crossover at the child phrase *catire*. If the mutation rate is 1 percent,
    this means that each character in the phrase has a 1 percent chance of mutating
    before being “born” into the next generation. What does it mean for a character
    to mutate? In this case, mutation could be defined as picking a new random character.
    A 1 percent probability is fairly low, so most of the time mutation won’t occur
    at all in a six-character string (about 94 percent of the time, in fact). However,
    when it does, the mutated character is replaced with a randomly generated one
    (see [Figure 9.6](ch09.xhtml#ch9fig6)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 变异是通过*变异率*来描述的。给定的遗传算法可能会有5%的变异率，1%的变异率，或者0.1%的变异率。例如，假设我通过交叉得到了子代短语*catire*。如果变异率是1%，这意味着该短语中的每个字符都有1%的概率在进入下一代之前发生变异。那么，字符变异是什么意思呢？在这种情况下，变异可以定义为选择一个新的随机字符。1%的概率相对较低，因此在六个字符的字符串中，大部分时间（实际上大约94%的时间）变异不会发生。然而，当变异发生时，变异的字符将被一个随机生成的字符替代（见[图9.6](ch09.xhtml#ch9fig6)）。
- en: '![Image](../images/pg489_Image_748.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg489_Image_748.jpg)'
- en: 'Figure 9.6: Mutating the child phrase'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：变异子代短语
- en: As you’ll see in the coming examples, the mutation rate can greatly affect the
    behavior of the system. A very high mutation rate (such as, say, 80 percent) would
    negate the entire evolutionary process and leave you with something more akin
    to a brute-force algorithm. If the majority of a child’s genes are generated randomly,
    you can’t guarantee that the more fit genes occur with greater frequency with
    each successive generation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在接下来的示例中看到的，变异率可以大大影响系统的行为。非常高的变异率（比如80%）会使整个进化过程失效，留下的结果更像是一个暴力破解算法。如果大多数子代基因是随机生成的，就无法保证随着每一代的到来，更适应的基因会以更高的频率出现。
- en: Overall, the process of selection (picking two parents) and reproduction (crossover
    and mutation) is repeated *N* times until you have a new population of *N* child
    elements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，选择（选择两个父代）和繁殖（交叉和变异）过程会重复*N*次，直到生成一个新的*N*个子代元素的种群。
- en: '**Step 4: Repetition!**'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤4：重复！**'
- en: At this point, the new population of children becomes the current population.
    Then the process returns to step 2 and starts all over again, evaluating the fitness
    of each element, selecting parents, and producing another generation of children.
    Hopefully, as the algorithm cycles through more and more generations, the system
    evolves closer and closer to the desired solution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，新的子代种群将成为当前种群。然后，过程返回到步骤2，再次开始，评估每个元素的适应度，选择父代，并产生另一个子代种群。希望随着算法循环经过越来越多的代数，系统会越来越接近理想的解决方案。
- en: '**Coding the Genetic Algorithm**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写遗传算法代码**'
- en: Now that I’ve described all the steps of the GA, it’s time to translate them
    into code. Before I dive into the details of the implementation, let’s think about
    how these steps fit into the overall standard structure of a p5.js sketch. What
    goes into `setup()`, and what goes into `draw()`?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经描述了遗传算法的所有步骤，是时候将它们转化为代码了。在深入实施细节之前，让我们思考一下这些步骤如何融入到p5.js草图的标准结构中。`setup()`中应该包含什么内容，`draw()`中又应该包含什么内容？
- en: setup()
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: setup()
- en: 'Step 1, **Initialization**: Create a starting population of *N* elements, each
    with randomly generated DNA.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，**初始化**：创建一个包含*N*个元素的初始种群，每个元素都拥有随机生成的DNA。
- en: draw()
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: draw()
- en: 'Step 2, **Selection**: Evaluate the fitness of each element of the population
    and build a mating pool.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3, **Reproduction**: Repeat *N* times:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Pick two parents with probability according to relative fitness.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crossover:** Create a child by combining the DNA of these two parents.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutation:** Modify the child’s DNA based on a given probability.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the new child to a new population.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 4: Replace the old population with the new population and return to step
    2.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: With this plan in place, I can start writing the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Initialization**'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If I’m going to create a population, I need a data structure to store a list
    of elements in the population:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg490_Image_749.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Choosing an array to represent a list is straightforward, but the question
    remains: An array of what? An object is an excellent choice for storing the genetic
    information, as it can hold multiple properties and methods. These genetic objects
    will be structured according to a class that I’ll call `DNA`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What should go in the `DNA` class? For a typing cat, its DNA would be the random
    phrase it types, a string of characters. However, using an array of characters
    (rather than a string object) provides a more generic template that can extend
    easily to other data types. For example, the DNA of a creature in a physics system
    could be an array of vectors—or for an image, an array of numbers (RGB pixel values).
    Any set of properties can be listed in an array, and even though a string is convenient
    for this particular scenario, an array will serve as a better foundation for future
    evolutionary examples.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The GA specifies that I create a population of *N* elements, each with *randomly
    generated genes*. The DNA constructor therefore includes a loop to fill in each
    element of the `genes` array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg491_Image_750.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'To randomly generate a character, I’ll write a helper function called `randomCharacter()`
    for each individual gene:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg491_Image_751.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: The random numbers picked correspond to a specific character according to a
    standard known as **ASCII** (American Standard Code for Information Interchange),
    and `String.fromCharCode()` is a native JavaScript method that converts a number
    into its corresponding character based on that standard. The range I’ve specified
    encompasses upper- and lowercase letters, numbers, punctuation marks, and special
    characters. An alternative approach could use the Unicode standard, which includes
    emojis and characters from various world languages, providing a more extensive
    range of characters for a different target string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I have the constructor, I can return to `setup()` and initialize each
    `DNA` object in the `population` array:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg492_Image_752.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: The `DNA` class is not at all complete. I need to give it methods that perform
    all the other tasks in the GA. I’ll do that as I walk through steps 2 and 3.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Selection**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Step 2 reads, “Evaluate the fitness of each element of the population and build
    a mating pool.” I’ll start with the first part, evaluating each object’s fitness.
    Earlier I stated that one possible fitness function for the typed phrases is the
    total number of correct characters. Now I’ll revise this fitness function a little
    bit and state it as the *percentage* of correct characters—that is, the number
    of correct characters divided by the total number of characters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg492_Image_753.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Where should I calculate the fitness? Since the `DNA` class contains the genetic
    information (the phrase I will test against the target phrase), I can write a
    method inside the `DNA` class to score its own fitness. Let’s assume a target
    phrase:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I can now compare each gene against the corresponding character in the target
    phrase, incrementing a counter each time I find a correct character in the correct
    position. For example, a `t` is found in several places in `target`, but it increases
    the fitness only if it is in the `genes` array at the correct corresponding index:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg493_Image_754.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Since fitness is calculated for each subsequent generation, the very first
    step I’ll take inside the `draw()` loop is to call the fitness function for each
    member of the population:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the fitness scores have been computed, the next step is to build the *mating
    pool* for the reproduction process. The mating pool is a data structure from which
    two parents are repeatedly selected. Recalling the description of the selection
    process, the goal is to pick parents with probabilities calculated according to
    fitness. The members of the population with the highest fitness scores should
    be the most likely to be selected; those with the lowest scores, the least likely.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 0](ch00.xhtml#ch00), I covered the basics of probability and generating
    a custom distribution of random numbers. I’m going to use the same techniques
    here to assign a probability to each member of the population, picking parents
    by spinning the wheel of fortune. Revisiting [Figure 9.2](ch09.xhtml#ch9fig2),
    your mind might immediately go back to [Chapter 3](ch03.xhtml#ch03) and contemplate
    coding a simulation of an actual spinning wheel. As fun as this might be (and
    you should make one!), it’s quite unnecessary.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: One solution that could work here is to pick from the five options depicted
    in [Figure 9.2](ch09.xhtml#ch9fig2) (A, B, C, D, E) according to their probabilities
    by filling an array with multiple instances of each parent. In other words, imagine
    you have a bucket of wooden letters, as in [Figure 9.7](ch09.xhtml#ch9fig7). Based
    on the earlier probabilities, it should contain 30 As, 40 Bs, 5 Cs, 10 Ds, and
    15 Es. If you were to pick a random letter out of that bucket, you’d have a 30
    percent chance of getting an A, a 5 percent chance of getting a C, and so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg494_Image_755.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: A bucket full of letters A, B, C, D, and E. The higher the fitness,
    the more instances of the letter in the bucket.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：一个装满字母A、B、C、D和E的桶。适应度越高，桶中某个字母的出现次数越多。
- en: 'For the GA code, that bucket could be an array, and each wooden letter a potential
    parent `DNA` object. The mating pool is therefore created by adding each parent
    to the array a certain number of times, scaled according to that parent’s fitness
    score:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GA代码来说，这个桶可以是一个数组，每个木制字母都是一个潜在的父母`DNA`对象。因此，配对池是通过根据每个父母的适应度分数，按一定次数将每个父母添加到数组中来创建的：
- en: '![Image](../images/pg494_Image_756.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg494_Image_756.jpg)'
- en: With the mating pool ready to go, it’s time to select two parents! Picking two
    parents for each child is a somewhat arbitrary decision. It certainly mirrors
    human reproduction and is the standard means in the textbook GA, but in terms
    of creative applications, there really aren’t restrictions here. You could choose
    only one parent for cloning, or devise a reproduction methodology for picking
    three or four parents from which to generate child DNA. For this demonstration,
    I’ll stick to two parents and call them `parentA` and `parentB`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好配对池后，接下来是选择两个父母！为每个孩子挑选两个父母是一个有些任意的决定。这确实反映了人类的生殖过程，并且是教科书中遗传算法的标准方法，但在创意应用方面，这里并没有限制。你可以选择只有一个父母进行克隆，或者设计一种繁殖方法，从三个或四个父母中挑选，生成子代DNA。为了演示，我将坚持使用两个父母，并称它们为`parentA`和`parentB`。
- en: 'I can select two random instances of DNA from the mating pool by using the
    p5.js `random()` function. When an array is passed as an argument to `random()`,
    the function returns a single random element from the array:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用p5.js的`random()`函数从配对池中选择两个随机DNA实例。当一个数组作为参数传递给`random()`时，该函数返回数组中的一个随机元素：
- en: '[PRE4]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method of building a mating pool and choosing parents from it works, but
    it isn’t the only way to perform selection. Other, more memory-efficient techniques
    don’t require an additional array full of multiple references to each element.
    For example, think back to the discussion of nonuniform distributions of random
    numbers in [Chapter 0](ch00.xhtml#ch00). There, I implemented the accept-reject
    method. If applied here, the approach would be to randomly pick an element from
    the original `population` array, and then pick a second, qualifying random number
    to check against the element’s fitness value. If the fitness is less than the
    qualifying number, start again and pick a new element. Keep going until two parents
    are deemed fit enough.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建配对池并从中选择父母的方法是有效的，但这并不是执行选择的唯一方式。其他一些更节省内存的技术不需要额外的数组来存储对每个元素的多个引用。例如，回想一下[第0章](ch00.xhtml#ch00)中关于随机数非均匀分布的讨论。在那里，我实现了接受-拒绝方法。如果应用到这里，这种方法将是从原始的`population`数组中随机挑选一个元素，然后再挑选一个符合条件的随机数来与该元素的适应度值进行对比。如果适应度小于符合条件的数字，就重新开始，选择一个新的元素。一直重复，直到选出两个适应度足够高的父母。
- en: Yet another excellent alternative is worth exploring that similarly capitalizes
    on the principle of fitness-proportionate selection. To understand how it works,
    imagine a relay race in which each member of the population runs a given distance
    tied to its fitness. The higher the fitness, the farther they run. Let’s also
    assume that the fitness values have been normalized to all add up to 1 (just as
    with the wheel of fortune). The first step is to pick a *starting line—*a random
    distance from the finish. This distance is a random number from 0 to 1\. (You’ll
    see in a moment that the finish line is assumed to be at 0.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得探索的优秀替代方案，类似地利用了适应度比例选择的原理。为了理解它是如何工作的，想象一下一个接力赛，每个种群成员跑的距离与其适应度相关。适应度越高，跑得越远。假设适应度值已经标准化，所有的适应度值加起来为1（就像幸运转盘一样）。第一步是选择一个*起跑线*——从终点到起点的随机距离。这个距离是一个从0到1的随机数。（你会马上看到，终点被假设为0。）
- en: '[PRE5]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then the relay race begins at the starting line with the first member of the
    population:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后接力赛从起点开始，由种群的第一位成员起跑：
- en: '[PRE6]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The runner travels a distance defined by its normalized fitness score, then
    hands the baton to the next runner:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 赛跑者按照其标准化的适应度分数跑一定的距离，然后将接力棒交给下一个跑者：
- en: '![Image](../images/pg495_Image_757.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg495_Image_757.jpg)'
- en: The steps are repeated over and over again in a `while` loop until the race
    ends ( `start` is less than or equal to `0`, the finish line). The runner who
    crosses the finish threshold is selected as a parent.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤会在`while`循环中反复执行，直到比赛结束（`start`小于或等于`0`，即终点）。跨过终点线的跑者被选为父母。
- en: 'Here are all the steps together in a function that returns the selected element:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg496_Image_758.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: This works well for selection because every member has a shot at crossing the
    finish line (the elements’ fitness scores all add up to 1), but those who run
    longer distances (that is, those with higher fitness scores) have a better chance
    of making it there. However, while this method is more memory efficient, it can
    be more *computationally* demanding, especially for large populations, as it requires
    iterating through the population for each selection. By contrast, the original
    `matingPool` array method needs only a single random lookup into the array per
    parent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the specific requirements and constraints of your application of
    GAs, one approach might prove more suitable than the other. I’ll alternate between
    them in the examples outlined in this chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.2**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Revisit the accept-reject algorithm from [Chapter 0](ch00.xhtml#ch00) and rewrite
    the `weightedSelection()` function to use accept-reject instead. Like the relay
    race method, this technique can also end up being computationally intensive, since
    several potential parents may be rejected as unfit before one is finally chosen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.3**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the wheel-of-fortune algorithm will have an extraordinarily
    high preference for some elements over others. Take the following probabilities:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **Probability** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| A | 98% |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| B | 1% |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| C | 1% |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: 'This is sometimes undesirable, given that it will decrease the amount of variety
    in this system. A solution to this problem is to replace the calculated fitness
    scores with the ordinals of scoring (meaning their rank):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '| **Element** | **Rank** | **Probability** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| A | 1 | 50% (1/2) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| B | 2 | 33% (1/3) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| C | 3 | 17% (1/6) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: 'How can you implement an approach like this? Hint: You don’t need to modify
    the selection algorithm. Instead, your task is to calculate the probabilities
    from the rank rather than the raw fitness score.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: For any of these algorithms, the same parent could be picked twice for a given
    child. If I wanted, I could enhance the algorithm to ensure that this isn’t possible.
    This would likely have very little impact on the end result, but it may be worth
    exploring as an exercise.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.4**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Pick any of the weighted selection algorithms and adapt the algorithm to guarantee
    that two unique parents are picked.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Reproduction (Crossover and Mutation)**'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once I have the two parents, the next step is to perform a **crossover** operation
    to generate child DNA, followed by **mutation**:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg497_Image_759.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Of course, the `crossover()` and `mutate()` methods don’t magically exist in
    the `DNA` class; I have to write them. The way I’ve called `crossover()` indicates
    that it should receive an instance of `DNA` as an argument ( `parentB` ) and return
    a new instance of `DNA`, the `child`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg498_Image_760.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: This implementation uses the random midpoint method of crossover, in which the
    first section of genes is taken from parent A and the second from parent B.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.5**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the crossover function to use the coin-flipping method instead, in which
    each gene has a 50 percent chance of coming from parent A and a 50 percent chance
    of coming from parent B.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mutate()` method is even simpler to write than `crossover()`. All I need
    to do is loop through the array of genes and randomly pick a new character according
    to the defined mutation rate. With a mutation rate of 1 percent, for example,
    a new character would be generated only 1 out of 100 times:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The entire method therefore reads as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg499_Image_761.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: Once again, I’m able to use the `randomCharacter()` helper function to simplify
    the mutation process.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**Putting It All Together**'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve now walked through the steps of the GA twice—once describing the algorithm
    in narrative form, and another time with code snippets implementing each of the
    steps. Now I’m ready to put it all together and show you the complete code alongside
    the basic steps of the algorithm.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg499_Image_762.jpg)![Image](../images/pg500_Image_763.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: The *sketch.js* file precisely mirrors the steps of the GA. However, most of
    the functionality called upon is encapsulated in the `DNA` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg501_Image_764.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: In [Example 9.1](ch09.xhtml#ch9ex1), you might notice that new child elements
    are directly added to the `population` array. This approach is possible because
    I have a separate mating pool array that contains references to the original parent
    elements. However, if I were to instead use the relay-race `weightedSelection()`
    function, I’d need to create a temporary array for the new population. This temporary
    array would hold the child elements and replace the original population array
    only after the reproduction step is completed. You’ll see this implemented in
    [Example 9.2](ch09.xhtml#ch9ex2).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.6**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Add features to [Example 9.1](ch09.xhtml#ch9ex1) to report more information
    about the progress of the GA itself. For example, show the phrase closest to the
    target in each generation, as well as a report on the number of generations, the
    average fitness, and so on. Stop the GA after it has solved the phrase. Consider
    writing a `Population` class to manage the GA, instead of including all the code
    in `draw()`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg502_Image_766.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: '![Image](../images/pencil.jpg) **Exercise 9.7**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Explore the idea of a dynamic mutation rate. For example, try calculating a
    mutation rate that inversely correlates with the average fitness of the parent
    phrases so that higher fitness results in fewer mutations. Does this change affect
    the behavior of the overall system and how quickly the target phrase is found?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Customizing Genetic Algorithms**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nice thing about using GAs in a project is that example code can easily
    be ported from application to application. The core mechanics of selection and
    reproduction don’t need to change. However, you, the creator, will have to customize
    three key components of GAs for each use. This is crucial to moving beyond trivial
    demonstrations of evolutionary simulations (as in the Shakespeare example) to
    creative uses in projects that you make in p5.js and other programming environments.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Key 1: The Global Variables**'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The GA doesn’t have a lot of variables. If you look at the code in [Example
    9.1](ch09.xhtml#ch9ex1), you’ll see only two global variables (not including the
    arrays to store the population and mating pool):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These two variables can greatly affect the behavior of the system, and it’s
    not such a good idea to arbitrarily assign them values (though tweaking them through
    trial and error is a perfectly reasonable way to arrive at optimal values).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'I chose the values for the Shakespeare demonstration to virtually guarantee
    that the GA would solve for the phrase, but not too quickly (approximately 1,000
    generations on average), so as to demonstrate the process over a reasonable period
    of time. A much larger population, however, would yield faster results (if the
    goal were algorithmic efficiency rather than demonstration). Here’s a table of
    some results:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '| **Population** | **Mutation** | **Number of Generations Until the Phrase
    Is Solved** | **Total Time (in Seconds) Until the Phrase Is Solved** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| 150 | 1% | 1,089 | 18.8 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| 300 | 1% | 448 | 8.2 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| 1,000 | 1% | 71 | 1.8 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| 50,000 | 1% | 27 | 4.3 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: Notice that increasing the population size drastically reduces the number of
    generations needed to solve for the phrase. However, it doesn’t necessarily reduce
    the amount of time. Once the population balloons to 50,000 elements, the sketch
    begins to run slowly, given the amount of time required to process fitness and
    build a mating pool out of so many elements. (Of course, optimizations could be
    made should you require such a large population.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the population size, the mutation rate can greatly affect performance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '|  **Population**  | **Mutation** | **Number of Generations Until the Phrase
    Is Solved** | **Total Time (in Seconds) Until the Phrase Is Solved** |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| 1,000 | 0% | 37 or never? | 1.2 or never? |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| 1,000 | 1% | 71 | 1.8 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| 1,000 | 2% | 60 | 1.6 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| 1,000 | 10% | Never? | Never? |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: Without any mutation at all (0 percent), you just have to get lucky. If all
    the correct characters are present somewhere in an element of the initial population,
    you’ll evolve the phrase very quickly. If not, there’s no way for the sketch to
    ever reach the exact phrase. Run it a few times and you’ll see both instances.
    In addition, once the mutation rate gets high enough (10 percent, for example),
    so much randomness is involved (1 out of every 10 letters is random in each new
    child) that the simulation is pretty much back to a randomly typing cat. In theory,
    it will eventually solve the phrase, but you may be waiting much, much longer
    than is reasonable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '**Key 2: The Fitness Function**'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Playing around with the mutation rate or population size is pretty easy and
    involves little more than typing numbers in your sketch. The real hard work of
    developing a GA is in writing the fitness function. If you can’t define your problem’s
    goals and evaluate numerically how well those goals have been achieved, you won’t
    have successful evolution in your simulation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I move on to other scenarios exploring more sophisticated fitness functions,
    I want to look at flaws in my Shakespearean fitness function. Consider solving
    for a phrase that isn’t 18 characters long, but 1,000\. And take two elements
    of the population, one with 800 characters correct and one with 801\. Here are
    their fitness scores:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| **Phrase** | **Characters Correct** | **Fitness** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| A | 800 | 80.0% |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| B | 801 | 80.1% |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: This scenario has a couple of problems. First, I’m adding elements to the mating
    pool *N* times, where *N* equals fitness multiplied by 100\. But objects can be
    added to an array only a whole number of times, so A and B will both be added
    80 times, giving them an equal probability of being selected. Even with an improved
    solution that takes floating-point probabilities into account, 80.1 percent is
    only a teeny tiny bit higher than 80 percent. But getting 801 characters right
    is a whole lot better than 800 in the evolutionary scenario. I really want to
    make that additional character count. I want the fitness score for 801 characters
    to be *substantially* better than the score for 800.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: To put it another way, [Figure 9.8](ch09.xhtml#ch9fig8) shows graphs of two
    possible fitness functions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg505_Image_767.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: A fitness graph of *y* = *x* (left) and of *y* = *x*² (right)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: On the left is a linear graph; as the number of characters goes up, so does
    the fitness score. By contrast, in the graph on the right, as the number of characters
    goes up, the fitness score goes *way* up. That is, the fitness increases at an
    accelerating rate as the number of correct characters increases.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'I can achieve this second type of result in various ways. For example, I could
    say this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: fitness = (correct characters)²
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the fitness scores increase **quadratically**, meaning proportional to
    the square of the number of correct characters. Say I have two members of the
    population, one with five correct characters and one with six. The number 6 is
    a 20 percent increase over the number 5\. However, by squaring the correct characters,
    the fitness value will go from 25 to 36, a 44 percent increase:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '| **Correct Characters** | **Fitness** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| 5 | 25 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| 6 | 36 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: 'Here’s another formula:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: fitness = 2^(correct characters)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s how that formula plays out as the number of correct characters increases:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '| **Correct Characters** | **Fitness** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| 2 | 4 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| 3 | 8 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| 4 | 16 |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: Here, the fitness scores increase **exponentially**, doubling with each additional
    correct character.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.8**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the fitness function to increase quadratically or exponentially, according
    to the number of correct characters. Note that you’ll likely have to normalize
    the fitness values to a range from 0 to 1 so they can be added to the mating pool
    a reasonable number of times, or use a different weighted-selection method.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'While this rather specific discussion of exponential versus linear equations
    is an important detail in the design of a good fitness function, I don’t want
    you to miss the more important point here: *design your own fitness function!*
    I seriously doubt that any project you undertake in p5.js with GAs will involve
    counting the correct number of characters in a string. In the context of this
    book, you’ll more likely be looking to evolve a creature that’s part of a physics
    system. Perhaps you’re looking to optimize the weights of steering behaviors so
    a creature can best escape a predator or avoid an obstacle or make it through
    a maze. You have to ask yourself what you’re hoping to evaluate.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a racing simulation in which a vehicle is evolving a design optimized
    for speed:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: fitness = total number of frames required for vehicle to reach race finish
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: How about a mouse that’s evolving the optimal way to find a piece of cheese?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: fitness = mouse distance to cheese
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The design of computer-controlled players in a game is also a common scenario.
    Say you’re programming a soccer game in which the user is the goalie. The rest
    of the players are controlled by your program and have a set of parameters that
    determine how they kick a ball toward the goal. What would be the fitness score
    for any given player?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: fitness = total goals scored
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: This, of course, is a simplistic take on the game of soccer, but it illustrates
    the point. The more goals a player scores, the higher its fitness, and the more
    likely its genetic information will appear in the next game. Even with a fitness
    function as simple as the one described here, this scenario is demonstrating something
    powerful—the adaptability of a system. If the players continue to evolve from
    game to game to game, when a new *human* user enters the game with a completely
    different strategy, the system will quickly discover that the fitness scores are
    going down and evolve a new optimal strategy. It will adapt. (Don’t worry, there’s
    very little danger of this resulting in sentient, soccer-playing robots that will
    enslave all humans.)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, if you don’t have a fitness function that effectively evaluates
    the performance of the individual elements of your population, you won’t have
    any evolution. And the fitness function from one example will likely not apply
    to a totally different project. You have to design a function, sometimes from
    scratch, that works for your particular project. And where do you do this? All
    you have to edit are those few lines of code inside the method that computes the
    `fitness` variable:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Filling in those question marks is the part where you get to shine!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '**Key 3: The Genotype and Phenotype**'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final key to designing your own GA relates to the way you choose to encode
    the properties of your system. What are you trying to express, and how can you
    translate that expression into a bunch of numbers? What is the genotype and phenotype?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'I started with the Shakespeare example because of how easy it is to design
    both the genotype (an array of characters) and its expression, the phenotype (the
    string displayed on the canvas). It isn’t always this easy, however. For example,
    when talking about the fitness function for a soccer game, I happily assumed the
    existence of computer-controlled kickers that each have a “set of parameters that
    determine how they kick a ball toward the goal,” but actually determining what
    those parameters are and how you choose to encode them would require some thought
    and creativity. And of course, there’s no one correct answer: how you design the
    system is up to you.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news—and I hinted at this earlier in the chapter—is that you’ve been
    translating genotypes (data) into phenotypes (expression) all along. Anytime you
    write a class in p5.js, you make a whole bunch of variables:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg507_Image_768.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: 'All you need to do to evolve those variables is to turn them into an array,
    so that the array can be used with all the methods—`crossover()`, `mutate()`,
    and the like—found in the `DNA` class. One common solution is to use an array
    of floating-point numbers from 0 to 1:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg508_Image_769.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: 'Notice that I’ve now put the raw genetic data (genotype) and its expression
    (phenotype) into two separate classes. The `DNA` class is the genotype—it’s just
    a bunch of numbers. The `Vehicle` class is the phenotype—it’s an expression of
    how to turn those numbers into animated, visual behaviors. The two can be linked
    by including a `DNA` instance inside the `Vehicle` class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg508_Image_770.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: 'Of course, you most likely don’t want all your variables to have a range from
    0 to 1\. But rather than try to remember how to adjust those ranges in the `DNA`
    class, it’s easier to pull the original genetic information from the `DNA` object
    and then use p5.js’s `map()` function to change the range as needed for your phenotype.
    For example, if you want a `size` variable between 10 and 72, you would say this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In other cases, you may want to design a genotype that’s an array of objects.
    Consider the design of a rocket with a series of thruster engines. You could consider
    each thruster to be a vector that describes its direction and relative strength:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg508_Image_771.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: 'The phenotype would be a `Rocket` class that participates in a physics system:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What’s great about dividing the genotype and phenotype into separate classes
    ( `DNA` and `Rocket`, for example) is that when it comes time to build all the
    code, you’ll notice that the `DNA` class I developed earlier remains intact. The
    only thing that changes is the kind of data stored in the array (numbers, vectors,
    and so on) and the expression of that data in the phenotype class.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I’ll follow this idea a bit further and walk through the
    necessary steps to implement an example that involves moving bodies and an array
    of vectors as DNA.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '**Evolving Forces: Smart Rockets**'
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I mentioned rockets for a specific reason: in 2009, Jer Thorp released a GAs
    example on his blog titled “Smart Rockets.” Thorp pointed out that the National
    Aeronautics and Space Administration (NASA) uses evolutionary computing techniques
    to solve all sorts of problems, from satellite antenna design to rocket-firing
    patterns. This inspired him to create a Flash demonstration of evolving rockets.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the scenario: a population of rockets launches from the bottom of the
    screen with the goal of hitting a target at the top of the screen. Obstacles block
    a straight-line path to the target (see [Figure 9.9](ch09.xhtml#ch9fig9)).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg510_Image_773.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: A population of smart rockets seeking a delicious strawberry planet'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Each rocket is equipped with five thrusters of variable strength and direction
    ([Figure 9.10](ch09.xhtml#ch9fig10)). The thrusters don’t fire all at once and
    continuously; rather, they fire one at a time in a custom sequence.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’m going to evolve my own simplified smart rockets, inspired
    by Thorp’s. When I get to the end of the section, I’ll leave implementing some
    of Thorp’s additional advanced features as an exercise.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg510_Image_774.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: A single smart rocket with five thrusters, carrying Clawdius the
    astronaut'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: My rockets will have only one thruster, which will be able to fire in any direction
    with any strength for every frame of animation. This isn’t particularly realistic,
    but it will make building out the example a little easier. (You can always make
    the rocket and its thrusters more advanced and realistic later.)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**Developing the Rockets**'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To implement my evolving smart rockets, I’ll start by taking the `Mover` class
    from [Chapter 2](ch02.xhtml#ch02) and renaming it `Rocket`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg511_Image_775.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: With this class, I can move the rocket by calling `applyForce()` with a new
    force for every frame of animation. The thruster applies a single force to the
    rocket each time through `draw()`. But at this point, I’m far from done. To make
    my rockets “smart” and evolvable, I need to think about the three keys to programming
    a custom GA, as outlined in the previous section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '**Key 1** is to define the right global variables for the population size and
    mutation rate. I’m going to hold off on worrying too much about these variables
    for now and arbitrarily choose reasonable-sounding numbers—perhaps a population
    of 50 rockets and a mutation rate of 1 percent. Once I’ve built out the system
    and have my sketch up and running, I can experiment with these numbers.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '**Key 2** is to develop an appropriate fitness function. In this case, the
    goal of a rocket is to reach its target. The closer a rocket gets to the target,
    the higher its fitness. Fitness is therefore inversely proportional to distance:
    the smaller the distance, the greater the fitness, and the greater the distance,
    the smaller the fitness.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this into practice, I first need to add a property to the `Rocket` class
    to store its fitness:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg511_Image_776.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: 'Next, I need to add a method to calculate the fitness to the `Rocket` class.
    After all, only a `Rocket` object knows how to compute its distance to the target,
    so the fitness function should live in this class. Assuming I have a `target`
    vector, I can write the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg512_Image_778.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: 'This is perhaps the simplest fitness function I could write. By dividing `1`
    by the distance, large distances become small numbers and small distances become
    large. If I want to use my quadratic trick from the previous section, I could
    divide `1` by the distance squared instead:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg512_Image_779.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: I’ll want to make several additional improvements to the fitness function, but
    this is a good start.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, **Key 3** is to think about the relationship between the genotype
    and the phenotype. I’ve stated that each rocket has a thruster that fires in a
    variable direction with a variable magnitude—in other words, a vector! The genotype,
    the data required to encode the rocket’s behavior, is therefore an array of vectors,
    one for each frame of the animation:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The happy news here is that I don’t really have to do anything else to the `DNA`
    class. All the functionality for the typing cat (crossover and mutation) still
    applies. The one difference I do have to consider is how to initialize the array
    of genes. With the typing cat, I had an array of characters and picked a random
    character for each element of the array. Now I’ll do exactly the same thing and
    initialize a DNA sequence as an array of random vectors.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Your instinct in creating a random vector might be as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code is perfectly fine and will likely do the trick. However, if I were
    to draw every single possible vector that could be picked, the result would fill
    a square (see [Figure 9.11](ch09.xhtml#ch9fig11), left). In this case, it probably
    doesn’t matter, but there’s a slight bias to the diagonals given that a vector
    from the center of a square to a corner is longer than a purely vertical or horizontal
    one.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg513_Image_780.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Vectors created with random *x* and *y* values (left) and using
    `p5.Vector.random2D()` (right)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall from [Chapter 3](ch03.xhtml#ch03), a better choice is to
    pick a random angle and create a vector of length 1 from that angle. This produces
    results that form a circle (see the right of [Figure 9.11](ch09.xhtml#ch9fig11))
    and can be achieved with polar-to-Cartesian conversion or the trusty `p5.Vector.random2D()`
    method:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg513_Image_781.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: 'A vector of length 1 would actually create quite a large force. Remember, forces
    are applied to acceleration, which accumulates into velocity 30 times per second
    (or whatever the frame rate is). Therefore, for this example, I’ll add another
    variable to the `DNA` class, a maximum force, and randomly scale all the vectors
    to be somewhere from 0 to the maximum. This will control the thruster power:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg514_Image_783.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: Notice that I’m using `lifeSpan` to set the length of `genes`, the array of
    vectors. This global variable stores the total number of frames in each generation’s
    life cycle, allowing me to create a vector for each frame of the rocket’s life.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression of this array of vectors, the phenotype, is my `Rocket` class.
    To cement the connection, I need to add an instance of a `DNA` object to the class:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg514_Image_784.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: 'What am I using `this.dna` for? As the rocket launches, it marches through
    the array of vectors and applies them one at a time as a force. To achieve this,
    I’ll need to include the variable `this.geneCounter` to help step through the
    array:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg514_Image_785.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: Now I have a `DNA` class (genotype) and a `Rocket` class (phenotype). The last
    piece of the puzzle is a mechanism for managing the population of rockets and
    implementing selection and reproduction.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '**Managing the Population**'
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To keep my *sketch.js* file tidier, I’ll put the code for managing the array
    of `Rocket` objects in a `Population` class. As with the `DNA` class, the happy
    news is that I barely have to change anything from the typing cats example. I’m
    just organizing the code in a more object-oriented way, with a `selection()` method
    and a `reproduction()` method. For the sake of demonstrating a different technique,
    I’ll also normalize the fitness values in `selection()` and use the weighted-selection
    (relay-race) algorithm in `reproduction()`. This eliminates the need for a separate
    mating-pool array. The `weightedSelection()` code is the same as that written
    earlier in the chapter:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg515_Image_787.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: 'I need to make one more fairly significant change, however. With typing cats,
    a random phrase was evaluated as soon as it was created. The string of characters
    had no life span; it existed purely for the purpose of calculating its fitness.
    The rockets, however, need to live for a period of time before they can be evaluated—that
    is, they need to be given a chance to make their attempt at reaching the target.
    Therefore, I need to add one more method to the `Population` class that runs the
    physics simulation. This is identical to what I did in the `run()` method of a
    particle system—update all the particle positions and draw them:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg516_Image_789.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: 'Finally, I’m ready for `setup()` and `draw()`. Here, my primary responsibility
    is to implement the steps of the GA in the appropriate order by calling the methods
    from the `Population` class:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, unlike the Shakespeare example, I don’t want to do this every frame.
    Rather, my steps work as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Create a population of rockets.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the rockets live for *N* frames.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evolve the next generation:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selection
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reproduction
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return to step 2.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To know when to go from step 2 to 3, I need a `lifeCounter` variable that tracks
    the current generation’s progress, along with the `lifeSpan` variable. In `draw()`,
    while `lifeCounter` is less than `lifeSpan`, the population’s `live()` method
    is called to run the simulation. Once `lifeCounter` hits `lifeSpan`, it’s time
    for `fitness()`, `selection(),` and `reproduction()` to evolve a new generation
    of rockets.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg517_Image_790.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the code, you’ll see that I’ve added a new feature: when the
    mouse is clicked, the target position is moved to the coordinates of the mouse
    cursor. This change allows you to observe how the rockets adapt and adjust their
    trajectories toward the new target position as the system continuously evolves
    in real time.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '**Making Improvements**'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: My smart rockets work but aren’t particularly exciting yet. After all, the rockets
    simply evolve toward having DNA with a bunch of vectors that point straight at
    the target. To make the example more interesting, I’m going to suggest two improvements.
    For starters, when I first introduced the smart rocket scenario, I said the rockets
    should evolve the ability to avoid obstacles. Adding this feature will make the
    system more complex and demonstrate the power of the evolutionary algorithm more
    effectively.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'To evolve obstacle avoidance, I need some obstacles to avoid. I can easily
    create rectangular, stationary obstacles by implementing a class of `Obstacle`
    objects that store their own position and dimensions:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg519_Image_791a.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: 'I’ll add a `contains()` method to the `Obstacle` class that returns `true`
    if a rocket has hit the obstacle, or `false` otherwise:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg519_Image_791b.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: 'If I create an array of `Obstacle` objects, I can then have each rocket check
    to see whether it has collided with each obstacle. If a collision occurs, the
    rocket can set the Boolean flag `hitObstacle` to `true`. To achieve this, I need
    to add a method to the `Rocket` class:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg519_Image_792.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: 'If the rocket hits an obstacle, I’ll stop the rocket from updating its position.
    The revised `run()` method now receives an `obstacles` array as an argument:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg519_Image_793.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: 'I also have an opportunity to adjust the fitness of the rocket. If the rocket
    hits an obstacle, the fitness should be penalized and greatly reduced:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg520_Image_795.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: With that, the rockets should be able to evolve to avoid obstacles. But I won’t
    stop now. I’d like to make another improvement.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely at [Example 9.2](ch09.xhtml#ch9ex2), you’ll notice that
    the rockets aren’t rewarded for getting to the target faster. The only variable
    in the fitness calculation is the distance to the target at the end of the generation’s
    life. In fact, in the event that a rocket gets very close to the target but overshoots
    it and flies past, it may actually be penalized for getting to the target faster.
    Slow and steady wins the race in this case.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'I could improve the algorithm in several ways to optimize for speed to reach
    the target. First, I could calculate a rocket’s fitness based on the closest it
    comes to the target at any point during its life, instead of using its distance
    to the target at the end of the generation. I’ll call this variable the rocket’s
    `recordDistance` and update it as part of a `checkTarget()` method on the `Rocket`
    class:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg520_Image_796.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, a rocket deserves a reward based on the speed with which it reaches
    its target. For that, I need a way of knowing when a rocket has hit the target.
    Actually, I already have one: the `Obstacle` class has a `contains()` method,
    and there’s no reason the target can’t also be implemented as an obstacle. It’s
    just an obstacle that the rocket *wants* to hit! I can use the `contains()` method
    to set a new `hitTarget` flag on each `Rocket` object. A rocket will stop if it
    hits the target, just as it stops if it hits an obstacle:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg521_Image_797.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: 'Remember, I also want the rocket to have a higher fitness the faster it reaches
    the target. Conversely, the slower it reaches the target, the lower its fitness
    score. To implement this, a `finishCounter` can be incremented every cycle of
    the rocket’s life until it reaches the target. At the end of its life, the counter
    will equal the amount of time the rocket took to reach the target:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg521_Image_798.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: 'I want the fitness to be inversely proportional to `finishCounter` as well.
    To achieve this, I can improve the fitness function with the following changes:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg521_Image_799.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: Both improvements are incorporated into the code for [Example 9.3](ch09.xhtml#ch9ex3).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg522_Image_800.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: This example could be improved and further expanded in many ways. The following
    exercises offer ideas and challenges to explore GAs in more depth. What else can
    you try?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.9**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Create a more complex obstacle course. As you make it more difficult for the
    rockets to reach the target, do you need to improve other aspects of the GA—for
    example, the fitness function?
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.10**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Implement the rocket-firing pattern of Thorp’s original smart rockets. Each
    rocket gets only five thrusters (of any direction and strength) that follow a
    firing sequence (of arbitrary length). Thorp’s simulation also gives the rockets
    a finite amount of fuel.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.11**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Visualize the simulation differently. Can you draw a line for the shortest path
    to the target? Can you draw the rockets in a more interesting way? What about
    adding particle systems that act as smoke in the direction of the rocket thrusters?
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.12**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Another way to teach a rocket to reach a target is to evolve a flow field. Can
    you make the genotype of a rocket a flow field of vectors?
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '**Interactive Selection**'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Karl Sims is a computer graphics researcher and visual artist who worked extensively
    with GAs. (He’s also well known for his work with particle systems!) One of his
    innovative evolutionary projects is the museum installation *Galapagos*. Originally
    installed in the NTT InterCommunication Center in Tokyo in 1997, the installation
    consists of 12 monitors displaying computer-generated images. These images evolve
    over time, following the GA steps of selection and reproduction.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The innovation here isn’t the use of the GA, but rather the strategy behind
    the fitness function. In front of each monitor is a sensor on the floor that can
    detect the presence of a visitor viewing the screen. The fitness of an image is
    tied to the length of time that viewers look at the image. This is known as **interactive
    selection**, a GA with fitness values assigned by people.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Far from being confined to art installations, interactive selection is quite
    prevalent in the digital age of user-generated ratings and reviews. Could you
    imagine evolving the perfect song based on your Spotify ratings? Or the ideal
    book according to Goodreads reviews? In keeping with the book’s nature theme,
    however, I’ll illustrate how interactive selection works by using a population
    of digital flowers like the ones in [Figure 9.12](ch09.xhtml#ch9fig12).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg523_Image_801.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Flower design for interactive selection'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Each flower will have a set of properties: petal color, petal size, petal count,
    center color, center size, stem length, and stem color. A flower’s DNA (genotype)
    is an array of floating-point numbers from 0 to 1, with a single value for each
    property:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg523_Image_802.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'The phenotype is a `Flower` class that includes an instance of a `DNA` object:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg524_Image_804.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
- en: When it comes time to draw the flower, I’ll use p5.js’s `map()` function to
    convert any gene value to the appropriate range for pixel dimensions or color
    values. (I’ll also use `colorMode()` to set the RGB ranges from 0 to 1.)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg524_Image_805.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: Up to this point, I haven’t done anything new. This is the same process I’ve
    followed in every GA example so far. What’s different is that I won’t be writing
    a `fitness()` function that computes the score based on a mathematical formula.
    Instead, I’ll ask the user to assign the fitness.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: How exactly to ask a user to assign fitness is best approached as an interaction
    design problem and isn’t really within the scope of this book. I’m not going to
    launch into an elaborate discussion of how to program sliders or build your own
    hardware dials or create a web app enabling people to submit online scores. How
    you choose to acquire fitness scores is up to you and the particular application
    you’re developing. For this demonstration, I’ll take inspiration from Sims’s *Galapagos*
    installation and simply increase a flower’s fitness whenever the mouse is over
    it. Then the next generation of flowers is created when an Evolve Next Generation
    button is pressed.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Look at how the steps of the GA—selection and reproduction—are applied in the
    `nextGeneration()` function, which is triggered by the `mousePressed()` event
    attached to the p5.js `button` element. Fitness is increased as part of the `Population`
    class’s `rollover()` method, which detects the presence of the mouse over any
    given flower design. You can find more details about the sketch in the accompanying
    example code on the book’s website.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg525_Image_806.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: This example is just a demonstration of the idea of interactive selection and
    doesn’t achieve a particularly meaningful result. For one, I didn’t take much
    care in the visual design of the flowers; they’re just a few simple shapes with
    different sizes and colors. (See if you can spot the use of polar coordinates
    in the code, though!) Sims used more elaborate mathematical functions as the genotype
    for his images. You might also consider a vector-based approach, in which a design’s
    genotype is a set of points or paths.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The more significant problem here, however, is one of time. In the natural world,
    evolution occurs over millions of years. In the computer simulation world of the
    chapter’s first examples, the populations are able to evolve behaviors relatively
    quickly because the new generations are being produced algorithmically. In the
    typing cat example, a new generation is born in each cycle through `draw()` (approximately
    60 per second). Each generation of smart rockets has a life span of 250 frames—still
    a mere blink of the eye in evolutionary time. In the case of interactive selection,
    however, you have to sit and wait for a person to rate each and every member of
    the population before you can get to the next generation. A large population would
    be unreasonably tedious for the user to evaluate—not to mention, how many generations
    could you stand to sit through?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: You can certainly get around this problem in clever ways. Sims’s *Galapagos*
    exhibit concealed the rating process from the viewers, as it occurred through
    the normal behavior of looking at artwork in a gallery setting. Building a web
    application that would allow many people to rate a population in a distributed
    fashion is also a good strategy for achieving ratings for large populations quickly.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the key to a successful interactive selection system boils down
    to the same keys previously established. What are the genotype and phenotype?
    And how do you calculate fitness—or in this case, what’s your strategy for assigning
    fitness according to interaction?
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.13**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Build your own interactive selection project. In addition to a visual design,
    consider evolving sounds—for example, a short sequence of tones. Can you devise
    a strategy, such as a web application or physical sensor system, to acquire ratings
    from many people over time?
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pencil.jpg) **Exercise 9.14**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Another of Karl Sims’s seminal works in the field of GAs is “Evolved Virtual
    Creatures.” In this project, a population of digital creatures in a simulated
    physics environment is evaluated for their ability to perform tasks, such as swimming,
    running, jumping, following, and competing for a green cube. The project uses
    a node-based genotype: the creature’s DNA isn’t a linear list of vectors or numbers,
    but a map of nodes (much like the soft-body simulation in [Chapter 6](ch06.xhtml#ch06)).
    The phenotype is the creature’s body itself, a network of limbs connected with
    muscles.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Can you design the DNA for a flower, plant, or creature as a network of parts?
    One idea is to use interactive selection to evolve the design. Alternatively,
    you could incorporate spring forces, perhaps with Toxiclibs.js or Matter.js, to
    create a simplified 2D version of Sims’s creatures. What if they were to evolve
    according to a fitness function associated with a specific goal? For more about
    Sims’s techniques, you can read his 1994 paper (*[https://www.karlsims.com/papers/siggraph94.pdf](https://www.karlsims.com/papers/siggraph94.pdf)*)
    and watch the “Evolved Virtual Creatures” video on YouTube (*[https://youtu.be/RZtZia4ZkX8](https://youtu.be/RZtZia4ZkX8)*).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg527_Image_808.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
- en: '**Ecosystem Simulation**'
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed something a bit odd about the evolutionary systems I’ve
    built so far in this chapter. In the real world, a population of babies isn’t
    born all at the same time. Those babies don’t then grow up and all reproduce at
    exactly the same time, then instantly die, leaving the population size perfectly
    stable. That would be ridiculous. Not to mention that certainly no one is running
    around the forest with a calculator crunching numbers and assigning fitness values
    to all the creatures.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, as I discussed at the start of the chapter, you don’t really
    have survival of the fittest; you have *survival of the reproducers*. Creatures
    that happen to live longer, in many cases, have a greater chance of reproducing.
    Babies are born, they live for a while, maybe they themselves have babies, maybe
    they don’t, and then they die. Could I write a sketch that captures this more
    realistic take on evolutionary biology?
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: You won’t necessarily find simulations of real-world evolution in artificial
    intelligence textbooks. GAs are generally used in the more formal manner outlined
    earlier in this chapter. However, since you’re reading this book to develop simulations
    of natural systems, it’s worth looking at how you might use a GA to build something
    that resembles a living ecosystem, much like the one I’ve described in the project
    prompts at the end of each chapter.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll begin by imagining a simple scenario. I’ll create a creature called a
    *bloop*, a circle that moves about the canvas according to Perlin noise. The creature
    will have a radius and a maximum speed. The bigger it is, the slower it moves;
    the smaller, the faster:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg528_Image_809.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
- en: 'As usual, the population of bloops can be stored in an array, which in turn
    can be managed by a class called `World`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg528_Image_810.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
- en: 'So far, I’m just rehashing the particle systems from [Chapter 4](ch04.xhtml#ch04).
    I have an entity called `Bloop` that moves around the canvas, and a class called
    `World` that manages a variable quantity of these entities. To turn this into
    a system that evolves, I need to add two additional features to my world:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '**Bloops die.**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bloops are born.**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bloops dying is my replacement for a fitness function and the process of selection.
    If a bloop dies, it can’t be selected to be a parent, because it no longer exists!
    One way I can build a mechanism to ensure bloop deaths in the world is by adding
    a `health` variable to the `Bloop` class:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg529_Image_811.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: 'Each time through `update()`, a bloop loses some of its health:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg529_Image_812.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
- en: 'If `health` drops below `0`, the bloop dies:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg529_Image_813.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: This is a good first step, but I haven’t really achieved anything. After all,
    if all bloops start with 100 health points and lose health at the same rate, then
    all bloops will live for the exact same amount of time and die together. If every
    single bloop lives the same amount of time, each one has an equal chance of reproducing,
    and therefore no evolutionary change will occur.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: You can achieve variable life spans in several ways with a more sophisticated
    world. One approach is to introduce predators that eat bloops. Faster bloops would
    be more likely to escape being eaten, leading to the evolution of increasingly
    faster bloops. Another option is to introduce food. When a bloop eats food, its
    health points increase, extending its life.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume I have an array of vector positions called `food`. I could test
    each bloop’s proximity to each food position. If the bloop is close enough, it
    eats the food (which is then removed from the world) and increases its health.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg530_Image_814.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
- en: In this scenario, bloops that eat more food are expected to live longer and
    have a greater likelihood of reproducing. As a result, the system should evolve
    bloops with an optimal ability to find and consume food.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Now that the world has been built, it’s time to add the components necessary
    for evolution. The first step is to establish the genotype and phenotype.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '**Genotype and Phenotype**'
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ability for a bloop to find food is tied to two variables: size and speed
    (see [Figure 9.13](ch09.xhtml#ch9fig13)). Bigger bloops will find food more easily
    simply because their size will allow them to intersect with food positions more
    often. And faster bloops will find more food because they can cover more ground
    in a shorter period of time.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg530_Image_815.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Small and big bloop creatures. The example will use simple circles,
    but you should try being more creative!'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Since size and speed are inversely related (large bloops are slow, small bloops
    are fast), I need a genotype with only a single number.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg530_Image_816.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: 'The phenotype is the bloop itself, whose size and speed are assigned by adding
    an instance of a `DNA` object to the `Bloop` class:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg531_Image_817.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: Note that the `maxSpeed` property is mapped to a range from `15` to `0`. A bloop
    with a gene value of `0` will move at a speed of `15`, while a bloop with a gene
    value of `1` won’t move at all (speed of `0`).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection and Reproduction**'
  id: totrans-464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that I have the genotype and phenotype, I need to move on to devising a
    method for selecting bloops as parents. I stated before that the longer a bloop
    lives, the more chances it has to reproduce. The length of a bloop’s life is its
    fitness.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: One option would be to say that whenever two bloops come into contact with each
    other, they make a new bloop. The longer a bloop lives, the more likely it is
    to come into contact with another bloop. This would also affect the evolutionary
    outcome, since the likelihood of giving birth, in addition to eating food, depends
    on a bloop’s ability to locate other bloops.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: A simpler option would be for bloops to clone themselves without needing a partner
    bloop, creating another bloop with the same genetic makeup instantly. For example,
    what if I said that at any given moment, a bloop has a 1 percent chance of reproducing?
    With this selection algorithm, the longer a bloop lives, the more likely it will
    clone itself. This is equivalent to saying the more times you play the lottery,
    the greater the likelihood you’ll win (though I’m sorry to say your chances of
    winning the lottery are still essentially zero).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this selection algorithm, I can write a method in the `Bloop`
    class that picks a random number every frame. If the number is less than 0.01
    (1 percent), a new bloop is born:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg531_Image_818.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
- en: 'How does a bloop reproduce? In previous examples, the reproduction process
    involved calling the `crossover()` method in the `DNA` class and creating a new
    object from the resulting array of genes. However, in this case, since I’m making
    a child from a single parent, I’ll call a method called `copy()` instead:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg532_Image_819.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: Note that I’ve lowered the probability of reproduction from 1 percent to 0.05
    percent. This change makes a significant difference; with a high reproduction
    probability, the system will rapidly become overpopulated. Too low a probability,
    and everything will likely die out quickly.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the `copy()` method into the `DNA` class is easy with the JavaScript
    array method `slice()`, a standard JavaScript method that makes a new array by
    copying elements from an existing array:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg532_Image_820.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
- en: With the selection and reproduction pieces in place, I can finalize the `World`
    class to manage a list of all `Bloop` objects, as well as a `Food` object that
    contains a list of positions for the food (which I’ll draw as small squares).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Before you run the example, take a moment to guess which size and speed of bloops
    the system will evolve toward. I’ll discuss these details following the code.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg533_Image_821.jpg)![Image](../images/pg534_Image_822.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
- en: If you guessed medium-sized bloops with medium speed, you’re right. With the
    design of this system, bloops that are large are simply too slow to find food.
    And bloops that are fast are too small to find food. The ones that are able to
    live the longest tend to be in the middle, large enough and fast enough to find
    food (but not too large or too fast). Some anomalies also exist. For example,
    if a bunch of large bloops happen to end up in the same position (and barely move
    because they are so large), they may all die out suddenly, leaving a lot of food
    for one large bloop that happens to be there to eat and allowing a mini population
    of large bloops to sustain themselves for a period of time in one position.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: This example is rather simplistic given its single gene and cloning instead
    of crossover. Here are some suggestions for applying the bloop example in a more
    elaborate ecosystem simulation.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'Add evolution to your ecosystem, building from the examples in this chapter:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Add a population of predators to your ecosystem. Biological evolution between
    predators and prey (or parasites and hosts) is often referred to as an *arms race*,
    in which the creatures continuously adapt and counter-adapt to one another. Can
    you achieve this behavior in a system of multiple creatures?
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you implement crossover and mutation between two parents in an ecosystem
    modeled after the bloops? Try implementing an algorithm so that two creatures
    mate when within a certain proximity.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try using the weights of multiple steering forces as a creature’s DNA. Can you
    create a scenario in which creatures evolve to cooperate with one another?
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the greatest challenges in ecosystem simulations is achieving balance.
    You will likely find that most of your attempts result in either mass overpopulation
    (followed by mass extinction) or mass extinction straight away. What techniques
    can you employ to achieve balance? Consider using the GA to evolve optimal parameters
    for an ecosystem.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg535_Image_823.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
