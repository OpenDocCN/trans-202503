["```\n\n      // Project 27 - Experimenting with Timer Overflows and Interrupts\n\n      #include <avr/io.h>\n\n      ❶ #include <avr/interrupt.h>\n\n      #include <util/delay.h>\n\n      ❷ ISR(TIMER1_OVF_vect)\n\n      {\n\n      // Code to be executed when an interrupt is triggered from TIMER1 overflow.\n\n      // For this example, quickly blink LED on PB1.\n\n      PORTB = 0b00000010;\n\n      _delay_ms(5);\n\n      PORTB = 0b00000000;\n\n      }\n\n      void initOVI()\n\n      // Set up overflow interrupt and TIMER1\n\n      {\n\n      ❸ TCCR1B = 0b00000010; // Set CS10 and CS11 for /8 prescaler\n\n      ❹ TIMSK1 = 0b00000001;  // Turn on TIMER1 interrupt on overflow\n\n      ❺ sei();                // Turn on global interrupts\n\n      }\n\n      int main(void)\n\n      {\n\n      DDRB = 0b11111111;    // Set PORTB register as outputs\n\n      initOVI();            // Set up overflow interrupt and TIMER1\n\n      for(;;)               // Do something (such as blink LED on PB0)\n\n      {\n\n      PORTB = 0b00000001;\n\n      _delay_ms(100);\n\n      PORTB = 0b00000000;\n\n      _delay_ms(100);\n\n      }\n\n      return 0;\n\n      }\n\n```", "```\n\n      // Project 28 - Using a CTC Timer for Repetitive Actions\n\n      #include <avr/io.h>\n\n      #include <avr/interrupt.h>\n\n      #include <util/delay.h>\n\n      ❶ ISR(TIMER1_COMPA_vect)\n\n      {\n\n      // Code to be executed when an interrupt is triggered from TIMER1 overflow.\n\n      // For this example, quickly blink LED on PB1.\n\n      ❷ TCNT1 = 0;\n\n      PORTB = 0b00000010;\n\n      _delay_ms(10);\n\n      PORTB = 0b00000000;\n\n      // Reset TIMER1 to zero, so counting can start again.\n\n      TCNT1 = 0;\n\n      }\n\n      ❸ void initCTC()\n\n      // Set up CTC interrupt and TIMER1\n\n      {\n\n      ❹ OCR1A = 14649;       // Number of periods to watch for: 14,649\n\n      // Turn on CTC mode and set CS12 and CS10 for /1024 prescaler\n\n      ❺ TCCR1B = 0b00000101;\n\n      ❻ TIMSK1 = 0b00000010; // Turn on timer compare interrupt\n\n      sei();               // Turn on global interrupts\n\n      }\n\n      int main(void)\n\n      {\n\n      DDRB = 0b11111111;   // Set PORTB register as outputs\n\n      initCTC();           // Set up overflow interrupt and TIMER1\n\n      for(;;)              // Do something (such as blink LED on PB0)\n\n      {\n\n      PORTB = 0b00000001;\n\n      _delay_ms(100);\n\n      PORTB = 0b00000000;\n\n      _delay_ms(100);\n\n      }\n\n      return 0;\n\n      }\n\n```", "```\n\n      // Project 29 - Using CTC Timers for Repetitive Actions with Longer Delays\n\n      #include <avr/io.h>\n\n      #include <avr/interrupt.h>\n\n      #include <util/delay.h>\n\n      ❶ uint16_t target = 1;\n\n      // Interval in seconds between running function \"targetFunction\"\n\n      ❷ uint16_t targetCount = 0;\n\n      // Used to track number of seconds for CTC counter resets\n\n      ❸ void targetFunction()\n\n      {\n\n      // Do something once target duration has elapsed\n\n      PORTB = 0b00000010;\n\n      _delay_ms(100);\n\n      PORTB = 0b00000000;\n\n      }\n\n      ISR(TIMER1_COMPA_vect)\n\n      { // Code to be executed when an interrupt is triggered from CTC\n\n      ❹ targetCount++;       // Add one to targetCount\n\n      ❺ if (targetCount == target)\n\n      // If required period of time has elapsed\n\n      {\n\n      ❻ TCNT1 = 0;        // Reset TIMER1 to zero\n\n      ❼ targetFunction(); // Do something\n\n      ❽ targetCount = 0;  // Reset targetCount to zero\n\n      }\n\n      }\n\n      void initCTC()\n\n      // Set up CTC interrupt and TIMER1\n\n      {\n\n      OCR1A = 15625;       // Number of periods to watch for - 15625 = 1 second\n\n      // Turn on CTC mode and set CS10 and CS11 for /64 prescaler\n\n      TCCR1B = 0b00000011;\n\n      TIMSK1 = 0b00000010; // Turn on timer compare interrupt\n\n      sei();               // Turn on global interrupts\n\n      }\n\n      int main(void)\n\n      {\n\n      DDRB = 0b11111111;   // Set PORTB register as outputs\n\n      initCTC();           // Set up overflow interrupt and TIMER1\n\n      for(;;)              // Do something (blink LED on PB0)\n\n      {\n\n      PORTB = 0b00000001;\n\n      _delay_ms(100);\n\n      PORTB = 0b00000000;\n\n      _delay_ms(100);\n\n      }\n\n      return 0;\n\n      }\n\n```", "```\n\n     DDRB = 0b11111111;  // Set PORTB to outputs\n\n     . . .\n\n     PORTB = 0b00000001; // Set PB0 on\n\n```", "```\n\n             `registername` \n             |= (1 <<\n             `bitname` \n             );\n\n    ```", "```\n\n             PORTB |= (1 << 7);\n\n    ```", "```\n\n             `registername` \n             ^= (1 <<\n             `bitname` \n             ); // Toggle bit \"bitname\"\n\n    ```", "```\n\n             PORTB ^= (1 << 3); // Toggle bit PB3\n\n    ```", "```\n\n             PORTB ^= (1 << 3); // Toggle PB3\n\n             _delay_ms(250);    // Wait 250 milliseconds\n\n    ```", "```\n\n             `registername` \n             &= ~(1 <<\n             `bitname` \n             ); // Set bit \"bitname\" to 0\n\n    ```", "```\n\n             PORTB &= ~(1 << 7);\n\n    ```", "```\n\n             `registername` \n             |= (1 <<\n             `bitname` \n             )|(1 <<\n             `bitname` \n             );\n\n    ```", "```\n\n             PORTB |= (1 << PORTB7)|(1 << PORTB0);\n\n    ```", "```\n\n             PORTB |= (1 << PORTB7)|(1 << PORTB3)|(1 << PORTB0);\n\n    ```", "```\n\n             `registername` \n             ^= (1 <<\n             `bitname` \n             )|(1 <<\n             `bitname` \n             );\n\n    ```", "```\n\n             PORTB ^= (1 << PORTB3)|(1 << PORTB0);\n\n    ```", "```\n\n             PORTB ^= (1 << PORTB7)|(1 << PORTB3)|(1 << PORTB0);\n\n    ```", "```\n\n             `registername` \n             &= ~(1 <<\n             `bitname` \n             )&~(1 <<\n             `bitname` \n             );\n\n    ```", "```\n\n             PORTB &= ~(1 << PORTB7)&~(1 << PORTB0);\n\n    ```", "```\n\n             PORTB &= ~(1 << PORTB7)&~(1 << PORTB3)&~(1 << PORTB0);\n\n    ```", "```\n\n      // Project 30 - Experimenting with Overflow Timers Using Bitwise Operations\n\n      #include <avr/io.h>\n\n      #include <avr/interrupt.h>\n\n      #include <util/delay.h>\n\n      ISR(TIMER1_OVF_vect)\n\n      {\n\n      // Code to be executed when an interrupt is triggered from TIMER1 overflow.\n\n      // For this example, quickly blink LED on PB1.\n\n      ❶ PORTB |= (1 << PORTB1);          // PB1 on\n\n      _delay_ms(5);\n\n      ❷ PORTB &= ~(1 << PORTB1);         // PB1 off\n\n      }\n\n      void initOVI()\n\n      // Set up overflow interrupt and TIMER1\n\n      {\n\n      ❸ TCCR1B |= (1 << CS11);           // Set prescaler to /8\n\n      ❹ TIMSK1 |= (1 << TOIE1);          // Enable TIMER1 overflow interrupts\n\n      sei();                           // Turn on global interrupts\n\n      }\n\n      int main(void)\n\n      {\n\n      ❺ DDRB |= (1 << DDB0)|(1 << DDB1); // Set PORTB pins 0 and 1 as outputs\n\n      initOVI();                       // Set up overflow interrupt and TIMER1\n\n      for(;;)                          // Do something (blink LED on PB0)\n\n      {\n\n      ❻ PORTB ^=(1 << PORTB0);        // Toggle PB0\n\n      _delay_ms(100);\n\n      }\n\n      return 0;\n\n      }\n\n```"]