<html><head></head><body>
<h2 class="h2" id="ch06"><a id="page_77"/><strong><span class="big">6</span></strong><br/><strong>BLACK-BOX TESTING</strong></h2>
<p class="noindent">While white-box testing is almost always the best way to security test an application, sometimes you simply have to do your testing without source code or insight into a program’s design. In these cases, you’ll need to dig a little deeper into the guts of iOS, especially into the realm of Objective-C and the Mach-O binary format.</p>
<p class="indent">Black-box testing on iOS is a rapidly moving target—it relies on the continuous development of jailbreaks, as well as robust third-party tools and debugging implements. I’ve tried to make the techniques and tools described in this chapter as future-proof as possible to give you a solid foundation to build on.</p>
<p class="indent">To effectively black-box test an iOS application, you’ll first need to get a jailbroken device so that you can sideload applications and install your testing tool chain. The details of jailbreaking change too rapidly for me to document here, but you can usually find current information from the iPhone Dev Team<sup><a href="footnote.html#fn37" id="fn_37">1</a></sup> or iClarified.<sup><a href="footnote.html#fn38" id="fn_38">2</a></sup></p>
<p class="indent">Once you’ve jailbroken your device, launch Cydia, choose <strong>Developer</strong> mode, and then update your package list (under Changes).</p>
<p class="indentb"><a id="page_78"/>Now you can load your device with some testing tools, primarily from the Cydia app store. These are the must-haves:</p>
<p class="hanging"><strong>odcctools</strong> This includes otool, lipo, and other development goodies.</p>
<p class="hanging"><strong>OpenSSH</strong> You’ll need this to actually access the device. Be sure to change the passwords of your <code>root</code> and <code>mobile</code> accounts <em>immediately</em> using the <code>passwd(1)</code> command.</p>
<p class="hanging"><strong>MobileTerminal</strong> This will allow you to navigate the command line on the device itself, when necessary.</p>
<p class="hanging"><strong>cURL</strong> You’ll want this for downloading remote files over HTTP or FTP.</p>
<p class="hanging"><strong>Erica Utilities</strong> This includes a smattering of useful utilities from Erica Sadun. See a detailed list at <em><a href="http://ericasadun.com/ftp/EricaUtilities/">http://ericasadun.com/ftp/EricaUtilities/</a></em>.</p>
<p class="hanging"><strong>vbindiff</strong> This is a binary diff program to help verify changes to binaries.</p>
<p class="hanging"><strong>netcat</strong> This is your general, all-purpose network listener.</p>
<p class="hanging"><strong>rsync</strong> You can install this for syncing whole directory trees to and from the device.</p>
<p class="hanging"><strong>tcpdump</strong> You can install this for capturing network traffic dumps for analysis.</p>
<p class="hanging"><strong>IPA Installer Console</strong> This will allow you to directly install <em>.ipa</em> files copied to the device.</p>
<p class="hanging"><strong>Cydia Substrate</strong> This tool is used for hooking and modifying the behavior of applications.</p>
<p class="indentt">Now, let’s look at how you can get these testing tools onto your device.</p>
<h3 class="h3" id="ch06lev1sec01"><strong>Installing Third-Party Apps</strong></h3>
<p class="noindent">Depending on how you’ve come to possess your application files, there are a couple of ways to sideload them onto your device.</p>
<h4 class="h4" id="ch06lev2sec01"><em><strong>Using a .app Directory</strong></em></h4>
<p class="noindent">If you’ve acquired a <em>.app</em> directory, you can do the following:</p>
<p class="indent">First, archive your <em>.app</em> bundle with <code>tar</code>, and use <code>scp</code> to copy the archive over to your test device, as follows:</p>
<pre>$ tar -cvzf archive.tar.gz mybundle.app}<br/>$ scp archive.tar.gz root@dev.ice.i.p:</pre>
<p class="indent"><a id="page_79"/>Then <code>ssh</code> to your device and untar the bundle into the <em>/Applications</em> directory:</p>
<pre>$ cd /Applications<br/>$ tar -xvzf ~/archive.tar.gz</pre>
<p class="indent">This should put the application right next to the official Apple-supplied applications. To get it to show up on the home screen, you’ll need to either restart the SpringBoard or reboot the device. To restart SpringBoard, you can use the <code>killall</code> command, like this:</p>
<pre>$ killall -HUP SpringBoard</pre>
<p class="indent">If you find yourself needing to “respring” a lot, you can use a tool like CCRespring from Cydia, as shown in <a href="ch06.html#ch6fig1">Figure 6-1</a>.</p>
<div class="image"><img alt="image" src="graphics/f06-01.jpg"/></div>
<p class="figcap"><a id="ch6fig1"/><em>Figure 6-1: A simple respring button added to the Control Center by CCRespring</em></p>
<p class="indent">Tools like CCRespring add a button that you can press to restart the SpringBoard so you don’t have to go to the command line every time.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Some have reported that simply respringing the device does not cause the application to appear on the SpringBoard. In this case, you can either reboot or run the</em> <code><em>uicache</em></code> <em>command as the</em> <code><em>mobile</em></code> <em>user.</em></p>
</div>
<h4 class="h4" id="ch06lev2sec02"><a id="page_80"/><em><strong>Using a .ipa Package File</strong></em></h4>
<p class="noindent">If you’ve been given (or have otherwise obtained) a <em>.ipa</em> package file, you can copy it to your device with <code>scp</code> and install it using the <code>installipa</code> command, as follows:</p>
<pre>$ installipa ./Wikipedia-iOS.ipa<br/>Analyzing Wikipedia-iOS.ipa...<br/>Installing Wikipedia (v3.3)...<br/>Installed Wikipedia (v3.3) successfully.<br/><br/>$ ls Applications/CC189021-7AD0-498F-ACB6-356C9E521962<br/>Documents  Library  Wikipedia-iOS.app  tmp</pre>
<h3 class="h3" id="ch06lev1sec02"><strong>Decrypting Binaries</strong></h3>
<p class="noindent">Before you can inspect the contents of binaries, you’ll need to decrypt them. There are a couple of ways to do so. The simplest way is to use a prepackaged tool, such as Stefan Esser’s dumpdecrypted.<sup><a href="footnote.html#fn39" id="fn_39">3</a></sup> This is a shared library that is dynamically loaded when executing your application. You can use it as follows:</p>
<pre>$ git clone https://github.com/stefanesser/dumpdecrypted<br/>$ cd dumpdecrypted<br/>$ make<br/>$ scp dumpdecrypted.dylib root@your.dev.ice:<br/>$ ssh root@your.dev.ice<br/>$ DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Applications/(APP_ID)/<br/>     YourApp.app/YourApp</pre>
<p class="indent">This will output a decrypted version of the binary within the <em>tmp</em> directory of the application’s <em>.app</em> bundle.</p>
<p class="indent">Because there have been many automated tools for dumping decrypted binaries, most of which have become unusable, it’s best to have a backup method. For a more robust and (ideally) future-proof way to decrypt binaries and to help you understand some of the inner workings of application encryption and decryption, you can use command line tools and lldb.<sup><a href="footnote.html#fn40" id="fn_40">4</a></sup></p>
<p class="indent">To create a decrypted binary, you’ll follow these basic steps:</p>
<ol>
<li><p class="noindent">Analyze the binary to determine the location of its encrypted portion.</p></li>
<li><p class="noindent">Run the application under lldb.</p></li>
<li><p class="noindent"><a id="page_81"/>Dump the unencrypted segment to disk.</p></li>
<li><p class="noindent">Copy the original binary for use as a donor file.</p></li>
<li><p class="noindent">Remove the donor binary’s <code>cryptid</code> flag.</p></li>
<li><p class="noindent">Transplant the unencrypted segment into the donor binary.</p></li>
</ol>
<p class="indent">Let’s discuss this decryption process in more detail.</p>
<h4 class="h4" id="ch06lev2sec03"><em><strong>Launching the debugserver on the Device</strong></em></h4>
<p class="noindent">Before you can get a memory dump, you need to get Apple’s debugserver onto the device. The debugserver is in <em>DeveloperDiskImage.dmg</em>, buried inside Xcode. From the command line, you can attach the disk image and extract the debugserver to a local directory, as shown in <a href="ch06.html#ch6ex1">Listing 6-1</a>.</p>
<pre>$ hdiutil attach /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/7.1\ \(11D167\)/DeveloperDiskImage.dmg<br/><br/>Checksumming whole disk (Apple_HFS : 0)<br/>..................................................................<br/>      disk (Apple_HFS : 0): verified CRC32 $D1221D77<br/>      verified   CRC32 $B5681BED<br/>      /dev/disk6         /Volumes/DeveloperDiskImage<br/><br/>$ cp /Volumes/DeveloperDiskImage/usr/bin/debugserver .</pre>
<p class="listcap"><a id="ch6ex1"/><em>Listing 6-1: Extracting the debugserver from the Developer Disk Image</em></p>
<p class="indent">Once you’ve copied over the debugserver, you’ll need to edit the entitlements of the binary. Normally, when Xcode itself uses the debugserver, it launches applications directly; you want to change its permissions to allow it to attach to arbitrary running programs on the device. First, generate a plist using the current entitlements of the binary, as follows:</p>
<pre>$ codesign --display --entitlements entitlements.plist debugserver</pre>
<p class="indent">This should result in an XML-formatted plist file with the following contents:</p>
<pre>&lt;?<span class="rose">xml version</span>=<span class="red">"1.0"</span> encoding=<span class="red">"UTF-8"</span>?&gt;<br/>&lt;!<span class="rose">DOCTYPE</span> plist <span class="rose">PUBLIC</span> <span class="red">"-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/</span><br/>     <span class="red">PropertyList-1.0.dtd"</span>&gt;<br/>&lt;plist <span class="rose">version</span>=<span class="red">"1.0"</span>&gt;<br/>&lt;dict&gt;<br/>        &lt;key&gt;com.apple.backboardd.debugapplications&lt;/key&gt;<br/>        &lt;true/&gt;<br/>        &lt;key&gt;com.apple.backboardd.launchapplications&lt;/key&gt;<br/>        &lt;true/&gt;<br/>        &lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt;<br/>        &lt;true/&gt;<br/>        &lt;key&gt;run-unsigned-code&lt;/key&gt;<br/>        &lt;true/&gt;<br/>        &lt;key&gt;seatbelt-profiles&lt;/key&gt;<br/>        &lt;array&gt;<br/>                &lt;string&gt;debugserver&lt;/string&gt;<br/>        &lt;/array&gt;<br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</pre>
<p class="indent"><a id="page_82"/>This file needs to be updated to include the <code>get-task-allow</code> and <code>task_for_pid-allow</code> entitlements and remove the <code>seatbelt-profiles</code> entitlement. Those updates will result in a plist like the following:</p>
<pre>&lt;!<span class="rose">DOCTYPE</span> plist <span class="rose">PUBLIC</span> <span class="red">"-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/</span><br/>     <span class="red">PropertyList-1.0.dtd"</span>&gt;<br/>&lt;plist <span class="rose">version</span>=<span class="red">"1.0"</span>&gt;<br/>&lt;dict&gt;<br/>    &lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt;<br/>    &lt;true/&gt;<br/>    &lt;key&gt;run-unsigned-code&lt;/key&gt;<br/>    &lt;true/&gt;<br/>    &lt;key&gt;get-task-allow&lt;/key&gt;<br/>    &lt;true/&gt;<br/>    &lt;key&gt;task_for_pid-allow&lt;/key&gt;<br/>    &lt;true/&gt;<br/>&lt;/dict&gt;<br/>&lt;/plist&gt;</pre>
<p class="indent">After updating the <em>entitlements.plist</em> file, you’d use it to sign the application (thus overwriting the existing entitlements of the binary) and copy the debugserver to the device, as shown here:</p>
<pre>$ codesign -s - --entitlements entitlements.plist -f debugserver<br/>debugserver: replacing existing signature<br/>$ scp debugserver root@de.vi.ce.ip:</pre>
<p class="indent">Now you can finally debug the application. Ensure that the program you want to debug is currently running on the device and then launch the debugserver to attach to it, like this:</p>
<pre>$ ssh root@de.vi.ce.ip<br/>$ ./debugserver *:666 --attach=Snapchat<br/><br/>debugserver-310.2 for arm64.<br/><br/>Attaching to process Snapchat...<br/>Listening to port 666 for a connection from *...</pre>
<p class="indent"><a id="page_83"/>This example debugserver is now listening for a network connection from another machine running lldb. Next, on your local machine, you’d connect to the device as follows:</p>
<pre>$ lldb<br/>(lldb) platform select remote-ios<br/>  Platform: remote-ios<br/> Connected: no<br/>  SDK Path: "/Users/lx/Library/Developer/Xcode/iOS DeviceSupport/8.0 (12A4265u)"<br/> SDK Roots: [ 0] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/4.2"<br/> SDK Roots: [ 1] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/4.3"<br/> SDK Roots: [ 2] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/5.0"<br/> SDK Roots: [ 3] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/5.1"<br/> SDK Roots: [ 4] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/6.0"<br/> SDK Roots: [ 5] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/6.1"<br/> SDK Roots: [ 6] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/7.0"<br/> SDK Roots: [ 7] "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.<br/>     platform/DeviceSupport/7.1 (11D167)"<br/> SDK Roots: [ 8] "/Users/lx/Library/Developer/Xcode/iOS DeviceSupport/5.0.1<br/>     (9A405)"<br/> SDK Roots: [ 9] "/Users/lx/Library/Developer/Xcode/iOS DeviceSupport/6.0.1<br/>      (10A523)"<br/> SDK Roots: [10] "/Users/lx/Library/Developer/Xcode/iOS DeviceSupport/7.0.4<br/>     (11B554a)"<br/> SDK Roots: [11] "/Users/lx/Library/Developer/Xcode/iOS DeviceSupport/8.0<br/>     (12A4265u)"<br/> SDK Roots: [12] "/Users/lx/Library/Developer/Xcode/iOS DeviceSupport/8.0<br/>     (12A4297e)"<br/><br/>(lldb) process connect connect://de.vi.ce.ip:666<br/>Process 2801 stopped<br/>* thread #1: tid = 0x18b64b, 0x0000000192905cc0 libsystem_kernel.dylib`<br/>     mach_msg_trap + 8, stop reason = signal SIGSTOP<br/>    frame #0: 0x0000000192905cc0 libsystem_kernel.dylib`mach_msg_trap + 8<br/>libsystem_kernel.dylib`mach_msg_trap + 8:<br/>-&gt; 0x192905cc0:  b      0x19290580c<br/><br/>libsystem_kernel.dylib`mach_msg_overwrite_trap:<br/>   0x192905cc4:  .long  0x0000093a                ; unknown opcode<br/>   0x192905cc8:  ldr    w16, 0x192905cd0          ; semaphore_signal_trap<br/>   0x192905ccc:  b      0x19290580c</pre>
<p class="indent"><a id="page_84"/>In this example, the running program is now interrupted, and at this point, you’d be free to manipulate it with lldb on your local machine. To extract the decrypted program data, you’d next need to determine which part of the binary the encrypted segment resides in.</p>
<p class="indent">Note that you may find that a network connection is too unstable to complete the memory dump successfully. If this is the case, you can use the <code>iproxy</code> command included with usbmuxd to act as a proxy between your USB port and a TCP port, as follows:</p>
<pre>$ brew install usbmuxd<br/>$ iproxy 1234 1234 &amp;<br/>$ lldb<br/>(lldb) process connect connect://127.0.0.1:1234</pre>
<p class="indent">These commands connect to a network socket with lldb but actually go over the USB port.</p>
<h4 class="h4" id="ch06lev2sec04"><em><strong>Locating the Encrypted Segment</strong></em></h4>
<p class="noindent">To locate the encrypted segment, you’ll require odcctools and lldb. First, run <code>otool -l <em>myBinary</em></code> and view the output in your favorite pager. You can do this either on the device or on your local machine. The copy included with OS X has a more modern version of otool that will provide cleaner output. Here’s an example:</p>
<pre>$ otool -fh Snapchat<br/>Fat headers<br/>fat_magic 0xcafebabe<br/>nfat_arch 2<br/>architecture 0<br/>    cputype 12<br/>    cpusubtype 9<br/>    capabilities 0x0<br/>    offset 16384<br/>    size 9136464<br/>    align 2^14 (16384)<br/>architecture 1<br/>    cputype 12<br/>    cpusubtype 11<br/>    capabilities 0x0<br/>    offset 9158656<br/>    size 9169312<br/>    align 2^14 (16384)<br/>Snapchat (architecture armv7:<br/>Mach header<br/>      magic cputype cpusubtype  caps   filetype ncmds sizeofcmds      flags<br/> 0xfeedface      12          9  0x00          2    47       5316 0x00218085<br/>Snapchat (architecture armv7s):<br/>Mach header<br/>      magic cputype cpusubtype  caps   filetype ncmds sizeofcmds      flags<br/> 0xfeedface      12         11  0x00          2    47       5316 0x00218085</pre>
<p class="indent"><a id="page_85"/>The Mach-O binary format allows for what are called <em>fat</em> files, which can contain the program compiled for multiple architectures at once (this is how OS X universal binaries work). To make reverse engineering easier, you need to work with the part of the binary that will be running on your target device; in my case, I have an iPhone 5s as a test device, so I want the armv7s architecture.</p>
<p class="indent">After determining the architecture, you have a couple of options. You could <em>thin</em> the binary to include only one architecture using the <code>lipo(1)</code> command (the <code>thin</code> flag specifies which architecture you’re interested in), like this:</p>
<pre>$ lipo -thin armv7 myBinary -output myBinary-thin</pre>
<p class="indent">But for the purposes of this chapter, I’ll show you how to work with a fat binary. First, you’d use otool to determine what the base address of the <em>text</em> segment of the binary is—this is where the actual executable instructions will be loaded into memory—as in <a href="ch06.html#ch6ex2">Listing 6-2</a>.</p>
<pre>$ otool -arch armv7s -l Snapchat<br/>Snapchat:<br/>Load command 0<br/>      cmd LC_SEGMENT<br/>  cmdsize 56<br/>  segname __PAGEZERO<br/>   vmaddr 0x00000000<br/>   vmsize 0x00004000<br/>  fileoff 0<br/> filesize 0<br/>  maxprot 0x00000000<br/> initprot 0x00000000<br/>   nsects 0<br/>    flags 0x0<br/>Load command 1<br/>      cmd LC_SEGMENT<br/>  cmdsize 736<br/>  <span class="codestrong">segname __TEXT<br/>   vmaddr 0x00004000</span><br/>   vmsize 0x007a4000<br/>  fileoff 0<br/> filesize 8011776<br/>  maxprot 0x00000005<br/> initprot 0x00000005<br/>   nsects 10<br/>    flags 0x0</pre>
<p class="listcap"><a id="ch6ex2"/><em>Listing 6-2: Finding the base address of the text segment</em></p>
<p class="indent"><a id="page_86"/>You can see here that the text segment starts at 0x00004000. Record this address because you’ll need it in a bit. The next step is to determine the beginning and end of the encrypted part of the binary. You can do this with otool—note that you’ll want to specify the <code>-arch armv7s</code> command (or whatever architecture you’re using) to ensure that you’re looking at the right section. The output should look like <a href="ch06.html#ch6ex3">Listing 6-3</a>.</p>
<pre>$ otool -arch armv7s -l Snapchat<br/>--<span class="codeitalic">snip</span>--<br/>Load command 9<br/>      cmd LC_VERSION_MIN_IPHONEOS<br/>  cmdsize 16<br/>  version 5.0<br/>      sdk 7.1<br/>Load command 10<br/>        cmd LC_UNIXTHREAD<br/>    cmdsize 84<br/>     flavor ARM_THREAD_STATE<br/>      count ARM_THREAD_STATE_COUNT<br/>            r0  0x00000000 r1     0x00000000 r2  0x00000000 r3  0x00000000<br/>            r4  0x00000000 r5     0x00000000 r6  0x00000000 r7  0x00000000<br/>            r8  0x00000000 r9     0x00000000 r10 0x00000000 r11 0x00000000<br/>            r12 0x00000000 sp     0x00000000 lr  0x00000000 pc  0x0000a300<br/>           cpsr 0x00000000<br/>Load command 11<br/>          cmd <span class="codestrong">LC_ENCRYPTION_INFO</span><br/>      cmdsize 20<br/><span class="codestrong">cryptoff 16384</span><br/><span class="codestrong">cryptsize 7995392</span><br/><span class="codestrong">cryptid 1</span></pre>
<p class="listcap"><a id="ch6ex3"/><em>Listing 6-3: otool displaying a binary’s load commands</em></p>
<p class="indent">The values of interest here are <code>cryptoff</code> and <code>cryptsize</code> (<code>cryptid</code> simply indicates this is an encrypted binary).<sup><a href="footnote.html#fn41" id="fn_41">5</a></sup> These indicate the address where the encrypted segment of the application begins and the size of the segment, respectively. The range between those two numbers will help you when dumping memory. These values are in hexadecimal, though—a quick way to obtain the hex values is to execute the following in the Terminal:</p>
<pre><a id="page_87"/>$ printf '%x\n' 16384<br/>4000<br/>$ printf '%x\n' 7995392<br/>7a0000</pre>
<p class="indent">In this case, the numbers are 0x00004000 and 0x007a0000. Write these down, too. Now, back in <a href="ch06.html#ch6ex2">Listing 6-2</a>, it was determined that the text segment in the binary starts at 0x00004000. However, the text segment probably won’t end up there when the program is actually run because ASLR moves portions of memory around at random.<sup><a href="footnote.html#fn42" id="fn_42">6</a></sup> So check to see where the text segment actually got loaded using lldb’s <code>image list</code> command, as follows:</p>
<pre>(lldb) image list<br/>[  0] E3BB2396-1EF8-3EA7-BC1D-98F736A0370F <span class="codestrong">0x000b2000</span> /var/mobile/Applications/<br/>     CCAC51DD-48DB-4798-9D1B-94C5C700191F/Snapchat.app/Snapchat<br/>     (0x00000000000b2000)<br/>[  1] F49F2879-0AA0-36C0-8E55-73071A7E2870 0x2db90000 /Users/lx/Library/Developer/<br/>     Xcode/iOS DeviceSupport/7.0.4 (11B554a)/Symbols/System/Library/Frameworks/<br/>     AudioToolbox.framework/AudioToolbox<br/>[  2] 763DDFFB-38AF-3444-B745-01DDE37A5949 0x388ac000 /Users/lx/Library/Developer/<br/>     Xcode/iOS DeviceSupport/7.0.4 (11B554a)/Symbols/usr/lib/libresolv.9.dylib<br/>[  3] 18B3A243-F792-3C39-951C-97AB416ED3E6 0x37fb0000 /Users/lx/Library/Developer/<br/>     Xcode/iOS DeviceSupport/7.0.4 (11B554a)/Symbols/usr/lib/libc++.1.dylib<br/>[  4] BC1A8B9C-9F5D-3B9D-B79E-345D4C3A361A 0x2e7a2000 /Users/lx/Library/Developer/<br/>     Xcode/iOS DeviceSupport/7.0.4 (11B554a)/Symbols/System/Library/Frameworks/<br/>     CoreLocation.framework/CoreLocation<br/>[  5] CC733C2C-249E-3161-A9AF-19A44AEB1577 0x2d8c2000 /Users/lx/Library/Developer/<br/>     Xcode/iOS DeviceSupport/7.0.4 (11B554a)/Symbols/System/Library/Frameworks/<br/>     AddressBook.framework/AddressBook</pre>
<p class="indent">You can see that the text segment landed at 0x000b2000. With that address in hand, you’re finally ready to extract the executable part of the binary.</p>
<h4 class="h4" id="ch06lev2sec05"><em><strong>Dumping Application Memory</strong></em></h4>
<p class="noindent">Let’s look at a bit of math to figure out the final offsets. The first step is to add the base address to the value of <code>cryptoff</code>; in this case, both were 0x00004000, so the starting number would be 0x00008000. The ending number would be the starting number plus the value of <code>cryptsize</code>, which is at 0x007a0000 in this example. These particular numbers are pretty easy to add in your head, but if you get offsets you can’t figure out easily, you can just use Python to calculate it for you, as shown in <a href="ch06.html#ch6ex4">Listing 6-4</a>.</p>
<pre><a id="page_88"/>$ python<br/>Python 2.7.10 (default, Dec 14 2015, 19:46:27)<br/>[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin<br/>Type "help", "copyright", "credits" or "license" for more information.<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; hex(0x00008000 + 0x007a0000)<br/>'0x7a8000'</pre>
<p class="listcap"><a id="ch6ex4"/><em>Listing 6-4: Adding the starting number and the hexadecimal value of</em> <code>cryptsize</code></p>
<p class="indent">Now this example is seriously almost done, I promise. From here, you’d just plug your numbers in to the following lldb command:</p>
<pre>(lldb) memory read --force --outfile /tmp/mem.bin --binary 0x00008000 0x007a8000<br/>8011776 bytes written to '/private/tmp/mem.bin'</pre>
<p class="indent">This won’t give you a full, working binary, of course—just a memory dump. The image lacks the Mach-O header metadata. To fix this, you’d need to transplant the memory dump into a valid binary, and to that end, you’d first make a copy of the original binary and use <code>scp</code> to copy it to your development machine.</p>
<p class="indent">Then, you’d copy the contents of the unencrypted memory dump into the donor binary, replacing the encrypted segment. You can use <code>dd</code> for this, specifying the <code>seek</code> parameter where it should start writing your data. The <code>seek</code> parameter should be the value of <code>vmaddr</code> added to <code>cryptoff</code>, which is 0x8000 in this case. Here’s how this example’s <code>dd</code> command would look:</p>
<pre>$ dd bs=1 seek=0x8000 conv=notrunc if=/tmp/mem.bin of=Snapchat-decrypted</pre>
<p class="indent">Next, you’d have to change the donor binary’s <code>cryptid</code> value to 0, indicating an unencrypted binary. There are several ways to do this. You can use MachOView<sup><a href="footnote.html#fn43" id="fn_43">7</a></sup> (see <a href="ch06.html#ch6fig2">Figure 6-2</a>), which provides an easy interface for examining and changing Mach-O binaries, or you can use a hex editor of your choice. If you’re using a hex editor, I find it easiest to first find the <code>LC_ENCRYPTION_INFO</code> command by searching for <code>2100 0000 1400 0000</code>.<sup><a href="footnote.html#fn44" id="fn_44">8</a></sup> The next 16 numbers will be the offset and size, followed by <code>0100 0000</code>. That byte is the <code>cryptid</code>; change it to <code>0000 0000</code>.</p>
<p class="indent">Once you’ve disabled the <code>cryptid</code> flag, you’d need to copy the modified binary back to the device. With the modified binary in place, you can verify the change using <code>vbindiff</code>, which is available in Homebrew. Output from <code>vbindiff</code> should appear as shown in <a href="ch06.html#ch6ex5">Listing 6-5</a>.</p>
<div class="image"><a id="page_89"/><img alt="image" src="graphics/f06-02.jpg"/></div>
<p class="figcap"><a id="ch6fig2"/><em>Figure 6-2: The</em> <code>encrypted</code> <em>flag with MachOView</em></p>
<div class="image"><img alt="image" src="graphics/p0089_01.jpg"/></div>
<p class="listcap"><a id="ch6ex5"/><em>Listing 6-5: Verifying the changed</em> <code>cryptid</code> <em>value with vbindiff</em></p>
<p class="indent">The lines at <span class="ent">➊</span> and <span class="ent">➋</span> show the <code>cryptid</code> bit (in bold) enabled and disabled, respectively. Now, if all has gone well, you’d be ready to start dissecting the binary in earnest.</p>
<h3 class="h3" id="ch06lev1sec03"><strong>Reverse Engineering from Decrypted Binaries</strong></h3>
<p class="noindent">Because of the rather transparent structure of the Mach-O binary format, basic reverse engineering on iOS is a fairly trivial task—at least once you’ve managed to obtain a decrypted binary. Several tools can help you understand class definitions, examine assembly instructions, and give details on <a id="page_90"/>how the binary was built. The most useful and easily obtainable ones are otool and class-dump. You’ll also take a look at Cycript and Hopper as tools for reversing particularly stubborn applications.</p>
<h4 class="h4" id="ch06lev2sec06"><em><strong>Inspecting Binaries with otool</strong></em></h4>
<p class="noindent">otool has long been part of the base OS X toolkit for inspecting Mach-O binaries. Its current incarnation supports both ARM and amd64 architectures and can optionally use llvm to disassemble binaries. To get a basic look at a program’s internals, you can use <code>otool -oV</code> to view the data segment, as shown in <a href="ch06.html#ch6ex6">Listing 6-6</a>.</p>
<pre>$ otool -oV MobileMail<br/><br/>MobileMail:<br/>Contents of (__DATA,__objc_classlist) section<br/>000c2870 0xd7be8<br/>           isa 0xd7bd4<br/>    superclass 0x0<br/>         cache 0x0<br/>        vtable 0x0<br/>          data 0xc303c (struct class_ro_t *)<br/>                    flags 0x0<br/>            instanceStart 80<br/>             instanceSize 232<br/>               ivarLayout 0x0<br/>                     name 0xb48ac MailAppController<br/>              baseMethods 0xc3064 (struct method_list_t *)<br/>                   entsize 12<br/>                     count 122<br/>                      name 0xa048e toolbarFixedSpaceItem<br/>                     types 0xb5bb0 @8@0:4<br/>                       imp 0x40c69<br/>                      name 0xa04a4 sidebarQuasiSelectTintColor<br/>                     types 0xb5bb0 @8@0:4<br/>                       imp 0x40ccd<br/>                      name 0xa04c0 sidebarMultiselectTintColor<br/>                     types 0xb5bb0 @8@0:4<br/>                       imp 0x40d75<br/>                      name 0xa04dc sidebarTintColor<br/>                     types 0xb5bb0 @8@0:4<br/>                       imp 0x130f5<br/>                      name 0xa04ed updateStyleOfToolbarActivityIndicatorView:<br/>    inView:<br/>                     types 0xb5c34 v16@0:4@8@12<br/>                       imp 0x18d69</pre>
<p class="listcap"><a id="ch6ex6"/><em>Listing 6-6: otool displaying the contents of the</em> <code>__OBJC</code> <em>segment</em></p>
<p class="indent"><a id="page_91"/>This gives you a view of class and method names, as well as information about ivars, provided these are implemented in Objective-C rather than straight C++. To view the text segment of a program, you can use <code>otool -tVq</code>. The <code>-q</code> indicates that you want to use llvm as the disassembler rather than otool’s built-in disassembler, which is noted by <code>-Q</code>. The differences in output are few, but llvm seems best suited for the task, given that it likely assembled the binary in the first place. It also provides slightly more readable output. <a href="ch06.html#ch6ex7">Listing 6-7</a> shows some example output of <code>otool -tVq</code>.</p>
<pre>MobileMail:<br/>(__TEXT,__text) section<br/>00003584            0000       movs    r0, r0<br/>00003586            e59d       b       0x30c4<br/>00003588            1004       asrs    r4, r0, #32<br/><br/>--<span class="codeitalic">snip</span>--<br/><br/>000035ca            447a       add     r2, pc<br/>000035cc            6801       ldr     r1, [r0]<br/>000035ce            6810       ldr     r0, [r2]<br/>000035d0        f0beecf0       blx     0xc1fb4 @ symbol stub for: _objc_msgSend<br/>000035d4        f2417128       movw    r1, #5928<br/>000035d8        f2c0010d       movt    r1, #13<br/>000035dc            4479       add     r1, pc<br/>000035de            6809       ldr     r1, [r1]<br/>000035e0        f0beece8       blx     0xc1fb4 @ symbol stub for: _objc_msgSend<br/>000035e4            4606       mov     r6, r0</pre>
<p class="listcap"><a id="ch6ex7"/><em>Listing 6-7: otool’s disassembly output</em></p>
<p class="indent">Here, you see the actual disassembly of methods, as well as some basic symbol information. To get a dump of all the symbols, use <code>otool -IV</code>, as shown in <a href="ch06.html#ch6ex8">Listing 6-8</a>.</p>
<pre>$ otool -IV MobileMail<br/><br/>MobileMail:<br/>Indirect symbols for (__TEXT,__symbolstub1) 241 entries<br/>address    index name<br/>0x000c1c30     3 _ABAddressBookFindPersonMatchingEmailAddress<br/>0x000c1c34     4 _ABAddressBookRevert<br/>0x000c1c38     5 _ABPersonCopyImageDataAndCropRect<br/>0x000c1c3c     7 _CFAbsoluteTimeGetCurrent<br/>0x000c1c40     8 _CFAbsoluteTimeGetGregorianDate<br/>0x000c1c44     9 _CFArrayAppendValue<br/>0x000c1c48    10 _CFArrayCreateMutable<br/>0x000c1c4c    11 _CFArrayGetCount<br/>0x000c1c50    12 _CFArrayGetFirstIndexOfValue<br/>0x000c1c54    13 _CFArrayGetValueAtIndex<br/>0x000c1c58    14 _CFArrayRemoveValueAtIndex<br/>0x000c1c5c    15 _CFArraySortValues<br/>0x000c1c60    16 _CFDateFormatterCopyProperty<br/>0x000c1c64    17 _CFDateFormatterCreate</pre>
<p class="listcap"><a id="ch6ex8"/><em>Listing 6-8: Inspecting symbols with otool</em></p>
<h4 class="h4" id="ch06lev2sec07"><a id="page_92"/><em><strong>Obtaining Class Information with class-dump</strong></em></h4>
<p class="noindent">The class-dump<sup><a href="footnote.html#fn45" id="fn_45">9</a></sup> tool is used to extract class information from Objective-C 2.0 binaries. The resulting output is essentially the equivalent of the header files of a given binary. This can give excellent insight into the design and structure of a program, making class-dump an invaluable tool for reverse engineering. The original class-dump by Steve Nygard runs only on OS X but recognizes the armv7 architecture, so you can copy files over to your desktop for analysis. There is also a modified version, class-dump-z,<sup><a href="footnote.html#fn46" id="fn_46">10</a></sup> that can run on Linux and iOS. As of this writing, class-dump appears to be more up-to-date and functional, so I recommend sticking with it.</p>
<p class="indent">You can test class-dump against any unencrypted iOS binary. The quickest way to get a feel for it is to copy over one of the built-in Apple apps in <em>/Applications</em> and run class-dump on the binary, as shown in <a href="ch06.html#ch6ex9">Listing 6-9</a>.</p>
<pre>$ class-dump MobileMail<br/><br/>--<span class="codeitalic">snip</span>--<br/><span class="rose">@interface</span> MessageHeaderHeader : _AAAccountConfigChangedNotification &lt;<br/>     MessageHeaderAddressBookClient, <span class="violet1">UIActionSheetDelegate&gt;</span><br/><span class="violet1">{</span><br/>    <span class="violet1">MailMessage *</span>_lastMessage;<br/>    <span class="rose">id</span> &lt;MessageHeaderDelegate&gt; _delegate;<br/>    <span class="violet1">UIWebBrowserView *</span>_subjectWebView;<br/>    DOMHTMLElement *_subjectTextElement;<br/>    <span class="violet1">UILabel *</span>_dateLabel;<br/>    <span class="rose">unsigned int</span> _markedAsUnread:1;<br/>    <span class="rose">unsigned int</span> _markedAsFlagged:1;<br/>    <span class="rose">unsigned int</span> _isOutgoing:1;<br/>    <span class="violet1">UIImageView *</span>_unreadIndicator;<br/>    <span class="violet1">UIImageView *</span>_flaggedIndicator;<br/>    WorkingPushButton *_markButton;<br/>    <span class="rose">id</span> _markUnreadTarget;<br/>    SEL _markUnreadAction;<br/>    ABPersonIconImageView *_personIconImageView;<br/>    SeparatorLayer *_bottomSeparator;<br/>    SeparatorLayer *_topSeparator;<br/>    <span class="rose">float</span> _horizontalInset;<br/>    <span class="rose">unsigned int</span> _allowUnreadStateToBeShown:1;<br/>}<br/><br/>- (<span class="rose">id</span>)<span class="violet">initWithFrame</span>:(<span class="rose">struct</span> CGRect)fp8;<br/>- (<span class="rose">void</span>)dealloc;</pre>
<p class="listcap"><a id="ch6ex9"/><em>Listing 6-9: class-dump Showing the Interface Details of MobileMail</em></p>
<p class="indent"><a id="page_93"/>Delightful, no? Once you have a decrypted binary, most Objective-C applications become transparent pretty quickly.</p>
<h4 class="h4" id="ch06lev2sec08"><em><strong>Extracting Data from Running Programs with Cycript</strong></em></h4>
<p class="noindent">If you don’t want to go through the hassle of decrypting a binary to get information about its internals, you can use Cycript<sup><a href="footnote.html#fn47" id="fn_47">11</a></sup> to extract some of this information from a running executable. There are many tricks to interact with running applications using Cycript, but you’ll probably be most interested in using <em>weak_classdump.cy</em><sup><a href="footnote.html#fn48" id="fn_48">12</a></sup> to approximate the functionality of class-dump. With the Contacts application running, you can extract class-dump information thusly:</p>
<pre>$ curl -OL https://raw.github.com/limneos/weak_classdump/master/<br/>     weak_classdump.cy<br/>$ cycript -p Contacts weak_classdump.cy<br/>'Added weak_classdump to "Contacts" (3229)'<br/>$ cycript -p Contacts<br/>cy# weak_classdump_bundle([NSBundle mainBundle],"/tmp/contactsbundle")<br/>"Dumping bundle... Check syslog. Will play lock sound when done."</pre>
<p class="indent">This will write out header files for each class into the <em>/tmp/contactsbundle</em> directory.</p>
<p class="indent">Note that in order to securely fetch things with cURL, you’ll need to install a CA certificate bundle on the device. If you use MacPorts and have cURL installed locally, do this:</p>
<pre>$ scp /opt/local/share/curl/curl-ca-bundle.crt \<br/>    root@de.vi.c.e:/etc/ssl/certificates/ca-certificates.crt</pre>
<p class="indent"><a id="page_94"/>Or if you use Homebrew and have the OpenSSL formula installed, you can use this command:</p>
<pre>$ scp /usr/local/etc/openssl/cert.pem \<br/>    root@de.vi.c.e:/etc/ssl/certificates/ca-certificates.crt}</pre>
<h4 class="h4" id="ch06lev2sec09"><em><strong>Disassembly with Hopper</strong></em></h4>
<p class="noindent">There will likely be some situations where you need to get a closer view of a program’s actual logic, in the absence of source code. While IDA Pro<sup><a href="footnote.html#fn49" id="fn_49">13</a></sup> is useful for this, it’s rather expensive. I usually use Hopper<sup><a href="footnote.html#fn50" id="fn_50">14</a></sup> for disassembling, decompiling, and making flow graphs during black-box testing. While assembly language and decompiling are somewhat outside the scope of this book, let’s take a quick look at what Hopper can show you about a program’s logic. Looking at a basic password manager in Hopper (<a href="ch06.html#ch6fig3">Figure 6-3</a>), you will find a method called <code>storeSavedKeyFor:</code>, which looks promising.</p>
<div class="image"><img alt="image" src="graphics/f06-03.jpg"/></div>
<p class="figcap"><a id="ch6fig3"/><em>Figure 6-3: The disassembly of the</em> <code>storeSavedKeyFor:</code> <em>function</em></p>
<p class="indent"><a id="page_95"/>If you call the decompiler (the <code>if(b)</code> button) on this particular section of code, Hopper will generate pseudocode to give you an idea of actual program flow, as shown in <a href="ch06.html#ch6fig4">Figure 6-4</a>.</p>
<div class="image"><img alt="image" src="graphics/f06-04.jpg"/></div>
<p class="figcap"><a id="ch6fig4"/><em>Figure 6-4: Code generated by the decompiler</em></p>
<p class="indent">Notice that the <code>PearlLogger</code> class is being instantiated, and there’s a reference to the username for which the current item is being stored. <code>var_64</code> shows that this username is getting passed to the logging function, probably to the NSLog facility—this is bad, for reasons I’ll explain further in <a href="ch10.html#ch10">Chapter 10</a>. However, you can also see that the item is being stored in <a id="page_96"/>the Keychain with a restrictive protection attribute (<code>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</code>, further detailed in <a href="ch13.html#ch13">Chapter 13</a>), which is a point in the program’s favor.</p>
<p class="indent">Assembly language and decompilation are broad areas, but Hopper gives you a great way to get started with reverse engineering via assembly for a fairly low price. If you’d like to get started developing your skills reading ARM assembly, check out Ray Wenderlich’s tutorial: <em><a href="http://www.raywenderlich.com/37181/ios-assembly-tutorial/">http://www.raywenderlich.com/37181/ios-assembly-tutorial/</a></em>.</p>
<h3 class="h3" id="ch06lev1sec04"><strong>Defeating Certificate Pinning</strong></h3>
<p class="noindent">Certificate pinning aims to prevent a rogue CA from signing a fake (but valid-looking) certificate for your site, with the purpose of intercepting communications between your network endpoint and the application. This is quite a good idea (and I’ll discuss how to implement it in <a href="ch07.html#ch07">Chapter 7</a>), but it does of course make black-box testing slightly more difficult.</p>
<p class="indent">My colleagues and I ran into this problem frequently enough that we wrote a tool to help us with it: the iOS SSL Killswitch.<sup><a href="footnote.html#fn51" id="fn_51">15</a></sup> The Killswitch tool hooks requests going through the URL loading system to prevent the validation of any SSL certificates, ensuring that you can run any black-box application through your proxy regardless of whether it uses certificate pinning.</p>
<p class="indent">To install the Killswitch tool, copy the precompiled <em>.deb</em> file to your device and install it with the dpkg tool.</p>
<pre># scp ios-ssl-kill-switch.deb root@192.168.1.107<br/># ssh root@192.168.1.107<br/>(and then, on the test device)<br/># dpkg -i ios-ssl-kill-switch.deb<br/># killall -HUP SpringBoard</pre>
<p class="indent">You should then find iOS SSL Killswitch in your Settings application (see <a href="ch06.html#ch6fig5">Figure 6-5</a>), where you can toggle it on and off.</p>
<div class="image"><img alt="image" src="graphics/f06-05.jpg"/></div>
<p class="figcap"><a id="ch6fig5"/><em>Figure 6-5: Enabling the SSL Killswitch tool from within the Settings application</em></p>
<h3 class="h3" id="ch06lev1sec05"><a id="page_97"/><strong>Hooking with Cydia Substrate</strong></h3>
<p class="noindent">On jailbroken devices (which you’ll be performing your black-box testing on), you can use Cydia Substrate<sup><a href="footnote.html#fn52" id="fn_52">16</a></sup> (formerly known as Mobile Substrate) to modify the behavior of the base system to give you additional information on your application’s activity or change application behavior. Your goals may be to disable certain security or validation mechanisms (like the iOS SSL Killswitch does) or to simply notify you when certain APIs are used, along with the arguments passed to them. Cydia Substrate hooks are referred to as <em>tweaks</em>.</p>
<p class="indent">The most user-friendly way to get started with developing Cydia Substrate tweaks is to use the Theos toolkit.<sup><a href="footnote.html#fn53" id="fn_53">17</a></sup> To create a new tweak, use the <em>nic.pl</em> script included with Theos. Note that Theos is by default oriented toward tweaking the behavior of the SpringBoard application in order to customize user interface elements. For the purposes described in this book, though, you’ll want to affect all applications, so you’d specify a Bundle filter of <code>com.apple.UIKit</code>. This filter will configure Mobile/Cydia Substrate to load your tweak in any application that links to the UIKit framework (that is, applications displaying a user interface) but not other programs like system daemons or command line tools.</p>
<p class="indent">First, you need to acquire the Link Identity Editor, ldid,<sup><a href="footnote.html#fn54" id="fn_54">18</a></sup> which Theos uses to generate the signature and entitlements for a tweak. Here’s how to get ldid:</p>
<pre>$ git clone git://git.saurik.com/ldid.git<br/><br/>$ cd ldid<br/><br/>$ git submodule update --init<br/><br/>$ ./make.sh<br/><br/>$ sudo cp ./ldid /usr/local/bin</pre>
<p class="indent">You can then clone the Theos repo and proceed to generate a tweak template, as follows:</p>
<pre>$ git clone git://github.com/DHowett/theos.git ~/git/theos<br/><br/>$ cd /tmp &amp;&amp; ~/git/theos/bin/nic.pl<br/>NIC 2.0 - New Instance Creator<br/>------------------------------<br/>  [1.] iphone/application<br/>  [2.] iphone/library<br/>  [3.] iphone/preference_bundle<br/>  [4.] iphone/tool<br/>  [5.] iphone/tweak<br/>Choose a Template (required): 5<br/>Project Name (required): MyTweak<br/>Package Name [com.yourcompany.mytweak]:<br/>Author/Maintainer Name [dthiel]:<br/>[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.<br/>     UIKit<br/>Instantiating iphone/tweak in mytweak/...<br/>Done.</pre>
<p class="indent"><a id="page_98"/>This will create a <em>Tweak.xm</em> file, with all of its contents commented out by default. Stubs are included for hooking either class methods or instance methods, with or without arguments.</p>
<p class="indent">The simplest type of hook you can write is one that just logs method calls and arguments; here’s an example that hooks two class methods of <code>UIPasteboard</code>:</p>
<pre>%hook <span class="violet1">UIPasteboard</span><br/><br/><span class="violet1">+ (UIPasteboard *)pasteboardWithName:(NSString *</span>)pasteboardName create:(<span class="rose">BOOL</span>)create<br/>{<br/>        %log;<br/>        <span class="rose">return</span> %orig;<br/>}<br/><br/>+ (<span class="violet1">UIPasteboard *</span>)<span class="violet">generalPasteboard</span><br/>{<br/>        %log;<br/>        <span class="rose">return</span> %orig;<br/>}<br/><br/>%end</pre>
<p class="indent">This code snippet uses Logos<sup><a href="footnote.html#fn55" id="fn_55">19</a></sup> directives such as <code>%hook</code> and <code>%log</code>. Logos is a component of Theos designed to allow method-hooking code to be written easily. However, it is possible to write a tweak with the same functionality using only C instead.</p>
<p class="indent">You’ll want to provide the full method signature as well, which you can obtain either from API documentation or from framework header files. Once you’ve customized your tweak to your satisfaction, you can build it using the Makefile provided by <em>nic.pl</em>.</p>
<p class="indent"><a id="page_99"/>To build a Debian package suitable for installation onto a jailbroken device, you’ll also need to install the dpkg tool. You can do this either with the MacPorts<sup><a href="footnote.html#fn56" id="fn_56">20</a></sup> <code>port</code> command or with Homebrew’s<sup><a href="footnote.html#fn57" id="fn_57">21</a></sup> <code>brew</code> command. This example uses <code>port</code>:</p>
<pre>$ sudo port install dpkg<br/>    --<span class="codeitalic">snip</span>--<br/>$ make<br/>Bootstrapping CydiaSubstrate...<br/> Compiling iPhoneOS CydiaSubstrate stub... default target?<br/> Compiling native CydiaSubstrate stub...<br/> Generating substrate.h header...<br/>Making all for tweak MyTweak...<br/> Preprocessing Tweak.xm...<br/> Compiling Tweak.xm...<br/> Linking tweak MyTweak...<br/> Stripping MyTweak...<br/> Signing MyTweak...<br/>$ make package<br/>Making all for tweak MyTweak...<br/>make[2]: Nothing to be done for `internal-library-compile'.<br/>Making stage for tweak MyTweak...<br/>dpkg-deb: building package `com.yourcompany.mytweak' in `./com.yourcompany.<br/>     mytweak_0.0.1-1_iphoneos-arm.deb'.</pre>
<p class="indent">Running these commands should result in a package that can be installed on your iOS device. First, you’d use the <code>scp</code> command to copy the file over to the device and load it manually. After that, you could simply use <code>dpkg -i</code> from the command line (as shown in the following code) or set up your own Cydia repository.<sup><a href="footnote.html#fn58" id="fn_58">22</a></sup></p>
<pre>$ dpkg -i com.yourcompany.mytweak_0.0.1-1_iphoneos-arm.deb<br/>Selecting previously deselected package com.yourcompany.mytweak.<br/>(Reading database ... 3551 files and directories currently installed.)<br/>Unpacking com.yourcompany.mytweak (from com.yourcompany.mytweak_0.0.1-1_iphoneos-<br/>     arm.deb) ...<br/>Setting up com.yourcompany.mytweak (0.0.1-1) ..</pre>
<p class="indent">When this finishes, you can either manage the package further with the <code>dpkg</code> command (removing it with <code>dpkg -P</code>) or manage it via Cydia, as shown in <a href="ch06.html#ch6fig6">Figure 6-6</a>.</p>
<div class="image"><a id="page_100"/><img alt="image" src="graphics/f06-06.jpg"/></div>
<p class="figcap"><a id="ch6fig6"/><em>Figure 6-6: Your very own tweak in the Cydia management interface</em></p>
<p class="indent">After a tweak is installed, if you examine the system log, you’ll see the Cydia Substrate dynamic library being loaded upon launch of all applications. You’ll also see the hooked method calls being logged by the tweak. Here’s an example log:</p>
<pre>May  2 14:22:08 my-iPad Maps~ipad[249]: MS:Notice: Loading: /Library/<br/>     MobileSubstrate/DynamicLibraries/MyTweak.dylib<br/>May  2 14:22:38 lxs-iPad Maps~ipad[249]: +[&lt;UIPasteboard: 0x3ef05408&gt;<br/>     generalPasteboard]</pre>
<p class="indent">There are, of course, many other things you can do with tweaks besides logging; see the <em>Tweak.xm</em> file of the iOS SSL Killswitch tool for an example of modifying method behavior, along with your own preference toggle.<sup><a href="footnote.html#fn59" id="fn_59">23</a></sup></p>
<h3 class="h3" id="ch06lev1sec06"><strong>Automating Hooking with Introspy</strong></h3>
<p class="noindent">While tweaks are useful for one-off hooking scenarios, my colleagues Alban Diquet and Tom Daniels have used the Cydia Substrate framework to make a tool called Intropsy<sup><a href="footnote.html#fn60" id="fn_60">24</a></sup> that can help automate the hooking process for <a id="page_101"/>black-box testing without having to dig too deep in to the guts of iOS or Cydia Substratey. Introspy uses the Cydia Substrate framework directly (rather than via Theos) to hook security-sensitive method calls, logging their arguments and return values in a format that can subsequently be used to generate reports. To install Introspy, download the latest precompiled <em>.deb</em> package from <em><a href="https://github.com/iSECPartners/Introspy-iOS/releases/">https://github.com/iSECPartners/Introspy-iOS/releases/</a></em>, copy it to your device, and enter the command <code>dpkg -i <em>filename</em></code> on the device to add the package.</p>
<p class="indent">Once installed, respring the device using the following:</p>
<pre>$ killall -HUP SpringBoard</pre>
<p class="indent">Do the same for any application that you want to test, if it’s already running. You can now tell Introspy what applications you want to hook, along with which API calls you’d like to record (see <a href="ch06.html#ch6fig7">Figure 6-7</a>). Once your testing is complete, a SQLite database file will be deposited in <em>/var/mobile</em> if you’re testing Apple built-in or Cydia applications, or in <em>/User/Applications/&lt;AppID&gt;</em> if you’re testing an application that came from the App Store.</p>
<div class="image"><img alt="image" src="graphics/f06-07.jpg"/></div>
<p class="figcap"><a id="ch6fig7"/><em>Figure 6-7: The Introspy settings screen. You can select which applications are profiled on the Apps tab.</em></p>
<p class="indent"><a id="page_102"/>To analyze this database, you’ll want to use the Introspy Analyzer,<sup><a href="footnote.html#fn61" id="fn_61">25</a></sup> which will generate HTML reports of Introspy’s findings (see <a href="ch06.html#ch6fig8">Figure 6-8</a>).</p>
<div class="image"><img alt="image" src="graphics/f06-08.jpg"/></div>
<p class="figcap"><a id="ch6fig8"/><em>Figure 6-8: The Introspy HTML report output, showing a list of findings that match the specified signatures</em></p>
<p class="indent">If you copy this database onto your test machine, you can create a report on the called APIs using <em>introspy.py</em>, as follows:</p>
<pre>$ python ./introspy.py --outdir report mydatabase.db</pre>
<p class="indent">Newer versions of Introspy also allow automatic copying and parsing of the database, by specifying the IP address of the device.</p>
<pre>$ python ./introspy.py -p ios -o outputdir -f device.ip.address</pre>
<p class="indent"><a id="page_103"/>Running Introspy will evaluate the calls against a signature database of potentially problematic APIs, helping you track down potential areas of interest. To cut down on noise, you can filter out specific API categories or signature types with the <code>--group</code> and <code>--sub-group</code> flags. With Introspy installed, enter <code>introspy.py --help</code> at the command line for details.</p>
<h3 class="h3" id="ch06lev1sec07"><strong>Closing Thoughts</strong></h3>
<p class="noindent">While black-box testing poses some challenges, the development community has gone a long way to making it feasible, and some elements of black-box testing will help you regardless of whether you have source code. You will now turn your primary attention back to white-box testing; in <a href="ch07.html#ch07">Chapter 7</a>, I’ll guide you through some of the most security-sensitive APIs in iOS, including IPC mechanisms, cryptographic facilities, and the myriad ways in which data can leak from applications unintentionally.<a id="page_104"/></p>
</body></html>