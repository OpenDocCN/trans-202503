<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="3" id="Page_3"/>1</span><br/>
<span class="ChapterTitle">Hello, World of Assembly Language</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter is a “quick-start” chapter that lets you begin writing basic assembly language programs as rapidly as possible. By the conclusion of this chapter, you should understand the basic syntax of a Microsoft Macro Assembler (MASM) program and the prerequisites for learning new assembly language features in the chapters that follow.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	This book uses the MASM running under Windows because that is, by far, the most commonly used assembler for writing x86-64 assembly language programs. Furthermore, the Intel documentation typically uses assembly language examples that are syntax-compatible with MASM. If you encounter x86 source code in the real world, it will likely be written using MASM. That being said, many other popular x86-64 assemblers are out there, including the GNU Assembler (gas), Netwide Assembler (NASM), Flat Assembler (FASM), and others. These assemblers employ a different syntax from MASM (gas being the one most radically different). At some point, if you work in assembly language much, you’ll probably encounter source code written with one of these other assemblers. Don’t fret; learning the syntactical differences isn’t that hard once you’ve mastered x86-64 assembly language using MASM. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="4" id="Page_4"/>This chapter covers the following:</p>
<ul>
<li>Basic syntax of a MASM program</li>
<li>The Intel central processing unit (CPU) architecture</li>
<li>Setting aside memory for variables</li>
<li>Using machine instructions to control the CPU</li>
<li>Linking a MASM program with C/C++ code so you can call routines in the C Standard Library</li>
<li>Writing some simple assembly language programs</li>
</ul>
<h2 id="h1-501089c01-0001">	1.1	What You’ll Need</h2>
<p class="BodyFirst">You’ll need a few prerequisites to learn assembly language programming with MASM: a 64-bit version of MASM, plus a text editor (for creating and modifying MASM source files), a linker, various library files, and a C++ compiler.</p>
<p>Today’s software engineers drop down into assembly language only when their C++, C#, Java, Swift, or Python code is running too slow and they need to improve the performance of certain modules (or functions) in their code. Because you’ll typically be interfacing assembly language with C++, or other high-level language (HLL) code, when using assembly in the real world, we’ll do so in this book as well.</p>
<p>Another reason to use C++ is for the C Standard Library. While different individuals have created several useful libraries for MASM (see <a href="http://www.masm32.com/" class="LinkURL">http://www.masm32.com/</a> for a good example), there is no universally accepted standard set of libraries. To make the C Standard Library immediately accessible to MASM programs, this book presents examples with a short C/C++ main function that calls a single external function written in assembly language using MASM. Compiling the C++ main program along with the MASM source file will produce a single executable file that you can run and test.</p>
<p>Do you need to know C++ to learn assembly language? Not really. This book will spoon-feed you the C++ you’ll need to run the example programs. Nevertheless, assembly language isn’t the best choice for your first language, so this book assumes that you have some experience in a language such as C/C++, Pascal (or Delphi), Java, Swift, Rust, BASIC, Python, or any other imperative or object-oriented programming language.</p>
<h2 id="h1-501089c01-0002">	1.2	Setting Up MASM on Your Machine</h2>
<p class="BodyFirst">MASM is a Microsoft product that is part of the Visual Studio suite of developer tools. Because it’s Microsoft’s tool set, you need to be running some variant of Windows (as I write this, Windows 10 is the latest version; however, any later version of Windows will likely work as well). <span class="xref" itemid="xref_target_Appendix C">Appendix C</span> provides a complete description of how to install Visual Studio Community (the “no-cost” version, which includes MASM and the Visual C++ compiler, plus other tools you will need). Please refer to that appendix for more details.</p>
<h2 id="h1-501089c01-0003"><span epub:type="pagebreak" title="5" id="Page_5"/>	1.3	Setting Up a Text Editor on Your Machine</h2>
<p class="BodyFirst">Visual Studio includes a text editor that you can use to create and edit MASM and C++ programs. Because you have to install the Visual Studio package to obtain MASM, you automatically get a production-quality programmer’s text editor you can use for your assembly language source files. </p>
<p>However, you can use any editor that works with straight ASCII files (UTF-8 is also fine) to create MASM and C++ source files, such as Notepad++ or the text editor available from <a href="https://www.masm32.com/" class="LinkURL">https://www.masm32.com/</a>. Word processing programs, such as Microsoft Word, are not appropriate for editing program source files.</p>
<h2 id="h1-501089c01-0004">	1.4	The Anatomy of a MASM Program </h2>
<p class="BodyFirst">A typical (stand-alone) MASM program looks like <a href="#listing1-1" id="listinganchor1-1">Listing 1-1</a>.</p>
<pre><code>; Comments consist of all text from a semicolon character
; to the end of the line.

; The ".code" directive tells MASM that the statements following
; this directive go in the section of memory reserved for machine
; instructions (code).

        .code

; Here is the "main" function. (This example assumes that the
; assembly language program is a stand-alone program with its
; own main function.)

main    PROC

<var>Machine instructions go here</var>
        
        ret    ; Returns to caller
        
main    ENDP

; The END directive marks the end of the source file.

        END</code></pre>
<p class="CodeListingCaption"><a id="listing1-1">Listing 1-1</a>: Trivial shell program</p>
<p>A typical MASM program contains one or more <em>sections</em> representing the type of data appearing in memory. These sections begin with a MASM statement such as <code>.code</code> or <code>.data</code>. Variables and other memory values appear in a <em>data</em> section. Machine instructions appear in procedures that appear within a <em>code</em> section. And so on. The individual sections appearing in an assembly language source file are optional, so not every type of section will appear in a particular source file. For example, <a href="#listing1-1">Listing 1-1</a> contains only a single code section.</p>
<p><span epub:type="pagebreak" title="6" id="Page_6"/>The <code>.code</code> statement is an example of an assembler <em>directive</em>—a statement that tells MASM something about the program but is not an actual x86-64 machine instruction. In particular, the <code>.code</code> directive tells MASM to group the statements following it into a special section of memory reserved for machine instructions.</p>
<h2 id="h1-501089c01-0005">	1.5	Running Your First MASM Program</h2>
<p class="BodyFirst">A traditional first program people write, popularized by Brian Kernighan and Dennis Ritchie’s <em>The C Programming Language</em> (Prentice Hall, 1978) is the “Hello, world!” program. The whole purpose of this program is to provide a simple example that someone learning a new programming language can use to figure out how to use the tools needed to compile and run programs in that language. </p>
<p>Unfortunately, writing something as simple as a “Hello, world!” program is a major production in assembly language. You have to learn several machine instruction and assembler directives, not to mention Windows system calls, to print the string “Hello, world!” At this point in the game, that’s too much to ask from a beginning assembly language programmer (for those who want to blast on ahead, take a look at the sample program in <span class="xref" itemid="xref_target_Appendix C">Appendix C</span>). </p>
<p>However, the program shell in <a href="#listing1-1">Listing 1-1</a> is actually a complete assembly language program. You can compile (<em>assemble</em>) and run it. It doesn’t produce any output. It simply returns back to Windows immediately after you start it. However, it does run, and it will serve as the mechanism for showing you how to assemble, link, and run an assembly language source file.</p>
<p>MASM is a traditional <em>command line assembler</em>, which means you need to run it from a Windows <em>command line prompt</em> (available by running the <em>cmd.exe</em> program). To do so, enter something like the following into the command line prompt or shell window:</p>
<pre><code>C:\&gt;<b>ml64 programShell.asm /link /subsystem:console /entry:main</b></code></pre>
<p>This command tells MASM to assemble the <em>programShell.asm</em> program (where I’ve saved <a href="#listing1-1">Listing 1-1</a>) to an executable file, link the result to produce a console application (one that you can run from the command line), and begin execution at the label <code>main</code> in the assembly language source file. Assuming that no errors occur, you can run the resulting program by typing the following command into your command prompt window: </p>
<pre><code>C:\&gt;<b>programShell</b></code></pre>
<p>Windows should immediately respond with a new command line prompt (as the <code>programShell</code> application simply returns control back to Windows after it starts running).</p>
<h2 id="h1-501089c01-0006"><span epub:type="pagebreak" title="7" id="Page_7"/>	1.6	Running Your First MASM/C++ Hybrid Program</h2>
<p class="BodyFirst">This book commonly combines an assembly language module (containing one or more functions written in assembly language) with a C/C++ main program that calls those functions. Because the compilation and execution process is slightly different from a stand-alone MASM program, this section demonstrates how to create, compile, and run a hybrid assembly/C++ program. <a href="#listing1-2" id="listinganchor1-2">Listing 1-2</a> provides the main C++ program that calls the assembly language module.</p>
<pre><code>// Listing 1-2
 
// A simple C++ program that calls an assembly language function.
// Need to include stdio.h so this program can call "printf()".

#include &lt;stdio.h&gt;

// extern "C" namespace prevents "name mangling" by the C++
// compiler.

extern "C"
{
    // Here's the external function, written in assembly
    // language, that this program will call:
    
    void asmFunc(void);
};

int main(void)
{
    printf("Calling asmMain:\n");
    asmFunc();
    printf("Returned from asmMain\n");
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-2">Listing 1-2</a>: A sample C/C++ program, <em>listing1-2.cpp</em>, that calls an assembly language function</p>
<p><a href="#listing1-3" id="listinganchor1-3">Listing 1-3</a> is a slight modification of the stand-alone MASM program that contains the <code>asmFunc()</code> function that the C++ program calls.</p>
<pre><code>; Listing 1-3

; A simple MASM module that contains an empty function to be 
; called by the C++ code in Listing 1-2.

        .CODE
        
; (See text concerning option directive.)

        option  casemap:none

; Here is the "asmFunc" function.

        public  asmFunc
asmFunc PROC

<span epub:type="pagebreak" title="8" id="Page_8"/>; Empty function just returns to C++ code.

        ret    ; Returns to caller

asmFunc ENDP
        END</code></pre>
<p class="CodeListingCaption"><a id="listing1-3">Listing 1-3</a>: A MASM program, <em>listing1-3.asm</em>, that the C++ program in <a href="#listing1-2">Listing 1-2</a> calls</p>
<p><a href="#listing1-3">Listing 1-3</a> has three changes from the original <em>programShell.asm</em> source file. First, there are two new statements: the <code>option</code> statement and the <code>public</code> statement. </p>
<p>The <code>option</code> statement tells MASM to make all symbols case-sensitive. This is necessary because MASM, by default, is case-insensitive and maps all identifiers to uppercase (so <code>asmFunc()</code> would become <code>ASMFUNC()</code>). C++ is a case-sensitive language and treats <code>asmFunc()</code> and <code>ASMFUNC()</code> as two different identifiers. Therefore, it’s important to tell MASM to respect the case of the identifiers so as not to confuse the C++ program.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	<em/>MASM identifiers may begin with a dollar sign (<code>$</code>), underscore (<code>_</code>), or an alphabetic character and may be followed by zero or more alphanumeric, dollar sign, or underscore characters. An identifier may not consist of a <code>$</code> character by itself (this has a special meaning to MASM).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The <code>public</code> statement declares that the <code>asmFunc()</code> identifier will be visible outside the MASM source/object file. Without this statement, <code>asmFunc()</code> would be accessible only within the MASM module, and the C++ compilation would complain that <code>asmFunc()</code> is an undefined identifier.</p>
<p>The third difference between <a href="#listing1-3">Listing 1-3</a> and <a href="#listing1-1">Listing 1-1</a> is that the function’s name was changed from <code>main()</code> to <code>asmFunc()</code>. The C++ compiler and linker would get confused if the assembly code used the name <code>main()</code>, as that’s also the name of the C++ <code>main()</code> function.</p>
<p>To compile and run these source files, you use the following commands:</p>
<pre><code>C:\&gt;<b>ml64 /c listing1-3.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing1-3.asm

C:\&gt;<b>cl listing1-2.cpp listing1-3.obj</b>
Microsoft (R) C/C++ Optimizing Compiler Version 19.15.26730 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

listing1-2.cpp
Microsoft (R) Incremental Linker Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:listing1-2.exe
listing1-2.obj
listing1-3.obj

<span epub:type="pagebreak" title="9" id="Page_9"/>C:\&gt;<b>listing1-2</b>
Calling asmFunc:
Returned from asmFunc</code></pre>
<p>The <code>ml64</code> command uses the <code/><code>/c</code> option, which stands for <em>compile-only</em>, and does not attempt to run the linker (which would fail because <em>listing1-3.asm</em> is not a stand-alone program). The output from MASM is an object code file (<em>listing1-3.obj</em>), which serves as input to the Microsoft Visual C++ (MSVC) compiler in the next command.</p>
<p>The <code>cl</code> command runs the MSVC compiler on the <em>listing1-2.cpp</em> file and links in the assembled code (<em>listing1-3.obj</em>). The output from the MSVC compiler is the <em>listing1-2.exe</em> executable file. Executing that program from the command line produces the output we expect.</p>
<h2 id="h1-501089c01-0007">	1.7	An Introduction to the Intel x86-64 CPU Family</h2>
<p class="BodyFirst">Thus far, you’ve seen a single MASM program that will actually compile and run. However, the program does nothing more than return control to Windows. Before you can progress any further and learn some real assembly language, a detour is necessary: unless you understand the basic structure of the Intel x86-64 CPU family, the machine instructions will make little sense. </p>
<p>The Intel CPU family is generally classified as a <em>von Neumann architecture machine</em>. Von Neumann computer systems contain three main building blocks: the <em>central processing unit</em> <em>(CPU)</em>, <em>memory</em>, and <em>input/output (I/0) devices</em>. These three components are interconnected via the <em>system bus</em> (consisting of the address, data, and control buses).<em> </em>The block diagram in <a href="#figure1-1" id="figureanchor1-1">Figure 1-1</a> shows these relationships.</p>
<p>The CPU communicates with memory and I/O devices by placing a numeric value on the address bus to select one of the memory locations or I/O device port locations, each of which has a unique numeric <em>address</em>. Then the CPU, memory, and I/O devices pass data among themselves by placing the data on the data bus. The control bus contains signals that determine the direction of the data transfer (to/from memory and to/from an I/O device).</p>
<figure>
<img src="image_fi/501089c01/f01001.png" alt="f01001" class=""/>
<figcaption><p><a id="figure1-1">Figure 1-1</a>: Von Neumann computer system block diagram</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="10" id="Page_10"/>Within the CPU, special locations known as <em>registers</em> are used to manipulate data. The x86-64 CPU registers can be broken into four categories: general-purpose registers, special-purpose application-accessible registers, segment registers, and special-purpose kernel-mode registers. Because the segment registers aren’t used much in modern 64-bit operating systems (such as Windows), there is little need to discuss them in this book. The special-purpose kernel-mode registers are intended for writing operating systems, debuggers, and other system-level tools. Such software construction is well beyond the scope of this text.</p>
<p>The x86-64 (Intel family) CPUs provide several <em>general-purpose registers</em> for application use. These include the following:</p>
<ul>
<li>Sixteen 64-bit registers that have the following names: RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8, R9, R10, R11, R12, R13, R14, and R15</li>
<li>Sixteen 32-bit registers: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, R8D, R9D, R10D, R11D, R12D, R13D, R14D, and R15D</li>
<li>Sixteen 16-bit registers: AX, BX, CX, DX, SI, DI, BP, SP, R8W, R9W, R10W, R11W, R12W, R13W, R14W, and R15W</li>
<li>Twenty 8-bit registers: AL, AH, BL, BH, CL, CH, DL, DH, DIL, SIL, BPL, SPL, R8B, R9B, R10B, R11B, R12B, R13B, R14B, and R15B</li>
</ul>
<p>Unfortunately, these are not 68 independent registers; instead, the x86-64 overlays the 64-bit registers over the 32-bit registers, the 32-bit registers over the 16-bit registers, and the 16-bit registers over the 8-bit registers. <a href="#table1-1" id="tableanchor1-1">Table 1-1</a> shows these relationships.</p>
<p>Because the general-purpose registers are not independent, modifying one register may modify as many as three other registers. For example, modifying the EAX register may very well modify the AL, AH, AX, and RAX registers. This fact cannot be overemphasized. A common mistake in programs written by beginning assembly language programmers is register value corruption due to the programmer not completely understanding the ramifications of the relationships shown in <a href="#table1-1">Table 1-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-1">Table 1-1</a>: General-Purpose Registers on the x86-64</p></figcaption>
<table id="table-501089c01-0001" border="1">
<thead>
<tr>
<td><b>Bits 0–63</b></td>
<td><b>Bits 0–31</b></td>
<td><b>Bits 0–15</b></td>
<td><b>Bits 8–15</b></td>
<td><b>Bits 0–7</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>RAX</td>
<td>EAX</td>
<td>AX</td>
<td>AH</td>
<td>AL</td>
</tr>
<tr>
<td>RBX</td>
<td>EBX</td>
<td>BX</td>
<td>BH</td>
<td>BL</td>
</tr>
<tr>
<td>RCX</td>
<td>ECX</td>
<td>CX</td>
<td>CH</td>
<td>CL</td>
</tr>
<tr>
<td>RDX</td>
<td>EDX</td>
<td>DX</td>
<td>DH</td>
<td>DL</td>
</tr>
<tr>
<td>RSI</td>
<td>ESI</td>
<td>SI</td>
<td/>
<td>SIL</td>
</tr>
<tr>
<td>RDI</td>
<td>EDI</td>
<td>DI</td>
<td/>
<td>DIL</td>
</tr>
<tr>
<td>RBP</td>
<td>EBP</td>
<td>BP</td>
<td/>
<td>BPL</td>
</tr>
<tr>
<td>RSP</td>
<td>ESP</td>
<td>SP</td>
<td/>
<td>SPL</td>
</tr>
<tr>
<td>R8</td>
<td>R8D</td>
<td>R8W</td>
<td/>
<td>R8B</td>
</tr>
<tr>
<td><span epub:type="pagebreak" title="11" id="Page_11"/>R9</td>
<td>R9D</td>
<td>R9W</td>
<td/>
<td>R9B</td>
</tr>
<tr>
<td>R10</td>
<td>R10D</td>
<td>R10W</td>
<td/>
<td>R10B</td>
</tr>
<tr>
<td>R11</td>
<td>R11D</td>
<td>R11W</td>
<td/>
<td>R11B</td>
</tr>
<tr>
<td>R12</td>
<td>R12D</td>
<td>R12W</td>
<td/>
<td>R12B</td>
</tr>
<tr>
<td>R13</td>
<td>R13D</td>
<td>R13W</td>
<td/>
<td>R13B</td>
</tr>
<tr>
<td>R14</td>
<td>R14D</td>
<td>R14W</td>
<td/>
<td>R14B</td>
</tr>
<tr>
<td>R15</td>
<td>R15D</td>
<td>R15W</td>
<td/>
<td>R15B</td>
</tr>
</tbody>
</table>
</figure>
<p>In addition to the general-purpose registers, the x86-64 provides special-purpose registers, including eight <em>floating-point registers</em> implemented in the x87 <em>floating-point unit (FPU)</em>. Intel named these registers ST(0) to ST(7). Unlike with the general-purpose registers, an application program cannot directly access these. Instead, a program treats the floating-point register file as an eight-entry-deep stack and accesses only the top one or two entries (see <span class="xref" itemid="xref_target_“Floating-Point Arithmetic” in Chapter 6">“Floating-Point Arithmetic” in Chapter 6</span> for more details).</p>
<p>Each floating-point register is 80 bits wide, holding an extended-precision real value (hereafter just <em>extended precision</em>). Although Intel added other floating-point registers to the x86-64 CPUs over the years, the FPU registers still find common use in code because they support this 80-bit floating-point format.</p>
<p>In the 1990s, Intel introduced the MMX register set and instructions to support <em>single instruction, multiple data</em> <em>(SIMD)</em> operations. The <em>MMX register set</em> is a group of eight 64-bit registers that overlay the ST(0) to ST(7) registers on the FPU. Intel chose to overlay the FPU registers because this made the MMX registers immediately compatible with multitasking operating systems (such as Windows) without any code changes to those OSs. Unfortunately, this choice meant that an application could not simultaneously use the FPU and MMX instructions.</p>
<p>Intel corrected this issue in later revisions of the x86-64 by adding the <em>XMM register set</em>. For that reason, you rarely see modern applications using the MMX registers and instruction set. They are available if you really want to use them, but it is almost always better to use the XMM registers (and instruction set) and leave the registers in FPU mode.</p>
<p>To overcome the limitations of the MMX/FPU register conflicts, AMD/Intel added sixteen 128-bit XMM registers (XMM0 to XMM15) and the SSE/SSE2 instruction set. Each register can be configured as four 32-bit floating-point registers; two 64-bit double-precision floating-point registers; or sixteen 8-bit, eight 16-bit, four 32-bit, two 64-bit, or one 128-bit integer registers. In later variants of the x86-64 CPU family, AMD/Intel doubled the size of the registers to 256 bits each (renaming them YMM0 to YMM15) to support eight 32-bit floating-point values or four 64-bit double-precision floating-point values (integer operations were still limited to 128 bits).</p>
<p><span epub:type="pagebreak" title="12" id="Page_12"/>The <em/><em>RFLAGS</em> (or just <em>FLAGS</em>) register is a 64-bit register that encapsulates several single-bit Boolean (true/false) values.<sup class="FootnoteReference"><a id="c01-footnoteref-1" href="#c01-footnote-1">1</a></sup> Most of the bits in the RFLAGS register are either reserved for kernel mode (operating system) functions or are of little interest to the application programmer. Eight of these bits (or <em>flags</em>) are of interest to application programmers writing assembly language programs: the overflow, direction, interrupt disable,<sup class="FootnoteReference"><a id="c01-footnoteref-2" href="#c01-footnote-2">2</a></sup> sign, zero, auxiliary carry, parity, and carry flags. <a href="#figure1-2" id="figureanchor1-2">Figure 1-2</a> shows the layout of the flags within the lower 16 bits of the RFLAGS register.</p>
<figure>
<img src="image_fi/501089c01/f01002.png" alt="f01002" class=""/>
<figcaption><p><a id="figure1-2">Figure 1-2</a>: Layout of the FLAGS register (lower 16 bits of RFLAGS)</p></figcaption>
</figure>
<p>Four flags in particular are extremely valuable: the overflow, carry, sign, and zero flags, collectively called the <em>condition codes.</em><sup class="FootnoteReference"><a id="c01-footnoteref-3" href="#c01-footnote-3">3</a></sup> The state of these flags lets you test the result of previous computations. For example, after comparing two values, the condition code flags will tell you whether one value is less than, equal to, or greater than a second value.</p>
<p>One important fact that comes as a surprise to those just learning assembly language is that almost all calculations on the x86-64 CPU involve a register. For example, to add two variables together and store the sum into a third variable, you must load one of the variables into a register, add the second operand to the value in the register, and then store the register away in the destination variable. Registers are a middleman in nearly every calculation.</p>
<p>You should also be aware that, although the registers are called <em/><em>general-purpose</em>, you cannot use any register for any purpose. All the x86-64 registers have their own special purposes that limit their use in certain contexts. The RSP register, for example, has a very special purpose that effectively prevents <span epub:type="pagebreak" title="13" id="Page_13"/>you from using it for anything else (it’s the <em>stack pointer</em>). Likewise, the RBP register has a special purpose that limits its usefulness as a general-purpose register. For the time being, avoid the use of the RSP and RBP registers for generic calculations; also, keep in mind that the remaining registers are not completely interchangeable in your programs.</p>
<h2 id="h1-501089c01-0008">	1.8	The Memory Subsystem</h2>
<p class="BodyFirst">The <em>memory subsystem</em> holds data such as program variables, constants, machine instructions, and other information. Memory is organized into cells, each of which holds a small piece of information. The system can combine the information from these small cells (or <em>memory locations</em>) to form larger pieces of information.</p>
<p>The x86-64 supports <em>byte-addressable memory</em>, which means the basic memory unit is a byte, sufficient to hold a single character or a (very) small integer value (we’ll talk more about that in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>).</p>
<p>Think of memory as a linear array of bytes. The address of the first byte is 0, and the address of the last byte is 2<sup>32</sup> – 1. For an x86 processor with 4GB memory installed,<sup class="FootnoteReference"><a id="c01-footnoteref-4" href="#c01-footnote-4">4</a></sup> the following pseudo-Pascal array declaration is a good approximation of memory:</p>
<pre><code>Memory: array [0..4294967295] of byte;</code></pre>
<p>C/C++ and Java users might prefer the following syntax:</p>
<pre><code>byte Memory[4294967296];</code></pre>
<p>For example, to execute the equivalent of the Pascal statement <code>Memory [125] := 0;</code>, the CPU places the value <code>0</code> on the data bus, places the address <code>125</code> on the address bus, and asserts the write line (this generally involves setting that line to <code>0</code>), as shown in <a href="#figure1-3" id="figureanchor1-3">Figure 1-3</a>.</p>
<figure>
<img src="image_fi/501089c01/f01003.png" alt="f01003" class=""/>
<figcaption><p><a id="figure1-3">Figure 1-3</a>: Memory write operation</p></figcaption>
</figure>
<p>To execute the equivalent of <code>CPU := Memory [125];</code>, the CPU places the address <code>125</code> on the address bus, asserts the read line (because the CPU is reading data from memory), and then reads the resulting data from the data bus (see <a href="#figure1-4" id="figureanchor1-4">Figure 1-4</a>).</p>
<span epub:type="pagebreak" title="14" id="Page_14"/><figure>
<img src="image_fi/501089c01/f01004.png" alt="f01004" class=""/>
<figcaption><p><a id="figure1-4">Figure 1-4</a>: Memory read operation</p></figcaption>
</figure>
<p>To store larger values, the x86 uses a sequence of consecutive memory locations. <a href="#figure1-5" id="figureanchor1-5">Figure 1-5</a> shows how the x86 stores bytes, <em>words</em> (2 bytes), and <em>double words</em> (4 bytes) in memory. The memory address of each object is the address of the first byte of each object (that is, the lowest address).</p>
<figure>
<img src="image_fi/501089c01/f01005.png" alt="f01005" class=""/>
<figcaption><p><a id="figure1-5">Figure 1-5</a>: Byte, word, and double-word storage in memory</p></figcaption>
</figure>
<h2 id="h1-501089c01-0009">	1.9	Declaring Memory Variables in MASM</h2>
<p class="BodyFirst">Although it is possible to reference memory by using numeric addresses in assembly language, doing so is painful and error-prone. Rather than having your program state, “Give me the 32-bit value held in memory location 192 and the 16-bit value held in memory location 188,” it’s much nicer to state, “Give me the contents of <code>elementCount</code> and <code>portNumber</code>.” Using variable names, rather than memory addresses, makes your program much easier to write, read, and maintain.</p>
<p>To create (writable) data variables, you have to put them in a data section of the MASM source file, defined using the <code>.data</code> directive. This directive tells MASM that all following statements (up to the next <code>.code</code> or other section-defining directive) will define data declarations to be grouped into a read/write section of memory.</p>
<p><span epub:type="pagebreak" title="15" id="Page_15"/>Within a <code>.data</code> section, MASM allows you to declare variable objects by using a set of data declaration directives. The basic form of a data declaration directive is</p>
<pre><code><var>label</var>  <var>directive</var> ?</code></pre>
<p class="BodyContinued">where <var>label</var> is a legal MASM identifier and <var>directive</var> is one of the directives appearing in <a href="#table1-2" id="tableanchor1-2">Table 1-2</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-2">Table 1-2</a>: MASM Data Declaration Directives</p></figcaption>
<table id="table-501089c01-0002" border="1">
<thead>
<tr>
<td><b>Directive</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code/><code>byte</code> (or <code>db</code>) </td>
<td>Byte (unsigned 8-bit) value</td>
</tr>
<tr>
<td><code/><code>sbyte</code></td>
<td>Signed 8-bit integer value</td>
</tr>
<tr>
<td><code/><code>word</code> (or <code>dw</code>)</td>
<td>Unsigned 16-bit (word) value</td>
</tr>
<tr>
<td><code/><code>sword</code></td>
<td>Signed 16-bit integer value</td>
</tr>
<tr>
<td><code/><code>dword</code> (or <code>dd</code>)</td>
<td>Unsigned 32-bit (double-word) value</td>
</tr>
<tr>
<td><code/><code>sdword</code></td>
<td>Signed 32-bit integer value</td>
</tr>
<tr>
<td><code/><code>qword</code> (or <code>dq</code>)</td>
<td>Unsigned 64-bit (quad-word) value</td>
</tr>
<tr>
<td><code/><code>sqword</code></td>
<td>Signed 64-bit integer value</td>
</tr>
<tr>
<td><code/><code>tbyte</code> (or <code>dt</code>)</td>
<td>Unsigned 80-bit (10-byte) value</td>
</tr>
<tr>
<td><code/><code>oword</code></td>
<td>128-bit (octal-word) value</td>
</tr>
<tr>
<td><code/><code>real4</code></td>
<td>Single-precision (32-bit) floating-point value</td>
</tr>
<tr>
<td><code/><code>real8</code></td>
<td>Double-precision (64-bit) floating-point value</td>
</tr>
<tr>
<td><code/><code>real10</code></td>
<td>Extended-precision (80-bit) floating-point value</td>
</tr>
</tbody>
</table>
</figure>
<p>The question mark (<code>?</code>) operand tells MASM that the object will not have an explicit value when the program loads into memory (the default initialization is zero). If you would like to initialize the variable with an explicit value, replace the <code>?</code> with the initial value; for example:</p>
<pre><code>hasInitialValue  sdword   -1</code></pre>
<p>Some of the data declaration directives in <a href="#table1-2">Table 1-2</a> have a signed version (the directives with the <code>s</code> prefix). For the most part, MASM ignores this prefix. It is the machine instructions you write that differentiate between signed and unsigned operations; MASM itself usually doesn’t care whether a variable holds a signed or an unsigned value. Indeed, MASM allows both of the following:</p>
<pre><code>     .data
u8   byte    -1    ; Negative initializer is okay
i8   sbyte   250   ; even though +128 is maximum signed byte</code></pre>
<p>All MASM cares about is whether the initial value will fit into a byte. The <code>-1</code>, even though it is not an unsigned value, will fit into a byte in memory. Even though <code>250</code> is too large to fit into a signed 8-bit integer (see <span class="xref" itemid="xref_target_“Signed and Unsigned Numbers” in Chapter 2"><span epub:type="pagebreak" title="16" id="Page_16"/>“Signed and Unsigned Numbers” in Chapter 2</span>), MASM will happily accept this because <code>250</code> will fit into a byte variable (as an unsigned number).</p>
<p>It is possible to reserve storage for multiple data values in a single data declaration directive. The string multi-valued data type is critical to this chapter (later chapters discuss other types, such as arrays in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>). You can create a null-terminated string of characters in memory by using the <code>byte</code> directive as follows:</p>
<pre><code>; Zero-terminated C/C++ string.
strVarName  byte 'String of characters', 0</code></pre>
<p>Notice the <code>, 0</code> that appears after the string of characters. In any data declaration (not just byte declarations), you can place multiple data values in the operand field, separated by commas, and MASM will emit an object of the specified size and value for each operand. For string values (surrounded by apostrophes in this example), MASM emits a byte for each character in the string (plus a zero byte for the <code>, 0</code> operand at the end of the string). MASM allows you to define strings by using either apostrophes or quotes; you must terminate the string of characters with the same delimiter that begins the string (quote or apostrophe).</p>
<h3 id="h2-501089c01-0001">1.9.1	Associating Memory Addresses with Variables</h3>
<p class="BodyFirst">One of the nice things about using an assembler/compiler like MASM is that you don’t have to worry about numeric memory addresses. All you need to do is declare a variable in MASM, and MASM associates that variable with a unique set of memory addresses. For example, say you have the following declaration section:</p>
<pre><code>     .data
i8   sbyte   ?
i16  sword   ?
i32  sdword  ?
i64  sqword  ?</code></pre>
<p>MASM will find an unused 8-bit byte in memory and associate it with the <code>i8</code> variable; it will find a pair of consecutive unused bytes and associate them with <code>i16</code>; it will find four consecutive locations and associate them with <code>i32</code>; finally, MASM will find 8 consecutive unused bytes and associate them with <code>i64</code>. You’ll always refer to these variables by their name. You generally don’t have to concern yourself with their numeric address. Still, you should be aware that MASM is doing this for you.</p>
<p>When MASM is processing declarations in a <code>.data</code> section, it assigns consecutive memory locations to each variable.<sup class="FootnoteReference"><a id="c01-footnoteref-5" href="#c01-footnote-5">5</a></sup> Assuming <code>i8</code> (in the previous declarations) as a memory address of 101, MASM will assign the addresses appearing in <a href="#table1-3" id="tableanchor1-3">Table 1-3</a> to <code>i8</code>, <code>i16</code>, <code>i32</code>, and <code>i64</code>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-3">Table 1-3</a>: Variable Address Assignment<span epub:type="pagebreak" title="17" id="Page_17"/></p></figcaption>
<table id="table-501089c01-0003" border="1">
<thead>
<tr>
<td><b>Variable</b></td>
<td><b>Memory address</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>i8</code></td>
<td>101</td>
</tr>
<tr>
<td><code>i16</code></td>
<td>102 (address of <code>i8</code> plus 1)</td>
</tr>
<tr>
<td><code>i32</code></td>
<td>104 (address of <code>i16</code> plus 2)</td>
</tr>
<tr>
<td><code>i64</code></td>
<td>108 (address of <code>i32</code> plus 4)</td>
</tr>
</tbody>
</table>
</figure>
<p>Whenever you have multiple operands in a data declaration statement, MASM will emit the values to sequential memory locations in the order they appear in the operand field. The label associated with the data declaration (if one is present) is associated with the address of the first (leftmost) operand’s value. See <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> for more details.</p>
<h3 id="h2-501089c01-0002">1.9.2	Associating Data Types with Variables</h3>
<p class="BodyFirst">During assembly, MASM associates a data type with every label you define, including variables. This is rather advanced for an assembly language (most assemblers simply associate a value or an address with an identifier).</p>
<p>For the most part, MASM uses the variable’s size (in bytes) as its type (see <a href="#table1-4" id="tableanchor1-4">Table 1-4</a>).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-4">Table 1-4</a>: MASM Data Types</p></figcaption>
<table id="table-501089c01-0004" border="1">
<thead>
<tr>
<td><b>Type</b></td>
<td><b>Size</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code> (<code>db</code>)</td>
<td>1</td>
<td>1-byte memory operand, unsigned (generic integer)</td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td>1</td>
<td>1-byte memory operand, signed integer</td>
</tr>
<tr>
<td><code>word</code> (<code>dw</code>)</td>
<td>2</td>
<td>2-byte memory operand, unsigned (generic integer)</td>
</tr>
<tr>
<td><code>sword</code></td>
<td>2</td>
<td>2-byte memory operand, signed integer</td>
</tr>
<tr>
<td><code>dword</code> (<code>dd</code>)</td>
<td>4</td>
<td>4-byte memory operand, unsigned (generic integer)</td>
</tr>
<tr>
<td><code>sdword</code></td>
<td>4</td>
<td>4-byte memory operand, signed integer</td>
</tr>
<tr>
<td><code>qword</code> (<code>dq</code>)</td>
<td>8</td>
<td>8-byte memory operand, unsigned (generic integer)</td>
</tr>
<tr>
<td><code>sqword</code></td>
<td>8</td>
<td>8-byte memory operand, signed integer</td>
</tr>
<tr>
<td><code>tbyte</code> (<code>dt</code>)</td>
<td>10</td>
<td>10-byte memory operand, unsigned (generic integer or BCD)</td>
</tr>
<tr>
<td><code>oword</code></td>
<td>16</td>
<td>16-byte memory operand, unsigned (generic integer)</td>
</tr>
<tr>
<td><code>real4</code></td>
<td>4</td>
<td>4-byte single-precision floating-point memory operand</td>
</tr>
<tr>
<td><code>real8</code></td>
<td>8</td>
<td>8-byte double-precision floating-point memory operand</td>
</tr>
<tr>
<td><code>real10</code></td>
<td>10</td>
<td>10-byte extended-precision floating-point memory operand</td>
</tr>
<tr>
<td><code>proc</code></td>
<td>N/A</td>
<td>Procedure label (associated with <code>PROC</code> directive)</td>
</tr>
<tr>
<td><var>label</var>:</td>
<td>N/A</td>
<td>Statement label (any identifier immediately followed by a <code>:</code>)</td>
</tr>
<tr>
<td><var>constant</var></td>
<td>Varies</td>
<td>Constant declaration (equate) using <code>=</code> or <code>EQU</code> directive</td>
</tr>
<tr>
<td><var>text</var></td>
<td>N/A</td>
<td>Textual substitution using macro or <code>TEXTEQU</code> directive</td>
</tr>
</tbody>
</table>
</figure>
<p>Later sections and chapters fully describe the <code>proc</code>, <var>label</var>, <var>constant</var>, and <var>text</var> types.</p>
<h2 id="h1-501089c01-0010"><span epub:type="pagebreak" title="18" id="Page_18"/>	1.10	Declaring (Named) Constants in MASM</h2>
<p class="BodyFirst">MASM allows you to declare manifest constants by using the <code>=</code> directive. A <em>manifest constant</em> is a symbolic name (identifier) that MASM associates with a value. Everywhere the symbol appears in the program, MASM will directly substitute the value of that symbol for the symbol.</p>
<p>A manifest constant declaration takes the following form:</p>
<pre><code><var>label</var> = <var>expression</var></code></pre>
<p>Here, <var>label</var> is a legal MASM identifier, and <var>expression</var> is a constant arithmetic expression (typically, a single literal constant value). The following example defines the symbol <code>dataSize</code> to be equal to <code>256</code>:</p>
<pre><code>dataSize = 256</code></pre>
<p>Most of the time, MASM’s <code>equ</code> directive is a synonym for the <code>=</code> directive. For the purposes of this chapter, the following statement is largely equivalent to the previous declaration:</p>
<pre><code>dataSize equ 256</code></pre>
<p>Constant declarations (<em>equates</em> in MASM terminology) may appear anywhere in your MASM source file, prior to their first use. They may appear in a .<code>data</code> section, a <code>.code</code> section, or even outside any sections.</p>
<h2 id="h1-501089c01-0011">	1.11	Some Basic Machine Instructions</h2>
<p class="BodyFirst">The x86-64 CPU family provides from just over a couple hundred to many thousands of machine instructions, depending on how you define a machine instruction. But most assembly language programs use around 30 to 50 machine instructions,<sup class="FootnoteReference"><a id="c01-footnoteref-6" href="#c01-footnote-6">6</a></sup> and you can write several meaningful programs with only a few. This section provides a small handful of machine instructions so you can start writing simple MASM assembly language programs right away.</p>
<h3 id="h2-501089c01-0003">1.11.1	The mov Instruction</h3>
<p class="BodyFirst">Without question, the <code>mov</code> instruction is the most oft-used assembly language statement. In a typical program, anywhere from 25 percent to 40 percent of the instructions are <code>mov</code> instructions. As its name suggests, this instruction moves data from one location to another.<sup class="FootnoteReference"><a id="c01-footnoteref-7" href="#c01-footnote-7">7</a></sup> Here’s the generic MASM syntax for this instruction:</p>
<pre><code>mov    <var>destination_operand</var>, <var>source_operand</var></code></pre>
<p><span epub:type="pagebreak" title="19" id="Page_19"/>The <var>source_operand</var> may be a (general-purpose) register, a memory variable, or a constant. The <var>destination_operand</var> may be a register or a memory variable. The x86-64 instruction set does not allow both operands to be memory variables. In a high-level language like Pascal or C/C++, the <code>mov</code> instruction is roughly equivalent to the following assignment statement:</p>
<pre><code><var>destination_operand</var> = <var>source_operand</var> ;</code></pre>
<p>The <code>mov</code> instruction’s operands must both be the same size. That is, you can move data between a pair of byte (8-bit) objects, word (16-bit) objects, double-word (32-bit), or quad-word (64-bit) objects; you may not, however, mix the sizes of the operands. <a href="#table1-5" id="tableanchor1-5">Table 1-5</a> lists all the legal combinations for the <code>mov</code> instruction. </p>
<p>You should study this table carefully because most of the general-purpose x86-64 instructions use this syntax.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-5">Table 1-5</a>: Legal x86-64 <code>mov</code> Instruction Operands</p></figcaption>
<table id="table-501089c01-0005" border="1">
<thead>
<tr>
<td><b>Source<a href="#table-footnote-1" id="table-footnoteref-1">*</a></b></td>
<td><b>Destination</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>reg<sub>8</sub></td>
<td>reg<sub>8</sub></td>
</tr>
<tr>
<td>reg<sub>8</sub></td>
<td>mem<sub>8</sub></td>
</tr>
<tr>
<td>mem<sub>8</sub></td>
<td>reg<sub>8</sub></td>
</tr>
<tr>
<td>constant<a href="#table-footnote-2" id="table-footnoteref-2">**</a></td>
<td>reg<sub>8</sub></td>
</tr>
<tr>
<td>constant</td>
<td>mem<sub>8</sub></td>
</tr>
<tr>
<td>reg<sub>16</sub></td>
<td>reg<sub>16</sub></td>
</tr>
<tr>
<td>reg<sub>16</sub></td>
<td>mem<sub>16</sub></td>
</tr>
<tr>
<td>mem<sub>16</sub></td>
<td>reg<sub>16</sub></td>
</tr>
<tr>
<td>constant</td>
<td>reg<sub>16</sub></td>
</tr>
<tr>
<td>constant</td>
<td>mem<sub>16</sub></td>
</tr>
<tr>
<td>reg<sub>32</sub></td>
<td>reg<sub>32</sub></td>
</tr>
<tr>
<td>reg<sub>32</sub></td>
<td>mem<sub>32</sub></td>
</tr>
<tr>
<td>mem<sub>32</sub></td>
<td>reg<sub>32</sub></td>
</tr>
<tr>
<td>constant</td>
<td>reg<sub>32</sub></td>
</tr>
<tr>
<td>constant</td>
<td>mem<sub>32</sub></td>
</tr>
<tr>
<td>reg<sub>64</sub></td>
<td>reg<sub>64</sub></td>
</tr>
<tr>
<td>reg<sub>64</sub></td>
<td>mem<sub>64</sub></td>
</tr>
<tr>
<td>mem<sub>64</sub></td>
<td>reg<sub>64</sub></td>
</tr>
<tr>
<td>constant</td>
<td>reg<sub>64</sub></td>
</tr>
<tr>
<td>constant<sub>32</sub></td>
<td>mem<sub>64</sub></td>
</tr>
</tbody>
<tfoot>
<tr>
<td colspan="2"><p class="TableFootnote"><sup><a href="#table-footnoteref-1" id="table-footnote-1">*</a></sup> reg<sub><em>n</em></sub> means an <em>n</em>-bit register, and mem<sub><em>n</em></sub> means an <em>n</em>-bit memory location.</p>
<p class="TableFootnote"><sup><a href="#table-footnoteref-2" id="table-footnote-2">**</a></sup> The constant must be small enough to fit in the specified destination operand.</p></td>
</tr>
</tfoot>
</table>
</figure>
<p><span epub:type="pagebreak" title="20" id="Page_20"/>This table includes one important thing to note: the x86-64 allows you to move only a 32-bit constant value into a 64-bit memory location (it will sign-extend this value to 64 bits; see <span class="xref" itemid="xref_target_“Sign Extension and Zero Extension” in Chapter 2">“Sign Extension and Zero Extension” in Chapter 2</span> for more information about sign extension). Moving a 64-bit constant into a 64-bit register is the only x86-64 instruction that allows a 64-bit constant operand. This inconsistency in the x86-64 instruction set is annoying. Welcome to the x86-64.</p>
<h3 id="h2-501089c01-0004">1.11.2	Type Checking on Instruction Operands</h3>
<p class="BodyFirst">MASM enforces some type checking on instruction operands. In particular, the size of an instruction’s operands must agree. For example, MASM will generate an error for the following:</p>
<pre><code>i8 byte ?
    .
    .
    .
mov ax, i8</code></pre>
<p>The problem is that you are attempting to load an 8-bit variable (<code>i8</code>) into a 16-bit register (AX). As their sizes are not compatible, MASM assumes that this is a logic error in the program and reports an error.<sup class="FootnoteReference"><a id="c01-footnoteref-8" href="#c01-footnote-8">8</a></sup></p>
<p>For the most part, MASM ignores the difference between signed and unsigned variables. MASM is perfectly happy with both of these <code>mov</code> instructions:</p>
<pre><code>i8 sbyte ?
u8 byte  ?
    .
    .
    .
mov al, i8
mov bl, u8</code></pre>
<p>All MASM cares about is that you’re moving a byte variable into a byte-sized register. Differentiating signed and unsigned values in those registers is up to the application program. MASM even allows something like this:</p>
<pre><code>r4v real4 ?
r8v real8 ?
    .
    .
    .
mov eax, r4v
mov rbx, r8v</code></pre>
<p><span epub:type="pagebreak" title="21" id="Page_21"/>Again, all MASM really cares about is the size of the memory operands, not that you wouldn’t normally load a floating-point variable into a general-purpose register (which typically holds integer values).</p>
<p>In <a href="#table1-4">Table 1-4</a>, you’ll notice that there are <code>proc</code>, <var>label</var>, and <var>constant</var> types. MASM will report an error if you attempt to use a <code>proc</code> or <var>label</var> reserved word in a <code>mov</code> instruction. The procedure and label types are associated with addresses of machine instructions, not variables, and it doesn’t make sense to “load a procedure” into a register.</p>
<p>However, you may specify a <var>constant</var> symbol as a source operand to an instruction; for example:</p>
<pre><code>someConst = 5
    .
    .
    .
mov eax, someConst</code></pre>
<p>As there is no size associated with constants, the only type checking MASM will do on a constant operand is to verify that the constant will fit in the destination operand. For example, MASM will reject the following:</p>
<pre><code>wordConst = 1000
    .
    .
    .
mov al, wordConst</code></pre>
<h3 id="h2-501089c01-0005">1.11.3	The add and sub Instructions</h3>
<p class="BodyFirst">The x86-64 <code>add</code> and <code>sub</code> instructions add or subtract two operands, respectively. Their syntax is nearly identical to the <code>mov</code> instruction: </p>
<pre><code>add <var>destination_operand</var><em>, </em><var>source_operand</var>
sub <var>destination_operand</var><em>, </em><var>source_operand</var></code></pre>
<p>However, constant operands are limited to a maximum of 32 bits. If your destination operand is 64 bits, the CPU allows only a 32-bit immediate source operand (it will sign-extend that operand to 64 bits; see <span class="xref" itemid="xref_target_“Sign Extension and Zero Extension” in Chapter 2">“Sign Extension and Zero Extension” in Chapter 2</span> for more details on sign extension).</p>
<p>The <code>add</code> instruction does the following: </p>
<pre><code><var>destination_operand</var> = <var>destination_operand</var> + <var>source_operand</var></code></pre>
<p>The <code>sub</code> instruction does the calculation:</p>
<pre><code><var>destination_operand</var> = <var>destination_operand</var> - <var>source_operand</var></code></pre>
<p>With these three instructions, plus some MASM control structures, you can actually write sophisticated programs.</p>
<h3 id="h2-501089c01-0006"><span epub:type="pagebreak" title="22" id="Page_22"/>1.11.4	The lea Instruction</h3>
<p class="BodyFirst">Sometimes you need to load the address of a variable into a register rather than the value of that variable. You can use the <code>lea</code> (<em>load effective address</em>) instruction for this purpose. The <code>lea</code> instruction takes the following form:</p>
<pre><code>lea    <var>reg64</var>, <var>memory_var</var></code></pre>
<p>Here, <var>reg64</var> is any general-purpose 64-bit register, and <var>memory_var</var> is a variable name. Note that <var>memory_var</var>’s type is irrelevant; it doesn’t have to be a <code>qword</code> variable (as is the case with <code>mov</code>, <code>add</code>, and <code>sub</code> instructions). Every variable has a memory address associated with it, and that address is always 64 bits. The following example loads the RCX register with the address of the first character in the <code>strVar</code> string:</p>
<pre><code>strVar  byte "Some String", 0
    .
    .
    .
    lea rcx, strVar</code></pre>
<p>The <code>lea</code> instruction is roughly equivalent to the C/C++ unary <code>&amp;</code> (<em>address-of</em>) operator. The preceding assembly example is conceptually equivalent to the following C/C++ code:</p>
<pre><code>char strVar[] = "Some String";
char *RCX;
    .
    .
    .
    RCX = &amp;strVar[0];</code></pre>
<h3 id="h2-501089c01-0007">1.11.5	The call and ret Instructions and MASM Procedures</h3>
<p class="BodyFirst">To make function calls (as well as write your own simple functions), you need the <code>call</code> and <code>ret</code> instructions.</p>
<p>The <code>ret</code> instruction serves the same purpose in an assembly language program as the <code>return</code> statement in C/C++: it returns control from an assembly language procedure (assembly language functions are called <em>procedures</em>). For the time being, this book will use the variant of the <code>ret</code> instruction that does not have an operand:</p>
<pre><code>ret</code></pre>
<p>(The <code>ret</code> instruction does allow a single operand, but unlike in C/C++, the operand does not specify a function return value. You’ll see the purpose of the <code>ret</code> instruction operand in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.)</p>
<p>As you might guess, you call a MASM procedure by using the <code>call</code> instruction. This instruction can take a couple of forms. The most common is</p>
<pre><code>call <var>proc_name</var></code></pre>
<p class="BodyContinued">where <var>proc_name</var> is the name of the procedure you want to call.</p>
<p><span epub:type="pagebreak" title="23" id="Page_23"/>As you’ve seen in a couple code examples already, a MASM procedure consists of the line</p>
<pre><code><var>proc_name</var> proc</code></pre>
<p class="BodyContinued">followed by the body of the procedure (typically ending with a <code>ret</code> instruction). At the end of the procedure (typically immediately after the <code>ret</code> instruction), you end the procedure with the following statement:</p>
<pre><code><var>proc_name</var> endp</code></pre>
<p>The label on the <code>endp</code> directive must be identical to the one you supply for the <code>proc</code> statement. </p>
<p>In the stand-alone assembly language program in <a href="#listing1-4" id="listinganchor1-4">Listing 1-4</a>, the main program calls <code>myProc</code>, which will immediately return to the main program, which then immediately returns to Windows.</p>
<pre><code>; Listing 1-4

; A simple demonstration of a user-defined procedure.

        .code

; A sample user-defined procedure that this program can call.

myProc  proc
        ret    ; Immediately return to the caller
myProc  endp

; Here is the "main" procedure.

main    PROC

; Call the user-defined procedure.

        call  myProc

        ret    ; Returns to caller
main    endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing1-4">Listing 1-4</a>: A sample user-defined procedure in an assembly language program</p>
<p>You can compile this program and try running it by using the following commands:</p>
<pre><code>C:\&gt;<b>ml64 listing1-4.asm /link /subsystem:console /entry:main</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing1-4.asm
Microsoft (R) Incremental Linker Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

<span epub:type="pagebreak" title="24" id="Page_24"/>/OUT:listing1-4.exe
listing1-4.obj
/subsystem:console
/entry:main

C:\&gt;<b>listing1-4</b></code></pre>
<h2 id="h1-501089c01-0012">	1.12	Calling C/C++ Procedures</h2>
<p class="BodyFirst">While writing your own procedures and calling them are quite useful, the reason for introducing procedures at this point is not to allow you to write your own procedures, but rather to give you the ability to call procedures (functions) written in C/C++. Writing your own procedures to convert and output data to the console is a rather complex task (probably well beyond your capabilities at this point). Instead, you can call the C/C++ <code>printf()</code> function to produce program output and verify that your programs are actually doing something when you run them.</p>
<p>Unfortunately, if you call <code>printf()</code> in your assembly language code without providing a <code>printf()</code> procedure, MASM will complain that you’ve used an undefined symbol. To call a procedure outside your source file, you need to use the MASM <code>externdef</code> directive.<sup class="FootnoteReference"><a id="c01-footnoteref-9" href="#c01-footnote-9">9</a></sup> This directive has the following syntax:</p>
<pre><code>externdef  <var>symbol</var>:<var>type</var></code></pre>
<p>Here, <var>symbol</var> is the external symbol you want to define, and <var>type</var> is the type of that symbol (which will be <code>proc</code> for external procedure definitions). To define the <code>printf()</code> symbol in your assembly language file, use this statement:</p>
<pre><code>externdef  printf:proc</code></pre>
<p>When defining external procedure symbols, you should put the <code>externdef</code> directive in your <code>.code</code> section.</p>
<p>The <code>externdef</code> directive doesn’t let you specify parameters to pass to the <code>printf()</code> procedure, nor does the <code>call</code> instruction provide a mechanism for specifying parameters. Instead, you can pass up to four parameters to the <code>printf()</code> function in the x86-64 registers RCX, RDX, R8, and R9. The <code>printf()</code> function requires that the first parameter be the address of a format string. Therefore, you should load RCX with the address of a zero-terminated string prior to calling <code>printf()</code>. If the format string contains any format specifiers (for example, <code>%d</code>), you must pass appropriate parameter values in RDX, R8, and R9. <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> goes into great detail concerning procedure parameters, including how to pass floating-point values and more than four parameters.</p>
<h2 id="h1-501089c01-0013"><span epub:type="pagebreak" title="25" id="Page_25"/>	1.13	Hello, World!</h2>
<p class="BodyFirst">At this point (many pages into this chapter), you finally have enough information to write this chapter’s namesake application: the “Hello, world!” program, shown in <a href="#listing1-5" id="listinganchor1-5">Listing 1-5</a>.</p>
<pre><code>; Listing 1-5
 
; A "Hello, world!" program using the C/C++ printf() function to
; provide the output.

        option  casemap:none
        .data

; Note: "10" value is a line feed character, also known as the
; "C" newline character.
 
fmtStr  byte    'Hello, world!', 10, 0

        .code

; External declaration so MASM knows about the C/C++ printf()
; function.

        externdef  printf:proc
        
; Here is the "asmFunc" function.

        public  asmFunc
asmFunc proc

; "Magic" instruction offered without explanation at this point:

        sub     rsp, 56

; Here's where we'll call the C printf() function to print
; "Hello, world!" Pass the address of the format string
; to printf() in the RCX register. Use the LEA instruction
; to get the address of fmtStr.

        lea     rcx, fmtStr
        call    printf

; Another "magic" instruction that undoes the effect of the 
; previous one before this procedure returns to its caller.

        add    rsp, 56
        
        ret    ; Returns to caller
        
asmFunc endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing1-5">Listing 1-5</a>: Assembly language code for the “Hello, world!” program</p>
<p><span epub:type="pagebreak" title="26" id="Page_26"/>The assembly language code contains two “magic” statements that this chapter includes without further explanation. Just accept the fact that subtracting from the RSP register at the beginning of the function and then adding this value back to RSP at the end of the function are needed to make the calls to C/C++ functions work properly. <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> more fully explains the purpose of these statements.</p>
<p>The C++ function in <a href="#listing1-6" id="listinganchor1-6">Listing 1-6</a> calls the assembly code and makes the <code>printf()</code> function available for use.</p>
<pre><code>// Listing 1-6
 
// C++ driver program to demonstrate calling printf() from assembly 
// language.
 
// Need to include stdio.h so this program can call "printf()".

#include &lt;stdio.h&gt;

// extern "C" namespace prevents "name mangling" by the C++
// compiler.

extern "C"
{
    // Here's the external function, written in assembly
    // language, that this program will call:

    void asmFunc(void);
};

int main(void)
{
    // Need at least one call to printf() in the C program to allow 
    // calling it from assembly.

    printf("Calling asmFunc:\n");
    asmFunc();
    printf("Returned from asmFunc\n");
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-6">Listing 1-6</a>: C++ code for the “Hello, world!” program</p>
<p>Here’s the sequence of steps needed to compile and run this code on my machine:</p>
<pre><code>C:\&gt;<b>ml64 /c listing1-5.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing1-5.asm

C:\&gt;<b>cl listing1-6.cpp listing1-5.obj</b>
Microsoft (R) C/C++ Optimizing Compiler Version 19.15.26730 for x64
<span epub:type="pagebreak" title="27" id="Page_27"/>Copyright (C) Microsoft Corporation.  All rights reserved.

listing1-6.cpp
Microsoft (R) Incremental Linker Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:listing1-6.exe
listing1-6.obj
listing1-5.obj

C:\&gt;<b>listing1-6</b>
Calling asmFunc:
Hello, World!
Returned from asmFunc</code></pre>
<p>You can finally print “Hello, world!” on the console!</p>
<h2 id="h1-501089c01-0014">	1.14	Returning Function Results in Assembly Language</h2>
<p class="BodyFirst">In a previous section, you saw how to pass up to four parameters to a procedure written in assembly language. This section describes the opposite process: returning a value to code that has called one of your procedures.</p>
<p>In pure assembly language (where one assembly language procedure calls another), passing parameters and returning function results are strictly a convention that the caller and callee procedures share with one another. Either the callee (the procedure being called) or the caller (the procedure doing the calling) may choose where function results appear.</p>
<p>From the callee viewpoint, the procedure returning the value determines where the caller can find the function result, and whoever calls that function must respect that choice. If a procedure returns a function result in the XMM0 register (a common place to return floating-point results), whoever calls that procedure must expect to find the result in XMM0. A different procedure could return its function result in the RBX register. </p>
<p>From the caller’s viewpoint, the choice is reversed. Existing code expects a function to return its result in a particular location, and the function being called must respect that wish.</p>
<p>Unfortunately, without appropriate coordination, one section of code might demand that functions it calls return their function results in one location, while a set of existing library functions might insist on returning their function results in another location. Clearly, such functions would not be compatible with the calling code. While there are ways to handle this situation (typically by writing facade code that sits between the caller and callee and moves the return results around), the best solution is to ensure that everybody agrees on things like where function return results will be found prior to writing any code.</p>
<p>This agreement is known as an <em>application binary interface (</em><em/><em>ABI)</em>. An ABI is a contract, of sorts, between different sections of code that describe <em>calling conventions</em> (where things are passed, where they are returned, and so on), <span epub:type="pagebreak" title="28" id="Page_28"/>data types, memory usage and alignment, and other attributes. CPU manufacturers, compiler writers, and operating system vendors all provide their own ABIs. For obvious reasons, this book uses the Microsoft Windows ABI.</p>
<p>Once again, it’s important to understand that when you’re writing your own assembly language code, the way you pass data between your procedures is totally up to you. One of the benefits of using assembly language is that you can decide the interface on a procedure-by-procedure basis. The only time you have to worry about adhering to an ABI is when you call code that is outside your control (or if that external code makes calls to your code). This book covers writing assembly language under Microsoft Windows (specifically, assembly code that interfaces with MSVC); therefore, when dealing with external code (Windows and C++ code), you have to use the Windows/MSVC ABI. The Microsoft ABI specifies that the first four parameters to <code>printf()</code> (or any C++ function, for that matter) must be passed in RCX, RDX, R8, and R9.</p>
<p>The Windows ABI also states that functions (procedures) return integer and pointer values (that fit into 64 bits) in the RAX register. So if some C++ code expects your assembly procedure to return an integer result, you would load the integer result into RAX immediately before returning from your procedure.</p>
<p>To demonstrate returning a function result, we’ll use the C++ program in <a href="#listing1-7" id="listinganchor1-7">Listing 1-7</a> (<em>c.cpp</em>, a generic C++ program that this book uses for most of the C++/assembly examples hereafter). This C++ program includes two extra function declarations: <code>getTitle()</code> (supplied by the assembly language code), which returns a pointer to a string containing the title of the program (the C++ code prints this title), and <code>readLine()</code> (supplied by the C++ program), which the assembly language code can call to read a line of text from the user (and put into a string buffer in the assembly language code).</p>
<pre><code>// Listing 1-7

// c.cpp
 
// Generic C++ driver program to demonstrate returning function
// results from assembly language to C++. Also includes a
// "readLine" function that reads a string from the user and
// passes it on to the assembly language code.
 
// Need to include stdio.h so this program can call "printf()"
// and string.h so this program can call strlen.

#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// extern "C" namespace prevents "name mangling" by the C++
// compiler.

<span epub:type="pagebreak" title="29" id="Page_29"/>extern "C"
{
    // asmMain is the assembly language code's "main program":

    void asmMain(void);

    // getTitle returns a pointer to a string of characters
    // from the assembly code that specifies the title of that
    // program (that makes this program generic and usable
    // with a large number of sample programs in "The Art of
    // 64-Bit Assembly").

    char *getTitle(void);

    // C++ function that the assembly
    // language program can call:

    int readLine(char *dest, int maxLen);

};

// readLine reads a line of text from the user (from the
// console device) and stores that string into the destination
// buffer the first argument specifies. Strings are limited in
// length to the value specified by the second argument
// (minus 1).
 
// This function returns the number of characters actually
// read, or -1 if there was an error.
 
// Note that if the user enters too many characters (maxlen or
// more), then this function returns only the first maxlen-1
// characters. This is not considered an error.

int readLine(char *dest, int maxLen)
{
    // Note: fgets returns NULL if there was an error, else
    // it returns a pointer to the string data read (which
    // will be the value of the dest pointer).

    char *result = fgets(dest, maxLen, stdin);
    if(result != NULL)
    {
        // Wipe out the newline character at the
        // end of the string:

        int len = strlen(result);
        if(len &gt; 0)
        {
            dest[len - 1] = 0;
        }
        return len;
    } 
<span epub:type="pagebreak" title="30" id="Page_30"/>    return -1; // If there was an error
}

int main(void)
{
    // Get the assembly language program's title:

    try
    {
        char *title = getTitle();
            
        printf("Calling %s:\n", title);
        asmMain();
        printf("%s terminated\n", title);
    }
    catch(...)
    {
        printf
        ( 
            "Exception occurred during program execution\n"
            "Abnormal program termination.\n"
        );
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-7">Listing 1-7</a>: Generic C++ code for calling assembly language programs</p>
<p>The <code/><code>try..catch</code> block catches any exceptions the assembly code generates, so you get some sort of indication if the program aborts abnormally.</p>
<p><a href="#listing1-8" id="listinganchor1-8">Listing 1-8</a> provides assembly code that demonstrates several new concepts, foremost returning a function result (to the C++ program). The assembly language function <code>getTitle()</code> returns a pointer to a string that the calling C++ code will print as the title of the program. In the <code>.data</code> section, you’ll see a string variable <code>titleStr</code> that is initialized with the name of this assembly code (<code><a href="#listing1-8">Listing 1-8</a></code>). The <code>getTitle()</code> function loads the address of that string into RAX and returns this string pointer to the C++ code (<a href="#listing1-7">Listing 1-7</a>) that prints the title before and after running the assembly code.</p>
<p>This program also demonstrates reading a line of text from the user. The assembly code calls the <code>readLine()</code> function appearing in the C++ code. The <code>readLine()</code> function expects two parameters: the address of a character buffer (C string) and a maximum buffer length. The code in <a href="#listing1-8">Listing 1-8</a> passes the address of the character buffer to the <code>readLine()</code> function in RCX and the maximum buffer size in RDX. The maximum buffer length must include room for two extra characters: a newline character (line feed) and a zero-terminating byte.</p>
<p>Finally, <a href="#listing1-8">Listing 1-8</a> demonstrates declaring a character buffer (that is, an array of characters). In the <code>.data</code> section, you will find the following declaration:</p>
<pre><code>input byte maxLen dup (?)</code></pre>
<p><span epub:type="pagebreak" title="31" id="Page_31"/>The <code>maxLen </code><code/><code>dup (?)</code> operand tells MASM to duplicate the <code>(?)</code> (that is, an uninitialized byte) <code>maxLen</code> times. <code>maxLen</code> is a constant set to <code>256</code> by an equate directive (<code>=</code>) at the beginning of the source file. (For more details, see <span class="xref" itemid="xref_target_“Declaring Arrays in Your MASM Programs” in Chapter 4">“Declaring Arrays in Your MASM Programs” in Chapter 4</span>.)</p>
<pre><code>; Listing 1-8
 
; An assembly language program that demonstrates returning
; a function result to a C++ program.

        option  casemap:none

nl      =       10  ; ASCII code for newline
maxLen  =       256 ; Maximum string size + 1

         .data  
titleStr byte    'Listing 1-8', 0
prompt   byte    'Enter a string: ', 0
fmtStr   byte    "User entered: '%s'", nl, 0

; "input" is a buffer having "maxLen" bytes. This program
; will read a user string into this buffer.
 
; The "maxLen dup (?)" operand tells MASM to make "maxLen"
; duplicate copies of a byte, each of which is uninitialized.

input    byte   maxLen dup (?)

        .code

        externdef   printf:proc
        externdef   readLine:proc

; The C++ function calling this assembly language module
; expects a function named "getTitle" that returns a pointer
; to a string as the function result. This is that function:

         public getTitle
getTitle proc

; Load address of "titleStr" into the RAX register (RAX holds
; the function return result) and return back to the caller:

         lea rax, titleStr
         ret
getTitle endp

; Here is the "asmMain" function.

        public  asmMain
asmMain proc
        sub     rsp, 56
                
<span epub:type="pagebreak" title="32" id="Page_32"/>; Call the readLine function (written in C++) to read a line
; of text from the console.
 
; int readLine(char *dest, int maxLen)
 
; Pass a pointer to the destination buffer in the RCX register.
; Pass the maximum buffer size (max chars + 1) in EDX.
; This function ignores the readLine return result.
; Prompt the user to enter a string:

        lea     rcx, prompt
        call    printf

; Ensure the input string is zero-terminated (in the event
; there is an error):

        mov     input, 0

; Read a line of text from the user:

        lea     rcx, input
        mov     rdx, maxLen
        call    readLine
        
; Print the string input by the user by calling printf():

        lea     rcx, fmtStr
        lea     rdx, input
        call    printf

        add     rsp, 56
        ret     ; Returns to caller
        
asmMain endp
        end</code></pre>
<p class="CodeListingCaption"><a id="listing1-8">Listing 1-8</a>: Assembly language program that returns a function result</p>
<p>To compile and run the programs in Listings 1-7 and 1-8, use statements such as the following:</p>
<pre><code>C:\&gt;<b>ml64 /c listing1-8.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing1-8.asm

C:\&gt;<b>cl /EHa /Felisting1-8.exe c.cpp listing1-8.obj</b>
Microsoft (R) C/C++ Optimizing Compiler Version 19.15.26730 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

c.cpp
Microsoft (R) Incremental Linker Version 14.15.26730.0
<span epub:type="pagebreak" title="33" id="Page_33"/>Copyright (C) Microsoft Corporation.  All rights reserved.

/out:listing1-8.exe
c.obj
listing1-8.obj

C:\&gt; <b>listing1-8</b>
Calling Listing 1-8:
Enter a string: This is a test
User entered: 'This is a test'
Listing 1-8 terminated</code></pre>
<p>The <code>/Felisting1-8.exe</code> command line option tells MSVC to name the executable file <em>listing1-8.exe</em>. Without the <code>/Fe</code> option, MSVC would name the resulting executable file <em>c.exe</em> (after <em>c.cpp</em>, the generic example C++ file from <a href="#listing1-7">Listing 1-7</a>). </p>
<h2 id="h1-501089c01-0015">	1.15	Automating the Build Process</h2>
<p class="BodyFirst">At this point, you’re probably thinking it’s a bit tiresome to type all these (long) command lines every time you want to compile and run your programs. This is especially true if you start adding more command line options to the <code>ml64</code> and <code>cl</code> commands. Consider the following two commands:</p>
<pre><code>ml64 /nologo /c /Zi /Cp listing1-8.asm
cl /nologo /O2 /Zi /utf-8 /EHa /Felisting1-8.exe c.cpp listing1-8.obj
listing1-8</code></pre>
<p>The <code>/Zi</code> option tells MASM and MSVC to compile extra debug information into the code. The <code>/nologo</code> option tells MASM and MSVC to skip printing copyright and version information during compilation. The MASM <code>/Cp</code> option tells MASM to make compilations case-insensitive (so you don’t need the <code>options casemap:none</code> directive in your assembly source file). The <code>/O2</code> option tells MSVC to optimize the machine code the compiler produces. The <code>/utf-8</code> option tells MSVC to use UTF-8 Unicode encoding (which is ASCII-compatible) rather than UTF-16 encoding (or other character encoding). The <code>/EHa</code> option tells MSVC to handle processor-generated exceptions (such as memory access faults—a common exception in assembly language programs). As noted earlier, the <code>/Fe</code> option specifies the executable output filename. Typing all these command line options every time you want to build a sample program is going to be a lot of work.</p>
<p>The easy solution is to create a batch file that automates this process. You could, for example, type the three previous command lines into a text file, name it<code> </code><em>l8.bat</em>, and then simply type <code>l8</code> at the command line to automatically execute those three commands. That saves a lot of typing and is much quicker (and less error-prone) than typing these three commands every time you want to compile and run the program.</p>
<p><span epub:type="pagebreak" title="34" id="Page_34"/>The only drawback to putting those three commands into a batch file is that the batch file is specific to the <em>listing1-8.asm</em> source file, and you would have to create a new batch file to compile other programs. Fortunately, it is easy to create a batch file that will work with any single assembly source file that compiles and links with the generic <em>c.cpp</em> program. Consider the following <em>build.bat</em> batch file:</p>
<pre><code>echo off
ml64 /nologo /c /Zi /Cp %1.asm
cl /nologo /O2 /Zi /utf-8 /EHa /Fe%1.exe c.cpp %1.obj</code></pre>
<p>The <code>%1</code> item in these commands tells the Windows command line processor to substitute a command line parameter (specifically, command line parameter number 1) in place of the <code>%1</code>. If you type the following from the command line</p>
<pre><code>build listing1-8</code></pre>
<p class="BodyContinued">then Windows executes the following three commands:</p>
<pre><code>echo off
ml64 /nologo /c /Zi /Cp listing1-8.asm
cl /nologo /O2 /Zi /utf-8 /EHa /Felisting1-8.exe c.cpp listing1-8.obj</code></pre>
<p>With this <em>build.bat</em> file, you can compile several projects simply by specifying the assembly language source file name (without the <em>.asm</em> suffix) on the build command line.</p>
<p>The <em>build.bat</em> file does not run the program after compiling and linking it. You could add this capability to the batch file by appending a single line containing <code>%1</code> to the end of the file. However, that would always attempt to run the program, even if the compilation failed because of errors in the C++ or assembly language source files. For that reason, it’s probably better to run the program manually after building it with the batch file, as follows:</p>
<pre><code>C:\&gt;<b>build listing1-8</b>
C:\&gt;<b>listing1-8</b></code></pre>
<p>A little extra typing, to be sure, but safer in the long run.</p>
<p>Microsoft provides another useful tool for controlling compilations from the command line: <em>makefiles</em>. They are a better solution than batch files because makefiles allow you to conditionally control steps in the process (such as running the executable) based on the success of earlier steps. However, using Microsoft’s make program (<em>nmake.exe</em>) is beyond the scope of this chapter. It’s a good tool to learn (and <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span> will teach you the basics). However, batch files are sufficient for the simple projects appearing throughout most of this book and require little extra knowledge or training to use. If you are interested in learning more about makefiles, see <span class="xref" itemid="xref_target_Chapter 15 ">Chapter 15 </span>or <span class="xref" itemid="xref_target_“For More Information” on page 39">“For More Information” on page 39</span><span class="xref" itemid="xref_target_"/>.</p>
<h2 id="h1-501089c01-0016"><span epub:type="pagebreak" title="35" id="Page_35"/>	1.16	Microsoft ABI Notes</h2>
<p class="BodyFirst">As noted earlier (see <span class="xref" itemid="xref_target_“Returning Function Results in Assembly Language” on page 27">“Returning Function Results in Assembly Language” on page 27</span>), the Microsoft ABI is a contract between modules in a program to ensure compatibility (between modules, especially modules written in different programming languages).<sup class="FootnoteReference"><a id="c01-footnoteref-10" href="#c01-footnote-10">10</a></sup> In this book, the C++ programs will be calling assembly language code, and the assembly modules will be calling C++ code, so it’s important that the assembly language code adhere to the Microsoft ABI.</p>
<p>Even if you were to write stand-alone assembly language code, it would still be calling C++ code, as it would (undoubtedly) need to make Windows <em/><em>application programming interface</em> <em>(API)</em> calls. The Windows API functions are all written in C++, so calls to Windows must respect the Windows ABI.</p>
<p>Because following the Microsoft ABI is so important, each chapter in this book (if appropriate) includes a section at the end discussing those components of the Microsoft ABI that the chapter introduces or heavily uses. This section covers several concepts from the Microsoft ABI: variable size, register usage, and stack alignment.</p>
<h3 id="h2-501089c01-0008">1.16.1	Variable Size</h3>
<p class="BodyFirst">Although dealing with different data types in assembly language is completely up to the assembly language programmer (and the choice of machine instructions to use on that data), it’s crucial to maintain the size of the data (in bytes) between the C++ and assembly language programs. <a href="#table1-6" id="tableanchor1-6">Table 1-6</a> lists several common C++ data types and the corresponding assembly language types (that maintain the size information).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-6">Table 1-6</a>: C++ and Assembly Language Types</p></figcaption>
<table id="table-501089c01-0006" border="1">
<thead>
<tr>
<td><b>C++ type</b></td>
<td><b>Size (in bytes)</b></td>
<td><b>Assembly language type</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>char</code></td>
<td>1</td>
<td><code>sbyte</code></td>
</tr>
<tr>
<td><code>signed char</code></td>
<td>1</td>
<td><code>sbyte</code></td>
</tr>
<tr>
<td><code>unsigned char</code></td>
<td>1</td>
<td><code>byte</code></td>
</tr>
<tr>
<td><code>short int</code></td>
<td>2</td>
<td><code>sword</code></td>
</tr>
<tr>
<td><code>short unsigned</code></td>
<td>2</td>
<td><code>word</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td><code>sdword</code></td>
</tr>
<tr>
<td><code>unsigned (unsigned int)</code></td>
<td>4</td>
<td><code>dword</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td>4</td>
<td><code>sdword</code></td>
</tr>
<tr>
<td><code>long int</code></td>
<td>4</td>
<td><code>sdword</code></td>
</tr>
<tr>
<td><code>long unsigned</code></td>
<td>4</td>
<td><code>dword</code></td>
</tr>
<tr>
<td><code>long int</code></td>
<td>8</td>
<td><code>sqword</code></td>
</tr>
<tr>
<td><code>long unsigned</code></td>
<td>8</td>
<td><code>qword</code></td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="36" id="Page_36"/>__int64</code></td>
<td>8</td>
<td><code>sqword</code></td>
</tr>
<tr>
<td><code>unsigned __int64</code></td>
<td>8</td>
<td><code>qword</code></td>
</tr>
<tr>
<td><code>Float</code></td>
<td>4</td>
<td><code>real4</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td><code>real8</code></td>
</tr>
<tr>
<td><code>pointer</code> (for example, <code>void *</code>)</td>
<td>8</td>
<td><code>qword</code></td>
</tr>
</tbody>
</table>
</figure>
<p>Although MASM provides signed type declarations (<code>sbyte</code>, <code>sword</code>, <code>sdword</code>, and <code>sqword</code>), assembly language instructions do not differentiate between the unsigned and signed variants. You could process a signed integer (<code>sdword</code>) by using unsigned instruction sequences, and you could process an unsigned integer (<code>dword</code>) by using signed instruction sequences. In an assembly language source file, these different directives mainly serve as a documentation aid to help describe the programmer’s intentions.<sup class="FootnoteReference"><a id="c01-footnoteref-11" href="#c01-footnote-11">11</a></sup></p>
<p><a href="#listing1-9" id="listinganchor1-9">Listing 1-9</a> is a simple program that verifies the sizes of each of these C++ data types.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The <code>%2zd</code> format string displays <code>size_t</code> type values (the <code>sizeof</code> operator returns a value of type <code>size_t</code>). This quiets down the MSVC compiler (which generates warnings if you use only <code>%2d</code>). Most compilers are happy with <code>%2d</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<pre><code>// Listing 1-9
 
// A simple C++ program that demonstrates Microsoft C++ data
// type sizes:

#include &lt;stdio.h&gt;

int main(void)
{
        char                v1;
        unsigned char       v2;
        short               v3;
        short int           v4;
        short unsigned      v5;
        int                 v6;
        unsigned            v7;
        long                v8;
        long int            v9;
        long unsigned       v10;
<span epub:type="pagebreak" title="37" id="Page_37"/>        long long int       v11;
        long long unsigned  v12;
        __int64             v13;
        unsigned __int64    v14;
        float               v15;
        double              v16;
        void *              v17;

    printf
    (
        "Size of char:               %2zd\n"
        "Size of unsigned char:      %2zd\n"
        "Size of short:              %2zd\n"
        "Size of short int:          %2zd\n"
        "Size of short unsigned:     %2zd\n"
        "Size of int:                %2zd\n"
        "Size of unsigned:           %2zd\n"
        "Size of long:               %2zd\n"
        "Size of long int:           %2zd\n"
        "Size of long unsigned:      %2zd\n"
        "Size of long long int:      %2zd\n"
        "Size of long long unsigned: %2zd\n"
        "Size of __int64:            %2zd\n"
        "Size of unsigned __int64:   %2zd\n"
        "Size of float:              %2zd\n"
        "Size of double:             %2zd\n"
        "Size of pointer:            %2zd\n",
        sizeof v1,
        sizeof v2,
        sizeof v3,
        sizeof v4,
        sizeof v5,
        sizeof v6,
        sizeof v7,
        sizeof v8,
        sizeof v9,
        sizeof v10,
        sizeof v11,
        sizeof v12,
        sizeof v13,
        sizeof v14,
        sizeof v15,
        sizeof v16,
        sizeof v17
    );            
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-9">Listing 1-9</a>: Output sizes of common C++ data types</p>
<p>Here’s the build command and output from <a href="#listing1-9">Listing 1-9</a>:</p>
<pre><code>C:\&gt;<b>cl listing1-9.cpp</b>
Microsoft (R) C/C++ Optimizing Compiler Version 19.15.26730 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

<span epub:type="pagebreak" title="38" id="Page_38"/>listing1-9.cpp
Microsoft (R) Incremental Linker Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:listing1-9.exe
listing1-9.obj

C:\&gt;<b>listing1-9</b>
Size of char:                1
Size of unsigned char:       1
Size of short:               2
Size of short int:           2
Size of short unsigned:      2
Size of int:                 4
Size of unsigned:            4
Size of long:                4
Size of long int:            4
Size of long unsigned:       4
Size of long long int:       8
Size of long long unsigned:  8
Size of __int64:             8
Size of unsigned __int64:    8
Size of float:               4
Size of double:              8
Size of pointer:             8</code></pre>
<h3 id="h2-501089c01-0009">1.16.2	Register Usage</h3>
<p class="BodyFirst"><em/><em>Register usage</em> in an assembly language procedure (including the main assembly language function) is also subject to certain Microsoft ABI rules. Within a procedure, the Microsoft ABI has this to say about register usage):<sup class="FootnoteReference"><a id="c01-footnoteref-12" href="#c01-footnote-12">12</a></sup></p>
<ul>
<li>Code that calls a function can pass the first four (integer) arguments to the function (procedure) in the RCX, RDX, R8, and R9 registers, respectively. Programs pass the first four floating-point arguments in XMM0, XMM1, XMM2, and XMM3.</li>
<li>Registers RAX, RCX, RDX, R8, R9, R10, and R11 are <em>volatile</em>, which means that the function/procedure does not need to save the registers’ values across a function/procedure call.</li>
<li>XMM0/YMM0 through XMM5/YMM5 are also volatile. The function/procedure does not need to preserve these registers across a call.</li>
<li>RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are nonvolatile registers. A procedure/function must preserve these registers’ values across a call. If a procedure modifies one of these registers, it must save the register’s value before the first such modification and restore the register’s value from the saved location prior to returning from the function/procedure.</li>
<li><span epub:type="pagebreak" title="39" id="Page_39"/>XMM6 through XMM15 are nonvolatile. A function must preserve these registers across a function/procedure call (that is, when a procedure returns, these registers must contain the same values they had upon entry to that procedure).</li>
<li>Programs that use the x86-64’s floating-point coprocessor instructions must preserve the value of the floating-point control word across procedure calls. Such procedures should also leave the floating-point stack cleared. </li>
<li>Any procedure/function that uses the x86-64’s direction flag must leave that flag cleared upon return from the procedure/function.</li>
</ul>
<p>Microsoft C++ expects function return values to appear in one of two places. Integer (and other non-scalar) results come back in the RAX register (up to 64 bits). If the return type is smaller than 64 bits, the upper bits of the RAX register are undefined—for example, if a function returns a short int (16-bit) result, bits 16 to 63 in RAX may contain garbage. Microsoft’s ABI specifies that floating-point (and vector) function return results shall come back in the XMM0 register.</p>
<h3 id="h2-501089c01-0010">1.16.3	Stack Alignment</h3>
<p class="BodyFirst">Some “magic” instructions appear in various source listings throughout this chapter (they basically add or subtract values from the RSP register). These instructions have to do with stack alignment (as required by the Microsoft ABI). This chapter (and several that follow) supply these instructions in the code without further explanation. For more details on the purpose of these instructions, see <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<h2 id="h1-501089c01-0017">	1.17	For More Information</h2>
<p class="BodyFirst">This chapter has covered a lot of ground! While you still have a lot to learn about assembly language programming, this chapter, combined with your knowledge of HLLs (especially C/C++), provides just enough information to let you start writing real assembly language programs.</p>
<p>Although this chapter covered many topics, the three primary ones of interest are the x86-64 CPU architecture, the syntax for simple MASM programs, and interfacing with the C Standard Library.</p>
<p>The following resources provide more information about makefiles:</p>
<ul>
<li>Wikipedia: <a href="https://en.wikipedia.org/wiki/Make_(software)" class="LinkURL">https://en.wikipedia.org/wiki/Make_(software)</a></li>
<li><em>Managing Projects with GNU Make</em> by Robert Mecklenburg (O’Reilly Media, 2004)</li>
<li><em>The GNU Make Book, </em>First Edition, by John Graham-Cumming (No Starch Press, 2015)</li>
<li><em>Managing Projects with make</em>, by Andrew Oram and Steve Talbott (O’Reilly &amp; Associates, 1993)</li>
</ul>
<p><span epub:type="pagebreak" title="40" id="Page_40"/>For more information about MVSC:</p>
<ul>
<li><em/>Microsoft Visual Studio websites: <a href="https://visualstudio.microsoft.com/ " class="LinkURL">https://visualstudio.microsoft.com/ </a>and <a href="https://visualstudio.microsoft.com/vs/" class="LinkURL">https://visualstudio.microsoft.com/vs/</a></li>
<li><em/>Microsoft free developer offers: <a href="https://visualstudio.microsoft.com/free-developer-offers/" class="LinkURL">https://visualstudio.microsoft.com/free-developer-offers/</a></li>
</ul>
<p>For more information about MASM:</p>
<ul>
<li><em/>Microsoft, C++, C, and Assembler documentation: <a href="https://docs.microsoft.com/en-us/cpp/assembler/masm/masm-for-x64-ml64-exe?view=msvc-160/" class="LinkURL">https://docs.microsoft.com/en-us/cpp/assembler/masm/masm-for-x64-ml64-exe?view=msvc-160/</a></li>
<li><em/>Waite Group MASM Bible (covers MASM 6, which is 32-bit only, but still contains lots of useful information about MASM): <a href="https://www.amazon.com/Waite-Groups-Microsoft-Macro-Assembler/dp/0672301555/" class="LinkURL">https://www.amazon.com/Waite-Groups-Microsoft-Macro-Assembler/dp/0672301555/</a></li>
</ul>
<p>For more information about the ABI:</p>
<ul>
<li>The best documentation comes from Agner Fog’s website: <a href="https://www.agner.org/optimize/" class="LinkURL">https://www.agner.org/optimize/</a>.</li>
<li>Microsoft’s website also has information on Microsoft ABI calling conventions (see <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160" class="LinkURL">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160</a> or search for <em>Microsoft calling conventions</em>).</li>
</ul>
<h2 id="h1-501089c01-0018">	1.18	Test Yourself</h2>
<ol class="decimal">
<li value="1">What is the name of the Windows command line interpreter program?</li>
<li value="2">What is the name of the MASM executable program file?</li>
<li value="3">What are the names of the three main system buses?</li>
<li value="4">Which register(s) overlap the RAX register?</li>
<li value="5">Which register(s) overlap the RBX register?</li>
<li value="6">Which register(s) overlap the RSI register?</li>
<li value="7">Which register(s) overlap the R8 register?</li>
<li value="8">Which register holds the condition code bits?</li>
<li value="9">How many bytes are consumed by the following data types?
<ol class="lower-alpha">
<li value="1"><code>word</code></li>
<li value="2"><code>dword</code></li>
<li value="3"><code>oword</code></li>
<li value="4"><code>qword</code> with a <code>4 dup (?)</code> operand</li>
<li value="5"><code>real8</code> </li>
</ol></li>
<li value="10">If an 8-bit (byte) memory variable is the destination operand of a <code>mov</code> instruction, what source operands are legal?</li>
<li value="11">If a <code>mov</code> instruction’s destination operand is the EAX register, what is the largest constant (in bits) you can load into that register?</li>
<li value="12"><span epub:type="pagebreak" title="41" id="Page_41"/>For the <code>add</code> instruction, fill in the largest constant size (in bits) for all the destination operands specified in the following table:
<table id="tabular-501089c01-0007" border="1"><tbody>
<tr>
<td><b>Destination</b></td>
<td><b>Constant size</b></td>
</tr>
<tr>
<td>RAX</td>
<td/>
</tr>
<tr>
<td>EAX</td>
<td/>
</tr>
<tr>
<td>AX</td>
<td/>
</tr>
<tr>
<td>AL</td>
<td/>
</tr>
<tr>
<td>AH</td>
<td/>
</tr>
<tr>
<td>mem<sub>32</sub></td>
<td/>
</tr>
<tr>
<td>mem<sub>64</sub></td>
<td/>
</tr>
</tbody>
</table></li>
<li value="13">What is the destination (register) operand size for the <code>lea</code> instruction?</li>
<li value="14">What is the source (memory) operand size of the <code>lea</code> instruction?</li>
<li value="15">What is the name of the assembly language instruction you use to call a procedure or function?</li>
<li value="16">What is the name of the assembly language instruction you use to return from a procedure or function?</li>
<li value="17">What does <em>ABI</em> stand for?</li>
<li value="18">In the Windows ABI, where do you return the following function return results?
<ol class="lower-alpha">
<li value="1">8-bit byte values</li>
<li value="2">16-bit word values</li>
<li value="3">32-bit integer values</li>
<li value="4">64-bit integer values</li>
<li value="5">Floating-point values</li>
<li value="6">64-bit pointer values</li>
</ol></li>
<li value="19">Where do you pass the first parameter to a Microsoft ABI–compatible function?</li>
<li value="20">Where do you pass the second parameter to a Microsoft ABI–compatible function?</li>
<li value="21">Where do you pass the third parameter to a Microsoft ABI–compatible function?</li>
<li value="22">Where do you pass the fourth parameter to a Microsoft ABI–compatible function?</li>
<li value="23">What assembly language data type corresponds to a C/C++ <code>long int</code>?</li>
<li value="24">What assembly language data type corresponds to a C/C++ <code>long long unsigned</code>?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-1" href="#c01-footnoteref-1">1.</a></sup> Technically, the I/O privilege level (IOPL) is 2 bits, but these bits are not accessible from user-mode programs, so this book ignores this field.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-2" href="#c01-footnoteref-2">2.</a></sup> Application programs cannot modify the interrupt flag, but we’ll look at this flag in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>; hence the discussion of this flag here.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-3" href="#c01-footnoteref-3">3.</a></sup> Technically, the parity flag is also a condition code, but we will not use that flag in this text.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-4" href="#c01-footnoteref-4">4.</a></sup> The following discussion will use the 4GB address space of the older 32-bit x86-64 processors. A typical x86-64 processor running a modern 64-bit OS can access a maximum of 2<sup>48</sup> memory locations, or just over 256TB.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-5" href="#c01-footnoteref-5">5.</a></sup> Technically, MASM assigns offsets into the <span class="LiteralFootnote"><code>.data</code></span> section to variables. Windows converts these offsets to physical memory addresses when it loads the program into memory at runtime.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-6" href="#c01-footnoteref-6">6.</a></sup> Different programs may use a different set of 30 to 50 instructions, but few programs use more than 50 distinct instructions.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-7" href="#c01-footnoteref-7">7.</a></sup> Technically, <span class="LiteralFootnote"><code>mov</code></span> copies data from one location to another. It does not destroy the original data in the source operand. Perhaps a better name for this instruction would have been <span class="LiteralFootnote"><code>copy</code></span>. Alas, it’s too late to change it now.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-8" href="#c01-footnoteref-8">8.</a></sup> It is possible that you might actually want to do this, with the <span class="LiteralFootnote"><code>mov</code></span> instruction loading AL with the byte at location <span class="LiteralFootnote"><code>i8</code></span> and AH with the byte immediately following <span class="LiteralFootnote"><code>i8</code></span> in memory. If you really want to do this (admittedly crazy) operation, see <span class="xref" itemid="xref_target_“Type Coercion” in Chapter 4">“Type Coercion” in Chapter 4</span>.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-9" href="#c01-footnoteref-9">9.</a></sup>  MASM has two other directives, <span class="LiteralFootnote"><code>extrn</code></span> and <span class="LiteralFootnote"><code>extern</code></span>, that could also be used. This book uses the <span class="LiteralFootnote"><code>externdef</code></span> directive because it is the most general directive.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-10" href="#c01-footnoteref-10">10.</a></sup> Microsoft also refers to the ABI as the <em>X64 Calling Conventions</em> in its documentation.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-11" href="#c01-footnoteref-11">11.</a></sup> Earlier 32-bit versions of MASM included some high-level language control statements (for example, <span class="LiteralFootnote"><code>.if</code></span>, <span class="LiteralFootnote"><code>.else</code></span>, <span class="LiteralFootnote"><code>.endif</code></span>) that made use of the signed versus unsigned declarations. However, Microsoft no longer supports these high-level statements. As a result, MASM no longer differentiates signed versus unsigned declarations.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c01-footnote-12" href="#c01-footnoteref-12">12.</a></sup> For more details, see the Microsoft documentation at <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160/." class="LinkURL">https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160/.</a></p></aside>
</section>
</section>
</body></html>