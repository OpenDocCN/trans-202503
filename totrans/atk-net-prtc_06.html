<html><head></head><body>
<h2 class="h2a" id="ch06"><span epub:type="pagebreak" id="page_111"/><strong><span class="big">6</span></strong><br/><strong>APPLICATION REVERSE ENGINEERING</strong></h2>&#13;
<p class="noindent_first">If you can analyze an entire network protocol just by looking at the transmitted data, then your analysis is quite simple. But that’s not always possible with some protocols, especially those that use custom encryption or compression schemes. However, if you can get the executables for the client or server, you can use binary <em>reverse engineering (RE)</em> to determine how the protocol operates and search for vulnerabilities as well.</p>&#13;
<p class="indent">The two main kinds of reverse engineering are <em>static</em> and <em>dynamic</em>. Static reverse engineering is the process of disassembling a compiled executable into native machine code and using that code to understand how the executable works. Dynamic reverse engineering involves executing an application and then using tools, such as debuggers and function monitors, to inspect the application’s runtime operation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>In this chapter, I’ll walk you through the basics of taking apart executables to identify and understand the code areas responsible for network communication.</p>&#13;
<p class="indent">I’ll focus on the Windows platform first, because you’re more likely to find applications without source code on Windows than you are on Linux or macOS. Then, I’ll cover the differences between platforms in more detail and give you some tips and tricks for working on alternative platforms; however, most of the skills you’ll learn will be applicable on all platforms. As you read, keep in mind that it takes time to become good reverse engineer, and I can’t possibly cover the broad topic of reverse engineering in one chapter.</p>&#13;
<p class="indent">Before we delve into reverse engineering, I’ll discuss how developers create executable files and then provide some details about the omnipresent x86 computer architecture. Once you understand the basics of x86 architecture and how it represents instructions, you’ll know what to look for when you’re reverse engineering code.</p>&#13;
<p class="indent">Finally, I’ll explain some general operating system principles, including how the operating system implements networking functionality. Armed with this knowledge, you should be able to track down and analyze network applications.</p>&#13;
<p class="indent">Let’s start with background information on how programs execute on a modern operating system and examine the principles of compilers and interpreters.</p>&#13;
<h3 class="h3" id="ch00lev1sec136"><strong>Compilers, Interpreters, and Assemblers</strong></h3>&#13;
<p class="noindent">Most applications are written in a higher-level programming language, such as C/C++, C#, Java, or one of the many scripting languages. When an application is developed, the raw language is its <em>source code</em>. Unfortunately, computers don’t understand source code, so the high-level language must be converted into <em>machine code</em> (the native instructions the computer’s processor executes) by <em>interpreting</em> or <em>compiling</em> the source code.</p>&#13;
<p class="indent">The two common ways of developing and executing programs is by interpreting the original source code or by compiling a program to native code. The way a program executes determines how we reverse engineer it, so let’s look at these two distinct methods of execution to get a better idea of how they work.</p>&#13;
<h4 class="h4" id="ch00lev1sec137"><strong><em>Interpreted Languages</em></strong></h4>&#13;
<p class="noindent">Interpreted languages, such as Python and Ruby, are sometimes called <em>scripting languages</em>, because their applications are commonly run from short scripts written as text files. Interpreted languages are dynamic and speed up development time. But interpreters execute programs more slowly than code that has been converted to <em>machine code</em>, which the computer understands directly. To convert source code to a more native representation, the programming language can instead be compiled.</p>&#13;
<h4 class="h4" id="ch00lev1sec138"><span epub:type="pagebreak" id="page_113"/><strong><em>Compiled Languages</em></strong></h4>&#13;
<p class="noindent">Compiled programming languages use a <em>compiler</em> to parse the source code and generate machine code, typically by generating an intermediate language first. For native code generation, usually an <em>assembly language</em> specific to the CPU on which the application will run (such as 32- or 64-bit assembly) is used. The language is a human-readable and understandable form of the underlying processor’s instruction set. The assembly language is then converted to machine code using an <em>assembler</em>. For example, <a href="../Text/ch06.xhtml#ch6fig1">Figure 6-1</a> shows how a C compiler works.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig1"/><em>Figure 6-1: The C language compilation process</em></p>&#13;
<p class="indent">To reverse a native binary to the original source code, you need to reverse the compilation using a process called <em>decompilation</em>. Unfortunately, decompiling machine code is quite difficult, so reverse engineers typically reverse just the assembly process using a process called <em>disassembly</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec139"><strong><em>Static vs. Dynamic Linking</em></strong></h4>&#13;
<p class="noindent">With extremely simple programs, the compilation process might be all that is needed to produce a working executable. But in most applications, a lot of code is imported into the final executable from external libraries by <em>linking</em>—a process that uses a linker program after compilation. The linker takes the application-specific machine code generated by the compiler, along with any necessary external libraries used by the application, <span epub:type="pagebreak" id="page_114"/>and embeds everything in a final executable by statically linking any external libraries. This <em>static linking</em> process produces a single, self-contained executable that doesn’t depend on the original libraries.</p>&#13;
<p class="indent">Because certain processes might be handled in very different ways on different operating systems, static linking all code into one big binary might not be a good idea because the OS-specific implementation could change. For example, writing to a file on disk might have widely different operating system calls on Windows than it does on Linux. Therefore, compilers commonly link an executable to operating system–specific libraries by <em>dynamic linking</em>: instead of embedding the machine code in the final executable, the compiler stores only a reference to the dynamic library and the required function. The operating system must resolve the linked references when the application runs.</p>&#13;
<h3 class="h3" id="ch00lev1sec140"><strong>The x86 Architecture</strong></h3>&#13;
<p class="noindent">Before getting into the methods of reverse engineering, you’ll need some understanding of the basics of the x86 computer architecture. For a computer architecture that is over 30 years old, x86 is surprisingly persistent. It’s used in the majority of desktop and laptop computers available today. Although the PC has been the traditional home of the x86 architecture, it has found its way into Mac<sup><a id="ch06nt_01"/><a href="../Text/footnote.xhtml#ch06nt01">1</a></sup> computers, game consoles, and even smartphones.</p>&#13;
<p class="indent">The original x86 architecture was released by Intel in 1978 with the 8086 CPU. Over the years, Intel and other manufacturers (such as AMD) have improved its performance massively, moving from supporting 16-bit operations to 32-bit and now 64-bit operations. The modern architecture has barely anything in common with the original 8086, other than processor instructions and programming idioms. Because of its lengthy history, the x86 architecture is very complex. We’ll first look at how the x86 executes machine code, and then examine its CPU registers and the methods used to determine the order of execution.</p>&#13;
<h4 class="h4" id="ch00lev1sec141"><strong><em>The Instruction Set Architecture</em></strong></h4>&#13;
<p class="noindent">When discussing how a CPU executes machine code, it’s common to talk about the <em>instruction set architecture (ISA)</em>. The ISA defines how the machine code works and how it interacts with the CPU and the rest of the computer. A working knowledge of the ISA is crucial for effective reverse engineering.</p>&#13;
<p class="indent">The ISA defines the set of machine language instructions available to a program; each individual machine language instruction is represented by a <em>mnemonic instruction</em>. The mnemonics name each instruction and determine how its parameters, or <em>operands</em>, are represented. <a href="../Text/ch06.xhtml#ch6tab1">Table 6-1</a> lists the mnemonics of some of the most common x86 instructions. (I’ll cover many of these instructions in greater detail in the following sections.)</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_115"/><a id="ch6tab1"/><strong>Table 6-1:</strong> Common x86 Instruction Mnemonics</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Instruction</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>MOV</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">source</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Moves a value from <code><span class="codeitalic">source</code></span> to <code><span class="codeitalic">destination</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>ADD</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Adds an integer <code><span class="codeitalic">value</code></span> to the <code><span class="codeitalic">destination</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>SUB</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Subtracts an integer <code><span class="codeitalic">value</code></span> from a <code><span class="codeitalic">destination</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>CALL</code> <code><span class="codeitalic">address</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Calls the subroutine at the specified <code><span class="codeitalic">address</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>JMP</code> <code><span class="codeitalic">address</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Jumps unconditionally to the specified <code><span class="codeitalic">address</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>RET</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Returns from a previous subroutine</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>RETN</code> <code><span class="codeitalic">size</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Returns from a previous subroutine and then increments the stack by <code><span class="codeitalic">size</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>Jcc</code> <code><span class="codeitalic">address</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Jumps to the specified <code><span class="codeitalic">address</code></span> if the condition indicated by <code><span class="codeitalic">cc</code></span> is true</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>PUSH</code> <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Pushes a <code><span class="codeitalic">value</code></span> onto the current stack and decrements the stack pointer</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>POP</code> <code><span class="codeitalic">destination</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Pops the top of the stack into the <code><span class="codeitalic">destination</code></span> and increments the stack pointer</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>CMP</code> <code><span class="codeitalic">valuea</code></span><code>,</code> <code><span class="codeitalic">valueb</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Compares <code><span class="codeitalic">valuea</code></span> and <code><span class="codeitalic">valueb</code></span> and sets the appropriate flags</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>TEST</code> <code><span class="codeitalic">valuea</code></span><code>,</code> <code><span class="codeitalic">valueb</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Performs a bitwise AND on <code><span class="codeitalic">valuea</code></span> and <code><span class="codeitalic">valueb</code></span> and sets the appropriate flags</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>AND</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Performs a bitwise AND on the <code><span class="codeitalic">destination</code></span> with the <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>OR</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Performs a bitwise OR on the <code><span class="codeitalic">destination</code></span> with the <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>XOR</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Performs a bitwise Exclusive OR on the <code><span class="codeitalic">destination</code></span> with the <code><span class="codeitalic">value</code></span></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>SHL</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">N</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Shifts the <code><span class="codeitalic">destination</code></span> to the left by <code><span class="codeitalic">N</code></span> bits (with left being higher bits)</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>SHR</code> <code><span class="codeitalic">destination</code></span><code>,</code> <code><span class="codeitalic">N</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Shifts the <code><span class="codeitalic">destination</code></span> to the right by <code><span class="codeitalic">N</code></span> bits (with right being lower bits)</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>INC</code> <code><span class="codeitalic">destination</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Increments <code><span class="codeitalic">destination</code></span> by 1</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>DEC</code> <code><span class="codeitalic">destination</code></span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Decrements <code><span class="codeitalic">destination</code></span> by 1</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">These mnemonic instructions take one of three forms depending on how many operands the instruction takes. <a href="../Text/ch06.xhtml#ch6tab2">Table 6-2</a> shows the three different forms of operands.</p>&#13;
<p class="tabcap"><a id="ch6tab2"/><strong>Table 6-2:</strong> Intel Mnemonic Forms</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Number of operands</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Form</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Examples</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">NAME</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"><code>POP</code>, <code>RET</code></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">1</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">NAME input</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"><code>PUSH 1</code>; <code>CALL func</code></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">2</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">NAME output, input</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table"><code>MOV EAX, EBX</code>; <code>ADD EDI, 1</code></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>The two common ways to represent x86 instructions in assembly are <em>Intel</em> and <em>AT&amp;T syntax</em>. Intel syntax, originally developed by the Intel Corporation, is the syntax I use throughout this chapter. AT&amp;T syntax is used in many development tools on Unix-like systems. The syntaxes differ in a few ways, such as the order in which operands are given. For example, the instruction to add 1 to the value stored in the EAX register would look like this in Intel syntax: <code>ADD EAX, 1</code> and like this in AT&amp;T Syntax: <code>addl $1, %eax</code>.</p>&#13;
<h4 class="h4" id="ch00lev1sec142"><strong><em>CPU Registers</em></strong></h4>&#13;
<p class="noindent">The CPU has a number of registers for very fast, temporary storage of the current state of execution. In x86, each register is referred to by a two- or three-character label. <a href="../Text/ch06.xhtml#ch6fig2">Figure 6-2</a> shows the main registers for a 32-bit x86 processor. It’s essential to understand the many types of registers the processor supports because each serves different purposes and is necessary for understanding how the instructions operate.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig2"/><em>Figure 6-2: The main 32-bit x86 registers</em></p>&#13;
<p class="indent">The x86’s registers are split into four main categories: general purpose, memory index, control, and selector.</p>&#13;
<h5 class="h5" id="ch00lev1sec143"><strong>General Purpose Registers</strong></h5>&#13;
<p class="noindent">The <em>general purpose registers</em> (EAX, EBX, ECX, and EDX in <a href="../Text/ch06.xhtml#ch6fig2">Figure 6-2</a>) are temporary stores for nonspecific values of computation, such as the results of addition or subtraction. The <em>general purpose registers</em> are 32 bits in size, although instructions can access them in 16- and 8-bit versions using a simple naming convention: for example, a 16-bit version of the EAX register is accessed as AX, and the 8-bit versions are AH and AL. <a href="../Text/ch06.xhtml#ch6fig3">Figure 6-3</a> shows the organization of the EAX register.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_117"/><img alt="image" src="../Images/f06-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig3"/><em>Figure 6-3: EAX general purpose register with small register components</em></p>&#13;
<h5 class="h5" id="ch00lev1sec144"><strong>Memory Index Registers</strong></h5>&#13;
<p class="noindent">The <em>memory index registers</em> (ESI, EDI, ESP, EBP, EIP) are mostly general purpose except for the ESP and EIP registers. The ESP register is used by the PUSH and POP instructions, as well as during subroutine calls to indicate the current memory location of the base of a stack.</p>&#13;
<p class="indent">Although you can utilize the ESP register for purposes other than indexing into the stack, it’s usually unwise to do so because it might cause memory corruption or unexpected behavior. The reason is that some instructions implicitly rely on the value of the register. On the other hand, the EIP register <em>cannot</em> be directly accessed as a general purpose register because it indicates the next address in memory where an instruction will be read from.</p>&#13;
<p class="indent">The only way to change the value of the EIP register is by using a control instruction, such as <code>CALL</code>, <code>JMP</code>, or <code>RET</code>. For this discussion, the important <em>control register</em> is EFLAGS. EFLAGS contains a variety of Boolean flags that indicate the results of instruction execution, such as whether the last operation resulted in the value 0. These Boolean flags implement conditional branches on the x86 processor. For example, if you subtract two values and the result is 0, the Zero flag in the EFLAGS register will be set to 1, and flags that do not apply will be set to 0.</p>&#13;
<p class="indent">The EFLAGS register also contains important system flags, such as whether interrupts are enabled. Not all instructions affect the value of EFLAGS. <a href="../Text/ch06.xhtml#ch6tab3">Table 6-3</a> lists the most important flag values, including the flag’s bit position, its common name, and a brief description.</p>&#13;
<p class="tabcap"><a id="ch6tab3"/><strong>Table 6-3:</strong> Important EFLAGS Status Flags</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Bit</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Name</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">0</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Carry flag</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Indicates whether a carry bit was generated from the last operation</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">2</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Parity flag</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">The parity of the least-significant byte of the last operation</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">6</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Zero flag</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Indicates whether the last operation has zero as its result; used in comparison operations</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">7</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Sign flag</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Indicates the sign of the last operation; effectively, the most-significant bit of the result</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">11</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Overflow flag</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Indicates whether the last operation overflowed</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch00lev1sec145"><span epub:type="pagebreak" id="page_118"/><strong>Selector Registers</strong></h5>&#13;
<p class="noindent">The <em>selector registers</em> (CS, DS, ES, FS, GS, SS) address memory locations by indicating a specific block of memory into which you can read or write. The real memory address used in reading or writing the value is looked up in an internal CPU table.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Selector registers are usually only used in operating system–specific operations. For example, on Windows, the FS register is used to access memory allocated to store the current thread’s control information.</em></p>&#13;
</div>&#13;
<p class="indent">Memory is accessed using little endian byte order. Recall from <a href="../Text/ch03.xhtml#ch03">Chapter 3</a> that little endian order means the least-significant byte is stored at the lowest memory address.</p>&#13;
<p class="indent">Another important feature of the x86 architecture is that it doesn’t require its memory operations to be aligned. All reads and writes to main memory on an <em>aligned</em> processor architecture must be aligned to the size of the operation. For example, if you want to read a 32-bit value, you would have to read from a memory address that is a multiple of 4. On aligned architectures, such as SPARC, reading an unaligned address would generate an error. Conversely, the x86 architecture permits you to read from or write to any memory address regardless of alignment.</p>&#13;
<p class="indent">Unlike architectures such as ARM, which use specialized instructions to load and store values between the CPU registers and main memory, many of the x86 instructions can take memory addresses as operands. In fact, the x86 supports a complex memory-addressing format for its instructions: each memory address reference can contain a base register, an index register, a multiplier for the index (between 1 and 8), or a 32-bit offset. For example, the following MOV instruction combines all four of these referencing options to determine which memory address contains the value to be copied into the EAX register:</p>&#13;
<pre>MOV EAX, [ESI + EDI * 8 + 0x50]   ; Read 32-bit value from memory address</pre>&#13;
<p class="indent">When a complex address reference like this is used in an instruction, it’s common to see it enclosed in square brackets.</p>&#13;
<h4 class="h4" id="ch00lev1sec146"><strong><em>Program Flow</em></strong></h4>&#13;
<p class="noindent"><em>Program flow</em>, or <em>control flow</em>, is how a program determines which instructions to execute. The x86 has three main types of program flow instructions: <em>subroutine calling</em>, <em>conditional branches</em>, and <em>unconditional branches</em>. Subroutine calling redirects the flow of the program to a <em>subroutine</em>—a specified sequence of instructions. This is achieved with the <code>CALL</code> instruction, which changes the EIP register to the location of the subroutine. <code>CALL</code> places the memory address of the next instruction onto the current stack, which tells the program flow where to return after it has performed its subroutine task. The return is performed using the <code>RET</code> instruction, which changes the EIP register to the top address in the stack (the one <code>CALL</code> put there).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_119"/>Conditional branches allow the code to make decisions based on prior operations. For example, the <code>CMP</code> instruction compares the values of two operands (perhaps two registers) and calculates the appropriate values for the EFLAGS register. Under the hood, the <code>CMP</code> instruction does this by subtracting one value from the other, setting the EFLAGS register as appropriate, and then discarding the result. The <code>TEST</code> instruction does the same except it performs an AND operation instead of a subtraction.</p>&#13;
<p class="indent">After the EFLAGS value has been calculated, a conditional branch can be executed; the address it jumps to depends on the state of EFLAGS. For example, the <code>JZ</code> instruction will conditionally jump if the Zero flag is set (which would happen if, for instance, the <code>CMP</code> instruction compared two values that were equal); otherwise, the instruction is a no-operation. Keep in mind that the EFLAGS register can also be set by arithmetic and other instructions. For example, the <code>SHL</code> instruction shifts the value of a destination by a certain number of bits from low to high.</p>&#13;
<p class="indent">Unconditional branching program flow is implemented through the <code>JMP</code> instruction, which just jumps unconditionally to a destination address. There’s not much more to be said about unconditional branching.</p>&#13;
<h3 class="h3" id="ch00lev1sec147"><strong>Operating System Basics</strong></h3>&#13;
<p class="noindent">Understanding a computer’s architecture is important for both static and dynamic reverse engineering. Without this knowledge, it’s difficult to ever understand what a sequence of instructions does. But architecture is only part of the story: without the operating system handling the computer’s hardware and processes, the instructions wouldn’t be very useful. Here I’ll explain some of the basics of how an operating system works, which will help you understand the processes of reverse engineering.</p>&#13;
<h4 class="h4" id="ch00lev1sec148"><strong><em>Executable File Formats</em></strong></h4>&#13;
<p class="noindent">Executable file formats define how executable files are stored on disk. Operating systems need to specify the executables they support so they can load and run programs. Unlike earlier operating systems, such as MS-DOS, which had no restrictions on what file formats would execute (when run, files containing instructions would load directly into memory), modern operating systems have many more requirements that necessitate more complex formats.</p>&#13;
<p class="indent">Some requirements of a modern executable format include:</p>&#13;
<p class="bullt">• Memory allocation for executable instructions and data</p>&#13;
<p class="bull">• Support for dynamic linking of external libraries</p>&#13;
<p class="bull">• Support for cryptographic signatures to validate the source of the executable</p>&#13;
<p class="bull">• Maintenance of debug information to link executable code to the original source code for debugging purposes</p>&#13;
<p class="bullb"><span epub:type="pagebreak" id="page_120"/>• A reference to the address in the executable file where code begins executing, commonly called the <em>start address</em> (necessary because the program’s start address might not be the first instruction in the executable file)</p>&#13;
<p class="indent">Windows uses the Portable Executable (PE) format for all executables and dynamic libraries. Executables typically use the <em>.exe</em> extension, and dynamic libraries use the <em>.dll</em> extension. Windows doesn’t actually need these extensions for a new process to work correctly; they are used just for convenience.</p>&#13;
<p class="indent">Most Unix-like systems, including Linux and Solaris, use the Executable Linking Format (ELF) as their primary executable format. The major exception is macOS, which uses the Mach-O format.</p>&#13;
<h4 class="h4" id="ch00lev1sec149"><strong><em>Sections</em></strong></h4>&#13;
<p class="noindent">Memory <em>sections</em> are probably the most important information stored in an executable. All nontrivial executables will have at least three sections: the code section, which contains the native machine code for the executable; the data section, which contains initialized data that can be read and written during execution; and a special section to contain uninitialized data. Each section has a name that identifies the data it contains. The code section is usually called <em>text</em>, the data section is called <em>data</em>, and the uninitialized data is called <em>bss</em>.</p>&#13;
<p class="indent">Every section contains four basic pieces of information:</p>&#13;
<p class="bullt">• A text name</p>&#13;
<p class="bull">• A size and location of the data for the section contained in the executable file</p>&#13;
<p class="bull">• The size and address in memory where the data should be loaded</p>&#13;
<p class="bullb">• Memory protection flags, which indicate whether the section can be written or executed when loaded into memory</p>&#13;
<h4 class="h4" id="ch00lev1sec150"><strong><em>Processes and Threads</em></strong></h4>&#13;
<p class="noindent">An operating system must be able to run multiple instances of an executable concurrently without them conflicting. To do so, operating systems define a <em>process</em>, which acts as a container for an instance of a running executable. A process stores all the private memory the instance needs to operate, isolating it from other instances of the same executable. The process is also a security boundary, because it runs under a particular user of the operating system and security decisions can be made based on this identity.</p>&#13;
<p class="indent">Operating systems also define a <em>thread</em> of execution, which allows the operating system to rapidly switch between multiple processes, making it seem to the user that they’re all running at the same time. This is called <em>multitasking</em>. To switch between processes, the operating system must <span epub:type="pagebreak" id="page_121"/>interrupt what the CPU is doing, store the current process’s state, and restore an alternate process’s state. When the CPU resumes, it is running another process.</p>&#13;
<p class="indent">A thread defines the current state of execution. It has its own block of memory for a stack and somewhere to store its state when the operating system stops the thread. A process will usually have at least one thread, and the limit on the number of threads in the process is typically controlled by the computer’s resources.</p>&#13;
<p class="indent">To create a new process from an executable file, the operating system first creates an empty process with its own allocated memory space. Then the operating system loads the main executable into the process’s memory space, allocating memory based on the executable’s section table. Next, a new thread is created, which is called the <em>main thread</em>.</p>&#13;
<p class="indent">The dynamic linking program is responsible for linking in the main executable’s system libraries before jumping back to the original start address. When the operating system launches the main thread, the process creation is complete.</p>&#13;
<h4 class="h4" id="ch00lev1sec151"><strong><em>Operating System Networking Interface</em></strong></h4>&#13;
<p class="noindent">The operating system must manage a computer’s networking hardware so it can be shared between all running applications. The hardware knows very little about higher-level protocols, such as TCP/IP,<sup><a id="ch06nt_02"/><a href="../Text/footnote.xhtml#ch06nt02">2</a></sup> so the operating system must provide implementations of these higher-level protocols.</p>&#13;
<p class="indent">The operating system also needs to provide a way for applications to interface with the network. The most common network API is the <em>Berkeley sockets model</em>, originally developed at the University of California, Berkeley in the 1970s for BSD. All Unix-like systems have built-in support for Berkeley sockets. On Windows, the <em>Winsock</em> library provides a very similar programming interface. The Berkeley sockets model is so prevalent that you’ll almost certainly encounter it on a wide range of platforms.</p>&#13;
<h5 class="h5" id="ch00lev1sec152"><strong>Creating a Simple TCP Client Connection to a Server</strong></h5>&#13;
<p class="noindent">To get a better sense of how the sockets API works, <a href="../Text/ch06.xhtml#ch6list1">Listing 6-1</a> shows how to create a simple TCP client connection to a remote server.</p>&#13;
<pre>   int port = 12345;<br/>   const char* ip = "1.2.3.4";<br/>   sockaddr_in addr = {0};<br/><br/><span class="ent">➊</span> int s = socket(AF_INET, SOCK_STREAM, 0);<br/><br/>   addr.sin_family = PF_INET;<br/><span class="ent">➋</span> addr.sin_port = htons(port);<br/><span class="ent">➌</span> inet_pton(AF_INET, ip, &amp;addr.sin_addr);<br/><span epub:type="pagebreak" id="page_122"/><span class="ent">➍</span> if(connect(s, (sockaddr*) &amp;addr, sizeof(addr)) == 0)<br/>   {<br/>       char buf[1024];<br/>       <span class="ent">➎</span> int len = recv(s, buf, sizeof(buf), 0);<br/><br/>       <span class="ent">➏</span> send(s, buf, len, 0);<br/>   }<br/><br/>   close(s);</pre>&#13;
<p class="listing"><a id="ch6list1"/><em>Listing 6-1: A simple TCP network client</em></p>&#13;
<p class="indent">The first API call <span class="ent">➊</span> creates a new socket. The <code>AF_INET</code> parameter indicates we want to use the IPv4 protocol. (To use IPv6 instead, we would write <code>AF_INET6</code>). The second parameter <code>SOCK_STREAM</code> indicates that we want to use a streaming connection, which for the internet means TCP. To create a UDP socket, we would write <code>SOCK_DGRAM</code> (for <em>datagram socket</em>).</p>&#13;
<p class="indent">Next, we construct a destination address with <code>addr</code>, an instance of the system-defined <code>sockaddr_in</code> structure. We set up the address structure with the protocol type, the TCP port, and the TCP IP address. The call to <code>inet_pton</code> <span class="ent">➌</span> converts the string representation of the IP address in <code>ip</code> to a 32-bit integer.</p>&#13;
<p class="indent">Note that when setting the port, the <code>htons</code> function is used <span class="ent">➋</span> to convert the value from host-byte-order (which for x86 is little endian) to network-byte-order (always big endian). This applies to the IP address as well. In this case, the IP address 1.2.3.4 will become the integer 0x01020304 when stored in big endian format.</p>&#13;
<p class="indent">The final step is to issue the call to connect to the destination address <span class="ent">➍</span>. This is the main point of failure, because at this point the operating system has to make an outbound call to the destination address to see whether anything is listening. When the new socket connection is established, the program can read and write data to the socket as if it were a file via the <code>recv</code> <span class="ent">➎</span> and <code>send</code> <span class="ent">➏</span> system calls. (On Unix-like systems, you can also use the general <code>read</code> and <code>write</code> calls, but not on Windows.)</p>&#13;
<h5 class="h5" id="ch00lev1sec153"><strong>Creating a Client Connection to a TCP Server</strong></h5>&#13;
<p class="noindent"><a href="../Text/ch06.xhtml#ch6list2">Listing 6-2</a> shows a snippet of the other side of the network connection, a very simple TCP socket server.</p>&#13;
<pre>   sockaddr_in bind_addr = {0};<br/><br/>   int s = socket(AF_INET, SOCK_STREAM, 0);<br/><br/>   bind_addr.sin_family = AF_INET;<br/>   bind_addr.sin_port = htons(12345);<br/><span class="ent">➊</span> inet_pton("0.0.0.0", &amp;bind_addr.sin_addr);<br/><br/><span class="ent">➋</span> bind(s, (sockaddr*)&amp;bind_addr, sizeof(bind_addr));<br/><span class="ent">➌</span> listen(s, 10);<br/><span epub:type="pagebreak" id="page_123"/><br/>   sockaddr_in client_addr;<br/>   int socksize = sizeof(client_addr);<br/><span class="ent">➍</span> int newsock = accept(s, (sockaddr*)&amp;client_addr, &amp;socksize);<br/><br/>   // Do something with the new socket</pre>&#13;
<p class="listing"><a id="ch6list2"/><em>Listing 6-2: A simple TCP socket server</em></p>&#13;
<p class="indent">The first important step when connecting to a TCP socket server is to bind the socket to an address on the local network interface, as shown at <span class="ent">➊</span> and <span class="ent">➋</span>. This is effectively the opposite of the client case in <a href="../Text/ch06.xhtml#ch6list1">Listing 6-1</a> because <code>inet_pton()</code> <span class="ent">➊</span> just converts a string IP address to its binary form. The socket is bound to all network addresses, as signified by <code>"0.0.0.0"</code>, although this could instead be a specific address on port 12345.</p>&#13;
<p class="indent">Then, the socket is bound to that local address <span class="ent">➋</span>. By binding to all interfaces, we ensure the server socket will be accessible from outside the current system, such as over the internet, assuming no firewall is in the way.</p>&#13;
<p class="indent">Finally, the listing asks the network interface to listen for new incoming connections <span class="ent">➌</span> and calls <code>accept</code> <span class="ent">➍</span>, which returns the next new connection. As with the client, this new socket can be read and written to using the <code>recv</code> and <code>send</code> calls.</p>&#13;
<p class="indent">When you encounter native applications that use the operating system network interface, you’ll have to track down all these function calls in the executable code. Your knowledge of how programs are written at the C programming language level will prove valuable when you’re looking at your reversed code in a disassembler.</p>&#13;
<h4 class="h4" id="ch00lev1sec154"><strong><em>Application Binary Interface</em></strong></h4>&#13;
<p class="noindent">The <em>application binary interface (ABI)</em> is an interface defined by the operating system to describe the conventions of how an application calls an API function. Most programming languages and operating systems pass parameters left to right, meaning that the leftmost parameter in the original source code is placed at the lowest stack address. If the parameters are built by pushing them to a stack, the last parameter is pushed first.</p>&#13;
<p class="indent">Another important consideration is how the return value is provided to the function’s caller when the API call is complete. In the x86 architecture, as long as the value is less than or equal to 32 bits, it’s passed back in the EAX register. If the value is between 32 and 64 bits, it’s passed back in a combination of EAX and EDX.</p>&#13;
<p class="indent">Both EAX and EDX are considered <em>scratch</em> registers in the ABI, meaning that their register values are not preserved across function calls: in other words, when calling a function, the caller can’t rely on any value stored in these registers to still exist when the call returns. This model of designating registers as scratch is done for pragmatic reasons: it allows functions to spend less time and memory saving registers, which might not be modified anyway. In fact, the ABI specifies an exact list of which registers must be saved into a location on the stack by the called function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/><a href="../Text/ch06.xhtml#ch6tab4">Table 6-4</a> contains a quick description of the typical register assignment’s purpose. The table also indicates whether the register must be saved when calling a function in order for the register to be restored to its original value before the function returns.</p>&#13;
<p class="tabcap"><a id="ch6tab4"/><strong>Table 6-4:</strong> Saved Register List</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Register</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>ABI usage</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Saved?</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">EAX</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Used to pass the return value of the function</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">No</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">EBX</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">General purpose register</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Yes</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">ECX</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Used for local loops and counters, and sometimes used to pass object pointers in languages such as C++</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">No</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">EDX</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Used for extended return values</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">No</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">EDI</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">General purpose register</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Yes</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">ESI</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">General purpose register</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Yes</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table">EBP</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Pointer to the base of the current valid stack frame</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Yes</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">ESP</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Pointer to the base of the stack</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Yes</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="../Text/ch06.xhtml#ch6fig4">Figure 6-4</a> shows an <code>add()</code> function being called in the assembly code for the <code>print_add()</code> function: it places the parameters on the stack (<code>PUSH 10</code>), calls the <code>add()</code> function (<code>CALL add</code>), and then cleans up afterward (<code>ADD ESP, 8</code>). The result of the addition is passed back from <code>add()</code> through the EAX register, which is then printed to the console.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig4"/><em>Figure 6-4: Function calling in assembly code</em></p>&#13;
<h3 class="h3" id="ch00lev1sec155"><span epub:type="pagebreak" id="page_125"/><strong>Static Reverse Engineering</strong></h3>&#13;
<p class="noindent">Now that you have a basic understanding of how programs execute, we’ll look at some methods of reverse engineering. <em>Static reverse engineering</em> is the process of dissecting an application executable to determine what it does. Ideally, we could reverse the compilation process to the original source code, but that’s usually too difficult to do. Instead, it’s more common to disassemble the executable.</p>&#13;
<p class="indent">Rather than attacking a binary with only a hex editor and a machine code reference, you can use one of many tools to disassemble binaries. One such tool is the Linux-based objdump, which simply prints the disassembled output to the console or to a file. Then it’s up to you to navigate through the disassembly using a text editor. However, objdump isn’t very user friendly.</p>&#13;
<p class="indent">Fortunately, there are interactive disassemblers that present disassembled code in a form that you can easily inspect and navigate. By far, the most fully featured of these is IDA Pro, which was developed by the Hex Rays company. IDA Pro is the go-to tool for static reversing, and it supports many common executable formats as well as almost any CPU architecture. The full version is pricey, but a free edition is also available. Although the free version only disassembles x86 code and can’t be used in a commercial environment, it’s perfect for getting you up to speed with a disassembler. You can download the free version of IDA Pro from the Hex Rays website at <em><a href="https://www.hex-rays.com/">https://www.hex-rays.com/</a></em>. The free version is only for Windows, but it should run well under Wine on Linux or macOS. Let’s take a quick tour of how to use IDA Pro to dissect a simple network binary.</p>&#13;
<h4 class="h4" id="ch00lev1sec156"><strong><em>A Quick Guide to Using IDA Pro Free Edition</em></strong></h4>&#13;
<p class="noindent">Once it’s installed, start IDA Pro and then choose the target executable by clicking <strong>File</strong> ▸ <strong>Open</strong>. The Load a new file window should appear (see <a href="../Text/ch06.xhtml#ch6fig5">Figure 6-5</a>).</p>&#13;
<p class="indent">This window displays several options, but most are for advanced users; you only need to consider certain important options. The first option allows you to choose the executable format you want to inspect <span class="ent">➊</span>. The default in the figure, Portable executable, is usually the correct choice, but it’s always best to check. The Processor type <span class="ent">➋</span> specifies the processor architecture as the default, which is x86. This option is especially important when you’re disassembling binary data for unusual processor architectures. When you’re sure the options you chose are correct, click <strong>OK</strong> to begin disassembly.</p>&#13;
<p class="indent">Your choices for the first and second options will depend on the executable you’re trying to disassemble. In this example, we’re disassembling a Windows executable that uses the PE format with an x86 processor. For other platforms, such as macOS or Linux, you’ll need to select the appropriate options. IDA will make its best efforts to detect the format necessary to disassemble your target, so normally you won’t need to choose. During <span epub:type="pagebreak" id="page_126"/>disassembly, it will do its best to find all executable code, annotate the decompiled functions and data, and determine cross-references between areas of the disassembly.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig5"/><em>Figure 6-5: Options for loading a new file</em></p>&#13;
<p class="indent">By default, IDA attempts to provide annotations for variable names and function parameters if it knows about them, such as when calling common API functions. For cross-references, IDA will find the locations in the disassembly where data and code are referenced: you can look these up when you’re reverse engineering, as you’ll soon see. Disassembly can take a long time. When the process is complete, you should have access to the main IDA interface, as shown in <a href="../Text/ch06.xhtml#ch6fig6">Figure 6-6</a>.</p>&#13;
<p class="indent">There are three important windows to pay attention to in IDA’s main interface. The window at <span class="ent">➋</span> is the default disassembly view. In this example, it shows the IDA Pro <em>graph view</em>, which is often a very useful way to view an individual function’s flow of execution. To display a native view showing the disassembly in a linear format based on the loading address of instructions, press the spacebar. The window at <span class="ent">➌</span> shows the status of the disassembly process as well as any errors that might occur if you try to perform an operation in IDA that it doesn’t understand. The tabs of the open windows are at <span class="ent">➊</span>.</p>&#13;
<p class="indent">You can open additional windows in IDA by selecting <strong>View</strong> ▸ <strong>Open subviews</strong>. Here are some windows you’ll almost certainly need and what they display:</p>&#13;
<p class="noindent1"><strong>IDA View</strong> Shows the disassembly of the executable</p>&#13;
<p class="noindent1"><strong>Exports</strong> Shows any functions exported by the executable</p>&#13;
<p class="noindent1"><strong>Imports</strong> Shows any functions dynamically linked into this executable at runtime</p>&#13;
<p class="noindent1"><span epub:type="pagebreak" id="page_127"/><strong>Functions</strong> Shows a list of all functions that IDA Pro has identified</p>&#13;
<p class="noindent1"><strong>Strings</strong> Shows a list of printable strings that IDA Pro has identified during analysis</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-06.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig6"/><em>Figure 6-6: The main IDA Pro interface</em></p>&#13;
<div class="image"><img alt="image" src="../Images/f06-07.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig7"/><em>Figure 6-7: The back button for the IDA Pro disassembly window</em></p>&#13;
<p class="indent">Of the five window types listed, the last four are basically just lists of information. The IDA View is where you’ll spend most of your time when you’re reverse engineering, because it shows you the disassembled code. You can easily navigate around the disassembly in IDA View. For example, double-click anything that looks like a function name or data reference to navigate automatically to the location of the reference. This technique is especially useful when you’re analyzing calls to other functions: for instance, if you see <code>CALL sub_400100</code>, just double-click the <code>sub_400100</code> portion to be taken directly to the function. You can go to the original caller by pressing the <small>ESC</small> key or the back button, highlighted in <a href="../Text/ch06.xhtml#ch6fig7">Figure 6-7</a>.</p>&#13;
<p class="indent">In fact, you can navigate back and forth in the disassembly window as you would in a web browser. When you find a reference string in the text, <span epub:type="pagebreak" id="page_128"/>move the text cursor to the reference and press X or right-click and choose <strong>Jump to xref to operand</strong> to bring up a cross-reference dialog that shows a list of all locations in the executable referencing that function or data value. Double-click an entry to navigate directly to the reference in the disassembly window.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>By default, IDA will generate automatic names for referenced values. For example, functions are named</em> <code><span class="codeitalic">sub_</code></span><code>XXXX</code>, <em>where</em> <code>XXXX</code> <em>is their memory address; the name</em> <code><span class="codeitalic">loc_</code></span><code>XXXX</code> <em>indicates branch locations in the current function or locations that are not contained in a function. These names may not help you understand what the disassembly is doing, but you can rename these references to make them more meaningful. To rename references, move the cursor to the reference text and press N or right-click and select <strong><em>Rename</em></strong> from the menu. The changes to the name should propagate everywhere it is referenced.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec157"><strong><em>Analyzing Stack Variables and Arguments</em></strong></h4>&#13;
<p class="noindent">Another feature in IDA’s disassembly window is its analysis of stack variables and arguments. When I discussed calling conventions in “<a href="../Text/ch06.xhtml#ch00lev1sec154">Application Binary Interface</a>” on <a href="../Text/ch06.xhtml#page_123">page 123</a>, I indicated that parameters are generally passed on the stack, but that the stack also stores temporary local variables, which are used by functions to store important values that can’t fit into the available registers. IDA Pro will analyze the function and determine how many arguments it takes and which local variables it uses. <a href="../Text/ch06.xhtml#ch6fig8">Figure 6-8</a> shows these variables at the start of a disassembled function as well as a few instructions that use these variables.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-08.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig8"/><em>Figure 6-8: A disassembled function showing local variables and arguments</em></p>&#13;
<p class="indent">You can rename these local variables and arguments and look up all their cross-references, but cross-references for local variables and arguments will stay within the same function.</p>&#13;
<h4 class="h4" id="ch00lev1sec158"><span epub:type="pagebreak" id="page_129"/><strong><em>Identifying Key Functionality</em></strong></h4>&#13;
<p class="noindent">Next, you need to determine where the executable you’re disassembling handles the network protocol. The most straightforward way to do this is to inspect all parts of the executable in turn and determine what they do. But if you’re disassembling a large commercial product, this method is very inefficient. Instead, you’ll need a way to quickly identify areas of functionality for further analysis. In this section, I’ll discuss four typical approaches for doing so, including extracting symbolic information, looking up which libraries are imported into the executable, analyzing strings, and identifying automated code.</p>&#13;
<h5 class="h5" id="ch00lev1sec159"><strong>Extracting Symbolic Information</strong></h5>&#13;
<p class="noindent">Compiling source code into a native executable is a lossy process, especially when the code includes symbolic information, such as the names of variables and functions or the form of in-memory structures. Because this information is rarely needed for a native executable to run correctly, the compilation process may just discard it. But dropping this information makes it very difficult to debug problems in the built executable.</p>&#13;
<p class="indent">All compilers support the ability to convert symbolic information and generate <em>debug symbols</em> with information about the original source code line associated with an instruction in memory as well as type information for functions and variables. However, developers rarely leave in debug symbols intentionally, choosing instead to remove them before a public release to prevent people from discovering their proprietary secrets (or bad code). Still, sometimes developers slip up, and you can take advantage of those slipups to aid reverse engineering.</p>&#13;
<p class="indent">IDA Pro loads debug symbols automatically whenever possible, but sometimes you’ll need to hunt down the symbols on your own. Let’s look at the debug symbols used by Windows, macOS, and Linux, as well as <em>where</em> the symbolic information is stored and <em>how</em> to get IDA to load it correctly.</p>&#13;
<p class="indent">When a Windows executable is built using common compilers (such as Microsoft Visual C++), the debug symbol information isn’t stored inside the executable; instead, it’s stored in a section of the executable that provides the location of a <em>program database (PDB)</em> file. In fact, all the debug information is stored in this PDB file. The separation of the debug symbols from the executable makes it easy to distribute the executable without debug information while making that information readily available for debugging.</p>&#13;
<p class="indent">PDB files are rarely distributed with executables, at least in closed-source software. But one very important exception is Microsoft Windows. To aid debugging efforts, Microsoft releases public symbols for most executables installed as part of Windows, including the kernel. Although these PDB files don’t contain all the debug information from the compilation process (Microsoft strips out information they don’t want to make public, <span epub:type="pagebreak" id="page_130"/>such as detailed type information), the files still contain most of the function names, which is often what you want. The upshot is that when reverse engineering Windows executables, IDA Pro should automatically look up the symbol file on Microsoft’s public symbol server and process it. If you happen to have the symbol file (because it came with the executable), load it by placing it next to the executable in a directory and then have IDA Pro disassemble the executable. You can also load PDB files after initial disassembly by selecting <strong>File</strong> ▸ <strong>Load File</strong> ▸ <strong>PDB File</strong>.</p>&#13;
<p class="indent">Debug symbols are most significant in reverse engineering in IDA Pro when naming functions in the disassembly and Functions windows. If the symbols also contain type information, you should see annotations on the function calls that indicate the types of parameters, as shown in <a href="../Text/ch06.xhtml#ch6fig9">Figure 6-9</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-09.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig9"/><em>Figure 6-9: Disassembly with debug symbols</em></p>&#13;
<p class="indent">Even without a PDB file, you might be able to access some symbolic information from the executable. Dynamic libraries, for example, must export some functions for another executable to use: that export will provide some basic symbolic information, including the names of the external functions. From that information, you should be able to drill down to find what you’re looking for in the Exports window. <a href="../Text/ch06.xhtml#ch6fig10">Figure 6-10</a> shows what this information would look like for the <em>ws2_32.dll</em> Windows network library.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_131"/><img alt="image" src="../Images/f06-10.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig10"/><em>Figure 6-10: Exports from the</em> ws2_32.dll <em>library</em></p>&#13;
<p class="indent">Debug symbols work similarly on macOS, except debugging information is contained in a <em>debugging symbols package (dSYM)</em>, which is created alongside the executable rather than in a single PDB file. The dSYM package is a separate macOS package directory and is rarely distributed with commercial applications. However, the Mach-O executable format can store basic symbolic information, such as function and data variable names, in the executable. A developer can run a tool called Strip, which will remove all this symbolic information from a Mach-O binary. If they do not run Strip, then the Mach-O binary may still contain useful symbolic information for reverse engineering.</p>&#13;
<p class="indent">On Linux, ELF executable files package all debug and other symbolic information into a single executable file by placing debugging information into its own section in the executable. As with macOS, the only way to remove this information is with the Strip tool; if the developer fails to do so before release, you might be in luck. (Of course, you’ll have access to the source code for most programs running on Linux.)</p>&#13;
<h5 class="h5" id="ch00lev1sec160"><strong>Viewing Imported Libraries</strong></h5>&#13;
<p class="noindent">On a general purpose operating system, calls to network APIs aren’t likely to be built directly into the executable. Instead, functions will be dynamically linked at runtime. To determine what an executable imports dynamically, view the Imports window in IDA Pro, as shown in <a href="../Text/ch06.xhtml#ch6fig11">Figure 6-11</a>.</p>&#13;
<p class="indent">In the figure, various network APIs are imported from the <em>ws2_32.dll</em> library, which is the BSD sockets implementation for Windows. When you double-click an entry, you should see the import in a disassembly window. From there, you can find references to that function by using IDA Pro to show the cross-references to that address.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_132"/><img alt="image" src="../Images/f06-11.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig11"/><em>Figure 6-11: The Imports window</em></p>&#13;
<p class="indent">In addition to network functions, you might also see that various cryptographic libraries have been imported. Following these references can lead you to where encryption is used in the executable. By using this imported information, you may be able to trace back to the original callee to find out how it’s been used. Common encryption libraries include OpenSSL and the Windows <em>Crypt32.dll</em>.</p>&#13;
<h5 class="h5" id="ch00lev1sec161"><strong>Analyzing Strings</strong></h5>&#13;
<p class="noindent">Most applications contain strings with printable text information, such as text to display during application execution, text for logging purposes, or text left over from the debugging process that isn’t used. The text, especially internal debug information, might hint at what a disassembled function is doing. Depending on how the developer added debug information, you might find the function name, the original C source code file, or even the line number in the source code where the debug string was printed. (Most C and C++ compilers support a syntax to embed these values into a string during compilation.)</p>&#13;
<p class="indent">IDA Pro tries to find printable text strings as part of its analysis process. To display these strings, open the Strings window. Click a string of interest, and you’ll see its definition. Then you can attempt to find references to the string that should allow you to trace back to the functionality associated with it.</p>&#13;
<p class="indent">String analysis is also useful for determining which libraries an executable was statically linked with. For example, the ZLib compression library is commonly statically linked, and the linked executable should always contain the following string (the version number might differ):</p>&#13;
<pre>inflate 1.2.8 Copyright 1995-2013 Mark Adler</pre>&#13;
<p class="indent">By quickly discovering which libraries are included in an executable, you might be able to successfully guess the structure of the protocol.</p>&#13;
<h5 class="h5" id="ch00lev1sec162"><span epub:type="pagebreak" id="page_133"/><strong>Identifying Automated Code</strong></h5>&#13;
<p class="noindent">Certain types of functionality lend themselves to automated identification. For example, encryption algorithms typically have several <em>magic constants</em> (numbers defined by the algorithm that are chosen for particular mathematical properties) as part of the algorithm. If you find these magic constants in the executable, you know a particular encryption algorithm is at least compiled into the executable (though it isn’t necessarily used). For example, <a href="../Text/ch06.xhtml#ch6list3">Listing 6-3</a> shows the initialization of the MD5 hashing algorithm, which uses magic constant values.</p>&#13;
<pre>void md5_init( md5_context *ctx )<br/>{<br/>    ctx-&gt;state[0] = <span class="codestrong">0x67452301</span>;<br/>    ctx-&gt;state[1] = <span class="codestrong">0xEFCDAB89</span>;<br/>    ctx-&gt;state[2] = <span class="codestrong">0x98BADCFE</span>;<br/>    ctx-&gt;state[3] = <span class="codestrong">0x10325476</span>;<br/>}</pre>&#13;
<p class="listing"><a id="ch6list3"/><em>Listing 6-3: MD5 initialization showing magic constants</em></p>&#13;
<p class="indent">Armed with knowledge of the MD5 algorithm, you can search for this initialization code in IDA Pro by selecting a disassembly window and choosing <strong>Search</strong> ▸ <strong>Immediate value</strong>. Complete the dialog as shown in <a href="../Text/ch06.xhtml#ch6fig12">Figure 6-12</a> and click <strong>OK</strong>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-12.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig12"/><em>Figure 6-12: The IDA Pro search box for MD5 constant</em></p>&#13;
<p class="indent">If MD5 is present, your search should display a list of places where that unique value is found. Then you can switch to the disassembly window to try to determine what code uses that value. You can also use this technique with algorithms, such as the AES encryption algorithm, which uses special <em>s-box</em> structures that contain similar magic constants.</p>&#13;
<p class="indent">However, locating algorithms using IDA Pro’s search box can be time consuming and error prone. For example, the search in <a href="../Text/ch06.xhtml#ch6fig12">Figure 6-12</a> will pick up MD5 as well as SHA-1, which uses the same four magic constants <span epub:type="pagebreak" id="page_134"/>(and adds a fifth). Fortunately, there are tools that can do these searches for you. One example, PEiD (available from <em><a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml">http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml</a></em>), determines whether a Windows PE file is packed with a known packing tool, such as UPX. It includes a few plug-ins, one of which will detect potential encryption algorithms and indicate where in the executable they are referenced.</p>&#13;
<p class="indent">To use PEiD to detect cryptographic algorithms, start PEiD and click the top-right button <strong>…</strong> to choose a PE executable to analyze. Then run the plug-in by clicking the button on the bottom right and selecting <strong>Plugins</strong> ▸ <strong>Krypto Analyzer</strong>. If the executable contains any cryptographic algorithms, the plug-in should identify them and display a dialog like the one in <a href="../Text/ch06.xhtml#ch6fig13">Figure 6-13</a>. You can then enter the referenced address value <span class="ent">➊</span> into IDA Pro to analyze the results.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-13.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig13"/><em>Figure 6-13: The result of PEiD cryptographic algorithm analysis</em></p>&#13;
<h3 class="h3" id="ch00lev1sec163"><strong>Dynamic Reverse Engineering</strong></h3>&#13;
<p class="noindent"><em>Dynamic reverse engineering</em> is about inspecting the operation of a running executable. This method of reversing is especially useful when analyzing complex functionality, such as custom cryptography or compression routines. The reason is that instead of staring at the disassembly of complex functionality, you can step through it one instruction at a time. Dynamic reverse engineering also lets you test your understanding of the code by allowing you to inject test inputs.</p>&#13;
<p class="indent">The most common way to perform dynamic reverse engineering is to use a debugger to halt a running application at specific points and inspect data values. Although several debugging programs are available to choose from, we’ll use IDA Pro, which contains a basic debugger for Windows applications and synchronizes between the static and debugger view. For example, if you rename a function in the debugger, that change will be reflected in the static disassembly.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_135"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although I use IDA Pro on Windows in the following discussion, the basic techniques are applicable to other operating systems and debuggers.</em></p>&#13;
</div>&#13;
<p class="indent">To run the currently disassembled executable in IDA Pro’s debugger, press F9. If the executable needs command line arguments, add them by selecting <strong>Debugger</strong> ▸ <strong>Process Options</strong> and filling in the <em>Parameters</em> text box in the displayed dialog. To stop debugging a running process, press <small>CTRL</small>-F2.</p>&#13;
<h4 class="h4" id="ch00lev1sec164"><strong><em>Setting Breakpoints</em></strong></h4>&#13;
<p class="noindent">The simplest way to use a debugger’s features is to set <em>breakpoints</em> at places of interest in the disassembly, and then inspect the state of the running program at these breakpoints. To set a breakpoint, find an area of interest and press F2. The line of disassembly should turn red, indicating that the breakpoint has been set correctly. Now, whenever the program tries to execute the instruction at that breakpoint, the debugger should stop and give you access to the current state of the program.</p>&#13;
<h4 class="h4" id="ch00lev1sec165"><strong><em>Debugger Windows</em></strong></h4>&#13;
<p class="noindent">By default, the IDA Pro debugger shows three important windows when the debugger hits a breakpoint.</p>&#13;
<h5 class="h5" id="ch00lev1sec166"><strong>The EIP Window</strong></h5>&#13;
<p class="noindent">The first window displays a disassembly view based on the instruction in the EIP register that shows the instruction currently being executed (see <a href="../Text/ch06.xhtml#ch6fig14">Figure 6-14</a>). This window works much like the disassembly window does while doing static reverse engineering. You can quickly navigate from this window to other functions and rename references (which are reflected in your static disassembly). When you hover the mouse over a register, you should see a quick preview of the value, which is very useful if the register points to a memory address.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-14.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig14"/><em>Figure 6-14: The debugger EIP window</em></p>&#13;
<h5 class="h5" id="ch00lev1sec167"><span epub:type="pagebreak" id="page_136"/><strong>The ESP Window</strong></h5>&#13;
<p class="noindent">The debugger also shows an ESP window that reflects the current location of the ESP register, which points to the base of the current thread’s stack. Here is where you can identify the parameters being passed to function calls or the value of local variables. For example, <a href="../Text/ch06.xhtml#ch6fig15">Figure 6-15</a> shows the stack values just before calling the <code>send</code> function. I’ve highlighted the four parameters. As with the EIP window, you can double-click references to navigate to that location.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-15.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig15"/><em>Figure 6-15: The debugger ESP window</em></p>&#13;
<h5 class="h5" id="ch00lev1sec168"><strong>The State of the General Purpose Registers</strong></h5>&#13;
<p class="noindent">The General registers default window shows the current state of the general purpose registers. Recall that registers are used to store the current values of various program states, such as loop counters and memory addresses. For memory addresses, this window provides a convenient way to navigate to a memory view window: click the arrow next to each address to navigate from the last active memory window to the memory address corresponding to that register value.</p>&#13;
<p class="indent">To create a new memory window, right-click the array and select <strong>Jump in new window</strong>. You’ll see the condition flags from the EFLAGS register on the right side of the window, as shown in <a href="../Text/ch06.xhtml#ch6fig16">Figure 6-16</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-16.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig16"/><em>Figure 6-16: The General registers window</em></p>&#13;
<h4 class="h4" id="ch00lev1sec169"><span epub:type="pagebreak" id="page_137"/><strong><em>Where to Set Breakpoints?</em></strong></h4>&#13;
<p class="noindent">Where are the best places to set breakpoints when you’re investigating a network protocol? A good first step is to set breakpoints on calls to the <code>send</code> and <code>recv</code> functions, which send and receive data from the network stack. Cryptographic functions are also a good target: you can set breakpoints on functions that set the encryption key or the encryption and decryption functions. Because the debugger synchronizes with the static disassembler in IDA Pro, you can also set breakpoints on code areas that appear to be building network protocol data. By stepping through instructions with breakpoints, you can better understand how the underlying algorithms work.</p>&#13;
<h3 class="h3" id="ch00lev1sec170"><strong>Reverse Engineering Managed Languages</strong></h3>&#13;
<p class="noindent">Not all applications are distributed as native executables. For example, applications written in <em>managed languages</em> like .NET and Java compile to an intermediate machine language, which is commonly designed to be CPU and operating system agnostic. When the application is executed, a <em>virtual machine</em> or <em>runtime</em> executes the code. In .NET this intermediate machine language is called <em>common intermediate language (CIL)</em>; in Java it’s called <em>Java byte code</em>.</p>&#13;
<p class="indent">These intermediate languages contain substantial amounts of metadata, such as the names of classes and all internal- and external-facing method names. Also, unlike for native-compiled code, the output of managed languages is fairly predictable, which makes them ideal for decompiling.</p>&#13;
<p class="indent">In the following sections, I’ll examine how .NET and Java applications are packaged. I’ll also demonstrate a few tools you can use to reverse engineer .NET and Java applications efficiently.</p>&#13;
<h4 class="h4" id="ch00lev1sec171"><strong><em>.NET Applications</em></strong></h4>&#13;
<p class="noindent">The .NET runtime environment is called the <em>common language runtime (CLR)</em>. A .NET application relies on the CLR as well as a large library of basic functionality called the <em>base class library (BCL)</em>.</p>&#13;
<p class="indent">Although .NET is primarily a Microsoft Windows platform (it is developed by Microsoft after all), a number of other, more portable versions are available. The best known is the Mono Project, which runs on Unix-like systems and covers a wide range of CPU architectures, including SPARC and MIPS.</p>&#13;
<p class="indent">If you look at the files distributed with a .NET application, you’ll see files with <em>.exe</em> and <em>.ddl</em> extensions, and you’d be forgiven for assuming they’re just native executables. But if you load these files into an x86 disassembler, you’ll be greeted with a message similar to the one shown in <a href="../Text/ch06.xhtml#ch6fig17">Figure 6-17</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_138"/><img alt="image" src="../Images/f06-17.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig17"/><em>Figure 6-17: A .NET executable in an x86 disassembler</em></p>&#13;
<p class="indent">As it turns out, .NET only uses the <em>.exe</em> and <em>.dll</em> file formats as convenient containers for the CIL code. In the .NET runtime, these containers are referred to as <em>assemblies</em>.</p>&#13;
<p class="indent">Assemblies contain one or more classes, enumerations, and/or structures. Each type is referred to by a name, typically consisting of a namespace and a short name. The namespace reduces the likelihood of conflicting names but can also be useful for categorization. For example, any types under the namespace System.Net deal with network functionality.</p>&#13;
<h4 class="h4" id="ch00lev1sec172"><strong><em>Using ILSpy</em></strong></h4>&#13;
<p class="noindent">You’ll rarely, if ever, need to interact with raw CIL because tools like Reflector (<em><a href="https://www.red-gate.com/products/dotnet-development/reflector/">https://www.red-gate.com/products/dotnet-development/reflector/</a></em>) and ILSpy (<em><a href="http://ilspy.net/">http://ilspy.net/</a></em>) can decompile CIL data into C# or Visual Basic source and display the original CIL. Let’s look at how to use ILSpy, a free open source tool that you can use to find an application’s network functionality. <a href="../Text/ch06.xhtml#ch6fig18">Figure 6-18</a> shows ILSpy’s main interface.</p>&#13;
<p class="indent">The interface is split into two windows. The left window <span class="ent">➊</span> is a tree-based listing of all assemblies that ILSpy has loaded. You can expand the tree view to see the namespaces and the types an assembly contains <span class="ent">➋</span>. The right window shows disassembled source code <span class="ent">➌</span>. The assembly you select in the left window is expanded on the right.</p>&#13;
<p class="indent">To work with a .NET application, load it into ILSpy by pressing <small>CTRL</small>+O and selecting the application in the dialog. If you open the application’s main executable file, ILSpy should automatically load any assembly referenced in the executable as necessary.</p>&#13;
<p class="indent">With the application open, you can search for the network functionality. One way to do so is to search for types and members whose names sound like network functions. To search all loaded assemblies, press F3. A new window should appear on the right side of your screen, as shown in <a href="../Text/ch06.xhtml#ch6fig19">Figure 6-19</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_139"/><img alt="image" src="../Images/f06-18.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig18"/><em>Figure 6-18: The ILSpy main interface</em></p>&#13;
<div class="image"><img alt="image" src="../Images/f06-19.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig19"/><em>Figure 6-19: The ILSpy Search window</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>Enter a search term at <span class="ent">➊</span> to filter out all loaded types and display them in the window below. You can also search for members or constants by selecting them from the drop-down list at <span class="ent">➋</span>. For example, to search for literal strings, select <strong>Constant</strong>. When you’ve found an entry you want to inspect, such as TcpNetworkListener <span class="ent">➌</span>, double-click it and ILSpy should automatically decompile the type or method.</p>&#13;
<p class="indent">Rather than directly searching for specific types and members, you can also search an application for areas that use built-in network or cryptography libraries. The base class library contains a large set of low-level socket APIs and libraries for higher-level protocols, such as HTTP and FTP. If you right-click a type or member in the left window and select <strong>Analyze</strong>, a new window should appear, as shown at the right side of <a href="../Text/ch06.xhtml#ch6fig20">Figure 6-20</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-20.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig20"/><em>Figure 6-20: ILSpy analyzing a type</em></p>&#13;
<p class="indent">This new window is a tree, which when expanded, shows the types of analyses that can be performed on the item you selected in the left window. Your options will depend on what you selected to analyze. For example, analyzing a type <span class="ent">➊</span> shows three options, although you’ll typically only need to use the following two forms of analysis:</p>&#13;
<p class="noindent1t"><strong>Instantiated By</strong> Shows which methods create new instances of this type</p>&#13;
<p class="noindent1b"><strong>Exposed By</strong> Shows which methods or properties use this type in their declaration or parameters</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_141"/>If you analyze a member, a method, or a property, you’ll get two options <span class="ent">➋</span>:</p>&#13;
<p class="noindent1t"><strong>Uses</strong> Shows what other members or types the selected member uses</p>&#13;
<p class="noindent1b"><strong>Used By</strong> Shows what other members use the selected member (say, by calling the method)</p>&#13;
<p class="indent">You can expand all entries <span class="ent">➌</span>.</p>&#13;
<p class="indent">And that’s pretty much all there is to statically analyzing a .NET application. Find some code of interest, inspect the decompiled code, and then start analyzing the network protocol.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Most of .NET’s core functionality is in the base class library distributed with the .NET runtime environment and available to all .NET applications. The assemblies in the BCL provide several basic network and cryptographic libraries, which applications are likely to need if they implement a network protocol. Look for areas that reference types in the <code><span class="codeitalic">System.Net</code></span> and <code><span class="codeitalic">System.Security.Cryptography</code></span> namespaces. These are mostly implemented in the MSCORLIB and System assemblies. If you can trace back from calls to these important APIs, you’ll discover where the application handles the network protocol.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec173"><strong><em>Java Applications</em></strong></h4>&#13;
<p class="noindent">Java applications differ from .NET applications in that the Java compiler doesn’t merge all types into a single file; instead, it compiles each source code file into a single <em>Class file</em> with a <em>.class</em> extension. Because separate Class files in filesystem directories aren’t very convenient to transfer between systems, Java applications are often packaged into a <em>Java archive</em>, or <em>JAR</em>. A JAR file is just a ZIP file with a few additional files to support the Java runtime. <a href="../Text/ch06.xhtml#ch6fig21">Figure 6-21</a> shows a JAR file opened in a ZIP decompression program.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-21.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig21"/><em>Figure 6-21: An example JAR file opened with a ZIP application</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_142"/>To decompile Java programs, I recommend using JD-GUI (<em><a href="http://jd.benow.ca/">http://jd.benow.ca/</a></em>), which works in essentially the same as ILSpy when decompiling .NET applications. I won’t cover using JD-GUI in depth but will just highlight a few important areas of the user interface in <a href="../Text/ch06.xhtml#ch6fig22">Figure 6-22</a> to get you up to speed.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-22.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig22"/><em>Figure 6-22: JD-GUI with an open JAR File</em></p>&#13;
<p class="indent"><a href="../Text/ch06.xhtml#ch6fig22">Figure 6-22</a> shows the JD-GUI user interface when you open the JAR file <em>jce.jar</em> <span class="ent">➊</span>, which is installed by default when you install Java and can usually be found in <em>JAVAHOME/lib</em>. You can open individual class files or multiple JAR files at one time depending on the structure of the application you’re reverse engineering. When you open a JAR file, JD-GUI will parse the metadata as well as the list of classes, which it will present in a tree structure. In <a href="../Text/ch06.xhtml#ch6fig22">Figure 6-22</a> we can see two important piece of information JD-GUI has extracted. First, a package named <code>javax.crypto</code> <span class="ent">➋</span>, which defines the classes for various Java cryptographic operations. Underneath the package name is list of classes defined in that package, such as <code>CryptoAllPermissionCollection.class</code> <span class="ent">➌</span>. If you click the class name in the left window, a decompiled version of the class will be shown on the right <span class="ent">➍</span>. You can scroll through the decompiled code, or click on the fields and methods exposed by the class <span class="ent">➎</span> to jump to them in the decompiled code window.</p>&#13;
<p class="indent">The second important thing to note is that any identifier underlined in the decompiled code can be clicked, and the tool will navigate to the definition. If you clicked the underlined <code>all_allowed</code> identifier <span class="ent">➏</span>, the user interface would navigate to the definition of the <code>all_allowed</code> field in the current decompiled class.</p>&#13;
<h4 class="h4" id="ch00lev1sec174"><span epub:type="pagebreak" id="page_143"/><strong><em>Dealing with Obfuscation</em></strong></h4>&#13;
<p class="noindent">All the metadata included with a typical .NET or Java application makes it easier for a reverse engineer to work out what an application is doing. However, commercial developers, who employ special “secret sauce” network protocols, tend to not like the fact that these applications are much easier to reverse engineer. The ease with which these languages are decompiled also makes it relatively straightforward to discover horrible security holes in custom network protocols. Some developers might not like you knowing this, so they use obscurity as a security solution.</p>&#13;
<p class="indent">You’ll likely encounter applications that are intentionally obfuscated using tools such as ProGuard for Java or Dotfuscator for .NET. These tools apply various modifications to the compiled application that are designed to frustrate a reverse engineer. The modification might be as simple as changing all the type and method names to meaningless values, or it might be more elaborate, such as employing runtime decryption of strings and code. Whatever the method, obfuscation will make decompiling the code more difficult. For example, <a href="../Text/ch06.xhtml#ch6fig23">Figure 6-23</a> shows an original Java class next to its obfuscated version, which was obtained after running it through ProGuard.</p>&#13;
<div class="image"><img alt="image" src="../Images/f06-23.jpg"/></div>&#13;
<p class="figcap"><a id="ch6fig23"/><em>Figure 6-23: Original and obfuscated class file comparison</em></p>&#13;
<p class="indent">If you encounter an obfuscated application, it can be difficult to determine what it’s doing using normal decompilers. After all, that’s the point of the obfuscation. However, here are a few tips to use when tackling them:</p>&#13;
<p class="bullt">• Keep in mind that external library types and methods (such as core class libraries) cannot be obfuscated. Calls to the socket APIs must exist in the application if it does any networking, so search for them.</p>&#13;
<p class="bull"><span epub:type="pagebreak" id="page_144"/>• Because .NET and Java are easy to load and execute dynamically, you can write a simple test harness to load the obfuscated application and run the string or code decryption routines.</p>&#13;
<p class="bullb">• Use dynamic reverse engineering as much as possible to inspect types at runtime to determine what they’re used for.</p>&#13;
<h3 class="h3" id="ch00lev1sec175"><strong>Reverse Engineering Resources</strong></h3>&#13;
<p class="noindent">The following URLs provide access to excellent information resources for reverse engineering software. These resources provide more details on reverse engineering or other related topics, such as executable file formats.</p>&#13;
<p class="bullt">• OpenRCE Forums: <em><a href="http://www.openrce.org/">http://www.openrce.org/</a></em></p>&#13;
<p class="bull">• ELF File Format: <em><a href="http://refspecs.linuxbase.org/elf/elf.pdf">http://refspecs.linuxbase.org/elf/elf.pdf</a></em></p>&#13;
<p class="bull">• macOS Mach-O Format: <em><a href="https://web.archive.org/web/20090901205800/">https://web.archive.org/web/20090901205800/</a></em></p>&#13;
<p class="bullp"><em><a href="http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html">http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html</a></em></p>&#13;
<p class="bullb">• PE File Format: <em><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx</a></em></p>&#13;
<p class="indent">For more information on the tools used in this chapter, including where to download them, turn to <a href="../Text/app01.xhtml#app01">Appendix A</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec176"><strong>Final Words</strong></h3>&#13;
<p class="noindent">Reverse engineering takes time and patience, so don’t expect to learn it overnight. It takes time to understand how the operating system and the architecture work together, to untangle the mess that optimized C can produce in the disassembler, and to statically analyze your decompiled code. I hope I’ve given you some useful tips on reverse engineering an executable to find its network protocol code.</p>&#13;
<p class="indent">The best approach when reverse engineering is to start on small executables that you already understand. You can compare the source of these small executables to the disassembled machine code to better understand how the compiler translated the original programming language.</p>&#13;
<p class="indent">Of course, don’t forget about dynamic reverse engineering and using a debugger whenever possible. Sometimes just running the code will be a more efficient method than static analysis. Not only will stepping through a program help you to better understand how the computer architecture works, but it will also allow you to analyze a small section of code fully. If you’re lucky, you might get to analyze a managed language executable written in .NET or Java using one of the many tools available. Of course, if the developer has obfuscated the executable, analysis becomes more difficult, but that’s part of the fun of reverse engineering.</p>&#13;
</body></html>