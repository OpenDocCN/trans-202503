- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    NATURE OF VALUES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: C# gives special meaning to the term *value type*, but the concept of a value
    certainly isn’t unique to C#. In this chapter, we’ll revisit values more generally
    and identify some key characteristics that indicate whether we should implement
    something as a value type. We’ll look at the unique and important role of values
    and value types in our programs, and how implementing a well-behaved value type
    requires more than just using a struct or a record struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to improve our designs by employing value type objects to encapsulate behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How overriding the native reference semantics for some types adversely affects
    their behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What application roles are fulfilled by different object types, and what characteristics
    define those roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why equality isn’t the same as equivalence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to identify appropriate candidates for value types in our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every application is different, and it’s our responsibility to create solutions
    to problems that are specific to a particular program. Ultimately, that requires
    us to use our own judgment on how best to apply our chosen programming language.
    In C#, to some extent, that means selecting whether we want to use classes, structs,
    records, or record structs for the types we create.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not appropriate for *everything* to be a value type; sometimes value semantics
    isn’t suitable for the functionality we need. When choosing among the different
    types, we need to decide when value semantics makes sense for a type—and, equally
    importantly, when it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Value vs. Reference Semantics</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *value semantics* is widely used to describe value types, usually in
    contrast with its counterpart, *reference semantics*. However, while reference
    semantics is easily defined in terms of indirect access to instances via reference
    variables (or similar mechanisms in other languages), value semantics is often
    ill-defined or superficially explained as something value types possess. In C#,
    value types are epitomized by the struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structs differ from classes in C# most conspicuously in that struct instances
    are copied by value, meaning the copy is a whole new instance. As a result, structs
    are commonly referred to as having value semantics. We might infer, then, that
    value semantics means that an instance is copied by value, and the C# Language
    Specification certainly supports this definition ([*https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-gb<wbr>/dotnet<wbr>/csharp<wbr>/language<wbr>-reference<wbr>/language<wbr>-specification<wbr>/structs*](https://docs.microsoft.com/en-gb/dotnet/csharp/language-reference/language-specification/structs):)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[Structs] can be conveniently implemented using value semantics where assignment
    copies the value instead of the reference.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we’ve discussed in earlier chapters, copying by value is a direct consequence
    of the way value type variables use memory. The value of every value type variable
    is a complete instance of the type. When the value is copied, the copy is necessarily
    a whole new instance of the type, including copies of each field’s value from
    the original instance. This differs from copying reference variables, where the
    copy is a new reference to the same instance in memory as the original variable.
    The original object’s field values aren’t copied at all.
  prefs: []
  type: TYPE_NORMAL
- en: The difference in copying behavior is merely a result of how value types and
    reference types are represented. Reference variables may be copied frequently,
    but the instances they refer to are rarely copied, which is a convenient and efficient
    use of memory. Struct and record struct variables are copied by value because
    they can’t be copied any other way. However, copying behavior is only one part
    of the difference between value and reference semantics.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying and Equality
    Comparison Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Equality comparison behavior is closely related to the way variables are copied.
    When we make a copy of a variable, the copy should compare equal to the original
    variable. That may seem obvious, but it’s the reason all structs inherit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    and why that default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for structs is so important. Without <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    a copy of a struct variable wouldn’t compare equal with the original value, because
    struct variables are copied by value. The copy is a distinct instance in its own
    right, and the default reference comparison offered by <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    would never compare the copy and original values as equal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    performs a value-based comparison to ensure that when we copy a value type instance,
    the copy and original variable will compare equal.
  prefs: []
  type: TYPE_NORMAL
- en: When we compare references, we’re checking to see whether they represent the
    same specific instance, not whether those instances look alike. The behavior of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method inherited
    by class types from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    matches the copying behavior of references, because copying a reference variable
    doesn’t also copy the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Being copied by value isn’t, on its own, what endows a value type with value
    semantics; it’s simply the mechanism defined in the language for copying variables
    of struct type. In fact, copy-by-value behavior isn’t even a necessary ingredient
    of value semantics. Take, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class, which overrides the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to perform
    a value-based comparison. As noted in [Chapter 5](chapter5.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    is a class, and <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables
    are references, but when we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables, we’re most often interested in whether they both have the same content—that
    is, whether their character sequences are the same.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of equality comparisons, at least, a string’s *value* is the
    sequence of characters, not the actual value of the reference. Whether the two
    variables refer to the same string in memory is almost always irrelevant. Since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables are references,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instances aren’t routinely
    copied by value, but they are *compared* by value.
  prefs: []
  type: TYPE_NORMAL
- en: When we’re trying to define or understand value semantics, equality behavior
    is more significant than the way variables are copied. In the broader sense, a
    value type is any type that bases its equality comparisons on its state; that
    is, two value type objects are equal if they have the same value. By extension,
    there’s more to value semantics than a type being implemented as a struct or record
    struct; having value semantics is what makes a type a *value* type, if we accept
    a wider interpretation of the term *value type* than the definition in the C#
    Language Specification.
  prefs: []
  type: TYPE_NORMAL
- en: We can override that behavior for any of our own class types too, but doing
    so is not always appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference-Based Comparisons</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most objects have some state, whether that’s private instance fields or public
    property values. We might be tempted to override the default reference equality
    behavior for all our classes and always use that state as an object’s value for
    comparisons. However, although we can model values by using a class, as C# does
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>, *having* a value
    and *being* a value are very different. Most types aren’t intended to be values,
    and the default reference comparison is more appropriate for the majority of the
    classes we create.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of reference-based comparisons being important for an object,
    consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> class
    in [Listing 6-1](#list6-1) for a system tracking logged-in users. Since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> is a class, the semantics
    of reference comparisons makes sense for it because we need to be able to distinguish
    between individual instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Reference-based
    equality matters for class types.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Even though the public properties directly expose the state of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    instance, using those properties to implement equality would be a mistake. Two
    instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> with the
    same property values might easily represent different connections. Even if we
    presume that the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>
    property is unique across all users, we may still need to identify an individual
    login in systems that allow multiple connections by the same user. The same user
    might even log in twice at exactly the same moment, so distinguishing different
    connections by their <samp class="SANS_TheSansMonoCd_W5Regular_11">Established</samp>
    property isn’t sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: If we overrode the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> to compare
    its property values, we couldn’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to distinguish between different instances with identical properties. If we needed
    to forcibly disconnect a specific connection by calling its <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method, we’d want to be certain we were disconnecting the right one! We therefore
    need to be able to identify a specific *instance* of a login, regardless of the
    values of its public properties.
  prefs: []
  type: TYPE_NORMAL
- en: We could use a mechanism other than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to distinguish between different instances with identical state, but we’d be adding
    extra complexity to support functionality that a normal reference-based comparison
    already provides.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference Semantics and Side
    Effects</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The difference between value semantics and reference semantics is also defined
    partly by the potential for side effects via aliasing references, which in turn
    is closely associated with mutability. If we change an object via one variable
    and expect the change to be visible via another variable, we need reference semantics.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> class from [Listing
    6-1](#list6-1) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method that alters the internal state of an instance. If we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method by using one reference variable, we expect every reference to that instance
    to become inactive. As [Listing 6-2](#list6-2) demonstrates, we also expect no
    other instances to be affected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: Intentionally
    changing an instance via a shared reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we copy the <samp class="SANS_TheSansMonoCd_W5Regular_11">norris</samp>
    reference variable and call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method on the copy, setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">Active</samp>
    property to <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. Although
    we never use the <samp class="SANS_TheSansMonoCd_W5Regular_11">norris</samp> variable
    to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>, the state
    of the instance <samp class="SANS_TheSansMonoCd_W5Regular_11">norris</samp> refers
    to is changed after <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    is called because that instance has been modified via a different reference. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mac</samp> variable refers to a
    separate instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>,
    so it’s not affected by the change to <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We want reference semantics for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    class because it means we can have many references to a specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    instance. We can pass a reference as an argument to methods and arrange for those
    methods to intentionally modify that instance. We don’t need to worry about searching
    for all other references to the modified instance to make sure they’ve been updated
    with our changes, because references have that behavior built in.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly more subtle outcome of reference semantics is that if we change the
    state of a reference type instance via one reference, the variable will still
    compare equal to any other references to the same instance. [Listing 6-3](#list6-3)
    checks that two references compare equal even after the instance has been modified
    by one of those variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: Checking for reference
    equality</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates that when we change an instance of a reference type,
    that change is visible via all other references that are *equal* to the reference
    used to make the change. The outcome is that if two reference variables compare
    equal once in a reference-based comparison, and neither variable is assigned to
    a different instance, they’ll *always* compare equal because references are equal
    when they have the same identity.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Object Identity</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *identity* of an object is what distinguishes it from other objects of
    the same type. Two reference type instances have different identities—they’re
    independent objects—regardless of whether they have fields containing the same
    values. We can think of the address of an object as its identity, although this
    is only an analogy: an object’s address can change if it’s moved in memory because
    of heap defragmentation or other memory management tasks, but the object retains
    its identity.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](chapter2.xhtml), you saw how the <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    statement relies on reference semantics; that’s one example of an object’s identity
    being more important than the state it contains, even though the underlying <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp> class doesn’t attempt to
    mutate the object used as a lock in any way. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp>
    relies on knowing the identity of a specific object instance, and that the identity
    is valid across multiple threads of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Reference semantics is an important element in our toolbox so that we can identify
    a specific object instance, not just an object that has the same state as another
    object. Two reference variables to different class instances with exactly the
    same state shouldn’t usually compare equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one exception occurs when we’re using a class to model a value type. In
    this case, the identity isn’t important, because we’re deliberately giving the
    class *value* semantics. The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    type is a classic example. This type isn’t a struct for valid reasons that are
    mostly concerned with efficiency: as a class, a string’s contents won’t be copied
    frequently, and its values will never be boxed. Nevertheless, <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables are compared by value, and using them is intuitive and straightforward
    thanks to value semantics for equality. Most classes, however, aren’t intended
    to model values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For types intended to have value semantics, instance identity has little or
    no significance. Values should be *referentially transparent*: we can switch one
    instance of a value with a different instance without affecting the program’s
    logic or behavior, provided both instances have identical state.'
  prefs: []
  type: TYPE_NORMAL
- en: An object’s identity is important when we can alter that object’s state, because
    identity is the only characteristic that distinguishes one object instance from
    another. The native reference equality of reference types tells us *which* variables
    will reflect a change we make to a particular instance.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value-Based Comparisons</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> type in [Listing
    6-1](#list6-1) were a struct or record struct instead of a class, the final assertions
    in [Listings 6-2](#list6-2) and [6-3](#list6-3) would fail because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method would be changing a different instance from the variable used in the assertion.
    Value types are useful when we don’t need the aliasing behavior of reference semantics
    or the ability to have multiple references to a single instance. Contrast the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> type in [Listing 6-1](#list6-1)
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type in [Listing
    6-4](#list6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: Comparing the
    state of two Color values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type is a struct,
    making it a value type. The two variables <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> are clearly different
    instances, but they have the same color value and thus should compare equal. The
    only interesting aspect of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type, at least as far as testing two instances for equality is concerned, is its
    state. Two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances
    should compare equal if—and only if—their externally visible property values match.
  prefs: []
  type: TYPE_NORMAL
- en: From one perspective, the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    *is* its identity, because identity is what distinguishes one object from another.
    Values are transient in that we can make one at any time with a given state. If
    we create multiple instances of a value type with the same state at different
    times or in different methods, then for all intents and purposes, they’re *the
    same* value because they’re indistinguishable, although the mechanics of the language
    means they’re necessarily separate instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'It *is* legitimate to say that equal values can be substituted for one another.
    Take, for example, the archetypal value type in C#: the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Two integers with the same value might as well be the same integer. That may sound
    obvious, but the important point is that we—and our programs—don’t care whether
    they’re the same <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in memory
    or two independent variables. All that matters is whether they have the same value.'
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, values have lifetimes that are beyond the technical boundaries imposed
    by scope or memory management. If two value type instances have exactly the same
    contents, and *that’s all that matters*, they’re indistinguishable from each other.
    For this reason, as you’ll see next, values are usually immutable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutability</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Values are sometimes characterized as being *eternal*: their lifetimes aren’t
    bounded by a variable’s scope within a program or even by the lifetime of the
    program itself. We can, in a sense, pluck values out of thin air to use them.
    When we need the number <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>,
    we just “materialize” it as a constant value.'
  prefs: []
  type: TYPE_NORMAL
- en: This characteristic isn’t limited to the built-in value types. The same is true
    of other values, such as a monetary amount like <samp class="SANS_TheSansMonoCd_W5Regular_11">$9.99</samp>,
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"To be, or not to be"</samp>,
    and the date <samp class="SANS_TheSansMonoCd_W5Regular_11">January 1st 2024</samp>.
    They’re *just there* when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, real variables certainly do have a measurable lifetime, and each
    instance requires storage, so we can’t simply dismiss the technical needs of our
    environment. Nonetheless, the theoretical view of eternal, immutable values is
    a useful way to model the way our own value types should behave.
  prefs: []
  type: TYPE_NORMAL
- en: When we add two numbers, we don’t change either of them; rather, we get a new
    number representing their sum. Similarly, adding a day to a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    or rounding an amount of money to the nearest whole dollar doesn’t alter the original—it
    produces a new value.
  prefs: []
  type: TYPE_NORMAL
- en: We can’t change the value of the number <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>,¹
    but we can produce a new number by using <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    in an expression with another number. If we add <samp class="SANS_TheSansMonoCd_W5Regular_11">^([1](#fn_1))</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp> doesn’t go away, even though
    we have a new number as a result of the expression. The same holds true for dates,
    speeds, lengths, temperatures, and other natural values. Values are immutable
    by nature.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability can seem like an unnecessary restriction when we’re creating types
    that represent values. After all, if we increase a speed value, we might not care
    about the previous value. Isn’t it usually more efficient to change a value in
    place than to create a new instance with a changed value? Well, perhaps—we’d have
    to measure that. However, immutability has other, more subtle consequences and
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Two immutable values—and remember from [Chapter 4](chapter4.xhtml) that read-only
    isn’t always the same thing as immutable—that compare equal will *always* do so.
    This has important implications for keys in hashed containers such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    collections. Hashed containers depend on the invariance of their keys. If we change
    the value of a particular key after it’s been added to a container, we can’t subsequently
    use the value to look up an item because, in a sense, we’ve altered that key’s
    identity by changing its value.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between state and instance identity is largely about equality.
    Specifically, when we check to see if one value equals another, are we interested
    in whether they have the same state or whether they’re the same object? If it’s
    the latter, we need a class. If it’s the former—we’re interested in the content
    and don’t care whether the variables are the same instance—we need a value type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mechanics vs. Semantics</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Microsoft documentation has a section entitled Framework Design Guidelines
    that includes advice on choosing between classes and structs but not much guidance
    on when value semantics are a positive choice for a type. Among other suggestions,
    the guidelines offer this ([*https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/dotnet<wbr>/standard<wbr>/design<wbr>-guidelines<wbr>/choosing<wbr>-between<wbr>-class<wbr>-and<wbr>-struct*](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct):)):'
  prefs: []
  type: TYPE_NORMAL
- en: Consider defining a struct instead of a class if instances of the type are small
    and commonly short-lived or are commonly embedded in other objects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This doesn’t seem unreasonable if we take it at face value. In particular,
    the rationale behind value types being small is directly related to memory usage
    and copy-by-value behavior: structs that have many fields take up more memory
    space, and the cost of copying a value from one location to another is correspondingly
    higher.'
  prefs: []
  type: TYPE_NORMAL
- en: However, this advice is focused purely on memory use and performance implications,
    and it’s silent on when we should use records or record structs. Other semantic
    differences between value types and other types exist that we should take into
    account. While recommendations like this can guide us, they tell only a small
    part of the story. Every application will have its own requirements, constraints,
    and behavior. We don’t have one single rule to apply that will be appropriate
    universally.
  prefs: []
  type: TYPE_NORMAL
- en: Policies that insist, or at least suggest, that value types have few data members
    and be short-lived focus on the technical mechanisms of memory representation
    and use, rather than the more conceptual premise of what behavior the type should
    exhibit. Values might often be small, but that doesn’t mean that all small types
    should be structs. A reference type might have only a single field, but that doesn’t
    automatically indicate that it should be a struct or other value-like type.
  prefs: []
  type: TYPE_NORMAL
- en: Correspondingly, just because we require a type that has several fields doesn’t
    mean that it can’t be a value type. If value semantics make sense for our type,
    we should make it a value type, regardless of how much data it carries with it.
    The number of fields required by an object shouldn’t be the main factor in our
    decision-making. If we’re worried about the cost of copying large values, we might
    endow a reference type with value-like behavior to address those concerns, a topic
    we’ll revisit in [Chapter 8](chapter8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: One way we can determine where we might use value types is to compare their
    characteristics with other types in a program. Although we can’t consider every
    possible object type for any potential application, some common categories of
    object roles are shared by many programs, as we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object Relationships</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object-oriented applications comprise a variety of objects with different roles,
    responsibilities, and interactions. These roles are characterized by the relationships
    between objects and how those objects collaborate to form a coherent application.
  prefs: []
  type: TYPE_NORMAL
- en: When we’re designing an application, it’s easy to overlook the central role
    played by values and value types. If we recognize their importance, we can often
    simplify our designs and make our programs clearer and easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: We might think of a value as simply the payload of a variable, whether that’s
    the representation of an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or the properties of an object on the heap. It’s tempting to view the values we
    use as incidental to an application’s purpose. Doing so can lead us to unduly
    rely on the built-in types and to oversimplify our custom value type implementations,
    resulting in what Martin Fowler describes as an *anemic domain model*.
  prefs: []
  type: TYPE_NORMAL
- en: The types used in an anemic design are perfunctory representations for common
    concepts in the design, especially for the value types. Such types often consist
    only of public properties, all of which have public getters and setters. They
    have no other associated behavior, instead relying on the surrounding code to
    perform common tasks such as data validation, calculations, and even managing
    comparisons. In turn, this leads to duplicated code, scattered error handling,
    and fragmented responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: The antidote to anemic design is a *rich domain model*, in which different kinds
    of types have individual roles and well-defined responsibilities. Each type incorporates
    behavior specific to it, rather than the behavior being scattered around the rest
    of the code. To successfully identify the types our applications require, we must
    recognize that objects aren’t all the same; however, objects in even the most
    complicated systems do fall into a few categories.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Kinds of Objects</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we don’t take care to partition our application’s roles, our design can
    end up becoming incoherent, making it difficult to manage and maintain. Once we
    recognize the main roles that different kinds of objects can play, we can classify
    the types we create by those roles, giving our designs more structure and making
    them easier to understand and work with. Objects fall broadly into one of four
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Values**'
  prefs: []
  type: TYPE_NORMAL
- en: Values are responsible for ensuring that an application’s data is valid and
    consistent and for controlling access to that data. They don’t usually outwardly
    collaborate with other objects in a system, except to contain other values. A
    value’s properties commonly don’t change over time, but new values with different
    properties occur frequently.
  prefs: []
  type: TYPE_NORMAL
- en: '**Services**'
  prefs: []
  type: TYPE_NORMAL
- en: Services are boundary objects that represent interfaces to systems that are
    external to the application. Services are often stateless; they can be used and
    accessed as they’re needed. They may be perpetual, meaning they are static types
    or have a global instance, or they’re ephemeral and instantiated as and when required.
    Services may be used by many objects but generally have few collaborations of
    their own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities**'
  prefs: []
  type: TYPE_NORMAL
- en: Entities are the higher-order design elements in an application. Whereas values
    are the currency of information, entities represent the transactions that use
    or act upon that information. They are often persistent, in the sense that they
    remain in memory rather than being created and destroyed often. They may change
    their properties over time—perhaps frequently—according to the needs of the system,
    and they collaborate often with other entities. An entity’s properties are generally
    either other entities or values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Controllers**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Controllers are the task objects in a system: they do things. Entities and
    controllers generally cooperate to perform activities. Controllers are often also
    persistent and may have some state, which is usually related to their collaborations
    with other objects. Controllers are frequently employed to mediate the interactions
    between entities and services.'
  prefs: []
  type: TYPE_NORMAL
- en: These are the application roles that define the behavior of a specific design
    and solution domain. These four are common in most systems, although not all applications
    will use or need all of them. Other categories of objects—such as collections,
    lifetime managers, and exceptions—have supporting roles in an application rather
    than being design elements in a system.
  prefs: []
  type: TYPE_NORMAL
- en: Values in C# are usually represented by structs, records, or record structs,
    although they can be modeled using classes, as you’ve seen with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    Each of the other roles will almost always be fulfilled by a class. Up to this
    point, the term *object* has been reserved for reference type instances. If we
    consider a value to be another kind of object, we have a common and uniform basis
    for comparing the characteristics of all the objects in an application.
  prefs: []
  type: TYPE_NORMAL
- en: The characteristics of a particular object, then, suggest the role it’s fulfilling.
    Put another way, we can identify an object’s role by looking at the characteristics
    of that object’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Characteristics</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The three non-value roles—service, entity, and controller—are strongly behavioral
    in the sense that we use them to perform operations or tasks. By contrast, values
    tend to have a passive role in a system and are generally used by other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior is one of three main characteristics shared by all objects in a system,
    as described by Grady Booch and his coauthors in *Object-Oriented Analysis and
    Design with Applications* (Addison-Wesley, 2007). The other two primary characteristics
    are state and identity (see [Figure 6-1](#fig6-1)), and the importance of each
    relative to the others is different for every application role.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Characteristics
    of objects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Booch and his coauthors describe the three characteristics as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object’s behavior describes what it can do or its visible attributes. Those
    two aspects are frequently interrelated: when an object performs an action, the
    result may change its visible properties. The visible properties may form part
    or all of an object’s state. A type’s public interface defines the behavior of
    instances of that type; that is, the interface tells us what an object can do
    rather than how it’s implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**'
  prefs: []
  type: TYPE_NORMAL
- en: The state of an object is defined by its member data, which may be persistent
    and immutable or may change over time. As just indicated, the state may be publicly
    visible in the interface or private and hidden, used only within the internal
    implementation of the type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**'
  prefs: []
  type: TYPE_NORMAL
- en: Every instance of a type has a distinct identity, which, as you’ve seen, allows
    us to distinguish one object from another. Identity is important when we need
    to know whether a variable represents a shared instance or a local value.
  prefs: []
  type: TYPE_NORMAL
- en: Each object role prioritizes different object characteristics, and in some cases,
    multiple characteristics are important for a given role. We can identify which
    role an object fulfills by looking at its profile in terms of these characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Values</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Of all the application roles, values attach the most importance to their state;
    it is literally their distinguishing feature. Values always have some kind of
    behavior associated with the concept they represent, but that behavior doesn’t
    alter the state. In most cases, the behavior is represented by properties to access
    the component parts of the state. A value might also have methods to return different
    representations of its state, or factory methods for creating new values. In any
    case, all of a value object’s behavior is directly related to its state.
  prefs: []
  type: TYPE_NORMAL
- en: Values are strongly typified by their equality semantics, where one value is
    equal to any other with the same state. They’re immutable and don’t usually collaborate
    with other object types. Values frequently use other value types as fields, as
    demonstrated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> types in [Listing
    6-5](#list6-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: Defining value
    objects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> structs implement the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> interface,
    similar to the value types we examined in [Chapter 5](chapter5.xhtml). Along with
    their properties, <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> both emphasize
    equality behavior, represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> protocol, although that behavior is secondary to and entirely dependent
    on their state (see [Figure 6-2](#fig6-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: Value object characteristics</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see how the state of a value object is its primary feature; we
    distinguish different values by their state rather than identity, and values with
    identical state can be used interchangeably. The behavior characteristic for values
    is less prominent than the state, although equality semantics certainly make it
    important. However, the identity of a value is immaterial, so it’s not shaded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Services</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Service objects often only encapsulate behavior and have no state. They generally
    provide some kind of façade or adaptation logic to interfaces that represent systems
    outside an application.
  prefs: []
  type: TYPE_NORMAL
- en: Identity usually isn’t important for service objects. Services may be global
    and have a well-known instance available throughout the application, or they may
    be created as required, but each instance is indistinguishable from all the others,
    since none has any state. Services are sometimes implemented as purely static
    interfaces (as a static class with only static methods), like the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetTime</samp>
    class in [Listing 6-6](#list6-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: Implementing a
    static service</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetTime</samp> class
    is a service that merely exposes a static method; it has no identity because there
    is no object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-3](#fig6-3) illustrates that the behavior of a service object isn’t
    just its most important characteristic—it’s frequently its *only* characteristic.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: Service object
    characteristics</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For services, like values, object identity is irrelevant, but for slightly different
    reasons. When a service object has an identity, such as when it’s implemented
    as a globally accessible object, we can substitute that instance with a different
    object, as long as its public interface is the same. As we know, values are interchangeable
    if they have the same state. Unlike values, services rarely have any state, so
    state and identity are both unshaded in [Figure 6-3](#fig6-3).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Entities</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Entities often do have some kind of state, which means we need to be able to
    distinguish one instance from another. An entity’s state is usually observable
    only through its behavior, which may involve either reading or modifying the state.
    Entities commonly don’t directly expose their state but instead provide methods
    to manipulate or access representations of it in different forms.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp> class
    in [Listing 6-7](#list6-7), which has a method to add purchases to the account,
    affecting the account balance. The balance itself isn’t represented directly as
    state in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp> class
    but is calculated from outstanding charges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: Creating an entity
    object</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Entities may also have behavior that doesn’t relate directly to their state
    but perhaps updates or modifies another entity object parameter. Abstract and
    virtual methods are a fairly common feature of entity types (as in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp>
    entity here), allowing them to be inherited, with derived types customizing the
    base class behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We’re usually interested in using a specific instance of an entity type, so
    object identity is critical, regardless of whether we have multiple instances
    with identical state.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 6-4](#fig6-4), then, entities place fairly high importance
    on all three object characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: Entity object characteristics</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Controllers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Controllers also often have some state, but they differ from entities in that
    the state affects the way controllers perform their task. One example is a database
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object whose state
    includes a connection to a data source and a representation of an SQL instruction.
    A controller may well expose its state publicly and even allow it to be directly
    changed, affecting the controller’s behavior. For example, consider how the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp>
    method uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> property
    in [Listing 6-8](#list6-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: Defining a controller</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object allows
    us to change its SQL instruction via the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    property. We can repeatedly call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp>
    method on one <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> instance
    to obtain different results, rather than creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    object for every query.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers, as illustrated in [Figure 6-5](#fig6-5), are principally characterized
    by identity and behavior. They depend on their state to some degree but tend to
    rely on it less than entities do, because that data is used to support or modify
    the controller’s behavior rather than being a hidden implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: Controller object
    characteristics</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Individual implementations of controller objects may attach more or less importance
    to their state or their behavior, depending on their specific requirements. However,
    as with entities, a controller object’s identity is almost always significant,
    because we need to be able to distinguish between different instances. Reference
    semantics are often important for both entities and controllers so that any changes
    to an instance are reflected by all references to it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Design Refinement
    to Model Object Roles</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The three characteristics of identity, state, and behavior give us a relatively
    simple metric we can apply to determine whether an object most closely resembles
    a value, entity, controller, or service. We can use this information to refine
    a design or to refactor code. Looking at an object’s characteristics might tell
    us that it has too much responsibility or represents a mixture of application
    roles, and we should adjust the code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: An object that’s highly dependent on its state, and that has different instances
    with identical state that are considered equal, is a strong contender for being
    a value. If the identity of a specific instance is important, however, it most
    likely shouldn’t be a value, so we’d look to the other characteristics to determine
    which of the non-value roles it best represents. If we can’t clearly identify
    a specific role based on an object’s characteristics, we should take the opportunity
    to decompose the type to better model individual roles with separate abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a system, programmers often look for the main characters—that
    is, the service, entity, and controller roles. Identifying value type candidates
    isn’t always so straightforward, which may be one reason they’re often represented
    by the built-in types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: An object should have a single responsibility and fulfill just one application
    role. By being mindful of the relative merits of identity, state, and behavior,
    we can more closely and clearly model our objects’ roles. Because values place
    so much importance on their state, everything about a value is focused on that
    state, whether obtaining, reporting, or manipulating it. Identifying the value
    types in an application helps us simplify our design by partitioning responsibilities
    and encapsulating behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Abstraction and Vocabulary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some objects stand out as good candidates to be values—for example, simple measurements
    and quantities, such as speed, temperature, distance, length, and money. Such
    objects are often simple wrappers around primitive types like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Each logically
    represents a single concept as an abstraction. We can’t easily decompose them
    other than to revert to using primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: We use the names of these types to form part of the *vocabulary* of a program.
    We write the program in terms of specific concepts like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> rather than more
    general-purpose types like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    More than that, when we talk to other people working on the same project, the
    names we use match the names in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Using a specific named type instead of a built-in primitive type also prevents
    simple errors, such as mistakenly using a temperature value when we mean to use
    a length. If, for example, we pass an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    type to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>,
    the program won’t compile. Such errors are easy to miss when we use built-in types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to represent
    values for both length and temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Other value candidates are less easily represented with primitive types because
    they consist of multiple components. Types to represent concepts such as currency
    rates of exchange, color spaces, Cartesian coordinates, and telephone numbers
    each have several related parts. Still, they all represent distinct abstractions
    to which we can give meaningful names like <samp class="SANS_TheSansMonoCd_W5Regular_11">FxRate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PhoneNumber</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The names we give our types should provide vital information about their purpose.
    We could collect the red, green, and blue components of an RGB color space into
    a simple tuple type, but it would be hard to distinguish such a value from a tuple
    containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> components of a three-dimensional
    coordinate value. Creating separate user-defined types for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> makes our
    code easier for other programmers to understand.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the name of an abstraction, we’re implicitly referring to the behavior
    associated with that abstraction. The name becomes shorthand for the concept and
    is most easily understood when the type representing that abstraction is a single,
    cohesive idea and its behavior is well encapsulated. Value types are a rich vein
    for exploring those ideas, although the same principles apply for all types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encapsulation and Cohesion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we’re designing our own type, beyond giving it a name that conveys its
    purpose, it’s also beneficial to collect the behavior that’s appropriate for the
    abstraction we’re modeling. This is what’s commonly meant by *encapsulation*:
    assembling the object’s data and the methods that support it. However, encapsulation
    is much more than just adding member methods; we also need to keep in mind a type’s
    cohesion, which is a much less tangible concept.'
  prefs: []
  type: TYPE_NORMAL
- en: A type is *cohesive* if the operations defined for it all work together to provide
    a well-defined and sensible interface for using instances of the type. In other
    words, cohesion means that the concept of the type makes sense as a whole. In
    this context, we’re talking about whether other programmers find a type easy to
    comprehend. The compiler cares only about what’s syntactically correct, but we’d
    likely be surprised to find a method for converting a string to uppercase on a
    type mostly concerned with money.
  prefs: []
  type: TYPE_NORMAL
- en: A type is more than just a place for defining methods; those methods should
    contribute to the abstraction we’re trying to represent. Conversely, as mentioned
    earlier, a type with no behavior at all, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type in [Listing 6-9](#list6-9), is often simplistic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Anemic type design</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct isn’t
    encapsulating anything, and its <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property might just as well be a public field. Although the name of the type gives
    us a clue as to its intended purpose and at least allows the compiler to catch
    many inappropriate uses, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is an example of an anemic type. Any behavior we add should support and contribute
    to the abstraction implied by the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: This advice applies equally to all types in a system, not just the value types.
    Whatever the purpose of the types we create, we need to capture individual abstractions
    in our designs. Good abstractions are well encapsulated; they don’t leak their
    implementation details. A type that is cohesive is easier to comprehend than one
    that’s just a collection of methods. Encapsulation and cohesion both contribute
    to the quality of the abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the objects we create have some kind of state, but that’s not the same
    as them representing values. For value types, the abstraction we’re representing
    *is* that value. If we’re defining a type to represent a speed, the operations
    we define for the type should present an interface consistent with a generally
    accepted notion of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    The value is the core of the encapsulation and cohesion we want to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The term* encapsulation *is sometimes used to mean merely data hiding. While
    it’s certainly true that exposing fields directly is usually a bad idea, as we’ll
    talk about shortly, encapsulation involves more than making data private. Encapsulation
    has a close relationship with cohesion, and in concert they play an important
    role in designing types that are easy to use correctly and hard to use incorrectly.*^([2](#fn_2))'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Eliminating Duplication</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encapsulating behavior into a named type allows us to capture common code in
    one place. As you saw in [Chapter 1](chapter1.xhtml), sensible values for a speed
    fall within a specific range, so attempting to use a speed with a value outside
    that range should be an error. If we use an overly simple type to represent a
    speed, we must duplicate those validation checks everywhere a speed value is used,
    which might be in multiple places. Consider the methods in [Listing 6-10](#list6-10),
    which use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct
    from [Listing 6-9](#list6-9). We must validate the value for every use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-10: Duplicated validation
    code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To protect these methods from invalid speed values being passed as arguments,
    we must validate the parameter to ensure that it’s not larger than the maximum
    allowed value, it’s not negative, and it’s a real number. The tests we use are
    the same for every method using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    and we should also validate the values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance</samp> parameters.
    It would be easy to forget one of these checks when we write a new function that
    uses a speed, time, or distance, or to accidentally use the wrong value for the
    maximum allowable speed.
  prefs: []
  type: TYPE_NORMAL
- en: The duplication of the validation code is also a maintenance problem. If we
    need to alter the acceptable range of values for speeds, we have to make sure
    we change it everywhere it occurs. We also need to test the validation logic in
    every method where it’s applied, so those tests will also be duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: If we instead encapsulate the validation logic within a constructor for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, we can test its characteristics
    in only one place and in isolation from other tests we need. We won’t need to
    worry that the values might be out of range for methods using <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values. Any method using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can rely on the validation it encapsulates. We can remove the duplicated validation
    code as well as any duplicated tests.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Establishing Class
    Invariants</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a constructor that performs all the necessary validation for a type’s
    value is an example of establishing a *class invariant* (where *class* has to
    do with type theory rather than the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>
    keyword). This approach ensures that all instances have values that make sense
    for the type.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-11](#list6-11) shows how we can combine a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression with pattern matching to efficiently perform numeric validation in
    a constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-11: Defining a simple
    value type with validation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    ensures that we’ll never have a value that is not a number, is negative, or is
    greater than the speed of light.
  prefs: []
  type: TYPE_NORMAL
- en: The patterns within the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression are matched from top to bottom, and wherever the value being tested—the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> parameter in this case—matches
    the pattern, the associated expression is evaluated to produce a result. The first
    two patterns here are the error conditions and throw exceptions instead of producing
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first pattern is a constant pattern matching <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>,
    as you saw in [Chapter 5](chapter5.xhtml) ❶. The second pattern throws an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRange</samp> exception if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> is either less than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or greater than the constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp> ❷. This pattern uses a
    combination of facilities available since C# v9.0: a relational pattern and a
    disjunctive pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The *relational pattern*, which is appropriate for any of the built-in numeric
    types, uses the relational operators <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> to determine whether
    a number is within a given range. The *disjunctive pattern* combines other patterns
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> keyword,
    and the pattern matches if any of its expressions match. The similar *conjunctive
    pattern* (not used here) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    keyword and matches if all of its component expressions match.
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> value doesn’t
    match either of the first two patterns, it matches the final discard pattern,
    whose expression is simply the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>
    ❸. This becomes the result of the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression and is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field. Since the discard is always a match, it must be the final pattern in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to encapsulating validation logic within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we’ve made <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> immutable
    to ensure that an instance, once successfully validated, can never become invalid.
    If the state can’t be changed, the class invariant needs to be checked only once—in
    the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clarifying with Symmetry</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The role of symmetry in an interface is often underestimated, but it can be
    important in making our types easy to use and understand. For instance, you saw
    in [Chapter 1](chapter1.xhtml) how class factory methods can help us represent
    units for a type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    We use such methods instead of directly accessing a public constructor, and each
    method encapsulates the name of the units it represents. [Listing 6-12](#list6-12)
    shows how we can couple the class factory methods with their corresponding properties
    to obtain a value in different units.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-12: Applying symmetry
    by pairing class factory methods with their respective properties</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’d probably expect that if we can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by using a value in kilometers per hour, we could get the value in the same unit
    at a later stage. We emphasize the symmetry between each class factory method
    and its corresponding property by declaring each pair for a particular unit together.
  prefs: []
  type: TYPE_NORMAL
- en: The methods and properties in [Listing 6-12](#list6-12) don’t prevent us from
    using the wrong units. We could still pass a value in <samp class="SANS_TheSansMonoCd_W5Regular_11">kmh</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>
    factory method. However, by encoding the units that we’re using in the names of
    the class factory methods and properties, we make them more explicit and more
    expressive than using a plain constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Being explicit helps to make the interface to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    consistent and easier to use correctly than incorrectly. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type has become much more than a simple wrapper around a primitive value.
  prefs: []
  type: TYPE_NORMAL
- en: Using explicit names like <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp> to represent the
    available conversions for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance helps maintain the encapsulation of the internal representation. A constructor
    taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameter,
    along with a vaguely named property to simply return that value, leaks the detail
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> has a particular
    underlying representation. The class factory methods and properties shown here
    hide these implementation details and add value for users in the form of some
    common conversions.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily imagine using similar class factory methods and properties to
    convert between units for other types, such as between Celsius and Fahrenheit
    for temperature, or meters and feet for length.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encapsulation and the Public Interface</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it involves more than making data private, encapsulation is built on the
    premise that a type’s internal data can’t be directly accessed—and especially
    can’t be changed—by code other than the type’s methods. Access to private data
    is controlled by the type’s public interface.
  prefs: []
  type: TYPE_NORMAL
- en: Well-encapsulated types aid us in reasoning about code because we can always
    be sure that private fields have consistent values, and that those values can
    never change without our knowing about it. More than that, it means that, as designers,
    we can change the underlying representation without changing the interface. If
    we never directly expose a type’s data, no code other than that type’s member
    instance methods can ever depend on its representation.
  prefs: []
  type: TYPE_NORMAL
- en: By encapsulating the <samp class="SANS_TheSansMonoCd_W5Regular_11">double amount</samp>
    field of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> as private
    and exposing or operating on it only under the controlled conditions afforded
    by member methods and properties, we limit the scope and impact of changing the
    representation to just those members.
  prefs: []
  type: TYPE_NORMAL
- en: Correspondingly, if we limit the number of members with direct access to a field,
    we reduce the scope of the change even further. If we write methods that depend
    only on the public interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    they’ll continue to work even if we change the underlying data type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending the Interface</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we add too many instance methods to any type, we risk cluttering its interface.
    The core interface of a type is harder to discover when the type has methods that
    are only occasionally useful. By contrast, keeping the methods of a type to a
    reasonable minimum makes the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: One alternative to instance member methods is to use extension methods, which
    are defined outside the type they extend. An example extension method for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is shown in [Listing 6-13](#list6-13),
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    method uses the public methods and properties defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> with
    a different value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-13: Extending the
    interface of Speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp> method
    doesn’t modify the instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    passed to it—it can’t, because <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is a read-only struct. Instead, we return a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    with the desired value. An extension method must be defined in a static class,
    so it’s always a static method. It’s common to group methods that extend a particular
    type together in one static class definition, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">SpeedExtensions</samp>
    class might include several methods to extend the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods are useful for adding utility methods to a type without overburdening
    its principal internal interface.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reducing the Internal
    Interface</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A type’s interface defines the collaborations that objects of that type can
    have with other objects in a system. The public methods, constructors, and properties
    defined within the type form the *internal*, or *intrinsic*, interface and define
    what other objects can do with instances of the type. A type also has an *external*,
    or *incidental*, interface comprising methods that take parameters of the type
    but are defined outside it. The external interface defines which other objects
    depend on the type. Those external methods can’t access the type’s internals,
    so they’re unaffected by any changes to the underlying representation.
  prefs: []
  type: TYPE_NORMAL
- en: The essential characteristics of a type with many public members can be difficult
    to discern because the physical definition of the class becomes large. If we restrict
    the internal interface members to those that require access to the type’s private
    implementation details, the type definition becomes shorter and thereby easier
    to comprehend. Methods that can be implemented entirely in terms of the internal
    public interface can be factored out into separate classes. Whether to make them
    extension methods or plain static methods depends on which is the most natural
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: The logical conclusion is that, where possible, we should actively try to reduce
    the internal interface as much as we can without breaking the type’s encapsulation
    or reducing its cohesion. This approach has two competing perspectives. On one
    hand, by extracting methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    that are implemented in terms of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    other public methods, we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    smaller and easier to comprehend. We also reduce the potential impact of any changes
    we might make to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    internal representation. On the other hand, <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    is still part of the overall accessible interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    and by extracting that method out separately, we make it harder to discover.
  prefs: []
  type: TYPE_NORMAL
- en: We must find the balance between the internal and external interfaces of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    method may be a useful utility for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values, it isn’t really intrinsic to the concept of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    Extracting it as an extension method doesn’t reduce <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    cohesion or break its encapsulation by requiring us to introduce a new property
    that would otherwise be unneeded or change a private member to be public. Collecting
    extension methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    in one place is one way to make the external interface easier to discover.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> class factory
    method, on the other hand, is much better suited as a member of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    We could implement it as a static method on a different type and in terms of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>. However, doing
    so would reduce the cohesion of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp> naturally go
    together. If we extracted both of those methods to a separate type, we’d need
    to make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor
    public, reducing its encapsulation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    method is intrinsic to the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    because it represents a way to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    in specific units and has a natural affinity with other intrinsic methods.
  prefs: []
  type: TYPE_NORMAL
- en: Some methods *must* be members of their type, even if they could conceivably
    be implemented in terms of other public properties and methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    method overrides a base class implementation and must be an instance method. Overloaded
    operators must all also be static member methods. An operator overload takes at
    least one parameter of the type of which it’s a member, so we can’t implement
    it in a separate type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Composing Abstractions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Values can be more than simple wrappers around primitive types such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. A struct can contain other
    user-defined types as fields, so we can create new abstractions by composing existing
    ones. We might, for instance, create our own type to represent a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>,
    which combines a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type. Although
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type in [Listing
    6-14](#list6-14) has no behavior of its own, it can take advantage of the richer
    abstractions represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-14: Composing a new
    abstraction for Velocity</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type benefits
    from the validated constraints on the possible values of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and can use any
    of their public operations and properties, including any extension methods. Building
    on those contained types, we can add to <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    any behavior that’s specific to it, such as arithmetic operations or conversions
    to and from different representations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> represents a specific
    single concept, even though it’s a kind of container for values of other types.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> aren’t
    arbitrary; they define what it means to be a measurement of velocity. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> abstraction forms part
    of the vocabulary of a program, along with <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> is a good candidate
    for implementation as a record or record struct, particularly using the compact
    positional syntax available for those types. However, the positional syntax is
    less well suited for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types. To explain
    why, in the next section we’ll look at some of the trade-offs and compromises
    among the different ways of defining types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing Between Value and Reference
    Semantics</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most programs, the majority of user-defined types will be classes, which
    support the widest array of features offered by C#. Classes are the most general-purpose
    way in C# of creating our own types because they support all the object-oriented
    facilities of the language, such as inheritance and virtual methods. Class instances
    also benefit from the automatic memory management afforded to objects allocated
    on the heap. Generally, only when we need the behavior associated with value semantics
    should we define a type differently.
  prefs: []
  type: TYPE_NORMAL
- en: We have a few indicators that value semantics are appropriate for a type we’re
    defining. Values shouldn’t support changes to their state, which is why it’s recommended
    that value types contain only other values. When all value types are immutable,
    regardless of whether they’re implemented using classes, records, structs, or
    record structs, we don’t have to worry about the state of an object changing unexpectedly,
    because the behavior of our code is more predictable. A type that requires unrestricted
    write access to its state is usually a poor candidate for being a value.
  prefs: []
  type: TYPE_NORMAL
- en: A related indicator is needing the type to support a full deep copy of its state.
    We need a *deep copy*, also known as a *clone*, to copy mutable state when we
    want to avoid the side effects associated with aliasing references. Most commonly,
    the state needs to be written only immediately after cloning so that the new object
    can have different properties than the original. The non-destructive mutation
    facility we examined in [Chapters 2](chapter2.xhtml) and [4](chapter4.xhtml) is
    a good example of providing limited mutability for value-like types.
  prefs: []
  type: TYPE_NORMAL
- en: Anytime we customize equality behavior for a class so that two instances can
    be compared according to their state, it’s another strong indicator that the type
    should be implemented as a full-fledged value. Cloning is often accompanied by
    an overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
  prefs: []
  type: TYPE_NORMAL
- en: State-based equality behavior and support for deep copies to avoid aliasing
    problems are two of the strongest signs that value semantics are needed. Although
    it’s possible to use a class to implement a value (as we’ve seen with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>),
    the other kinds of type definition are usually preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Records, structs, and record structs are all facilities for creating types that
    represent values—that is, for defining types that have *value semantics*. The
    choice between them isn’t necessarily obvious, as each has different advantages
    and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding the Pitfalls
    of Default Variables</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For struct and record struct types, we need to remember that instances can
    always be default-initialized, so the default value must be considered valid both
    by the type’s implementation and by code using the type. For simple numeric types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>,
    this isn’t a problem. The default value for such types is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    which is a perfectly acceptable state no matter the unit: 0 meters is precisely
    the same value as 0 miles or 0 inches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is not universally true for all values. In temperature measurements,
    for example, the unit of the stored value matters: 0°C is 32°F, and 0°F is approximately
    –17.78°C. We might establish the convention that the default unit for <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    is Celsius, but it’s hard to make that explicit without having a separate type
    for each unit, which seems unnecessary.'
  prefs: []
  type: TYPE_NORMAL
- en: If we use a class or record instead of a struct or record struct, we can prevent
    default values and force our users to specify the correct units when creating
    instances. However, classes and records are both reference types, meaning that
    variables can have a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value. We can mitigate that in C# v8.0 and later by taking as much advantage of
    non-nullable references as we can, although that might not prevent every possible
    misuse.
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding that, when we’re deciding between a class or record to model
    a type that has value-like characteristics, a record is almost always preferable.
    Records are specifically intended to define types that have value semantics, and
    the compiler provides the default equality behavior for records based on the state
    of the instances being compared.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Custom
    vs. Generated Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want a class to have value-based equality, we must define it ourselves.
    As a minimum, we should override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods,
    but, as you saw in [Chapter 5](chapter5.xhtml), a more complete definition includes
    implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>
    interface and overloading <samp class="SANS_TheSansMonoCd_W5Regular_11">operator=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, and its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    to make equality comparisons natural and easy.
  prefs: []
  type: TYPE_NORMAL
- en: For most value-like types, implementing those methods is straightforward as
    long as we’re careful to avoid common mistakes. However, if we use <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>, the compiler
    generates implementations for all those methods. This makes a record type definition
    smaller and easier to comprehend and saves us from having to remember all the
    potential pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: For our prospective <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    type, we might consider a positional record, saving us the trouble of a complete
    definition. A provisional implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    as a positional record might look like the definition in [Listing 6-15](#list6-15),
    but positional records have limitations to take into account.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-15: A positional
    Temperature record</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler uses the parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>’s
    definition to automatically generate a property named <samp class="SANS_TheSansMonoCd_W5Regular_11">InCelsius</samp>,
    but we must write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">InFahrenheit</samp>
    property so we can add the code to perform the conversion. Users can invoke the
    class factory methods to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    instances with different units, but the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    generated by the compiler is *public*. The generated constructor also won’t validate
    its parameters, and we might want to ensure that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    can’t be below absolute zero.
  prefs: []
  type: TYPE_NORMAL
- en: If we want users to be explicit about the units, we need to force them to use
    those class factory methods, so a positional record doesn’t meet our needs. For
    the same reasons, the positional syntax isn’t appropriate for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types we used in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> in [Listing 6-14](#list6-14).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding Generated
    Methods</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the positional record syntax won’t meet our needs, we can use a full record
    definition, which doesn’t have the positional type arguments. We can then provide
    our own *private* constructor and use that to validate the initial value.
  prefs: []
  type: TYPE_NORMAL
- en: We sacrifice some of the convenience of using a positional record for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp> because we have to
    write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">InCelsius</samp> property,
    since the compiler generates properties only for positional records. The record
    definition in [Listing 6-16](#list6-16) shows how we can customize behavior for
    a record type while still enjoying the benefits of the other code provided by
    the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-16: A full record
    definition for Temperature</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will still generate the methods to implement value-based equality
    for a nonpositional record, leaving us to concentrate on correctly implementing
    any other behavior specific to a record type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Records and record structs offer the greatest benefit over classes and structs,
    respectively, when we can accept all the default behavior of the positional syntax.
    A good example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type from [Listing 6-4](#list6-4), which as a positional record struct would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, a default-initialized
    instance is a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and compares equal to an instance with properties that are all <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We don’t have to add any of our own methods or properties, so the positional
    syntax is compact and does exactly what we need.
  prefs: []
  type: TYPE_NORMAL
- en: Records and record structs can be convenient for defining simple value types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, although the
    compiler might not provide everything required by a type. In particular, if we
    need to compare two values to see if one is less than the other, we must always
    provide our own implementation of that comparison.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparison for Ordering</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principle of value-based equality is the *one thing* that defines what it
    means to be a value. When we talk about whether something is a value type, that’s
    really shorthand for whether two instances compare equal according to their state
    or according to their identity. Using state as the basis for equality is intrinsic
    to all values. However, some values may be equivalent but not necessarily equal.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, two values are equal if they have exactly the same state. Two instances
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> record struct
    in [Listing 6-17](#list6-17) are equal if all the properties are also equal, whereas
    the identity of individual <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    instances isn’t important.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-17: Value type equality</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Some, but not all, values have a natural ordering, which enables us to sort
    collections of them. Many sorting algorithms exist, but all generally work by
    comparing each item in a collection with the others in turn to determine whether
    one is less than the other. If the left-hand value is less than the right, the
    items are considered to be in order.
  prefs: []
  type: TYPE_NORMAL
- en: We can customize the meaning of *less than*, and therefore *in order*, for our
    own purposes. In C#, the protocol for defining *less than* is the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> interface, which requires us to implement a single method named <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> for a type. If the left
    argument is less than the right, <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    returns a negative integer; if the right is less than the left, the result is
    positive. Otherwise, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values to see if they’re equal, we use all the properties. For ordering, however,
    we might care only about the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    property, because we merely want to put the entries in the order in which they
    were logged. Ordering <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values by message makes little sense, and ordering them by severity isn’t necessary
    for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    instance, which itself implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    interface, so [Listing 6-18](#list6-18) implements <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> simply by comparing
    only the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp> properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-18: Defining ordering
    by TimeStamp for a LogEntry value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We normally wouldn’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    on a <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> instance directly;
    it would usually be invoked indirectly when we sort a collection of <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values. Unless we explicitly specify a different comparison to be used for sorting,
    our <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> method will
    be used to determine how to order <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    elements, so the default ordering for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values is based solely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Values have *extensionality*: two instances are equal if they have the same
    observable properties. This isn’t necessarily the same as having the same structural
    definition, called *intentionality*. It’s possible, although relatively rare,
    to need extra data that doesn’t contribute to the value in a meaningful way and
    thus isn’t used in a test for equality. Such data is usually also a private detail
    of the implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between intentionality and extensionality becomes more important
    when we want not only to compare values for equality but also to order them. Putting
    values in order requires a different but closely related comparison, which may
    result in two unequal values being equivalent for the purposes of sorting them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equivalence vs. Equality</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most value types, if <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, then the two values
    are indeed equal, and calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. This is
    the case for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value underlying our <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    property. However, while this result is what we’d normally expect, it’s not a
    strict requirement. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method should return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> when
    neither value is less than the other, although those values may not actually be
    equal. Rather, the values are *equivalent* for the purposes of ordering.
  prefs: []
  type: TYPE_NORMAL
- en: With our <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> value,
    two values are equivalent when their <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    properties exactly match. Even so, the two values might very well be *un*equal
    because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Severity</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp> properties might
    be different, as the simple test in [Listing 6-19](#list6-19) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-19: Equality versus
    equivalence for LogEntry</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code shows no contradiction: the two entries have clearly different values,
    but for the purpose of sorting <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    instances, they’re nevertheless equivalent because it doesn’t matter whether one
    goes before or after the other. Equivalence doesn’t necessarily imply equality,
    and we should avoid the temptation to implement equality in terms of <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: A fairly common example demonstrating the difference between equivalence and
    equality is comparing string values. Sometimes we want to use a case-insensitive
    string comparison for ordering but not for equality. The two string values <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"September"</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">"september"</samp>
    might be considered equivalent for sorting, but they’re clearly not equal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Contract for
    Comparisons</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must meet certain expectations for the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method. In particular, comparing a single value with itself should report equivalence;
    that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">x.CompareTo(x)</samp> must
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. More generally, for
    two objects that are equal according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> should
    return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    interface is a contract, and the semantics of comparing one object with itself
    is just one aspect of that contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    implementation to define the comparison operator <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>, which gives
    us a natural way to see if <samp class="SANS_TheSansMonoCd_W5Regular_11">log1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">log2</samp>
    and a more compact way of expressing the rest of the contract. The contract for
    the less-than relationship specifies that it has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Irreflexive**'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is always <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '**Antisymmetric**'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> must be <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transitive**'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    must also be <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable**'
  prefs: []
  type: TYPE_NORMAL
- en: The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> remains the same as long
    as neither value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe**'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing values of the same type does not throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: We can define <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp> for reference
    types in a similar way, although we also need to consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, which should always compare less than any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Kinds of Ordering</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ordering by <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> is an example of ordering
    by magnitude, but other orderings are possible. Strings commonly use a *lexicographical*
    ordering, which broadly means that one string is less than another if it would
    appear before the other in a lexicon, better known as a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other values are ordinal in nature, such as months of the year. Ordinal comparisons
    sometimes need a bit of care. Take days of the week in English as an example:
    should Sunday come before Monday? The answer to that question depends on how we
    define the first day of the week.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some values aren’t intrinsically less than another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type is an example: red comes before blue when we enumerate the colors in a rainbow—a
    property of their relative wavelengths—but blue certainly comes before red in
    an English dictionary. We might apply one of several orderings to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    objects under different circumstances, but those definitions of ordering are external
    to the concept of a color.'
  prefs: []
  type: TYPE_NORMAL
- en: We can customize the ordering of elements in a sequence on a case-by-case basis
    by creating our own comparer, or even multiple comparers to address different
    scenarios. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparer< T ></samp>
    interface complements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> interface from [Chapter 5](chapter5.xhtml). Just as <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> establishes an equality comparison that’s external to the types being
    compared, an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparer<
    T ></samp> is an externally defined ordering comparison. [Listing 6-20](#list6-20)
    shows a custom comparer type for ordering <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    objects by their <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>
    property rather than by time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-20: Defining an external
    comparer for LogEntry objects</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantics of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare</samp>
    method match those of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable.CompareTo</samp>,
    returning a negative integer when <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, a positive
    integer when <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is less than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    otherwise. Several of the sorting algorithms in the Standard Library have overloads
    that accept an explicit comparer object as an argument, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">Order</samp>
    method shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">alphabeticalLog</samp> is
    a new list of <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> elements
    sorted alphabetically by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntryComparer.Compare</samp>
    comparison. Similar overloads are provided for <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Sort</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.BinarySearch</samp> and the constructor
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">SortedList</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering is a common characteristic of values, but not an essential one in the
    same way that value-based equality is. When a value has a natural ordering, implementing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> method makes
    sense. Reference types, on the other hand, generally don’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    unless they also override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Mixing identity-based equality with value-based ordering, or vice versa, will
    likely lead to confusion and probably errors that are hard to track down. In particular,
    references have no natural ordering; saying that the value of one reference is
    less than another makes no sense.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Perils of Uniformity and Consistency</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes coding guidelines advise that we should override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and implement <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> for
    every type. The thinking behind such rules is usually to try to remove restrictions
    on the use of objects. Types that don’t implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    can’t be used as keys in a <samp class="SANS_TheSansMonoCd_W5Regular_11">SortedList</samp>.
    Types that don’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> can’t be
    used reliably as keys in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>.
    While we can use an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparer<
    T ></samp> to address the former, and a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> for the latter, we must remember to explicitly use those implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Such guidelines aim to improve consistency and remove the barriers to commonplace
    requirements. The goal is usually to enable *any* object to be used as a key in
    a hashing container, or collections of them to be sorted according to their state,
    without needing explicitly defined external comparers.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines that suggest this kind of uniformity ignore the fact that values
    and non-values are semantically and conceptually different, and the differences
    go far beyond the technical characteristics of reference types and value types.
    Reference semantics have their own desirable characteristics, especially when
    we actively need multiple aliasing references to a single, mutable instance. Those
    characteristics don’t lend themselves well to being used as keys in collections,
    and they often cause conflict with ordering too. A sorted collection of mutable
    objects can easily become *un*ordered by altering the state of its elements, which
    gives us one more reason for all our value types to be immutable. A collection
    of values that has been sorted should remain sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve discussed, some types have no natural ordering. Let’s revisit the
    example of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. Insisting
    that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp> interface
    would leave us with a problem: how should <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    behave for two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values?
    We could choose one plausible implementation, but that might not satisfy every
    use case, leading to difficulties in other aspects of our code. This is why, while
    records and record structs provide a default implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface, they don’t also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp>. Even when the individual fields can be compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>,
    it doesn’t always mean that the whole type can be compared that way. All the fields
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values that implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    int ></samp>, after all, but *less than* isn’t a meaningful comparison for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of overriding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for value types isn’t primarily to allow them to be used as keys. Values
    have no use for referential equality, because one value is as good as any other
    value with the same properties. Value-based equality is the single, natural way
    to compare those variables that are values.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types, by contrast, often depend on identity-based equality. Any type
    not specifically intended to have value semantics probably shouldn’t be used as
    a key in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arithmetic and Nonarithmetic
    Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as not all values have a natural ordering, some values are arithmetic by
    nature, and some are not. We might, for example, define operations to allow instances
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type from [Listing
    6-11](#list6-11) to be added together. Operations like addition have a natural
    representation with arithmetic operators, such as in an expression like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">startingSpeed</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed.FromKmh(10)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing support for arithmetic operations, or indeed any operation, requires
    a certain amount of discretion on our part as designers. We need to be mindful
    of both the common use cases for the types we create and the wider expectation
    from, for example, being able to add two instances together with a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> type in [Listing 6-17](#list6-17)
    isn’t arithmetic in nature, so we should avoid overloading the arithmetic operators
    for it. Adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    instances makes no sense.
  prefs: []
  type: TYPE_NORMAL
- en: It does make sense for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    to overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and
    its counterpart <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for equality comparisons. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    type is a record struct, so the compiler will provide the equality operator definitions
    automatically. Since we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    LogEntry></samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>,
    we should also consider overloading <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator></samp>, which the
    compiler won’t provide. [Listing 6-21](#list6-21) shows that implementing these
    operators in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-21: Equivalence comparison
    operator definitions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: These operator definitions make handling equality and comparisons much more
    natural for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> instances.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nonstandard Operator
    Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Occasionally, arithmetic operators are useful beyond truly arithmetic operations.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instances
    can be “added” together, and most programmers understand that adding two strings
    concatenates them, so <samp class="SANS_TheSansMonoCd_W5Regular_11">"key"</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"board"</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">"keyboard"</samp>. In arithmetic,
    addition is commutative, so <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    gives the same result as <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    This clearly isn’t true when used with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instances, but concatenating two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>s
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> is a widely used and
    accepted convention.
  prefs: []
  type: TYPE_NORMAL
- en: When we bend the rules this way, it’s especially important that we’re mindful
    of conventions, natural usage, and expectations. For instance, in arithmetic the
    ability to add numbers together goes hand in hand with the facility for subtraction.
    Consider what subtracting one string from another might mean. Would it remove
    all instances of the right-hand argument from the left-hand string? Only if it
    appeared at the end of the string? String subtraction doesn’t have the natural
    and conventional appeal that string addition/concatenation does.
  prefs: []
  type: TYPE_NORMAL
- en: We’d normally expect to find a symmetry between <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and symmetry is usually
    a desirable quality. When we overload <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    the compiler insists that we also implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator. Coupling addition with
    subtraction for <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> values
    is one example where symmetry is undesirable, because it introduces conflicting
    expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetry is inappropriate in other situations too. For example, matching every
    property <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor with
    a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> is superficially
    attractive but contradicts the recommendation that value types are immutable.
    This is another instance where we need to apply our own judgment on whether symmetry
    is a positive characteristic.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*It’s not hard to make decisions when you know what your values are.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Roy Disney, American film writer and producer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although C# has its own definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    the broader concept of a value isn’t specific to C#. That more general idea of
    a value type has commonalities with the C# definition, but notable differences
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: The language definition of a value type focuses mainly on the memory requirements
    and behavior associated with structs. We need to take other factors into account,
    however, in order to decide when and how to introduce values into our programs.
    In this chapter, we’ve explored some of those considerations by contrasting values
    with reference types—in particular, by examining how values fulfill specific and
    important roles in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented systems are made up of several kinds of objects with varying
    emphasis on the characteristics of identity, state, and behavior. When an object’s
    role places a high importance on instance identity, it’s a strong indicator that
    the type shouldn’t be a value type. When the priority is an object’s state and
    identity is unimportant, the type is almost certainly best modeled as a value.
  prefs: []
  type: TYPE_NORMAL
- en: Whether a type has a single field or many fields isn’t necessarily the best
    metric for choosing whether to make it a value. Sometimes we want value semantics,
    and sometimes reference semantics are more important. The phrases *value semantics*
    and *copy by value* are sometimes used interchangeably and even defined in terms
    of each other. However, value semantics has more to do with value-based equality
    than with copying.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing value types from other kinds of types is an important first step
    in partitioning their responsibilities in an application. Identifying candidate
    value types helps us clarify our designs by introducing specialized types that
    encapsulate behavior and responsibilities. In turn, we benefit from a more modular
    system, both in its implementation and in the testing it requires. Having decided
    a type should be modeled as a value, we have more options for implementing it.
    C# has rich support for all user-defined types, but its facilities for value types
    are sometimes unappreciated.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#fn-1) FORTRAN programmers, please remain silent on this ([*https://<wbr>softwareengineering<wbr>.stackexchange<wbr>.com<wbr>/questions<wbr>/254799<wbr>/ever<wbr>-change<wbr>-the<wbr>-value<wbr>-of<wbr>-4<wbr>-how<wbr>-did<wbr>-this<wbr>-come<wbr>-into<wbr>-hayes<wbr>-thomas<wbr>-quiz*](https://softwareengineering.stackexchange.com/questions/254799/ever-change-the-value-of-4-how-did-this-come-into-hayes-thomas-quiz)).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[2](#fn-2) With thanks and apologies to Scott Meyers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
