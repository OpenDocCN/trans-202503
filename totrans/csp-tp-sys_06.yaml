- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    NATURE OF VALUES</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">值的本质</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: C# gives special meaning to the term *value type*, but the concept of a value
    certainly isn’t unique to C#. In this chapter, we’ll revisit values more generally
    and identify some key characteristics that indicate whether we should implement
    something as a value type. We’ll look at the unique and important role of values
    and value types in our programs, and how implementing a well-behaved value type
    requires more than just using a struct or a record struct.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C# 对术语*值类型*赋予了特殊的意义，但值的概念并不仅限于 C#。在这一章中，我们将更广泛地回顾值的概念，并确定一些关键特征，帮助我们判断何时应该将某个内容实现为值类型。我们将探讨值和值类型在程序中的独特且重要的角色，以及如何实现一个表现良好的值类型不仅仅需要使用结构体（struct）或记录结构体（record
    struct）。
- en: 'We’ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: How to improve our designs by employing value type objects to encapsulate behavior
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用值类型对象来封装行为，进而改进我们的设计
- en: How overriding the native reference semantics for some types adversely affects
    their behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何覆盖某些类型的原生引用语义对其行为产生不利影响
- en: What application roles are fulfilled by different object types, and what characteristics
    define those roles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同对象类型在应用中所扮演的角色是什么，以及定义这些角色的特征是什么
- en: Why equality isn’t the same as equivalence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么相等性与等价性不同
- en: How to identify appropriate candidates for value types in our applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别我们应用中适合做值类型的候选项
- en: Every application is different, and it’s our responsibility to create solutions
    to problems that are specific to a particular program. Ultimately, that requires
    us to use our own judgment on how best to apply our chosen programming language.
    In C#, to some extent, that means selecting whether we want to use classes, structs,
    records, or record structs for the types we create.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都是不同的，作为开发者，我们有责任为特定程序的具体问题创造解决方案。最终，这要求我们根据对所选编程语言的最佳应用做出自己的判断。在 C# 中，在某种程度上，这意味着我们需要选择是使用类、结构体、记录类型（record）还是记录结构体（record
    struct）来创建我们的类型。
- en: It’s not appropriate for *everything* to be a value type; sometimes value semantics
    isn’t suitable for the functionality we need. When choosing among the different
    types, we need to decide when value semantics makes sense for a type—and, equally
    importantly, when it doesn’t.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是*所有*东西都适合成为值类型；有时候，值语义并不适合我们需要的功能。在选择不同类型时，我们需要判断何时值语义对某个类型是合适的——同样重要的是，何时它并不适合。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Value vs. Reference Semantics</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">值语义与引用语义</samp>
- en: The term *value semantics* is widely used to describe value types, usually in
    contrast with its counterpart, *reference semantics*. However, while reference
    semantics is easily defined in terms of indirect access to instances via reference
    variables (or similar mechanisms in other languages), value semantics is often
    ill-defined or superficially explained as something value types possess. In C#,
    value types are epitomized by the struct.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*值语义*这个术语广泛用于描述值类型，通常与其对立面——*引用语义*进行对比。然而，虽然引用语义可以通过引用变量（或其他语言中的类似机制）间接访问实例来轻松定义，但值语义往往没有明确的定义，或者仅仅表面上被解释为值类型所具备的特性。在
    C# 中，值类型的典型代表是结构体（struct）。'
- en: 'Structs differ from classes in C# most conspicuously in that struct instances
    are copied by value, meaning the copy is a whole new instance. As a result, structs
    are commonly referred to as having value semantics. We might infer, then, that
    value semantics means that an instance is copied by value, and the C# Language
    Specification certainly supports this definition ([*https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-gb<wbr>/dotnet<wbr>/csharp<wbr>/language<wbr>-reference<wbr>/language<wbr>-specification<wbr>/structs*](https://docs.microsoft.com/en-gb/dotnet/csharp/language-reference/language-specification/structs):)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，结构体与类的最显著区别在于，结构体实例是按值复制的，意味着复制的是一个全新的实例。因此，结构体通常被称为具有值语义。我们可能会推测，值语义意味着实例是按值复制的，C#
    语言规范也明确支持这一定义（[*https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-gb<wbr>/dotnet<wbr>/csharp<wbr>/language<wbr>/reference<wbr>/language<wbr>-specification<wbr>/structs*](https://docs.microsoft.com/en-gb/dotnet/csharp/language-reference/language-specification/structs):））。
- en: '[Structs] can be conveniently implemented using value semantics where assignment
    copies the value instead of the reference.'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[结构体（Structs）]可以方便地使用值语义来实现，其中赋值会复制值而不是引用。'
- en: As we’ve discussed in earlier chapters, copying by value is a direct consequence
    of the way value type variables use memory. The value of every value type variable
    is a complete instance of the type. When the value is copied, the copy is necessarily
    a whole new instance of the type, including copies of each field’s value from
    the original instance. This differs from copying reference variables, where the
    copy is a new reference to the same instance in memory as the original variable.
    The original object’s field values aren’t copied at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的，按值复制是值类型变量使用内存方式的直接结果。每个值类型变量的值都是该类型的完整实例。当值被复制时，副本必然是该类型的全新实例，包括从原始实例复制的每个字段的值。这与复制引用变量不同，在复制引用变量时，副本是指向内存中与原始变量相同实例的新引用。原始对象的字段值根本没有被复制。
- en: The difference in copying behavior is merely a result of how value types and
    reference types are represented. Reference variables may be copied frequently,
    but the instances they refer to are rarely copied, which is a convenient and efficient
    use of memory. Struct and record struct variables are copied by value because
    they can’t be copied any other way. However, copying behavior is only one part
    of the difference between value and reference semantics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 复制行为的差异仅仅是值类型和引用类型表示方式的结果。引用变量可能会被频繁复制，但它们引用的实例很少被复制，这是一种方便且高效的内存使用方式。结构体和记录结构体变量是按值复制的，因为它们无法以其他方式复制。然而，复制行为只是值语义和引用语义之间差异的一个方面。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying and Equality
    Comparison Behavior</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">复制和相等比较行为</samp>
- en: Equality comparison behavior is closely related to the way variables are copied.
    When we make a copy of a variable, the copy should compare equal to the original
    variable. That may seem obvious, but it’s the reason all structs inherit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    and why that default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    for structs is so important. Without <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    a copy of a struct variable wouldn’t compare equal with the original value, because
    struct variables are copied by value. The copy is a distinct instance in its own
    right, and the default reference comparison offered by <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    would never compare the copy and original values as equal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    performs a value-based comparison to ensure that when we copy a value type instance,
    the copy and original variable will compare equal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相等比较行为与变量的复制方式密切相关。当我们复制一个变量时，复制应该与原始变量比较相等。虽然这似乎显而易见，但这也是为什么所有结构体都从<samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>继承<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，并且结构体的< samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的默认实现非常重要的原因。如果没有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>，结构体变量的副本将无法与原始值比较相等，因为结构体变量是按值复制的。副本是一个独立的实例，而<object.Equals</samp>提供的默认引用比较方法永远不会将副本和原始值视为相等。继承自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>的< samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法执行基于值的比较，以确保当我们复制值类型实例时，副本和原始变量将被视为相等。
- en: When we compare references, we’re checking to see whether they represent the
    same specific instance, not whether those instances look alike. The behavior of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method inherited
    by class types from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    matches the copying behavior of references, because copying a reference variable
    doesn’t also copy the instance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较引用时，我们是在检查它们是否代表相同的特定实例，而不是检查这些实例是否相似。类类型从<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>继承的<
    samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>方法的行为与引用的复制行为相匹配，因为复制一个引用变量并不会复制实例。
- en: Being copied by value isn’t, on its own, what endows a value type with value
    semantics; it’s simply the mechanism defined in the language for copying variables
    of struct type. In fact, copy-by-value behavior isn’t even a necessary ingredient
    of value semantics. Take, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class, which overrides the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to perform
    a value-based comparison. As noted in [Chapter 5](chapter5.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    is a class, and <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables
    are references, but when we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables, we’re most often interested in whether they both have the same content—that
    is, whether their character sequences are the same.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过值复制并不是赋予值类型值语义的原因；它只是语言中定义的复制结构体类型变量的机制。事实上，通过值复制的行为甚至不是值语义的必要成分。举个例子，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>类，它重写了默认的<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>方法，以执行基于值的比较。正如在[第5章](chapter5.xhtml)中所述，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>是一个类，<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>变量是引用类型，但当我们比较两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>变量时，我们最关心的是它们是否有相同的内容——也就是说，它们的字符序列是否相同。
- en: For the purposes of equality comparisons, at least, a string’s *value* is the
    sequence of characters, not the actual value of the reference. Whether the two
    variables refer to the same string in memory is almost always irrelevant. Since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables are references,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instances aren’t routinely
    copied by value, but they are *compared* by value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在进行相等性比较时，一个字符串的*值*是字符序列，而不是引用的实际值。两个变量是否引用内存中相同的字符串几乎总是无关紧要的。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>变量是引用类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>实例通常不是通过值复制的，但它们是通过值进行*比较*的。
- en: When we’re trying to define or understand value semantics, equality behavior
    is more significant than the way variables are copied. In the broader sense, a
    value type is any type that bases its equality comparisons on its state; that
    is, two value type objects are equal if they have the same value. By extension,
    there’s more to value semantics than a type being implemented as a struct or record
    struct; having value semantics is what makes a type a *value* type, if we accept
    a wider interpretation of the term *value type* than the definition in the C#
    Language Specification.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图定义或理解值语义时，相等行为比变量如何被复制更为重要。从广义上讲，值类型是任何基于其状态进行相等性比较的类型；也就是说，如果两个值类型对象具有相同的值，则它们是相等的。进一步来说，值语义不仅仅局限于类型是作为结构体或记录结构体实现的；拥有值语义是让一个类型成为*值*类型的关键，如果我们接受一个比C#语言规范中*值类型*定义更广泛的解释。
- en: We can override that behavior for any of our own class types too, but doing
    so is not always appropriate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为任何自定义的类类型重写这种行为，但这样做并不总是合适的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference-Based Comparisons</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于引用的比较</samp>
- en: Most objects have some state, whether that’s private instance fields or public
    property values. We might be tempted to override the default reference equality
    behavior for all our classes and always use that state as an object’s value for
    comparisons. However, although we can model values by using a class, as C# does
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>, *having* a value
    and *being* a value are very different. Most types aren’t intended to be values,
    and the default reference comparison is more appropriate for the majority of the
    classes we create.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对象都有一些状态，无论是私有实例字段还是公共属性值。我们可能会倾向于为所有类重写默认的引用相等性行为，并总是使用该状态作为对象比较的值。然而，尽管我们可以通过类来建模值，就像C#对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>所做的那样，*拥有*一个值和*作为*一个值是非常不同的。大多数类型并不是设计成值类型的，默认的引用比较对于我们创建的大多数类来说更加合适。
- en: As an example of reference-based comparisons being important for an object,
    consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> class
    in [Listing 6-1](#list6-1) for a system tracking logged-in users. Since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> is a class, the semantics
    of reference comparisons makes sense for it because we need to be able to distinguish
    between individual instances.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基于引用的比较对对象很重要的一个例子，考虑 [示例 6-1](#list6-1) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    类，它用于跟踪已登录用户的系统。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    是一个类，因此引用比较的语义对于它是合理的，因为我们需要能够区分不同的实例。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Reference-based
    equality matters for class types.</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 6-1：基于引用的相等性对于类类型很重要。</samp>
- en: Even though the public properties directly expose the state of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    instance, using those properties to implement equality would be a mistake. Two
    instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> with the
    same property values might easily represent different connections. Even if we
    presume that the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>
    property is unique across all users, we may still need to identify an individual
    login in systems that allow multiple connections by the same user. The same user
    might even log in twice at exactly the same moment, so distinguishing different
    connections by their <samp class="SANS_TheSansMonoCd_W5Regular_11">Established</samp>
    property isn’t sufficient.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管公共属性直接暴露了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> 实例的状态，但使用这些属性来实现相等性比较是一个错误。两个具有相同属性值的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> 实例可能表示不同的连接。即使我们假设
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp> 属性在所有用户中是唯一的，我们仍然需要在允许同一用户多次连接的系统中区分每个登录实例。同一用户甚至可能在完全相同的时刻登录两次，因此仅仅通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Established</samp> 属性来区分不同的连接是不够的。
- en: If we overrode the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> to compare
    its property values, we couldn’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to distinguish between different instances with identical properties. If we needed
    to forcibly disconnect a specific connection by calling its <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method, we’d want to be certain we were disconnecting the right one! We therefore
    need to be able to identify a specific *instance* of a login, regardless of the
    values of its public properties.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重写了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法来比较它的属性值，那么我们就无法使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    来区分具有相同属性的不同实例。如果我们需要通过调用其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    方法强制断开某个特定连接，我们希望确保断开的是正确的连接！因此，我们需要能够识别出一个特定的 *登录实例*，而不管其公共属性的值如何。
- en: We could use a mechanism other than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to distinguish between different instances with identical state, but we’d be adding
    extra complexity to support functionality that a normal reference-based comparison
    already provides.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法以外的机制来区分具有相同状态的不同实例，但这将增加额外的复杂性，以支持正常的引用比较已经提供的功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reference Semantics and Side
    Effects</samp>
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">引用语义与副作用</samp>
- en: The difference between value semantics and reference semantics is also defined
    partly by the potential for side effects via aliasing references, which in turn
    is closely associated with mutability. If we change an object via one variable
    and expect the change to be visible via another variable, we need reference semantics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 值语义（value semantics）和引用语义（reference semantics）之间的区别，也在于通过别名引用可能带来的副作用，这与可变性密切相关。如果我们通过一个变量修改了一个对象，并希望通过另一个变量看到该变化，我们就需要引用语义。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> class from [Listing
    6-1](#list6-1) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method that alters the internal state of an instance. If we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method by using one reference variable, we expect every reference to that instance
    to become inactive. As [Listing 6-2](#list6-2) demonstrates, we also expect no
    other instances to be affected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[清单 6-1](#list6-1)的`Login`类具有一个`Disconnect`方法，该方法会改变实例的内部状态。如果我们通过一个引用变量调用`Disconnect`方法，我们希望该实例的每个引用都变为不活动状态。如[清单
    6-2](#list6-2)所示，我们还希望没有其他实例受到影响。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: Intentionally
    changing an instance via a shared reference</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-2：通过共享引用故意改变实例</samp>
- en: Here, we copy the <samp class="SANS_TheSansMonoCd_W5Regular_11">norris</samp>
    reference variable and call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method on the copy, setting its <samp class="SANS_TheSansMonoCd_W5Regular_11">Active</samp>
    property to <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. Although
    we never use the <samp class="SANS_TheSansMonoCd_W5Regular_11">norris</samp> variable
    to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>, the state
    of the instance <samp class="SANS_TheSansMonoCd_W5Regular_11">norris</samp> refers
    to is changed after <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    is called because that instance has been modified via a different reference. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mac</samp> variable refers to a
    separate instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>,
    so it’s not affected by the change to <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们复制了`norris`引用变量，并在复制的副本上调用`Disconnect`方法，将其`Active`属性设置为`false`。尽管我们从未使用`norris`变量调用`Disconnect`，但是由于该实例通过另一个引用进行了修改，`norris`所引用的实例的状态在调用`Disconnect`后发生了变化。`mac`变量引用的是一个独立的`Login`实例，因此它不会受到对`thing`更改的影响。
- en: We want reference semantics for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    class because it means we can have many references to a specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>
    instance. We can pass a reference as an argument to methods and arrange for those
    methods to intentionally modify that instance. We don’t need to worry about searching
    for all other references to the modified instance to make sure they’ve been updated
    with our changes, because references have that behavior built in.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对`Login`类使用引用语义，因为这意味着我们可以拥有多个指向特定`Login`实例的引用。我们可以将引用作为参数传递给方法，并安排这些方法故意修改该实例。我们无需担心搜索所有其他指向已修改实例的引用，以确保它们已经更新了我们的更改，因为引用本身具有这种行为。
- en: A slightly more subtle outcome of reference semantics is that if we change the
    state of a reference type instance via one reference, the variable will still
    compare equal to any other references to the same instance. [Listing 6-3](#list6-3)
    checks that two references compare equal even after the instance has been modified
    by one of those variables.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 引用语义的一个稍微更微妙的结果是，如果我们通过一个引用类型实例修改其状态，该变量仍然会与对同一实例的任何其他引用进行比较时相等。[清单 6-3](#list6-3)检查了即使实例已被其中一个变量修改后，两个引用是否仍然相等。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: Checking for reference
    equality</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-3：检查引用相等性</samp>
- en: This example demonstrates that when we change an instance of a reference type,
    that change is visible via all other references that are *equal* to the reference
    used to make the change. The outcome is that if two reference variables compare
    equal once in a reference-based comparison, and neither variable is assigned to
    a different instance, they’ll *always* compare equal because references are equal
    when they have the same identity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了当我们改变一个引用类型的实例时，这个改变通过所有其他与用于改变的引用*相等*的引用是可见的。结果是，如果两个引用变量在基于引用的比较中第一次比较相等，并且没有任何一个变量被赋值为不同的实例，那么它们将*始终*比较相等，因为引用在具有相同身份时是相等的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Object Identity</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">对象身份</samp>
- en: 'The *identity* of an object is what distinguishes it from other objects of
    the same type. Two reference type instances have different identities—they’re
    independent objects—regardless of whether they have fields containing the same
    values. We can think of the address of an object as its identity, although this
    is only an analogy: an object’s address can change if it’s moved in memory because
    of heap defragmentation or other memory management tasks, but the object retains
    its identity.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的*身份*是将其与同类型的其他对象区分开的特征。两个引用类型实例具有不同的身份——它们是独立的对象——无论它们的字段是否包含相同的值。我们可以把对象的地址看作它的身份，尽管这只是一个类比：如果对象因堆内存碎片整理或其他内存管理任务被移动，地址会发生变化，但对象保持其身份不变。
- en: In [Chapter 2](chapter2.xhtml), you saw how the <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    statement relies on reference semantics; that’s one example of an object’s identity
    being more important than the state it contains, even though the underlying <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp> class doesn’t attempt to
    mutate the object used as a lock in any way. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp>
    relies on knowing the identity of a specific object instance, and that the identity
    is valid across multiple threads of execution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](chapter2.xhtml)中，你看到了如何利用 <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    语句依赖于引用语义；这是对象身份比它所包含的状态更重要的一个例子，尽管底层的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp>
    类并未以任何方式尝试改变作为锁的对象。<samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp>
    的实现依赖于知道特定对象实例的身份，并且该身份在多个执行线程中保持有效。
- en: Reference semantics is an important element in our toolbox so that we can identify
    a specific object instance, not just an object that has the same state as another
    object. Two reference variables to different class instances with exactly the
    same state shouldn’t usually compare equal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引用语义是我们工具箱中的一个重要元素，这样我们就可以识别特定的对象实例，而不仅仅是具有与另一个对象相同状态的对象。两个引用变量如果指向具有完全相同状态的不同类实例，通常不应比较相等。
- en: 'The one exception occurs when we’re using a class to model a value type. In
    this case, the identity isn’t important, because we’re deliberately giving the
    class *value* semantics. The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    type is a classic example. This type isn’t a struct for valid reasons that are
    mostly concerned with efficiency: as a class, a string’s contents won’t be copied
    frequently, and its values will never be boxed. Nevertheless, <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variables are compared by value, and using them is intuitive and straightforward
    thanks to value semantics for equality. Most classes, however, aren’t intended
    to model values.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外发生在我们使用类来模拟值类型时。在这种情况下，身份不重要，因为我们故意赋予该类*值*语义。<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    类型就是一个经典例子。该类型不是结构体，主要是出于效率考虑：作为类，字符串的内容不会频繁复制，其值也永远不会被装箱。然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    变量是按值进行比较的，并且由于值语义的存在，使用它们直观且简单。大多数类并非旨在模拟值。
- en: 'For types intended to have value semantics, instance identity has little or
    no significance. Values should be *referentially transparent*: we can switch one
    instance of a value with a different instance without affecting the program’s
    logic or behavior, provided both instances have identical state.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有值语义的类型，实例的身份几乎没有或完全没有意义。值应该是*引用透明*的：只要两个实例具有相同的状态，我们可以用一个不同的实例替换值的一个实例，而不影响程序的逻辑或行为。
- en: An object’s identity is important when we can alter that object’s state, because
    identity is the only characteristic that distinguishes one object instance from
    another. The native reference equality of reference types tells us *which* variables
    will reflect a change we make to a particular instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们可以改变一个对象的状态时，对象的身份就变得重要，因为身份是唯一能够区分不同对象实例的特征。引用类型的本地引用相等性告诉我们*哪个*变量会反映我们对某个特定实例所做的更改。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value-Based Comparisons</samp>
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">基于值的比较</samp>
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> type in [Listing
    6-1](#list6-1) were a struct or record struct instead of a class, the final assertions
    in [Listings 6-2](#list6-2) and [6-3](#list6-3) would fail because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>
    method would be changing a different instance from the variable used in the assertion.
    Value types are useful when we don’t need the aliasing behavior of reference semantics
    or the ability to have multiple references to a single instance. Contrast the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp> type in [Listing 6-1](#list6-1)
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type in [Listing
    6-4](#list6-4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[清单6-1](#list6-1)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>类型是结构体或记录结构体，而不是类，则[清单6-2](#list6-2)和[清单6-3](#list6-3)中的最终断言将失败，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Disconnect</samp>方法将会修改与断言中使用的变量不同的实例。当我们不需要引用语义的别名行为或能够同时引用同一实例时，值类型是非常有用的。将[清单6-1](#list6-1)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Login</samp>类型与[清单6-4](#list6-4)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型对比。
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: Comparing the
    state of two Color values</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单6-4：比较两个Color值的状态</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type is a struct,
    making it a value type. The two variables <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp> are clearly different
    instances, but they have the same color value and thus should compare equal. The
    only interesting aspect of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type, at least as far as testing two instances for equality is concerned, is its
    state. Two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances
    should compare equal if—and only if—their externally visible property values match.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型是一个结构体，使其成为一个值类型。两个变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>显然是不同的实例，但它们具有相同的颜色值，因此应该比较为相等。至少就测试两个实例是否相等而言，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>类型唯一有趣的方面是它的状态。如果两个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例的外部可见属性值相同，它们就应该被认为是相等的。
- en: From one perspective, the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    *is* its identity, because identity is what distinguishes one object from another.
    Values are transient in that we can make one at any time with a given state. If
    we create multiple instances of a value type with the same state at different
    times or in different methods, then for all intents and purposes, they’re *the
    same* value because they’re indistinguishable, although the mechanics of the language
    means they’re necessarily separate instances.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个角度来看，一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的*身份*就是它的值，因为身份是区分不同对象的标准。值是暂时性的，因为我们可以在任何时候根据某一给定的状态创建一个值。如果我们在不同的时间或不同的方法中创建多个具有相同状态的值类型实例，那么从实际目的上来说，它们是*相同的*值，因为它们无法区分，尽管语言的机制意味着它们本质上是独立的实例。
- en: 'It *is* legitimate to say that equal values can be substituted for one another.
    Take, for example, the archetypal value type in C#: the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Two integers with the same value might as well be the same integer. That may sound
    obvious, but the important point is that we—and our programs—don’t care whether
    they’re the same <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in memory
    or two independent variables. All that matters is whether they have the same value.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以*合法*地说，相同的值可以互相替代。例如，C#中的典型值类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。两个具有相同值的整数实际上可以认为是同一个整数。这听起来可能很显而易见，但重要的点在于，我们和我们的程序并不关心它们是否是内存中同一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，还是两个独立的变量。唯一重要的是它们是否具有相同的值。
- en: In a sense, values have lifetimes that are beyond the technical boundaries imposed
    by scope or memory management. If two value type instances have exactly the same
    contents, and *that’s all that matters*, they’re indistinguishable from each other.
    For this reason, as you’ll see next, values are usually immutable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，值的生命周期超越了作用域或内存管理所施加的技术边界。如果两个值类型实例的内容完全相同，且*这才是最重要的*，它们是无法区分的。因此，正如你接下来会看到的，值通常是不可变的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutability</samp>
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可变性</samp>
- en: 'Values are sometimes characterized as being *eternal*: their lifetimes aren’t
    bounded by a variable’s scope within a program or even by the lifetime of the
    program itself. We can, in a sense, pluck values out of thin air to use them.
    When we need the number <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>,
    we just “materialize” it as a constant value.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 值有时被描述为*永恒的*：它们的生命周期不受程序内变量作用域甚至程序本身生命周期的限制。从某种意义上说，我们可以像凭空抓取一样使用值。当我们需要数字<samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>时，我们只需将其作为常量值“显现”出来。
- en: This characteristic isn’t limited to the built-in value types. The same is true
    of other values, such as a monetary amount like <samp class="SANS_TheSansMonoCd_W5Regular_11">$9.99</samp>,
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"To be, or not to be"</samp>,
    and the date <samp class="SANS_TheSansMonoCd_W5Regular_11">January 1st 2024</samp>.
    They’re *just there* when we need them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一特性并不限于内置的值类型。其他值也一样，比如货币金额<samp class="SANS_TheSansMonoCd_W5Regular_11">$9.99</samp>，字符串<samp
    class="SANS_TheSansMonoCd_W5Regular_11">"To be, or not to be"</samp>，以及日期<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2024年1月1日</samp>。当我们需要时，它们*就在那里*。
- en: In practice, real variables certainly do have a measurable lifetime, and each
    instance requires storage, so we can’t simply dismiss the technical needs of our
    environment. Nonetheless, the theoretical view of eternal, immutable values is
    a useful way to model the way our own value types should behave.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，真实的变量确实具有可测量的生命周期，每个实例都需要存储空间，因此我们不能简单地忽视环境的技术需求。然而，关于永恒且不可变值的理论观点，是模拟我们自己值类型行为的一种有用方式。
- en: When we add two numbers, we don’t change either of them; rather, we get a new
    number representing their sum. Similarly, adding a day to a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    or rounding an amount of money to the nearest whole dollar doesn’t alter the original—it
    produces a new value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将两个数字相加时，并不会改变它们中的任何一个；相反，我们得到一个新的数字，表示它们的和。类似地，将一天加到<samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>上，或将一笔金额四舍五入到最接近的整美元，都不会改变原始值——它们产生了一个新值。
- en: We can’t change the value of the number <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>,¹
    but we can produce a new number by using <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    in an expression with another number. If we add <samp class="SANS_TheSansMonoCd_W5Regular_11">^([1](#fn_1))</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp> doesn’t go away, even though
    we have a new number as a result of the expression. The same holds true for dates,
    speeds, lengths, temperatures, and other natural values. Values are immutable
    by nature.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能改变数字<samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>的值，¹但我们可以通过将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>与另一个数字一起使用，得到一个新数字。如果我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">^([1](#fn_1))</samp>加到<samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>上，尽管表达式的结果是一个新数字，但<samp
    class="SANS_TheSansMonoCd_W5Regular_11">100</samp>的值并没有消失。对于日期、速度、长度、温度和其他自然值也同样如此。值本质上是不可变的。
- en: Immutability can seem like an unnecessary restriction when we’re creating types
    that represent values. After all, if we increase a speed value, we might not care
    about the previous value. Isn’t it usually more efficient to change a value in
    place than to create a new instance with a changed value? Well, perhaps—we’d have
    to measure that. However, immutability has other, more subtle consequences and
    benefits.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建表示值的类型时，不可变性可能看起来像是一个不必要的限制。毕竟，如果我们增加一个速度值，我们可能不关心之前的值。通常改变一个值的地方比创建一个新实例并改变其值更高效，不是吗？嗯，也许——我们得测量一下。不过，不可变性还有其他更微妙的后果和好处。
- en: Two immutable values—and remember from [Chapter 4](chapter4.xhtml) that read-only
    isn’t always the same thing as immutable—that compare equal will *always* do so.
    This has important implications for keys in hashed containers such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>
    collections. Hashed containers depend on the invariance of their keys. If we change
    the value of a particular key after it’s been added to a container, we can’t subsequently
    use the value to look up an item because, in a sense, we’ve altered that key’s
    identity by changing its value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 两个不可变的值——并且请记住，正如[第4章](chapter4.xhtml)中所述，**readonly**并不总是等同于不可变——如果它们比较相等，*总是*如此。这对哈希容器中的键具有重要意义，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>集合。哈希容器依赖于其键的不变性。如果我们在键添加到容器后更改其值，那么之后我们无法使用该值查找项，因为从某种意义上说，通过改变其值，我们已经改变了该键的身份。
- en: The difference between state and instance identity is largely about equality.
    Specifically, when we check to see if one value equals another, are we interested
    in whether they have the same state or whether they’re the same object? If it’s
    the latter, we need a class. If it’s the former—we’re interested in the content
    and don’t care whether the variables are the same instance—we need a value type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和实例身份的区别主要在于相等性。具体来说，当我们检查一个值是否等于另一个值时，我们是关心它们是否具有相同的状态，还是它们是否是同一个对象？如果是后者，我们需要一个类。如果是前者——我们关心的是内容，而不在乎变量是否是同一个实例——我们需要一个值类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mechanics vs. Semantics</samp>
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">机制与语义</samp>
- en: 'The Microsoft documentation has a section entitled Framework Design Guidelines
    that includes advice on choosing between classes and structs but not much guidance
    on when value semantics are a positive choice for a type. Among other suggestions,
    the guidelines offer this ([*https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/dotnet<wbr>/standard<wbr>/design<wbr>-guidelines<wbr>/choosing<wbr>-between<wbr>-class<wbr>-and<wbr>-struct*](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct):)):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 微软文档中有一部分标题为《框架设计指南》，其中包括关于如何选择类和结构体的建议，但对何时选择值语义作为类型的选择并没有太多指导。指南中提供了以下建议（[*https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/dotnet<wbr>/standard<wbr>/design<wbr>-guidelines<wbr>/choosing<wbr>-between<wbr>-class<wbr>-and<wbr>-struct*](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)）：）：
- en: Consider defining a struct instead of a class if instances of the type are small
    and commonly short-lived or are commonly embedded in other objects.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果类型的实例较小并且通常生命周期较短，或者常嵌入其他对象中，可以考虑定义一个结构体而不是类。
- en: 'This doesn’t seem unreasonable if we take it at face value. In particular,
    the rationale behind value types being small is directly related to memory usage
    and copy-by-value behavior: structs that have many fields take up more memory
    space, and the cost of copying a value from one location to another is correspondingly
    higher.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们表面上看待这一点，这似乎并不不合理。特别是，值类型较小的理由直接与内存使用和按值复制行为有关：具有多个字段的结构体占用更多内存空间，而将值从一个位置复制到另一个位置的成本相应地更高。
- en: However, this advice is focused purely on memory use and performance implications,
    and it’s silent on when we should use records or record structs. Other semantic
    differences between value types and other types exist that we should take into
    account. While recommendations like this can guide us, they tell only a small
    part of the story. Every application will have its own requirements, constraints,
    and behavior. We don’t have one single rule to apply that will be appropriate
    universally.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些建议纯粹关注内存使用和性能影响，对于何时使用记录或记录结构体并未提供明确的指导。值类型与其他类型之间还存在其他语义差异，我们应该加以考虑。虽然像这样的建议可以为我们提供指导，但它们只是故事的一小部分。每个应用程序都有自己的需求、约束和行为。我们并没有一个普适的规则可以应用于所有情况。
- en: Policies that insist, or at least suggest, that value types have few data members
    and be short-lived focus on the technical mechanisms of memory representation
    and use, rather than the more conceptual premise of what behavior the type should
    exhibit. Values might often be small, but that doesn’t mean that all small types
    should be structs. A reference type might have only a single field, but that doesn’t
    automatically indicate that it should be a struct or other value-like type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持或至少建议值类型应具有少量数据成员且生命周期短的策略，关注的是内存表示和使用的技术机制，而不是该类型应该表现的更概念化的行为前提。值类型可能通常较小，但这并不意味着所有小的类型都应该是结构体。引用类型可能只有一个字段，但这并不自动表明它应该是结构体或其他类似值类型的类型。
- en: Correspondingly, just because we require a type that has several fields doesn’t
    mean that it can’t be a value type. If value semantics make sense for our type,
    we should make it a value type, regardless of how much data it carries with it.
    The number of fields required by an object shouldn’t be the main factor in our
    decision-making. If we’re worried about the cost of copying large values, we might
    endow a reference type with value-like behavior to address those concerns, a topic
    we’ll revisit in [Chapter 8](chapter8.xhtml).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，仅仅因为我们需要一个具有多个字段的类型，并不意味着它不能是值类型。如果值语义对于我们的类型有意义，我们应该将其定义为值类型，而不管它携带了多少数据。对象所需的字段数不应成为我们决策的主要因素。如果我们担心复制大值的成本，我们可以赋予引用类型值类型的行为来解决这些问题，关于这个话题我们将在[第8章](chapter8.xhtml)中重新讨论。
- en: One way we can determine where we might use value types is to compare their
    characteristics with other types in a program. Although we can’t consider every
    possible object type for any potential application, some common categories of
    object roles are shared by many programs, as we’ll discuss next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将值类型的特征与程序中其他类型进行比较，来确定在哪些地方可能使用值类型。尽管我们不能考虑任何潜在应用的每一种可能的对象类型，但许多程序共享一些常见的对象角色类别，正如我们接下来将讨论的那样。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object Relationships</samp>
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">对象关系</samp>
- en: Object-oriented applications comprise a variety of objects with different roles,
    responsibilities, and interactions. These roles are characterized by the relationships
    between objects and how those objects collaborate to form a coherent application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的应用程序包含多种具有不同角色、职责和交互的对象。这些角色通过对象之间的关系以及这些对象如何协作形成一个一致的应用程序来表征。
- en: When we’re designing an application, it’s easy to overlook the central role
    played by values and value types. If we recognize their importance, we can often
    simplify our designs and make our programs clearer and easier to reason about.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，我们很容易忽视值和值类型所扮演的核心角色。如果我们认识到它们的重要性，通常可以简化我们的设计，使我们的程序更加清晰，易于推理。
- en: We might think of a value as simply the payload of a variable, whether that’s
    the representation of an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or the properties of an object on the heap. It’s tempting to view the values we
    use as incidental to an application’s purpose. Doing so can lead us to unduly
    rely on the built-in types and to oversimplify our custom value type implementations,
    resulting in what Martin Fowler describes as an *anemic domain model*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会将值视为一个变量的有效载荷，无论是一个<int>的表示还是堆上一个对象的属性。我们很容易把我们使用的值看作是与应用程序目的无关的附带内容。这样做可能会导致我们过度依赖内置类型，并且过于简化自定义值类型的实现，从而导致马丁·福勒所描述的*贫血领域模型*。
- en: The types used in an anemic design are perfunctory representations for common
    concepts in the design, especially for the value types. Such types often consist
    only of public properties, all of which have public getters and setters. They
    have no other associated behavior, instead relying on the surrounding code to
    perform common tasks such as data validation, calculations, and even managing
    comparisons. In turn, this leads to duplicated code, scattered error handling,
    and fragmented responsibilities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在贫血设计中使用的类型只是设计中常见概念的敷衍表现，尤其是值类型。这些类型通常仅由公共属性组成，所有属性都有公共的 getter 和 setter。它们没有其他相关的行为，而是依赖周围的代码来执行常见任务，如数据验证、计算，甚至是管理比较操作。反过来，这会导致代码重复、错误处理分散和职责分散。
- en: The antidote to anemic design is a *rich domain model*, in which different kinds
    of types have individual roles and well-defined responsibilities. Each type incorporates
    behavior specific to it, rather than the behavior being scattered around the rest
    of the code. To successfully identify the types our applications require, we must
    recognize that objects aren’t all the same; however, objects in even the most
    complicated systems do fall into a few categories.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 克服贫弱设计的解药是*丰富的领域模型*，在这种模型中，不同种类的类型拥有各自的角色和明确定义的责任。每个类型都包含特定的行为，而不是将行为分散到代码的其他部分。要成功识别我们的应用程序所需的类型，我们必须认识到对象并非都是相同的；然而，即便是在最复杂的系统中，对象仍然可以归入几个类别。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Kinds of Objects</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象种类</samp>
- en: 'If we don’t take care to partition our application’s roles, our design can
    end up becoming incoherent, making it difficult to manage and maintain. Once we
    recognize the main roles that different kinds of objects can play, we can classify
    the types we create by those roles, giving our designs more structure and making
    them easier to understand and work with. Objects fall broadly into one of four
    categories:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心划分应用程序的角色，我们的设计可能会变得不连贯，导致难以管理和维护。一旦我们识别出不同类型的对象所扮演的主要角色，我们可以根据这些角色来分类我们创建的类型，从而使设计更具结构性，并使其更容易理解和使用。对象大致可以分为以下四类：
- en: '**Values**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**值对象**'
- en: Values are responsible for ensuring that an application’s data is valid and
    consistent and for controlling access to that data. They don’t usually outwardly
    collaborate with other objects in a system, except to contain other values. A
    value’s properties commonly don’t change over time, but new values with different
    properties occur frequently.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象负责确保应用程序数据的有效性和一致性，并控制对这些数据的访问。它们通常不会与系统中的其他对象进行明显的合作，除非是包含其他值对象。值对象的属性通常不会随时间变化，但具有不同属性的新值对象会频繁出现。
- en: '**Services**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**'
- en: Services are boundary objects that represent interfaces to systems that are
    external to the application. Services are often stateless; they can be used and
    accessed as they’re needed. They may be perpetual, meaning they are static types
    or have a global instance, or they’re ephemeral and instantiated as and when required.
    Services may be used by many objects but generally have few collaborations of
    their own.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是边界对象，表示与应用程序外部系统的接口。服务通常是无状态的，可以按需使用和访问。它们可能是永久的，意味着它们是静态类型或具有全局实例，或者是短暂的，根据需要实例化。服务可能被许多对象使用，但通常自身的协作较少。
- en: '**Entities**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体**'
- en: Entities are the higher-order design elements in an application. Whereas values
    are the currency of information, entities represent the transactions that use
    or act upon that information. They are often persistent, in the sense that they
    remain in memory rather than being created and destroyed often. They may change
    their properties over time—perhaps frequently—according to the needs of the system,
    and they collaborate often with other entities. An entity’s properties are generally
    either other entities or values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是应用程序中的高阶设计元素。值对象是信息的货币，而实体代表使用或作用于这些信息的事务。实体通常是持久的，意味着它们会长时间驻留在内存中，而不是经常被创建和销毁。实体的属性可能会随着时间的推移而变化——可能会频繁变化——以适应系统的需求，而且它们经常与其他实体进行协作。实体的属性通常是其他实体或值对象。
- en: '**Controllers**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**'
- en: 'Controllers are the task objects in a system: they do things. Entities and
    controllers generally cooperate to perform activities. Controllers are often also
    persistent and may have some state, which is usually related to their collaborations
    with other objects. Controllers are frequently employed to mediate the interactions
    between entities and services.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是系统中的任务对象：它们执行操作。实体和控制器通常合作以完成任务。控制器通常也是持久化的，并可能具有某种状态，这种状态通常与它们与其他对象的协作相关。控制器通常用于调解实体与服务之间的交互。
- en: These are the application roles that define the behavior of a specific design
    and solution domain. These four are common in most systems, although not all applications
    will use or need all of them. Other categories of objects—such as collections,
    lifetime managers, and exceptions—have supporting roles in an application rather
    than being design elements in a system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是定义特定设计和解决方案领域行为的应用角色。这四个角色在大多数系统中都很常见，尽管并非所有应用程序都会使用或需要它们。其他类别的对象——例如集合、生命周期管理器和异常——在应用程序中扮演支持角色，而不是系统中的设计元素。
- en: Values in C# are usually represented by structs, records, or record structs,
    although they can be modeled using classes, as you’ve seen with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    Each of the other roles will almost always be fulfilled by a class. Up to this
    point, the term *object* has been reserved for reference type instances. If we
    consider a value to be another kind of object, we have a common and uniform basis
    for comparing the characteristics of all the objects in an application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，值通常通过结构体、记录或记录结构体表示，尽管它们也可以通过类建模，正如你在 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    中看到的那样。几乎所有其他角色都会由类来承担。到目前为止，术语*对象*仅限于引用类型实例。如果我们认为值也是另一种类型的对象，那么我们就可以为比较应用程序中所有对象的特征提供一个共同且统一的基础。
- en: The characteristics of a particular object, then, suggest the role it’s fulfilling.
    Put another way, we can identify an object’s role by looking at the characteristics
    of that object’s implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个特定对象的特征提示了它正在履行的角色。换句话说，我们可以通过查看该对象实现的特征来识别对象的角色。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Characteristics</samp>
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对象特征</samp>
- en: The three non-value roles—service, entity, and controller—are strongly behavioral
    in the sense that we use them to perform operations or tasks. By contrast, values
    tend to have a passive role in a system and are generally used by other objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 三个非值角色——服务、实体和控制器——在行为上非常强烈，因为我们用它们来执行操作或任务。相比之下，值在系统中通常扮演被动角色，通常由其他对象使用。
- en: Behavior is one of three main characteristics shared by all objects in a system,
    as described by Grady Booch and his coauthors in *Object-Oriented Analysis and
    Design with Applications* (Addison-Wesley, 2007). The other two primary characteristics
    are state and identity (see [Figure 6-1](#fig6-1)), and the importance of each
    relative to the others is different for every application role.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 行为是所有系统中对象共有的三大主要特征之一，正如Grady Booch及其合著者在《*面向对象分析与设计及应用*》（Addison-Wesley，2007）中所描述的。另两个主要特征是状态和身份（参见[图
    6-1](#fig6-1)），每个特征相对于其他特征的重要性对于每个应用角色来说是不同的。
- en: '![](../images/Figure6-1.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Characteristics
    of objects</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 6-1：对象的特征</samp>
- en: 'Booch and his coauthors describe the three characteristics as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Booch及其合著者将这三大特征描述如下：
- en: '**Behavior**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为**'
- en: 'An object’s behavior describes what it can do or its visible attributes. Those
    two aspects are frequently interrelated: when an object performs an action, the
    result may change its visible properties. The visible properties may form part
    or all of an object’s state. A type’s public interface defines the behavior of
    instances of that type; that is, the interface tells us what an object can do
    rather than how it’s implemented.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的行为描述了它可以做什么或其可见的属性。这两个方面通常是相互关联的：当一个对象执行某个操作时，结果可能会改变它的可见属性。可见属性可能构成对象状态的一部分或全部。类型的公共接口定义了该类型实例的行为；也就是说，接口告诉我们一个对象能做什么，而不是它是如何实现的。
- en: '**State**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**'
- en: The state of an object is defined by its member data, which may be persistent
    and immutable or may change over time. As just indicated, the state may be publicly
    visible in the interface or private and hidden, used only within the internal
    implementation of the type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的状态由其成员数据定义，这些数据可能是持久的且不可变的，也可能随着时间的推移发生变化。正如前面所述，状态可能在接口中公开可见，也可能是私有的且被隐藏，只在类型的内部实现中使用。
- en: '**Identity**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份**'
- en: Every instance of a type has a distinct identity, which, as you’ve seen, allows
    us to distinguish one object from another. Identity is important when we need
    to know whether a variable represents a shared instance or a local value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型的实例都有一个独特的身份，正如你所看到的，它使我们能够区分一个对象与另一个对象。身份在我们需要知道一个变量是否代表共享实例或本地值时非常重要。
- en: Each object role prioritizes different object characteristics, and in some cases,
    multiple characteristics are important for a given role. We can identify which
    role an object fulfills by looking at its profile in terms of these characteristics.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象角色优先考虑不同的对象特征，在某些情况下，多个特征对于给定的角色都很重要。我们可以通过查看对象在这些特征上的表现来识别它所承担的角色。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Values</samp>
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">值类型</samp>
- en: Of all the application roles, values attach the most importance to their state;
    it is literally their distinguishing feature. Values always have some kind of
    behavior associated with the concept they represent, but that behavior doesn’t
    alter the state. In most cases, the behavior is represented by properties to access
    the component parts of the state. A value might also have methods to return different
    representations of its state, or factory methods for creating new values. In any
    case, all of a value object’s behavior is directly related to its state.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有应用角色中，值类型最看重的是它们的状态；这几乎是它们的区分特征。值类型总是与它们所代表的概念有某种行为相关联，但这种行为不会改变状态。在大多数情况下，行为通过属性来表示，用于访问状态的各个组成部分。值类型也可能有方法返回其状态的不同表示，或者具有工厂方法来创建新的值。在任何情况下，值对象的所有行为都与其状态直接相关。
- en: Values are strongly typified by their equality semantics, where one value is
    equal to any other with the same state. They’re immutable and don’t usually collaborate
    with other object types. Values frequently use other value types as fields, as
    demonstrated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> types in [Listing
    6-5](#list6-5).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型通过它们的相等语义来强烈定义，一个值与任何具有相同状态的其他值相等。它们是不可变的，通常不会与其他对象类型进行协作。值类型经常将其他值类型作为字段，正如在[代码清单6-5](#list6-5)中展示的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>类型所示。
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: Defining value
    objects</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">代码清单6-5：定义值对象</samp>
- en: Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> structs implement the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> interface,
    similar to the value types we examined in [Chapter 5](chapter5.xhtml). Along with
    their properties, <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> both emphasize
    equality behavior, represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> protocol, although that behavior is secondary to and entirely dependent
    on their state (see [Figure 6-2](#fig6-2)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>结构体都实现了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>接口，类似于我们在[第5章](chapter5.xhtml)中研究的值类型。连同它们的属性，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>都强调相等性行为，通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>协议来表示，尽管这种行为是次要的，且完全依赖于它们的状态（见[图6-2](#fig6-2)）。
- en: '![](../images/Figure6-2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: Value object characteristics</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-2：值对象特征</samp>
- en: Here, you can see how the state of a value object is its primary feature; we
    distinguish different values by their state rather than identity, and values with
    identical state can be used interchangeably. The behavior characteristic for values
    is less prominent than the state, although equality semantics certainly make it
    important. However, the identity of a value is immaterial, so it’s not shaded.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到值对象的状态是它的主要特征；我们通过状态而不是身份来区分不同的值，并且具有相同状态的值可以互换使用。值类型的行为特征不如状态突出，尽管相等语义无疑使其变得重要。然而，值类型的身份是无关紧要的，因此它不会被着色。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Services</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">服务类型</samp>
- en: Service objects often only encapsulate behavior and have no state. They generally
    provide some kind of façade or adaptation logic to interfaces that represent systems
    outside an application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象通常仅封装行为，而没有状态。它们通常提供某种外观模式或适配逻辑，以便与代表应用外部系统的接口进行交互。
- en: Identity usually isn’t important for service objects. Services may be global
    and have a well-known instance available throughout the application, or they may
    be created as required, but each instance is indistinguishable from all the others,
    since none has any state. Services are sometimes implemented as purely static
    interfaces (as a static class with only static methods), like the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetTime</samp>
    class in [Listing 6-6](#list6-6).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 身份通常对服务对象并不重要。服务可能是全局的，并且在整个应用程序中有一个广为人知的实例，或者它们可能根据需要创建，但每个实例都与其他实例不可区分，因为它们没有任何状态。服务有时作为纯静态接口实现（如只有静态方法的静态类），就像[列表
    6-6](#list6-6)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetTime</samp>
    类。
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: Implementing a
    static service</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-6：实现静态服务</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetTime</samp> class
    is a service that merely exposes a static method; it has no identity because there
    is no object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetTime</samp> 类是一个仅暴露静态方法的服务；它没有身份，因为没有对象。
- en: '[Figure 6-3](#fig6-3) illustrates that the behavior of a service object isn’t
    just its most important characteristic—it’s frequently its *only* characteristic.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](#fig6-3) 表明，服务对象的行为不仅是其最重要的特征——它通常是其*唯一*的特征。'
- en: '![](../images/Figure6-3.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: Service object
    characteristics</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 6-3：服务对象特性</samp>
- en: For services, like values, object identity is irrelevant, but for slightly different
    reasons. When a service object has an identity, such as when it’s implemented
    as a globally accessible object, we can substitute that instance with a different
    object, as long as its public interface is the same. As we know, values are interchangeable
    if they have the same state. Unlike values, services rarely have any state, so
    state and identity are both unshaded in [Figure 6-3](#fig6-3).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务来说，像值那样，对象的身份并不重要，但原因稍有不同。当一个服务对象有身份时，比如它作为一个全局可访问的对象实现，我们可以用另一个对象替代该实例，只要它的公共接口相同。正如我们所知道的，如果值具有相同的状态，它们是可以互换的。与值不同，服务很少有状态，因此状态和身份在[图
    6-3](#fig6-3)中都没有阴影。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Entities</samp>
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">实体</samp>
- en: Entities often do have some kind of state, which means we need to be able to
    distinguish one instance from another. An entity’s state is usually observable
    only through its behavior, which may involve either reading or modifying the state.
    Entities commonly don’t directly expose their state but instead provide methods
    to manipulate or access representations of it in different forms.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实体通常有某种状态，这意味着我们需要能够区分一个实例和另一个实例。实体的状态通常只能通过其行为来观察，这可能涉及读取或修改状态。实体通常不会直接暴露其状态，而是提供方法以不同的形式操作或访问其状态的表示。
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp> class
    in [Listing 6-7](#list6-7), which has a method to add purchases to the account,
    affecting the account balance. The balance itself isn’t represented directly as
    state in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp> class
    but is calculated from outstanding charges.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[列表 6-7](#list6-7)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp>
    类，它有一个方法用于向账户添加购买，这会影响账户余额。余额本身并没有直接作为状态在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp>
    类中表示，而是通过未结账款来计算。
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: Creating an entity
    object</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-7：创建实体对象</samp>
- en: Entities may also have behavior that doesn’t relate directly to their state
    but perhaps updates or modifies another entity object parameter. Abstract and
    virtual methods are a fairly common feature of entity types (as in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp>
    entity here), allowing them to be inherited, with derived types customizing the
    base class behavior.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实体也可能具有与其状态无关的行为，但可能会更新或修改另一个实体对象的参数。抽象方法和虚方法是实体类型的一个常见特征（如这里的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Account</samp>
    实体），允许它们被继承，派生类型可以自定义基类行为。
- en: We’re usually interested in using a specific instance of an entity type, so
    object identity is critical, regardless of whether we have multiple instances
    with identical state.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常关心的是使用实体类型的特定实例，因此对象身份至关重要，无论我们是否有多个具有相同状态的实例。
- en: As shown in [Figure 6-4](#fig6-4), then, entities place fairly high importance
    on all three object characteristics.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 6-4](#fig6-4)所示，实体在这三种对象特征上都赋予了相当高的优先级。
- en: '![](../images/Figure6-4.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: Entity object characteristics</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 6-4：实体对象特征</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Controllers</samp>
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">控制器</samp>
- en: Controllers also often have some state, but they differ from entities in that
    the state affects the way controllers perform their task. One example is a database
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object whose state
    includes a connection to a data source and a representation of an SQL instruction.
    A controller may well expose its state publicly and even allow it to be directly
    changed, affecting the controller’s behavior. For example, consider how the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp>
    method uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> property
    in [Listing 6-8](#list6-8).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器通常也有一些状态，但与实体不同的是，状态会影响控制器执行任务的方式。一个例子是数据库 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    对象，它的状态包括与数据源的连接和 SQL 指令的表示。控制器可能会公开其状态，甚至允许直接更改，这会影响控制器的行为。例如，考虑 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    类的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp> 方法如何在[清单 6-8](#list6-8)中使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> 属性。
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: Defining a controller</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-8：定义控制器</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object allows
    us to change its SQL instruction via the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    property. We can repeatedly call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp>
    method on one <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> instance
    to obtain different results, rather than creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    object for every query.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 对象允许我们通过可变的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> 属性来更改其 SQL 指令。我们可以在一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 实例上反复调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Execute</samp>
    方法，以获得不同的结果，而不是为每个查询创建一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    对象。
- en: Controllers, as illustrated in [Figure 6-5](#fig6-5), are principally characterized
    by identity and behavior. They depend on their state to some degree but tend to
    rely on it less than entities do, because that data is used to support or modify
    the controller’s behavior rather than being a hidden implementation detail.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 6-5](#fig6-5)所示，控制器主要以身份和行为为特征。它们在某种程度上依赖于状态，但比实体依赖得少，因为这些数据用于支持或修改控制器的行为，而不是作为隐藏的实现细节。
- en: '![](../images/Figure6-5.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure6-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: Controller object
    characteristics</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 6-5：控制器对象特征</samp>
- en: Individual implementations of controller objects may attach more or less importance
    to their state or their behavior, depending on their specific requirements. However,
    as with entities, a controller object’s identity is almost always significant,
    because we need to be able to distinguish between different instances. Reference
    semantics are often important for both entities and controllers so that any changes
    to an instance are reflected by all references to it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器对象的具体实现可能会根据其特定需求，更加重视它们的状态或行为。然而，和实体一样，控制器对象的身份通常非常重要，因为我们需要能够区分不同的实例。引用语义对于实体和控制器通常都很重要，以确保对实例的任何修改都会反映在所有引用中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Design Refinement
    to Model Object Roles</samp>
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">模型对象角色的设计优化</samp>
- en: The three characteristics of identity, state, and behavior give us a relatively
    simple metric we can apply to determine whether an object most closely resembles
    a value, entity, controller, or service. We can use this information to refine
    a design or to refactor code. Looking at an object’s characteristics might tell
    us that it has too much responsibility or represents a mixture of application
    roles, and we should adjust the code accordingly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 身份、状态和行为这三个特征为我们提供了一个相对简单的度量标准，可以用来确定一个对象最接近值、实体、控制器还是服务。我们可以利用这些信息来优化设计或重构代码。查看一个对象的特征可能告诉我们它承担了过多的责任或代表了多个应用角色的混合，我们应该相应地调整代码。
- en: An object that’s highly dependent on its state, and that has different instances
    with identical state that are considered equal, is a strong contender for being
    a value. If the identity of a specific instance is important, however, it most
    likely shouldn’t be a value, so we’d look to the other characteristics to determine
    which of the non-value roles it best represents. If we can’t clearly identify
    a specific role based on an object’s characteristics, we should take the opportunity
    to decompose the type to better model individual roles with separate abstractions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高度依赖于其状态的对象，并且具有不同实例的相同状态且被认为相等，通常是一个强有力的值候选对象。然而，如果一个特定实例的身份很重要，那么它很可能不应该是一个值类型，因此我们需要查看其他特征来确定它最能代表哪个非值角色。如果我们不能根据对象的特征清晰地识别出特定角色，我们应该借此机会将该类型分解，以更好地使用单独的抽象来建模各个角色。
- en: When designing a system, programmers often look for the main characters—that
    is, the service, entity, and controller roles. Identifying value type candidates
    isn’t always so straightforward, which may be one reason they’re often represented
    by the built-in types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统时，程序员通常会寻找主要角色——即服务、实体和控制器角色。识别值类型候选对象并不总是那么直接，这也可能是它们经常由内置类型表示的原因，比如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>。
- en: An object should have a single responsibility and fulfill just one application
    role. By being mindful of the relative merits of identity, state, and behavior,
    we can more closely and clearly model our objects’ roles. Because values place
    so much importance on their state, everything about a value is focused on that
    state, whether obtaining, reporting, or manipulating it. Identifying the value
    types in an application helps us simplify our design by partitioning responsibilities
    and encapsulating behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象应该有单一的责任，并且仅履行一个应用角色。通过关注身份、状态和行为的相对优点，我们可以更加紧密和清晰地对对象的角色进行建模。由于值类型如此重视它们的状态，因此关于值的一切都集中在该状态上，无论是获取、报告还是操控它。识别应用中的值类型有助于通过划分责任和封装行为来简化设计。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Abstraction and Vocabulary</samp>
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">抽象与词汇</samp>
- en: Some objects stand out as good candidates to be values—for example, simple measurements
    and quantities, such as speed, temperature, distance, length, and money. Such
    objects are often simple wrappers around primitive types like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Each logically
    represents a single concept as an abstraction. We can’t easily decompose them
    other than to revert to using primitive types.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象被认为是良好的值候选，例如简单的度量和数量，比如速度、温度、距离、长度和金钱。这些对象通常是围绕像 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 这样的基本类型的简单封装。每个对象在逻辑上代表一个抽象的单一概念。我们很难将它们分解，除非回退到使用基本类型。
- en: We use the names of these types to form part of the *vocabulary* of a program.
    We write the program in terms of specific concepts like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> rather than more
    general-purpose types like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    More than that, when we talk to other people working on the same project, the
    names we use match the names in the code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些类型的名称来构成程序的一部分*词汇表*。我们以特定概念（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>）的方式编写程序，而不是使用像 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 这样的通用类型。更重要的是，当我们与其他参与同一项目的人交流时，我们使用的名称与代码中的名称相匹配。
- en: Using a specific named type instead of a built-in primitive type also prevents
    simple errors, such as mistakenly using a temperature value when we mean to use
    a length. If, for example, we pass an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    type to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>,
    the program won’t compile. Such errors are easy to miss when we use built-in types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to represent
    values for both length and temperature.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具体命名的类型代替内建的原始类型还可以防止一些简单错误，比如误将温度值当作长度值使用。例如，如果我们将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    类型的实例传递给一个期望 <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> 类型的方法，程序将无法编译。当我们使用像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 这样的内建类型来表示长度和温度值时，这种错误容易被忽视。
- en: Other value candidates are less easily represented with primitive types because
    they consist of multiple components. Types to represent concepts such as currency
    rates of exchange, color spaces, Cartesian coordinates, and telephone numbers
    each have several related parts. Still, they all represent distinct abstractions
    to which we can give meaningful names like <samp class="SANS_TheSansMonoCd_W5Regular_11">FxRate</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PhoneNumber</samp>.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的值候选类型较难使用原始类型表示，因为它们由多个组成部分构成。表示汇率、色彩空间、笛卡尔坐标和电话号码等概念的类型每个都有几个相关的部分。然而，它们都代表了不同的抽象，我们可以为这些抽象赋予有意义的名称，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FxRate</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">PhoneNumber</samp>。
- en: The names we give our types should provide vital information about their purpose.
    We could collect the red, green, and blue components of an RGB color space into
    a simple tuple type, but it would be hard to distinguish such a value from a tuple
    containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> components of a three-dimensional
    coordinate value. Creating separate user-defined types for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> makes our
    code easier for other programmers to understand.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为类型命名时，应提供关于其目的的关键信息。我们可以将 RGB 色彩空间中的红、绿、蓝分量收集成一个简单的元组类型，但很难将这样的值与包含 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> 分量的三维坐标元组区分开。为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    创建独立的用户定义类型，使我们的代码更容易被其他程序员理解。
- en: When we use the name of an abstraction, we’re implicitly referring to the behavior
    associated with that abstraction. The name becomes shorthand for the concept and
    is most easily understood when the type representing that abstraction is a single,
    cohesive idea and its behavior is well encapsulated. Value types are a rich vein
    for exploring those ideas, although the same principles apply for all types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一个抽象名称时，我们隐含地指的是与该抽象相关的行为。这个名称成为该概念的简写，当代表该抽象的类型是一个单一的、内聚的概念，并且其行为被良好封装时，最容易理解。值类型是探索这些思想的丰富资源，尽管相同的原则也适用于所有类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encapsulation and Cohesion</samp>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">封装与内聚性</samp>
- en: 'When we’re designing our own type, beyond giving it a name that conveys its
    purpose, it’s also beneficial to collect the behavior that’s appropriate for the
    abstraction we’re modeling. This is what’s commonly meant by *encapsulation*:
    assembling the object’s data and the methods that support it. However, encapsulation
    is much more than just adding member methods; we also need to keep in mind a type’s
    cohesion, which is a much less tangible concept.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计自己的类型时，除了给它起个能表达其目的的名字外，将与我们所建模的抽象相适应的行为集合起来也是有益的。这就是通常所说的*封装*：将对象的数据和支持它的方法组合在一起。然而，封装远不止是添加成员方法；我们还需要牢记类型的内聚性，这是一个更为抽象的概念。
- en: A type is *cohesive* if the operations defined for it all work together to provide
    a well-defined and sensible interface for using instances of the type. In other
    words, cohesion means that the concept of the type makes sense as a whole. In
    this context, we’re talking about whether other programmers find a type easy to
    comprehend. The compiler cares only about what’s syntactically correct, but we’d
    likely be surprised to find a method for converting a string to uppercase on a
    type mostly concerned with money.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型是*内聚*的，那么为其定义的所有操作都能协同工作，提供一个清晰且合理的接口来使用该类型的实例。换句话说，内聚意味着该类型的概念作为一个整体是有意义的。在这个背景下，我们讨论的是其他程序员是否容易理解某个类型。编译器只关心语法是否正确，但如果我们发现一个主要涉及金钱的类型中有一个用于将字符串转换为大写的方法，我们可能会感到惊讶。
- en: A type is more than just a place for defining methods; those methods should
    contribute to the abstraction we’re trying to represent. Conversely, as mentioned
    earlier, a type with no behavior at all, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type in [Listing 6-9](#list6-9), is often simplistic.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型不仅仅是定义方法的地方；这些方法应该有助于我们尝试表示的抽象。相反，正如之前所提到的，像 [列表 6-9](#list6-9) 中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 类型那样没有任何行为的类型通常是过于简化的。
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Anemic type design</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-9：贫血类型设计</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct isn’t
    encapsulating anything, and its <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property might just as well be a public field. Although the name of the type gives
    us a clue as to its intended purpose and at least allows the compiler to catch
    many inappropriate uses, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is an example of an anemic type. Any behavior we add should support and contribute
    to the abstraction implied by the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 结构体并没有封装任何东西，它的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> 属性完全可以是一个公共字段。虽然类型的名字给了我们关于其预期用途的一些线索，并且至少可以让编译器捕捉到许多不当的用法，但
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 仍然是一个贫血类型的例子。我们添加的任何行为都应该支持并且有助于名字
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 所暗示的抽象。
- en: This advice applies equally to all types in a system, not just the value types.
    Whatever the purpose of the types we create, we need to capture individual abstractions
    in our designs. Good abstractions are well encapsulated; they don’t leak their
    implementation details. A type that is cohesive is easier to comprehend than one
    that’s just a collection of methods. Encapsulation and cohesion both contribute
    to the quality of the abstraction.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这一建议同样适用于系统中的所有类型，而不仅仅是值类型。无论我们创建的类型目的是什么，我们都需要在设计中捕捉到各个抽象。好的抽象是高度封装的；它们不会泄露实现细节。一个内聚的类型比一个只是方法集合的类型更容易理解。封装性和内聚性共同作用于抽象的质量。
- en: Many of the objects we create have some kind of state, but that’s not the same
    as them representing values. For value types, the abstraction we’re representing
    *is* that value. If we’re defining a type to represent a speed, the operations
    we define for the type should present an interface consistent with a generally
    accepted notion of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    The value is the core of the encapsulation and cohesion we want to achieve.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的许多对象都有某种状态，但这并不等同于它们表示的是值。对于值类型来说，我们表示的抽象*就是*那个值。如果我们定义一个类型来表示速度，那么我们为该类型定义的操作应该提供一个与普遍接受的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 概念一致的接口。值是我们希望实现的封装性和内聚性的核心。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The term* encapsulation *is sometimes used to mean merely data hiding. While
    it’s certainly true that exposing fields directly is usually a bad idea, as we’ll
    talk about shortly, encapsulation involves more than making data private. Encapsulation
    has a close relationship with cohesion, and in concert they play an important
    role in designing types that are easy to use correctly and hard to use incorrectly.*^([2](#fn_2))'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*术语*封装*有时仅用于指数据隐藏。虽然直接暴露字段通常是一个不好的主意，正如我们稍后会讨论的那样，封装涉及的内容远不止使数据变得私有。封装与内聚性有着密切的关系，并且二者共同在设计易于正确使用且难以错误使用的类型中发挥着重要作用。*^([2](#fn_2))'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Eliminating Duplication</samp>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">消除重复代码</samp>
- en: Encapsulating behavior into a named type allows us to capture common code in
    one place. As you saw in [Chapter 1](chapter1.xhtml), sensible values for a speed
    fall within a specific range, so attempting to use a speed with a value outside
    that range should be an error. If we use an overly simple type to represent a
    speed, we must duplicate those validation checks everywhere a speed value is used,
    which might be in multiple places. Consider the methods in [Listing 6-10](#list6-10),
    which use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct
    from [Listing 6-9](#list6-9). We must validate the value for every use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将行为封装成一个命名类型可以让我们将常见代码集中到一个地方。如同你在[第1章](chapter1.xhtml)中看到的，合理的速度值应该在特定的范围内，因此，尝试使用一个超出此范围的速度值应该是一个错误。如果我们使用一个过于简单的类型来表示速度，我们就必须在每次使用速度值的地方重复进行这些验证检查，这可能会在多个地方发生。考虑[第6-10节](#list6-10)中的方法，它们使用了[第6-9节](#list6-9)中的<
    s am p class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>结构体。我们必须为每次使用< s am
    p class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>时验证该值。
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-10: Duplicated validation
    code</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">第6-10节：重复的验证代码</samp>
- en: To protect these methods from invalid speed values being passed as arguments,
    we must validate the parameter to ensure that it’s not larger than the maximum
    allowed value, it’s not negative, and it’s a real number. The tests we use are
    the same for every method using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    and we should also validate the values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance</samp> parameters.
    It would be easy to forget one of these checks when we write a new function that
    uses a speed, time, or distance, or to accidentally use the wrong value for the
    maximum allowable speed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止无效的速度值作为参数传递给这些方法，我们必须验证参数，确保它不大于最大允许值、不为负数，并且是一个实数。我们使用的测试对于每个使用< s am
    p class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的方法都是相同的，我们还应该验证< s am p
    class="SANS_TheSansMonoCd_W5Regular_11">time</samp>和< s am p class="SANS_TheSansMonoCd_W5Regular_11">distance</samp>参数的值。在编写一个使用速度、时间或距离的新函数时，很容易忘记其中的某个检查，或者不小心使用错误的最大允许速度值。
- en: The duplication of the validation code is also a maintenance problem. If we
    need to alter the acceptable range of values for speeds, we have to make sure
    we change it everywhere it occurs. We also need to test the validation logic in
    every method where it’s applied, so those tests will also be duplicated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 验证代码的重复也是一个维护问题。如果我们需要修改速度的可接受范围，就必须确保在所有出现的地方都进行相应的更改。我们还需要在每个应用此验证逻辑的方法中测试验证逻辑，因此这些测试也将被重复。
- en: If we instead encapsulate the validation logic within a constructor for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, we can test its characteristics
    in only one place and in isolation from other tests we need. We won’t need to
    worry that the values might be out of range for methods using <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values. Any method using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    can rely on the validation it encapsulates. We can remove the duplicated validation
    code as well as any duplicated tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将验证逻辑封装在一个< s am p class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的构造函数中，那么我们就可以仅在一个地方对其特性进行测试，并且与其他所需的测试相互独立。我们不再需要担心使用<
    s am p class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>值的方法中，值可能超出范围的问题。任何使用<
    s am p class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的方法都可以依赖它所封装的验证逻辑。我们可以删除重复的验证代码以及任何重复的测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Establishing Class
    Invariants</samp>
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">建立类不变量</samp>
- en: Having a constructor that performs all the necessary validation for a type’s
    value is an example of establishing a *class invariant* (where *class* has to
    do with type theory rather than the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>
    keyword). This approach ensures that all instances have values that make sense
    for the type.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个执行类型值必要验证的构造函数是建立*类不变量*的一个例子（其中*类*与类型理论相关，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>关键字）。这种方法确保所有实例的值都符合该类型的逻辑。
- en: '[Listing 6-11](#list6-11) shows how we can combine a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression with pattern matching to efficiently perform numeric validation in
    a constructor.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-11](#list6-11)展示了如何将<samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>表达式与模式匹配结合起来，以便在构造函数中高效地进行数值验证。'
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-11: Defining a simple
    value type with validation</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-11：定义带有验证的简单值类型</samp>
- en: The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    ensures that we’ll never have a value that is not a number, is negative, or is
    greater than the speed of light.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的构造函数确保我们永远不会有一个不是数字、为负数或大于光速的值。
- en: The patterns within the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression are matched from top to bottom, and wherever the value being tested—the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> parameter in this case—matches
    the pattern, the associated expression is evaluated to produce a result. The first
    two patterns here are the error conditions and throw exceptions instead of producing
    a value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>表达式中的模式是从上到下匹配的，在被测试的值—在此情况下是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">val</samp>参数—匹配模式时，关联的表达式会被评估并产生结果。前两个模式是错误条件，并会抛出异常，而不是生成一个值。
- en: 'The first pattern is a constant pattern matching <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>,
    as you saw in [Chapter 5](chapter5.xhtml) ❶. The second pattern throws an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRange</samp> exception if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> is either less than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> or greater than the constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp> ❷. This pattern uses a
    combination of facilities available since C# v9.0: a relational pattern and a
    disjunctive pattern.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式是常量模式匹配<samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>，正如你在[第5章](chapter5.xhtml)中看到的❶。第二个模式会抛出一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ArgumentOutOfRange</samp>异常，如果<samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>小于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>或大于常量<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>❷。这个模式使用了自C#
    v9.0以来可用的组合功能：关系模式和析取模式。
- en: The *relational pattern*, which is appropriate for any of the built-in numeric
    types, uses the relational operators <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> to determine whether
    a number is within a given range. The *disjunctive pattern* combines other patterns
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp> keyword,
    and the pattern matches if any of its expressions match. The similar *conjunctive
    pattern* (not used here) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    keyword and matches if all of its component expressions match.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系模式*，适用于任何内置的数值类型，使用关系运算符<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>来判断一个数字是否在给定范围内。*析取模式*通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">or</samp>关键字将其他模式结合起来，当其任何表达式匹配时，模式会匹配。类似的*合取模式*（此处未使用）使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">and</samp>关键字，只有当所有组件表达式匹配时，模式才会匹配。'
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> value doesn’t
    match either of the first two patterns, it matches the final discard pattern,
    whose expression is simply the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>
    ❸. This becomes the result of the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    expression and is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp>
    field. Since the discard is always a match, it must be the final pattern in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> expression.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> 值不匹配前两个模式中的任何一个，它将匹配最后一个丢弃模式，其表达式只是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> 的值 ❸。这将成为整个 <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>
    表达式的结果，并分配给 <samp class="SANS_TheSansMonoCd_W5Regular_11">amount</samp> 字段。由于丢弃模式始终匹配，它必须是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> 表达式中的最后一个模式。
- en: In addition to encapsulating validation logic within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type, we’ve made <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> immutable
    to ensure that an instance, once successfully validated, can never become invalid.
    If the state can’t be changed, the class invariant needs to be checked only once—in
    the constructor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将验证逻辑封装在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 类型中，我们还使
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 变得不可变，以确保一旦实例通过验证，就再也不会变得无效。如果状态不能被改变，那么类的不变性仅需在构造函数中检查一次。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clarifying with Symmetry</samp>
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">通过对称性来澄清</samp>
- en: The role of symmetry in an interface is often underestimated, but it can be
    important in making our types easy to use and understand. For instance, you saw
    in [Chapter 1](chapter1.xhtml) how class factory methods can help us represent
    units for a type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    We use such methods instead of directly accessing a public constructor, and each
    method encapsulates the name of the units it represents. [Listing 6-12](#list6-12)
    shows how we can couple the class factory methods with their corresponding properties
    to obtain a value in different units.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中对称性的重要性常常被低估，但它在使我们的类型易于使用和理解方面可能非常关键。例如，你在[第1章](chapter1.xhtml)中看到过，类工厂方法如何帮助我们为像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 这样的类型表示单位。我们使用这些方法，而不是直接访问公共构造函数，每个方法都封装了它所代表的单位名称。[清单
    6-12](#list6-12)展示了如何将类工厂方法与相应的属性配对，以便获得不同单位的值。
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-12: Applying symmetry
    by pairing class factory methods with their respective properties</samp>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-12：通过将类工厂方法与各自的属性配对来应用对称性</samp>
- en: We’d probably expect that if we can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by using a value in kilometers per hour, we could get the value in the same unit
    at a later stage. We emphasize the symmetry between each class factory method
    and its corresponding property by declaring each pair for a particular unit together.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会期望，如果我们可以通过使用以公里每小时为单位的值来创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，那么我们在后续阶段也能够获得相同单位的值。我们通过将每一对特定单位的类工厂方法和对应的属性一起声明，强调了它们之间的对称性。
- en: The methods and properties in [Listing 6-12](#list6-12) don’t prevent us from
    using the wrong units. We could still pass a value in <samp class="SANS_TheSansMonoCd_W5Regular_11">kmh</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>
    factory method. However, by encoding the units that we’re using in the names of
    the class factory methods and properties, we make them more explicit and more
    expressive than using a plain constructor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-12](#list6-12)中的方法和属性并不会阻止我们使用错误的单位。我们仍然可以将一个值以 <samp class="SANS_TheSansMonoCd_W5Regular_11">kmh</samp>
    传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp> 工厂方法。然而，通过将我们使用的单位编码到类工厂方法和属性的名称中，我们使它们比直接使用普通构造函数更为明确和富有表现力。'
- en: Being explicit helps to make the interface to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    consistent and easier to use correctly than incorrectly. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type has become much more than a simple wrapper around a primitive value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的表示有助于使 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 接口更加一致，并且比错误地使用更容易正确使用。我们的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 类型已经不再只是一个简单的包装原始值的容器。
- en: Using explicit names like <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp> to represent the
    available conversions for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance helps maintain the encapsulation of the internal representation. A constructor
    taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameter,
    along with a vaguely named property to simply return that value, leaks the detail
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> has a particular
    underlying representation. The class factory methods and properties shown here
    hide these implementation details and add value for users in the form of some
    common conversions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp>
    这样明确的名称来表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例的可用转换，有助于保持内部表示的封装。一个接受
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 参数的构造函数，以及一个模糊命名的属性来简单返回该值，会泄露
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 具有特定底层表示的细节。这里显示的类工厂方法和属性隐藏了这些实现细节，并通过一些常见的转换为用户增加了价值。
- en: We can easily imagine using similar class factory methods and properties to
    convert between units for other types, such as between Celsius and Fahrenheit
    for temperature, or meters and feet for length.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松想象使用类似的类工厂方法和属性，在其他类型之间进行单位转换，例如在温度单位摄氏度和华氏度之间，或在长度单位米和英尺之间进行转换。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encapsulation and the Public Interface</samp>
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">封装和公共接口</samp>
- en: While it involves more than making data private, encapsulation is built on the
    premise that a type’s internal data can’t be directly accessed—and especially
    can’t be changed—by code other than the type’s methods. Access to private data
    is controlled by the type’s public interface.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管封装不仅仅是让数据变为私有，但它建立在类型的内部数据不能被直接访问——尤其不能被其他代码改变——这一前提上，只有类型的方法才能访问。对私有数据的访问由类型的公共接口控制。
- en: Well-encapsulated types aid us in reasoning about code because we can always
    be sure that private fields have consistent values, and that those values can
    never change without our knowing about it. More than that, it means that, as designers,
    we can change the underlying representation without changing the interface. If
    we never directly expose a type’s data, no code other than that type’s member
    instance methods can ever depend on its representation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 良好封装的类型有助于我们推理代码，因为我们可以始终确保私有字段具有一致的值，并且这些值在没有我们知道的情况下永远不会改变。更重要的是，这意味着作为设计者，我们可以在不改变接口的情况下更改底层表示。如果我们从不直接暴露类型的数据，除了该类型的成员实例方法外，任何其他代码都无法依赖于其表示。
- en: By encapsulating the <samp class="SANS_TheSansMonoCd_W5Regular_11">double amount</samp>
    field of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> as private
    and exposing or operating on it only under the controlled conditions afforded
    by member methods and properties, we limit the scope and impact of changing the
    representation to just those members.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double
    amount</samp> 字段封装为私有，并仅在成员方法和属性所提供的受控条件下对其进行暴露或操作，我们将更改表示的范围和影响限制在这些成员之间。
- en: Correspondingly, if we limit the number of members with direct access to a field,
    we reduce the scope of the change even further. If we write methods that depend
    only on the public interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    they’ll continue to work even if we change the underlying data type.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，如果我们限制具有直接访问字段的成员数量，我们进一步缩小了更改的范围。如果我们编写只依赖于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    公共接口的方法，即使我们更改底层数据类型，它们也会继续工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending the Interface</samp>
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">扩展接口</samp>
- en: If we add too many instance methods to any type, we risk cluttering its interface.
    The core interface of a type is harder to discover when the type has methods that
    are only occasionally useful. By contrast, keeping the methods of a type to a
    reasonable minimum makes the code easier to understand.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向任何类型添加太多实例方法，我们就有可能使其接口变得凌乱。当类型的某些方法仅偶尔有用时，它的核心接口就更难以发现。相比之下，将类型的方法保持在合理的最小数量内，可以使代码更容易理解。
- en: One alternative to instance member methods is to use extension methods, which
    are defined outside the type they extend. An example extension method for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is shown in [Listing 6-13](#list6-13),
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    method uses the public methods and properties defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> with
    a different value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实例成员方法的一种替代方案是使用扩展方法，这些方法定义在它们扩展的类型之外。一个为<sam class="SANS_TheSansMonoCd_W5Regular_11">Speed</sam>类型编写的扩展方法示例在[Listing
    6-13](#list6-13)中给出，其中<sam class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</sam>方法利用<sam
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</sam>中定义的公共方法和属性来创建一个不同值的新的<sam
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</sam>实例。
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-13: Extending the
    interface of Speed</samp>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-13: 扩展Speed的接口</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp> method
    doesn’t modify the instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    passed to it—it can’t, because <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is a read-only struct. Instead, we return a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    with the desired value. An extension method must be defined in a static class,
    so it’s always a static method. It’s common to group methods that extend a particular
    type together in one static class definition, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">SpeedExtensions</samp>
    class might include several methods to extend the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>方法不会修改传递给它的<sam
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</sam>实例——它不能修改，因为<sam class="SANS_TheSansMonoCd_W5Regular_11">Speed</sam>是一个只读结构体。相反，我们返回一个新的具有所需值的<sam
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</sam>实例。扩展方法必须在静态类中定义，因此它总是静态方法。通常，将扩展特定类型的多个方法组合在一个静态类定义中，所以<sam
    class="SANS_TheSansMonoCd_W5Regular_11">SpeedExtensions</sam>类可能会包含多个扩展<sam class="SANS_TheSansMonoCd_W5Regular_11">Speed</sam>接口的方法。
- en: Extension methods are useful for adding utility methods to a type without overburdening
    its principal internal interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法对于在不使其主要内部接口过于繁重的情况下向类型添加实用方法非常有用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reducing the Internal
    Interface</samp>
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">减少内部接口</samp>
- en: A type’s interface defines the collaborations that objects of that type can
    have with other objects in a system. The public methods, constructors, and properties
    defined within the type form the *internal*, or *intrinsic*, interface and define
    what other objects can do with instances of the type. A type also has an *external*,
    or *incidental*, interface comprising methods that take parameters of the type
    but are defined outside it. The external interface defines which other objects
    depend on the type. Those external methods can’t access the type’s internals,
    so they’re unaffected by any changes to the underlying representation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的接口定义了该类型的对象与系统中其他对象之间可以进行的协作。类型内定义的公共方法、构造函数和属性构成了*内部*接口或*固有*接口，定义了其他对象可以对类型实例执行的操作。类型还具有*外部*接口或*偶然*接口，其中包含接受类型参数但定义在类型外部的方法。外部接口定义了哪些其他对象依赖于该类型。这些外部方法无法访问类型的内部，因此它们不会受到底层表示变化的影响。
- en: The essential characteristics of a type with many public members can be difficult
    to discern because the physical definition of the class becomes large. If we restrict
    the internal interface members to those that require access to the type’s private
    implementation details, the type definition becomes shorter and thereby easier
    to comprehend. Methods that can be implemented entirely in terms of the internal
    public interface can be factored out into separate classes. Whether to make them
    extension methods or plain static methods depends on which is the most natural
    usage.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有许多公共成员的类型，其基本特征可能很难辨认，因为类的物理定义变得庞大。如果我们将内部接口成员限制为仅包含那些需要访问类型私有实现细节的成员，那么类型定义会变得更简洁，从而更容易理解。那些可以完全通过内部公共接口实现的方法，可以提取到单独的类中。是否将它们作为扩展方法或普通静态方法，取决于哪种使用方式更自然。
- en: The logical conclusion is that, where possible, we should actively try to reduce
    the internal interface as much as we can without breaking the type’s encapsulation
    or reducing its cohesion. This approach has two competing perspectives. On one
    hand, by extracting methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    that are implemented in terms of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    other public methods, we make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    smaller and easier to comprehend. We also reduce the potential impact of any changes
    we might make to <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    internal representation. On the other hand, <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    is still part of the overall accessible interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    and by extracting that method out separately, we make it harder to discover.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的结论是，在可能的情况下，我们应尽量减少内部接口，而不破坏类型的封装性或降低其内聚性。这种方法有两种相互竞争的观点。一方面，通过提取像<samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>这样的根据<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的其他公共方法实现的方式，我们使得<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>变得更小，更易于理解。我们还减少了对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>内部表示所做更改的潜在影响。另一方面，<samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>仍然是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的整体可访问接口的一部分，通过将该方法单独提取出来，我们使得它更难被发现。
- en: We must find the balance between the internal and external interfaces of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>. Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    method may be a useful utility for <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    values, it isn’t really intrinsic to the concept of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    Extracting it as an extension method doesn’t reduce <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s
    cohesion or break its encapsulation by requiring us to introduce a new property
    that would otherwise be unneeded or change a private member to be public. Collecting
    extension methods like <samp class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>
    in one place is one way to make the external interface easier to discover.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在内部接口和外部接口之间找到平衡，针对<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>。虽然<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>方法可能是一个对<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>值有用的工具，但它并不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>概念的本质部分。将其提取为扩展方法并不会降低<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>的内聚性，也不会通过要求我们引入一个本不需要的新属性，或将私有成员改为公有成员来破坏其封装性。将像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WithPercentAdded</samp>这样的扩展方法集中在一个地方，是让外部接口更容易发现的一种方式。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> class factory
    method, on the other hand, is much better suited as a member of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    We could implement it as a static method on a different type and in terms of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp>. However, doing
    so would reduce the cohesion of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp> naturally go
    together. If we extracted both of those methods to a separate type, we’d need
    to make <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>’s constructor
    public, reducing its encapsulation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    method is intrinsic to the interface of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    because it represents a way to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    in specific units and has a natural affinity with other intrinsic methods.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，<samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> 类工厂方法更适合作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 类型的成员。我们可以将其实现为一个不同类型上的静态方法，并以
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp> 为基础。然而，这样做会降低
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的内聚性，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">FromMetersPerSecond</samp> 自然是一起的。如果我们将这两个方法提取到一个单独的类型中，就需要将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 的构造函数设为公共的，从而降低了它的封装性。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp> 方法是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    接口的内在部分，因为它表示以特定单位创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    的一种方式，并且与其他内在方法有自然的联系。
- en: Some methods *must* be members of their type, even if they could conceivably
    be implemented in terms of other public properties and methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    method overrides a base class implementation and must be an instance method. Overloaded
    operators must all also be static member methods. An operator overload takes at
    least one parameter of the type of which it’s a member, so we can’t implement
    it in a separate type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法 *必须* 是它们类型的成员，即使它们理论上可以通过其他公共属性和方法来实现。<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    方法覆盖了基类的实现，并且必须是实例方法。重载的操作符也必须是静态成员方法。一个操作符重载至少需要一个作为其成员类型的参数，因此我们无法在一个单独的类型中实现它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Composing Abstractions</samp>
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">组合抽象</samp>
- en: Values can be more than simple wrappers around primitive types such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. A struct can contain other
    user-defined types as fields, so we can create new abstractions by composing existing
    ones. We might, for instance, create our own type to represent a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>,
    which combines a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type. Although
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type in [Listing
    6-14](#list6-14) has no behavior of its own, it can take advantage of the richer
    abstractions represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以不仅仅是对基本类型的简单封装，比如 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。结构体可以包含其他用户定义类型作为字段，因此我们可以通过组合现有的抽象类型来创建新的抽象类型。例如，我们可以创建一个新的类型来表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>（速度），它将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>（速度）类型和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>（角度）类型结合起来。虽然 [Listing
    6-14](#list6-14) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    类型本身没有行为，但它可以利用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 所代表的更丰富的抽象。
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-14: Composing a new
    abstraction for Velocity</samp>'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-14: 为 Velocity 组合一个新的抽象</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type benefits
    from the validated constraints on the possible values of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> and can use any
    of their public operations and properties, including any extension methods. Building
    on those contained types, we can add to <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    any behavior that’s specific to it, such as arithmetic operations or conversions
    to and from different representations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>` 类型受限于 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>`
    的可能值的验证约束，可以使用它们的任何公共操作和属性，包括任何扩展方法。在这些包含的类型的基础上，我们可以为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>`
    添加任何特定于它的行为，例如算术操作或不同表示形式之间的转换。'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> represents a specific
    single concept, even though it’s a kind of container for values of other types.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> aren’t
    arbitrary; they define what it means to be a measurement of velocity. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> abstraction forms part
    of the vocabulary of a program, along with <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>` 代表一个特定的单一概念，尽管它是一个用于存储其他类型值的容器。
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>` 的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>`
    和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>` 属性不是任意的；它们定义了速度测量的含义。`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>` 抽象是程序词汇的一部分，连同 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>`
    一起使用。'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> is a good candidate
    for implementation as a record or record struct, particularly using the compact
    positional syntax available for those types. However, the positional syntax is
    less well suited for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types. To explain
    why, in the next section we’ll look at some of the trade-offs and compromises
    among the different ways of defining types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>` 是作为记录或记录结构体实现的一个不错选择，特别是使用这些类型可用的紧凑位置语法。然而，位置语法不太适合
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>`
    类型。为了说明原因，接下来的章节我们将探讨定义类型的不同方式之间的一些权衡和折中。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Choosing Between Value and Reference
    Semantics</samp>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_Futura_Std_Bold_B_11">选择值语义与引用语义</samp>`'
- en: In most programs, the majority of user-defined types will be classes, which
    support the widest array of features offered by C#. Classes are the most general-purpose
    way in C# of creating our own types because they support all the object-oriented
    facilities of the language, such as inheritance and virtual methods. Class instances
    also benefit from the automatic memory management afforded to objects allocated
    on the heap. Generally, only when we need the behavior associated with value semantics
    should we define a type differently.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数程序中，大多数用户定义的类型将是类，类支持 C# 提供的最广泛的特性。类是 C# 中创建我们自己类型的最通用方式，因为它们支持语言的所有面向对象功能，例如继承和虚方法。类实例还受益于堆上分配的对象所提供的自动内存管理。通常，只有当我们需要值语义相关的行为时，才应该以不同的方式定义类型。
- en: We have a few indicators that value semantics are appropriate for a type we’re
    defining. Values shouldn’t support changes to their state, which is why it’s recommended
    that value types contain only other values. When all value types are immutable,
    regardless of whether they’re implemented using classes, records, structs, or
    record structs, we don’t have to worry about the state of an object changing unexpectedly,
    because the behavior of our code is more predictable. A type that requires unrestricted
    write access to its state is usually a poor candidate for being a value.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些指示器可以判断某个类型定义是否适合使用值语义。值类型不应支持其状态的更改，这也是为什么建议值类型仅包含其他值的原因。当所有值类型都是不可变的，无论它们是通过类、记录、结构还是记录结构实现的，我们就不必担心对象的状态会意外改变，因为我们的代码行为更加可预测。需要对其状态进行不受限制写入访问的类型，通常不是值类型的好候选。
- en: A related indicator is needing the type to support a full deep copy of its state.
    We need a *deep copy*, also known as a *clone*, to copy mutable state when we
    want to avoid the side effects associated with aliasing references. Most commonly,
    the state needs to be written only immediately after cloning so that the new object
    can have different properties than the original. The non-destructive mutation
    facility we examined in [Chapters 2](chapter2.xhtml) and [4](chapter4.xhtml) is
    a good example of providing limited mutability for value-like types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的指示器是需要类型支持其状态的完整深拷贝。当我们想避免别名引用带来的副作用时，我们需要进行*深拷贝*，也称为*克隆*，以复制可变状态。通常，状态需要在克隆之后立即被写入，以便新对象可以与原对象具有不同的属性。我们在[第2章](chapter2.xhtml)和[第4章](chapter4.xhtml)中讨论的非破坏性变异功能就是为类似值的类型提供有限可变性的一个很好例子。
- en: Anytime we customize equality behavior for a class so that two instances can
    be compared according to their state, it’s another strong indicator that the type
    should be implemented as a full-fledged value. Cloning is often accompanied by
    an overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们为一个类定制相等性行为，使得两个实例能够根据其状态进行比较时，这就是另一个强烈的指示，表明该类型应该实现为一个完整的值类型。克隆通常伴随有重写的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。
- en: State-based equality behavior and support for deep copies to avoid aliasing
    problems are two of the strongest signs that value semantics are needed. Although
    it’s possible to use a class to implement a value (as we’ve seen with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>),
    the other kinds of type definition are usually preferable.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 基于状态的相等性行为以及支持深拷贝以避免别名问题，是需要值语义的两个最强信号。尽管可以使用类来实现一个值类型（正如我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    中看到的那样），但其他类型定义通常更为优先。
- en: Records, structs, and record structs are all facilities for creating types that
    represent values—that is, for defining types that have *value semantics*. The
    choice between them isn’t necessarily obvious, as each has different advantages
    and disadvantages.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型、结构体和记录结构体都是用于创建表示值的类型的工具——也就是说，用于定义具有*值语义*的类型。它们之间的选择并不总是显而易见，因为每种类型有不同的优缺点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding the Pitfalls
    of Default Variables</samp>
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">避免默认变量的陷阱</samp>
- en: 'For struct and record struct types, we need to remember that instances can
    always be default-initialized, so the default value must be considered valid both
    by the type’s implementation and by code using the type. For simple numeric types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp>,
    this isn’t a problem. The default value for such types is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    which is a perfectly acceptable state no matter the unit: 0 meters is precisely
    the same value as 0 miles or 0 inches.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构体和记录结构体类型，我们需要记住，实例总是可以进行默认初始化，因此默认值必须被类型的实现以及使用该类型的代码视为有效。对于像 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Length</samp> 这样的简单数值类型，这不是问题。此类类型的默认值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，无论单位是什么，这都是一个完全可以接受的状态：0米与0英里或0英寸是完全相同的值。
- en: 'The same is not universally true for all values. In temperature measurements,
    for example, the unit of the stored value matters: 0°C is 32°F, and 0°F is approximately
    –17.78°C. We might establish the convention that the default unit for <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    is Celsius, but it’s hard to make that explicit without having a separate type
    for each unit, which seems unnecessary.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: If we use a class or record instead of a struct or record struct, we can prevent
    default values and force our users to specify the correct units when creating
    instances. However, classes and records are both reference types, meaning that
    variables can have a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value. We can mitigate that in C# v8.0 and later by taking as much advantage of
    non-nullable references as we can, although that might not prevent every possible
    misuse.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding that, when we’re deciding between a class or record to model
    a type that has value-like characteristics, a record is almost always preferable.
    Records are specifically intended to define types that have value semantics, and
    the compiler provides the default equality behavior for records based on the state
    of the instances being compared.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Custom
    vs. Generated Behavior</samp>
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want a class to have value-based equality, we must define it ourselves.
    As a minimum, we should override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods,
    but, as you saw in [Chapter 5](chapter5.xhtml), a more complete definition includes
    implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp>
    interface and overloading <samp class="SANS_TheSansMonoCd_W5Regular_11">operator=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, and its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    to make equality comparisons natural and easy.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: For most value-like types, implementing those methods is straightforward as
    long as we’re careful to avoid common mistakes. However, if we use <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>, the compiler
    generates implementations for all those methods. This makes a record type definition
    smaller and easier to comprehend and saves us from having to remember all the
    potential pitfalls.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: For our prospective <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    type, we might consider a positional record, saving us the trouble of a complete
    definition. A provisional implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    as a positional record might look like the definition in [Listing 6-15](#list6-15),
    but positional records have limitations to take into account.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-15: A positional
    Temperature record</samp>'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The compiler uses the parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>’s
    definition to automatically generate a property named <samp class="SANS_TheSansMonoCd_W5Regular_11">InCelsius</samp>,
    but we must write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">InFahrenheit</samp>
    property so we can add the code to perform the conversion. Users can invoke the
    class factory methods to create <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    instances with different units, but the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    generated by the compiler is *public*. The generated constructor also won’t validate
    its parameters, and we might want to ensure that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>
    can’t be below absolute zero.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: If we want users to be explicit about the units, we need to force them to use
    those class factory methods, so a positional record doesn’t meet our needs. For
    the same reasons, the positional syntax isn’t appropriate for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types we used in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> in [Listing 6-14](#list6-14).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding Generated
    Methods</samp>
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the positional record syntax won’t meet our needs, we can use a full record
    definition, which doesn’t have the positional type arguments. We can then provide
    our own *private* constructor and use that to validate the initial value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We sacrifice some of the convenience of using a positional record for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp> because we have to
    write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">InCelsius</samp> property,
    since the compiler generates properties only for positional records. The record
    definition in [Listing 6-16](#list6-16) shows how we can customize behavior for
    a record type while still enjoying the benefits of the other code provided by
    the compiler.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-16: A full record
    definition for Temperature</samp>'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will still generate the methods to implement value-based equality
    for a nonpositional record, leaving us to concentrate on correctly implementing
    any other behavior specific to a record type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Temperature</samp>.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器仍然会为非位置记录生成方法，以实现基于值的相等性，这样我们可以专注于正确实现与<code class="SANS_TheSansMonoCd_W5Regular_11">Temperature</code>类型相关的其他行为。
- en: 'Records and record structs offer the greatest benefit over classes and structs,
    respectively, when we can accept all the default behavior of the positional syntax.
    A good example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type from [Listing 6-4](#list6-4), which as a positional record struct would look
    like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们能够接受位置语法的所有默认行为时，记录和记录结构比类和结构体提供了最大的优势。一个很好的例子是[示例 6-4](#list6-4)中的<code
    class="SANS_TheSansMonoCd_W5Regular_11">Color</code>类型，作为位置记录结构，它看起来像这样：
- en: '[PRE16]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, a default-initialized
    instance is a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and compares equal to an instance with properties that are all <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    as shown in this example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于<code class="SANS_TheSansMonoCd_W5Regular_11">Color</code>类型，默认初始化的实例是一个有效的<code
    class="SANS_TheSansMonoCd_W5Regular_11">Color</code>，并且与所有属性为<code class="SANS_TheSansMonoCd_W5Regular_11">0</code>的实例比较时是相等的，示例如下：
- en: '[PRE17]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We don’t have to add any of our own methods or properties, so the positional
    syntax is compact and does exactly what we need.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要添加任何自定义的方法或属性，因此位置语法简洁且恰好能满足我们的需求。
- en: Records and record structs can be convenient for defining simple value types
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, although the
    compiler might not provide everything required by a type. In particular, if we
    need to compare two values to see if one is less than the other, we must always
    provide our own implementation of that comparison.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 记录和记录结构对于定义简单的值类型（如<code class="SANS_TheSansMonoCd_W5Regular_11">Color</code>）非常方便，尽管编译器可能不会提供类型所需的所有内容。特别是，如果我们需要比较两个值，看看一个是否小于另一个，我们必须始终提供自己的比较实现。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Comparison for Ordering</samp>
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">排序比较</samp>
- en: The principle of value-based equality is the *one thing* that defines what it
    means to be a value. When we talk about whether something is a value type, that’s
    really shorthand for whether two instances compare equal according to their state
    or according to their identity. Using state as the basis for equality is intrinsic
    to all values. However, some values may be equivalent but not necessarily equal.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 基于值的相等性原则是定义什么是值的*唯一标准*。当我们讨论某物是否是值类型时，这实际上是指两个实例是否根据它们的状态或身份比较相等。使用状态作为相等性的基础是所有值的内在特性。然而，有些值可能是等价的，但不一定相等。
- en: Normally, two values are equal if they have exactly the same state. Two instances
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> record struct
    in [Listing 6-17](#list6-17) are equal if all the properties are also equal, whereas
    the identity of individual <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    instances isn’t important.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果两个值具有完全相同的状态，它们被认为是相等的。在[示例 6-17](#list6-17)中，两个<code class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</code>记录结构实例相等的前提是它们的所有属性也都相等，而单个<code
    class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</code>实例的身份并不重要。
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-17: Value type equality</samp>'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 6-17：值类型相等性</samp>
- en: Some, but not all, values have a natural ordering, which enables us to sort
    collections of them. Many sorting algorithms exist, but all generally work by
    comparing each item in a collection with the others in turn to determine whether
    one is less than the other. If the left-hand value is less than the right, the
    items are considered to be in order.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有些值具有自然的排序顺序，这使得我们可以对它们进行排序。存在许多排序算法，但所有排序算法通常都是通过依次比较集合中的每个项，确定一个是否小于另一个。如果左侧的值小于右侧，则这些项被认为是按顺序排列的。
- en: We can customize the meaning of *less than*, and therefore *in order*, for our
    own purposes. In C#, the protocol for defining *less than* is the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> interface, which requires us to implement a single method named <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> for a type. If the left
    argument is less than the right, <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    returns a negative integer; if the right is less than the left, the result is
    positive. Otherwise, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values to see if they’re equal, we use all the properties. For ordering, however,
    we might care only about the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    property, because we merely want to put the entries in the order in which they
    were logged. Ordering <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values by message makes little sense, and ordering them by severity isn’t necessary
    for our use case.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    instance, which itself implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    interface, so [Listing 6-18](#list6-18) implements <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> simply by comparing
    only the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp> properties.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-18: Defining ordering
    by TimeStamp for a LogEntry value</samp>'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: We normally wouldn’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    on a <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> instance directly;
    it would usually be invoked indirectly when we sort a collection of <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values. Unless we explicitly specify a different comparison to be used for sorting,
    our <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> method will
    be used to determine how to order <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    elements, so the default ordering for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    values is based solely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    property.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Values have *extensionality*: two instances are equal if they have the same
    observable properties. This isn’t necessarily the same as having the same structural
    definition, called *intentionality*. It’s possible, although relatively rare,
    to need extra data that doesn’t contribute to the value in a meaningful way and
    thus isn’t used in a test for equality. Such data is usually also a private detail
    of the implementation.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between intentionality and extensionality becomes more important
    when we want not only to compare values for equality but also to order them. Putting
    values in order requires a different but closely related comparison, which may
    result in two unequal values being equivalent for the purposes of sorting them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equivalence vs. Equality</samp>
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most value types, if <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, then the two values
    are indeed equal, and calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. This is
    the case for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value underlying our <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    property. However, while this result is what we’d normally expect, it’s not a
    strict requirement. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method should return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> when
    neither value is less than the other, although those values may not actually be
    equal. Rather, the values are *equivalent* for the purposes of ordering.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: With our <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> value,
    two values are equivalent when their <samp class="SANS_TheSansMonoCd_W5Regular_11">TimeStamp</samp>
    properties exactly match. Even so, the two values might very well be *un*equal
    because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Severity</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp> properties might
    be different, as the simple test in [Listing 6-19](#list6-19) demonstrates.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-19: Equality versus
    equivalence for LogEntry</samp>'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'This code shows no contradiction: the two entries have clearly different values,
    but for the purpose of sorting <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    instances, they’re nevertheless equivalent because it doesn’t matter whether one
    goes before or after the other. Equivalence doesn’t necessarily imply equality,
    and we should avoid the temptation to implement equality in terms of <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: A fairly common example demonstrating the difference between equivalence and
    equality is comparing string values. Sometimes we want to use a case-insensitive
    string comparison for ordering but not for equality. The two string values <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"September"</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">"september"</samp>
    might be considered equivalent for sorting, but they’re clearly not equal.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Contract for
    Comparisons</samp>
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must meet certain expectations for the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method. In particular, comparing a single value with itself should report equivalence;
    that is, <samp class="SANS_TheSansMonoCd_W5Regular_11">x.CompareTo(x)</samp> must
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. More generally, for
    two objects that are equal according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> should
    return <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    interface is a contract, and the semantics of comparing one object with itself
    is just one aspect of that contract.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    implementation to define the comparison operator <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>, which gives
    us a natural way to see if <samp class="SANS_TheSansMonoCd_W5Regular_11">log1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">log2</samp>
    and a more compact way of expressing the rest of the contract. The contract for
    the less-than relationship specifies that it has the following characteristics:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**Irreflexive**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is always <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Antisymmetric**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> must be <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Transitive**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>
    must also be <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> remains the same as long
    as neither value is changed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Comparing values of the same type does not throw exceptions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We can define <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp> for reference
    types in a similar way, although we also need to consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, which should always compare less than any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Kinds of Ordering</samp>
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ordering by <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> is an example of ordering
    by magnitude, but other orderings are possible. Strings commonly use a *lexicographical*
    ordering, which broadly means that one string is less than another if it would
    appear before the other in a lexicon, better known as a dictionary.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Other values are ordinal in nature, such as months of the year. Ordinal comparisons
    sometimes need a bit of care. Take days of the week in English as an example:
    should Sunday come before Monday? The answer to that question depends on how we
    define the first day of the week.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Some values aren’t intrinsically less than another. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type is an example: red comes before blue when we enumerate the colors in a rainbow—a
    property of their relative wavelengths—but blue certainly comes before red in
    an English dictionary. We might apply one of several orderings to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    objects under different circumstances, but those definitions of ordering are external
    to the concept of a color.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We can customize the ordering of elements in a sequence on a case-by-case basis
    by creating our own comparer, or even multiple comparers to address different
    scenarios. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparer< T ></samp>
    interface complements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> interface from [Chapter 5](chapter5.xhtml). Just as <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> establishes an equality comparison that’s external to the types being
    compared, an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparer<
    T ></samp> is an externally defined ordering comparison. [Listing 6-20](#list6-20)
    shows a custom comparer type for ordering <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    objects by their <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>
    property rather than by time.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-20: Defining an external
    comparer for LogEntry objects</samp>'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The semantics of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare</samp>
    method match those of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable.CompareTo</samp>,
    returning a negative integer when <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, a positive
    integer when <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is less than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    otherwise. Several of the sorting algorithms in the Standard Library have overloads
    that accept an explicit comparer object as an argument, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">Order</samp>
    method shown here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">alphabeticalLog</samp> is
    a new list of <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> elements
    sorted alphabetically by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntryComparer.Compare</samp>
    comparison. Similar overloads are provided for <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.Sort</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.BinarySearch</samp> and the constructor
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">SortedList</samp>.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Ordering is a common characteristic of values, but not an essential one in the
    same way that value-based equality is. When a value has a natural ordering, implementing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> method makes
    sense. Reference types, on the other hand, generally don’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    unless they also override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Mixing identity-based equality with value-based ordering, or vice versa, will
    likely lead to confusion and probably errors that are hard to track down. In particular,
    references have no natural ordering; saying that the value of one reference is
    less than another makes no sense.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Perils of Uniformity and Consistency</samp>
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes coding guidelines advise that we should override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and implement <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> for
    every type. The thinking behind such rules is usually to try to remove restrictions
    on the use of objects. Types that don’t implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    can’t be used as keys in a <samp class="SANS_TheSansMonoCd_W5Regular_11">SortedList</samp>.
    Types that don’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> can’t be
    used reliably as keys in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>.
    While we can use an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparer<
    T ></samp> to address the former, and a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer<
    T ></samp> for the latter, we must remember to explicitly use those implementations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Such guidelines aim to improve consistency and remove the barriers to commonplace
    requirements. The goal is usually to enable *any* object to be used as a key in
    a hashing container, or collections of them to be sorted according to their state,
    without needing explicitly defined external comparers.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines that suggest this kind of uniformity ignore the fact that values
    and non-values are semantically and conceptually different, and the differences
    go far beyond the technical characteristics of reference types and value types.
    Reference semantics have their own desirable characteristics, especially when
    we actively need multiple aliasing references to a single, mutable instance. Those
    characteristics don’t lend themselves well to being used as keys in collections,
    and they often cause conflict with ordering too. A sorted collection of mutable
    objects can easily become *un*ordered by altering the state of its elements, which
    gives us one more reason for all our value types to be immutable. A collection
    of values that has been sorted should remain sorted.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve discussed, some types have no natural ordering. Let’s revisit the
    example of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. Insisting
    that a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp> interface
    would leave us with a problem: how should <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    behave for two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values?
    We could choose one plausible implementation, but that might not satisfy every
    use case, leading to difficulties in other aspects of our code. This is why, while
    records and record structs provide a default implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface, they don’t also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp>. Even when the individual fields can be compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>,
    it doesn’t always mean that the whole type can be compared that way. All the fields
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values that implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    int ></samp>, after all, but *less than* isn’t a meaningful comparison for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of overriding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for value types isn’t primarily to allow them to be used as keys. Values
    have no use for referential equality, because one value is as good as any other
    value with the same properties. Value-based equality is the single, natural way
    to compare those variables that are values.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Reference types, by contrast, often depend on identity-based equality. Any type
    not specifically intended to have value semantics probably shouldn’t be used as
    a key in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp>.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arithmetic and Nonarithmetic
    Types</samp>
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as not all values have a natural ordering, some values are arithmetic by
    nature, and some are not. We might, for example, define operations to allow instances
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> type from [Listing
    6-11](#list6-11) to be added together. Operations like addition have a natural
    representation with arithmetic operators, such as in an expression like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">startingSpeed</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed.FromKmh(10)</samp>.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Introducing support for arithmetic operations, or indeed any operation, requires
    a certain amount of discretion on our part as designers. We need to be mindful
    of both the common use cases for the types we create and the wider expectation
    from, for example, being able to add two instances together with a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    operator.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> type in [Listing 6-17](#list6-17)
    isn’t arithmetic in nature, so we should avoid overloading the arithmetic operators
    for it. Adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    instances makes no sense.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: It does make sense for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    to overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and
    its counterpart <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for equality comparisons. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>
    type is a record struct, so the compiler will provide the equality operator definitions
    automatically. Since we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    LogEntry></samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp>,
    we should also consider overloading <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator></samp>, which the
    compiler won’t provide. [Listing 6-21](#list6-21) shows that implementing these
    operators in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method is straightforward.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-21: Equivalence comparison
    operator definitions</samp>'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: These operator definitions make handling equality and comparisons much more
    natural for <samp class="SANS_TheSansMonoCd_W5Regular_11">LogEntry</samp> instances.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nonstandard Operator
    Behavior</samp>
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Occasionally, arithmetic operators are useful beyond truly arithmetic operations.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instances
    can be “added” together, and most programmers understand that adding two strings
    concatenates them, so <samp class="SANS_TheSansMonoCd_W5Regular_11">"key"</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"board"</samp>
    becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">"keyboard"</samp>. In arithmetic,
    addition is commutative, so <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    gives the same result as <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
    This clearly isn’t true when used with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instances, but concatenating two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>s
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> is a widely used and
    accepted convention.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: When we bend the rules this way, it’s especially important that we’re mindful
    of conventions, natural usage, and expectations. For instance, in arithmetic the
    ability to add numbers together goes hand in hand with the facility for subtraction.
    Consider what subtracting one string from another might mean. Would it remove
    all instances of the right-hand argument from the left-hand string? Only if it
    appeared at the end of the string? String subtraction doesn’t have the natural
    and conventional appeal that string addition/concatenation does.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We’d normally expect to find a symmetry between <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and symmetry is usually
    a desirable quality. When we overload <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    the compiler insists that we also implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator. Coupling addition with
    subtraction for <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> values
    is one example where symmetry is undesirable, because it introduces conflicting
    expectations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Symmetry is inappropriate in other situations too. For example, matching every
    property <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor with
    a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> is superficially
    attractive but contradicts the recommendation that value types are immutable.
    This is another instance where we need to apply our own judgment on whether symmetry
    is a positive characteristic.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*It’s not hard to make decisions when you know what your values are.*'
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Roy Disney, American film writer and producer
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although C# has its own definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    the broader concept of a value isn’t specific to C#. That more general idea of
    a value type has commonalities with the C# definition, but notable differences
    exist.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The language definition of a value type focuses mainly on the memory requirements
    and behavior associated with structs. We need to take other factors into account,
    however, in order to decide when and how to introduce values into our programs.
    In this chapter, we’ve explored some of those considerations by contrasting values
    with reference types—in particular, by examining how values fulfill specific and
    important roles in a program.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented systems are made up of several kinds of objects with varying
    emphasis on the characteristics of identity, state, and behavior. When an object’s
    role places a high importance on instance identity, it’s a strong indicator that
    the type shouldn’t be a value type. When the priority is an object’s state and
    identity is unimportant, the type is almost certainly best modeled as a value.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Whether a type has a single field or many fields isn’t necessarily the best
    metric for choosing whether to make it a value. Sometimes we want value semantics,
    and sometimes reference semantics are more important. The phrases *value semantics*
    and *copy by value* are sometimes used interchangeably and even defined in terms
    of each other. However, value semantics has more to do with value-based equality
    than with copying.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing value types from other kinds of types is an important first step
    in partitioning their responsibilities in an application. Identifying candidate
    value types helps us clarify our designs by introducing specialized types that
    encapsulate behavior and responsibilities. In turn, we benefit from a more modular
    system, both in its implementation and in the testing it requires. Having decided
    a type should be modeled as a value, we have more options for implementing it.
    C# has rich support for all user-defined types, but its facilities for value types
    are sometimes unappreciated.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#fn-1) FORTRAN programmers, please remain silent on this ([*https://<wbr>softwareengineering<wbr>.stackexchange<wbr>.com<wbr>/questions<wbr>/254799<wbr>/ever<wbr>-change<wbr>-the<wbr>-value<wbr>-of<wbr>-4<wbr>-how<wbr>-did<wbr>-this<wbr>-come<wbr>-into<wbr>-hayes<wbr>-thomas<wbr>-quiz*](https://softwareengineering.stackexchange.com/questions/254799/ever-change-the-value-of-4-how-did-this-come-into-hayes-thomas-quiz)).'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[2](#fn-2) With thanks and apologies to Scott Meyers.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
