<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_3"/><span class="big">1</span><br/>A CHERRY-PICKED REVIEW OF PROGRAMMING LANGUAGES</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">This book’s primary goal is to explore new ways to think about coding. Doing so will help you become a better coder, regardless of what language you are using. To that end, it makes sense to review existing programming languages, especially the languages that first introduced a particular coding paradigm or strongly influenced later languages.</p>&#13;
<p class="indent">The languages discussed in this chapter are not esolangs. Instead, they are serious approaches to the process of coding, meaning the process of translating thought into something a computer can use to solve a problem. Some of these languages are still in use. Others flowered briefly and then died. Still others evolved into something new. All of these languages have things to teach us, in addition to being fun to learn about and work with.</p>&#13;
<p class="indent">We’ll begin the chapter with a bit of programming language paleontology. Following that, we’ll consider the first programming languages. Even if you are still relatively new to coding, you already have a conception of what coding is and how to do it. That wasn’t always the case—the very idea of coding had to come from somewhere. It’s worth our time to take a look.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_4"/>The remainder of the chapter is a series of vignettes, in roughly chronological order, that introduce us to a collection of programming languages we should keep in the back of our minds as we move through the book. We’ll spend the next few chapters exploring select languages in still more detail before diving into esolangs proper.</p>&#13;
<p class="indent">There are thousands of programming languages (see <em><a href="http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm">http://www.info.univ-angers.fr/~gh/hilapr/langlist/langlist.htm</a></em>), so why this particular set? I selected languages that were important to the development of future languages and, as such, often represent a new conception of programming, or languages that were novel in some way that will help us when we get to esolangs.</p>&#13;
<p class="indent">All of the languages presented in this chapter were invented before the year 2000. Of course, that’s not to say programming language development stopped with Y2K. There are a plethora of new languages: Rust, Scala, Julia, Go, Kotlin, and Swift are all examples of languages developed after 2000. There will be no end to developing new programming languages. However, the current trend in language design leans toward multi-paradigm languages that take the best of what came before and mix it in some way with the hope of creating synergy. In other words, something greater than the sum of its parts. This trend validates our review of older languages with novel ideas as that is precisely what new languages are doing.</p>&#13;
<p class="indent">Let’s begin.</p>&#13;
<h3 class="h3" id="lev1sec7"><strong>Programming Language Paleontology</strong></h3>&#13;
<p class="noindent">Paleontology, literally the study of ancient being, is concerned with the history of life on Earth as well as the equally important diversity of life, that is, the number and kind of species. An important event studied by paleontologists is the <em>Cambrian explosion</em>, which was the sudden appearance of a huge assortment of animals in the fossil record.</p>&#13;
<p class="indent">The best-known fossil site related to the Cambrian explosion, from a time just after it, is the Burgess Shale of western Canada. The Burgess Shale is a priceless fossil site, half a billion years old, where the soft body parts of a myriad of animals, most unlike any living today, are preserved.</p>&#13;
<p class="indent">Burgess Shale fauna, entirely marine, has familiar representatives, like trilobites, which are favorites of fossil collectors. But the real stars of the Burgess Shale are weird animals like <em>anomalocaris</em>, a large predator so unusual that its various body parts were originally classified as separate animals, or the five-eyed Opabinia, with its single, trunk-like arm and claw. Then there is Hallucigenia, a spiny, worm-like creature initially described upside down as if it were walking the sea floor on its spines.</p>&#13;
<p class="indent">Later life, which for us means more mainstream life, is definitely more familiar, if less diverse. Fish dominated the later Paleozoic seas and eventually wandered out of the water onto land to become the first tetrapods, a body plan that land-dwelling vertebrates from crocodiles to pterosaurs, dinosaurs, elephants, and humans have maintained virtually unchanged ever since.</p>&#13;
<span epub:type="pagebreak" id="page_5"/>&#13;
<div class="image"><img id="ch01fig1" src="Images/01fig01.jpg" alt="Image" width="587" height="698"/></div>&#13;
<p class="figcap"><em>Figure 1-1: A geologic time scale of programming languages</em></p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01fig1">Figure 1-1</a> shows a time scale of geologic history with programming languages marked at various places.</p>&#13;
<p class="indent">The silhouettes in <a href="ch01.xhtml#ch01fig1">Figure 1-1</a> indicate the type of life dominant at the time. What is important for us is not so much the time scale, but the diversity of life. Modern life, signified by the mammals during the Cenozoic era, such as Smilodon, the famed sabre-toothed cat, and the mighty mammoth, are related to newer languages like Python, Java, and C#. These languages are familiar and not at all surprising to us.</p>&#13;
<p class="indent">For the Mesozoic we have dinosaurs, including Alectrosaurus, a hunter who terrorized the late Cretaceous. Also present are a living tank, Edmontonia, and Achelousaurus, the prehistoric equivalent of a buffalo, but with fearsome horns. Although different in some ways, and perhaps a bit old, dinosaurs are familiar, so I’ve placed C and C++ in their company. Lest you think I’m slighting C and C++, do remember that the dinosaurs ruled the land for more than 100 million years and continue to rule the air even now, for birds are dinosaurs.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_6"/>The later Paleozoic era, the Age of Fishes, seems a good place for unusual, but still not entirely alien, programming languages like Forth, SNOBOL, and CLIPS, all three of which we’ll explore in this book. The fish silhouettes from the time are Eusthenopteron, the lobe-finned Sarcopterygii, and the jawless and armored Ostracoderm.</p>&#13;
<p class="indent">The Burgess Shale, the time of Anomalocaris, Opabinia, and Hallucigenia, is also marked. The diversity and unusual body plans of the Burgess Shale seem a perfect analogy for esolangs—experimental, perhaps evolutionary dead ends, but important all the same because they pushed the boundaries of what could be, before natural selection’s heavy hand decided who continued and who didn’t.</p>&#13;
<p class="indent">To me, esolangs are like the weirdly wonderful animals of the Burgess Shale. Like those animals, esolangs are experiments, forays into what could be, existing and thriving even if not destined to endure. The animals of the Burgess Shale made paleontologists rethink and reevaluate how they approached ancient life. Similarly, esolangs, if we let them, make us rethink and reevaluate how we approach programming.</p>&#13;
<p class="indent">Esolangs are weird, often very strange and alien, but that’s the point. Like the beautifully bizarre animals of the Burgess Shale, esolangs explore niches in novel, unusual ways that might not be practical, but are definitely interesting and, most of all, fun.</p>&#13;
<p class="indent">There you have it: geology and computer science living together, sans mass hysteria. Hopefully, <a href="ch01.xhtml#ch01fig1">Figure 1-1</a> provides some food for thought, or at least an alternative viewpoint. We’ll refer to <a href="ch01.xhtml#ch01fig1">Figure 1-1</a> from time to time throughout the book, but for now, let’s move on and explore the first programming languages.</p>&#13;
<h3 class="h3" id="lev1sec8"><strong>The First Programming Languages</strong></h3>&#13;
<p class="noindent">What was the first programming language? That’s a difficult question to answer without defining <em>programming language</em>. We’ll define what we mean by a programming language in <a href="ch02.xhtml#ch02">Chapter 2</a>. For now, we’ll use an intuitive definition: a programming language is a means by which an algorithm can be encoded to control a machine, specifically a computer.</p>&#13;
<h4 class="h4" id="lev2sec1"><strong><em>Programming Before Computers</em></strong></h4>&#13;
<p class="noindent">The idea of a programmable machine predates the idea of a programmable computer. The <em>Jacquard loom</em>, a loom that used punch cards for control, was introduced in 1804. The pattern of dots on the card controlled the movement of threads in the loom to specify the pattern woven. There is a language there, something that can be varied to produce a different output. Change the pattern of holes on the card and a new pattern emerges from the machine. The rolls for a player piano work in much the same way.</p>&#13;
<p class="indent">In fact, the first “modern” computer design, Charles Babbage’s <em>Analytical Engine</em>, was influenced by the Jacquard loom. Although the Analytical Engine was never built, the engine had all the key components found <span epub:type="pagebreak" id="page_7"/>in a modern computer and was programmable using punch cards. In 1843, while translating a set of lecture notes on the Analytical Engine from French to English, Ada Lovelace, Babbage’s long-time friend and daughter of the famous poet Lord Byron, wrote about the capabilities and potential uses of the Analytical Engine. She envisioned using the Analytical Engine for computation, but went further, imagining that the engine could be used for composing music and would release scientists from tedious computation, thereby freeing them for more advanced thinking. Ada was correct on both counts.</p>&#13;
<p class="indent">The translation, and more importantly, Ada’s insightful and brilliant notes, are in “Sketch of the Analytical Engine” in volume III of <em>Taylor’s Scientific Memoirs</em> (1843, pp. 666–731). An online search will quickly locate a PDF version. I highly recommend reading through Ada’s notes, at least Note A. However, Ada’s Note G is most important to us. There, she applied an algorithm to the engine to compute Bernoulli numbers to demonstrate how the engine would compute the result. Bernoulli numbers are used in different areas of mathematics, but how they are used is unimportant to us. What matters is that Ada took an algorithm and structured it for the Analytical Engine—that is, she wrote a program for a general-purpose computer. It then seems fair to claim that Ada wrote the world’s first computer program in 1843. The programming language she used was the <em>diagram of development</em> notation she introduced in Note D.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01fig2">Figure 1-2</a> presents Ada’s program. It details the sequence of steps, the variables involved, and how they change during the computation. Various people have translated her program into modern programming languages. Of particular interest is that she seems to have made an error, the world’s first computer bug.</p>&#13;
<div class="image"><img id="ch01fig2" src="Images/01fig02.jpg" alt="Image" width="589" height="413"/></div>&#13;
<p class="figcap"><em>Figure 1-2: Ada Lovelace’s Analytical Engine program to calculate the eighth Bernoulli number (1843)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_8"/>Step 4 of <a href="ch01.xhtml#ch01fig2">Figure 1-2</a> calculates <span class="literal">v5 / v4</span>; however, the correct calculation is <span class="literal">v4 / v5</span>. With that modification, translations into modern languages produce the correct result: <em>–</em> 1/30. Translations into C and Python are available on the internet. To learn more about Ada’s life, I recommend <em>Ada’s Algorithm</em>, by James Essinger (Melville House, 2015). She was ahead of her time, even though her own life was so short.</p>&#13;
<h4 class="h4" id="lev2sec2"><strong><em>The First Modern Programming Languages</em></strong></h4>&#13;
<p class="noindent">The first programming language in the modern sense was <em>Plankalk</em><em>ü</em><em>l</em>, developed by Konrad Zuse around 1943, 100 years after Ada’s first program. Plankalkül is German for “plan calculus” or “plan calculation.” Zuse used Plankalkül as a high-level programming language, though it was not implemented for any of his “Z” series computers. The language supported structured programming with <span class="literal">for</span> and <span class="literal">while</span> loops, floating-point arithmetic, arrays, and other features found in modern programming languages. Interestingly, the syntax of Plankalkül is 2D, with symbols written above other symbols. Zuse’s word for a program was “rechenplan,” which means “arithmetic” or “computation” plan. A good summary of Plankalkül can be found in “The Plankalkül of Konrad Zuse: A Forerunner of Today’s Programming Languages,” by Bauer and Wössner, Communications of the ACM 15, no. 7 (1972).</p>&#13;
<p class="indent">Lovelace and Zuse, respectively, deserve credit for the first program and the first programming language. But neither program nor language worked on actual, physical computers. The first programming language for a working computer is likely up for much debate. Early computers like ENIAC were programmed by rewiring. The Manchester Baby, circa 1948, was the first stored-program computer, so in that sense, it had a programming language—the instructions stored in its memory. We call the low-level instructions understood by a processor <em>machine language</em> or <em>machine code</em>. Machine code is a programming language, as are the assemblers that generate the machine code from <em>assembly language</em>.</p>&#13;
<p class="indent">Machine code and assembly aside, the first programming language used on an actual computer is probably <em>Short Code</em>, developed by John Mauchly in 1949 and implemented by William Schmitt for the UNIVAC I in 1950. Short Code supported arithmetic, including branching and a set of library functions like square root and absolute value. Expressions were transliterated from algebra to code and then manually packed into six 2-byte groups to fit the 12-byte words of the UNIVAC. Short Code was interpreted and parsed the meaning of an instruction from a tokenized representation of the program. In other words, Short Code worked much like the BASIC that interpreters built into early home computers of the 1980s. Running on a computer from the 1950s, interpreted Short Code must have been exceedingly slow to execute.</p>&#13;
<p class="indent">The first proper compiler, at least as credited by Knuth and Pardo in “The Early Development of Programming Languages” in <em>A History of Computing in the Twentieth Century</em> (Academic Press, 1980) is <em>AUTOCODE</em> by Alick E. Glennie at the University of Manchester, circa 1950–52. Unlike <span epub:type="pagebreak" id="page_9"/>Short Code, AUTOCODE was compiled, meaning it was translated into equivalent machine code instructions. Visually, AUTOCODE looks a bit like machine code with text thrown in here and there.</p>&#13;
<p class="indent">While AUTOCODE and its successors were under development in the UK, in the US, Grace Hopper, Margaret H. Harper, and Richard K. Ridgeway were working on their compilers for the UNIVAC: A-0 to A-2. In 1954, John Backus defined “The IBM Mathematical FORmula TRANslating system, FORTRAN,” and by 1957, the first <em>FORTRAN</em> compiler was released.</p>&#13;
<p class="indent">The development of FORTRAN was a watershed moment. Programming language design kicked into high gear in the late 1950s. Most notable of the languages defined in the later 1950s, besides FORTRAN, is John McCarthy’s <em>Lisp</em> in 1958. It is truly impressive that both FORTRAN and Lisp are still in widespread use today. High-performance computing (HPC) makes frequent use of FORTRAN. Later in the book, we’ll use a version of Lisp to implement a <em>FRACTRAN</em> interpreter. We’ll focus on FRACTRAN, perhaps the most unusual of esolangs, in <a href="ch08.xhtml#ch08">Chapter 8</a>.</p>&#13;
<p class="indent">The last pre-1960 programming language of note is <em>COBOL</em>. It was designed by a committee in 1959, with the first version appearing a year later. Rightly or wrongly, COBOL is still in use today. Unlike FORTRAN, a language for research scientists, and Lisp, a language for computer scientists, COBOL was a language intended for business use. COBOL programs are highly structured, rigid, and verbose. For example, consider this snippet from the COBOL 60 report defining the language:</p>&#13;
<pre>IF X EQUALS Y THEN MOVE A TO B; &#13;
OTHERWISE IF C EQUALS D THEN MOVE A TO D AND&#13;
IF Y EQUALS Z THEN ADD B TO C</pre>&#13;
<p class="indent">The early years of programming language development resulted in the basic form and concept of a general-purpose programming language. The three critical languages to come out of this era are FORTRAN, Lisp, and COBOL. All three are still in use.</p>&#13;
<p class="indent">FORTRAN was a natural choice for what is still a primary use of computers: number crunching. COBOL is an early example recognizing that commercial use of computers was something apart from their scientific use. Lisp was far in advance of its time, but slow, resource-limited computers made it difficult for Lisp to live up to its potential.</p>&#13;
<p class="indent">Let’s now examine 10 different programming languages. These languages represent major transitions in the evolution of programming languages because of what they introduced or how they grew in popularity or opened the arcane art of coding to a larger population.</p>&#13;
<h3 class="h3" id="lev1sec9"><strong>ALGOL</strong></h3>&#13;
<p class="noindent">The first language we’ll consider, <em>ALGOL</em>, gave rise to entire generations of programming languages and still influences programming languages today. ALGOL, like COBOL, was designed by committee.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_10"/>ALGOL is a compiled, structured, imperative programming language, meaning it looks familiar to modern programmers. Subsequent programming languages inspired by ALGOL include Simula, PL/I, and Pascal, all mentioned later. ALGOL captured the essentials of what <em>imperative programming</em> is: a structured way to give step-by-step instructions to the computer.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list1">Listing 1-1</a> is a simple program to compare two integers.</p>&#13;
<pre>#  Ask for two ints and report their relationship #&#13;
( print("enter an integer: ");&#13;
  INT a = read int;&#13;
  print("now enter another integer: ");&#13;
  INT b = read int;&#13;
  IF (a &gt; b) THEN&#13;
    print((a, " is greater than ", b, new line))&#13;
  ELSE &#13;
    IF (b &gt; a) THEN&#13;
      print((b, " is greater than ", a, new line))&#13;
    ELSE&#13;
      print((a, " is equal to ", b, new line))&#13;
    FI&#13;
  FI )</pre>&#13;
<p class="caption" id="ch01list1"><em>Listing 1-1: Comparing numbers in ALGOL 68</em></p>&#13;
<p class="indent">Even without knowing the language, the form should be familiar to you if you know any modern structured programming language. Notice that the program begins with <span class="literal">(</span> and ends with <span class="literal">)</span> instead of <span class="literal">BEGIN</span> and <span class="literal">END</span>. The latter works as well and is what users of Pascal or Modula-2 expect to see, but ALGOL’s free-form approach allows parentheses to denote code blocks.</p>&#13;
<p class="indent">If you’re interested in trying ALGOL, you should look to Marcel van der Veer’s “Algol 68 Genie” implementation (see <em><a href="https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html">https://jmvdveer.home.xs4all.nl/en.algol-68-genie.html</a></em>), which runs on Linux and Windows. You’ll find extensive documentation on his site, all you need to learn the language. The Ubuntu package is <span class="literal">algol68g</span>. <a href="ch01.xhtml#ch01list1">Listing 1-1</a> is in <em>bigger.a68</em>. To run it, enter</p>&#13;
<pre>&gt; <span class="codestrong1">a68g bigger.a68</span></pre>&#13;
<p class="indent"><a href="ch01.xhtml#ch01fig3">Figure 1-3</a> shows ALGOL’s descendants.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_11"/><img id="ch01fig3" src="Images/01fig03.jpg" alt="Image" width="647" height="484"/></div>&#13;
<p class="figcap"><em>Figure 1-3: The ALGOL family tree</em></p>&#13;
<p class="indent">Naturally, programming languages can have multiple influences, but this tree seems quite reasonable.</p>&#13;
<h3 class="h3" id="lev1sec10"><strong>APL</strong></h3>&#13;
<p class="noindent">In 1962, Kenneth E. Iverson published <em>A Programming Language</em>, detailing a new programming language designed with arrays in mind that, in a show of boundless creativity, came to be called <em>APL</em>. One of the defining characteristics of APL is its nonstandard character set. That fact sometimes turns off would-be learners. For us, Iverson’s use of alternative characters is an excellent reason to include APL in our list of programming languages. However, the real reason to include APL is that it was the first <em>array-processing language</em>. Array-processing is a paradigm we’ll encounter in a later chapter, but, in a nutshell, it involves wholesale operations on arrays in a compact way. For a modern comparison, consider Matlab or Python with NumPy.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>APL sessions are typically interactive. <a href="ch01.xhtml#ch01list2">Listing 1-2</a> shows GNU APL in action. The user’s input is indented and the system’s responses are not.</p>&#13;
<pre>      x ← <span class="codeitalic1">ι</span>10        &#13;
      10 × x                &#13;
10 20 30 40 50 60 70 80 90 100&#13;
      y ← 4 4 <span class="codeitalic1">ρ</span> 16 ? 100&#13;
      y&#13;
97  5 92 67&#13;
49 74 63 29&#13;
23 85 56 33&#13;
78 77 98 81</pre>&#13;
<p class="caption" id="ch01list2"><em>Listing 1-2: APL in action</em></p>&#13;
<p class="indent">The first line of <a href="ch01.xhtml#ch01list2">Listing 1-2</a> assigns (←) whatever <em>ι</em>100 returns to the variable, <em>x</em>. APL’s many operators each have two modes. If used in a unary fashion (that is, on a single operand), then the use is <em>monadic</em>. If used in a binary fashion (on two operands), then the use is <em>dyadic</em>. In this case, the monadic use of <em>ι</em> returns the vector 1 2 3 4 5 6 7 8 9 10, which is exactly how it would be entered manually. Thus, the first line is equivalent to <span class="literal">x = np.arange(1,11)</span> in Python using NumPy. The second line in <a href="ch01.xhtml#ch01list2">Listing 1-2</a> multiplies each element of <em>x</em> by 10.</p>&#13;
<p class="indent">The dyadic form of <em>ι</em> searches for its second argument in the first. For example, consider the following APL code:</p>&#13;
<pre>      x ← 10?10        &#13;
      x                               &#13;
7 9 4 2 10 5 6 3 8 1                &#13;
      x<span class="codeitalic1">ι</span>10&#13;
5</pre>&#13;
<p class="noindent">Here we use the dyadic form of <span class="literal">?</span> to set <em>x</em> to a 10-element vector of random integers from 1 to 10, without repeats. Next, the dyadic form of <em>ι</em> searches <em>x</em> for the number 10 and returns its index, 5. APL indexes from 1, not 0. If the dyadic form of <span class="literal">?</span> returns vectors of random integers between 1 and some upper limit, what might the monadic form of <span class="literal">?</span> do? If you guessed return a random integer, you are correct: <span class="literal">?</span><em>n</em> returns a random integer in [1, <em>n</em>].</p>&#13;
<p class="indent">The second assignment in <a href="ch01.xhtml#ch01fig2">Figure 1-2</a> sets <em>y</em> to a 4 × 4 matrix of random integers in [1, 100]. We use <span class="literal">?</span> to ask for 16 numbers, and then use <em>ρ</em> (rho) to reshape the 16-element vector into a 4 × 4 matrix before assigning it to <em>y</em>. To index a vector or array, use <img src="Images/f0012-01.jpg" alt="Image" width="7" height="14"/> (vertical rectangle) as in 3 <img src="Images/f0012-01.jpg" alt="Image" width="7" height="14"/> <em>x</em> to access the third element of vector <em>x</em> or 2 3 <img src="Images/f0012-01.jpg" alt="Image" width="7" height="14"/> <em>y</em> to access <em>y</em><sub>23</sub> of matrix <em>y</em>.</p>&#13;
<p class="indent">One quirk of APL is that expressions are evaluated from right to left, with no operator precedence rules. As a consequence, parentheses must be used to enforce desired behavior. For example, according to APL, the first of the two expressions below is completely correct.</p>&#13;
<pre><span epub:type="pagebreak" id="page_13"/>      3 × 6 + 2&#13;
24&#13;
      (3 × 6) + 2&#13;
20</pre>&#13;
<p class="noindent">Virtually every other programming language will tell you that both expressions equal 20 because multiplication is performed before addition. However, APL parses the first expression as “add 2 and 6 to get 8, then multiply by 3 to get 24.”</p>&#13;
<p class="indent">APL is compact and powerful but also cryptic, and thus comes with a high learning curve. This, to say nothing of the early difficulties in using its alternative character set, has limited its use. Perhaps because of these difficulties, Iverson and Roger Hui developed <em>J</em>, an ASCII version of APL in the early 1990s (<em><a href="https://www.jsoftware.com/">https://www.jsoftware.com/</a></em>). J retains the power of APL and expands on its capabilities to be more useful on modern computer systems. However, like APL, J has a high learning curve, creating the potential for high reward in learning a new way to think about what it means to code.</p>&#13;
<h3 class="h3" id="lev1sec11"><strong>BASIC</strong></h3>&#13;
<p class="noindent">Almost everyone who used a microcomputer in the 1980s is at least somewhat familiar with <em>BASIC</em>. The “Beginner’s All-purpose Symbolic Instruction Code” was developed at Dartmouth College in 1964 by John G. Kemeny and Thomas E. Kurtz. BASIC was originally an unstructured programming language, meaning it used gotos to control program flow, and was intended for students and non-professionals. In the late 1970s, when the microcomputer revolution took off, most computers included BASIC, usually in ROM. The first programming language many current software engineers learned was unstructured BASIC on a personal computer from the 1980s. As a result, BASIC’s impact on software development is significant and continues to this day.</p>&#13;
<p class="indent">BASIC was interpreted and often stored in memory as tokens, much like Short Code, described above. BASIC lives on as <em>Visual Basic</em>, which uses structured programming and is fully object-oriented. Visual Basic is still one of the most widely used programming languages.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list3">Listing 1-3</a> shows a simple BASIC program for the Apple II to simulate coin flips.</p>&#13;
<pre>10  HOME&#13;
100  REM COIN FLIPPER&#13;
110  PRINT : INPUT "HOW MANY FLIPS:";N&#13;
120  IF N &lt; 1 THEN  END&#13;
130 K = 0:T = 0:H = 0: PRINT&#13;
140 C =  INT (2 *  RND (1))&#13;
150  IF C = 0 THEN  PRINT "T";:T = T + 1&#13;
160  IF C = 1 THEN  PRINT "H";:H = H + 1<span epub:type="pagebreak" id="page_14"/>&#13;
170 K = K + 1&#13;
180  IF K &lt; N THEN  GOTO 140&#13;
190  PRINT : PRINT&#13;
200  PRINT H;" HEADS AND ";T;" TAILS"&#13;
210  PRINT "DO YOU WANT TO TRY AGAIN?": INPUT A$&#13;
220  IF A$ = "Y" THEN  GOTO 10&#13;
230  HOME : END</pre>&#13;
<p class="caption" id="ch01list3"><em>Listing 1-3: An Applesoft BASIC program to simulate coin flips</em></p>&#13;
<p class="indent">BASIC used line numbers, required for every line, to provide targets for <span class="literal">GOTO</span> statements. Different dialects of BASIC provided various commands, but all had <span class="literal">GOTO</span> and many had <span class="literal">ON-GOTO</span> to provide a simple computed goto construct. BASIC also supported subroutines via <span class="literal">GOSUB</span>, though most did not support recursion. Although perhaps scoffed at by many more serious programmers back in the 1960s and onward, the fact that BASIC continues today validates its utility.</p>&#13;
<h3 class="h3" id="lev1sec12"><strong>PL/I</strong></h3>&#13;
<p class="noindent"><em>PL/I (Programming Language 1</em>) was developed by IBM in the mid-1960s as a general-purpose programming language for all uses, scientific to business. As such, it competed directly with FORTRAN and COBOL. IBM has maintained PL/I and it’s currently available for IBM mainframe computers. The language itself is structured and imperative, and borrowed concepts from ALGOL, FORTRAN, and COBOL, as one might expect from a jack-of-all-trades language of the time. PL/I was in steady use from the late 1970s through the mid-1990s and represents one of the first languages intended to meet all programming needs.</p>&#13;
<p class="indent">Even though PL/I survives on IBM mainframes, its use elsewhere is negligible. New development in PL/I is likely equally insignificant. As an example of the language, <a href="ch01.xhtml#ch01list4">Listing 1-4</a> shows a simple loop that outputs “Hello, world!” repeatedly.</p>&#13;
<pre>hello:proc options(main);&#13;
  declare i fixed binary;&#13;
  do i = 1 to 10;&#13;
    put skip list("Hello, world!");&#13;
  end;&#13;
end hello;</pre>&#13;
<p class="caption" id="ch01list4"><em>Listing 1-4: A PL/I greeting</em></p>&#13;
<p class="indent">This example is quite readable, even now, though wordy, requiring four words to declare a simple integer variable. The influence of FORTRAN and ALGOL is evident via FORTRAN’s <span class="literal">DO</span> loop and ALGOL’s <span class="literal">END</span>.</p>&#13;
<h3 class="h3" id="lev1sec13"><span epub:type="pagebreak" id="page_15"/><strong>Logo</strong></h3>&#13;
<p class="noindent">In 1967, Wally Feurzeig, Seymour Papert, and Cynthia Solomon gifted generations of students with <em>Logo</em>, a “simplified” version of Lisp intended to teach programming concepts. Logo, which means “word” or “thought” in Greek, is intended to foster thinking about programming, especially thinking about how the Logo turtle will behave given the commands the students enter.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01fig4">Figure 1-4</a> shows a simple Logo session. The user enters commands at the bottom of the screen, and the triangular “turtle” responds.</p>&#13;
<div class="image"><img id="ch01fig4" src="Images/01fig04.jpg" alt="Image" width="592" height="380"/></div>&#13;
<p class="figcap"><em>Figure 1-4: Drawing with the Logo turtle</em></p>&#13;
<p class="indent">Most commands are easy to understand, even if you’ve never seen Logo before. The commands in <a href="ch01.xhtml#ch01fig4">Figure 1-4</a> are, with comments</p>&#13;
<pre>repeat 16 [         ; repeat commands in [ ] 16 times&#13;
    repeat 4 [      ; repeat commands in [ ] 4 times&#13;
        fd 50       ; turtle forward 50 pixels&#13;
        rt 90       ; turtle turn right 90 degrees&#13;
    ]&#13;
    rt 22.5         ; turn right 22.5 degrees&#13;
]&#13;
pu                  ; pen up&#13;
fd 80               ; forward 80 pixels&#13;
rt 40               ; right turn 40 degrees</pre>&#13;
<p class="noindent">The inner <span class="literal">repeat</span> command draws a square with the turtle ending where it began. The 22.5 degree right turn tilts the turtle to draw another square. Since 16 × 22<em>.</em>5 = 360, 16 repetitions completes the pattern. The final instructions move the turtle off the pattern. Note that this particular Logo <span epub:type="pagebreak" id="page_16"/>example is for Berkeley Logo. The exact form of the commands might be slightly different for another implementation. Logo is still used to teach programming concepts to children; see “Turtle Academy” (<em><a href="https://turtleacademy.com/">https://turtleacademy.com/</a></em>). As Logo represents one of the first attempts to develop a programming language designed for teaching children, it deserves a place in our pantheon of languages.</p>&#13;
<h3 class="h3" id="lev1sec14"><strong>Simula</strong></h3>&#13;
<p class="noindent">The first object-oriented language was <em>Simula</em>, developed by Kristen Nygaard and Ole-Johan Dahl. As the name suggests, Simula was first used for discrete-time simulations and evolved into a general-purpose language by 1967 (Simula 67). Simula brought the world classes, objects, and inheritance. The description that follows is specific to Simula 67. I tested the examples with the GNU cim compiler (<em><a href="https://www.gnu.org/software/cim/">https://www.gnu.org/software/cim/</a></em>), which is a bit tricky to build (at least version 5.1 is, which is the latest version available as of this writing). The cim compiler translates Simula to C before calling the standard gcc compiler to build the final executable.</p>&#13;
<p class="indent">The “Hello, world!” program in Simula isn’t particularly impressive.</p>&#13;
<pre>comment Hello world;&#13;
begin&#13;
    OutText("Hello, world!");&#13;
    OutImage;&#13;
    OutText("How are you today?");&#13;
end</pre>&#13;
<p class="noindent">It’s immediately clear that <span class="literal">OutText</span> prints something, and it’s reasonable to guess that <span class="literal">OutImage</span> acts like a newline, which it does. Structurally, Simula is part of the ALGOL family, with blocks denoted by <span class="literal">Begin</span> and <span class="literal">End</span> and semicolons to separate statements. Simula isn’t case sensitive, so <span class="literal">Begin</span> and <span class="literal">BEGIN</span> are equivalent. Comments begin with <span class="literal">comment</span> or an exclamation point and end with a semicolon, like other statements. If you’re familiar with Modula-2 or Pascal, then Simula syntax should look familiar.</p>&#13;
<p class="indent">Simula is a structured language, like ALGOL, so both <span class="literal">for</span> and <span class="literal">while</span> control structures are present. Simula’s <span class="literal">for</span> is more flexible than in most other languages. For example, <span class="literal">for</span> iterates over a list of values, some of which may specify ranges. Consider the program</p>&#13;
<pre>begin&#13;
    integer r;&#13;
    for r:= 1,1, 3 step 3 until 18, -12 do&#13;
    begin&#13;
        OutInt(r,5);     OutText(" ");&#13;
        OutInt(r*r,5);   OutText(" ");&#13;
        OutInt(r*r*r,5); Outimage;&#13;
    end&#13;
end</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_17"/>which outputs a table of squares and cubes:</p>&#13;
<pre>    1     1     1&#13;
    1     1     1&#13;
    3     9    27&#13;
    6    36   216&#13;
    9    81   729&#13;
   12   144  1728&#13;
   15   225  3375&#13;
   18   324  5832&#13;
  -12   144 -1728</pre>&#13;
<p class="noindent">Here, <span class="literal">r</span> is 1 for the first two iterations of the loop, then runs from 3 through 18 by threes, and ends with –12.</p>&#13;
<p class="indent">However, if this were all Simula offered, it wouldn’t be worth discussing. Simula’s true gift to the world is object-oriented programming (<a href="ch01.xhtml#ch01list5">Listing 1-5</a>), for which both Nygaard and Dahl received the Turing Award in 2001.</p>&#13;
<pre>begin&#13;
  class Person;&#13;
  begin&#13;
    text first, last;&#13;
    integer age;&#13;
    procedure Print;&#13;
    begin&#13;
      OutText(first); OutText(" ");&#13;
      OutText(last); OutText(", age");&#13;
      OutInt(age,3); Outimage;&#13;
    end;&#13;
  end;&#13;
&#13;
  Person class Pal;&#13;
  begin&#13;
    text nickname;&#13;
    procedure Print;&#13;
    begin&#13;
      OutText(nickname);&#13;
      OutText(" is ");&#13;
      This Pal Qua Person.Print;&#13;
    end;&#13;
  end;&#13;
&#13;
  ref(Person) Fred, Barney;&#13;
  ref(Pal) Wilma, Betty;&#13;
&#13;
  Fred :- new Person;&#13;
  Barney :- new Person;&#13;
  Wilma :- new Pal;<span epub:type="pagebreak" id="page_18"/>&#13;
  Betty :- new Pal;&#13;
&#13;
  Fred.first :- "Fred";         Barney.first :- "Barney";&#13;
  Fred.last :- "Flintstone";    Barney.last :- "Rubble";&#13;
  Fred.age := 37;               Barney.age := 34;&#13;
  &#13;
  Wilma.first :- "Wilhelmina";  Betty.first :- "Elizabeth";&#13;
  Wilma.last :- "Flintstone";   Betty.last :- "Rubble";&#13;
  Wilma.age := 35;              Betty.age := 31;&#13;
  Wilma.nickname :- "Wilma";    Betty.nickname :- "Betty";&#13;
&#13;
  Fred.Print;&#13;
  Wilma.Print;&#13;
  Barney.Print;&#13;
  Betty.Print;    &#13;
end</pre>&#13;
<p class="caption" id="ch01list5"><em>Listing 1-5: Using classes in Simula 67</em></p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list5">Listing 1-5</a> shows us how to define and use classes. We define two classes, <span class="literal">Person</span> and <span class="literal">Pal</span>, a subclass of <span class="literal">Person</span>. <span class="literal">Person</span> uses the familiar <span class="literal">class</span> keyword and then defines <span class="literal">first</span> and <span class="literal">last</span> names as type <span class="literal">text</span>, a string object, along with <span class="literal">age</span>, an integer. <span class="literal">Person</span> defines one method, <span class="literal">Print</span>, to print the person’s full name and age.</p>&#13;
<p class="indent"><span class="literal">Pal</span> is a subclass of <span class="literal">Person</span>. It adds <span class="literal">nickname</span> and overrides <span class="literal">Print</span> to output the nickname before throwing in the strange line</p>&#13;
<pre>This Pal Qua Person.Print;</pre>&#13;
<p class="noindent">which is a way to call the <span class="literal">Print</span> method of the superclass, <span class="literal">Person</span>. The phrase <span class="literal">This Pal</span> is a reference to the object itself. It returns a reference to the current object much like <span class="literal">this</span> in C++. The phrase <span class="literal">Qua Person.Print</span> interprets the reference returned by <span class="literal">This Pal</span> as a <span class="literal">Person</span> object so the proper <span class="literal">Print</span> method is called. (“Qua” is derived from Latin and means “in the capacity of” or “as.”)</p>&#13;
<p class="indent">To use instances of these classes, we must create reference variables and then use <span class="literal">new</span> to assign the references to the actual instances. The <span class="literal">:-</span> operator assigns objects created on the heap to references. The <span class="literal">:=</span> operator assigns values to variables. Simula includes automatic garbage collection, so there is no need to delete objects when no longer needed.</p>&#13;
<p class="indent">To populate the objects, we use both <span class="literal">:-</span> and <span class="literal">:=</span>. Strings are objects, so <span class="literal">:-</span> assigns them to the <span class="literal">text</span> objects, whereas <span class="literal">:=</span> is used to assign <span class="literal">age</span> as it is an integer. First we populate the two instances of the parent class, <span class="literal">Fred</span> and <span class="literal">Barney</span>, with names and ages. Then we populate the two <span class="literal">Pal</span> subclass instances, <span class="literal">Wilma</span> and <span class="literal">Betty</span>, in much the same way, this time including nicknames.</p>&#13;
<p class="indent">The goal of all of <a href="ch01.xhtml#ch01list5">Listing 1-5</a> is to call the <span class="literal">Print</span> methods of the now populated objects, which produces</p>&#13;
<pre><span epub:type="pagebreak" id="page_19"/>Fred Flintstone, age 37&#13;
Wilma is Wilhelmina Flintstone, age 35&#13;
Barney Rubble, age 34&#13;
Betty is Elizabeth Rubble, age 31</pre>&#13;
<p class="noindent">Notice that the proper <span class="literal">Print</span> method is called on each object to produce the desired output string.</p>&#13;
<p class="indent">Simula was well ahead of its time. Object-oriented programming took well over a decade after Simula 67 to catch on and, arguably, 20 years to become widely employed in the commercial software world. Simula’s strong association with simulation hurt the adoption of the language. As we’ve seen here, Simula is much more than a simulation language and even now fits into what we expect an object-oriented language to be.</p>&#13;
<h3 class="h3" id="lev1sec15"><strong>Pascal</strong></h3>&#13;
<p class="noindent">Niklaus Wirth released Pascal in 1970. It is a direct descendant of ALGOL and was widely used into the 1980s, primarily to teach structured programming concepts. After unstructured BASIC, many software engineers learned Pascal as their first “serious” programming language. Early versions of the Macintosh operating system were written, at least partially, in Pascal. UCSD Pascal, followed by commercial products like Turbo Pascal, brought the language to microcomputers. As with BASIC above, Pascal has strongly influenced a generation of developers, to say nothing of programming language development as a whole, so it deserves a place in the pantheon as well.</p>&#13;
<p class="indent">Look again at <a href="ch01.xhtml#ch01fig3">Figure 1-3</a>. There are two main branches of the ALGOL family of languages, one based on C and the other on Pascal. The Pascal branch leads to Modula-2, which overcame Pascal’s shortcomings but was never particularly popular, at least in North America. Ada was created by the US Department of Defense (DoD) as a standard for all development in the 1980s (Ada is named after Ada Lovelace). The DoD required the use of Ada for projects from 1991 to 1997. At present, Pascal has fallen into obscurity, and Modula-2 and its descendants, along with Ada, are even less popular. However, Pascal lives on as Delphi/Object Pascal. As a straightforward, structured programming language without object-oriented abilities, there was little reason to select Pascal after the rise of C and C++.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list6">Listing 1-6</a> gives us a feel for the language.</p>&#13;
<pre>program nonsquares;&#13;
&#13;
var&#13;
   n : integer;&#13;
&#13;
begin&#13;
    for n := 1 to 120 do begin<span epub:type="pagebreak" id="page_20"/>&#13;
        write(n + trunc(0.5 + sqrt(n)):4);&#13;
        if (n mod 10) = 0 then writeln;&#13;
    end;&#13;
    writeln&#13;
end.</pre>&#13;
<p class="caption" id="ch01list6"><em>Listing 1-6: Generating the sequence of nonsquare integers</em></p>&#13;
<p class="indent">Pascal looks quite similar to ALGOL and Simula. This particular program produces a table of 120 numbers.</p>&#13;
<pre>   2   3   5   6   7   8  10  11  12  13&#13;
  14  15  17  18  19  20  21  22  23  24&#13;
  26  27  28  29  30  31  32  33  34  35&#13;
  37  38  39  40  41  42  43  44  45  46&#13;
  47  48  50  51  52  53  54  55  56  57&#13;
  58  59  60  61  62  63  65  66  67  68&#13;
  69  70  71  72  73  74  75  76  77  78&#13;
  79  80  82  83  84  85  86  87  88  89&#13;
  90  91  92  93  94  95  96  97  98  99&#13;
 101 102 103 104 105 106 107 108 109 110&#13;
 111 112 113 114 115 116 117 118 119 120&#13;
 122 123 124 125 126 127 128 129 130 131</pre>&#13;
<p class="noindent">Look carefully at the table; do you see what isn’t there? The table contains every integer less than 132 <em>except</em> for all the perfect squares: 4, 9, 16, 25, 36, 49, 64, 81, 100, and 121. The program implements the sequence</p>&#13;
<div class="imagec"><img src="Images/f0020.jpg" alt="Image" width="300" height="26"/></div>&#13;
<p class="noindent">which has the remarkable property of bypassing all perfect squares, as <em>n</em> is incremented from one.</p>&#13;
<p class="indent">Pascal programs begin with <span class="literal">program</span> followed by a variable declaration section beginning with <span class="literal">var</span>. Here we define one integer variable, <span class="literal">n</span>. The body of the program is between <span class="literal">begin</span> at the beginning and <span class="literal">end.</span> at the end. Note that the period is required for the final <span class="literal">end</span>. Blocks of code are also enclosed within <span class="literal">begin</span> and <span class="literal">end</span>.</p>&#13;
<p class="indent">The body of this program is a single <span class="literal">for</span> loop running from 1 to 120. The body of the loop is a <span class="literal">write</span> statement, which does not move to the next line when done. The number output is the equation above for the current value of <em>n</em>. The argument <span class="literal">:4</span> tells Pascal to right-justify the output in four spaces. The code also tells the program to move to the next line if <span class="literal">n</span> is a multiple of 10.</p>&#13;
<p class="indent">Pascal was intended for teaching and wasn’t suitable for system-level programming without nonstandard extensions. Wirth enhanced Pascal to make Modula-2, which was suitable for system-level programming. However, Modula-2 never reached its full potential in the commercial world. Regardless, Wirth’s Pascal, and subsequent languages, rightfully earned him the Turing Award in 1984.</p>&#13;
<h3 class="h3" id="lev1sec16"><span epub:type="pagebreak" id="page_21"/><strong>Prolog</strong></h3>&#13;
<p class="noindent">Most programming languages are imperative. That is, programs are a recipe, a series of “do this” followed by “now do that.” However, in <em>Prolog</em>, things are different. Prolog is a <em>declarative language</em>. Relationships are encoded as rules, and it’s up to the Prolog engine to figure out how to accomplish the goal of answering a user query. Prolog was created in 1972 by Alain Colmerauer and Robert Kowalski and is still in limited use today.</p>&#13;
<p class="indent">A Prolog program is a series of <em>facts</em>, <em>rules</em>, and <em>queries</em>. We’ll learn what these are in a bit. Thinking in Prolog is quite different from thinking in most languages. Imperative languages are natural, and object-oriented languages build on that. Even APL makes sense once you understand the odd characters. But Prolog is an entirely different beast. We’ll only scratch the surface of it here. Later in the book, we devote an entire chapter to CLIPS, which is somewhat like Prolog, so we’ll struggle with this mode of thinking then.</p>&#13;
<p class="indent">This section presents two small Prolog examples. I used SWI-Prolog (<em><a href="https://www.swi-prolog.org/">https://www.swi-prolog.org/</a></em>), which is most easily installed on Ubuntu by typing the following command:</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install swi-prolog-nox</span></pre>&#13;
<p class="noindent">Please see the Prolog website for the macOS and Windows versions.</p>&#13;
<h4 class="h4" id="lev2sec3"><strong><em>Modeling Family Relationships</em></strong></h4>&#13;
<p class="noindent">The canonical Prolog example involves family relationships. Our example is in <em>family.pl</em>, with the most important parts shown in <a href="ch01.xhtml#ch01list7">Listing 1-7</a>.</p>&#13;
<pre>male(uranus).&#13;
male(cronus).&#13;
male(zeus).&#13;
<span class="codeitalic1">--snip--</span>&#13;
female(gaia).&#13;
female(rhea).&#13;
female(hera).&#13;
<span class="codeitalic1">--snip--</span>&#13;
parent(uranus, cronus).&#13;
parent(gaia, cronus).&#13;
parent(cronus, zeus).&#13;
<span class="codeitalic1">--snip--</span>&#13;
married(zeus, hera).&#13;
married(hephaestus, aphrodite).&#13;
&#13;
father(X,Y) :- parent(X,Y), male(X).&#13;
mother(X,Y) :- parent(X,Y), female(X).&#13;
child(X,Y) :- parent(Y,X).&#13;
sibling(X,Y) :- parent(P,X), parent(P,Y), dif(X,Y).&#13;
brother(X,Y) :- sibling(X,Y), male(X).&#13;
sister(X,Y) :- sibling(X,Y), female(X).<span epub:type="pagebreak" id="page_22"/>&#13;
grandparent(X,Y) :- parent(X,A), parent(A,Y).&#13;
grandfather(X,Y) :- grandparent(X,Y), male(X).&#13;
grandmother(X,Y) :- grandparent(X,Y), female(X).&#13;
greatgrandparent(X,Y) :- parent(X,A), parent(A,B), parent(B,Y).&#13;
greatgrandfather(X,Y) :- greatgrandparent(X,Y), male(X).&#13;
greatgrandmother(X,Y) :- greatgrandparent(X,Y), female(X).&#13;
cousin(X,Y) :- sibling(A,B), parent(A,X), parent(B,Y), dif(X,Y).&#13;
aunt(X,Y) :- sister(X,A), parent(A,Y).&#13;
uncle(X,Y) :- brother(X,A), parent(A,Y).&#13;
wife(X,Y) :- female(X), (married(X,Y); married(Y,X)).&#13;
husband(X,Y) :- male(X), (married(X,Y); married(Y,X)).&#13;
paramour(X,Y) :- child(A,X), child(A,Y), \+ married(X,Y), dif(X,Y).</pre>&#13;
<p class="caption" id="ch01list7"><em>Listing 1-7: Family relationships in Prolog</em></p>&#13;
<p class="indent">Let’s walk through the code in <a href="ch01.xhtml#ch01list7">Listing 1-7</a> before exploring what Prolog can do with it. The first portion of the code builds a knowledge base, which is a listing of facts. The code presents facts about the relationships between the classic Greek gods. For example, according to mythology, the parents of Cronus are Gaia and Uranus, so the knowledge base uses the lines <span class="literal">parent(uranus, cronus).</span> and <span class="literal">parent(gaia, cronus).</span> to state this.</p>&#13;
<p class="indent">Note that Prolog doesn’t have a <span class="literal">parent</span> function’ thus, the statements are facts relating two <em>atoms</em>. Atoms are generic names, a collection of characters treated as a symbol and acting as a single unit. There is a relationship called <span class="literal">parent</span> and <span class="literal">gaia</span> and <span class="literal">cronus</span> share it. We read the fact as “Gaia is the parent of Cronus.” Similarly, the knowledge base also labels the sex of the gods. Read <span class="literal">female(hera).</span> as “Hera is female.” Notice that facts, and later rules and queries, end with a period. The knowledge base identifies the sex, parents, and whether or not two gods were considered married. Again, these are the facts that Prolog will work with. To do anything interesting, we need some rules to go with the facts. That’s the second part of <a href="ch01.xhtml#ch01list7">Listing 1-7</a>.</p>&#13;
<p class="indent">Using family relationships helps because we are all so familiar with them. For example, we define a rule to decide if <span class="literal">X</span> is the father of <span class="literal">Y</span>, where atoms beginning with a capital letter are logical variables. Prolog will try to satisfy rules by locating values for these variables. The rule defines the relationship as “If <em>X</em> is the parent of <em>Y</em> and <em>X</em> is male, then <em>X</em> is the father of <em>Y</em>.”</p>&#13;
<p class="indent">The left-hand side of <span class="literal">father(X,Y)</span> is true <em>if</em> the right-hand side is true. The right-hand side is true <em>if</em> <span class="literal">parent(X,Y)</span> is true <em>and</em> (comma) <span class="literal">male(X)</span> is true. Prolog uses a comma for “and” and a semicolon for “or.” With just this bit of knowledge, we can read the rest of the rules. A mother is a parent and female. Someone, <span class="literal">X</span>, is the child of <span class="literal">Y</span> if <span class="literal">Y</span> is the parent of <span class="literal">X</span>.</p>&#13;
<p class="indent">The rule for <span class="literal">sibling</span> says two people are siblings if they share a parent. That much makes sense. The last part of the rule is <span class="literal">dif(X,Y)</span>. It adds “and <em>X</em> and <em>Y</em> are not the same” to the rule. This is there because we don’t normally think of ourselves as our own siblings.</p>&#13;
<p class="indent">The rule for <span class="literal">wife</span> uses parentheses and a semicolon for “or.” <span class="literal">X</span> is a wife if she is female and married to <span class="literal">Y</span>. Prolog doesn’t intuitively know that the rule <span class="literal">married(X,Y)</span> implies <span class="literal">married(Y,X)</span>, so either case is checked.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_23"/>The final rule is <span class="literal">paramour</span>, because, after all, we’re talking about ancient Greek gods. Here, <span class="literal">X</span> is a paramour of <span class="literal">Y</span> if <span class="literal">A</span> is a child of both <span class="literal">X</span> and <span class="literal">Y</span>, <span class="literal">X</span> and <span class="literal">Y</span> are not married (<span class="literal">\+</span> is like “not”), and <span class="literal">X</span> and <span class="literal">Y</span> are different. Read through the rules in <a href="ch01.xhtml#ch01list7">Listing 1-7</a> until you feel comfortable with what they express.</p>&#13;
<p class="indent">Prolog programs are not loaded, but are rather <em>consulted</em>. The line</p>&#13;
<pre>&gt; <span class="codestrong1">swipl family.pl</span></pre>&#13;
<p class="noindent">consults <em>family.pl</em>, after which Prolog presents its prompt and waits patiently for user input. Let’s ask Prolog some questions about the gods and see if it can answer them based on the facts and rules we fed it (see <a href="ch01.xhtml#ch01list8">Listing 1-8</a>).</p>&#13;
<pre>?- <span class="codestrong1">married(zeus,hera).</span>&#13;
true.&#13;
?- <span class="codestrong1">wife(X,zeus).</span>&#13;
X = hera <span class="codestrong1">;</span>&#13;
false.&#13;
?- <span class="codestrong1">mother(hera,W).</span>&#13;
W = ares <span class="codestrong1">;</span>&#13;
W = hephaestus <span class="codestrong1">;</span>&#13;
W = eris.&#13;
?- <span class="codestrong1">mother(X,hera).</span>&#13;
X = rhea.&#13;
?- <span class="codestrong1">mother(X,zeus).</span>&#13;
X = rhea.&#13;
?- <span class="codestrong1">father(zeus,W).</span>&#13;
W = ares <span class="codestrong1">;</span>&#13;
W = hephaestus <span class="codestrong1">;</span>&#13;
W = eris <span class="codestrong1">;</span>&#13;
W = athena <span class="codestrong1">;</span>&#13;
W = hermes <span class="codestrong1">;</span>&#13;
W = apollo <span class="codestrong1">;</span>&#13;
W = artemis <span class="codestrong1">;</span>&#13;
W = dionysus.</pre>&#13;
<p class="caption" id="ch01list8"><em>Listing 1-8: Exploring family relationships</em></p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list8">Listing 1-8</a> shows a Prolog session where <em>family.pl</em> has been consulted. User input is in bold with Prolog’s replies following. First, we ask Prolog if Zeus and Hera are married. Prolog replies <span class="literal">true</span>, as this is simply a fact in its knowledge base.</p>&#13;
<p class="indent">Next, we ask Prolog to find an <span class="literal">X</span> such that <span class="literal">X</span> is the wife of Zeus. Notice that the rule is defined such that <span class="literal">X</span> is the wife of <span class="literal">Y</span> so the query is <span class="literal">wife(X,zeus)</span> and not <span class="literal">wife(zeus,X)</span> which would be asking the question “who is Zeus the wife of?” Prolog finds one match, one binding for <span class="literal">X</span> that makes the query true: Hera. The user then enters the bold semicolon. After Prolog finds a solution, if it can’t decide that there are no other solutions to the query on its own, it pauses and waits for the user to enter a semicolon to tell Prolog to <span epub:type="pagebreak" id="page_24"/>search for more solutions. The final <span class="literal">false</span> is Prolog telling the user that no more solutions were found.</p>&#13;
<p class="indent">Then we ask Prolog, “Hera is the mother of who?” and we’re correctly told Ares, Hephaestus, and Eris. Next we ask, “Who is the mother of Hera?” and, again correctly, Prolog answers Rhea. The following query tells us that Rhea is also Zeus’s mother. The ancient gods certainly had complex family relationships.</p>&#13;
<p class="indent">We next ask Prolog to identify the children of Zeus. Specifically, we ask, “Zeus is the father of who?” and are correctly told he is the father of eight other gods, much to the annoyance of Hera.</p>&#13;
<p class="indent">A few more examples will drive home how Prolog works. <a href="ch01.xhtml#ch01list9">Listing 1-9</a> shows Prolog’s response to the query “Who are Zeus’s paramours?”</p>&#13;
<pre>?- <span class="codestrong1">paramour(zeus,W).</span>&#13;
W = metis <span class="codestrong1">;</span>&#13;
W = maia <span class="codestrong1">;</span>&#13;
W = leto <span class="codestrong1">;</span>&#13;
W = leto <span class="codestrong1">;</span>&#13;
W = semele.&#13;
?- <span class="codestrong1">grandmother(X,apollo).</span>&#13;
X = rhea <span class="codestrong1">;</span>&#13;
false.&#13;
?- <span class="codestrong1">greatgrandfather(X,artemis).</span>&#13;
X = uranus <span class="codestrong1">;</span>&#13;
false.</pre>&#13;
<p class="caption" id="ch01list9"><em>Listing 1-9: More family relationships</em></p>&#13;
<p class="indent">Notice that Leto is listed twice. The rule for paramour is</p>&#13;
<pre>paramour(X,Y) :- child(A,X), child(A,Y), \+ married(X,Y), dif(X,Y).</pre>&#13;
<p class="noindent">meaning that <span class="literal">X</span> and <span class="literal">Y</span> are paramours if they are not married and have a child together. In mythology, Zeus and Leto have twins, Apollo and Artemis. There-fore, Prolog finds that Leto and Zeus are paramours in two different ways, once for Apollo and again for Artemis. There are ways to capture responses and return only unique solutions, but using them here would only cloud the example. The final two queries in <a href="ch01.xhtml#ch01list9">Listing 1-9</a> illustrate that Prolog can resolve queries involving grandparents and great-grandparents.</p>&#13;
<h4 class="h4" id="lev2sec4"><strong><em>Implementing the Fibonacci Sequence</em></strong></h4>&#13;
<p class="noindent">Our last Prolog example shows how it works with numeric data and its support for recursion. Specifically, we’ll implement the Fibonacci sequence,</p>&#13;
<pre>1 1 2 3 5 8 13 21 34 55 ...</pre>&#13;
<p class="noindent">which is expressible recursively by saying that the next number is the sum of the previous two:</p>&#13;
<p class="equationc"><span epub:type="pagebreak" id="page_25"/><em>F<sub>n</sub></em> = <em>F<sub>n–</sub></em><sub>1</sub> + <em>F<sub>n–</sub></em><sub>2</sub>, <em>F</em><sub>1</sub> = 1, <em>F</em><sub>2</sub> = 1</p>&#13;
<p class="indent">We’ll discuss the Fibonacci sequence in more detail in <a href="ch13.xhtml#ch13">Chapter 13</a>. It’s an easy target for esolang examples. For now, we’ll use a recursive Python implementation as a guide for a Prolog version. In Python, the equation above can be implemented as</p>&#13;
<pre>def fib(n):&#13;
    if (n &lt;= 2):&#13;
        return 1&#13;
    else:&#13;
        return fib(n-1) + fib(n-2)</pre>&#13;
<p class="noindent">The <em>n</em>th Fibonacci number is the sum of the previous two, or if <em>n</em> is less than or equal to two, just one. This function tells us that <em>F</em><sub>11</sub> = 89, which is correct. So how can we express the rule for the Fibonacci sequence in Prolog? To do so, we first need two facts that act as the base cases, <em>F</em><sub>1</sub> = 1 and <em>F</em><sub>2</sub> = 1. Then we need to express the recursive relationship. <a href="ch01.xhtml#ch01list10">Listing 1-10</a> has what we need.</p>&#13;
<pre>fib(1,1).&#13;
fib(2,1).&#13;
&#13;
fib(N,F) :-&#13;
    N &gt; 2,&#13;
    N1 is N-1,&#13;
    N2 is N-2,&#13;
    fib(N1,F1),&#13;
    fib(N2,F2),&#13;
    F is F1 + F2.</pre>&#13;
<p class="caption" id="ch01list10"><em>Listing 1-10: Recursive Fibonacci numbers</em></p>&#13;
<p class="indent">The two base cases are facts. The first Fibonacci number is 1, and the second is 1. When Prolog is eventually trying to satisfy <span class="literal">fib(2,1)</span>, it will find the fact. The “return value” is the second number. The query to find the 11th Fibonacci number is <span class="literal">fib(11,F).</span> or “What F value makes <span class="literal">fib(11,F)</span> true?” That’s the 11th Fibonacci number.</p>&#13;
<p class="indent">The general rule is <span class="literal">fib(N,F)</span>. The body is the conjunction (that is, clauses linked by “and”) of several things. First, is it true that <span class="literal">N &gt; 2</span>? Next come two “assignments,” which are true when <span class="literal">N1</span> is <em>n –</em> 1 and <span class="literal">N2</span> is <em>n –</em> 2. So far, the statements make sense and are elements of the Python definition.</p>&#13;
<p class="indent">The next two lines, <span class="literal">fib(N1,F1)</span> and <span class="literal">fib(N2,F2)</span>, are strange at first. These are the recursive calls, as it were. The first seeks to find <em>F</em><sub><em>n–</em>1</sub> by finding an <span class="literal">F1</span> such that <span class="literal">fib(N1,F1)</span> is true. Likewise, the second does the same for <em>F</em><sub><em>n–</em>2</sub>. If these are found, then <span class="literal">F1</span> and <span class="literal">F2</span> have meaningful values, and the last line says that <span class="literal">F</span>, the actual number we’ve been looking for, is the sum of <span class="literal">F1</span> and <span class="literal">F2</span>, which must be the previous two Fibonacci numbers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_26"/>The code for <a href="ch01.xhtml#ch01list10">Listing 1-10</a> is in <em>fib.pl</em>. Let’s start Prolog, consulting <em>fib.pl</em>, and ask it for the 11th Fibonacci number:</p>&#13;
<pre>?- <span class="codestrong1">fib(11,F).</span>&#13;
F = 89 .</pre>&#13;
<p class="noindent">We see that our example works, as it gives us the same answer as the Python version. Now, ask for <span class="literal">fib(26,F)</span> and see how long it takes Prolog to answer. On my machine, Python answers immediately with 121,393. Prolog also answers with 121,393 but takes 29 seconds to do so. The double recursive call makes this Fibonacci implementation inefficient. However, Prolog’s exceedingly slow response validates a common criticism of the language: its performance. Moreover, the Unix utility, <span class="literal">top</span>, reported that during the search, Prolog used 0.5 percent of system memory, or about 42MB, which seems excessive for such a simple task.</p>&#13;
<p class="indent">Tracing lets us watch Prolog work through a query. For example, here’s the output tracing the query <span class="literal">fib(3,F)</span>.</p>&#13;
<pre>?- <span class="codestrong1">trace.</span>&#13;
true.&#13;
[trace]  ?- <span class="codestrong1">fib(3,F).</span>&#13;
   Call: (8) fib(3, _4072) ? creep&#13;
   Call: (9) 3&gt;2 ? creep&#13;
   Exit: (9) 3&gt;2 ? creep&#13;
   Call: (9) _4296 is 3+ -1 ? creep&#13;
   Exit: (9) 2 is 3+ -1 ? creep&#13;
   Call: (9) _4302 is 3+ -2 ? creep&#13;
   Exit: (9) 1 is 3+ -2 ? creep&#13;
<span class="ent">➊</span> Call: (9) fib(2, _4304) ? creep&#13;
   Exit: (9) fib(2, 1) ? creep&#13;
<span class="ent">➋</span> Call: (9) fib(1, _4304) ? creep&#13;
   Exit: (9) fib(1, 1) ? creep&#13;
   Call: (9) _4072 is 1+1 ? creep&#13;
   Exit: (9) 2 is 1+1 ? creep&#13;
   Exit: (8) fib(3, 2) ? creep&#13;
F = 2 .</pre>&#13;
<p class="indent">First, we activate <span class="literal">trace</span> and enter the query: <span class="literal">fib(3,F)</span>. At each step, Prolog pauses, waiting for a command. Pressing ENTER moves to the next step and displays <span class="literal">creep</span>. Therefore, each line above represents entering or exiting a subgoal of the rule. Temporary variables have names like <span class="literal">_4072</span>.</p>&#13;
<p class="indent">The first line of the trace is the query with a temporary name for <span class="literal">F</span>. The <span class="literal">8</span> is similar to a call depth indicator, as it increases as the query is evaluated and decreases back to its initial value when the query is satisfied.</p>&#13;
<p class="indent">If you walk through the trace, you’ll see that each step works to satisfy the particular subgoal, that is, a part of the right-hand side of the rule. The first pair, for example, indicates that 3 &gt; 2 is true. The second pair says that 2 = 3 + (<em>–</em>1), which is also true. Interestingly, Prolog adds a –1 instead of subtracting 1.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>The first recursive call <span class="ent">➊</span> is immediately satisfied because <span class="literal">fib(2,1)</span> is a known fact, one of the base cases of the recursion. The second recursive call <span class="ent">➋</span> is similarly satisfied because <span class="literal">fib(1,1)</span> is also a fact.</p>&#13;
<p class="indent">With the recursive calls satisfied, the final subgoal, <span class="literal">F is F1 + F2</span>, can be satisfied with <span class="literal">F=2</span>. Thus, the query, <span class="literal">fib(3,2)</span>, is now satisfied and Prolog returns <span class="literal">F = 2</span>.</p>&#13;
<p class="indent">The trace for <span class="literal">fib(3,F)</span> produced 14 lines of output and the trace for <span class="literal">fib(26,F)</span>, which took nearly 30 seconds to return, produced 1,456,706 lines, reaching a maximum depth 24 above the base depth.</p>&#13;
<p class="indent">We’ve been a bit unfair to Prolog. The double recursive Fibonacci algorithm is inefficient because it is not <em>tail recursive</em>. A tail-recursive call is one in which the last invocation is the recursive part. Tail-recursive functions can be implemented without storing the current call’s stack frame. The recursion becomes essentially a jump to the beginning of the function without involving the call stack.</p>&#13;
<p class="indent"><a href="ch01.xhtml#ch01list11">Listing 1-11</a> is a tail-recursive version of the Fibonacci program. You’ll find it in the file <em>fib_tail.pl</em>.</p>&#13;
<pre>fib(1,A,F,F).&#13;
&#13;
fib(N,A,B,F) :-&#13;
    N &gt; 0,&#13;
    N1 is N-1,&#13;
    B1 is A+B,&#13;
    fib(N1,B,B1,F).</pre>&#13;
<p class="caption" id="ch01list11"><em>Listing 1-11: Fibonacci numbers using tail recursion</em></p>&#13;
<p class="indent">This version of the code uses two additional variables as accumulators: the second and third arguments. The base case is any call matching <span class="literal">fib(1,A,F,F)</span>, with <span class="literal">F</span> being the desired number, and <span class="literal">A</span> being any other value. Notice that the rule <span class="literal">fib(N,A,B,F)</span> has a recursive call as the final subgoal, unlike <a href="ch01.xhtml#ch01list10">Listing 1-10</a>, which has two recursive calls, neither of which is the final subgoal. Prolog can use tail recursion here because there is nothing in the body to come back to.</p>&#13;
<p class="indent">Run <a href="ch01.xhtml#ch01list11">Listing 1-11</a> as <span class="literal">fib(26,0,1,F)</span> to find the 26th Fibonacci number. This time, Prolog will respond immediately with 121,383. Then try <span class="literal">fib(266,0,1,F)</span> to see that Prolog supports arbitrary precision integers. The <span class="literal">trace</span> command will show you how the accumulators are used to ultimately arrive at a call matching <span class="literal">fib(1,A,F,F)</span>.</p>&#13;
<p class="indent">If our goal is to learn to think outside the box in terms of what it means to code, and it is, then Prolog promotes such thinking. Keep Prolog in the back of your mind. We’ll see a similar approach later when we discuss CLIPS in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<h3 class="h3" id="lev1sec17"><strong>Smalltalk</strong></h3>&#13;
<p class="noindent">Smalltalk came to be in the early 1970s, a product of the Learning Research Group at Xerox PARC. It was designed by Alan Kay, Dan Ingalls, and Adele <span epub:type="pagebreak" id="page_28"/>Goldberg as a teaching language, much like Logo. Smalltalk is an object-oriented language. In fact, it is a <em>pure object-oriented language</em>, meaning that everything, even numbers, is an object. Pure object-oriented languages stand in contrast to impure languages like C++. In C++, <em>primitives</em>, such as integers, are not objects. Smalltalk objects communicate with each other by sending messages. If an object knows how to reply to a message, then that object is a valid receiver of the message.</p>&#13;
<p class="indent">Smalltalk classes support <em>duck typing</em> and may be extended at will. Duck typing allows any object that supports a particular method to be used where that method is expected. In other words, if it walks like a duck and quacks like a duck, it’s a duck.</p>&#13;
<p class="indent">Even without knowing the syntax, we can understand that <span class="literal">MyClass</span> in the following example defines a method, <span class="literal">A</span>, to square its argument.</p>&#13;
<pre>Object subclass: MyClass [ &#13;
    A: n [ ^n*n ]&#13;
]</pre>&#13;
<p class="noindent">At any later time, even if objects of <span class="literal">MyClass</span> already exist, a new method to calculate cubes may be added.</p>&#13;
<pre>MyClass extend [ &#13;
    B: n [ ^n*n*n ] &#13;
]</pre>&#13;
<p class="noindent">The <span class="literal">MyClass</span> class, including any existing objects, now knows how to use the method <span class="literal">B</span>.</p>&#13;
<p class="indent">Many Smalltalk systems include an extensive graphical interface. This includes Smalltalk-80, the version we’ll explore here. Modern Smalltalk systems, like Squeak (<em><a href="https://squeak.org/">https://squeak.org/</a></em>) or Pharo (<em><a href="https://pharo.org/">https://pharo.org/</a></em>), follow this tradition. If Smalltalk piques your curiosity, do take a look at one or both of these systems. However, the essence of the Smalltalk language is our focus, not its graphics abilities. Therefore, we’ll work with GNU Smalltalk, which is graphics-free.</p>&#13;
<p class="indent">If you want to follow along yourself, install GNU Smalltalk by typing</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install gnu-smalltalk</span></pre>&#13;
<p class="noindent">On macOS, you can install Smalltalk by typing</p>&#13;
<pre>$ <span class="codestrong1">brew install gnu-smalltalk</span></pre>&#13;
<p class="noindent">For Windows users, I recommend a Linux virtual machine, Windows Subsystem for Linux, or, barring that, Cygwin.</p>&#13;
<p class="indent">Smalltalk supports integers, floating-point numbers, strings, and fractions (rationals). Smalltalk has 1D arrays, dictionaries, and many other container objects.</p>&#13;
<p class="indent">Our goal in this vignette is to learn what makes Smalltalk unique and a good addition to our collection of novel programming languages. First comes a brief discussion of what Smalltalk brings to the table. Then we’ll <span epub:type="pagebreak" id="page_29"/>work through a complete Smalltalk program to understand, at least superficially, how classes are defined and subclassed. Specifically, we simulate a race between four different animals, each its own Smalltalk class: bird, wolf, frog, and snail.</p>&#13;
<h4 class="h4" id="lev2sec5"><strong><em>Basic Smalltalk Features</em></strong></h4>&#13;
<p class="noindent">GNU Smalltalk is intended for scripting, just like Python or Perl. For example, this code shows our first example:</p>&#13;
<pre>#!/usr/bin/gst&#13;
"Smalltalk 'Hello, world!' example"&#13;
&#13;
'' displayNl.&#13;
'Hello, world!' displayNl.&#13;
'' displayNl.</pre>&#13;
<p class="noindent">The first line is not standard Smalltalk. It’s the comment line used by Unix systems to make a script executable by pointing to its interpreter. Double quotes surround comments in Smalltalk, while single quotes surround strings.</p>&#13;
<p class="indent">The general syntax for calling a method on an object is <span class="codeitalic">&lt;object&gt;</span> <span class="codeitalic">&lt;method&gt;</span> or <span class="codeitalic">&lt;object&gt; &lt;method&gt;: &lt;argument&gt;</span>. Everything’s an object, including strings (even empty ones). Each line in the example above defines a string and then calls the <span class="literal">displayNl</span> method to print it. Notice the period at the end of each line. Smalltalk uses periods as statement separators. On a Unix-like system, <span class="literal">chmod a+x hello.st</span> makes <em>hello.st</em> executable. The GNU Smalltalk interpreter itself is <span class="literal">gst</span>:</p>&#13;
<pre><span class="codestrong1">gst</span>&#13;
GNU Smalltalk ready&#13;
&#13;
st&gt; <span class="codestrong1">2 + 3 * 6</span>&#13;
30&#13;
st&gt; <span class="codestrong1">2 + (3 * 6)</span>&#13;
20</pre>&#13;
<p class="noindent">You can exit the interpreter with CTRL-D.</p>&#13;
<p class="indent">The expressions above should give you pause. Smalltalk evaluates from left to right without respect to operator precedence. Therefore, the first expression is interpreted as <span class="literal">2+3*6 = 5*6 = 30</span>. Recall that APL is similar but evaluates from right to left. In Smalltalk, use parentheses on expressions to enforce the desired evaluation ordering.</p>&#13;
<p class="indent">Smalltalk syntax is simple but leads to verbose statements. To define and make basic use of an array, use</p>&#13;
<pre>st&gt; <span class="codestrong1">x := Array new: 5</span>&#13;
(nil nil nil nil nil )&#13;
st&gt; <span class="codestrong1">x at: 1 put: 3</span>&#13;
3<span epub:type="pagebreak" id="page_30"/>&#13;
st&gt; <span class="codestrong1">x at: 3 put: 'plugh'</span>&#13;
'plugh'&#13;
st&gt; <span class="codestrong1">x</span>&#13;
(3 nil 'plugh' nil nil )</pre>&#13;
<p class="indent">Smalltalk uses <span class="literal">:=</span> for assignment, so the first line declares <span class="literal">x</span> to be an array of five elements. Smalltalk variables default to <span class="literal">nil</span>. The second line is <span class="literal">x[0]=3</span> in most other languages. The method name is <span class="literal">at</span> and it accepts one argument, the index, and a keyword argument, <span class="literal">put</span>. Smalltalk arrays hold any object, as the remaining lines above demonstrate. Smalltalk indexes arrays from one.</p>&#13;
<p class="indent">It’s possible Smalltalk would win first prize for the longest method name in a standard library. Consider the following, which counts how many times a substring appears in another string:</p>&#13;
<pre>st&gt; <span class="codestrong1">s := 'Nobody expects the Spanish inquisition!'</span>&#13;
st&gt; <span class="codestrong1">s countSubCollectionOccurrencesOf: 'i'</span>&#13;
5</pre>&#13;
<p class="indent">Graphical Smalltalk systems have a transcript window where messages are displayed. GNU Smalltalk uses this for normal output:</p>&#13;
<pre>st&gt; <span class="codestrong1">Transcript show: 'howdy'; cr; show: 'partner'; cr</span>&#13;
howdy&#13;
partner</pre>&#13;
<p class="noindent">This little example illustrates several Smalltalk features. First, <span class="literal">Transcript</span> is the name of a class, so we’re using class-level methods, not instance methods. Second, Smalltalk uses a semicolon to call methods using the most recent class or object, which in this case is <span class="literal">Transcript</span>.</p>&#13;
<h5 class="h5" id="lev3sec1"><strong>Blocks</strong></h5>&#13;
<p class="noindent">An important concept in Smalltalk is the <em>block</em>, which is code between square brackets. Blocks are similar to unnamed functions, as they can be assigned to variables and later executed. They also form the body of Smalltalk’s control structures, which are nothing more than method calls on objects, like everything else in Smalltalk. Consider the following example.</p>&#13;
<pre>st&gt; <span class="codestrong1">b := [ 'I am a block. I am an island.' displayNl ]</span>&#13;
a BlockClosure&#13;
st&gt; <span class="codestrong1">b value</span>&#13;
I am a block.  I am an island.&#13;
'I am a block.  I am an island.'</pre>&#13;
<p class="noindent">We define <span class="literal">b</span> to be a block. The block contains one statement to print a string. To execute the block, we call <span class="literal">value</span>, which prints the string. The second string in quotes is the value of the block, the last statement in it, which is the string here. In a running program, the second string would not be shown.</p>&#13;
<p class="indent">Blocks accept arguments and support local variables.</p>&#13;
<pre><span epub:type="pagebreak" id="page_31"/>st&gt; <span class="codestrong1">x := 'number 9'</span>&#13;
'number 9'&#13;
st&gt; <span class="codestrong1">b := [ :i | |y| y:=i. x:=y. z:=y ]</span>&#13;
a BlockClosure&#13;
st&gt; <span class="codestrong1">b value: 42</span>&#13;
42&#13;
st&gt; <span class="codestrong1">x. z. y</span>&#13;
42&#13;
42&#13;
nil</pre>&#13;
<p class="indent">It’s important to understand this example. First, we have <span class="literal">x</span>, defined outside of a block and set to a string. Next, we define block <span class="literal">b</span>. It accepts an argument, <span class="literal">i</span> (the colon is necessary), and defines a local variable, <span class="literal">y</span>. Local variables are listed between vertical bars (pipes). The body of the block sets <span class="literal">y</span> to the argument, <span class="literal">i</span>, then uses <span class="literal">y</span> to assign to <span class="literal">x</span> and <span class="literal">z</span>.</p>&#13;
<p class="indent">The block is executed with 42 as the argument. Then we look at the value of <span class="literal">x</span>, <span class="literal">z</span>, and <span class="literal">y</span>. What happened? The block updated <span class="literal">x</span>, which already existed outside of the block. It also defined <span class="literal">z</span> <em>outside</em> the block. We didn’t declare <span class="literal">z</span> to be local to the block, so it was defined globally. We did declare <span class="literal">y</span> to be local to the block, so it has no value outside of the block, hence <span class="literal">nil</span>. The moral of the story is: if you want what happens in the block to stay in the block, only use local variables. As an exercise, try this example in Python, defining a function called <span class="literal">b(i)</span> in place of the block. Variables defined in the function do not alter variables defined globally unless you use <span class="literal">global</span> explicitly. Smalltalk blocks allow unintended consequences, so care is necessary.</p>&#13;
<h5 class="h5" id="lev3sec2"><strong>Control Structures</strong></h5>&#13;
<p class="noindent">Smalltalk has the expected control structures, but their syntax is unusual because they are really methods. Let’s look quickly at conditional statements, <span class="literal">while</span> loops, and iterated loops. We can’t cover all combinations, especially with iteration, but you’ll get the gist of what’s going on.</p>&#13;
<p class="indent">Examine this short program:</p>&#13;
<pre>v := stdin nextLine asInteger.&#13;
&#13;
(v &lt; 0) ifTrue: [&#13;
    a := -1&#13;
] ifFalse: [ &#13;
    (v &gt; 0) ifTrue: [&#13;
        a := 1&#13;
    ] ifFalse: [&#13;
        a := 0&#13;
    ]&#13;
].</pre>&#13;
<p class="noindent">It asks the user for an integer by reading the next line from standard input and interpreting the resulting string as an integer before assigning it to <span class="literal">v</span>. <span epub:type="pagebreak" id="page_32"/>Next, the code checks to see if <span class="literal">v</span> is less than 0, 0, or greater than 0 and sets the value of <span class="literal">a</span> accordingly.</p>&#13;
<p class="indent">The code above looks like an <span class="literal">if-then-else</span> construct, and it acts like one, but it isn’t one. It’s normal Smalltalk <span class="codeitalic">&lt;object&gt; &lt;method&gt;: &lt;argument&gt;</span> syntax. The <span class="literal">ifTrue</span> method is applied to the Boolean returned by <span class="literal">(v &lt; 0)</span>. If the Boolean is true, execute the block that sets <span class="literal">a</span> to –1. Similarly, <span class="literal">ifFalse</span> fires if the Boolean value is not true. Nesting within the block is perfectly fine, so the first <span class="literal">ifFalse</span> block has its own pair of <span class="literal">ifTrue</span> and <span class="literal">ifFalse</span> method calls.</p>&#13;
<p class="indent">In Smalltalk, <span class="literal">while</span> loops act similarly. Consider</p>&#13;
<pre>i:=1. &#13;
[i &lt; 10] whileTrue: [ i displayNl. i := i + 1 ]</pre>&#13;
<p class="noindent">where, unlike <span class="literal">ifTrue</span>, <span class="literal">whileTrue</span> is applied to a block, <span class="literal">[i &lt; 10]</span>. As expected, this code snippet displays the numbers 1 through 9. The same output is generated by</p>&#13;
<pre>i:=1.&#13;
[i &gt;= 10] whileFalse: [ i displayNl. i := i + 1 ]</pre>&#13;
<p class="noindent">which loops for as long as the code block returns <span class="literal">false</span>. Note that <span class="literal">while</span> loops are applied to a block, so the block need not be just a simple Boolean expression, but need only return a Boolean value. The following is a perfectly valid loop</p>&#13;
<pre>i:=1. &#13;
[x:=i*i. i &lt; 10] whileTrue: [ i displayNl. i := i + 1 ]</pre>&#13;
<p class="noindent">with the side effect of defining <span class="literal">x</span> and setting it to 100.</p>&#13;
<p class="indent">A basic <span class="literal">for</span> loop in Smalltalk is</p>&#13;
<pre>1 to: 10 do: [ :i | i displayNl ]</pre>&#13;
<p class="noindent">As with <span class="literal">if</span> and <span class="literal">while</span>, the loop isn’t a construct; it’s a message <span class="literal">to</span> sends to the integer object, 1. The first part creates an <span class="literal">Interval</span> object, which is the entity that understands the <span class="literal">do</span> message. For example, the following code produces the same output as the previous.</p>&#13;
<pre>j := 1 to: 10.&#13;
j do: [ :i | i displayNl ]</pre>&#13;
<p class="noindent">Notice that the argument to <span class="literal">do</span> is a block, with <span class="literal">i</span> being the argument that becomes the loop control variable. Therefore, we can do something like the following if we wish:</p>&#13;
<pre>j := 1 to: 10.&#13;
b := [ :i | i displayNl ].&#13;
j do: b.</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_33"/>The first line defines <span class="literal">j</span> as an <span class="literal">Interval</span> object, the second defines <span class="literal">b</span> as a block (really a <span class="literal">BlockClosure</span> object), and the third uses <span class="literal">do</span> to apply the block to the interval.</p>&#13;
<p class="indent">We’ve hit the essentials of Smalltalk, though honestly we’ve barely put our little toe in the water. Smalltalk has a simple syntax and an extensive class library that we’ve ignored. However, we must press on. Smalltalk is all about objects and classes. Let’s see how by going to the races.</p>&#13;
<h4 class="h4" id="lev2sec6"><strong><em>Going to the Races</em></strong></h4>&#13;
<p class="noindent">We’ll create a small class hierarchy and use it to race four animals against each other. Our plan is this:</p>&#13;
<ol>&#13;
<li class="noindent">Define a base class, <span class="literal">Animal</span>, that responds to messages common to  all the animals.</li>&#13;
<li class="noindent">Define four subclasses: <span class="literal">Bird</span>, <span class="literal">Wolf</span>, <span class="literal">Frog</span>, and <span class="literal">Snail</span>. The subclasses  respond to messages based on how the animals move: <span class="literal">fly</span>, <span class="literal">run</span>, <span class="literal">hop</span>,  and <span class="literal">crawl</span>, respectively. The class ignores messages that it doesn’t  understand.</li>&#13;
<li class="noindent">Create an instance of each animal and send randomly selected  messages to them.</li>&#13;
<li class="noindent">Display the distance each animal has moved and declare a winner.</li>&#13;
</ol>&#13;
<p class="indent">The complete source code is in <em>race.st</em>. We’ll present it in pieces as we walk through it. Please read through the full source code file first before proceeding. If you do, the discussion will be easier to follow. Recall that the first line of the file is not standard Smalltalk; it’s Unix-speak to run the file as a script. The <span class="literal">-g</span> option disables the occasional garbage collection message.</p>&#13;
<p class="indent">We begin with the base class, <span class="literal">Animal</span>:</p>&#13;
<pre>Object subclass: Animal [&#13;
    | increment distance letter |&#13;
    init: inc letter: l [&#13;
        letter := l.&#13;
        increment := inc.&#13;
        distance := 0&#13;
    ]&#13;
    getDistance [ ^distance ]&#13;
    print [&#13;
        (distance-1) timesRepeat: [  '-' display ].&#13;
        letter displayNl&#13;
    ]&#13;
]</pre>&#13;
<p class="indent">All Smalltalk classes are subclasses of something. The top of the object hierarchy is the class <span class="literal">Object</span>, so <span class="literal">Animal</span> subclasses from it. There are three member variables: <span class="literal">increment</span>, <span class="literal">distance</span>, and <span class="literal">letter</span>. There are three methods: <span class="literal">init</span>, <span class="literal">getDistance</span>, and <span class="literal">print</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_34"/>The <span class="literal">init</span> method accepts <span class="literal">inc</span> as an argument along with <span class="literal">letter</span>, a keyword argument. In Smalltalk, instances of a class are usually created with <span class="literal">new</span> and initialized later; however, this process is flexible. We’ll call <span class="literal">init</span> to set up our class instances. In this case, initialization sets the distance traveled to zero, the letter associated with the animal when printing, and how far the animal moves each time it does move.</p>&#13;
<p class="indent">The next method is <span class="literal">getDistance</span>. It returns the current value of <span class="literal">distance</span>. Smalltalk does not have a return statement; rather, it precedes the value to return with a carat (<span class="literal">^</span>).</p>&#13;
<p class="indent">The final method, <span class="literal">print</span>, displays the animal’s distance traveled as a sequence of dashes ending with the animal’s letter. It uses <span class="literal">timesRepeat</span>, a message sent to an integer to repeat a code block a set number of times.</p>&#13;
<p class="indent"><span class="literal">Animal</span> defines the base class. The specific animal classes come next:</p>&#13;
<pre>Animal subclass: Bird [&#13;
    init [ super init: 6 letter: 'B' ]&#13;
    fly [ distance := distance + increment ]&#13;
    doesNotUnderstand: msg [ ]&#13;
]&#13;
Animal subclass: Wolf [&#13;
    init [ super init: 5 letter: 'W' ]&#13;
    run [ distance := distance + increment ]&#13;
    doesNotUnderstand: msg [ ]&#13;
]&#13;
Animal subclass: Frog [&#13;
    init [ super init: 4 letter: 'F' ]&#13;
    hop [ distance := distance + increment ]&#13;
    doesNotUnderstand: msg [ ]&#13;
]&#13;
Animal subclass: Snail [&#13;
    init [ super init: 3 letter: 'S' ]&#13;
    crawl [ distance := distance + increment ]&#13;
    doesNotUnderstand: msg [ ]&#13;
]</pre>&#13;
<p class="indent">Each class defines <span class="literal">init</span>, which calls <span class="literal">init</span> of the superclass, <span class="literal">Animal</span>, passing in the increment and letter associated with the animal. For <span class="literal">Bird</span>, the increment is <span class="literal">6</span> and the letter is <span class="literal">'B'</span>.</p>&#13;
<p class="indent">Each subclass defines a method based on how the animal moves. For <span class="literal">Bird</span>, it’s <span class="literal">fly</span>. The move method adds the increment to the distance. The last method in each subclass is <span class="literal">doesNotUnderstand</span>. This method is called by Smalltalk when an object receives a message it has no method for. For example, if we pass the <span class="literal">fly</span> method to a <span class="literal">Wolf</span> object, <span class="literal">doesNotUnderstand</span> is be called. We want to ignore unknown messages, so the body of the method is empty.</p>&#13;
<p class="indent">The classes are defined, but no instances have been created. Let’s create an instance of each and store the objects in an array.<span epub:type="pagebreak" id="page_35"/></p>&#13;
<pre>animals := Array new: 4.&#13;
animals at: 1 put: (Bird new).&#13;
animals at: 2 put: (Wolf new).&#13;
animals at: 3 put: (Frog new).&#13;
animals at: 4 put: (Snail new).&#13;
1 to: 4 do: [ :i | (animals at: i) init ].</pre>&#13;
<p class="indent">Each element of the array <span class="literal">animals</span> is set to the object returned by calling <span class="literal">new</span>. Doing this creates the objects, but they are not yet initialized. The final line loops over the array, calling each object’s <span class="literal">init</span> method.</p>&#13;
<p class="indent">The animals are ready, so let’s run the race.</p>&#13;
<pre>moves := #('fly' 'run' 'hop' 'crawl').&#13;
50 timesRepeat: [&#13;
    m := moves at: ((1 to: 4) atRandom).&#13;
    1 to: 4 do: [ :i | (animals at: i) perform: m asSymbol ].&#13;
].</pre>&#13;
<p class="indent">There are four movement methods: <span class="literal">fly</span>, <span class="literal">run</span>, <span class="literal">hop</span>, and <span class="literal">crawl</span>. We want to select one of them at random and send it to each animal. If the animal knows how to respond to the message, it does; otherwise, it quietly ignores it.</p>&#13;
<p class="indent">First, <span class="literal">moves</span> is set to an array of the method names. This syntax is a shortcut for the <span class="literal">at:put:</span> syntax used above. The <span class="literal">timesRepeat</span> loop sets the number of moves that will happen. The interval, <span class="literal">(1 to: 4)</span>, is sent <span class="literal">atRandom</span> to return a random integer in [1,4]. This is the index in <span class="literal">moves</span> to set <span class="literal">m</span> to a randomly selected method string. The <span class="literal">do</span> loop sends the message in <span class="literal">m</span> to each animal by first converting the string to a symbol representing the method before passing it to the object itself via <span class="literal">perform</span>. Because each animal only responds to one of the move messages, only one animal will move during each pass through the <span class="literal">timesRepeat</span> loop.</p>&#13;
<p class="indent">The race is now over. To see how the animals did, we use the code below to call the <span class="literal">print</span> method of each animal:</p>&#13;
<pre>Transcript cr; show: 'Race results:'; cr; cr&#13;
1 to: 4 do: [ :i | (animals at: i) print ].&#13;
'' displayNl.</pre>&#13;
<p class="noindent">To declare a winner, we need to find which of the four moved the farthest. For that, we’ll use a <span class="literal">Dictionary</span>,</p>&#13;
<pre>dist := Dictionary new.&#13;
1 to: 4 do: [ :i | &#13;
    animal := animals at: i.&#13;
    dist at: animal put: animal getDistance&#13;
].</pre>&#13;
<p class="noindent">where the keys are the object instances and the values are the distance each animal moved. To declare a winner we find the maximum distance.</p>&#13;
<pre><span epub:type="pagebreak" id="page_36"/>d := (animals at: 1) getDistance.&#13;
winner := (animals at: 1) class displayString.&#13;
dist associationsDo: [ :pair |&#13;
    ((pair value) &gt; d) ifTrue: [&#13;
        d := pair value.&#13;
        winner := (pair key) class displayString.&#13;
    ]&#13;
].&#13;
Transcript show: 'The winner is '; show: winner; cr; cr.</pre>&#13;
<p class="indent">To loop over a dictionary, use <span class="literal">associationsDo</span>, which passes a key-value pair to the body of the loop. The <span class="literal">value</span> of the pair is the distance that animal traveled and the <span class="literal">key</span> is a reference to the object. The phrase <span class="literal">class displayString</span> converts the name of the object class to a string for display.</p>&#13;
<p class="indent">The output of <em>race.st</em> looks like this:</p>&#13;
<pre>Race results:&#13;
&#13;
------------------------------------------------------------------B&#13;
--------------------------------------------------------------------W&#13;
--------------------------------------------------------------F&#13;
-----------------------------S&#13;
&#13;
The winner is Wolf</pre>&#13;
<p class="indent">The bird will win most often as it flies the farthest each time it moves. The wolf wins next most often and the snail least often. The file <em>run.py</em> runs 10,000 races tracking how often each animal wins. For example, one run produced</p>&#13;
<pre>Bird wins  0.6373&#13;
Wolf wins  0.2802&#13;
Frog wins  0.0760&#13;
Snail wins 0.0065</pre>&#13;
<p class="indent">The bird won nearly 64 percent of the races, followed by the wolf, who won 28 percent. The poor snail only won about one race in two hundred.</p>&#13;
<h3 class="h3" id="lev1sec18"><strong>Standard ML</strong></h3>&#13;
<p class="noindent">Our final language is <em>Standard ML</em> (SML), an early functional language based on ML. <em>Functional languages</em> use composition of functions—that is, functions applied to the output of other functions—to implement algorithms. We’ll get to what makes SML a functional language in a later chapter when discussing programming language paradigms.</p>&#13;
<p class="indent">The version of SML we’ll work with, SML-NJ (NJ stands for “New Jersey”) largely conforms to the language standard promulgated in 1997 (<em><a href="https://smlfamily.github.io/sml97-defn.pdf">https://smlfamily.github.io/sml97-defn.pdf</a></em>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>To follow along, install SML on Ubuntu using the command</p>&#13;
<pre>&gt; <span class="codestrong1">sudo apt-get install smlnj</span></pre>&#13;
<p class="noindent">Versions for macOS and Windows are available at <em><a href="http://www.smlnj.org/dist/working/110.99/index.html">http://www.smlnj.org/dist/working/110.99/index.html</a></em>.</p>&#13;
<p class="indent">Run <span class="codestrong">sml</span> to start the interpreter. As with Smalltalk, use CTRL-D to exit.</p>&#13;
<pre>Standard ML of New Jersey v110.79 [built: Tue Aug  8 23:21:20 2017]&#13;
-</pre>&#13;
<p class="noindent">Ensure that the version number is at least that shown here. The interpreter is waiting for us to type something; try <span class="literal">"scary movie";</span>. The interpreter responds with</p>&#13;
<pre>val it = "scary movie" : string</pre>&#13;
<p class="noindent">This tells us that <span class="literal">"scary movie"</span> is of type <span class="literal">string</span>. Moreover, the interpreter has defined the variable <span class="literal">it</span> and assigned the string to <span class="literal">it</span>. SML statements end with a semicolon and SML is a typed language; however, one of its strengths is that it infers types in most cases.</p>&#13;
<p class="indent">One characteristic of functional languages like SML is <em>referential transparency</em>, meaning that a function returns the same value for the same input regardless of the state of the system as a whole. For example, consider the following Python session:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = 359</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">def f(y):</span>&#13;
... <span class="codestrong1">    return x+y</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">f(2)</span>&#13;
361&#13;
&gt;&gt;&gt; <span class="codestrong1">x = 42</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">f(2)</span>&#13;
44</pre>&#13;
<p class="indent">The value returned by <span class="literal">f(y)</span> depends on the current value of the variable <span class="literal">x</span>. Now consider the equivalent in SML.</p>&#13;
<pre>- <span class="codestrong1">val x = 359;</span>&#13;
val x = 359 : int&#13;
- <span class="codestrong1">fun f(y) = x+y;</span>&#13;
val f = fn : int -&gt; int&#13;
- <span class="codestrong1">f(2);</span>&#13;
val it = 361 : int&#13;
- <span class="codestrong1">val x = 42;</span>&#13;
val x = 42 : int&#13;
- <span class="codestrong1">f(2);</span>&#13;
val it = 361 : int</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_38"/>In this case, the function uses the value of <span class="literal">x</span> as it was when the function was defined. Changing <span class="literal">x</span> later does not affect the function value. SML is referentially transparent, but Python is not. SML functions are defined with <span class="literal">fun</span>, followed by the function name and argument list in parentheses. At least they can be defined that way. We’ll encounter other ways below.</p>&#13;
<p class="indent">SML supports the common primitive data types: integers, reals, and strings. It also supports lists and tuples, along with more advanced user-defined data structures resembling classes. Every member of an SML list must be of the same data type. Tuples may mix data types; however, SML functions consider tuples to be a compound type rather than a collection of the same type.</p>&#13;
<p class="indent">SML is perhaps the only language that requires you to write threatening code.</p>&#13;
<pre>- <span class="codestrong1">val x = true;</span>&#13;
- <span class="codestrong1">val y = false;</span>&#13;
- <span class="codestrong1">x orelse y;</span>&#13;
val it = true : bool&#13;
- <span class="codestrong1">x andalso y;</span>&#13;
val it = false : bool</pre>&#13;
<p class="indent">SML uses <span class="literal">orelse</span> where most other languages use <span class="literal">or</span>. So to check if one or the other conditional expression is true, you use <span class="literal">orelse</span>. Similarly, <span class="literal">andalso</span> replaces <span class="literal">and</span>.</p>&#13;
<p class="indent">SML supports <em>unnamed functions</em>, or <em>lambda functions</em> as they are sometimes called. For example, the following code defines an unnamed function to add 1 to its argument and then immediately applies it to the number 11.</p>&#13;
<pre>- <span class="codestrong1">(fn x =&gt; x+1) 11;</span>&#13;
val it = 12 : int</pre>&#13;
<p class="indent">SML treats functions as <em>first-class objects</em>. This means they can be assigned to variables and returned from functions. One use of this ability is to return a partially evaluated function in which some of the arguments are bound but others are not. This is known as <em>currying</em>, after Haskell Curry, an American mathematician who worked in logic. The Haskell programming language is named after him.</p>&#13;
<p class="indent">Before we see currying in action, consider the following two function definitions:</p>&#13;
<pre>- <span class="codestrong1">fun add(x,y) = x+y;</span>&#13;
val add = fn : int * int -&gt; int&#13;
- <span class="codestrong1">add(11,22);</span>&#13;
val it = 33 : int&#13;
- <span class="codestrong1">fun add x y = x+y;</span>&#13;
val add = fn : int -&gt; int -&gt; int&#13;
- <span class="codestrong1">add 11 22;</span>&#13;
val it = 33 : int</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>We define <span class="literal">add</span> twice with the second definition replacing the first. Both definitions take two arguments and add them together, so <span class="literal">add(11,22)</span> produces the same output as <span class="literal">add 11 22</span>. Look carefully at what SML returned after each function definition.</p>&#13;
<p class="indent">The first definition produced</p>&#13;
<pre>fn : int * int -&gt; int</pre>&#13;
<p class="noindent">which means that <span class="literal">add</span> is a function that accepts two integers and returns an integer. The second definition produced</p>&#13;
<pre>fn : int -&gt; int -&gt; int</pre>&#13;
<p class="noindent">meaning that <span class="literal">add</span> is now a function that accepts an integer and produces <em>a function</em> that accepts an integer and returns an integer. Defined in this form, <span class="literal">add</span> enables currying. Consider:</p>&#13;
<pre>- <span class="codestrong1">fun add x y = x+y;</span>&#13;
val add = fn : int -&gt; int -&gt; int&#13;
- <span class="codestrong1">(add 11) 22;</span>&#13;
val it = 33 : int&#13;
- <span class="codestrong1">val add11 = add 11;</span>&#13;
val add11 = fn : int -&gt; int&#13;
- <span class="codestrong1">add11(22);</span>&#13;
val it = 33 : int&#13;
- <span class="codestrong1">add11;</span>&#13;
val it = fn : int -&gt; int</pre>&#13;
<p class="noindent">We define <span class="literal">add</span> as above and apply it to 11 to return a function that we then apply to 22 to get 33.</p>&#13;
<p class="indent">Currying allows us to fix the first argument, the <span class="literal">x</span>, and bind the returned function, now expecting only the <span class="literal">y</span>, to a variable. The new function, <span class="literal">add11</span>, accepts an integer argument and returns that argument plus 11. Lastly, we see that <span class="literal">add11</span> is indeed a function mapping an integer to an integer.</p>&#13;
<p class="indent">SML functions can use patterns, much like Prolog. For example, consider these definitions:</p>&#13;
<pre>fun hello () = print "Hello, world!\n";&#13;
&#13;
fun greetA(n) =&#13;
    if (n = 1) then hello()&#13;
    else (hello(); greetA(n-1));&#13;
&#13;
fun greetB 1 = hello()&#13;
  | greetB n = (hello(); greetB(n-1));</pre>&#13;
<p class="noindent">This example is in the file <em>hello.sml</em>. You can load it with <span class="codestrong">sml hello.sml</span> or by entering <span class="codestrong">use "hello.sml";</span> if you’re already in the interpreter. Either way, you’ll see SML’s output as to the functions and their types.</p>&#13;
<pre>[opening hello.sml]&#13;
val hello = fn : unit -&gt; unit&#13;
val greetA = fn : int -&gt; unit&#13;
val greetB = fn : int -&gt; unit</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_40"/>The first function, <span class="literal">hello</span>, accepts no arguments and returns nothing. In SML, nothing is represented by <span class="literal">unit</span>. The <span class="literal">hello</span> function is used solely for its side effect of printing “Hello, world!” Therefore, <span class="literal">hello</span> accepts <span class="literal">unit</span> and returns <span class="literal">unit</span>. Both <span class="literal">greetA</span> and <span class="literal">greetB</span> accept an integer and return nothing, hence <span class="literal">unit</span>.</p>&#13;
<p class="indent">Look at the definition of <span class="literal">greetA</span>. It uses a recursive call to <span class="literal">greetA</span> to print “Hello, world!” repeatedly. If the argument is 1, call <span class="literal">hello</span> and return. Otherwise, call <span class="literal">hello</span> then call <span class="literal">greetA</span> again after subtracting 1 from the argument.</p>&#13;
<p class="indent">Now look at <span class="literal">greetB</span>.</p>&#13;
<pre>fun greetB 1 = hello()&#13;
  | greetB n = (hello(); greetB(n-1));</pre>&#13;
<p class="noindent">This function uses a pattern. The first pattern is <span class="literal">greetB 1</span>, meaning that if the argument is one, the pattern matches, so call <span class="literal">hello</span>. The pipe (<span class="literal">|</span>) marks the beginning of the next pattern. This pattern is checked if the previous pattern fails to match. Here, the pattern is any <span class="literal">n</span> that isn’t 1. In that case, call <span class="literal">hello</span> and then call <span class="literal">greetB</span> again with <span class="literal">n-1</span>. This second pattern will repeatedly match until the first pattern matches. The first pattern returns nothing, so the return value of all recursive calls is nothing. This is why SML tells us that <span class="literal">greetB</span> maps an integer to <span class="literal">unit</span>. As an exercise, try implementing the recursive factorial function using a pattern.</p>&#13;
<p class="indent">The final piece of Standard ML we’ll consider is <em>higher-order functions</em>. Higher-order functions are functions that accept functions as arguments. The most common higher-order function is <span class="literal">map</span>, which applies a function to every element of a list. Consider these examples:</p>&#13;
<pre>- <span class="codestrong1">fun add x y = x+y;</span>&#13;
val add = fn : int -&gt; int -&gt; int&#13;
- <span class="codestrong1">val add3 = add 3;</span>&#13;
val add3 = fn : int -&gt; int&#13;
- <span class="codestrong1">map add3 [0,1,2,3,4];</span>&#13;
val it = [3,4,5,6,7] : int list&#13;
- <span class="codestrong1">map (fn x =&gt; "a " ^ x) ["boat", "car", "truck"];</span>&#13;
val it = ["a boat","a car","a truck"] : string list</pre>&#13;
<p class="noindent">The first two definitions use currying to define <span class="literal">add3</span>, a function that adds 3 to its argument. The next line uses <span class="literal">map</span> to apply <span class="literal">add3</span> to each element of the list <span class="literal">[0,1,2,3,4]</span>, producing <span class="literal">[3,4,5,6,7]</span>. The final example applies an unnamed function to prefix a list of strings using <span class="literal">^</span> , which concatenates two strings.</p>&#13;
<p class="indent">The function <span class="literal">map</span> is straightforward to understand. Let’s now look at two more higher-order functions supplied by SML. They go by the names <span class="literal">foldl</span> and <span class="literal">foldr</span>. Review the following and try to work out what they do.</p>&#13;
<pre><span epub:type="pagebreak" id="page_41"/>- <span class="codestrong1">val f = (fn (x,y) =&gt; y^x);</span>&#13;
val f = fn : string * string -&gt; string&#13;
- <span class="codestrong1">foldr f "a " ["boat", "car", "truck"];</span>&#13;
val it = "a truckcarboat" : string&#13;
- <span class="codestrong1">foldl f "a " ["boat", "car", "truck"];</span>&#13;
val it = "a boatcartruck" : string</pre>&#13;
<p class="indent">The first line shows yet another way to define a function by assigning an unnamed function to a variable. The function <span class="literal">f</span> accepts two arguments and returns the first prepended by the second. Note the flip between <span class="literal">x</span> and <span class="literal">y</span>.</p>&#13;
<p class="indent">The next line calls <span class="literal">foldr</span> with <span class="literal">f</span> and two arguments: the string <span class="literal">"a "</span> and a list of strings. The result is a string. The following statement uses <span class="literal">foldl</span> in place of <span class="literal">foldr</span>. It also produces a string, but the order of the strings in the list is reversed from the <span class="literal">foldr</span> example. Do you see the pattern?</p>&#13;
<p class="indent">The <span class="literal">foldl</span> function traverses the list from left to right, so the <span class="literal">foldl</span> call is equivalent to</p>&#13;
<pre>f("truck", f("car", f("boat", "a ")));</pre>&#13;
<p class="noindent">whereas <span class="literal">foldr</span> traverses from right to left</p>&#13;
<pre>f("boat", f("car", f("truck", "a ")));</pre>&#13;
<p class="indent">The fold higher-order functions are useful numerically as well.</p>&#13;
<pre>- <span class="codestrong1">foldl op+ 0 [11,33,22,44];</span>&#13;
val it = 110 : int&#13;
- <span class="codestrong1">foldl op* 1 [5,4,3,2,1];</span>&#13;
val it = 120 : int</pre>&#13;
<p class="noindent">The notation <span class="literal">op+</span> refers to the binary addition operator, so the first line sums a list of integers. Likewise, <span class="literal">op*</span> is multiplication, meaning the second line calculates the product of a list of integers.</p>&#13;
<p class="indent">There is much more to Standard ML, including an extensive library of data types. However, we’ve reviewed enough to get a feel for the language.</p>&#13;
<h3 class="h3" id="lev1sec19"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we compared programming languages to paleontology, a metaphor we’ll return to throughout the book. Then, we briefly explored 10 programming languages to understand how they approach the idea of coding. The selected languages either introduced fundamental concepts or programming paradigms, like object-oriented programming, or were novel simply because they were first. In some cases, the language was foundational to a collection of future languages, like ALGOL. Reviewing what was and is helps us see where we might go and puts us in a frame of mind conducive to what esolangs have to offer.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_42"/>The vignettes in this chapter are superficial, but necessarily so. Let’s step back a bit now and consider what it means to be a programming language, to grasp at their essence.</p>&#13;
</div></body></html>