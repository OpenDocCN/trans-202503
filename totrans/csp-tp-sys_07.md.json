["```\npublic class Color\n{\n    public Color(int red, int green, int blue)\n        => (Red, Green, Blue) = (red, green, blue);\n    public int Red   {get;}\n    public int Green {get;}\n    public int Blue  {get;}\n}\npublic class TranslucentColor : Color\n{\n    public TranslucentColor(int red, int green, int blue, int alpha)\n        : base(red, green, blue) => Alpha = alpha;\n    **public int Alpha {get;}**\n}\n```", "```\nvar foreground = new TranslucentColor(red: 0xFF, green: 0, blue: 0, alpha: 0x77);\nAssert.That(foreground.Red, Is.EqualTo(0xFF));\nAssert.That(foreground.Alpha, Is.EqualTo(0x77));\n```", "```\npublic class Color : IEquatable<Color>\n{\n    public int Red   {get;}\n    public int Green {get;}\n    public int Blue  {get;}\n    public bool Equals(Color? other)\n        => (object?)this == (object?)other ||\n           other is not null &&\n           GetType() == other.GetType() &&\n           Red == other.Red && Green == other.Green && Blue == other.Blue;\n    public override bool Equals(object? obj)\n        => Equals(obj as Color);\n    public override int GetHashCode()\n        => HashCode.Combine(Red, Green, Blue);\n    public static bool operator==(Color? left, Color? right)\n        => left?.Equals(right) ?? right is null;\n public static bool operator!=(Color? left, Color? right)\n        => !left?.Equals(right) ?? right is not null;\n}\n```", "```\npublic override bool Equals(object? obj)\n    => Equals(obj as Color);\n```", "```\npublic bool Equals(Color? other)\n    => (object?)this == (object?)other ||\n       other is not null &&\n       GetType() == other.GetType() &&\n       Red == other.Red && Green == other.Green && Blue == other.Blue;\n```", "```\npublic static bool operator==(Color? left, Color? right)\n    => left?.Equals(right) ?? right is null;\npublic static bool operator!=(Color? left, Color? right)\n    => !left?.Equals(right) ?? right is not null;\n```", "```\nvar pencil = new Color(0xFF, 0, 0);\nvar crayon = new Color(0xFF, 0, 0);\nvar brush =  new Color(0xFF, 0, 0);\n// Reflexive, value-based equality\nAssert.That(pencil == pencil, Is.True);\nAssert.That(pencil == new Color(0xFF, 0, 0), Is.True);\n// Symmetric\nAssert.That(pencil == crayon, Is.True);\nAssert.That(crayon == pencil, Is.True);\n// Transitive\nAssert.That(pencil == crayon, Is.True); Assert.That(crayon == brush, Is.True);\nAssert.That(pencil == brush, Is.True);\n// Safe with null\nAssert.That(pencil != null, Is.True);\nAssert.That(null != pencil, Is.True);\n```", "```\nvar pencil = new Color(0xFF, 0, 0);\nvar crayon = new Color(0xFF, 0, 0);\nAssert.That(pencil == crayon, Is.True);\npencil = new Color(0, 0xFF, 0);\nAssert.That(pencil != crayon, Is.True);\n```", "```\npublic class TranslucentColor : Color, IEquatable<TranslucentColor>\n{\n    public int Alpha {get;}\n    public bool Equals(TranslucentColor? other) ❶\n        => base.Equals(other) && Alpha == other.Alpha;\n    public override bool Equals(object? obj)\n        => Equals(obj as TranslucentColor);\n public override int GetHashCode()\n        => HashCode.Combine(Alpha, base.GetHashCode());\n    public static bool operator==(TranslucentColor? left, TranslucentColor? right) ❷\n        => left?.Equals(right) ?? right is null;\n    public static bool operator!=(TranslucentColor? left, TranslucentColor? right)\n        => !left?.Equals(right) ?? right is not null;\n}\n```", "```\nvar pencil = new TranslucentColor(0xFF, 0, 0xFF, 0x77);\nvar crayon = new TranslucentColor(0xFF, 0, 0xFF, 0x77);\nAssert.That(pencil == crayon, Is.True);\npencil = new TranslucentColor(0xFF, 0, 0xFF, 0);\n**Assert.That(pencil !=** **crayon, Is.True);**\n```", "```\n**Color** pencil = new TranslucentColor(0xFF, 0, 0xFF, **0x77**);\n**Color** crayon = new TranslucentColor(0xFF, 0, 0xFF, **0**);\nAssert.That(pencil == crayon, Is.False);\n```", "```\n**bool EqualViaBase(Color left, Color right)**\n    => left.Equals(right);\nbool EqualViaDerived(TranslucentColor left, TranslucentColor right)\n    => left.Equals(right);\n var pencil = new TranslucentColor(0xFF, 0, 0xFF, 0x77);\nvar crayon = new TranslucentColor(0xFF, 0, 0xFF, 0);\n**Assert.That(EqualViaBase(pencil, crayon), Is.True);**\nAssert.That(EqualViaDerived(pencil, crayon), Is.False);\n```", "```\npublic virtual Color Subtract(Color? other)\n{\n    `--snip--`\n}\n```", "```\npublic record Color(int Red, int Green, int Blue);\npublic record TranslucentColor(int Red, int Green, int Blue, int Alpha)\n            : Color(Red, Green, Blue);\n```", "```\nbool EqualViaBase(Color left, Color right)\n    => left.Equals(right);\nbool EqualViaDerived(TranslucentColor left, TranslucentColor right)\n    => left.Equals(right);\nvar pencil = new TranslucentColor(0xFF, 0, 0xFF, 0x77);\nvar crayon = new TranslucentColor(0xFF, 0, 0xFF, 0);\n**Assert.That(EqualViaBase(pencil, crayon), Is.False);**\n**Assert.That(EqualViaDerived(pencil, crayon), Is.False);**\n```", "```\npublic class Color : IEquatable<Color>\n{\n    `--snip--`\n    **protected virtual Type EqualityContract**\n        **=>** **typeof(Color);**\n public virtual bool Equals(Color? other)\n        => (object?)this == (object?)other ||\n           other is not null &&\n           **EqualityContract** **==** **other.EqualityContract &&**\n           Red == other.Red && Green == other.Green && Blue == other.Blue;\n}\n```", "```\npublic class TranslucentColor : Color, IEquatable<TranslucentColor>\n{\n    `--snip--`\n    protected override Type EqualityContract\n        => typeof(TranslucentColor);\n    **public override bool Equals(Color? obj)**\n        **=>** **Equals(obj as TranslucentColor);**\n    public virtual bool Equals(TranslucentColor? other)\n        => base.Equals(other) && Alpha == other.Alpha;\n}\n```", "```\npublic record Area(double Width, double Height)\n    : IComparable<Area>\n{\n    public int CompareTo(Area? other)\n    {\n        if(other is null) return 1;\n        return (int)(Width * Height - other.Width * other.Height);\n    }\n    public static bool operator<(Area left, Area right)\n        => left.CompareTo(right) < 0;\n    public static bool operator>(Area left, Area right)\n        => left.CompareTo(right) > 0;\n}\npublic record Volume(double Width, double Height, double Depth)\n    : Area(Width, Height), IComparable<Volume>\n{\n    public int CompareTo(Volume? other)\n    { if(other is null) return 1;\n        return (int)(Width * Height * Depth -\n                     other.Width * other.Height * other.Depth);\n    }\n    public static bool operator<(Volume left, Volume right)\n       => left.CompareTo(right) < 0;\n    public static bool operator>(Volume left, Volume right)\n       => left.CompareTo(right) > 0;\n}\n```", "```\nArea door =   new Volume(Width: 100, Height: 200, Depth: 25);\nArea window = new Volume(Width: 100, Height: 200, Depth: 5);\nAssert.That(window < door, Is.True);\n```", "```\npublic readonly record struct Color(int Red, int Green, int Blue);\npublic readonly record struct TranslucentColor**(Color Color, int Alpha)**\n{\n    public TranslucentColor(int red, int green, int blue, int alpha)\n        : this(new Color(red, green, blue), alpha)\n    {\n    }\n public int Red => Color.Red;\n    public int Green => Color.Green;\n    public int Blue => Color.Blue;\n}\n```", "```\nvar bg = new TranslucentColor(0xFF, 0xA0, 0, 0x77);\nAssert.That(bg.Red,   Is.EqualTo(0xFF));\nAssert.That(bg.Green, Is.EqualTo(0xA0));\nAssert.That(bg.Blue,  Is.EqualTo(0));\nAssert.That(bg.Alpha, Is.EqualTo(0x77));\n`--snip--`\n```", "```\nAssert.That(bg.Color.Red,   Is.EqualTo(0xFF));\nAssert.That(bg.Color.Green, Is.EqualTo(0xA0));\nAssert.That(bg.Color.Blue,  Is.EqualTo(0));\nAssert.That(bg.Alpha,       Is.EqualTo(0x77));\n`--snip--`\n```", "```\nvar colors = new List<Color>();\nvar names = new List<string>();\n```", "```\npublic interface IParser<T>\n{\n    public T Parse(string input);\n}\n```", "```\npublic sealed class DataAdapter<**TParser**, TResult>\n    **where TParser : IParser<TResult>**\n{\n    public DataAdapter(TParser parser, IEnumerable<string> source)\n        => (this.parser, items) = (parser, source);\n    public IEnumerable<TResult> Read()\n    {\n        foreach (var item in items)\n        {\n            yield return **parser.Parse(item);**\n        }\n    }\n    private readonly TParser parser;\n    private readonly IEnumerable<string> items;\n}\n```", "```\npublic interface IParser<T>\n{\n    public T Parse(string input);\n}\npublic sealed class ColorParser : **IParser<Color>**\n{\n    public static int FromHex(string part)\n        => int.Parse(part, NumberStyles.HexNumber);\n    **public Color Parse(string input)**\n        => new(Red:   FromHex(input[0..2]),\n               Green: FromHex(input[2..4]),\n               Blue:  FromHex(input[4..6]));\n}\n```", "```\nstring messages = \"FFA000 A0FF00 00F0F0\"; …\nvar provider = new DataAdapter<ColorParser, **Color**>\n                        (new ColorParser(), messages.Split(' '));\nforeach(Color color in provider.Read()) {\n    `--snip--`\n    // Do something with a color\n}\n```", "```\nvar other = new DataAdapter<ColorParser, **TranslucentColor**>\n                    (new ColorParser(), messages.Split(' '));\n```", "```\n[CS0311] The type 'ColorParser' cannot be used as type parameter 'TParser' in the generic\ntype or method 'DataAdapter<TParser, T>'. There is no implicit reference conversion from\n'ColorParser' to 'IParser<TranslucentColor>'.\n```", "```\npublic sealed class DataAdapter<TParser, TResult>\n    where TParser : IParser<TResult>\n`--snip--`\n```", "```\npublic sealed class DataAdapter<TResult>\n{\n    public DataAdapter(IEnumerable<string> source)\n        => items = source;\n    **public IEnumerable<TResult>** **Read<TParser>(TParser parser)**\n        **where TParser : IParser<TResult>**\n    {\n        foreach (var item in items)\n        {\n            yield return parser.Parse(item);\n        }\n    }\n    private readonly IEnumerable<string> items;\n}\n```", "```\nvar provider = new DataAdapter<Color>(messages);\nforeach (Color color in provider.Read(new ColorParser()))\n{\n    `--snip--`\n}\n```", "```\npublic sealed class **TranslucentColorParser : IParser<TranslucentColor>**\n{\n    **public TranslucentColor Parse(string input)**\n        => new(Color: color.Parse(input[0..6]),\n              Alpha: ColorParser.FromHex(input[6..8]));\n    private readonly ColorParser color = new();\n}\n`--snip--`\nvar provider = new DataAdapter<TranslucentColor>(messages);\nvar colors = provider.Read(new TranslucentColorParser()).ToList();\n```", "```\npublic readonly record struct Color(int Red, int Green, int Blue);\nvar plum = new Color(0xDD, 0xA0, 0xDD);\nvar other = new Color(0xDD, 0xA0, 0xDD);\nAssert.That(plum.Equals(**null**), Is.False);\nAssert.That(plum.Equals(**other**), Is.True);\n```", "```\n**object plum** = new Color(0xDD, 0xA0, 0xDD);\nColor other = new Color(0xDD, 0xA0, 0xDD);\nAssert.That(plum.Equals(other), Is.True);\n```", "```\nvar plum = new Color(0xDD, 0xA0, 0xDD);\nvar pink = new Color(0xFF, 0xCC, 0xCC);\nAssert.That(plum != pink, Is.True);\n```", "```\npublic static bool operator==(Color left, int right)\n    => left.Equals(new (right));\npublic static bool operator==(int left, Color right)\n    => right.Equals(new (left));\n```", "```\nvar plum = new Color(Red: 0xDD, Green: 0xA0, Blue: 0xDD);\nAssert.That(plum == 0xDDA0DD, Is.True);\nAssert.That(0xDDA0DD == plum, Is.True);\n```", "```\nvar colors = new List<Color>\n    {\n        `--snip--`\n    };\nvar formatted = colors.Select(\n    color => $\"{color.Red:X2}{color.Green:X2}{color.Blue:X2}\");\n```", "```\npublic static class Formatter\n{\n    public static string Format(Color color)\n        => $\"{color.Red:X2}{color.Green:X2}{color.Blue:X2}\";\n    public static string Format(TranslucentColor color)\n        => $\"{**Format(color.Color)**}{color.Alpha:X2}\";\n}\n```", "```\nvar colors = new List<TranslucentColor>\n{\n    `--snip--`\n};\nvar formatted = colors.Select(**Formatter.Format**);\n```", "```\npublic readonly record struct TranslucentColor(Color Color, int Alpha)\n{\n    `--snip--`\n    public static implicit operator Color(TranslucentColor color)\n        => color.Color;\n}\n```", "```\npublic bool EqualViaColor(Color left, Color right)\n    => left.Equals(right);\nvar red = new TranslucentColor(0xFF, 0, 0, 0);\nvar blue = new TranslucentColor(0, 0, 0xFF, 0);\n**Assert.That(EqualViaColor(red, blue), Is.False);**\n```", "```\npublic readonly struct Color\n{\n    `--snip--`\n    public static explicit operator int(Color color)\n        => color.Red << 16 | color.Green << 8 | color.Blue;\n}\n```", "```\nint Converted(int color)\n{\n    return color;\n}\nvar plum = new Color(0xDD, 0xA0, 0xDD);\nAssert.That(Converted(**(int)plum**), Is.EqualTo(0xDDA0DD));\n```", "```\nvar blue = new Color(0, 0, 0xFF);\nvar green = new Color(0, 0xFF, 0);\nAssert.That(blue < green, Is.True);\n```", "```\npublic class ColorBuilder\n{\n    public int Red {get; set;}\n    public int Green {get; set;}\n    public int Blue {get; set;}\n    public static implicit operator Color(ColorBuilder color)\n        => new Color(color.Red, color.Green, color.Blue);\n}\n```", "```\npublic static double **RelativeLuminance(Color color)**\n    => 0.2126 * color.Red + 0.7152 * color.Green + 0.0722 * color.Blue;\nvar background = new Color(0, 0, 0);\nvar builder = new ColorBuilder();\nbuilder.Red = 0xFF;\nbuilder.Green = 0xFF;\nbuilder.Blue = 0;\nif(**RelativeLuminance(builder)** **<** **RelativeLuminance(background)**)\n    background = builder;\n```"]