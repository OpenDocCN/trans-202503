- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**Search**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: 'This chapter is about a topic that, perhaps more than any other subject covered
    in this book, we all take for granted: finding the data we want, known as a *search*.
    Searching happens so often, and so quickly, that it’s easy to miss the magic.
    When a word processor underlines a misspelled word that you just typed, a fast
    search has taken place behind the scenes. When you enter part of a filename and
    get a list of matching files on your laptop’s hard drive, that’s another near-instant
    search. And then there’s the ultimate search achievement: the Web. The Web is
    so unfathomably large that we can only guess its true size, and yet, web search
    engines can find relevant web pages in a fraction of a second.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的是一个或许比本书中其他任何主题都更为我们所忽视的话题：找到我们想要的数据，也就是*搜索*。搜索如此频繁且迅速，以至于我们常常忽视了其中的“魔法”。当文字处理软件为你刚输入的错别字加上下划线时，背后已经进行了快速的搜索。当你输入文件名的一部分并得到笔记本硬盘上匹配的文件列表时，那也是一次几乎瞬间完成的搜索。而还有终极搜索成就：万维网。万维网庞大到我们只能猜测它的真实规模，然而，网页搜索引擎可以在不到一秒的时间内找到相关的网页。
- en: How does software find what we want so fast?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是如何如此快速地找到我们想要的东西的呢？
- en: '**Defining the Search Problem**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义搜索问题**'
- en: Let’s start by getting our terminology straight. A collection of data is known,
    appropriately enough, as a *data collection*. Each item in the data collection
    is a *record*. A record is uniquely identified by a *key* (no relation to the
    cryptography term). A search retrieves the record that matches a given key. For
    a real-world example, when you use a dictionary the word you’re looking up is
    the key, and the definition of that word is the record.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理清术语开始。一组数据被称为*数据集*。数据集中的每一项被称为*记录*。每条记录通过一个*键*（与密码学术语无关）来唯一标识。搜索会检索出与给定键匹配的记录。举个现实中的例子，当你使用字典时，你查找的单词就是键，而该单词的定义就是记录。
- en: The main goal of searching is to find the right record. But the speed of the
    search is just as important. If searches could go on indefinitely, searching would
    be simple. But as the wait time increases, so does our frustration. The length
    of time we’ll wait on a search varies, but it’s never very long, and in many situations,
    the search must appear to finish instantaneously.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的主要目标是找到正确的记录。但搜索的速度同样重要。如果搜索可以无限进行，搜索就会变得简单。但随着等待时间的增加，我们的沮丧感也会增加。我们愿意等待的搜索时间是有差异的，但通常不会很长，在许多情况下，搜索必须看起来几乎是瞬间完成的。
- en: '**Putting Data in Order**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将数据排序**'
- en: Efficient searching requires well-organized data. When you visit a bookstore,
    for example, finding a novel by a particular author is easy if the store has ordered
    the shelves by authors’ last names. For one thing, you know where to start looking.
    Once you look at the first book on the shelf and see how close its author’s name
    is alphabetically to the author you seek, you would have a good idea where to
    look next.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的搜索需要井井有条的数据。当你去书店时，比如说，按作者的姓氏排列书架上的书籍，找到某个特定作者的小说就很容易。首先，你知道从哪里开始寻找。你看到书架上的第一本书，看到它的作者名字按字母顺序离你要找的作者名字有多近，你就能大致知道接下来该去哪里找。
- en: If the store didn’t shelve its books in any particular order, then finding a
    book would be hard work. The best option is to start at one end of the shelf and
    examine every single book, which is known as a *sequential search*. In the worst
    case, the book you want isn’t even on the shelf, but you wouldn’t know that until
    you’ve looked through the whole collection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果书店没有按照任何特定顺序排列书籍，那么找一本书就会变得非常困难。最好的办法是从书架的一端开始，逐本检查，这叫做*顺序搜索*。在最糟糕的情况下，你想要的书甚至不在书架上，但直到你查看完所有书籍之前，你都不会知道这一点。
- en: Therefore, putting the data collection in a particular order, known as *sorting*,
    is essential for efficient searching. There are many different ways to sort; entire
    books have been written to describe different sorting algorithms for software.
    We’ll look at two methods here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将数据集按特定顺序排列，也就是*排序*，对于高效的搜索至关重要。有许多不同的排序方法；为了描述不同的排序算法，已经出版了整本书。我们将在这里介绍两种方法。
- en: '***Selection Sort***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***选择排序***'
- en: If I asked you to put a list of numbers in order, you would most likely use
    what is known as a *selection sort*. First, you’d scan the list to find the lowest
    number, and then you’d cross the number out and copy it to a new list. You would
    repeat the process until all the numbers were in order in the new, sorted list.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我让你将一个数字列表排序，你很可能会使用被称为*选择排序*的方法。首先，你会扫描列表找到最小的数字，然后将该数字删除并复制到新列表中。你会重复这个过程，直到所有数字都在新的已排序列表中。
- en: The first three steps of a selection sort of nine numbers are shown in [Figure
    7-1](ch07.html#ch7fig1). In the first step, the lowest number is copied to the
    beginning of a new list. In the steps that follow, the lowest remaining numbers
    are copied to the new list.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 九个数字的选择排序的前三步显示在[图7-1](ch07.html#ch7fig1)中。在第一步中，最小的数字被复制到新列表的开头。在接下来的步骤中，剩余的最小数字被复制到新列表中。
- en: '![image](graphics/f07-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-01.jpg)'
- en: '*Figure 7-1: The first three steps in a selection sort of nine numbers*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：九个数字的选择排序的前三步*'
- en: '***Quicksort***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***快速排序***'
- en: While selection sort is easy to understand, software rarely uses it because
    it isn’t efficient. Each step requires us to process every number in the unsorted
    list, and for that effort all we get is one number in its correct position.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然选择排序很容易理解，但软件中很少使用它，因为它效率低下。每一步都需要处理未排序列表中的每个数字，而为了这些努力，我们仅仅得到一个数字排到了正确的位置。
- en: A better sorting method, called *quicksort*, partially orders all of the data
    processed during each pass, reducing later effort and time. Instead of scanning
    the entire list for the lowest number, we select a number in the list to be the
    *pivot*. We use the pivot to *partition* the list, dividing the list around the
    pivot. Numbers that are less than the pivot go to the front of the list, and those
    that are greater go to the back.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的排序方法叫做*快速排序*，它在每次遍历时部分排序所有处理过的数据，从而减少了后续的工作量和时间。我们不需要扫描整个列表来找到最小的数字，而是选择列表中的一个数字作为*基准*。我们利用基准来*分区*列表，将列表围绕基准进行划分。小于基准的数字移到列表前面，大于基准的数字移到列表后面。
- en: For this example we’ll use the same list of numbers used in the selection sort.
    [Figure 7-2](ch07.html#ch7fig2) shows the first step of partitioning. Different
    versions of quicksort select the pivot in different way; we’ll keep things simple
    and use the first number in the list, 47, as the pivot. The next number, 93, is
    copied to the end of the new list because it is greater than 47.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用与选择排序相同的数字列表。[图7-2](ch07.html#ch7fig2)显示了分区的第一步。快速排序的不同版本选择基准的方式不同；我们为了简便起见，选择列表中的第一个数字47作为基准。接下来的数字93由于大于47，因此被复制到新列表的末尾。
- en: '![image](graphics/f07-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-02.jpg)'
- en: '*Figure 7-2: The number 93 is more than the pivot, so it moves to the end of
    the new list.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：数字93大于基准，因此它移到新列表的末尾。*'
- en: In [Figure 7-3](ch07.html#ch7fig3), 56 is also greater than 47, so it’s copied
    to the next space on the end.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-3](ch07.html#ch7fig3)中，56同样大于47，因此它被复制到末尾的下一个位置。
- en: '![image](graphics/f07-03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-03.jpg)'
- en: '*Figure 7-3: The number 56 is more than the pivot, so it moves to the end of
    the new list.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：数字56大于基准，因此它移到新列表的末尾。*'
- en: In [Figure 7-4](ch07.html#ch7fig4), 33 is less than 47, so it’s copied to the
    front of the new list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-4](ch07.html#ch7fig4)中，33小于47，因此它被复制到新列表的前面。
- en: '![image](graphics/f07-04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-04.jpg)'
- en: '*Figure 7-4: The number 33 is less than the pivot, so it moves to the front
    of the new list.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：数字33小于基准，因此它移到新列表的前面。*'
- en: '[Figure 7-5](ch07.html#ch7fig5) combines the next five steps. Three of the
    remaining numbers go to the front of the list and two go to the back. This leaves
    a gap for one more number.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-5](ch07.html#ch7fig5)合并了接下来的五个步骤。剩余的三个数字移到列表前面，两个数字移到列表后面。这留下了一个空位，等待填充一个数字。'
- en: '![image](graphics/f07-05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-05.jpg)'
- en: '*Figure 7-5: The remaining numbers in the list are partitioned.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：列表中剩余的数字被分区。*'
- en: In [Figure 7-6](ch07.html#ch7fig6), this gap is filled with 47, the pivot. This
    completes the initial partitioning.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-6](ch07.html#ch7fig6)中，这个空位被47填充，即基准数字。这完成了初始的分区过程。
- en: '![image](graphics/f07-06.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-06.jpg)'
- en: '*Figure 7-6: The pivot fills the open space in the new list.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：基准填补了新列表中的空位。*'
- en: 'This new list isn’t sorted, but it’s in better shape than before. The pivot
    is in its correct sorted position, indicated by the shading. The first four numbers
    in the list are less than 47, and the last four are greater than 47\. A single
    partitioning does more than put one number in its correct place, like one step
    of a selection sort; it also divides the remaining numbers in the list into sublists,
    as shown in [Figure 7-7](ch07.html#ch7fig7). These sublists can be sorted independently.
    Sorting two shorter lists requires less effort than sorting one longer list. If
    you doubt this, consider an extreme case: would you rather sort 50 short lists
    of 2 numbers, or 1 long list of 100 numbers?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新列表尚未排序，但比之前的状态更好。枢轴已经放在了正确的排序位置，用阴影标识出来。列表中的前四个数字小于47，而最后四个数字大于47。一次分区不仅仅是将一个数字放到正确的位置，就像选择排序的一步；它还将剩余的数字划分成子列表，如[图7-7](ch07.html#ch7fig7)所示。这些子列表可以独立排序。排序两个较短的列表比排序一个较长的列表需要的努力要少。如果你对此有所怀疑，考虑一个极端的情况：你宁愿排序50个包含2个数字的短列表，还是一个包含100个数字的长列表？
- en: '![image](graphics/f07-07.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-07.jpg)'
- en: '*Figure 7-7: Partitioning has transformed the list into two separate, smaller
    lists that can be sorted independently.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：分区已经将列表转变为两个独立的小列表，可以独立排序。*'
- en: The two sublists are now independently partitioned. In [Figure 7-8](ch07.html#ch7fig8),
    the first number in the sublist, 33, becomes the new pivot and the four numbers
    of sublist 1 are partitioned. This puts 22 and 11 to the left of the 33, and 45
    to the right.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个子列表已经独立分区。在[图7-8](ch07.html#ch7fig8)中，子列表中的第一个数字33成为新的枢轴，子列表1中的四个数字被分区。这将22和11放在33的左侧，将45放在右侧。
- en: '![image](graphics/f07-08.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-08.jpg)'
- en: '*Figure 7-8: Partitioning sublist 1 of [Figure 7-7](ch07.html#ch7fig7)*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-8：对[图7-7](ch07.html#ch7fig7)的子列表1进行分区*'
- en: In [Figure 7-9](ch07.html#ch7fig9), sublist 2 is partitioned using 74 as a pivot.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-9](ch07.html#ch7fig9)中，子列表2使用74作为枢轴进行了分区。
- en: '![image](graphics/f07-09.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-09.jpg)'
- en: '*Figure 7-9: Partitioning sublist 2 of [Figure 7-7](ch07.html#ch7fig7)*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-9：对[图7-7](ch07.html#ch7fig7)的子列表2进行分区*'
- en: These partitions put both of their pivots in their correct sorted places in
    the list. The partitions also create four new sublists, as shown in [Figure 7-10](ch07.html#ch7fig10).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分区将它们的两个枢轴放在了正确的排序位置。这些分区还创建了四个新的子列表，如[图7-10](ch07.html#ch7fig10)所示。
- en: '![image](graphics/f07-10.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-10.jpg)'
- en: '*Figure 7-10: Now four sublists remain. Single-number sublists are trivial.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-10：现在剩下四个子列表。单一数字的子列表是琐碎的。*'
- en: Sublists 4 and 6 contain a single number, which means there’s nothing to partition.
    In [Figure 7-11](ch07.html#ch7fig11), sublists 3 and 5 are partitioned.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 子列表4和6包含单一数字，这意味着没有需要分区的内容。在[图7-11](ch07.html#ch7fig11)中，子列表3和5已被分区。
- en: '![image](graphics/f07-11.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-11.jpg)'
- en: '*Figure 7-11: Only two trivial sublists remain, which means the whole list
    is sorted.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-11：只剩下两个琐碎的子列表，意味着整个列表已排序。*'
- en: Now we have just two single-number sublists left, which means that the sort
    is complete.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只剩下两个单一数字的子列表，这意味着排序已经完成。
- en: In this example, the pivots evenly divided their partitions, but quicksort isn’t
    always so lucky. Sometimes the split is uneven, and in the worst case, the pivot
    could be the lowest or highest number in the list, which means the partitioning
    produces the same result as a step in a selection sort. But most partitions will
    be roughly even, which tends to result in a much faster sort.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，枢轴均匀地划分了它们的分区，但快速排序并不总是如此幸运。有时分裂是不均匀的，最糟糕的情况是枢轴可能是列表中最小或最大数字，这意味着分区的结果与选择排序的某一步相同。但大多数分区会大致均匀，这通常会导致更快的排序。
- en: More generally, quicksort *scales* much better than selection sort. For any
    sorting method, sorting time increases as the size of the data collection increases,
    but selection sort slows down much more than quicksort. Let’s say a particular
    computer can sort 10,000 records in around a second using either method. On the
    same computer, a selection sort of 1,000,000 records would take nearly 3 hours,
    while a quicksort would take only about 11 minutes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般来说，快速排序比选择排序*扩展*得更好。对于任何排序方法，排序时间会随着数据集合大小的增加而增加，但选择排序的速度下降比快速排序要快得多。假设一台特定的计算机可以用两种方法在大约一秒钟内排序10,000条记录。在同一台计算机上，选择排序1,000,000条记录大约需要3小时，而快速排序只需要约11分钟。
- en: '**Binary Search**'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二分查找**'
- en: When data is in order, software can find a particular record easily. One simple
    search method for ordered data is *binary search*. The word *binary* in this case
    doesn’t refer to binary numbers, but to choosing between two alternatives.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据是有序时，软件可以轻松找到特定的记录。对于有序数据，一种简单的查找方法是 *二分查找*。在这里，*二分*一词并不是指二进制数字，而是指在两种选择之间做出决策。
- en: '[Figure 7-12](ch07.html#ch7fig12) shows binary search in action. The record
    we want has a key of 48\. Initially, all we know is that the data in the collection
    is ordered on our key, so the record could appear anywhere. In step 1, we examine
    the record in the middle of the collection. If this record had a key of 48, we
    would we be done, but this is unlikely. However, because this record has a key
    of 62, which is larger than 48, we know that the desired record must appear among
    the first seven records. Thus, examining one record has eliminated not just that
    record from consideration, but also the seven records that appear later in the
    collection.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-12](ch07.html#ch7fig12) 展示了二分查找的实际操作。我们要查找的记录的键值为 48。最初，我们知道的是集合中的数据按照键值排序，因此记录可能出现在任何地方。在第一步中，我们检查集合中间的记录。如果这条记录的键值为
    48，那我们就完成了查找，但这不太可能。然而，由于这条记录的键值为 62，超过了 48，我们知道目标记录必须出现在前七条记录中。因此，检查这一条记录不仅排除了它本身，也排除了集合中之后的七条记录。'
- en: In step 2, we examine the fourth record, the midpoint of the remaining seven
    records. This record has a key of 23, which is lower than 48\. Therefore the desired
    record must be in the three records between 23 and 62.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们检查第四条记录，它是剩余七条记录的中点。这条记录的键值为 23，低于 48。因此，目标记录必须出现在 23 和 62 之间的三条记录中。
- en: In step 3, we examine the middle of these remaining three records, which has
    a key of 47\. This tells us the desired record must be the one record between
    47 and 62\. If that record did not have a key of 48, it would mean the collection
    did not include a record with that key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们检查这三条记录中的中间记录，它的键值为 47。这告诉我们目标记录一定是 47 和 62 之间的那一条。如果那条记录的键值不是 48，那就意味着集合中没有键值为
    48 的记录。
- en: '![image](graphics/f07-12.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f07-12.jpg)'
- en: '*Figure 7-12: Binary search taking four steps to find a particular record in
    a collection of size 15*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：二分查找通过四步在 15 条记录的集合中找到特定记录*'
- en: Each step in a binary search eliminates half of the records from consideration,
    which means binary search scales fantastically well. With a sequential search,
    doubling the size of a data collection doubles the time needed for the average
    search. With binary search, doubling the number of records requires just one more
    step. If we start with 31 records, for example, after examining the middle record,
    either we get lucky and find the desired record, or we find out whether the desired
    record is in the first or last 15 records. Either way we would now have only 15
    records left to search, putting us back where we started in [Figure 7-12](ch07.html#ch7fig12).
    For huge data collections, the difference between binary and sequential search
    is dramatic. A sequential search of 1,000,000 records will examine 500,000 records
    on average, while a binary search of 1,000,000 records will examine no more than
    20.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步二分查找都会将一半的记录从考虑范围中排除，这意味着二分查找的扩展性非常好。对于顺序查找来说，数据集合大小翻倍意味着平均查找所需时间也会翻倍。而对于二分查找来说，记录数翻倍只需要多一步。例如，如果我们从
    31 条记录开始，检查中间记录后，要么我们运气好找到了目标记录，要么我们知道目标记录是在前 15 条记录还是后 15 条记录。无论哪种情况，我们现在只需要继续查找剩下的
    15 条记录，这就相当于回到了 [图 7-12](ch07.html#ch7fig12) 所示的状态。对于庞大的数据集合，二分查找与顺序查找之间的差距是巨大的。顺序查找
    1,000,000 条记录平均会检查 500,000 条记录，而二分查找 1,000,000 条记录最多只需检查 20 条。
- en: '**Indexing**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**索引**'
- en: To keep the figures simple, our examples to this point have used just record
    keys. In practice, though, the rest of the record has to be stored somewhere,
    and this can cause problems. To see why, we have to understand the choice software
    faces when allocating storage space for data, whether in main memory, on a hard
    drive, or anywhere else.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，我们到目前为止使用的仅仅是记录的键值。然而，实际上，记录的其余部分必须存储在某个地方，这可能会引发问题。为了理解原因，我们需要明白在为数据分配存储空间时，软件所面临的选择，无论是在主存、硬盘，还是其他地方。
- en: '*Fixed-size* storage allocation assigns each record the same amount of space
    and is used for data that is either always the same size or has a small maximum
    size. Credit card numbers, for example, are always 16 digits. The names of credit
    card owners, on the other hand, vary in size, but there are only so many letters
    that will fit on the card. Both card numbers and card-holder names could be stored
    in a fixed number of bytes. In [Figure 7-13](ch07.html#ch7fig13), the maximum
    size of a last name is 15 characters, just long enough for Hammond-Hammond. The
    other names are shorter, resulting in wasted bytes, shown as shaded squares. Because
    the space needed to store a name is small, though, this wasted space is of no
    great concern.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*固定大小*存储分配为每个记录分配相同的空间，适用于大小始终相同或有小的最大大小的数据。例如，信用卡号码始终是 16 位数字。另一方面，信用卡持有人的名字长度不一，但卡片上只能容纳有限数量的字母。信用卡号和持卡人姓名都可以存储在固定字节数中。在[图
    7-13](ch07.html#ch7fig13)中，姓氏的最大长度为 15 个字符，正好够 "Hammond-Hammond"。其他名字较短，导致浪费的字节如阴影方块所示。然而，由于存储名字所需的空间很小，这些浪费的空间并不构成大问题。'
- en: '![image](graphics/f07-13.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-13.jpg)'
- en: '*Figure 7-13: Fixed allocation of storage results in wasted space*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：固定存储分配导致空间浪费*'
- en: '*Variable-size* storage allocation exactly fits the data. Consider a collection
    of MP3 files. Roughly speaking, the longer the song, the larger the MP3 file.
    A short pop song might be 3 or 4MB, while a progressive-rock epic might be as
    large as 20MB. We wouldn’t want to store song data in fixed space because this
    would waste too much space for shorter songs, and this would limit the length
    of a song. Instead, the data should be stored in just as much space as needed.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变大小*存储分配精确适应数据的大小。考虑一组 MP3 文件。粗略地说，歌曲越长，MP3 文件就越大。一首短小的流行歌曲可能是 3 或 4MB，而一首渐进摇滚史诗可能大到
    20MB。我们不希望将歌曲数据存储在固定大小的空间中，因为这样会浪费过多空间用于较短的歌曲，同时也会限制歌曲的长度。相反，数据应该存储在正好满足需求的空间中。'
- en: Variable-size storage allocation uses space efficiently, but fixed-size storage
    allocation is required for software to use efficient search methods. When all
    the records in a collection are the same size, software can quickly find a record
    in a particular position.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可变大小存储分配高效利用空间，但软件需要固定大小存储分配来使用高效的查找方法。当集合中的所有记录大小相同时，软件可以快速找到某个特定位置的记录。
- en: This is because storage locations are identified by numerical *addresses*. Every
    byte in digital storage—whether in a computer’s main memory, or on a flash drive
    or hard drive—can be precisely located by its address. If a computer has 8GB of
    main memory, for example, those bytes are numbered from zero to just over eight
    trillion. Collections of fixed-size records are stored contiguously, which makes
    finding a record’s address simple. Suppose a collection has 100 records, each
    20 bytes in size, and the collection begins at address 1,000\. That puts the first
    record at address 1,000, the second at 1,020, the third at 1,040, and so on. We
    can calculate the address of any record by multiplying its position number by
    20 and adding the result to 1,000\. In this way, software can quickly locate any
    record in any collection of fixed-size records.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为存储位置是通过数字 *地址* 来标识的。数字存储中的每一个字节——无论是在计算机的主内存中，还是在闪存驱动器或硬盘上——都可以通过其地址精确定位。例如，如果一台计算机有
    8GB 的主内存，那么这些字节的编号从零开始，直到超过 8 万亿。固定大小记录的集合是连续存储的，这使得查找记录的地址变得简单。假设一个集合有 100 个记录，每个记录
    20 字节，且该集合从地址 1,000 开始。这意味着第一个记录位于地址 1,000，第二个记录位于地址 1,020，第三个记录位于 1,040，以此类推。我们可以通过将记录的位置编号乘以
    20 并将结果加到 1,000 来计算任何记录的地址。这样，软件就能快速定位任何固定大小记录集合中的记录。
- en: Finding records quickly is essential for a method like binary search. Without
    fixed-size records, the only way to find a record in a particular position is
    to start from the beginning of the data collection and count the records. That’s
    just a sequential search, and defeats the point.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查找记录对于像二分查找这样的算法至关重要。如果没有固定大小的记录，查找某个特定位置的记录唯一的方法是从数据集的开始处开始，并逐一计算记录。这就是顺序查找，完全违背了高效查找的初衷。
- en: Choosing between fixed-size and variable-size storage allocation means choosing
    between efficient search and efficient storage. However, a technique called *indexing*
    gives us both. Indexing separates the keys from the rest of the records, much
    as a library card catalog allows patrons to search for books on cards before ultimately
    retrieving the books from the shelves.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择固定大小或可变大小的存储分配意味着在高效搜索和高效存储之间做出选择。然而，一种叫做*索引*的技术使我们能够同时拥有这两者。索引将键与其余记录分开，就像图书馆卡片目录使读者可以先在卡片上查找书籍，再从书架上取书一样。
- en: An index is a table of record keys and addresses. The addresses themselves are
    stored as binary numbers with a fixed number of bits. For example, when Microsoft
    releases versions of Windows in “32-bit” and “64-bit” editions, those bit counts
    refer to the size of the addresses for main memory. Because the addresses are
    a fixed size, we can store the addresses and keys together in an index of fixed-size
    records that can be searched efficiently using a method like binary search. The
    rest of each record’s data is stored in a variable-size allocation. This produces
    a data collection that is efficient for storage *and* searching.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是记录键和值地址的表。地址本身作为二进制数存储，具有固定的位数。例如，当微软发布“32位”和“64位”版本的Windows时，这些位数指的是主内存地址的大小。由于地址是固定大小的，我们可以将地址和键一起存储在一个固定大小的索引记录中，并使用类似二分查找的方法高效地进行搜索。每条记录的其余数据存储在一个可变大小的分配区域中。这种方式产生的数据集合在存储*和*搜索上都很高效。
- en: '[Figure 7-14](ch07.html#ch7fig14) shows an indexed data collection of four
    songs. On the left, the index contains the song titles and the addresses for the
    remaining data of each song, such as the artist name and the encoded music. On
    the right is a block of memory cells numbered from 1 to 400\. The arrows point
    to each address.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-14](ch07.html#ch7fig14)展示了一个包含四首歌曲的索引数据集合。左侧是索引，包含每首歌的歌名和其余数据的地址，如艺术家名称和编码的音乐。右侧是一个从1到400编号的内存单元块。箭头指向每个地址。'
- en: As shown in the example, this split data allocation allows each record to use
    as much or as little space as needed. It even allows the index and remaining data
    to be on different storage devices. For example, the index might be kept in a
    computer’s fast main memory, while the encoded music data is left on its relatively
    slow hard drive. Because only the index is needed for search, such an arrangement
    allows for efficient search while using the minimum amount of main memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，这种分离的数据分配方式允许每条记录根据需要使用多大或多小的空间。它甚至允许索引和剩余数据存储在不同的存储设备上。例如，索引可能保存在计算机的快速主内存中，而编码的音乐数据则存储在相对较慢的硬盘上。由于只需要索引进行搜索，这种安排使得在使用最少主内存的情况下实现高效搜索。
- en: '![image](graphics/f07-14.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-14.jpg)'
- en: '*Figure 7-14: An indexed data collection of digital music*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：数字音乐的索引数据集合*'
- en: We can also have multiple indexes for the same data collection. The arrangement
    in [Figure 7-14](ch07.html#ch7fig14) allows individual songs to be quickly located
    by song title, but doesn’t help us search for a song based on artist name or album
    title. Data collections can have multiple indexes for different search criteria,
    and because the main record data is simply referenced by an address, having multiple
    indexes doesn’t greatly affect the total storage requirements for the data collection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为同一数据集合设置多个索引。[图 7-14](ch07.html#ch7fig14)中的排列方式允许通过歌名快速定位单独的歌曲，但对于根据艺术家名称或专辑标题搜索歌曲没有帮助。数据集合可以有多个索引以满足不同的搜索标准，并且因为主记录数据只是通过地址进行引用，拥有多个索引并不会显著增加数据集合的总存储需求。
- en: '**Hashing**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**哈希**'
- en: Although ordered data is required for efficient searching, sorting data takes
    time. So far we’ve discussed sorting as though data collections need to be sorted
    just once. Sometimes that is the case; for example, a word processor needs a list
    of correctly spelled words for spell checking, but that list is created once and
    supplied as part of the application. A spellcheck word list is a *static* data
    collection, one that changes infrequently. However, many of the collections we
    search are *dynamic*—records are frequently added or removed. Because efficient
    searching requires ordered data, collections must be re-sorted following each
    addition or removal. When insertions and deletions are common, the time spent
    re-sorting the data collection can negate the benefit of a faster search. In such
    cases, it may be better to structure the data to facilitate frequent changes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有序数据对高效搜索是必需的，但排序数据需要时间。到目前为止，我们讨论排序时，仿佛数据集合只需要排序一次。有时确实如此；例如，文字处理程序需要一个正确拼写单词的列表用于拼写检查，但该列表只需创建一次，并作为应用程序的一部分提供。拼写检查单词列表是一个
    *静态* 数据集合，很少发生变化。然而，我们搜索的许多集合是 *动态的*——记录会频繁地添加或删除。由于高效的搜索需要有序数据，集合必须在每次添加或删除后重新排序。当插入和删除操作很频繁时，重新排序数据集合所花费的时间可能会抵消搜索速度的提升。在这种情况下，更好的做法是构建数据结构，以便频繁的变更操作。
- en: One data structure that eases additions and removals of records involves hash
    functions, which were introduced in [Chapter 2](ch02.html#ch02). For this example
    let’s imagine a hash function that produces a mere 3-bit hash, equivalent to a
    decimal number in the range of 0 to 7\. We can use this to store records in a
    *hash table* with slots for 8 records. A *slot* is a place where a record could
    be stored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简化记录添加和删除的数据结构涉及哈希函数，它们在[第 2 章](ch02.html#ch02)中有所介绍。以这个例子为例，我们可以想象一个哈希函数，它生成一个仅为
    3 位的哈希，相当于 0 到 7 之间的十进制数。我们可以利用它在一个 *哈希表* 中存储记录，哈希表有 8 个槽位。*槽位*是一个可能存放记录的地方。
- en: To store a record in the hash table, we hash the record’s key to determine which
    slot to use. Suppose we are storing MP3 files with song titles as the keys. Four
    titles and their associated hash codes are shown in [Table 7-1](ch07.html#ch7tab1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一条记录存储在哈希表中，我们对记录的键进行哈希，以确定使用哪个槽位。假设我们正在存储带有歌曲标题作为键的 MP3 文件。[表 7-1](ch07.html#ch7tab1)
    显示了四个标题及其相关的哈希码。
- en: '**Table 7-1:** Hash Codes for Sample Song Titles'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 示例歌曲标题的哈希码'
- en: '| **Song title** | **Hash code** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **歌曲标题** | **哈希码** |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Life on Mars | 6 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Life on Mars | 6 |'
- en: '| Nite Flights | 4 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Nite Flights | 4 |'
- en: '| Surrender | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| Surrender | 1 |'
- en: '| The True Wheel | 4 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| The True Wheel | 4 |'
- en: '[Figure 7-15](ch07.html#ch7fig15) shows the hash table after the insertion
    of the first three songs from [Table 7-1](ch07.html#ch7tab1). The first column
    in each record is a bit, which is 1 if the slot is in use and 0 if not. The second
    column is the title, and the third column holds the address of the remaining data.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-15](ch07.html#ch7fig15) 展示了插入 [表 7-1](ch07.html#ch7tab1) 中前三首歌曲后的哈希表。每条记录的第一列是一个比特，如果槽位在使用中则为
    1，如果不在使用中则为 0。第二列是标题，第三列保存剩余数据的地址。'
- en: '![image](graphics/f07-15.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-15.jpg)'
- en: '*Figure 7-15: An eight-slot hash table*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：一个八槽哈希表*'
- en: The beauty of a hash table is that a search doesn’t really require searching.
    We just run the key through the hash function and the result tells us where the
    record should be. If there’s no record in that slot, we know right away that the
    collection doesn’t contain a record with that key. Even better, hash tables avoid
    the effort of sorting. This makes a hash table an excellent choice for a collection
    with frequent additions and deletions of records.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的优点是搜索实际上并不需要进行查找。我们只需通过哈希函数处理键，结果会告诉我们记录应该存放在哪里。如果该槽位没有记录，我们立即知道集合中没有该键的记录。更好的是，哈希表避免了排序的工作量。这使得哈希表成为一个非常适合频繁添加和删除记录的集合的选择。
- en: However, we haven’t inserted the fourth song in the list. The song title “The
    True Wheel” hashes to 4, the same number as “Nite Flights.” As you may remember
    from [Chapter 2](ch02.html#ch02), a hash function is not guaranteed to produce
    a different hash value for every input, and indeed, some matching hash values,
    or *collisions*, are inevitable. Since we can put only one record in a slot, we
    need a rule for handling collisions. The simplest rule is to use the first empty
    slot after the collision point. Because slot 4 is already occupied with “Nite
    Flights,” we would place “The True Wheel” in the next open slot, which is slot
    5, as shown in [Figure 7-16](ch07.html#ch7fig16).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并没有插入列表中的第四首歌曲。歌曲标题“The True Wheel”哈希到4，和“Nite Flights”相同。如你在[第2章](ch02.html#ch02)中所记得的，哈希函数并不能保证对每个输入产生不同的哈希值，事实上，一些匹配的哈希值，或者*碰撞*，是不可避免的。由于每个插槽只能放置一个记录，我们需要一个处理碰撞的规则。最简单的规则是使用碰撞点之后的第一个空插槽。因为插槽4已经被“Nite
    Flights”占用，所以我们会将“The True Wheel”放入下一个空插槽，即插槽5，如[图7-16](ch07.html#ch7fig16)所示。
- en: '![image](graphics/f07-16.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-16.jpg)'
- en: '*Figure 7-16: Resolving a collision. The second song that hashes to 4 is placed
    in the next empty slot, which is slot 5.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-16：解决碰撞问题。第二首哈希到4的歌曲被放入下一个空插槽，即插槽5。*'
- en: This handles the collision problem, but it complicates the use of the hash table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了碰撞问题，但它使得哈希表的使用变得更加复杂。
- en: With this collision rule in place, finding a record is no longer a one-step
    process. Each search still starts at the slot indicated by the hash code, but
    then checks the slots one by one until it finds the matching song title. If the
    search reaches an empty slot, the song isn’t in the collection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个碰撞规则，查找记录不再是一个一步的过程。每次搜索仍然从哈希码所指示的插槽开始，但随后会依次检查插槽，直到找到匹配的歌曲标题。如果搜索达到一个空插槽，则说明歌曲不在集合中。
- en: Collisions can also cause records to be stored far from the position indicated
    by the hash code. For example, if a title with a hash code of 5 is inserted into
    the table shown in [Figure 7-16](ch07.html#ch7fig16), even though no previous
    song title has hashed to 5, the slot is already filled by “The True Wheel,” and
    the new song would move all the way to slot 7\. As a hash table fills, these situations
    become more common, degrading search performance; in effect, some hash table searches
    become miniature sequential searches.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞还可能导致记录被存储在与哈希码所指示的位置相距较远的地方。例如，如果插入一个哈希码为5的标题到[图7-16](ch07.html#ch7fig16)所示的表中，即使之前没有任何歌曲标题哈希到5，插槽已经被“The
    True Wheel”占用，因此新歌曲会移动到插槽7。随着哈希表的填充，这种情况变得更加常见，导致搜索性能下降；实际上，一些哈希表搜索变成了小型的顺序搜索。
- en: Collisions also complicate the deletion of records. Suppose “Nite Flights” is
    removed from the hash table of [Figure 7-16](ch07.html#ch7fig16). The obvious
    way to remove a record is just to mark the slot “empty” again, but that doesn’t
    work. To see why, remember that the song title “The True Wheel” hashed to 4, and
    the song was stored in slot 5 only because slot 4 was occupied at the time. A
    search for “The True Wheel” will begin at slot 4 as indicated by the hash code,
    find the slot empty, and end the search unsuccessfully. The song is still in the
    index table, but can’t be found by a hash search.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞还使得记录的删除变得复杂。假设“ Nite Flights”从[图7-16](ch07.html#ch7fig16)中的哈希表中删除。删除记录的显而易见的方法是将插槽标记为“空”，但那样并不奏效。为了理解原因，请记住，歌曲标题“The
    True Wheel”曾哈希到4，并且该歌曲被存储在插槽5中，只有当时插槽4被占用。搜索“The True Wheel”将从插槽4开始，如哈希码所示，找到插槽为空并结束搜索，无法找到该歌曲。该歌曲仍然在索引表中，但通过哈希搜索无法找到。
- en: To avoid this problem, we can remove the song data but keep the slot marked
    as occupied, as shown in [Figure 7-17](ch07.html#ch7fig17).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们可以删除歌曲数据，但保留插槽标记为已占用，如[图7-17](ch07.html#ch7fig17)所示。
- en: Slot 4 is now what is called a *tombstone*. By leaving the slot marked as occupied
    while deleting the data, we ensure that searches still work. However, tombstones
    waste space. Furthermore, because the table never really frees any record slots,
    the performance issues of congestion remain.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽4现在被称为*墓碑*。通过在删除数据时将插槽标记为已占用，我们确保搜索仍然有效。然而，墓碑会浪费空间。此外，由于表格实际上并没有释放任何记录插槽，因此拥塞的性能问题依然存在。
- en: For these reasons, hash tables are periodically *rehashed*. Once a certain percentage
    of the slots in a table are occupied, a new, larger table is created, and each
    key in the original table is hashed with a new hash function, producing a fresh,
    sparsely populated table without any tombstones.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，哈希表会定期进行*重新哈希*。当表中的某个槽位被占满到一定比例时，便会创建一个新的、更大的表，并且原表中的每个键值都会使用新的哈希函数重新进行哈希，生成一个新的、稀疏的表，并且不再包含任何“墓碑”条目。
- en: '![image](graphics/f07-17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-17.jpg)'
- en: '*Figure 7-17: Leaving slot 4 marked as occupied after deletion of its data*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：删除其数据后，保持槽 4 标记为占用*'
- en: '**Web Search**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网页搜索**'
- en: All of the techniques shown in this chapter are needed for efficiently searching
    large data collections, and no collection is larger than the Web. A search engine
    such as Google depends upon a vast index, where the keys are search terms, the
    addresses are URLs, and the web pages are the records. The size of the Google
    index is estimated at around 100 petabytes, or 100,000,000 gigabytes. To find
    something in an index this large requires all of the best search techniques. Although
    these techniques help illustrate how an index this large could be searched, they
    don’t tell us how the index was created in the first place.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有技术都需要高效地搜索大型数据集，而没有比网络更大的数据集了。像 Google 这样的搜索引擎依赖于庞大的索引，其中的关键字是搜索词，地址是
    URL，网页是记录。Google 索引的大小估计约为 100 PB（拍字节），即 100,000,000 GB。要在如此庞大的索引中找到某个内容，必须使用所有最佳的搜索技术。尽管这些技术有助于说明如何搜索如此庞大的索引，但它们并没有告诉我们这个索引最初是如何创建的。
- en: Search engines use *robots*, programs that run without direct human intervention,
    to build their indexes. The robots crawl all over the Web. Starting at some particular
    web page, they make a list of all the links on that page. Those linked pages are
    then processed to find links to other pages, and so on. Eventually the robot has
    links to most of the content on the Web.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎使用*机器人*，即无需直接人工干预的程序，来建立它们的索引。这些机器人会遍布整个网络。从某个特定的网页开始，它们会列出该页面上的所有链接。然后，这些链接的页面会被处理，以寻找其他页面的链接，以此类推。最终，机器人会获取到网络上大部分的内容链接。
- en: Some content, though, is more difficult to locate. Some pages can’t be reached
    from a site’s home page but are instead found through the site’s own search engine.
    A news site, for example, may not link to older articles but does provide a local
    search for its archives. This unlinked but valuable content is known as the *deep
    web*. Incorporating deep web content into a search engine index usually requires
    some assistance from the site. Site managers have several ways to provide web-crawling
    robots a “table of contents” for all the pages on the site, such as a document
    called a *Sitemap*. This document is named after the *site map* page some sites
    provide for users to quickly find the content they are looking for, but has a
    specific format that’s easy for robots to process. Sitemaps keep search engines
    updated with content changes and are especially useful for sites with deep content
    that would otherwise be left out of search engine indexes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些内容更难以定位。有些页面无法从网站的主页访问，而是通过网站自己的搜索引擎找到。例如，新闻网站可能不会链接到较老的文章，但提供了本地搜索功能来查找其存档。这些未链接但有价值的内容被称为*深网*。将深网内容纳入搜索引擎索引通常需要网站的帮助。网站管理员可以通过几种方式为网页爬虫提供“目录”，例如一个叫做*Sitemap*的文档。这个文档得名于一些网站提供给用户快速找到所需内容的*网站地图*页面，但它有一个特定的格式，便于机器人处理。网站地图帮助搜索引擎及时更新内容变化，尤其对那些拥有大量深层内容的网站特别有用，这些内容否则可能会被排除在搜索引擎索引之外。
- en: '***Ranking Results***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***排名结果***'
- en: As robots gather pages, search engines mine the pages for keywords, counting
    how often each keyword appears on each page. Early search engines employed little
    more than a list of keywords along with their page counts. If you searched for
    *cake*, the page where *cake* most often appeared would be at the top of the returned
    list. That’s logical enough, but a mere word count doesn’t produce what we now
    consider to be good search results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器人收集页面时，搜索引擎会挖掘页面中的关键词，并统计每个关键词在每个页面上出现的频率。早期的搜索引擎只是简单地列出关键词及其页面计数。如果你搜索*蛋糕*，出现*蛋糕*关键词频率最高的页面将排在返回结果的最前面。这看起来很合逻辑，但仅仅根据字数统计并不能提供我们现在认为的优秀搜索结果。
- en: The first problem is that it’s too easy for someone to exploit the system for
    personal gain. Suppose the operator of a site selling knockoff pharmaceuticals
    wants to get a lot of traffic and doesn’t care how it’s done. When the operator
    discovers that legions of people are searching for *omelette recipe*, the operator
    might put those words on the home page as many times as possible, even hiding
    the words in the behind-the-scenes formatting code. As a result, the site might
    be among the first returned on searches for omelette recipes, even though no such
    recipes appear on the site. Word counts do not guarantee a match between search
    terms and content.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是，系统太容易被某些人利用来谋取个人利益。假设某个售卖假冒药品的网站运营者想要获取大量流量，而不在乎如何实现这一目标。当运营者发现大批人正在搜索*煎蛋卷食谱*时，他可能会尽可能多地将这些词语放在首页上，甚至将这些词语隐藏在后台的格式化代码中。结果，网站可能会出现在煎蛋卷食谱的搜索结果的前几名，尽管网站上根本没有这类食谱。词频并不保证搜索词和内容之间的匹配。
- en: Another website operator might build a site that is legitimately about omelettes,
    but it’s filled with content stolen from Wikipedia, in order to generate revenue
    from ads about a zero-cholesterol egg substitute. In this case, the word count
    correctly connects the search term to matching content, but the quality of the
    content is poor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个网站运营者可能会建立一个真正与煎蛋卷相关的网站，但网站内容充满了从维基百科偷来的内容，以便通过广告获得零胆固醇蛋替代品的收入。在这种情况下，词频确实将搜索词与匹配内容联系起来，但内容质量很差。
- en: The underlying issue is that the websites are self-reporting the nature and
    the quality of their content. What’s missing is the opinion of a disinterested
    viewer. Ideally, search engines could employ an army of reviewers to determine
    what pages are about and how well they cover their chosen topics. The Web is so
    vast and ever-changing, though, that this is a practical impossibility.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根本的问题在于，网站自我报告其内容的性质和质量。缺失的是一个无偏的观众的意见。理想情况下，搜索引擎可以雇用一支审查员队伍来确定页面的主题以及它们覆盖话题的质量。然而，由于网络庞大且不断变化，这几乎是不可能的。
- en: Instead, search engines rely on the opinions of other websites. They acquire
    these opinions in the form of *inbound links*. The number of links to a particular
    page is a good metric for how that page is regarded by the online community. In
    [Figure 7-18](ch07.html#ch7fig18), page C has four inbound links, page D has none,
    and each of the others has one. On this basis alone, page C appears to be the
    most valued resource, while A, B, and E appear equally useful.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，搜索引擎依赖其他网站的意见。这些意见通过*外部链接*的形式获取。指向某个页面的链接数量是衡量该页面在在线社区中被看作多么有价值的一个良好指标。在[图
    7-18](ch07.html#ch7fig18)中，C页有四个外链，D页没有外链，其他页面每个都有一个。仅凭这一点，C页看起来是最有价值的资源，而A、B和E则显得同样有用。
- en: '![image](graphics/f07-18.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-18.jpg)'
- en: '*Figure 7-18: The number of links pointing to a page is one factor used by
    search engines to determine ranking.*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：指向页面的链接数量是搜索引擎用于确定排名的一个因素。*'
- en: There’s more to the story though. A page with a high inbound link count grants
    more points to the pages it links to. In the previous figure, three pages have
    only one inbound link, but the quality of each link is different. Page E is linked
    from page C, which has a high inbound link count, while pages A and B are linked
    only from each other. Factoring the quality of each link into the link count helps
    to foil *link farming*, in which large numbers of pointless websites are created,
    often through free host services, for the purpose of increasing a target site’s
    inbound link count.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，故事还不止于此。具有大量外链的页面会为它所链接的页面加分。在前面的图中，三页只有一个外链，但每个链接的质量不同。E页是从C页链接过来的，而C页有很多外链；而A页和B页只是相互链接。将每个链接的质量考虑到链接计数中，有助于打破*链接农场*，即大量无意义的网站通过免费的托管服务创建，目的是增加目标网站的外链数。
- en: In effect, this turns the Web into a collection of self-organized expert communities.
    When a number of well-regarded cooking sites begin linking to a new omelette-focused
    site, which in turn links back to omelette-related content in the established
    sites, the new site is inducted into the online cooking community. Thereafter,
    the new site’s links count as much as the older, established sites.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这将网络转变为一系列自组织的专家社区。当多个受人尊敬的烹饪网站开始链接到一个新的煎蛋卷网站，而该网站又反向链接到已建立网站中的煎蛋卷相关内容时，新网站便被纳入在线烹饪社区。此后，新网站的链接与老牌网站的链接同样重要。
- en: '***Using the Index Effectively***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***有效使用索引***'
- en: While building the index is the bulk of the work of making a search engine,
    how the index is used during a search is just as important. Good search results
    require attention to detail.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然建立索引是搜索引擎工作的主要部分，但索引在搜索过程中如何使用同样重要。良好的搜索结果需要关注细节。
- en: For one thing, a search engine cannot merely use the supplied search terms as
    keywords. Consider the differences in word forms. You might type *frozen rain*
    in a search box, but most pages with relevant information use the form *freezing
    rain*. By linking together different forms of keywords in its index, a search
    engine can maximize the usefulness of results. This idea applies to synonymous
    terms as well. Because the words *insomnia* and *sleeplessness* mean the same
    thing, searching for either term produces similar results, even though some pages
    predominantly use one word or the other. For example, the Wikipedia article on
    insomnia appears in the first few results for either search term, even though,
    at the time of this writing, the word *sleeplessness* appears only twice in the
    article, while the word *insomnia* appears over 200 times.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，搜索引擎不能仅仅将提供的搜索词作为关键词。考虑到词形的差异，你可能会在搜索框中输入*frozen rain*，但大多数相关信息的页面使用的是*frozen
    rain*的变体形式*freezing rain*。通过将不同形式的关键词在其索引中关联起来，搜索引擎能够最大化搜索结果的有效性。这个思路同样适用于同义词。因为*insomnia*和*sleeplessness*的意思相同，搜索任何一个词都会产生相似的结果，尽管有些页面主要使用其中一个词。例如，关于失眠的维基百科条目在这两个搜索词的前几个结果中都会出现，尽管在撰写本文时，*sleeplessness*一词仅出现在文章中两次，而*insomnia*一词出现了200多次。
- en: The results from these search terms are not identical, though. A search for
    *insomnia* will also include links to the 2002 film *Insomnia*, but these links
    aren’t returned by a search for *sleeplessness*. That result makes sense—presumably,
    no one searching for the film would have entered a synonym of the film’s title—but
    how can a search engine know the two terms are linked in some ways but not others?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些搜索词的结果并不完全相同。搜索*insomnia*时还会出现2002年电影《*Insomnia*》的链接，但搜索*sleeplessness*时这些链接却不会出现。这一结果是合理的——可以推测，搜索电影的人不会使用电影标题的同义词——但是，搜索引擎怎么知道这两个词在某些情况下相关，而在另一些情况下则无关呢？
- en: Tracking how search terms are combined can yield valuable clues. If searchers
    frequently add the terms *movie* or *film* to the term *insomnia*, then searches
    for just *insomnia* may indicate someone interested in the film and not the medical
    condition.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪搜索词的组合可以提供宝贵的线索。如果搜索者经常在*insomnia*一词后加上*movie*或*film*等词语，那么仅搜索*insomnia*可能表明搜索者对电影感兴趣，而非对这一医学问题的关注。
- en: Furthermore, the links on a search results page are not actually direct links
    to the listed pages. Instead, they are *pass-through links*. For example, if you
    search Google for *insomnia*, then click on the link for the Wikipedia entry,
    you’ll first be taken to the google.com server, which will then redirect you to
    [wikipedia.org](http://wikipedia.org). Google tracks which result you selected,
    and this data, collected from countless users over time, allows Google to fine-tune
    the results, keeping the links that users actually find useful near the top.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，搜索结果页面上的链接实际上并不是直接链接到列出的页面。相反，它们是*跳转链接*。例如，如果你在谷歌搜索*insomnia*，然后点击维基百科条目的链接，你首先会被带到google.com服务器，然后再被重定向到[wikipedia.org](http://wikipedia.org)。谷歌会追踪你选择了哪个结果，且这些数据是从无数用户身上收集的，能够帮助谷歌不断优化搜索结果，将用户真正觉得有用的链接排在前面。
- en: Search engines can also make use of the location of the person searching. For
    example, when you search for *smiley’s pizza* while you’re standing in a particular
    town, the search engine appends the town’s name to the search, so that the results
    are localized, instead of returning the websites of the most popular pizzerias
    with that name in the entire world.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎还可以利用搜索者的位置。例如，当你在某个城市搜索*smiley’s pizza*时，搜索引擎会将该城市的名称附加到搜索中，从而使结果本地化，而不是返回全球范围内最受欢迎的同名披萨店网站。
- en: '**What’s Next for Web Search**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**下一步：网络搜索的未来**'
- en: As impressive as current web search capabilities are, there’s still room for
    improvement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当前的网络搜索能力令人印象深刻，但仍有提升空间。
- en: For example, images provide unique challenges for search engines. Currently,
    image files are indexed based on accompanying text. A search engine might gather
    clues from an image’s filename, or make educated guesses based on the text surrounding
    the image on the page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图像为搜索引擎提供了独特的挑战。目前，图像文件是根据附带的文本进行索引的。搜索引擎可能会根据图像文件名收集线索，或者根据页面上图像周围的文本进行推测。
- en: We can soon expect the use of *computer vision* techniques in web indexes. Such
    software techniques transform an image into a description of the image. In some
    ways this is the reverse of the graphics techniques described in [Chapters 4](ch04.html#ch04)
    and [5](ch05.html#ch05), where mathematical models were rendered into images.
    With computer vision, images are simplified into mathematical descriptions that
    are then categorized by pattern. Such software is currently used in self-governing
    robots, so that they can recognize an object they have been sent to retrieve.
    Future search engines may process the Web’s images using these techniques, identifying
    both general subjects (“clear sky,” “kittens”) and specific subjects (“Eiffel
    Tower,” “Abraham Lincoln”) within the images.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就能看到*计算机视觉*技术在网页索引中的应用。这种软件技术将图像转化为对图像的描述。从某种程度上来说，这与[第4章](ch04.html#ch04)和[第5章](ch05.html#ch05)中描述的图形技术正好相反，后者是将数学模型转化为图像。而计算机视觉则是将图像简化为数学描述，然后按模式进行分类。这样的软件目前已在自我管理的机器人中使用，以便它们能够识别出被指派去获取的物体。未来的搜索引擎可能会使用这些技术处理网页上的图像，识别出图像中的一般主题（如“晴空”，“小猫”）和特定主题（如“埃菲尔铁塔”，“亚伯拉罕·林肯”）。
- en: Indexes will also be updated faster. Currently web indexes update only when
    a web-crawling robot passes through. In the future, indexes may be updated in
    near real time, so that conversations quickly developing throughout social media
    can be indexed as they happen. Eventually, real-time search may be combined with
    artificial intelligence to automatically generate basic news stories from social
    media for fast-breaking events like natural disasters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的更新速度也将加快。目前，网络索引只有在网络爬虫机器人经过时才会更新。未来，索引可能会接近实时更新，这样社交媒体上快速发展的对话可以在发生的同时被索引。最终，实时搜索可能与人工智能结合，自动生成来自社交媒体的基础新闻报道，以应对像自然灾害这样的突发事件。
- en: But those are tomorrow’s marvels. The Web and its search engines are the marvel
    of today, a powerhouse of information unfathomable just a few decades ago.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些都是明天的奇迹。今天的奇迹是网络及其搜索引擎，它们是一个信息的强大源泉，几乎是几十年前无法想象的。
