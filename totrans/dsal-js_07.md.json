["```\nconst factorial = (n) => {\n❶ if (n === 0) {\n   return 1;\n❷} else {\n   return n * factorial(n - 1);\n }\n};\n```", "```\nconst fibo = (n) => {\n❶ if (n === 0) {\n   return 0;\n❷} else if (n === 1) {\n   return 1;\n❸} else {\n   return fibo(n - 1) + fibo(n - 2);\n }\n};\n```", "```\nconst towers = (disks, origin, extra, destination) => {\n❶ if (disks > 0) {\n  ❷ towers(disks - 1, origin, destination, extra);\n  ❸ console.log(`Move disk ${disks} from ${origin} to ${destination}`);\n  ❹ towers(disks - 1, extra, origin, destination);\n  }\n};\n```", "```\nMove disk 1 from A to B\nMove disk 2 from A to C\nMove disk 1 from B to C\nMove disk 3 from A to B\nMove disk 1 from C to A\nMove disk 2 from C to B\nMove disk 1 from A to B\nMove disk 4 from A to C\nMove disk 1 from B to C\nMove disk 2 from B to A\nMove disk 1 from C to A\nMove disk 3 from B to C\nMove disk 1 from A to B\nMove disk 2 from A to C\nMove disk 1 from B to C\n```", "```\n❶ solveMaze(fromCell, toCell, maze, path=[])\n❷ if(fromCell === toCell) {\n    return path // success!\n  }\n❸ mark fromCell as visited\n❹ for all nextCell cells adjacent to fromCell {\n  ❺ updatedPath = solveMaze(nextCell, toCell, maze, path + fromCell)\n    if updatedPath is not null {\n      return path\n    }\n  }\n // All adjacent cells were tried, and failed...\n❻ return null   // failure\n}\n```", "```\n❶ const solve = (goal, standing, score = 0, dropped = []) => {\n❷ if (score === goal) {\n    return dropped;\n❸} else if (score > goal || standing.length === 0) {\n    return null;\n  } else {\n  ❹ const chosen = standing[0];\n  ❺ const others = standing.slice(1);\n  ❻ return (\n      solve(goal, others, score + chosen, [...dropped, chosen]) ||\n      solve(goal, others, score, dropped)\n    );\n  }\n};\n❼ console.log(solve(50, [15, 9, 30, 21, 19, 3, 12, 6, 25, 27]));\n```", "```\nconst fibo = (n) => {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  } else {\n    return fibo(n - 1) + fibo(n - 2);\n  }\n};\n```", "```\n❶ const memoize = (fn) => {\n  ❷ const cache = {};\n  ❸ return (...args) => {\n      ❹ const strX = JSON.stringify(args);\n      ❺ return strX in cache\n        ❻ ? cache[strX]\n        ❼ : (cache[strX] = fn(...args));\n    };\n};\n```", "```\nconst fibo = **memoize(**(n) => {\n  ...\n}**);**\n```", "```\nconst costOfFragment = (p, q) => {\n❶ const s = totalWidth(p, q);\n  if (s <= MW) {\n  ❷ return [(MW - s) ** 2, [q]];\n  }\n\n❸ let optimum = Infinity;\n❹ let split = [];\n❺ for (let r = p; r < q; r++) {\n  ❻ const left = costOfFragment(p, r);\n    const right = costOfFragment(r + 1, q);\n  ❼ const newTry = left[0] + right[0];\n  ❽ if (newTry < optimum) {\n      optimum = newTry;\n      split = [r, . . .right[1]];\n    }\n  }\n❾ return [optimum, split];\n};\n```", "```\n❶ const blocks = [7, 2, 5, 3, 6];\nconst costOfFragment = ...\n❷ const result = costOfFragment(0, blocks.length - 1);\n❸ console.log(result[0], result[1]);\n// 19 [0, 2, 4]\n```", "```\nconst costOfFragment = **memoize(**(p, q) => {\n  ...\n}**);**\n```", "```\nconst fibo = (n) => {\n❶ if (n < 2) {\n    return n;\n❷} else {\n    let a = 0;\n    let b = 1;\n ❸ while (n > 1) {\n      [a, b] = [b, a + b];\n      n--;\n    }\n ❹ return b;\n }\n};\n```", "```\nconst totalWidth1 = (arr, from, to) => {\n  let sum = 0;\n  for (let i = from; i <= to; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n```", "```\nconst totalWidth1 = **memoize(**(arr, from, to) => {\n  ...\n}**);**\n```", "```\nconst totalWidth2 = memoize((arr, from, to) => {\n  if (from === to) {\n    return arr[from];\n  } else if (from === 0) {\n    return totalWidth2(arr, 0, to - 1) + arr[to];\n  } else {\n    return totalWidth2(arr, 0, to) - totalWidth2(arr, 0, from - 1);\n  }\n});\n```", "```\nconst totalWidth3 = ((tab) => {\n❶ const partial = [0];\n  tab.forEach((v, i) => {\n  ❷ partial[i + 1] = partial[i] + v;\n  });\n❸ return (from, to) => partial[to + 1] – partial[from];\n❹})(arr);\n```", "```\n❶ const isTautology = (fn, args = []) => {\n❷ if (fn.length === args.length) {\n  ❸ const result = !!fn(...args);\n ❹ if (!result) {\n      console.log(\"Failed at\", . . .args);\n    }\n    return result;\n  } else {\n  ❺ return (\n      isTautology(fn, [...args, false]) && isTautology(fn, [...args, true])\n    );\n  }\n};\n```", "```\nconst f = (x, y) => x || y || (!x && !y);\nconsole.log(isTautology(f)); // true\n\nconst g = (x, y) => (x || (!x && y)) === (x || y);\nconsole.log(isTautology(g)); // true\n\nconst h = (x, y, z) => !x || (x && z) || !y || (y && z) || z;\nconsole.log(isTautology(h)); // false: Failed at true true false\n```", "```\n❶ const solve = (puzzle, digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) => {\n❷ const d = [...digits].sort();\n\n❸ for (;;) {\n  ❹ if (puzzle(...d)) {\n      console.log(\"SOLUTION: \", . . .d);\n      return true;\n    }\n  ❺ // Try generating the next combination of d.\n    // If there are no more combinations left, return false.\n  }\n};\n```", "```\nconst solve = (puzzle, digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) => {\n  const d = [...digits].sort();\n\n  for (;;) {\n    if (puzzle(...d)) {\n      console.log(\"SOLUTION: \", . . .d);\n      return true;\n    }\n\n **let p = d.length - 2;**\n    while (p >= 0 && d[p] > d[p + 1]) {\n      p--;\n    }\n\n    if (p === -1) {\n      console.log(\"No solution found\");\n      return false;\n    }\n\n    **let q = d.length - 1;**\n    while (d[p] > d[q]) {\n      q--;\n    }\n\n    **[d[p], d[q]] = [d[q], d[p]];**\n\n    **let l = p + 1;**\n    let r = d.length - 1;\n    while (l < r) {\n      [d[l], d[r]] = [d[r], d[l]];\n      l++;\n      r--;\n    }\n  }\n};\n```", "```\n❶ const sendMoreMoney = (s, e, n, d, m, o, r, y) => {\n❷ if (s === 0 || m === 0) {\n    return false;\n❸} else {\n    const SEND = Number(`${s}${e}${n}${d}`);\n    const MORE = Number(`${m}${o}${r}${e}`);\n    const MONEY = Number(`${m}${o}${n}${e}${y}`);\n    return SEND + MORE === MONEY;\n  }\n};\n\n❹ solve(sendMoreMoney);\n// SOLUTION:  9 5 6 7 1 0 8 2 3 4\n// 9567 + 1085=10652\n```"]