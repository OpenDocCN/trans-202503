<html><head></head><body><section class="chapter" epub:type="chapter" id="building_the_network_you_need" title="Chapter&#xA0;1.&#xA0;Building the Network you Need"><div class="titlepage"><div><div><h2 class="title">Chapter 1. Building the Network you Need</h2></div></div></div><div class="mediaobject"><a id="med_id00002"/><img alt="Building the Network you Need" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p><a class="indexterm" id="iddle1601"/><a class="indexterm" id="iddle1615"/>PF, the OpenBSD <span class="emphasis"><em>Packet Filter subsystem</em></span>, is in my opinion the finest tool available for taking control of your network. Before diving into the specifics of how to make your network the fine-tuned machinery of your dreams, please read this chapter. It introduces basic networking terminology and concepts, provides some PF history, and gives you an overview of what you can expect to find in this book.</p><div class="sect1" title="Your Network: High Performance, Low Maintenance, and Secure"><div class="titlepage"><div><div><h2 class="title" id="your_network_high_performancecomma_low_m" style="clear: both">Your Network: High Performance, Low Maintenance, and Secure</h2></div></div></div><p>If this heading accurately describes your network, you’re most likely reading this book for pure entertainment, and I hope you’ll enjoy the rest of it. <a class="indexterm" id="iddle1175"/><a class="indexterm" id="iddle1187"/><a class="indexterm" id="iddle1342"/><a class="indexterm" id="iddle1372"/><a class="indexterm" id="iddle1510"/><a class="indexterm" id="iddle1566"/><a class="indexterm" id="iddle1567"/><a class="indexterm" id="iddle1995"/><a class="indexterm" id="iddle2027"/><a class="indexterm" id="iddle2069"/><a class="indexterm" id="iddle2070"/>If, on the other hand, you’re still learning how to build networks or you’re not quite confident of your skills yet, a short recap of basic network security concepts can be useful.</p><p>Information technology (IT) security is a large, complex, and sometimes confusing subject. Even if we limit ourselves to thinking only in terms of network security, it may seem that we haven’t narrowed down the field much or eliminated enough of the inherently confusing terminology. Matters became significantly worse some years ago when personal computers started joining the networked world, equipped with system software and applications that clearly weren’t designed for a networked environment.</p><p>The result was predictable. Even before the small computers became networked, they’d become home to malicious software, such as <span class="emphasis"><em>viruses</em></span> (semiautonomous software that is able to “infect” other files in order to deliver its payload and make further copies of itself) and <span class="emphasis"><em>trojans</em></span> (originally <span class="emphasis"><em>trojan horses</em></span>, software or documents with code embedded that, if activated, would cause the victim’s computer to perform actions the user didn’t intend). When the small computers became networked, they were introduced to yet another kind of malicious software called a <span class="emphasis"><em>worm</em></span>, a class of software that uses the network to propagate its payload.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch01fn01" id="ch01fn01">1</a>]</sup> Along the way, the networked versions of various kinds of frauds made it onto the network security horizon as well, and today a significant part of computer security activity (possibly the largest segment of the industry) centers on threat management, with emphasis on fighting and cataloging malicious software, or <span class="emphasis"><em>malware</em></span>.</p><p>The futility of enumerating badness has been argued convincingly elsewhere (see <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a> for references, such as Marcus Ranum’s excellent essay “The Six Dumbest Ideas in Computer Security”). The OpenBSD approach is to design and code properly in the first place. However, even smart people make mistakes every now and then, producing bugs, so make sure to design the system to allow any such failure to have the least possible impact security-wise. Then, if you later discover mistakes and the bugs turn out to be exploitable, fix those bugs wherever similar code turns up in the tree, even if it could mean a radical overhaul of the design and, at worst, a loss of backward compatibility.<sup>[<a class="footnote" href="#ftn.ch01fn02" id="ch01fn02">2</a>]</sup></p><p>In PF, and by extension in this book, the focus is narrower, concentrated on network traffic at the network level. The introduction of divert(4) sockets in OpenBSD 4.7 made it incrementally easier to set up a system where PF contributes to <span class="emphasis"><em>deep packet inspection</em></span>, much like some fiercely marketed products. However, the interface is not yet widely used in free software for that purpose, although exceptions exist. Therefore, we’ll instead <a class="indexterm" id="iddle1077"/><a class="indexterm" id="iddle1107"/><a class="indexterm" id="iddle1108"/><a class="indexterm" id="iddle1214"/><a class="indexterm" id="iddle1246"/><a class="indexterm" id="iddle1261"/><a class="indexterm" id="iddle1471"/><a class="indexterm" id="iddle1529"/><a class="indexterm" id="iddle1571"/><a class="indexterm" id="iddle1628"/><a class="indexterm" id="iddle1958"/>focus on some techniques based on pure network-level behavior, which are most evident in the example configurations in <a class="xref" href="ch06.html" title="Chapter 6. Turning the Tables for Proactive Defense">Chapter 6</a>. These techniques will help ease the load on content-inspecting products if you have them in place. As you’ll see in the following chapters, the network level offers a lot of fun and excitement, in addition to the blocking or passing packets.</p></div><div class="sect1" title="Where the Packet Filter Fits In"><div class="titlepage"><div><div><h2 class="title" id="where_the_packet_filter_fits_in" style="clear: both">Where the Packet Filter Fits In</h2></div></div></div><p>The packet filter’s main function is, as the name suggests, to filter network packets by matching the properties of individual packets and the network connections built from those packets against the filtering criteria defined in its configuration files. The packet filter is responsible for deciding what to do with those packets. This could mean passing them through or rejecting them, or it could mean triggering events that other parts of the operating system or external applications are set up to handle.</p><p>PF lets you write custom filtering criteria to control network traffic based on essentially any packet or connection property, including address family, source and destination address, interface, protocol, port, and direction. Based on these criteria, the packet filter performs the action you specify. One of the simplest and most common actions is to block traffic.</p><p>A packet filter can keep unwanted traffic out of your network. It can also help contain network traffic inside your own network. Both these functions are important to the <span class="emphasis"><em>firewall</em></span> concept, but blocking is far from the only useful or interesting feature of a functional packet filter. As you’ll see in this book, you can use filtering criteria to direct certain kinds of network traffic to specific hosts, assign classes of traffic to queues, perform traffic shaping, and even hand off selected kinds of traffic to other software for special treatment.</p><p>All this processing happens at the network level, based on packet and connection properties. PF is part of the network stack, firmly embedded in the operating system kernel. While there have been examples of packet filtering implemented in user space, in most operating systems, the filtering functions are performed in the kernel because it’s faster to do so.</p></div><div class="sect1" title="The Rise of PF"><div class="titlepage"><div><div><h2 class="title" id="rise_of_pf" style="clear: both">The Rise of PF</h2></div></div></div><p>If you have a taste for history, you probably already know that OpenBSD and the other BSDs<sup>[<a class="footnote" href="#ftn.ch01fn03" id="ch01fn03">3</a>]</sup> are direct descendants of the BSD system (sometimes referred to as <span class="emphasis"><em>BSD Unix</em></span>), the operating system that contained the original reference implementation of the TCP/IP Internet protocols in the early 1980s.</p><p><a class="indexterm" id="iddle1181"/><a class="indexterm" id="iddle1316"/><a class="indexterm" id="iddle1378"/><a class="indexterm" id="iddle1379"/><a class="indexterm" id="iddle1380"/><a class="indexterm" id="iddle1617"/><a class="indexterm" id="iddle1618"/><a class="indexterm" id="iddle1762"/>As the research project behind BSD development started winding down in the early 1990s, the code was liberated for further development by small groups of enthusiasts around the world. Some of these enthusiasts were responsible for keeping vital parts of the emerging Internet’s infrastructure running reliably, and BSD development continued along parallel lines in several groups. The OpenBSD group became known as the most security-oriented of the BSDs. For its packet-filtering needs, it used a subsystem called <span class="emphasis"><em>IPFilter</em></span>, written mainly by Darren Reed. During these early years, OpenBSD quickly earned a positive reputation as “THE firewall OS,” and it’s still quite common for people to believe that OpenBSD was developed specifically for that purpose.</p><p>It shocked the OpenBSD community when Reed announced in early 2001 that IPFilter, which at that point was intimately integrated with OpenBSD, wasn’t covered under the BSD license. Instead, it used almost a word-for-word copy of the license, omitting only the right to make changes to the code and distribute the result. The problem was that the OpenBSD version of IPFilter contained several changes and customizations that, as it turned out, were not allowed under the license. As a result, IPFilter was deleted from the OpenBSD source tree on May 29, 2001, and for a few weeks, the development version of OpenBSD (-current) didn’t include any packet filter software.</p><p>Fortunately, at this time, in Switzerland, Daniel Hartmeier had been performing some limited experiments involving kernel hacking in the networking code. He began by hooking a small function of his own into the networking stack and then making packets pass through it. Then, he began thinking about filtering. When the license crisis happened, PF was already under development on a small scale. The first commit of the PF code was on Sunday, June 24, 2001, at 19:48:58 UTC. A few months of intense activity by many developers followed, and the resulting version of PF was launched as a default part of the OpenBSD 3.0 base system in December of 2001.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch01fn04" id="ch01fn04">4</a>]</sup> This version contained an implementation of packet filtering, including network address translation, with a configuration language that was similar enough to IPFilter’s that migrating to the new OpenBSD version did not pose major problems.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch01fn05" id="ch01fn05">5</a>]</sup></p><p><a class="indexterm" id="iddle1088"/><a class="indexterm" id="iddle1166"/><a class="indexterm" id="iddle1167"/><a class="indexterm" id="iddle1215"/><a class="indexterm" id="iddle1262"/><a class="indexterm" id="iddle1308"/><a class="indexterm" id="iddle1504"/><a class="indexterm" id="iddle1530"/><a class="indexterm" id="iddle1627"/>PF proved to be well-developed software. In 2002, Hartmeier presented a USENIX paper with performance tests showing that the OpenBSD 3.1 PF performed equally well or better under stress than either IPFilter on OpenBSD 3.1 or iptables on Linux. In addition, tests run on the original PF from OpenBSD 3.0 showed mainly that the code had gained in efficiency from version 3.0 to version 3.1.<sup>[<a class="footnote" href="#ftn.ch01fn06" id="ch01fn06">6</a>]</sup></p><p>The OpenBSD PF code, with a fresh packet-filtering engine written by experienced and security-oriented developers, naturally generated interest in the sister BSDs as well. The FreeBSD project gradually adopted PF, first as a package and then, from version 5.3 on, in the base system as one of three packet-filtering systems. PF has also been included in NetBSD and DragonFly BSD.<sup>[<a class="footnote" href="#ftn.ch01fn07" id="ch01fn07">7</a>]</sup></p><p>This book focuses on the PF version available in OpenBSD 5.5. I’ll note significant differences between that version and the ones integrated in other systems as appropriate.</p><p>If you’re ready to dive into PF configuration, you can jump to <a class="xref" href="ch02.html" title="Chapter 2. PF Configuration Basics">Chapter 2</a> to get started. If you want to spend a little more time getting your bearings in unfamiliar BSD territory, continue reading this chapter.</p><div class="sidebar"><a id="newer_pf_releases_perform_better"/><div class="sidebar-title">Newer PF Releases Perform Better</div><p>Like the rest of the computing world, OpenBSD and PF have been affected by rapid changes in hardware and network conditions. I haven’t seen tests comparable to the ones in Daniel Hartmeier’s USENIX paper performed recently, but PF users have found that the filtering overhead is modest.</p><p>As an example (mainly to illustrate that even unexciting hardware configurations can be useful), the machine that gateways between one small office network in my care and the world is a Pentium III 450MHz with 384MB of RAM. When I’ve remembered to check, I’ve never seen the machine at less than 96 percent idle according to the output from the <code class="literal">top(1)</code> command.</p><p>It’s also worth noting that the current PF developers, mainly Henning Brauer and Ryan McBride, with contributions from several others, rewrote large portions of OpenBSD’s PF code with improved performance as a stated main goal during recent releases, making each release from 4.4 through 5.6 perform noticeably better than its predecessors.</p></div></div><div class="sect1" title="If You Came from Elsewhere"><div class="titlepage"><div><div><h2 class="title" id="if_you_came_from_elsewhere" style="clear: both">If You Came from Elsewhere</h2></div></div></div><p><a class="indexterm" id="iddle1110"/><a class="indexterm" id="iddle1111"/><a class="indexterm" id="iddle1432"/><a class="indexterm" id="iddle1433"/><a class="indexterm" id="iddle1620"/><a class="indexterm" id="iddle1622"/>If you’re reading this because you’re considering moving your setup to PF from some other system, this section is for you.</p><p>If you want to use PF, you need to install and run a BSD system, such as OpenBSD, FreeBSD, NetBSD, or DragonFly BSD. These are all fine operating systems, but my personal favorite is OpenBSD, mainly because that’s the operating system where essentially all PF development happens. I also find the no-nonsense approach of the developers and the system refreshing.</p><p>Occasionally, minor changes and bug fixes trickle back to the main PF code base from the PF implementations on other systems, but the newest, most up-to-date PF code is always to be found on OpenBSD. Some of the features described in this book are available only in the most recent versions of OpenBSD. The other BSDs have tended to port the latest released PF version from OpenBSD to their code bases in time for their next release, but synchronized updates are far from guaranteed, and the lag is sometimes considerable.</p><p>If you’re planning to run PF on FreeBSD, NetBSD, DragonFly BSD, or another system, you should check your system’s release notes and other documentation for information about which version of PF is included.</p><div class="sect2" title="Pointers for Linux Users"><div class="titlepage"><div><div><h3 class="title" id="pointers_for_linux_users">Pointers for Linux Users</h3></div></div></div><p>The differences and similarities between Linux and BSD are potentially a large topic if you probe deeply, but if you have a reasonable command of the basics, it shouldn’t take too long for you to feel right at home with the BSD way of doing things. In the rest of this book, I’ll assume you can find your way around the basics of BSD network configuration. So, if you’re more familiar with configuring Linux or other systems than you are with BSD, it’s worth noting a few points about BSD configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Linux and BSD use different conventions for naming network interfaces. The Linux convention is to label all the network interfaces on a given machine in the sequence <code class="literal">eth0</code>, <code class="literal">eth1</code>, and so on (although with some Linux versions and driver combinations, you also see <code class="literal">wlan0</code>, <code class="literal">wlan1</code>, and so on for wireless interfaces).</p><p>On the BSDs, interfaces are assigned names that equal the driver name plus a sequence number. For example, older 3Com cards using the ep driver appear as <code class="literal">ep0</code>, <code class="literal">ep1</code>, and so on; Intel Gigabit cards are likely to end up as <code class="literal">em0</code>, <code class="literal">em1</code>, and so on. Some SMC cards are listed as <code class="literal">sn0</code>, <code class="literal">sn1</code>, and so on. This system is quite logical and makes it easier to find the documentation for the specifics of that interface. If your kernel reports (at boot time or in <code class="literal">ifconfig</code> output) that you have an interface called <code class="literal">em0</code>, you need only type <code class="literal">man em</code> at a shell command-line prompt to find out what speeds it supports—whether there are any eccentricities to be aware of, whether any firmware download is needed, and so on.</p></li><li class="listitem"><p><a class="indexterm" id="iddle1109"/><a class="indexterm" id="iddle1155"/><a class="indexterm" id="iddle1158"/><a class="indexterm" id="iddle1160"/><a class="indexterm" id="iddle1263"/><a class="indexterm" id="iddle1434"/><a class="indexterm" id="iddle1569"/><a class="indexterm" id="iddle1623"/><a class="indexterm" id="iddle1625"/>You should be aware that in BSDs, the configuration is <span class="emphasis"><em>/etc/rc.conf</em></span>-centric. In general, the BSDs are organized to read the configuration from the file <span class="emphasis"><em>/etc/rc.conf</em></span>, which is read by the <span class="emphasis"><em>/etc/rc</em></span> script at startup. OpenBSD recommends using <span class="emphasis"><em>/etc/rc.conf.local</em></span> for local customizations because <span class="emphasis"><em>rc.conf</em></span> contains the default values. FreeBSD uses <span class="emphasis"><em>/etc/defaults/rc.conf</em></span> to store the default settings, making <span class="emphasis"><em>/etc/rc.conf</em></span> the correct place to make changes. In addition, OpenBSD uses per-interface configuration files called <span class="emphasis"><em>hostname.&lt;if&gt;</em></span>, where <span class="emphasis"><em>&lt;if&gt;</em></span> is replaced with the interface name.</p></li><li class="listitem"><p>For the purpose of learning PF, you’ll need to concentrate on an <span class="emphasis"><em>/etc/pf.conf</em></span> file, which will be largely your own creation.</p></li></ul></div><p>If you need a broader and more thorough introduction to your BSD of choice, look up the operating system’s documentation, including FAQs and guides, at the project’s website. You can also find some suggestions for further reading in <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a>.</p></div><div class="sect2" title="Frequently Answered Questions About PF"><div class="titlepage"><div><div><h3 class="title" id="frequently_answered_questions_about_pf">Frequently Answered Questions About PF</h3></div></div></div><p>This section is based on questions I’ve been asked via email or at meetings and conferences as well as some that have popped up in mailing lists and other discussion forums. Some of the more common questions are covered here in a FAQ-style<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch01fn08" id="ch01fn08">8</a>]</sup> format.</p><div class="sect3" title="Can I run PF on my Linux machine?"><div class="titlepage"><div><div><h4 class="title" id="can_i_run_pf_on_my_linux_machinequestion">Can I run PF on my Linux machine?</h4></div></div></div><p>In a word, no. Over the years, announcements have appeared on the PF mailing list from someone claiming to have started a Linux port of PF, but at the time of this writing, no one has yet claimed to have completed the task. The main reason for this is probably that PF is developed primarily as a deeply integrated part of the OpenBSD networking stack. Even after more than a decade of parallel development, the OpenBSD code still shares enough fundamentals with the other BSDs to make porting possible, but porting PF to a non-BSD system would require rewriting large chunks of PF itself as well as whatever integration is needed at the target side.</p><p>For some basic orientation tips for Linux users to find their way in BSD network configurations, see <a class="xref" href="ch01.html#pointers_for_linux_users" title="Pointers for Linux Users">Pointers for Linux Users</a>.</p></div><div class="sect3" title="Can you recommend a GUI tool for managing my PF rule set?"><div class="titlepage"><div><div><h4 class="title" id="can_you_recommend_a_gui_tool_for_managin">Can you recommend a GUI tool for managing my PF rule set?</h4></div></div></div><p>This book is mainly oriented toward users who edit their rule sets in their favorite text editor. The sample rule sets in this book are simple enough that you probably wouldn’t get a noticeable benefit from any of the visualization options the various GUI tools are known to offer.</p><p>A common claim is that the PF configuration files are generally readable enough that a graphic visualization tool isn’t really necessary. There are, however, several GUI tools available that can edit and/or generate PF <a class="indexterm" id="iddle1204"/><a class="indexterm" id="iddle1265"/><a class="indexterm" id="iddle1381"/><a class="indexterm" id="iddle1619"/><a class="indexterm" id="iddle1621"/><a class="indexterm" id="iddle1626"/><a class="indexterm" id="iddle1662"/><a class="indexterm" id="iddle1825"/>configurations, including a complete, customized build of FreeBSD called <span class="emphasis"><em>pfSense</em></span> (<span class="emphasis"><em><a class="ulink" href="http://www.pfsense.org/" target="_top">http://www.pfsense.org/</a></em></span>), which includes a sophisticated GUI rule editor.</p><p>I recommend that you work through the parts of this book that apply to your situation and then decide whether you need to use a GUI tool to feel comfortable running and maintaining the systems you build.</p></div><div class="sect3" title="Is there a tool I can use to convert my OtherProduct® setup to a PF configuration?"><div class="titlepage"><div><div><h4 class="title" id="is_there_a_tool_i_can_use_to_convert_my">Is there a tool I can use to convert my OtherProduct<sup>®</sup> setup to a PF configuration?</h4></div></div></div><p>The best strategy when converting network setups, including firewall setups, from one product to another is to go back to the specifications or policies for your network or firewall configuration and then implement the policies using the new tool.</p><p>Other products will inevitably have a slightly different feature set, and the existing configuration you created for OtherProduct<sup>®</sup> is likely to mirror slightly different approaches to specific problems, which do not map easily, or at all, to features in PF and related tools.</p><p>Having a documented policy, and taking care to update it as your needs change, will make your life easier. This documentation should contain a complete prose specification of what your setup is meant to achieve. (You might start out by putting comments in your configuration file to explain the purpose of your rules.) This makes it possible to verify whether the configuration you’re running actually implements the design goals. In some corporate settings, there may even be a formal requirement for a written policy.</p><p>The impulse to look for a way to automate your conversion is quite understandable and perhaps expected in a system administrator. I urge you to resist the impulse and to perform your conversion after reevaluating your business and technical needs and (preferably) after creating or updating a formal specification or policy in the process.</p><p>Some of the GUI tools that serve as administration frontends claim the ability to output configuration files for several firewall products and could conceivably be used as conversion tools. However, this has the effect of inserting another layer of abstraction between you and your rule set, and it puts you at the mercy of the tool author’s understanding of how PF rule sets work. I recommend working through at least the relevant parts of this book before spending serious time on considering an automated conversion.</p></div><div class="sect3" title="I heard PF is based on IPFilter, which I know from working with Solaris. Can I just copy my IPFilter configuration across and have a working setup right away?"><div class="titlepage"><div><div><h4 class="title" id="i_heard_pf_is_based_on_ipfiltercomma_whi">I heard PF is based on IPFilter, which I know from working with Solaris. Can I just copy my IPFilter configuration across and have a working setup right away?</h4></div></div></div><p>If people claim that PF is “based on” IPFilter, they are saying something that isn’t true. PF was written from scratch to be a replacement for the newly deleted IPFilter code. For that first version of PF, one of the design goals was to keep the syntax fairly compatible with the older software so the transition to OpenBSD 3.0 would be as painless as possible and not break existing setups too badly or in unpredictable ways.</p><p><a class="indexterm" id="iddle1020"/><a class="indexterm" id="iddle1481"/><a class="indexterm" id="iddle1624"/>However, a version or two down the road, it was reasonable to believe that no OpenBSD users were still likely to upgrade from a version that contained IPFilter, so staying compatible with the older system fell off the list of priorities. Some syntax similarities remain, even after 25 OpenBSD releases and more than 12 years of active development. Trying to load one system’s configuration on the other—for example, copying across an IPFilter configuration to an OpenBSD system and trying to load it there or copying a modern PF configuration to a Solaris system and trying to load it as an IPFilter configuration—is guaranteed to fail in almost all cases, except for a few specially crafted but still quite trivial and, in fact, rather useless configurations.</p></div><div class="sect3" title="Why did the PF rule syntax change all of a sudden?"><div class="titlepage"><div><div><h4 class="title" id="why_did_the_pf_rule_syntax_change_all_of">Why did the PF rule syntax change all of a sudden?</h4></div></div></div><p>The world changed, and PF changed with it. More specifically, the OpenBSD developers have a very active and pragmatically critical relationship to their code, and like all parts of OpenBSD, the PF code is under constant review.</p><p>The lessons learned over more than a decade of PF development and use led to internal changes in the code that eventually made it clear to the developers that changing the syntax slightly would make sense. The changes would make the PF syntax more consistent and make life easier for users in the long run at the price of some light edits of configuration files. The result for you, the user, is that PF is now even easier to use and that it performs better than the earlier versions. If you’re upgrading your system to OpenBSD 4.7 or newer, you’re in for a real treat.</p><p>And with OpenBSD 5.5, you’ll find another good reason to upgrade: the new queuing system for traffic shaping, which is intended to replace the venerable ALTQ system. ALTQ is still part of OpenBSD 5.5, although in slightly modified form, but it has already been removed from the OpenBSD kernel in time for the OpenBSD 5.6 release. <a class="xref" href="ch07.html" title="Chapter 7. Traffic Shaping with Queues and Priorities">Chapter 7</a> contains a section specifically about migrating to the new traffic-shaping system.</p></div><div class="sect3" title="Where can I find out more?"><div class="titlepage"><div><div><h4 class="title" id="where_can_i_find_out_morequestion_mark">Where can I find out more?</h4></div></div></div><p>There are several good sources of information about PF and the systems on which it runs. You’ve already found one in this book. You can find references to a number of printed and online resources in <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a>.</p><p>If you have a BSD system with PF installed, consult the online manual pages, or <span class="emphasis"><em>man pages</em></span>, for information about your exact release of the software. Unless otherwise indicated, the information in this book refers to the world as it looks from the command line on an OpenBSD 5.5 system.</p></div></div></div><div class="sect1" title="A Little Encouragement: A PF Haiku"><div class="titlepage"><div><div><h2 class="title" id="little_encouragement_a_pf_haiku" style="clear: both">A Little Encouragement: A PF Haiku</h2></div></div></div><p>If you’re not quite convinced yet, or even if you are, a little encouragement may be in order. Over the years, a good many people have said and written their bit about PF—sometimes odd, sometimes wonderful, and sometimes just downright strange.</p><p><a class="indexterm" id="iddle1189"/>The poem quoted here is a good indication of the level of feeling PF sometimes inspires in its users. This poem appeared on the PF mailing list, in a thread that started with a message with the subject “Things pf can’t do?” in May 2004. The message was written by someone who didn’t have a lot of firewall experience and who consequently found it hard to get the desired setup.</p><p>This, of course, led to some discussion, with several participants saying that if PF was hard on a newbie, the alternatives weren’t any better. The thread ended in the following haiku of praise from Jason Dixon, dated May 20, 2004.</p><a id="pro_id00002"/><pre class="programlisting">Compared to working with iptables, PF is like this haiku:&#13;
&#13;
A breath of fresh air,&#13;
floating on white rose petals,&#13;
eating strawberries.&#13;
&#13;
Now I'm getting carried away:&#13;
&#13;
Hartmeier codes now,&#13;
Henning knows not why it fails,&#13;
fails only for n00b.&#13;
&#13;
Tables load my lists,&#13;
tarpit for the asshole spammer,&#13;
death to his mail store.&#13;
&#13;
CARP due to Cisco,&#13;
redundant blessed packets,&#13;
licensed free for me.</pre><p>Some of the concepts Dixon mentions here may sound a bit unfamiliar, but if you read on, it’ll all make sense soon.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.ch01fn01"><p><sup>[<a class="para" href="#ch01fn01">1</a>] </sup>The famous worms before the Windows era were the IBM Christmas Tree EXEC worm (1987) and the first Internet worm, the Morris worm (1988). A wealth of information about both is within easy reach of your favorite search engine. The Windows era of networked worms is considered to have started with the ILOVEYOU worm in May 2000.</p></div><div class="footnote" id="ftn.ch01fn02"><p><sup>[<a class="para" href="#ch01fn02">2</a>] </sup>Several presentations on OpenBSD’s approach to security can be found via the collection at <span class="emphasis"><em><a class="ulink" href="http://www.openbsd.org/papers/" target="_top">http://www.openbsd.org/papers/</a></em></span>. Some of my favorites are Theo de Raadt’s “Exploit Mitigation Techniques” (as well as the 2013 follow-up, “Security Mitigation Techniques: An Update After 10 Years”), Damien Miller’s “Security Measures in OpenSSH,” and Henning Brauer and Sven Dehmlow’s “Puffy at Work—Getting Code Right and Secure, the OpenBSD Way.”</p></div><div class="footnote" id="ftn.ch01fn03"><p><sup>[<a class="para" href="#ch01fn03">3</a>] </sup>If <span class="emphasis"><em>BSD</em></span> doesn’t sound familiar, here is a short explanation: The acronym expands to <span class="emphasis"><em>Berkeley Software Distribution</em></span> and originally referred to a collection of useful software developed for the Unix operating system by staff and students at the University of California, Berkeley. Over time, the collection expanded into a complete operating system, which in turn became the forerunner of a family of systems, including OpenBSD, FreeBSD, NetBSD, DragonFly BSD, and, by some definitions, even Apple’s Mac OS X. For a very readable explanation of what BSD is, see Greg Lehey’s “Explaining BSD” at <span class="emphasis"><em><a class="ulink" href="http://www.freebsd.org/doc/en/articles/explaining-bsd/" target="_top">http://www.freebsd.org/doc/en/articles/explaining-bsd/</a></em></span> (and, of course, the projects’ websites).</p></div><div class="footnote" epub:type="footnote" id="ftn.ch01fn04"><p><sup>[<a class="para" href="#ch01fn04">4</a>] </sup>The IPFilter copyright episode spurred the OpenBSD team to perform a license audit of the entire source tree in order to avoid similar situations in the future. Several potential problems were resolved over the months that followed, resulting in the removal of a number of potential license pitfalls for everyone involved in free software development. Theo de Raadt summed up the effort in a message to the <span class="emphasis"><em>openbsd-misc</em></span> mailing list on February 20, 2003. The initial drama of the license crisis had blown over, and the net gain was a new packet-filtering system under a free license, with the best code quality available, as well as better free licenses for a large body of code in OpenBSD itself and in other widely used free software.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch01fn05"><p><sup>[<a class="para" href="#ch01fn05">5</a>] </sup>Compatibility with IPFilter configurations was an early design goal for the PF developers, but it stopped being a priority once it could be safely assumed that all OpenBSD users had moved to PF (around the time OpenBSD 3.2 was released, if not earlier). You shouldn’t assume that an existing IPFilter configuration will work without changes with any version of PF. With the syntax changes introduced in OpenBSD 4.7, even upgrades from earlier PF versions will involve some conversion work.</p></div><div class="footnote" id="ftn.ch01fn06"><p><sup>[<a class="para" href="#ch01fn06">6</a>] </sup>The article that provides the details of these tests is available from Daniel Hartmeier’s website. See <span class="emphasis"><em><a class="ulink" href="http://www.benzedrine.cx/pf-paper.html" target="_top">http://www.benzedrine.cx/pf-paper.html</a></em></span>.</p></div><div class="footnote" id="ftn.ch01fn07"><p><sup>[<a class="para" href="#ch01fn07">7</a>] </sup>At one point, there even existed a personal firewall product running on Microsoft Windows, named <span class="emphasis"><em>Core Force</em></span>, that was based on a port of PF. By early 2010, Core Security, the company that developed Core Force (<span class="emphasis"><em><a class="ulink" href="http://force.coresecurity.com/" target="_top">http://force.coresecurity.com/</a></em></span>), seemed to have shifted focus to other security areas, such as penetration testing, but the product was still available for download.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch01fn08"><p><sup>[<a class="para" href="#ch01fn08">8</a>] </sup>The three-letter abbreviation FAQ expands to either <span class="emphasis"><em>frequently asked questions</em></span> or <span class="emphasis"><em>frequently answered questions</em></span>—both equally valid.</p></div></div></section></body></html>