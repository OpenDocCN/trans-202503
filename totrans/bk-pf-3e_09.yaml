- en: Chapter 9. Logging, Monitoring, and Statistics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章：日志记录、监控与统计
- en: '![Logging, Monitoring, and Statistics](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![日志记录、监控与统计](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
- en: Exercising control over a network—whether for your home networking needs or
    in a professional context—is likely to be a main objective for anyone who reads
    this book. One necessary element of keeping control is having access to all relevant
    information about what happens in your network. Fortunately for us, PF—like most
    components of Unix-like systems—is able to generate log data for network activity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 控制网络——无论是为了家庭网络需求，还是在专业环境中的应用——可能是阅读本书的每个人的主要目标之一。保持控制的一个必要元素是能够访问关于网络中发生的所有相关信息。幸运的是，PF
    —— 就像大多数类 Unix 系统的组件 —— 能够生成网络活动的日志数据。
- en: PF offers a wealth of options for setting the level of logging detail, processing
    log files, and extracting specific kinds of data. You can already do a lot with
    the tools that are in your base system, and several other tools are available
    via your package system to collect, study, and view log data in a number of useful
    ways. In this chapter, we take a closer look at PF logs in general and some of
    the tools you can use to extract and present information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PF 提供了丰富的选项来设置日志详细程度、处理日志文件以及提取特定类型的数据。你已经可以使用基础系统中的工具做很多事情，并且通过你的包管理系统还可以获得其他一些工具，用于以多种有用的方式收集、研究和查看日志数据。在本章中，我们将更详细地探讨
    PF 日志的一般情况以及你可以用来提取和展示信息的一些工具。
- en: 'PF Logs: The Basics'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PF 日志：基础
- en: 'The information that PF logs and the level of logging detail are up to you,
    as determined by your rule set. Basic logging is simple: For each rule that you
    want to log data for, add the `log` keyword. When you load the rule set with `log`
    added to one or more rules, any packet that starts a connection matching the logging
    rule (blocked, passed, or matched) is copied to a `pflog` device. *The packet
    is logged as soon as it’s seen by PF and at the same time that the logging rule
    is evaluated.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PF 记录的信息和日志详细程度由你决定，取决于你的规则集。基础的日志记录很简单：对于每个你希望记录数据的规则，添加 `log` 关键字。当你加载带有 `log`
    的规则集时，任何开始连接的匹配日志规则的数据包（被阻止、通过或匹配）都会被复制到 `pflog` 设备。*数据包一旦被 PF 看到并且日志规则被评估时，它就会立即被记录。*
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In complicated rule sets, a packet may go through several transformations
    due to `match` or `pass` rules, and criteria that matched a packet when it entered
    the host might not match after a transformation.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*在复杂的规则集中，由于 `match` 或 `pass` 规则，数据包可能会经历多次转换，当数据包进入主机时匹配的条件可能在转换后不再匹配。*'
- en: PF will also store certain additional data, such as the timestamp, interface,
    original source and destination IP addresses, whether the packet was blocked or
    passed, and the associated rule number from the loaded rule set.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: PF 还会存储一些附加数据，例如时间戳、接口、原始的源和目的 IP 地址、数据包是否被阻止或通过，以及从加载的规则集中关联的规则编号。
- en: PF log data is collected by the `pflogd` logging daemon, which starts by default
    when PF is enabled at system startup. The default location for storing the log
    data is */var/log/pflog*. The log is written in a binary format, usually called
    *packet capture format (pcap)*, that’s intended to be read and processed by `tcpdump`.
    We’ll discuss additional tools to extract and display information from your log
    file later. The log file format is a well-documented and widely supported binary
    format.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PF 日志数据由 `pflogd` 日志守护进程收集，该进程默认在系统启动时启用 PF 时启动。默认的日志数据存储位置是 */var/log/pflog*。日志以二进制格式写入，通常称为
    *数据包捕获格式（pcap）*，旨在通过 `tcpdump` 进行读取和处理。稍后我们将讨论一些提取和展示日志文件信息的附加工具。日志文件格式是一种文档化完善且广泛支持的二进制格式。
- en: 'To get started, here’s a basic log example. Start with the rules you want to
    log and add the `log` keyword:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，这是一个基本的日志示例。首先从你希望记录的规则开始，并添加 `log` 关键字：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Reload the rule set, and you should see the timestamp on your */var/log/ pflog*
    file change as the file starts growing. To see what’s being stored there, use
    `tcpdump` with the `-r` option to read the file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载规则集后，你应该会看到 */var/log/pflog* 文件的时间戳发生变化，文件开始增长。要查看存储了什么内容，可以使用 `tcpdump`
    配合 `-r` 选项读取该文件。
- en: 'If logging has been going on for a while, entering the following on a command
    line can produce large amounts of output:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志记录已经进行了一段时间，输入以下命令可能会产生大量输出：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, the following are just the first lines from a file several screens
    long, with almost all lines long enough to wrap:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下仅是一个长文件的前几行，几乎所有行都足够长，需要换行显示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `tcpdump` program is very flexible, especially when it comes to output,
    and it offers a number of display choices. The format in this example follows
    from the options we fed to `tcpdump`. The program almost always displays the date
    and time the packet arrived (the `-ttt` option specifies this long format). Next,
    `tcpdump` lists the rule number in the loaded rule set, the interface on which
    the packet appeared, the source and target address and ports (the `-n` option
    tells `tcpdump` to display IP addresses, not hostnames), and the various packet
    properties.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump`程序非常灵活，特别是在输出方面，它提供了多种显示选项。此示例中的格式来自我们提供给`tcpdump`的选项。该程序几乎总是显示数据包到达的日期和时间（`-ttt`选项指定了这种长格式）。接下来，`tcpdump`列出了加载的规则集中的规则编号、数据包出现的接口、源地址和目标地址及端口（`-n`选项告诉`tcpdump`显示IP地址而不是主机名），以及各种数据包属性。'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The rule numbers in your log files refer to the* loaded, in-memory *rule set.
    Your rule set goes through some automatic steps during the loading process, such
    as macro expansion and optimizations, which make it likely that the rule number
    as stored in the logs will not quite match what you’d find by counting from the
    top of your* pf.conf *file. If it isn’t immediately obvious to you which rule
    matched, use `pfctl -vvs rules` and study the output.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*日志文件中的规则编号指的是* 加载到内存中的 *规则集。你的规则集在加载过程中会经历一些自动步骤，例如宏扩展和优化，这使得日志中存储的规则编号可能与从`pf.conf`文件顶部开始计算得到的规则编号不完全匹配。如果你不确定是哪个规则匹配了，可以使用`pfctl
    -vvs rules`命令并研究输出。*'
- en: In our `tcpdump` output example, we see that the tenth rule (`rule 10`) in the
    loaded rule set seems to be a catchall that matches both IDENT requests and domain
    name lookups. This is the kind of output you’ll find invaluable when debugging,
    and it’s essential to have this kind of data available in order to stay on top
    of your network. With a little effort and careful reading of the `tcpdump` man
    pages, you should be able to extract useful information from your log data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`tcpdump`输出示例中，我们看到加载的规则集中的第十条规则（`rule 10`）似乎是一个捕获规则，匹配IDENT请求和域名查询。这种输出在调试时非常有价值，要保持网络的掌控，必须具备这种类型的数据。通过一些努力和仔细阅读`tcpdump`手册页面，你应该能够从日志数据中提取出有用的信息。
- en: For a live display of the traffic you log, use `tcpdump` to read log information
    directly from the log device. To do so, use the `-i` option to specify which interface
    you want `tcpdump` to read from, as follows. (The `-l` option, which enables line
    buffering on the output, is useful if you want to look at what you’re capturing.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 若要实时显示你记录的流量，可以使用`tcpdump`直接从日志设备读取日志信息。为此，使用`-i`选项指定你希望`tcpdump`读取的接口，如下所示。（`-l`选项可启用输出的行缓冲，如果你想查看正在捕获的内容，这个选项很有用。）
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This sequence begins with a domain name lookup answer, followed by two packets
    from an open SSH connection, which tells us that the site’s administrator probably
    enabled `log (all)` on the matching rules (see [Logging All Packets: log (all)](ch09.html#logging_all_packets_log_left_parenthesis
    "Logging All Packets: log (all)")). The fourth packet belongs to a website connection,
    the fifth is part of an outgoing SMTP connection, and finally there’s another
    SSH packet. If you were to leave this command running, the displayed lines would
    eventually scroll off the top of your screen, but you could redirect the data
    to a file or to a separate program for further processing.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列以域名查询响应开始，接着是两个来自打开SSH连接的数据包，这告诉我们该站点的管理员可能在匹配规则上启用了`log (all)`（参见[记录所有数据包：log
    (all)](ch09.html#logging_all_packets_log_left_parenthesis "记录所有数据包：log (all)")).
    第四个数据包属于一个网站连接，第五个是一个外发SMTP连接的一部分，最后是另一个SSH数据包。如果你让这个命令一直运行，显示的行最终会滚动出屏幕，但你可以将数据重定向到文件或其他程序以进一步处理。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Sometimes you’ll be interested mainly in traffic between specific hosts or
    in traffic matching specific criteria. For these cases, `tcpdump`’s filtering
    features can be useful. See `man tcpdump` for details.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时你可能主要对特定主机之间的流量或符合特定条件的流量感兴趣。在这种情况下，`tcpdump`的过滤功能可能会非常有用。详情请参见`man tcpdump`。*'
- en: 'Logging the Packet’s Path Through Your Rule Set: log (matches)'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录数据包在规则集中的路径：log（匹配）
- en: Early versions of the PF logging code didn’t feature an easy way to track all
    rules that a packet would match during rule-set traversal. This omission became
    more evident than before when `match` rules were introduced in OpenBSD 4.6 and
    PF users were offered a more convenient and slightly easier way to subject packets
    and connections to transformations, such as address rewriting. `match` rules allow
    you to perform actions on a packet or connection independently of the eventual
    `pass` or `block` decision. The specified actions—such as `nat-to`, `rdr-to`,
    and a few others—are performed immediately. This can lead to situations in which
    a packet has been transformed by a `match` rule and it no longer matches criteria
    in a filtering rule that appears later in the rule set that it otherwise would
    have matched if the transformation hadn’t already occurred. One fairly basic example
    is a `match` rule that applies `nat-to` on the external interface, placed before
    any `pass` rules in the rule set. Once the `nat-to` action has been applied, any
    filtering criteria that would have matched the packet’s original source address
    will no longer match the packet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: This greater versatility made some rule sets harder to debug (typically those
    with several `match` rules that perform transformations), and it became clear
    that a new logging option was needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The PF developers had been eyeing the logging code for a rewrite for some time,
    and by the time the logging system was rewritten for the OpenBSD 4.9 release,
    the restructured code made it easy to introduce the log option `matches` to help
    debug such rule sets and to help track a packet’s path through rule sets where
    several sets of `match` or `pass` rules could transform the packet.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Adding `log (matches)` to a rule forces the logging of all matched rules once
    a packet matches a rule containing a `log (matches)` clause. Once such a match
    occurs, all subsequent rules will also be logged. As a result, you can use targeted
    `log (`**`matches`**`)` statements to trace a packet’s path through your loaded
    rule set, making it much easier to untangle complicated rule sets.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this simple rule set with NAT. The `log (matches)` rule
    is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our test host is a workstation in the local network with the IP address 192.168.103.44\.
    When the test host looks up a website somewhere on the Internet, the logged information
    looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The initial packet first matches `rule 3`, the `match log (matches)` rule quoted
    above the log fragment ➊. The next match is `rule 11` in our loaded rule set ➋,
    the initial `block all`, but the packet also matches `rule 17`, which lets it
    `pass in on em0` ➌. The next matching `rule 5` at ➍ is apparently a `match` rule
    that applies `nat-to` (note the changed source address). Finally, the packet passes
    `out on xl0` thanks to `rule 16` ➎, a matching `pass` rule.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: This example really has only one transformation (the `nat-to`), but the `log
    (matches)` feature allows us to follow the connection’s initial packet through
    all matching rules in the rule set, including the source address substitution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例实际上只有一个转换（`nat-to`），但`log (matches)`功能使我们能够跟踪连接的初始数据包，通过规则集中的所有匹配规则，包括源地址的替换。
- en: 'Logging All Packets: log (all)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录所有数据包：log (all)
- en: 'For most debugging and lightweight monitoring purposes, logging the first packet
    in a connection provides enough information. However, sometimes you may want to
    log all packets that match certain rules. To do so, use the `(all)` logging option
    in the rules you want to monitor. After making this change to our minimal rule
    set, we have the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数调试和轻量级监控目的，记录连接中的第一个数据包就提供了足够的信息。然而，有时你可能希望记录所有匹配某些规则的数据包。为此，在你想要监控的规则中使用`(all)`日志选项。对我们的最小规则集做出这个更改后，我们得到了以下内容：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This option makes the logs quite a bit more verbose. To illustrate just how
    much more data `log (all)` generates, we’ll use the following rule set fragment,
    which passes domain name lookups and network time synchronizations:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项使得日志变得更加冗长。为了说明`log (all)`生成的日志数据有多少，我们将使用以下规则集片段，它包含了域名查找和网络时间同步的内容：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With these rules in place, here’s an example of what happens when a Russian
    name server sends a domain name request to a server in our network:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些规则设置好后，以下是一个示例，展示当一个俄罗斯域名服务器向我们网络中的服务器发送域名请求时会发生什么：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We now have six entries instead of just one.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有六条记录，而不仅仅是一条。
- en: Even with all but `port domain` filtered out by `tcpdump`, adding `log (all)`
    to one or more rules considerably increases the amount of data in your logs. If
    you need to log all traffic but your gateway’s storage capacity is limited, you
    may find yourself shopping for additional storage, and the added I/O activity
    may in fact have a negative impact on performance. Also, recording and storing
    traffic logs with this level of detail is likely to have legal implications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通过`tcpdump`过滤掉所有除`port domain`外的数据，向一个或多个规则添加`log (all)`也会显著增加日志中的数据量。如果你需要记录所有流量，但网关的存储容量有限，你可能会发现自己需要购买额外的存储设备，而增加的I/O活动实际上可能对性能产生负面影响。此外，以这种细节级别记录和存储流量日志很可能会带来法律影响。
- en: Log Responsibly!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 负责任地记录日志！
- en: Creating logs of any kind could have surprising consequences, including some
    legal implications. Once you start storing log data generated by your network
    traffic, you’re creating a store of information about your users. There may be
    good technical and business reasons to store logs for extended periods, but logging
    just enough data and storing it for just the right amount of time can be a fine
    art.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任何类型的日志都可能带来意想不到的后果，包括一些法律影响。一旦你开始存储由网络流量生成的日志数据，你就在创建关于用户的信息存储库。存储日志数据长时间的技术和商业理由可能是合理的，但仅记录足够的数据并将其存储在适当的时间内，是一门精细的艺术。
- en: You probably have some idea of the practical issues related to generating log
    data, such as arranging for sufficient storage to retain enough log data long
    enough to be useful. The legal implications will vary according to your location.
    Some countries and territories have specific requirements for handling log data,
    along with restrictions on how that data may be used and how long logs can be
    retained. Others require service providers to retain traffic logs for a specific
    period of time, in some cases with a requirement to deliver any such data to law
    enforcement upon request. Make sure you understand the legal issues before you
    build a logging infrastructure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经对生成日志数据的实际问题有了一些了解，比如安排足够的存储空间，以便保留足够多的日志数据并且能够保持足够长的时间以便使用。法律影响会根据你所在的地区有所不同。某些国家和地区有关于如何处理日志数据的具体要求，并且对这些数据如何使用和保留日志的时间有着限制。其他地方要求服务提供商在特定的时间段内保留流量日志，在某些情况下还要求在执法部门提出请求时提供相关数据。在建立日志基础设施之前，确保你了解法律问题。
- en: Logging to Several pflog Interfaces
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录到多个pflog接口
- en: Versions of PF newer than OpenBSD 4.1 make it possible to direct your log data
    to more than one `pflog` interface. In OpenBSD 4.1, the `pflog` interface became
    a *cloneable* device, meaning that you can use `ifconfig` commands to create several
    `pflog` interfaces, in addition to the default `pflog0`. This makes it possible
    to record the log data for different parts of your rule set to separate `pflog`
    interfaces, and it makes it easier to process the resulting data separately if
    necessary.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 4.1 之后的 PF 版本中，你可以将日志数据定向到多个`pflog`接口。在 OpenBSD 4.1 中，`pflog`接口成为了一个*可克隆*设备，这意味着你可以使用`ifconfig`命令创建多个`pflog`接口，除了默认的`pflog0`之外。这使得将不同规则集部分的日志数据记录到不同的`pflog`接口成为可能，如果需要，还可以更方便地单独处理这些数据。
- en: Moving from the default single `pflog0` interface to several `pflog` interfaces
    requires some changes to your setup that are subtle but effective. To log to several
    interfaces, make sure that all the log interfaces your rule set uses are created.
    You don’t need to create the devices before the rule set is loaded; if your rule
    set logs to a nonexistent interface, the log data is simply discarded.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从默认的单一`pflog0`接口转移到多个`pflog`接口需要对你的设置进行一些微妙但有效的修改。为了将日志记录到多个接口，请确保你规则集中使用的所有日志接口都已创建。你不需要在加载规则集之前创建这些设备；如果你的规则集记录到一个不存在的接口，日志数据会被简单地丢弃。
- en: 'When tuning your setup to use several `pflog` interfaces, you’ll most likely
    add the required interfaces from the command line, like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当调整你的设置以使用多个`pflog`接口时，你很可能会通过命令行添加所需的接口，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Specify the log device when you add the `log` keyword to your rule set, as
    follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的规则集中添加`log`关键字时，指定日志设备，如下所示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For a more permanent configuration on OpenBSD, create a *hostname. pflog1* file
    containing only `up` and similar *hostname.pflogN* files for any additional logging
    interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OpenBSD 上更永久的配置，创建一个包含仅有`up`的*hostname.pflog1*文件，以及针对任何额外日志接口的类似*hostname.pflogN*文件。
- en: 'On FreeBSD, the configuration of the cloned `pflog` interfaces belongs in your
    *rc.conf* file in the following form:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上，克隆的`pflog`接口的配置应包含在你的*rc.conf*文件中，格式如下：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As of this writing, cloning `pflog` interfaces on NetBSD isn’t an option.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，NetBSD 上的`pflog`接口克隆尚不可用。
- en: As you saw in [Chapter 6](ch06.html "Chapter 6. Turning the Tables for Proactive
    Defense"), directing log information for different parts of your rule set to separate
    interfaces makes it possible to feed different parts of the log data PF produces
    to separate applications. This makes it easier to have programs like `spamlogd`
    process only the relevant information, while you feed other parts of your PF log
    data to other log-processing programs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第6章](ch06.html "第6章. 为主动防御翻盘")中看到的，将日志信息定向到规则集的不同部分并分配到不同的接口使得可以将 PF 生成的日志数据的不同部分输送到不同的应用程序。这使得像`spamlogd`这样的程序仅处理相关信息，而你可以将
    PF 日志数据的其他部分传输给其他日志处理程序。
- en: Logging to syslog, Local or Remote
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将日志记录到 syslog，本地或远程
- en: One way to avoid storing PF log data on the gateway itself is to instruct your
    gateway to log to another machine. If you already have a centralized logging infrastructure
    in place, this is a fairly logical thing to do, even if PF’s ordinary logging
    mechanisms weren’t really designed with traditional `syslog`-style logging in
    mind.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 避免将 PF 日志数据存储在网关本身的一种方式是指示网关将日志记录到另一台机器。如果你已经有了集中式日志基础设施，尽管 PF 的普通日志机制并未专门设计为传统的`syslog`风格的日志记录，但这仍然是一个相当合乎逻辑的做法。
- en: As any old BSD hand will tell you, the traditional `syslog` system log facility
    is a bit naive about managing the data it receives over UDP from other hosts,
    with denial-of-service attacks involving full disks one frequently mentioned danger.
    There’s also the ever-present risk that log information will be lost under high
    load on either individual systems or the network. Therefore, consider setting
    up remote logging *only* if all hosts involved communicate over a well-secured
    and properly dimensioned network. On most BSDs, `syslogd` isn’t set up by default
    to accept log data from other hosts. (See the `syslogd` man page for information
    about how to enable listening for log data from remote hosts if you plan to use
    remote `syslog` logging.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如任何老牌 BSD 用户所告诉你的，传统的 `syslog` 系统日志设施在处理它从其他主机通过 UDP 接收到的数据时有些天真，经常提到的一个危险是磁盘填满的拒绝服务攻击。还有一个永远存在的风险是，在高负载下，无论是个别系统还是网络，都可能丢失日志信息。因此，考虑在所有相关主机通过一个安全且适当规划的网络进行通信时，*仅*设置远程日志记录。在大多数
    BSD 系统中，默认情况下，`syslogd` 并没有配置为接受来自其他主机的日志数据。（如果你计划使用远程 `syslog` 日志记录，请参见 `syslogd`
    手册页，了解如何启用监听来自远程主机的日志数据。）
- en: 'If you’d still like to do your PF logging via `syslog`, the following is a
    short recipe for how to accomplish this. In ordinary PF setups, `pflogd` copies
    the log data to the log file. When you want to store the log data on a remote
    system, you should disable `pflog`’s data accumulation by changing daemon’s startup
    options in *rc.conf.local* (on OpenBSD), like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然希望通过 `syslog` 来进行 PF 日志记录，以下是一个简短的教程，介绍如何实现这一目标。在普通的 PF 配置中，`pflogd` 会将日志数据复制到日志文件中。当你希望将日志数据存储在远程系统上时，你应该通过修改
    *rc.conf.local* 文件（在 OpenBSD 上）来禁用 `pflog` 的数据收集，像这样：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On FreeBSD and NetBSD, change the `pflog_flats=` setting line in *rc.conf.*
    Then kill the `pflogd` process. Next, make sure that the log data, now no longer
    collected by `pflogd`, is transmitted in a meaningful way to your log-processing
    system instead. This step has two parts: First, set up your system logger to transmit
    data to the log-processing system, and then use `tcpdump` with `logger` to convert
    the data and inject it into the `syslog` system.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 和 NetBSD 上，修改 *rc.conf* 文件中的 `pflog_flats=` 设置行。然后终止 `pflogd` 进程。接下来，确保不再由
    `pflogd` 收集的日志数据以有意义的方式传输到你的日志处理系统中。这个步骤分为两部分：首先，配置系统日志程序将数据传输到日志处理系统，然后使用 `tcpdump`
    和 `logger` 将数据转换并注入到 `syslog` 系统中。
- en: 'To set up `syslogd` to process the data, choose your *log facility*, *log level*,
    and *action* and put the resulting line in */etc/syslog.conf*. These concepts
    are very well explained in `man syslog.conf`, which is required reading if you
    want to understand system logs. The *action* part is usually a file in a local
    file-system. For example, if you’ve already set up the system logger at *`loghost.example.com`*
    to receive your data, choose log facility `local2` with log level `info` and enter
    this line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 `syslogd` 来处理数据，选择你的 *日志设施*、*日志级别* 和 *动作*，然后将生成的行添加到 */etc/syslog.conf*
    文件中。这些概念在 `man syslog.conf` 中有很好的解释，如果你想理解系统日志，这是必读的。*动作* 部分通常是本地文件系统中的一个文件。例如，如果你已经设置好系统日志程序在
    *`loghost.example.com`* 接收数据，那么选择日志设施 `local2` 和日志级别 `info`，并输入以下行：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once you’ve made this change, restart `syslogd` to make it read the new settings.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此更改后，重新启动 `syslogd` 以使其读取新的设置。
- en: 'Next, set `tcpdump` to convert the log data from the `pflog` device and feed
    it to `logger`, which will then send it to the system logger. Here, we reuse the
    `tcpdump` command from the basic examples earlier in this chapter, with some useful
    additions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置 `tcpdump` 将日志数据从 `pflog` 设备转换并传递给 `logger`，然后 `logger` 会将其发送到系统日志程序。在这里，我们重复使用本章早些时候示例中的
    `tcpdump` 命令，并添加了一些有用的内容：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `nohup` command makes sure the process keeps running even if it doesn’t
    have a controlling terminal or it’s put in the background (as we do here with
    the trailing `&`). The `-l` option to the `tcpdump` command specifies line-buffered
    output, which is useful for redirecting to other programs. The `logger` option
    adds the tag `pf` to identify the PF data in the stream and specifies log priority
    with the `-p` option as `local2.info`. The result is logged to the file you specify
    on the logging host, with entries that will look something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`nohup` 命令确保即使进程没有控制终端或者被放到后台（正如我们在这里使用 `&` 处理的那样），它仍会继续运行。`tcpdump` 命令的 `-l`
    选项指定行缓冲输出，这对于重定向到其他程序非常有用。`logger` 选项为数据流添加标签 `pf`，以标识 PF 数据，并使用 `-p` 选项将日志优先级设置为
    `local2.info`。结果会被记录到你在日志主机上指定的文件中，日志条目将类似于以下内容：'
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This log fragment shows mainly Web-browsing activities from a client in a NATed
    local network, as seen from the gateway’s perspective, with accompanying domain
    name lookups.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段日志片段主要显示了来自NAT本地网络中客户端的Web浏览活动，从网关的视角来看，并伴随有域名查找。
- en: Tracking Statistics for Each Rule with Labels
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标签跟踪每个规则的统计信息
- en: The sequential information you get from retrieving log data basically tracks
    packet movements over time. In other contexts, the sequence or history of connections
    is less important than aggregates, such as the number of packets or bytes that
    have matched a rule since the counters were last cleared.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从获取日志数据时得到的顺序信息基本上是跟踪数据包随时间的移动。在其他情况下，连接的序列或历史记录不如总数重要，例如自从计数器最后一次重置以来，匹配规则的数据包或字节的数量。
- en: 'At the end of [Chapter 2](ch02.html "Chapter 2. PF Configuration Basics"),
    you saw how to use `pfctl -s info` to view the global aggregate counters, along
    with other data. For a more detailed breakdown of the data, track traffic totals
    on a per-rule basis with a slightly different form of `pfctl` command, such as
    `pfctl -vs rules`, to display statistics along with the rule, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章 PF 配置基础")的结尾，你看到如何使用`pfctl -s info`查看全局汇总计数器以及其他数据。要更详细地分析数据，按规则逐个跟踪流量总数，使用稍微不同形式的`pfctl`命令，比如`pfctl
    -vs rules`，以显示带规则的统计信息，如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The format of this output is easy to read, and it’s obviously designed for contexts
    in which you want to get an idea of what’s going on at a glance. If you specify
    even more verbose output with `pfctl -vvs rules`, you’ll see essentially the same
    display, with rule numbers added. On the other hand, the output from this command
    isn’t very well suited for feeding to a script or other program for further processing.
    To extract these statistics and a few more items in a script-friendly format—and
    to make your own decisions about which rules are worth tracking)—use rule *labels*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出的格式易于阅读，显然是为那些希望快速了解发生了什么的场景设计的。如果你指定更详细的输出，使用`pfctl -vvs rules`，你会看到基本相同的显示，只不过添加了规则编号。另一方面，这个命令的输出并不非常适合用作脚本或其他程序进一步处理的数据。要以脚本友好的格式提取这些统计数据和其他一些项，并根据自己的需求决定哪些规则值得追踪——请使用规则*标签*。
- en: Labels do more than identify rules for processing specific kinds of traffic;
    they also make it easier to extract the traffic statistics. By attaching labels
    to rules, you can store certain extra data about parts of your rule set. For example,
    you could use labeling to measure bandwidth use for accounting purposes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 标签不仅仅是为了标识处理特定类型流量的规则；它们还使得提取流量统计信息变得更容易。通过将标签附加到规则，你可以存储一些关于规则集部分的额外数据。例如，你可以使用标签来测量带宽使用情况以供计费目的。
- en: In the following example, we attach the labels `mail-in` and `mail-out` to our
    `pass` rules for incoming and outgoing mail traffic, respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将标签`mail-in`和`mail-out`分别附加到入站和出站邮件流量的`pass`规则上。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once you’ve loaded the rule set with labels, check the data using `pfctl -vsl`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你加载了带标签的规则集，使用`pfctl -vsl`检查数据：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This output contains the following information:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出包含以下信息：
- en: ➊ The label
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➊ 标签
- en: ➋ The number of times the rule has been evaluated
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➋ 规则被评估的次数
- en: ➌ The total number of packets passed
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➌ 传递的数据包总数
- en: ➍ The total number of bytes passed
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➍ 传递的总字节数
- en: ➎ The number of packets passed in
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➎ 传递的数据包数量
- en: ➏ The number of bytes passed in
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➏ 传入的字节数
- en: ➐ The number of packets passed out
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➐ 传递出去的数据包数量
- en: ➒ The number of bytes passed out
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ➒ 传递出去的字节数
- en: The format of this list makes it very well suited for parsing by scripts and
    applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表的格式非常适合脚本和应用程序进行解析。
- en: The labels accumulate data from the time the rule set is loaded until their
    counters are reset. And, in many contexts, it makes sense to set up a `cron` job
    that reads label values at fixed intervals and then puts those values into permanent
    storage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 标签会从规则集加载时起累积数据，直到它们的计数器被重置。在许多情况下，设置一个`cron`作业，定期读取标签值并将这些值存入永久存储是有意义的。
- en: If you choose to run the data collection at fixed intervals, consider collecting
    the data using `pfctl -vsl -z`. The `z` option resets the counters once `pfctl`
    has read them, with the result that your data collector will then fetch *periodic
    data*, accumulated since the command or the script was last run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择定期运行数据收集，考虑使用`pfctl -vsl -z`来收集数据。`z`选项在`pfctl`读取计数器后重置它们，这样你的数据收集器就会获取*周期性数据*，即自从命令或脚本上次运行以来的累积数据。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Rules with macros and lists expand to several distinct rules. If your rule
    set contains rules with lists and macros that have a label attached, the in-memory
    result will be a number of rules, each with a separate, identically named label
    attached to it. While this may lead to confusing `sudo pfctl -vsl` output, it
    shouldn’t be a problem as long as the application or script that receives the
    data can interpret the data correctly by adding up the totals for the identical
    labels.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用宏和列表的规则会扩展为几个不同的规则。如果你的规则集中包含带标签的列表和宏，则内存中的结果将是多个规则，每个规则都附带一个相同名称的标签。虽然这可能导致`sudo
    pfctl -vsl`的输出令人困惑，但只要接收数据的应用程序或脚本能够通过汇总相同标签的总数正确解释数据，就不应该成为问题。*'
- en: If this type of data collection sounds useful to you, it’s also worth noting
    that recent PF versions offer the option of collecting traffic metadata as NetFlow
    or IPFIX data. See [Collecting NetFlow Data with pflow(4)](ch09.html#collecting_netflow_data_with_pflowleft_p
    "Collecting NetFlow Data with pflow(4)") for details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种数据收集方式对你有用，那么值得注意的是，最近的PF版本提供了将流量元数据收集为NetFlow或IPFIX数据的选项。有关详细信息，请参见[使用pflow(4)收集NetFlow数据](ch09.html#collecting_netflow_data_with_pflowleft_p
    "使用pflow(4)收集NetFlow数据")。
- en: Additional Tools for PF Logs and Statistics
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PF日志和统计信息的附加工具
- en: One other important component of staying in control of your network is having
    the ability to keep an updated view of your system’s status. In this section,
    we’ll examine a selection of monitoring tools that you may find useful. All the
    tools presented here are available either in the base system or via the package
    system on OpenBSD and FreeBSD (and, with some exceptions, on NetBSD).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 保持对网络的控制还需要能够实时查看系统的状态。在本节中，我们将介绍一些你可能会觉得有用的监控工具。这里介绍的所有工具要么在基础系统中可用，要么可以通过OpenBSD和FreeBSD的包管理系统获得（在NetBSD中也有，但有一些例外）。
- en: Keeping an Eye on Things with systat
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用systat监控系统
- en: If you’re interested in seeing an instant snapshot of the traffic passing through
    your systems right now, the `systat` program on OpenBSD offers several useful
    views. In [Chapter 7](ch07.html "Chapter 7. Traffic Shaping with Queues and Priorities"),
    we looked briefly at `systat queues` to see how traffic was assigned to queues
    in our traffic-shaping rule sets. Here, we’ll review some additional useful options.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣查看当前通过你系统传递的流量的即时快照，OpenBSD上的`systat`程序提供了几个有用的视图。在[第7章](ch07.html "第7章
    流量整形与队列优先级")中，我们简要查看了`systat queues`，以了解流量是如何在我们的流量整形规则集中分配到队列的。这里，我们将回顾一些其他有用的选项。
- en: The `systat` program is available on all BSD operating systems, in slightly
    different versions. On all systems, `systat` offers views of system statistics,
    with some minor variations in syntax and output. For example, the `queues` view
    is one of several `systat` views available in recent OpenBSD versions, but not
    in FreeBSD or NetBSD as of this writing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`systat`程序在所有BSD操作系统中都有，版本略有不同。在所有系统中，`systat`都提供系统统计视图，语法和输出有一些小的差异。例如，`queues`视图是最近OpenBSD版本中的多个`systat`视图之一，但在本文写作时，FreeBSD和NetBSD中并没有这个视图。'
- en: 'For a more general view of the current state table than that offered by `queues`,
    try `systat states`, which gives a listing very similar to the `top(1)` process
    listing. Here’s an example of typical `systat states` output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要比`queues`提供的当前状态表更全面的视图，可以尝试`systat states`，它提供了一个与`top(1)`进程列表非常相似的输出。以下是典型的`systat
    states`输出示例：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If your states don’t fit on one screen, just page through the live display.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的状态列表无法完全显示在一个屏幕上，只需通过实时显示翻页查看。
- en: 'Similarly, `systat rules` displays a live view of packets, bytes, and other
    statistics for your loaded rule set, as in this example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`systat rules`会显示加载的规则集的实时数据，包括数据包、字节和其他统计信息，如以下示例所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `systat rules` view is especially useful because it offers a live view into
    the fully parsed and loaded rule set. For example, if your rule set behaves oddly,
    the `rules` view can point you in the right direction and show you the flow of
    packets.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`systat rules`视图特别有用，因为它提供了对完全解析并加载的规则集的实时查看。例如，如果你的规则集表现异常，`rules`视图可以帮助你找出问题所在，并显示数据包的流动情况。'
- en: The `systat` program also offers a view that presents the same data you’d get
    via `pfctl -s status` on the command line. The following example shows part of
    the output of `systat pf`. The `systat pf` view offers more information than will
    fit on most screens, but you can page through the live display of the data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`systat` 程序还提供了一个视图，呈现你通过命令行使用 `pfctl -s status` 获取的相同数据。下面的示例显示了 `systat pf`
    的一部分输出。`systat pf` 视图提供了比大多数屏幕显示更多的信息，但你可以分页浏览数据的实时显示。'
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `systat` program offers quite a few other views, including network-related
    ones, such as `netstat`, `vmstat` for virtual memory statistics, and `iostat`
    for input/output statistics by device. You can cycle through all `systat` views
    using the left and right cursor keys. (See `man systat` for full details.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`systat` 程序提供了许多其他视图，包括与网络相关的视图，例如 `netstat`、用于虚拟内存统计的 `vmstat` 以及用于按设备显示输入/输出统计的
    `iostat`。你可以通过左右光标键切换所有 `systat` 视图。（请参阅 `man systat` 获取详细信息。）'
- en: Keeping an Eye on Things with pftop
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 pftop 监控事物
- en: 'If your system doesn’t have a `systat` version with the PF-related views, you
    can still keep an eye on what’s passing into and out of your network in real time
    using Can Erkin Acar’s `pftop`. This command shows a running snapshot of your
    traffic. `pftop` isn’t included in the base system, but it’s available as a package—in
    ports on OpenBSD and FreeBSD as *sysutils/pftop*^([[44](#ftn.ch09fn01)]) and on
    NetBSD via `pkgsrc` as *sysutils/pftop*. Here’s an example of its output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统没有包含带有 PF 相关视图的 `systat` 版本，你仍然可以使用 Can Erkin Acar 的 `pftop` 实时监控进出网络的流量。这个命令显示的是流量的运行快照。`pftop`
    并不包含在基础系统中，但作为一个包可以使用——在 OpenBSD 和 FreeBSD 的 ports 系统中为 *sysutils/pftop*^([[44](#ftn.ch09fn01)])，在
    NetBSD 通过 `pkgsrc` 提供 *sysutils/pftop*。以下是其输出的一个示例：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can use `pftop` to sort your connections by a number of different criteria,
    including by PF rule, volume, age, and source and destination addresses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `pftop` 按多个不同的标准对连接进行排序，包括按 PF 规则、流量、连接时间、源地址和目标地址等。
- en: Graphing Your Traffic with pfstat
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 pfstat 绘制流量图
- en: Once you have a system up and running and producing data, a graphical representation
    of traffic data is a useful way to view and analyze your data. One way to graph
    your PF data is with `pfstat`, a utility developed by Daniel Hartmeier to extract
    and present the statistical data that’s automatically generated by PF. The `pfstat`
    tool is available via the OpenBSD package system or as the port *net/pfstat*,
    via the FreeBSD ports system as *sysutils/pfstat*, and via NetBSD `pkgsrc` as
    *sysutils/pfstat*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的系统启动并运行并开始生成数据，图形化表示流量数据是查看和分析数据的有用方式。绘制 PF 数据图表的一种方法是使用 `pfstat`，这是由 Daniel
    Hartmeier 开发的一个工具，用于提取并呈现 PF 自动生成的统计数据。`pfstat` 工具可以通过 OpenBSD 的包系统或作为端口 *net/pfstat*，通过
    FreeBSD 的 ports 系统作为 *sysutils/pfstat*，以及通过 NetBSD `pkgsrc` 提供作为 *sysutils/pfstat*
    来获得。
- en: The `pfstat` program collects the data you specify in the configuration file
    and presents that data as JPG or PNG graphics files. The data source can be either
    PF running on the local system via the */dev/pf* device or data collected from
    a remote computer running the companion `pfstatd` daemon.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`pfstat` 程序收集你在配置文件中指定的数据，并以 JPG 或 PNG 图形文件的形式呈现这些数据。数据源可以是通过 */dev/pf* 设备在本地系统上运行的
    PF，或者是通过运行配套的 `pfstatd` 守护进程的远程计算机收集的数据。'
- en: To set up `pfstat`, you simply decide which parts of your PF data you want to
    graph and how, and then you write the configuration file and start `cron` jobs
    to collect the data and generate your graphs. The program comes with a well-annotated
    sample configuration file and a useful man page. The sample configuration is a
    useful starting point for writing your own configuration file. For example, the
    following *pfstat.conf* fragment is very close to one you’ll find in the sample
    configuration:^([[45](#ftn.ch09fn02)])
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 `pfstat`，你只需决定哪些 PF 数据需要绘制成图，并且如何绘制，然后编写配置文件并启动 `cron` 作业以收集数据并生成图表。该程序附带一个注释良好的示例配置文件和一个有用的手册页。示例配置文件是编写自己配置文件的一个有用起点。例如，下面的
    *pfstat.conf* 片段非常接近你在示例配置中会看到的内容：^([[45](#ftn.ch09fn02)])
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The configuration here starts off with three `collect` statements, where each
    of the data series is assigned a unique numeric identifier. Here, we capture the
    number of insertions, removals, and searches in the state table. Next up is the
    `image` definition, which specifies the data that is to be graphed. The `from`
    line specifies the period to display (`from 1 days to now` means that only data
    collected during the last 24 hours is to be displayed). `width` and `height` specify
    the graph size measured in number of pixels in each direction. The `graph` statements
    specify how the data series are displayed as well as the graph legends. Collecting
    state insertions, removals, and searches once a minute and then graphing the data
    collected over one day produces a graph roughly like the one in [Figure 9-1](ch09.html#state_table_statisticscomma_24-hour_time
    "Figure 9-1. State table statistics, 24-hour time scale").
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的配置从三个`collect`语句开始，每个数据系列都分配了一个唯一的数字标识符。在这里，我们捕获状态表中的插入、删除和查找次数。接下来是`image`定义，它指定要绘制的数据。`from`行指定要显示的时间段（`from
    1 days to now`表示只显示过去24小时收集的数据）。`width`和`height`指定图形的大小，单位为每个方向的像素数。`graph`语句指定如何显示数据系列以及图例。每分钟收集一次状态插入、删除和查找数据，然后将收集的数据绘制成一天的数据图，产生的图形大致与[图9-1](ch09.html#state_table_statisticscomma_24-hour_time
    "图9-1。状态表统计，24小时时间尺度")中的图形相似。
- en: '![State table statistics, 24-hour time scale](httpatomoreillycomsourcenostarchimages2127165.png.jpg)Figure 9-1. State
    table statistics, 24-hour time scale'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![状态表统计，24小时时间尺度](httpatomoreillycomsourcenostarchimages2127165.png.jpg)图9-1。状态表统计，24小时时间尺度'
- en: The graph can be tweaked to provide a more detailed view of the same data. For
    example, to see the data for the last hour in a slightly higher resolution, change
    the period to `from 1 hours to now` and the dimensions to `width 600 height 300`.
    The result is something like the graph in [Figure 9-2](ch09.html#state_table_statisticscomma_1-hour_time
    "Figure 9-2. State table statistics, 1-hour time scale").
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调整图形以提供相同数据的更详细视图。例如，要以稍高的分辨率查看过去一小时的数据，可以将时间段更改为`from 1 hours to now`，并将尺寸设置为`width
    600 height 300`。结果类似于[图9-2](ch09.html#state_table_statisticscomma_1-hour_time
    "图9-2。状态表统计，1小时时间尺度")中的图形。
- en: '![State table statistics, 1-hour time scale](httpatomoreillycomsourcenostarchimages2127167.png)Figure 9-2. State
    table statistics, 1-hour time scale'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![状态表统计，1小时时间尺度](httpatomoreillycomsourcenostarchimages2127167.png)图9-2。状态表统计，1小时时间尺度'
- en: The `pfstat` home page at *[http://www.benzedrine.cx/pfstat.html](http://www.benzedrine.cx/pfstat.html)*
    contains several examples, with demonstrations in the form of live graphs of the
    data from the *benzedrine.cx* domain’s gateways. By reading the examples and tapping
    your own knowledge of your traffic, you should be able to create `pfstat` configurations
    that are well suited to your site’s needs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`pfstat`主页位于*[http://www.benzedrine.cx/pfstat.html](http://www.benzedrine.cx/pfstat.html)*，其中包含了多个示例，并展示了来自*benzedrine.cx*域网关的实时数据图。通过阅读这些示例并结合你自己对流量的了解，你应该能够创建适合你站点需求的`pfstat`配置。'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In addition to `pfstat`, other system-monitoring packages offer at least some
    PF-monitoring features. One such package is the popular `symon` utility, which
    is usually configured with the `symon` data gatherer on all monitored systems
    and at least one host with `symux` and the optional `syweb` Web interface. Based
    on round-robin database tool (RRDtool), `symon` has a useful interface for recording
    PF data and offers a useful graphical interface for displaying PF statistics via
    the `syweb` Web interface. `symon` is available as a port or package on OpenBSD
    and FreeBSD as `sysutils/symon`, and the `syweb` Web interface is available as
    `www/syweb`.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了`pfstat`，其他系统监控工具包至少提供了一些PF监控功能。其中一个工具包是流行的`symon`实用程序，它通常与`symon`数据收集器一起配置，在所有监控的系统上运行，至少有一个主机安装了`symux`和可选的`syweb`
    Web接口。`symon`基于循环数据库工具（RRDtool），它提供了一个用于记录PF数据的有用接口，并通过`syweb` Web接口展示PF统计信息的图形化界面。`symon`可以作为端口或包在OpenBSD和FreeBSD上使用，作为`sysutils/symon`，`syweb`
    Web接口则作为`www/syweb`提供。*'
- en: Collecting NetFlow Data with pflow(4)
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用pflow(4)收集NetFlow数据
- en: '*NetFlow* is a network data collection and analysis method that has spawned
    many supporting tools for recording and analyzing data about TCP/IP connections.
    NetFlow originated at Cisco and over time has become an essential feature in various
    network equipment as a tool for network management and analysis.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The NetFlow data model defines a network *flow* as a unidirectional sequence
    of packets with the same source and destination IP address and protocol. For example,
    a TCP connection will appear in NetFlow data as two flows: one in each direction.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: PF data can be made available to NetFlow tools via the `pflow(4)` pseudo-interface
    that was introduced in OpenBSD 4.5 along with the `pflow` state option. Essentially,
    all the information you’d expect to find in a NetFlow-style flow record is easily
    derived from the data PF keeps in the state table, and the `pflow` interface offers
    a straightforward way to export PF state-table data in this processing-friendly
    and well-documented format. As with other logging, you enable NetFlow data collection
    in your PF rule set on a per-rule basis.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: A complete NetFlow-based network-monitoring system consists of several distinct
    parts. The NetFlow data originates at one or more *sensors* that generate data
    about network traffic. The sensors forward data about the flows to a *collector*,
    which stores the data it receives. Finally, a *reporting* or *analysis* system
    lets you extract and process the data.^([[46](#ftn.ch09fn03)])
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the NetFlow Sensor
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The NetFlow sensor requires two components: one or more configured `pflow(4)`
    devices and at least one `pass` rule in your rule set with the `pflow` state option
    enabled. The `pflow` interfaces are created with two required parameters: the
    flow source IP address and flow destination’s IP address and port. Here’s an example
    of the `ifconfig` command for the */etc/hostname.pflow0* file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From the command line, use this command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In both cases, this command sets up the host to send NetFlow data with a flow
    source address 192.0.2.1 to a collector that should listen for NetFlow data at
    192.0.2.105, UDP port 3001.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*It’s possible to set up several `pflow` devices with separate flow destinations.
    It’s not currently possible, however, to specify on a per-rule basis which `pflow`
    device should receive the generated data.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'After enabling the `pflow` device, specify in */etc/pf.conf* which `pass` rules
    should provide NetFlow data to the sensor. For example, if your main concern is
    to collect data on your clients’ email traffic to IPv4 hosts, this rule would
    set up the necessary sensor:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `pflow` was first introduced to PF, the immediate reaction from early adopters
    was that more likely than not, they’d want to add the `pflow` option to most `pass`
    rules in their rule sets. This led PF developer Henning Brauer to introduce another
    useful PF feature—the ability to set *state defaults* that apply to all rules
    unless otherwise specified. For example, if you add the following line at the
    start of your rule set, all `pass` rules in the configuration will generate NetFlow
    data to be exported via the `pflow` device.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With at least one `pflow` device configured and at least one rule in your *pf.conf*
    that generates data for export via the `pflow` device, you’re almost finished
    setting up the sensor. You may still need to add a rule, however, that allows
    the UDP data to flow from the IP address you specified as the flow data source
    to the collector’s IP address and target port at the flow destination. Once you’ve
    completed this last step, you should be ready to turn your attention to collecting
    the data for further processing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow Data Collecting, Reporting, and Analysis
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your site has a NetFlow-based collection and analysis infrastructure in place,
    you may already have added the necessary configuration to feed the PF-originated
    data into the data collection and analysis system. If you haven’t yet set up a
    flow-analysis environment, there are a number of options available.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenBSD packages system offers three NetFlow collector and analysis packages:
    `flow-tools`, `flowd`, and `nfdump`.^([[47](#ftn.ch09fn04)]) All three systems
    have a dedicated and competent developer and user community as well as various
    add-ons, including graphical Web interfaces. `flow-tools` is the main component
    in many sites’ flow-analysis setups. The `nfdump` fans point to the `nfsen` analysis
    package that integrates the `nfdump` tools in a powerful and flexible Web-based
    analysis frontend that will, among other things, display the command-line equivalent
    of your GUI selections. You’ll find the command-line display useful when you need
    to drill down further into the data than the selections in the GUI allow. You
    can copy the command displayed in the GUI and make any further adjustments you
    need on the `nfdump` command line in a shell session or script to extract the
    exact data you want.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Collector
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The choice of collector is somewhat tied to the choice of analysis package.
    Perhaps because the collectors tend to store flow data in their own unique formats,
    most reporting and analysis backends are developed with a distinctive bias for
    one or the other collector.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of your choice of NetFlow collector, the familiar logging caveats
    apply: Detailed traffic log information will require storage. In the case of NetFlow,
    each flow will generate a record of fairly fixed size, and anecdotal evidence
    indicates that even modest collection profiles on busy sites can generate gigabytes
    of NetFlow data per day. The amount of storage you’ll need is directly proportional
    to the number of connections and how long you keep the original NetFlow data.
    Finally, recording and storing traffic logs with this level of detail is likely
    to have legal implications.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Collectors generally offer filtering features that let you discard data about
    specific hosts or networks or even discard some parts of the NetFlow records themselves,
    either globally or for data about specific hosts or networks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate some basic NetFlow collection and how to extract a subset of the
    collected data for further analysis, we’ll use `flowd`, developed by long-time
    OpenBSD developer Damien Miller and available via the package systems (on OpenBSD
    as *net/flowd* and on FreeBSD as *net-mgmt/flowd*).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen to use `flowd` here mainly because it was developed to be small,
    simple, and secure. As you’ll see, `flowd` still manages to be quite useful and
    flexible. Flow data operations with other tools will differ in some details, but
    the underlying principles remain the same.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: When compared to other NetFlow collector suites, `flowd` is very compact, with
    only two executable programs—the collector daemon `flowd` and the flow-filtering
    and presentation program `flowd-reader`—as well as the supporting library and
    controlling configuration file. The documentation is adequate, if a bit terse,
    and the sample */etc/flowd.conf* file contains a generous number of comments.
    Based on the man pages and the comments in the sample configuration file, it shouldn’t
    take you long to create a useful collector configuration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'After stripping out any comment lines—using `grep -v \# /etc/flowd.conf` or
    similar—a very basic `flowd` configuration could look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'While this configuration barely contains more information than the `pflow`
    interface’s configuration in the earlier description of setting up the sensor,
    it does include two important items:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The `logfile` line tells us where the collected data is to be stored (and reveals
    that `flowd` tends to store all data in a single file).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final line tells us that `flowd` will store all fields in the data it receives
    from the designated flow source.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this configuration in place, start up the `flowd` daemon, and almost immediately
    you should see the */var/log/flowd* file grow as network traffic passes through
    your gateway and flow records are collected. After a while, you should be able
    to look at the data using `flowd`’s companion program `flowd-reader`. For example,
    with all fields stored, the data for one name lookup from a host on the NATed
    local network looks like this in `flowd-reader`’s default view:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice that the lookup generates two flows: one in each direction.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The first flow is identified mainly by the time it was received, followed by
    the protocol used (protocol 17 is UDP, as */etc/protocols* will tell you). The
    connection had both TCP and TOS flags unset, and the collector received the data
    from our gateway at 192.0.2.1\. The flow’s source address was 192.0.2.254, source
    port 55108, and the destination address was 192.0.2.1, source port 53, conventionally
    the DNS port. The flow consisted of 1 packet with a payload of 62 octets. The
    return flow was received by the collector at the same time, and we see that this
    flow has the source and destination reversed, with a slightly larger payload of
    129 octets. `flowd-reader`’s output format lends itself to parsing by regular
    expressions for postprocessing in reporting tools or plotting software.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that this data is all anyone would ever want to know about
    any particular set of network flows, but it’s possible to extract even more detailed
    information. For example, using the `flowd-reader -v` option for verbose output,
    you might see something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `gateway` field indicates that the sensor itself served as the gateway for
    this connection. You see a list of the interfaces involved (the `in_if` and `out_if`
    values), the sensor’s system uptime (`sys_uptime_ms`), and a host of other parameters—such
    as `AS` numbers (`src_AS` and `dst_AS`)—that may be useful for statistics or filtering
    purposes in various contexts. Once again, the output is ideally suited to filtering
    via regular expressions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to rely on external software for the initial filtering on the
    data you collect from your `pflow` sensor. `flowd` itself offers a range of filtering
    features that make it possible to store only the data you need. One approach is
    to put the filtering expressions in the *flowd.conf*, as in the following example
    (with the comments stripped to save space):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can choose to store only certain fields in the flow records. For example,
    in configurations where there’s only one collector or agent, the `agent` field
    serves no useful purpose and doesn’t need to be stored. In this configuration,
    we choose to store only the source and destination address and port, the number
    of packets, and the number of octets.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'You can limit the data you store even further. The macros `internalnet` and
    `unwired` expand to two NATed local networks, and the four `discard` lines following
    the macro definitions mean that `flowd` discards any data it receives about flows
    with either source or destination addresses in either of those local networks.
    The result is a more compact set of data, tailored to your specific needs, and
    you see only routable addresses and the address of the sensor gateway’s external
    interface:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Even with the verbose option, `flowd-reader`’s display reveals only what you
    explicitly specify in the filtering configuration:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Fortunately, `flowd` doesn’t force you to make all your filtering decisions
    when your collector receives the flow data from the sensor. Using the `-f` flag,
    you can specify a separate file with filtering statements to extract specific
    data from a larger set of collected flow data. For example, to see HTTP traffic
    to your Web server, you could write a filter that stores only flows with your
    Web server’s address and TCP port 80 as the destination or flows with your Web
    server and TCP port 80 as the source:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Assuming you stored the filter in *towebserver.flowdfilter*, you could then
    extract traffic matching your filtering criteria from */var/log/flowd*, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In addition to the filtering options demonstrated here, the `flowd` filtering
    functions take a number of other options. Some of those options will be familiar
    from other filtering contexts such as PF, including a range of network-oriented
    parameters; others are more oriented to extracting data on flows originating at
    specific dates or time periods and other storage-oriented parameters. The full
    story, as always, is found in `man flowd.conf`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve extracted the data you need, you have several tools available for
    processing and presenting your data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Collecting NetFlow Data with pfflowd
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For systems that don’t support NetFlow data export via `pflow`, NetFlow support
    is available via the `pfflowd` package. As we already saw in the previous section,
    PF state table data maps very well to the NetFlow data model, and `pfflowd` is
    intended to record state changes from the local system’s `pfsync` device. Once
    enabled, `pfflowd` acts as a NetFlow sensor that converts `pfsync` data to NetFlow
    format for transmission to a NetFlow collector on the network.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The `pfflowd` tool was written and is maintained by Damien Miller and is available
    from *[http://www.mindrot.org/projects/pfflowd/](http://www.mindrot.org/projects/pfflowd/)*
    as well as through the package systems on OpenBSD and FreeBSD as *net/pfflowd*.
    The lack of `pfsync` support on NetBSD means that `pfflowd` isn’t available on
    that platform as of this writing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Tools and PF-Related SNMP MIBs
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Simple Network Management Protocol (SNMP)* was designed to let network administrators
    collect and monitor key data about how their systems run and change configurations
    on multiple network nodes from a centralized system.^([[48](#ftn.ch09fn05)]) The
    SNMP protocol comes with a well-defined interface and a method for extending the
    *management information base (MIB)*, which defines the managed devices and objects.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Both proprietary and open source network management and monitoring systems generally
    have SNMP support in one form or the other, and in some products, it’s a core
    feature. On the BSDs, SNMP support has generally come in the form of the `net-snmp`
    package, which provides the tools you need to retrieve SNMP data and to collect
    data for retrieval by management systems. The package is available on OpenBSD
    as *net/net-snmp*, on FreeBSD as *net-mgmt/net-snmp*, and on NetBSD as *net/net-snmp*.
    OpenBSD’s `snmpd` (written mainly by Reyk Floeter) debuted as part of the base
    system in OpenBSD 4.3 and implements all required SNMP functionality. (See `man
    snmpd` and `man snmpd.conf` for details.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: There are MIBs to make PF data available to SNMP monitoring. Joel Knight maintains
    the MIBs for retrieving data on PF, CARP, and OpenBSD kernel sensors, and he offers
    them for download from *[http://www.packetmischief.ca/openbsd/snmp/](http://www.packetmischief.ca/openbsd/snmp/)*.
    The site also offers patches to the `net-snmp` package to integrate the OpenBSD
    MIBs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: After installing the package and the extension, your SNMP-capable monitoring
    systems will be able to watch PF data in any detail you desire. (FreeBSD’s `bsnmpd`
    includes a PF module. See the `bsnmpd` man page for details.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Log Data as the Basis for Effective Debugging
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we walked through the basics of collecting, displaying, and
    interpreting data about a running system with PF enabled. Knowing how to find
    and use information about how your system behaves is useful for several purposes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of the status of a running system is useful in itself, but the
    ability to read and interpret log data is even more essential when testing your
    setup. Another prime use for log data is to track the effect of changes you make
    in the configuration, such as when tuning your system to give optimal performance.
    In the next chapter, we’ll focus on checking your configuration and tuning it
    for optimal performance, based on log data and other observations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: ^([[44](#ch09fn01)]) On OpenBSD, all `pftop` functionality is included in various
    `systat` views, as described in the previous section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '^([[45](#ch09fn02)]) The color values listed in the configuration example would
    give you a graph with red, blue, and green lines. For the print version of this
    book, we changed the colors to grayscale values: `0 192 0` became `105 105 105`,
    `0 0 255` became `192 192 192`, and `255 0 0` became `0 0 0`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: ^([[46](#ch09fn03)]) For a more in-depth treatment of network analysis with
    NetFlow-based tools, see *Network Flow Analysis* by Michael W. Lucas (No Starch
    Press, 2010).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: ^([[47](#ch09fn04)]) The actively maintained project home pages for `flow-tools`
    and `nfdump` are *[http://code.google.com/p/flow-tools/](http://code.google.com/p/flow-tools/)*
    and *[http://nfdump.sourceforge.net/](http://nfdump.sourceforge.net/)*. (The older
    versions should still be available from *[http://www.splintered.net/sw/flow-tools/](http://www.splintered.net/sw/flow-tools/).*)
    The `nfsen` Web frontend has a project page at *[http://nfsen.sourceforge.net/](http://nfsen.sourceforge.net/).*
    For the latest information about `flowd`, visit *[http://www.mindrot.org/flowd.html](http://www.mindrot.org/flowd.html).*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: ^([[48](#ch09fn05)]) The protocol debuted with RFC 1067 in August 1988 and is
    now in its third major version as defined in RFCs 3411 through 3418.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
