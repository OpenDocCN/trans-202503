- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RANDOM
    WALKS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">随机行走</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'So far, this book has introduced a variety of algorithms focused on achieving
    specific goals. This chapter considers algorithms that seek to do something a
    bit different: inducing *random behavior* on graphs. Analyzing random movement
    through a graph allows us to model and study systems with nondeterministic behavior
    such as randomized network routing or real-world social interactions.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书介绍了多种旨在实现特定目标的算法。本章考虑了那些寻求做些不同事情的算法：在图上引入*随机行为*。分析图上的随机移动使我们能够模拟和研究具有非确定性行为的系统，例如随机化网络路由或现实世界中的社交互动。
- en: Random walks on graphs have a rich mathematical history that extends well beyond
    the scope of this book. This chapter provides an overview of random walks, an
    introduction of how to analyze them with Markov chains, and code for implementing
    a random walk over a graph. We consider the types of questions we can investigate
    and systems we can model with random walks, such as gambling and luck-based board
    games. Finally, we consider how we can reconstruct underlying graphs from sample
    observations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图上的随机行走有着丰富的数学历史，远超本书的范围。本章概述了随机行走，介绍了如何用马尔科夫链分析它们，并提供了在图上实现随机行走的代码。我们探讨了通过随机行走可以调查的问题类型以及能够建模的系统，如赌博和基于运气的棋盘游戏。最后，我们考虑如何通过样本观察重建潜在的图。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Introducing Random Walks</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">引入随机行走</samp>'
- en: 'A *random walk* on a graph is a sequence of nodes where the next node in the
    sequence is chosen randomly based on some probability distribution. We denote
    the *transition probability* from node *u* to node *v* as:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图上的*随机行走*是一个节点序列，其中序列中的下一个节点是基于某种概率分布随机选择的。我们用 *u* 到 *v* 的*转移概率*表示：
- en: '*p*(*u* → *v*) where 0 ≤ *p*(*u* → *v*) ≤ 1'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*u* → *v*) 其中 0 ≤ *p*(*u* → *v*) ≤ 1'
- en: This means that whenever we are at a node *u*, we select the next node from
    *u*’s neighbors using the given probability distribution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们处于节点 *u* 时，我们根据给定的概率分布从 *u* 的邻居中选择下一个节点。
- en: We can visualize a random walk as a tourist who absolutely refuses to plan ahead.
    Convinced that serendipity produces the best vacations, they set out to explore
    the city with neither a map nor a clue as to where they are going. When they reach
    an intersection, they consider possible routes and choose one at random. The tourist
    makes each decision in isolation, without thought to past or future transitions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将随机行走想象成一个完全拒绝提前计划的游客。相信偶然性能带来最好的假期，他们在没有地图或目的地线索的情况下出发，开始探索这座城市。当他们到达一个交叉口时，会考虑可能的路线并随机选择一条。游客每次做出决定时，都会独立考虑，而不考虑过去或未来的转变。
- en: 'We use the graph structure to restrict probabilities in a few ways. First,
    we limit movement to nodes that are connected to the current node by an edge.
    In the case of directed graphs, this must be an edge in the correct direction:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用图的结构以几种方式限制概率。首先，我们限制只能在通过边连接当前节点的节点之间移动。在有向图的情况下，这必须是朝正确方向的边：
- en: '*p*(*u* → *v*) = 0 if (*u*, *v*) ∉ *E*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*u* → *v*) = 0 如果 (*u*, *v*) ∉ *E*'
- en: 'In other words, our tourist has no chance of traversing from point *u* to point
    *v* unless there is a road connecting them. For the sake of clarity, in this chapter
    we also require the probability to be greater than zero if the edge exists:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们的游客如果没有道路连接点 *u* 和点 *v*，就无法从 *u* 到 *v*。为了清晰起见，本章还要求如果边存在，则概率必须大于零：
- en: '*p*(*u* → *v*) > 0 if (*u*, *v*) ∈ *E*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*u* → *v*) > 0 如果 (*u*, *v*) ∈ *E*'
- en: This means that our tourist can, in theory, traverse all the roads in the city.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的游客理论上可以遍历城市中的所有道路。
- en: 'Second, transition probabilities must sum to 1.0 over all outgoing adjacent
    edges:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，所有出发邻接边的转移概率之和必须为 1.0：
- en: ∑v *p*(*u* → *v*) = 1 for every *u* ∈ *V*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ∑v *p*(*u* → *v*) = 1 对于每个 *u* ∈ *V*
- en: This restricts the probabilities to form a valid distribution. Every node must
    include at least one outgoing edge. In directed graphs, we can use self-loops
    *p*(*u* → *u*) > 0 to model cases where the walk does not proceed to a new node.
    This constraint corresponds to the tourist always having at least one path along
    which to proceed, even if that path loops back to the current location.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这限制了概率的分布，使其形成有效的分布。每个节点必须至少包含一条出口边。在有向图中，我们可以使用自环*p*(*u* → *u*) > 0 来模拟漫步未前往新节点的情况。这个约束意味着游客始终至少有一条路径可以继续前进，即使这条路径最终回到当前的位置。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Probabilities in
    Random Walks</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">随机漫步中的概率</samp>
- en: The simplest random walk is one where we choose among the outgoing edges with
    equal probability. In this case, our hypothetical tourist chooses from the current
    intersection’s streets completely at random. If the intersection has two outgoing
    edges, the tourist chooses either with a 50 percent probability. If the intersection
    has four outgoing edges, they each get a probability of 25 percent. [Figure 13-1](#fig13-1)
    shows an undirected and unweighted graph (a) and the corresponding transition
    probabilities out of each node (b).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的随机漫步是我们以相等的概率从出口边选择。在这种情况下，我们假设的游客完全随机地从当前交叉口的街道中选择。如果交叉口有两条出口边，游客选择其中一条的概率为50%。如果交叉口有四条出口边，每条边的概率为25%。[图13-1](#fig13-1)展示了一个无向且无权重的图（a）以及每个节点的相应转移概率（b）。
- en: '![(A) shows an undirected graph with 4 nodes and 5 edges. Node 0 is adjacent
    to two edges (0, 1) and (0, 2). (B) shows a directed graph with 4 nodes and 10
    edges. Each edge is labeled with a fraction. Node 0 has outgoing edges (0, 1)
    and (0, 2) with labels of a half.](../images/f13001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![(A)展示了一个包含4个节点和5条边的无向图。节点0相邻的两条边分别是(0, 1)和(0, 2)。(B)展示了一个包含4个节点和10条边的有向图。每条边都标有一个分数。节点0有两条出口边(0,
    1)和(0, 2)，它们的标签都是1/2。](../images/f13001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: An undirected
    graph (a) and its random walk probabilities (b)</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-1：无向图（a）及其随机漫步概率（b）</samp>
- en: 'While we discuss random walks on both directed and undirected graphs, we always
    model these systems as directed graphs because, in many cases, the transition
    probabilities between two nodes will not be symmetric. In formal terms:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们讨论了有向和无向图上的随机漫步，但我们始终将这些系统建模为有向图，因为在许多情况下，两个节点之间的转移概率不会是对称的。用正式的术语来说：
- en: '*p*(*u* → *v*) ≠ *p*(*v* → *u*)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*u* → *v*) ≠ *p*(*v* → *u*)'
- en: In [Figure 13-1(b)](#fig13-1), for example, the probability of moving from node
    0 to node 1 is 1/2, while the probability of moving in the reverse direction is
    only 1/3\. For our wandering tourist, the probability of traveling between two
    intersections depends on how many roads branch out from the current intersection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图13-1(b)](#fig13-1)中，例如，从节点0到节点1的概率是1/2，而从节点1到节点0的概率只有1/3。对于我们的游荡游客而言，旅行在两个交叉口之间的概率取决于当前交叉口有多少条路分出。
- en: 'We can use weighted graphs to model more realistic scenarios by assigning different
    probabilities to each edge and storing them in the edge weights. We constrain
    these probabilities (the edge weights) such that the sum of probabilities over
    all outgoing edges equals 1.0\. [Figure 13-2](#fig13-2) shows an example as a
    directed, weighted graph. A random walk at node 3 has three possible next states:
    it can move to node 1 with a probability of 0.2 or to node 2 with a probability
    of 0.6, or it can stay at node 3 (via a self-loop) with a probability of 0.2.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用加权图来模拟更现实的场景，通过为每条边分配不同的概率，并将这些概率存储在边的权重中。我们对这些概率（边的权重）进行约束，使得所有出口边的概率和等于1.0。[图13-2](#fig13-2)展示了一个作为有向加权图的示例。在节点3的随机漫步中，有三个可能的下一状态：它可以以0.2的概率移动到节点1，或以0.6的概率移动到节点2，或者以0.2的概率停留在节点3（通过自环）。
- en: '![a directed graph with 4 nodes and 10 edges. Each edge is labeled with a number
    between 0 and 1.](../images/f13002.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含4个节点和10条边的有向图。每条边标有一个介于0和1之间的数字。](../images/f13002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: A directed graph
    with transition probabilities</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-2：带有转移概率的有向图</samp>
- en: These more general graphs correspond to a tourist who is probabilistically influenced
    by factors beyond the number of roads. They tend to head toward areas with more
    interesting architecture or follow the smell of coffee. When arriving at a particular
    four-way intersection, they have a surprising 90 percent chance of taking a left
    toward a street of cafés.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更一般的图对应于一个受概率性因素影响的游客，这些因素超出了道路数量。他们倾向于朝着具有更有趣建筑的区域走去，或者跟随咖啡的香气。当他们到达一个特定的四岔路口时，他们有惊人的90%的概率向左转，朝着一条咖啡馆街道走去。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Random Walks as Markov
    Chains</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">作为马尔科夫链的随机游走</samp>
- en: Random walks over a graph’s edges are one example of a *Markov chain* or *Markov
    model*, a system for which the probability of the next state depends solely on
    the current state. Each step is taken without consideration to the previous path,
    a property known as *time invariance*. We draw the connection to Markov chains
    to allow us to tap into the vast amount of related analysis. The full breadth
    of research into analyzing different types of Markov chains far exceeds the scope
    of this book. In this chapter, we will only briefly touch upon a few concepts
    and terminology that help analyze random walks and demonstrate their modeling
    power.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图的边上的随机游走是 *马尔科夫链* 或 *马尔科夫模型* 的一种示例，这种系统的下一个状态的概率仅依赖于当前状态。每一步的选择不考虑之前的路径，这种特性称为
    *时间不变性*。我们将其与马尔科夫链相联系，以便利用大量相关的分析。对不同类型的马尔科夫链的全面研究远远超出了本书的范围。在本章中，我们将简要介绍一些有助于分析随机游走的概念和术语，并展示其建模能力。
- en: The time invariance property corresponds to our wandering tourist’s habit of
    considering only the paths open in front of them. They do not consider pesky details
    such as where they have already been, how many steps they have taken, or even
    what time of day it is. While this is not optimal for conventionally regular activities
    such as eating and sleeping, the tourist resolutely adheres to their randomized
    vacationing principles.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 时间不变性特性对应于我们徘徊游客的习惯，即只考虑他们面前开放的路径。他们不考虑烦人的细节，例如他们已经去过哪里，走了多少步，甚至是一天中的哪个时段。虽然对于像吃饭和睡觉这样常规的活动来说，这并不是最理想的，但这位游客坚定地遵循着他们随机的度假原则。
- en: 'In probability and statistics references, these transition probabilities are
    often written as *p*(*X*t | *X*t [– 1]) to indicate the probability of being in
    state *X*t at timestep *t* given that the system was in state *X*t [– 1] at time
    *t* – 1\. Combining this shorthand with the graph-based notation, we get the following
    equation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在概率和统计的参考文献中，这些转移概率通常写作 *p*(*X*t | *X*t [– 1])，表示在时刻 *t* 系统处于状态 *X*t 的概率，前提是系统在时刻
    *t* – 1 时处于状态 *X*t [– 1]。将这种简写与基于图的符号结合，我们得到以下方程：
- en: '*p*(*u* → *v*) = *p*(*X*t = *v* | *X*t [– 1] = *u*)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*u* → *v*) = *p*(*X*t = *v* | *X*t [– 1] = *u*)'
- en: 'Given the independence of each transition, we can compute the probability of
    an entire path [*v*[0], *v*[1], *v*[2], . . . , *v*k] from a fixed starting node
    *v*[0] by multiplying the probability of each transition:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于每个转移的独立性，我们可以通过将每个转移的概率相乘来计算从固定起始节点 *v*[0] 到整个路径 [*v*[0], *v*[1], *v*[2],
    . . . , *v*k] 的概率：
- en: '*p*([*v*[0], *v*[1], *v*[2], . . . , *v*k]) = ∏i [= 1 to] k *p*(*X*t = *v*i
    | *X*t [– 1] = *v*i [– 1])'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*([*v*[0], *v*[1], *v*[2], . . . , *v*k]) = ∏i [= 1 to] k *p*(*X*t = *v*i
    | *X*t [– 1] = *v*i [– 1])'
- en: Markov chains are useful for a wide variety of tasks for which transitions are
    independent of previous paths. Artificial intelligence uses a variety of (more
    powerful) Markov models to simulate or reason about a range of real phenomena,
    from understanding speech to decision-making with autonomous agents. For example,
    the *hidden Markov model* is a staple of machine learning that uses random transitions
    over unseen states, where each state produces noisy output. Efficient algorithms
    exist for estimating the underlying states from the output or even learning both
    the transition probabilities and output distributions from sample data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔科夫链对于许多任务非常有用，尤其是那些转移与之前路径无关的任务。人工智能使用各种（更强大的）马尔科夫模型来模拟或推理各种现实现象，从理解语音到使用自主代理进行决策。例如，*隐马尔科夫模型*
    是机器学习中的一个基础，它使用随机的转移状态，这些状态的输出是噪声。已经有高效的算法可以从输出中估计潜在的状态，甚至通过样本数据学习转移概率和输出分布。
- en: In contrast, the random walks we consider in this chapter represent a particularly
    simple Markov model. The current state (node) is visible at each state and the
    decisions are fully random. As we will see, however, even these seemingly simple
    models can provide a wealth of simulative and analytical power.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，本章中我们考虑的随机游走代表了一个特别简单的马尔可夫模型。每个状态（节点）在每个时刻都是可见的，决策是完全随机的。然而，正如我们将看到的，即使这些看似简单的模型，也能提供丰富的模拟和分析能力。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transition Probabilities</samp>
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转移概率</samp>
- en: When modeling a random walk on a graph using the edge weights, we require the
    weights out of each node to form a valid probability distribution. We can test
    whether the edge weights of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    data structure form a valid probability distribution by iterating over each node
    and checking that the sum of outgoing edge weights is 1.0, as shown in [Listing
    13-1](#list13-1).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用边的权重对图进行随机游走建模时，我们要求每个节点的出边权重形成一个有效的概率分布。我们可以通过遍历每个节点并检查其出边的权重总和是否为1.0，来测试我们的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>数据结构的边权重是否形成了一个有效的概率分布，正如在[Listing
    13-1](#list13-1)中所示。
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Checking the
    validity of probabilities stored in the edge weights</samp>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: 检查存储在边权重中的概率的有效性</samp>'
- en: The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to iterate over each node and check that the weights of its outgoing edges form
    a valid probability distribution. First, it extracts the node’s edge list and
    checks whether it is empty ❶. If so, there is nowhere to go from that node and
    the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The
    constraint that the sum probabilities out of a node equal 1 requires that every
    node must have at least one outgoing edge with a nonzero weight, even if it is
    a self-loop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历每个节点，并检查其出边的权重是否形成一个有效的概率分布。首先，它提取该节点的边列表，并检查该列表是否为空❶。如果为空，说明从该节点没有出路，代码返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>。节点的出边权重总和为1的约束要求每个节点必须至少有一条权重不为零的出边，即使它是自环。
- en: The code uses a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate over the outgoing edges. It checks that each edge has a valid
    probability between 0.0 and 1.0, immediately returning <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    if not ❷, then adds the current the edge weight to the total. After reviewing
    all edges, the code checks if the total weight is 1.0, allowing for a small accumulation
    of floating-point errors ❸. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    only if all these conditions pass for all nodes and edges.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用第二个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历每个出边。它检查每个边的概率是否在0.0到1.0之间，如果不是，立即返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">False</samp>❷，然后将当前边的权重加到总和中。在检查完所有的边后，代码会检查总权重是否为1.0，以允许少量的浮动点误差❸。只有当所有节点和边满足这些条件时，才会返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Matrix Formulation</samp>
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">矩阵表示</samp>
- en: 'The matrix representation of a graph is useful when analyzing properties of
    a random walk on the graph and is commonly used in statistics and machine learning
    texts to describe random walks. In the matrix representation, transition probabilities
    are often specified using a *transition matrix* (*M*) where the value in row *i*
    and column *j* of the matrix corresponds to the probability of moving to node
    *j* given that the walk is at node *i*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图的矩阵表示在分析图上随机游走的性质时非常有用，并且在统计学和机器学习的文献中常用于描述随机游走。在矩阵表示中，转移概率通常通过*转移矩阵*（*M*）来指定，其中矩阵的第*i*行第*j*列的值对应于从节点*i*到节点*j*的概率：
- en: M[*i*][*j*] = *p*(*i* → *j*)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: M[*i*][*j*] = *p*(*i* → *j*)
- en: 'We can even reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    data structure from [Chapter 1](chapter1.xhtml) to store these values. Because
    we restrict the entries to be probabilities, we impose additional restrictions
    to the values in <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以重用 [第 1 章](chapter1.xhtml) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    数据结构来存储这些值。由于我们将条目限制为概率，我们对 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> 列表施加了额外的限制：
- en: 0 ≤ <samp class="SANS_TheSansMonoCd_W5Regular_11">connections[i][j]</samp> ≤
    1 for all <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>，有
    0 ≤ <samp class="SANS_TheSansMonoCd_W5Regular_11">connections[i][j]</samp> ≤ 1。
- en: ∑j <samp class="SANS_TheSansMonoCd_W5Regular_11">connections[i][j]</samp> =
    1 for all <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>，有 ∑j <samp class="SANS_TheSansMonoCd_W5Regular_11">connections[i][j]</samp>
    = 1。
- en: These constraints mirror the restrictions placed on edge weights earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束与先前对边权重施加的限制相对应。
- en: We can use matrix math to model the effect of taking a random step. We let *V*t
    be a vector of probabilities such that *V*t [*u*] is the probability that our
    random walk is at node *u* (so 0 ≤ *V*t [*u*] ≤ 1 for each *u* and ∑u *V*t [*u*]
    = 1) at time step *t*. For example, we would use *V*t = [0.5, 0.4, 0.0, 0.1] to
    represent the probability that our walk is at each of the four nodes in [Figure
    13-2](#fig13-2). The vector indicates there is a 50 percent chance of being at
    node 0, a 40 percent chance of being at node 1, a 0 percent chance of being at
    node 2, and a 10 percent chance of being at node 4.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用矩阵运算来模拟随机步伐的效果。我们令 *V*t 为概率向量，使得 *V*t [*u*] 表示我们在时间步 *t* 时随机漫步位于节点 *u*
    的概率（因此对于每个 *u*，0 ≤ *V*t [*u*] ≤ 1 且 ∑u *V*t [*u*] = 1）。例如，我们可以使用 *V*t = [0.5,
    0.4, 0.0, 0.1]* 来表示在 [Figure 13-2](#fig13-2) 中我们的漫步位于四个节点的概率。该向量表示在节点 0 处有 50%
    的概率，在节点 1 处有 40% 的概率，在节点 2 处有 0% 的概率，在节点 4 处有 10% 的概率。
- en: The vector *V*[0] gives the probability of starting the walk at each of the
    nodes. For example, *V*[0] = [1.0, 0.0, 0.0, 0.0] indicates a deterministic start
    at node 0, while *V*[0] = [0.5, 0.5, 0.0, 0.0] indicates an equal chance of starting
    from either node 0 or node 1\. The vector *V*[1] then gives the probability of
    being at each node after randomly starting the walk according to *V*[0] and taking
    a single additional random step. *V*[2] indicates the probability after two steps
    of the random walk and so forth.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 向量 *V*[0] 给出了从每个节点开始漫步的概率。例如，*V*[0] = [1.0, 0.0, 0.0, 0.0] 表示从节点 0 确定性地开始漫步，而
    *V*[0] = [0.5, 0.5, 0.0, 0.0] 表示从节点 0 或节点 1 开始漫步的机会相等。接下来，向量 *V*[1] 给出了根据 *V*[0]
    随机开始漫步并执行一步随机漫步后，位于每个节点的概率。*V*[2] 表示随机漫步进行两步后的概率，依此类推。
- en: 'We can use matrix algebra with the transition matrix *M* to compute subsequent
    probability distributions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用矩阵代数与转移矩阵 *M* 来计算后续的概率分布：
- en: '*V*t [+ 1] = *V*t *M*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*V*t [+ 1] = *V*t *M*'
- en: Each entry *V*t [+ 1] [*u*] gives us the probability that our random walk is
    at node *u* at the following time step *t* + 1\. We can even add a method to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> class that performs
    this computation, as shown in [Listing 13-2](#list13-2).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目 *V*t [+ 1] [*u*] 给出了我们在下一时间步 *t* + 1 时随机漫步位于节点 *u* 的概率。我们甚至可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    类中添加一个方法来执行此计算，如 [Listing 13-2](#list13-2) 所示。
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Simulating a
    single step of a random walk on a graph</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: 在图上模拟单步随机漫步</samp>'
- en: The code starts by checking that the incoming vector <samp class="SANS_TheSansMonoCd_W5Regular_11">Vt</samp>
    has the correct length and, if not, raising an error. It then creates a result
    vector <samp class="SANS_TheSansMonoCd_W5Regular_11">Vnext</samp> and uses a pair
    of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to perform
    the computation. It returns the new vector of probabilities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查传入向量 <samp class="SANS_TheSansMonoCd_W5Regular_11">Vt</samp> 的长度是否正确，如果不正确，则抛出错误。然后，它创建一个结果向量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Vnext</samp>，并使用一对嵌套的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环执行计算。最后，它返回新的概率向量。
- en: '> <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '> <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>'
- en: '*As mentioned in [Chapter 1](chapter1.xhtml), the code in this book uses a
    list of lists to represent matrices for the purposes of illustration. For the
    sake of efficiency, production code for this computation should use a library
    that supports efficient matrix operations, such as* <samp class="SANS_TheSansMonoCd_W7Italic">numpy</samp>*.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如在[第一章](chapter1.xhtml)中提到的，本书中的代码使用列表的列表来表示矩阵，以便于说明。为了提高效率，生产环境中的代码应该使用支持高效矩阵操作的库，例如*
    <samp class="SANS_TheSansMonoCd_W7Italic">numpy</samp>*。*'
- en: 'The computation for simulating a random step also works from a deterministic
    state: *V*[*u*] = 1 for exactly one node *u*. By then multiplying *V*t [+ 1] =
    *V*t *M*, we get the probability distribution of where our random walk will be
    after exactly one step away from *u*. We can repeat this process by multiplying
    by *M* again as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟随机步长的计算也适用于一个确定性状态：*V*[*u*] = 1 对于恰好一个节点 *u*。然后通过乘以 *V*t [+ 1] = *V*t *M*，我们得到随机游走在从
    *u* 出发后恰好一步的概率分布。我们可以通过再次乘以 *M* 来重复这一过程，如下所示：
- en: '*V*t [+ 2] = *V*t *M M*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*V*t [+ 2] = *V*t *M M*'
- en: This gives us the probability distribution of nodes that are reached in exactly
    two steps.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了恰好经过两步后到达的节点的概率分布。
- en: 'Alternatively, we can extend our matrix notation such that *M*t is the transition
    matrix for a random walk of exactly *t* steps, so *M*t [*u*][*v*] is the probability
    of transitioning from node *u* to node *v* in exactly *t* steps. We can compute
    this matrix directly using matrix multiplication:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以扩展我们的矩阵表示，使得 *M*t 成为一个随机游走的转移矩阵，表示恰好 *t* 步的随机游走，因此 *M*t [*u*][*v*] 是从节点
    *u* 到节点 *v* 在恰好 *t* 步内的转移概率。我们可以直接通过矩阵乘法来计算这个矩阵：
- en: '*M*t = ∏I [= 1 to] t *M*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*t = ∏I [= 1 到] t *M*'
- en: While the matrix formulation is useful for describing and analyzing the properties
    of a random walk, the code in the remainder of the chapter uses the adjacency
    list representation of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class for consistency with the other chapters. All the functions can be adapted
    to work with the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然矩阵表示法对于描述和分析随机游走的性质很有用，但本章其余部分的代码使用了我们 <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    类的邻接表表示法，以保持与其他章节的一致性。所有函数都可以适配为与 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp>
    类一起使用。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用案例</samp>
- en: 'Random walks are used to model and analyze problems that involve non-deterministic
    behavior. Random behavior shows up in a wide range of real-world systems, from
    human interaction to the explicit randomness in some computer algorithms. In this
    section, we look at three example use cases: social networks, randomized explorations,
    and games of chance.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随机游走用于建模和分析涉及非确定性行为的问题。随机行为在许多现实世界的系统中都有出现，从人类互动到一些计算机算法中的显式随机性。在本节中，我们将看三个示例用例：社交网络、随机化探索和机会游戏。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Information Chains
    in Social Networks</samp>
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">社交网络中的信息链</samp>
- en: We can use random walks to model how a rumor spreads through a social network
    where the interactions have a random component. Determined not to gossip excessively,
    each person in the network resolves to pass information to only a single other
    person when they hear a rumor. However, they are bursting to share the latest
    gossip as soon as they hear it, so they share the news with the first person they
    come across. This is inherently a probabilistic selection, as they don’t know
    which friend they’ll run into first. After sharing their news, they are temporarily
    satisfied and hold off on discussing the rumor until it is shared with them again.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用随机游走来模拟谣言如何在社交网络中传播，其中的互动包含随机成分。每个人都决心不传播过多的闲言碎语，但一旦听到谣言，他们就迫不及待地想与某个人分享。因此，他们将新闻传给遇到的第一个人。这是一个概率性的选择，因为他们不知道首先会遇到哪个朋友。分享完新闻后，他们暂时满足，会等到别人再次传递这个谣言给他们时，才会继续讨论。
- en: We could model the social network as a graph where the edges represent the probability
    that each neighbor is the person with whom the rumor is shared. The rumor itself
    randomly walks the graph, getting passed from person to person.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将社交网络建模为一个图，其中边表示每个邻居是传递谣言的对象的概率。谣言本身随机在图中传播，逐个传递给不同的人。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploration</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">探索</samp>
- en: Previous chapters discussed numerous algorithms for deterministically exploring
    graphs, such as depth-first search or A* search. However, many real-world explorations
    involve a randomized element, such as weather-based path closures. Random walks
    allow us to model systems with such constraints.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节讨论了许多用于确定性地探索图的算法，如深度优先搜索或A*搜索。然而，许多现实世界中的探索涉及随机元素，比如基于天气的路径封闭。随机漫步允许我们模拟具有这些约束的系统。
- en: Consider the explorer from [Chapter 8](chapter8.xhtml) searching for a best
    path to an archeological site. The current conditions might add a random element
    to their exploration. When faced with a fork in the path, the northern route might
    have a 50 percent chance of being flooded out, while the southern route has a
    10 percent chance of being blocked by an angry swarm of hornets. Taking these
    probabilities into account, we could model their unpleasant journey through the
    jungle as a random walk.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[第8章](chapter8.xhtml)中提到的探险者，正在寻找通往考古遗址的最佳路径。当前的条件可能会为他们的探索增添随机因素。当面临路径的分岔时，北边的路线可能有50%的几率被洪水淹没，而南边的路线则有10%的几率被愤怒的黄蜂群堵住。考虑到这些概率，我们可以将他们穿越丛林的艰难旅程建模为一次随机漫步。
- en: We can use a similar approach to analyze robot path planning in dynamic environments.
    A search-and-rescue robot exploring a damaged building may run into different
    obstacles at different times, such as fires or flooded passages, and need to reroute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法来分析动态环境中的机器人路径规划。一个探索损坏建筑物的搜救机器人可能会在不同的时间遇到不同的障碍物，比如火灾或被淹没的通道，并需要重新规划路径。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Games of Chance</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">机会游戏</samp>
- en: We can also use a random walk to simulate the outcomes of games of chance. Graph
    nodes represent different game states, and the edges indicate the possible (probabilistic)
    changes in those states. For example, we can use the Markov chain shown in [Figure
    13-3](#fig13-3) to represent a gambler playing a one-dollar slot machine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用随机漫步来模拟机会游戏的结果。图节点表示不同的游戏状态，边表示这些状态的可能（概率）变化。例如，我们可以使用[图13-3](#fig13-3)所示的马尔可夫链来表示赌徒玩一美元老虎机的情况。
- en: '![A linear chain of nodes. Each node has a directed edge to the left with probability
    0.99 and an edge 9 nodes to the right with a probability of 0.01.](../images/f13003.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![一条线性节点链。每个节点都有一个指向左边的边，概率为0.99，还有一条指向右边9个节点的边，概率为0.01。](../images/f13003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: A subset of nodes
    for a gambler’s graph</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-3：赌徒图中的一个子集</samp>
- en: Each state represents the number of dollars in the gambler’s possession. Each
    pull of the slot machine decides the next state without regard to previous pulls
    or the gambler’s current financial situation. Maybe the machine has a 1 in 100
    chance of paying out 10 dollars, moving the gambler from state *k* to state *k*
    + 9, and a 99 in 100 of chance of paying out nothing, moving the gambler from
    state *k* to *k* – 1.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态表示赌徒手中的美元数量。每次拉动老虎机时，都会决定下一个状态，而不考虑之前的拉动或赌徒当前的财务状况。也许机器有1/100的几率支付10美元，将赌徒从状态*k*移动到状态*k*
    + 9，而99/100的几率什么也不支付，将赌徒从状态*k*移动到*k* - 1。
- en: As we model more complex games of chance, we need correspondingly more complex
    graphs. Later in this chapter we show how to use graphs to model luck-based board
    games. We discuss nodes that simultaneously represent multiple players’ states
    and the transitions among them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对更复杂的机会游戏进行建模，我们需要更复杂的图来表示这些情况。在本章稍后，我们将展示如何使用图来建模基于运气的桌面游戏。我们讨论了同时表示多个玩家状态的节点及其之间的转换。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Simulating Random Walks</samp>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">模拟随机漫步</samp>
- en: One powerful approach to understanding random walks and their underlying graph
    is to *repeatedly simulate* a random walk over the graph and analyze the paths
    taken. We simulate a random walk on a graph by repeatedly selecting the next state
    based on the probability distribution over the neighbors of the current state.
    As a prerequisite, we need a function to sample from a finite set of options with
    pre-specified probabilities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 理解随机游走及其底层图形的一个强大方法是*反复模拟*图上的随机游走并分析所走过的路径。我们通过反复选择基于当前状态邻居的概率分布来模拟图上的随机游走。作为先决条件，我们需要一个从有限选项集中按预定概率采样的函数。
- en: We provide a simple algorithm for illustration purposes that draws a random
    number uniformly within [0, 1) and checks to which neighbor it corresponds by
    iterating over each outgoing edge and accumulating the cumulative probability
    of the previous nodes. We are effectively breaking the range [0, 1) into regions
    for each option where the size of the region corresponds to the probability of
    that option. [Figure 13-4](#fig13-4) shows an example where 50 percent of the
    range leads to node 0, 20 percent leads to node 1, and 30 percent leads to node
    3.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个简单的算法进行说明，它在[0, 1)范围内均匀抽取一个随机数，并通过遍历每个出边，累积之前节点的累积概率，检查该随机数对应哪个邻居。我们实际上是将[0,
    1)范围划分为每个选项的区域，其中每个区域的大小对应于该选项的概率。[图 13-4](#fig13-4)展示了一个示例，其中50%的范围指向节点0，20%指向节点1，30%指向节点3。
- en: By tracking the cumulative probability seen so far while iterating over the
    options, we are tracking the start and end of each region and comparing it to
    the selected value. We want to find the bin whose region brackets our randomly
    selected value. As soon as we cross the bin edge where the cumulative value exceeds
    the randomly selected value, we know we have gone too far.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在遍历选项时跟踪目前为止看到的累积概率，我们在跟踪每个区域的起始和结束，并将其与选定值进行比较。我们想要找到一个区域，该区域的范围包含我们随机选择的值。只要跨过累积值超过随机选择值的区域边界，我们就知道走得太远了。
- en: '![A bar from 0.0 to 1.0 divided into three sections. The first section spans
    0.0 to 0.5 and is labeled node 0.](../images/f13004.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![从0.0到1.0的条形图分为三个部分。第一部分从0.0到0.5，标签为节点0。](../images/f13004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: The transition
    probability to three nodes and the corresponding cumulative probability</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-4：到三个节点的转移概率及其对应的累积概率</samp>
- en: The code for a random walk on a graph consists of a random number generation
    followed by a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop that iterates over the outgoing edges, as shown in [Listing 13-3](#list13-3).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图上的随机游走代码包括生成随机数，随后是一个单独的 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环，遍历出边，如[列表 13-3](#list13-3)所示。
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: Choosing the
    next node in a random walk</samp>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-3：在随机游走中选择下一个节点</samp>
- en: The code starts by drawing a random number from [0, 1) using Python’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">random</samp> library ❶. It then uses
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop over each outgoing
    edge to compute the total (cumulative) probability seen so far. The selected edge
    is the first one whose weight causes this cumulative probability to exceed the
    selected random number ❷. If the code makes it to the end of the list (due to
    imprecisions in how floating-point numbers are stored), the code simply returns
    the last edge ❸.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先使用 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp>
    库从[0, 1)范围内生成一个随机数 ❶。然后，它通过一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历每个出边来计算目前为止看到的总（累积）概率。选中的边是第一个其权重导致累积概率超过选定随机数的边 ❷。如果代码到达列表末尾（由于浮点数存储的精度问题），代码将简单地返回最后一条边
    ❸。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp>
    function in [Listing 13-3](#list13-3) does not perform any validity checks on
    the probability distribution leaving each node. This is intentional so as not
    to pay the cost of performing the check each time the function is called. Instead,
    I recommend checking the distributions for all nodes once using the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_valid_probability_graph()</samp>
    function from [Listing 13-1](#list13-1).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-3](#list13-3)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp>
    函数没有对每个节点离开的概率分布进行任何有效性检查。这是故意的，因为每次调用该函数时都不想支付进行检查的成本。相反，我建议使用[列表 13-1](#list13-1)中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_valid_probability_graph()</samp>
    函数，先检查所有节点的分布。'
- en: 'Given this helper function, the code to perform the random walk from a given
    starting node (<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>) is
    relatively short:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个辅助函数，从一个给定起始节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>）执行随机漫步的代码相对简短：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function starts by confirming that the graph’s weights represent a valid
    probability distribution and raising an error if not ❶. It then allocates a list
    <samp class="SANS_TheSansMonoCd_W5Regular_11">walk</samp> to store the results,
    sets the current node to the start node, and sets the first step in the walk to
    the start node. The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to iterate through each step, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp>
    function from [Listing 13-3](#list13-3) to continually select the next node from
    the current one ❷. The code adds the new node to the <samp class="SANS_TheSansMonoCd_W5Regular_11">walk</samp>
    list, which it returns after taking all the steps.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先确认图的权重表示一个有效的概率分布，如果没有则抛出错误 ❶。接着，它分配一个列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">walk</samp>
    来存储结果，将当前节点设置为起始节点，并将漫步的第一步设置为起始节点。代码使用一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环迭代每一步，使用[列表 13-3](#list13-3)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp>
    函数不断从当前节点选择下一个节点 ❷。代码将新节点添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">walk</samp>
    列表中，并在走完所有步骤后返回该列表。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Statistical Measures</samp>
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">统计度量</samp>
- en: Random walks are a powerful tool for understanding randomized systems and computing
    a variety of practical statistics measures. For example, we might want to find
    the probability of reaching a particular node or determine how many steps it will
    take to get there. These measures are useful in answering questions such as “What
    is the probability a gambler will lose all their money?” or “How long (on average)
    will it take a rumor to reach me?” or “If a tourist randomly wanders the city
    for years, how long will they spend at each location?”
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随机漫步是理解随机化系统和计算各种实用统计度量的有力工具。例如，我们可能想找到到达特定节点的概率，或确定需要多少步才能到达那里。这些度量在回答以下问题时非常有用：“一个赌徒输掉所有钱的概率是多少？”或者“一个谣言平均需要多长时间才能传到我这里？”或者“如果一个游客在城市中随机游荡多年，他们在每个地方会停留多久？”
- en: In this section, we briefly consider how such questions apply to the case of
    our wandering tourist and outline how to compute the answers. After considering
    the probability of reaching specific nodes and the average number of steps to
    do so, we analyze the long-term behavior of random walks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要考虑如何将这些问题应用于我们徘徊的游客案例，并概述如何计算答案。在考虑到到达特定节点的概率和所需平均步数后，我们分析了随机漫步的长期行为。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hitting and Absorption
    Time</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">到达与吸收时间</samp>
- en: The *hitting time* of a set of nodes *A* ⊂ *V* is the average number of steps
    a random walk must take before it first hits a node in *A* from a given starting
    node. For example, if *A* is the set of all intersections with cafés in the town
    our tourist is exploring, they might want to calculate the hitting time of that
    set to find out when they are likely to get their next cup of coffee.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*到达时间*指的是随机漫步必须采取的平均步数，直到它从一个给定的起始节点首次到达集合 *A* ⊂ *V* 中的一个节点。例如，如果 *A* 是我们游客正在探索的小镇上所有有咖啡馆的交叉路口的集合，他们可能想要计算这个集合的到达时间，以便了解他们可能何时能喝到下一杯咖啡。'
- en: If a random walk cannot leave the nodes in *A*, we refer to these hitting times
    as *absorption times* because the walk is absorbed into *A*. For example, in [Figure
    13-5](#fig13-5), node *k* forms an absorbing set. Once a walk arrives at node
    *k*, it stays there forever.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个随机游走无法离开子集*A*中的节点，我们称这些到达时间为*吸收时间*，因为游走已经被*A*吸收。例如，在[图13-5](#fig13-5)中，节点*k*形成了一个吸收集。一旦游走到达节点*k*，它将永远停留在那里。
- en: '![A node with multiple incoming edges and a single outgoing edge labeled 1.0
    that forms a self-loop.](../images/f13005.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![一个节点具有多个进入边和一个标记为1.0的单一出边，形成自环。](../images/f13005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: An absorbing set
    consisting of a single node in a graph</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-5：一个由单个节点组成的吸收集</samp>
- en: Absorbing nodes can also be used to represent the termination of a random walk.
    As a concrete example, the tourist could decide to stop their random walk when
    they hit their hotel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收节点还可以用来表示随机游走的终止。例如，游客可以决定在到达酒店时停止随机游走。
- en: 'When analyzing random walks on graphs, we often consider two statistical quantities
    related to hitting times: the probability the walk will reach the subset and the
    expected time to do so.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析图上的随机游走时，我们通常会考虑与到达时间相关的两个统计量：游走到达子集的概率和达到该子集所需的期望时间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hitting Probability and Absorption
    Probability</samp>
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">到达概率和吸收概率</samp>
- en: The *hitting probability* for a subset of nodes *A* ⊆ *V* is the probability
    that a random walk from node *u* will hit a node *v* ∈ *A* in that subset. We
    can use this measure to answer questions like “What is the probability that our
    tourist will encounter a coffee shop?” Similarly, the *absorption probability*
    for a subset of nodes *A* is the probability that a random walk from node *u*
    will be absorbed by that subset. This allows us to ask questions like “What is
    the probability the tourist will return to the hotel and stop their random walk?”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*到达概率*对于一个节点子集*A* ⊆ *V*来说，是指从节点*u*开始的随机游走将会在该子集内到达节点*v* ∈ *A*的概率。我们可以使用这个度量来回答像“我们的游客遇到咖啡馆的概率是多少？”这样的问题。类似地，*吸收概率*对于一个节点子集*A*来说，是指从节点*u*开始的随机游走会被该子集吸收的概率。这使我们能够问类似“游客回到酒店并停止随机游走的概率是多少？”这样的问题。'
- en: Absorbing subsets of nodes can impact the hitting probability of non-absorbing
    nodes. For example, consider the weighted graph in [Figure 13-6](#fig13-6), which
    shows a graph with three nodes and an absorbing subset of {0, 1}.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收子集的节点可以影响非吸收节点的到达概率。例如，考虑[图13-6](#fig13-6)中显示的加权图，其中有三个节点和一个吸收子集{0, 1}。
- en: '![A graph with three nodes. Node 0 has a self-loop with weight 0.25 and an
    edge to node 1 with weight 0.75\. Node 1 has a single edge to node 0 with a weight
    of 1.0\. Node 2 has a self-loop with weight 0.5 and an edge to node 1 with weight
    0.5.](../images/f13006.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含三个节点的图。节点0有一个自环，权重为0.25，并且有一条权重为0.75指向节点1的边。节点1有一条权重为1.0的边指向节点0。节点2有一个自环，权重为0.5，并且有一条权重为0.5指向节点1的边。](../images/f13006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: A graph with three
    nodes and transition probabilities</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-6：一个包含三个节点和转移概率的图</samp>
- en: The probability that a walk starting from node 2 will hit node 0 is 1.0 given
    a potentially infinite number of steps. In contrast, once the walk hits the nodes
    *A* = {0, 1}, it can never travel to node 2, as it will be stuck in an endless
    set of steps connected to nodes 0 and 1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定潜在的无限步数的情况下，从节点2开始的随机游走到达节点0的概率是1.0。相反，一旦游走到达节点*A* = {0, 1}，它将永远无法到达节点2，因为它将被困在一个无限的步骤集合中，该集合连接到节点0和1。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Expected Hitting Time</samp>
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">期望到达时间</samp>
- en: The *expected hitting time* is the expected number of steps a random walk takes
    (on average) before it first hits a node in *A*. This allows us to determine how
    long on average it will take our tourist to get their next coffee. The *absorption
    time* is similar, quantifying the expected time until the random walk reaches
    the absorbing set. For our tourist, this would be how long their walk will be
    on average (before they reach their hotel and stop for the day).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*期望到达时间*是指一个随机游走（平均而言）首次到达子集*A*中的一个节点所需要的步骤数。这使我们能够确定游客平均需要多久才能喝到下一杯咖啡。*吸收时间*类似，量化了随机游走到达吸收集所需的期望时间。对于我们的游客来说，这将是他们的游走将持续多久（直到他们到达酒店并停下来）。'
- en: 'For example, the expected hitting time of node 1 from node 0 (denoted *h*[01])
    in [Figure 13-6](#fig13-6) is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图 13-6](#fig13-6)中从节点 0 到节点 1 的预期到达时间（记作 *h*[01]）如下所示：
- en: '*h*[01] = 1 × *p*(first hit node 1 after 1 step)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*[01] = 1 × *p*(在 1 步后首次到达节点 1)'
- en: + 2 × *p*(first hit node 1 after 2 steps)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: + 2 × *p*(在 2 步后首次到达节点 1)
- en: + 3 × *p*(first hit node 1 after 3 steps) + . . .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: + 3 × *p*(在 3 步后首次到达节点 1) + . . .
- en: '*h*[01] = 1 × ¾ + 2 × ¼ × ¾ + 3 × (¼)² × ¾ + 4 × (¼)³ × ¾ + . . .'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*[01] = 1 × ¾ + 2 × ¼ × ¾ + 3 × (¼)² × ¾ + 4 × (¼)³ × ¾ + . . .'
- en: '*h*[01] = 4/3'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*h*[01] = 4/3'
- en: This is because the possible walks from node 0 include walks that start [0,
    1], [0, 0, 1], [0, 0, 0, 1], and so forth. If we have the full transition matrix,
    we can use a set of equations to solve for the expected hitting times.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为从节点 0 开始的可能游走包括 [0, 1]、[0, 0, 1]、[0, 0, 0, 1] 等等。如果我们拥有完整的转移矩阵，就可以通过一组方程来求解预期到达时间。
- en: The expected hitting time may be infinite, like that from node 0 to node 2 (*h*[02])
    in [Figure 13-6](#fig13-6). No matter how long of a walk we consider, we can never
    hit node 2 from node 0.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 预期到达时间可能是无限的，例如 [图 13-6](#fig13-6) 中从节点 0 到节点 2 的 *h*[02]。无论我们考虑多长时间的游走，都无法从节点
    0 到达节点 2。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stationary Distribution</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">平稳分布</samp>
- en: '*Stationary distribution* represents the distribution of visits to each state
    if we keep wandering a strongly connected graph forever. This distribution provides
    insight into how likely we are to spend time at each node. For example, we could
    ask, “After our tourist has been wandering for days, what is the probability that
    they are currently at the café on Fifth Street?” We can also use stationary distribution
    to predict the probable locations of millions of wandering tourists all following
    the same randomized rules as they traverse a city.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*平稳分布* 表示如果我们在一个强连通的图中永远游走，每个状态的访问分布。这个分布提供了我们在每个节点停留的可能性。例如，我们可以问：“我们的游客已经游走了好几天，当前他们有多大概率在第五街的咖啡馆？”我们还可以利用平稳分布来预测成千上万的游客的可能位置，这些游客都遵循相同的随机化规则在城市中游走。'
- en: 'Returning to the matrix notation introduced earlier in the chapter (where *M*
    is the transition matrix and *V*t is a vector of probabilities such that *V*t
    [*u*] is the probability that our random walk is at node *u* at time step *t*),
    the stationary distribution is a vector *V*^* where:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本章早些时候介绍的矩阵表示法（其中 *M* 是转移矩阵，*V*t 是一个概率向量，使得 *V*t [*u*] 是在时间步 *t* 时随机游走位于节点
    *u* 的概率），平稳分布是一个向量 *V*^*，其满足：
- en: '*V*^* = *V* ^**M*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*V*^* = *V* ^**M*'
- en: In other words, adding one more step to the random walk will not change the
    distribution of the possible locations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在随机游走中再增加一步也不会改变可能位置的分布。
- en: We can derive stationary distributions from the structure of the graph. Consider
    the two-node graph in [Figure 13-7](#fig13-7), where *M* = [[0.25, 0.75], [0.5,
    0.5]].
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从图的结构中推导出平稳分布。考虑 [图 13-7](#fig13-7) 中的两个节点图，其中 *M* = [[0.25, 0.75], [0.5,
    0.5]]。
- en: '![The graph has two nodes. Node 0 has a self-loop with weight 0.25 and an edge
    to node 1 with weight 0.75\. Node 1 has a self-loop with weight 0.5 and an edge
    to node 0 with a weight of 0.5.](../images/f13007.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图中有两个节点。节点 0 有一个自环，权重为 0.25，且有一条指向节点 1 的边，权重为 0.75。节点 1 有一个自环，权重为 0.5，且有一条指向节点
    0 的边，权重为 0.5。](../images/f13007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-7: A graph with two
    nodes and four transition probabilities</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-7：一个包含两个节点和四个转移概率的图</samp>
- en: The structure of the graph in [Figure 13-7](#fig13-7) indicates that over the
    long term, random walks will tend to spend more time at node 1 than at node 0\.
    The probability of staying at node 0, due to a self-loop, is only 0.25, while
    the probability of staying at node 1 is 0.5\. We can quantify that difference
    in time spent at each node by using the stationary distribution, which for this
    graph is *V*^* = [0.4, 0.6].
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-7](#fig13-7) 中图的结构表明，从长远来看，随机游走将在节点 1 上花费比节点 0 更多的时间。由于自环的存在，停留在节点 0
    的概率仅为 0.25，而停留在节点 1 的概率为 0.5。我们可以通过平稳分布量化在每个节点上花费的时间差异，对于该图，平稳分布为 *V*^* = [0.4,
    0.6]。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Luck-Based Board Games</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">基于运气的桌面游戏</samp>
- en: 'We can bring together the topics in this section to consider one of the most
    entertaining applications of random walks: analyzing luck-based board games for
    children. These games involve no actual choices, but instead rely on random numbers
    generated by spinners or dice to decide the moves. After hours spent spinning
    dials that determine whether a plastic piece moves ahead one, two, or three spaces,
    even non-statistically minded people might inquire about the expected absorption
    time of the goal state by asking, “How much longer do I have to play this game?”
    We can answer such questions by modeling the game as a random walk on a graph.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合本节中的主题，考虑随机游走最有趣的应用之一：分析基于运气的儿童棋盘游戏。这些游戏没有实际的选择，而是依赖于转盘或骰子生成的随机数字来决定行动。在花了几个小时转动指示棋子前进一格、两格或三格的拨轮之后，即使是不懂统计学的人也可能会问到目标状态的期望吸收时间，问：“我还需要多久才能玩完这个游戏？”我们可以通过将游戏建模为图上的随机游走来回答这些问题。
- en: Consider the simple example of a game where the goal is to be the first player
    to complete a circuit of the board. During their turn, each player uses a small
    spinner labeled with 1, 2, and 3 that indicates how many steps to take. [Figure
    13-8](#fig13-8) shows a graphical representation of several states in this game.
    The nodes’ numbers correspond to the squares on the board, where the player is
    currently at square *k*. Based on the random spinner, they could move to squares
    *k* + 1, *k* + 2, or *k* + 3, each with a 1/3 probability.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的游戏示例，目标是成为第一个完成棋盘一圈的玩家。在每个玩家的回合中，他们使用一个标有1、2和3的小转盘，指示要走多少步。[图 13-8](#fig13-8)显示了游戏中多个状态的图示。节点的数字对应棋盘上的方格，玩家当前所在方格是*k*。根据转盘的随机结果，他们可以移动到方格*k*
    + 1、*k* + 2或*k* + 3，每个方格的概率为1/3。
- en: '![A line of graph nodes. Each node k has three outgoing edges, to node k +
    1, k + 2, and k + 3.](../images/f13008.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![一行图节点，每个节点k有三条出边，分别指向节点k + 1、k + 2和k + 3。](../images/f13008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-8: A graph representing
    sample states of a spinner-based game</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-8：表示基于转盘的游戏示例状态的图</samp>
- en: In an attempt to make the game more exciting (or possibly to cause more children
    to cry in frustration), the creators label some of the squares “Go back X spaces.”
    These represent traps that should be avoided at all costs. We can incorporate
    this behavior directly into our graph.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游戏更刺激（或可能让更多的孩子因沮丧而哭泣），游戏设计者将某些方格标记为“倒退X步”。这些代表应避免的陷阱。我们可以将这种行为直接纳入我们的图中。
- en: '[Figure 13-9](#fig13-9) shows the state graph where square *k* + 2 contains
    the instructions “Move back one space.” This effectively removes node *k* + 2
    from the graph (represented in the figure by graying out the node). It is not
    possible to finish a turn in that state. The transition probabilities of the neighboring
    nodes change correspondingly. The probability of going from node *k* to *k* +
    1 increases from 1/3 to 2/3, because now spins of both 1 and 2 will end on square
    *k* + 1\. Similarly, a spin of 1 from node *k* + 1 will land the player back on
    node *k* + 1\. We model this as a self-loop with probability 1/3.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-9](#fig13-9)显示了一个状态图，其中方格*k* + 2包含“倒退一格”的指示。这实际上将节点*k* + 2从图中移除（在图中通过将节点变灰来表示）。在这个状态下无法完成一个回合。相邻节点的转移概率也相应发生变化。从节点*k*到*k*
    + 1的概率从1/3增加到2/3，因为现在转动1和2都会停在方格*k* + 1。类似地，从节点*k* + 1转动1会将玩家带回节点*k* + 1。我们将这建模为一个自环，概率为1/3。'
- en: '![A line of graph nodes. Nodes have edges to themselves and to nodes further
    right.](../images/f13009.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![一行图节点，节点有指向自身和更右侧节点的边。](../images/f13009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-9: A graph representing
    the movements from state</samp> <samp class="SANS_Futura_Std_Book_11">k</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in a spinner-based game</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-9：表示从状态</samp> <samp class="SANS_Futura_Std_Book_11">k</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">在基于转盘的游戏中的移动</samp>
- en: While we can add more edges to capture square-based and spinner-based transitions,
    significantly more complexity is required to capture aspects such as player-player
    interactions. The graph model presented so far in this section captures only the
    dynamics of a single random walk through the board game. This works fine if all
    players are independent. However, if the game provides the ability to knock a
    player back two squares when someone lands on their square, we need a model that
    incorporates both players’ positions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以添加更多的边来捕捉基于方格和旋转器的转移，但要捕捉玩家之间互动等方面需要更复杂的模型。本节中介绍的图模型只捕捉了单次随机行走在棋盘游戏中的动态。如果所有玩家是独立的，这样的模型工作得很好。然而，如果游戏提供了一种在某个玩家落到另一个玩家的方格上时将其击退两个方格的能力，那么我们就需要一个同时考虑两个玩家位置的模型。
- en: We can create such models by increasing the number of nodes to match the available
    states of the board game. Instead of *N* nodes for *N* squares, we could use 2*N*²
    nodes by modeling the game state as a tuple of Alice’s location (player 1’s state),
    Bob’s location (player 2’s state), and a Boolean indicating whether it is Alice’s
    turn. For example, the tuple <samp class="SANS_TheSansMonoCd_W5Regular_11">(5,
    4, False)</samp> indicates that Alice is on square 5, Bob is on square 4, and
    it is Bob’s turn. If we combine the three-option spinner with the new “knock-back”
    rule, there is a 1/3 probability that Bob will spin a 1, move forward a square,
    and knock Alice back two squares. More formally, *p*(<samp class="SANS_TheSansMonoCd_W5Regular_11">(5,
    4, False)</samp> → <samp class="SANS_TheSansMonoCd_W5Regular_11">(3, 5, True)</samp>)
    = 1/3.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增加节点的数量来创建此类模型，以匹配棋盘游戏的可用状态。与其为*N*个方格使用*N*个节点，我们可以通过将游戏状态建模为包含爱丽丝位置（玩家1的状态）、鲍勃位置（玩家2的状态）以及一个布尔值表示是否是爱丽丝回合的三元组，来使用2*N*²个节点。例如，三元组<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(5, 4, False)</samp>表示爱丽丝在第5个方格，鲍勃在第4个方格，并且是鲍勃的回合。如果我们将三项选择旋转器与新的“击退”规则结合起来，那么鲍勃有1/3的概率旋转到1，前进一个方格，并将爱丽丝击退两个方格。更正式地说，*p*(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(5, 4, False)</samp> → <samp class="SANS_TheSansMonoCd_W5Regular_11">(3,
    5, True)</samp>) = 1/3。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Transition Probabilities</samp>
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">转移概率</samp>
- en: Beyond analyzing given graphs, we can extend the concepts in this chapter to
    *estimating* the graphs themselves from observed data. Imagine that we’ve found
    the logbook of a tourist who spent the last year randomly wandering the streets
    of an unknown city. Each entry lists at least a location and a time. Eager to
    understand their journey, we consider their long sequence of visited locations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分析给定的图形外，我们还可以将本章中的概念扩展到*估计*这些图形本身，从观察数据中进行估算。假设我们发现了一个游客的日志本，他在过去一年里随机地在一个未知城市的街道上漫游。每个条目至少列出了一个地点和一个时间。为了更好地理解他们的旅程，我们考虑他们长时间的访问地点序列。
- en: We can easily reconstruct individual nodes from the location names, such as
    Integer Square and Floating Point Harbor. With a little reasoning, we can also
    identify the existence of edges; for example, the transition from Integer Square
    to If-Then Intersection implies an edge connects them. After hours of studying
    the tourist’s agonizingly looping path, we step back and try to reconstruct their
    transition matrix.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地从地点名称重建各个节点，例如整数广场和浮动点港口。稍作推理，我们还可以识别边的存在；例如，从整数广场到“如果-那么”交叉口的过渡暗示着它们之间存在一条边。经过几个小时对游客痛苦循环路径的研究后，我们退后一步，试图重建他们的转移矩阵。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Maximum Likelihood
    Estimations</samp>
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">最大似然估计</samp>
- en: 'We can estimate a transition matrix using a sequence of observations that result
    from one or more walks to statistically estimate transition probabilities. A *maximum
    likelihood estimation* allows us to find the model parameters (transition probabilities)
    that maximize the chance that we will see the sampled data given those parameters.
    We won’t discuss the mathematical details of this approach here, but in short,
    a maximum likelihood estimation uses the independence of each step to compute
    the transition probability from node *u* to node *v* by counting the following
    two quantities:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用一系列由一次或多次行走所产生的观察值来估计转移矩阵，从而统计地估计转移概率。*最大似然估计*让我们找到那些最大化在给定参数下观测到样本数据的模型参数（转移概率）。我们在这里不会讨论这种方法的数学细节，但简而言之，最大似然估计利用每一步的独立性，通过计算以下两项量来计算从节点*u*到节点*v*的转移概率：
- en: '***N***uThe number of times node *u* appears in the data at the start of a
    move (not the last node in the path)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '***N***u节点 *u* 在数据中作为移动起始节点出现的次数（不是路径中的最后一个节点）'
- en: '***N***u [→] vThe number of times node *v* appears immediately after node *u*
    in the data'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '***N***u [→] v节点 *v* 在数据中紧跟在节点 *u* 之后出现的次数'
- en: 'Given this information, we compute the probability of a transition as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些信息，我们计算转移的概率如下：
- en: '*p*(*u* → *v*) ≈ *N*u [→] v / *N*u'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*u* → *v*) ≈ *N*u [→] v / *N*u'
- en: If we have departed 100 times from node 1, and 30 of those times we moved directly
    to node 3, we estimate *p*(1 → 3) = 30 / 100 = 0.3.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从节点1出发了100次，其中有30次直接移动到节点3，那么我们估算 *p*(1 → 3) = 30 / 100 = 0.3。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Transition Matrix
    Estimation Algorithm</samp>
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转移矩阵估算算法</samp>
- en: The algorithm to estimate an underlying graph from observational data consists
    of three phrases. In the first phase, we use the nodes visited along the walks
    to compute the number of nodes for the graph. This corresponds to scanning through
    the tourist’s logbook and determining how many intersections we will need to track.
    Second, we construct the count array for the number of times the tourist visited
    each node (*N*u) and the count matrix for the node-to-node transitions (*N*u [→]
    v). We compute the counts by iterating over the steps in the walk, effectively
    retracing the tourist’s journey. Finally, we build the graph by inserting edges
    for all nonzero node-to-node transitions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从观察数据中估算一个潜在图形的算法包含三个阶段。在第一个阶段，我们使用行走中访问过的节点来计算图形中节点的数量。这相当于扫描游客的日志并确定我们需要跟踪多少个交叉点。第二，我们构建节点访问次数的计数数组（*N*u）和节点到节点转移的计数矩阵（*N*u
    [→] v）。我们通过遍历行走中的每一步来计算计数，实际上是在重新追溯游客的旅程。最后，我们通过为所有非零的节点到节点转移插入边来构建图形。
- en: Because we are constructing the graph from nodes in the walk, we include only
    those nodes that the algorithm visits at least once. This means that, given a
    disconnected graph, we would capture only the graph that is reachable from the
    initial starting node(s). If the tourist is frightened of water and refuses to
    cross bridges, we might miss all of the locations on the other side of the river.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们是从行走中的节点构建图形，所以只包括算法至少访问过一次的节点。这意味着，对于一个断开的图形，我们只会捕捉到从初始起始节点（或节点们）可达的部分。如果游客害怕水并拒绝过桥，那么我们可能会错过河对岸的所有地点。
- en: '[Listing 13-4](#list13-4) reflects these three phases.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单13-4](#list13-4) 反映了这三个阶段。'
- en: '[PRE4]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-4: Estimating a
    transition matrix from observed data</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单13-4：从观察数据估算转移矩阵</samp>
- en: The function takes in a list of lists (<samp class="SANS_TheSansMonoCd_W5Regular_11">walks</samp>)
    that contain the nodes visited on multiple random walks. The code starts by using
    a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    to iterate over each walk and each node in that walk and records the highest index
    seen ❶. It then allocates data structures for the two sets of counts (<samp class="SANS_TheSansMonoCd_W5Regular_11">counts</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">move_counts</samp>) and fills
    these using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to
    iterate over each step in the path ❷. Once it has completed the counts, the code
    creates a graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>) and iterates
    over each pair of nodes with two nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops ❸. If the transition count between the two nodes is nonzero ❹, it computes
    the probability and inserts the corresponding edge into the graph.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接收一个包含多个随机行走的节点的列表的列表（<samp class="SANS_TheSansMonoCd_W5Regular_11">walks</samp>）。代码首先使用一对嵌套的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历每个行走和该行走中的每个节点，并记录看到的最大索引
    ❶。然后，它为两组计数（<samp class="SANS_TheSansMonoCd_W5Regular_11">counts</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">move_counts</samp>）分配数据结构，并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环遍历路径中的每一步 ❷ 来填充这些数据。一旦计数完成，代码创建一个图形（<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）并用两层嵌套的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历每对节点 ❸。如果这两个节点之间的转移计数非零
    ❹，则计算概率并将相应的边插入图形中。
- en: Keep in mind that using the highest index seen has the downside that if the
    underlying graph consists of multiple disconnected components, the re-created
    graph will include indices that we will never visit. Since these indices have
    a count of zero, they will not be given any outgoing edges, and the resulting
    graph will fail the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_valid_probability_graph()</samp>
    check. We use the maximum index approach in [Listing 13-4](#list13-4) for simplicity
    and consistency with previous chapters, but a more robust approach is to use a
    *node name* to index mapping, as described in [Appendix A](appendix_A.xhtml).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用看到的最高索引的缺点在于，如果底层图由多个不连通的组件组成，重建的图将包含我们永远不会访问的索引。由于这些索引的计数为零，它们将没有出边，导致生成的图未能通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_valid_probability_graph()</samp>检查。为了简化并保持与前面章节的一致性，我们在[清单13-4](#list13-4)中使用了最大索引方法，但更健壮的方法是使用*节点名称*到索引的映射，如[附录A](appendix_A.xhtml)中所述。
- en: 'As an example of estimating the graph, consider a travel journal that consists
    of two paths and contains visits to numbered buildings:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为估算图的示例，考虑一个旅行日志，其中包含两条路径并且访问了编号的建筑物：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can feed these paths into our estimation function to learn about our tourist’s
    vacation behavior:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些路径输入到我们的估算函数中，来了解旅游者的度假行为：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A few points immediately jump out when looking at the paths. First, the tourist
    always started from node 0\. Second, they visited only two buildings, 0 and 1\.
    In this case, building 0 is the hotel with a café in the lobby, while building
    1 is the coffee shop across the street.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看这些路径时，有几个要点立刻显现。首先，旅游者总是从节点0出发。其次，他们只访问了两个建筑，0号和1号。在这个案例中，0号建筑是有咖啡馆的大堂的酒店，而1号建筑是街对面的咖啡店。
- en: 'As we compute the maximum likelihood estimate, we accumulate the following
    values:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算最大似然估计时，我们积累了以下值：
- en: '*N*[0] = 8, *N*[1] = 4'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*[0] = 8, *N*[1] = 4'
- en: '*N*[0 → 0] = 4, *N*[0 → 1] = 4, *N*[1 → 0] = 4, *N*[1 → 1] = 0'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*[0 → 0] = 4, *N*[0 → 1] = 4, *N*[1 → 0] = 4, *N*[1 → 1] = 0'
- en: The tourist started a move from node 0 eight times (*N*[0] = 8). Four of those
    times they stayed at node 0 (*N*[0 → 0] = 4), and four times they went to node
    1 (*N*[0 → 1] = 4). They started moves from node 1 four times, always going to
    node 0 (*N*[1 → 0] = 4) and never to node 1 (*N*[1 → 1] = 0).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 旅游者从节点0出发移动了八次 (*N*[0] = 8)。其中四次停留在节点0 (*N*[0 → 0] = 4)，四次移动到节点1 (*N*[0 → 1]
    = 4)。他们从节点1出发四次，始终回到节点0 (*N*[1 → 0] = 4)，从未回到节点1 (*N*[1 → 1] = 0)。
- en: 'We use these statistics to estimate the pairwise transition probabilities:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些统计数据来估算成对的转移概率：
- en: '*p*(0 → 0) = 4 / 8 = 0.5'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(0 → 0) = 4 / 8 = 0.5'
- en: '*p*(0 → 1) = 4 / 8 = 0.5'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(0 → 1) = 4 / 8 = 0.5'
- en: '*p*(1 → 0) = 4 / 4 = 1.0'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(1 → 0) = 4 / 4 = 1.0'
- en: '*p*(1 → 1) = 0 / 4 = 0.0'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(1 → 1) = 0 / 4 = 0.0'
- en: These probabilities provide the edge weights for the estimated graph, as shown
    in [Figure 13-10](#fig13-10). Note that we do not include the edge (1, 1) because
    it has a weight of 0.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概率提供了估算图的边权重，如[图13-10](#fig13-10)所示。注意，我们没有包括边(1, 1)，因为它的权重为0。
- en: '![A graph with two nodes and three edges. Node 0 has a self-loop with a weight
    0.5 and an edge to node 1 with a weight 0.5\. Node 1 has a single edge back to
    node 0 with a weight 1.0.](../images/f13010.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含两个节点和三条边的图。节点0有一个自环，权重为0.5，并且有一条指向节点1的边，权重为0.5。节点1有一条回到节点0的边，权重为1.0。](../images/f13010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-10: A graph with
    edge transition probabilities estimated from data</samp>'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图13-10：一个根据数据估算的边转移概率图</samp>
- en: When at the hotel, the tourist has a 50 percent chance of staying at the hotel
    and a 50 percent chance of going across the street to the coffee shop. However,
    when at the coffee shop, they always return directly to the hotel.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在酒店时，旅游者有50%的机会停留在酒店，也有50%的机会走到街对面的咖啡店。然而，在咖啡店时，他们总是直接回到酒店。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Limitations of Working
    with Finite Data</samp>
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理有限数据的局限性</samp>
- en: Of course, our estimates of transition probability are likely to be very noisy
    until we accumulate significant observations. If we have a big enough graph, we
    might never have a chance to observe certain nodes or low-probability edges. This
    is a fundamental problem of working with random data. If our tourist has a 5 percent
    chance of turning down a narrow alley, they might reasonably skip it each of the
    10 times we see them at its entrance.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，直到我们积累了足够的观察数据之前，我们对转移概率的估计可能会非常嘈杂。如果我们的图足够大，可能永远也没有机会观察到某些节点或低概率的边。这是使用随机数据时的一个基本问题。如果我们的游客有5%的几率进入一条狭窄的小巷，我们在看到他们10次时，他们可能每次都会合理地跳过这条小巷。
- en: Using statistics, we can analyze not only the maximum likelihood values but
    also their error bars and our confidence levels. These analyses are outside the
    scope of this book. For now, we just give a word of caution against trying to
    draw rigorous conclusions from a small amount of random data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用统计学方法，我们不仅可以分析最大似然值，还可以分析它们的误差范围和我们的置信水平。这些分析超出了本书的范围。现在，我们只是提醒读者避免从少量的随机数据中得出严谨的结论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Random Starting Nodes</samp>
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">随机起始节点</samp>
- en: We can extend both our model and its estimation to account for cases where the
    random walk starts at different nodes. The idea of a *random starting node* may
    not seem intuitive since physical walks start at a single location such as the
    tourist’s hotel. However, randomized starts can represent a variety of real-world
    phenomena, such as the tourist randomly leaving one of many hotels or a rumor
    starting at a random point in a social network.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们的模型及其估计，考虑随机游走从不同节点开始的情况。*随机起始节点*的概念可能并不直观，因为物理上的游走通常从一个特定地点开始，比如游客的酒店。然而，随机起始点可以代表许多现实世界的现象，例如游客随机选择离开某个酒店，或者谣言从社交网络中的一个随机点开始传播。
- en: Let’s label the vector of starting probabilities *S* where *S*[*u*] indicates
    the probability that we start our random walk at node *u*. Since *S* contains
    probabilities, we restrict 0 ≤ *S*[*u*] ≤ 1 and ∑u *S*[*u*] = 1.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将起始概率的向量标记为*S*，其中*S*[*u*]表示我们从节点*u*开始随机游走的概率。由于*S*包含概率，我们限制0 ≤ *S*[*u*] ≤
    1，并且∑u *S*[*u*] = 1。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Choosing a Random
    Starting Node</samp>
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">选择一个随机起始节点</samp>
- en: 'We can directly sample the starting node with the same approach we used for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp> in [Listing
    13-3](#list13-3):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用与[示例13-3](#list13-3)中用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp>
    相同的方法，直接抽取起始节点：
- en: '[PRE7]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_start()</samp> function
    draws a random number from [0, 1) using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp>
    library ❶. Instead of iterating over a node’s edges as in <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp>,
    the function iterates over the values in *S* until it finds the correct one ❷.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_start()</samp>函数使用Python的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp> 库 ❶ 从[0, 1)之间随机抽取一个数。与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">choose_next_node()</samp> 函数按节点边进行迭代不同，该函数会在*S*中的值上迭代，直到找到正确的值
    ❷。
- en: As a more detailed example, imagine an evil wizard who creates dungeons that
    use randomized entryways to prevent former adventurers from writing strategy guides
    (thereby messing with the adventurers’ retirement plans). The wizard teleports
    each new arrival to a random location using a carefully chosen distribution *S*.
    They restrict adventurers from ever starting their quest in the treasure room
    by setting that room’s starting probability to zero, *S*[*treasure*] = 0\. To
    reduce the ability for adventurers to share information, the wizard also enforces
    *S*[*room*] < 0.1 for all rooms, meaning that there is less than a 10 percent
    chance the adventurers will start in any particular room.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更详细的例子，想象一个邪恶的巫师，他创建的地下城使用随机化的入口，以防止前来的冒险者编写攻略（从而影响他们的退休计划）。巫师使用精心挑选的分布*S*将每个新到达者传送到一个随机地点。他们通过将宝藏室的起始概率设置为零，*S*[*treasure*]
    = 0，来限制冒险者永远不能从宝藏室开始他们的探险。为了减少冒险者之间分享信息的可能性，巫师还强制要求所有房间的起始概率 *S*[*room*] < 0.1，这意味着冒险者有不到10%的概率从任何特定房间开始。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Estimating the Probability
    Distribution for Starting Nodes</samp>
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">估计起始节点的概率分布</samp>
- en: 'If we run many random walks, we might be interested in estimating the distribution
    over starting states. We can use a similar approach to that of the transition
    probabilities to estimate the starting probabilities. If *N*[0][*u*] is the number
    of walks that start at node *u*, then we define the probability of starting at
    node *u* as the fraction of times a walk started from that node:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行多个随机漫步，可能会对估计起始状态的分布感兴趣。我们可以使用类似于转移概率的方法来估计起始概率。如果*N*[0][*u*]是从节点*u*开始的漫步次数，那么我们将从节点*u*开始的概率定义为该节点开始漫步的次数所占的比例：
- en: S[*u*] = *N*[0][*u*] / ∑v *N*[0][*v*]
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: S[*u*] = *N*[0][*u*] / ∑v *N*[0][*v*]
- en: 'We can implement this estimation in the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中实现这一估计：
- en: '[PRE8]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Like the code for estimating the transition probabilities, the code to estimate
    the starting probabilities starts by computing the maximum node index and creating
    a data structure to track occurrences ❶. In this case, however, the code looks
    only at the first node in the walk. It uses a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop over the different walks to count how many of the walks start at each node
    ❷. It then computes the empirical probability of starting at each node.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与估计转移概率的代码类似，估计起始概率的代码从计算最大节点索引开始，并创建一个数据结构来跟踪出现次数❶。然而，在这种情况下，代码只关注漫步中的第一个节点。它通过一个<sup
    class="SANS_TheSansMonoCd_W5Regular_11">for</sup>循环遍历不同的漫步，统计有多少次漫步是从每个节点开始的❷。然后它计算每个节点的经验起始概率。
- en: Our adventurer could theoretically use this approach to gather information for
    their upcoming strategy guide. They enter the dungeon a few hundred times, carefully
    tracking where they land each time. It is up to them to decide whether the payoff
    of writing a comprehensive guide to this dungeon is worth the hassle of navigating
    through the same dungeon over and over again.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的冒险者理论上可以使用这种方法为他们即将发布的战略指南收集信息。他们进入地下城几百次，每次都仔细记录自己落脚的位置。他们可以决定是否值得编写一本全面的地下城指南，尽管这意味着需要一次又一次地穿越相同的地下城。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: Analyzing random walks on graphs is useful for both understanding the structure
    of a graph and analyzing its underlying system. More importantly, however, the
    concept of random walks extends the range of real-world problems we can model
    with graph algorithms. We can move beyond deterministic questions, such as how
    to find the shortest path between two nodes, to account for more realistic behaviors.
    For example, to model path planning with occasional wrong turns, we could use
    a random walk that takes the optimal path most of the time but makes a random
    error at some intersections.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在图上分析随机漫步对于理解图的结构以及分析其底层系统是非常有用的。然而，更重要的是，随机漫步的概念扩展了我们可以用图算法建模的现实世界问题的范围。我们可以超越确定性问题，比如如何找到两个节点之间的最短路径，转而考虑更现实的行为。例如，为了模拟有时会发生错误的路径规划，我们可以使用一种随机漫步，它大多数时候走最优路径，但在某些交叉口会随机出错。
- en: In the next chapter, we switch topics and consider the graphs from a perspective
    of overall capacity, finding the maximum flow through a network to model systems
    from plumbing to transportation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将话题转向另一个方向，从整体容量的角度考虑图，寻找通过网络的最大流，以建模从管道到交通运输的各种系统。
