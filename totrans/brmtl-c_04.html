<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="33" id="Page_33"/>3</span><br/>
<span class="ChapterTitle">Programming the Microcontroller</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Now that we’ve written and run a “Hello World” program in the IDE, we’ll do the same on the STM32 NUCLEO-F030R8 development board, which contains the STM32F030R8 processor and several other components needed to use the processor. On an embedded system, the equivalent of “Hello World” is a program that makes an LED blink. By making an LED blink, you’ll learn the steps needed to make a complex program at a smaller scale.</p>
<p>In the process, you’ll learn how to use the System Workbench for STM32, which we explored in the last chapter, to create an embedded program. To assist us, we’ll use STMicroelectronics software called the hardware abstraction layer (HAL), which hides some of the more annoying details of the hardware from you. (However, the details aren’t hidden very deep, and you can examine the source code to see what was done.) We’ll also get into what the IDE is doing behind the scenes with a detailed explanation of the options it’s using to compile the code.</p>
<p><span epub:type="pagebreak" title="34" id="Page_34"/>Finally, like we did in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, we’ll run the debugger to see our program execute one statement at a time, which will prove extremely useful when we start to make larger and larger programs.</p>
<h2 id="h1-501621c03-0001">The NUCLEO-F030R8 Development Board</h2>
<p class="BodyFirst"><em>Development boards</em> are circuit boards that contain a processor chip and various other components required to develop applications for that processor, including a lot of useful items for developing programs and circuits that use the chip. In addition to programming and debugging support, the development board includes numerous <em>connectors</em>, which allow you to hook up your prototype hardware. It also includes a few <em>peripherals</em> such as a serial port, a push button switch, and an LED, although some of the fancier boards will have additional peripherals.</p>
<p>Thus, the development board provides you with an instant prototype for developing the initial software with breadboarded hardware. Microprocessor manufacturers generally sell development boards with all that stuff included to get people to use their chips.</p>
<p>The STM32 NUCLEO-F030R8 board bundles the STM32F030R8 chip with a clock circuit, a power supply, and some devices to talk to, including an LED, a button, and a serial I/O device. <a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a> shows the basic building blocks of our processor board.</p>
<figure>
<img src="image_fi/501621c03/f03001.png" alt="f03001" class=""/>
<figcaption><p><a id="figure3-1">Figure 3-1</a>: The processor board</p></figcaption>
</figure>
<p>The power and clock drive the CPU, the reset button restarts the CPU, the user LED and push button are for user interaction, and the serial port and connectors are for programming and debugging.</p>
<h3 id="h2-501621c03-0001">Programming and Debugging the Board</h3>
<p class="BodyFirst">The development board contains three devices useful for programming and debugging the chip—a flash programmer, a JTAG pod, and a serial I/O device—all of which connect to your computer through a single USB cable. (One cable, three devices.)</p>
<p>To program the chip, we use the <em>flash programmer</em>, a device that allows our PC to reprogram the memory of the chip. Reprogramming memory is how we get our program into the machine.</p>
<p><span epub:type="pagebreak" title="35" id="Page_35"/>To facilitate debugging, the chip has a JTAG port. JTAG, which stands for Joint Test Action Group, is a standard debugging interface. Before this standard came out, everyone created their own debugging interface or, more often, left it out, leaving programmers to get very creative when it came to debugging programs. To debug with the JTAG port, we need to connect it to our computer. This is done through a <em>debug pod</em>, which has a connection to the JTAG port on our development board on one end and a connection to our computer’s USB port on the other.</p>
<p>Another very useful debugging and maintenance tool is the printing of diagnostic messages. The problem when it comes to embedded programs is where to print them. You don’t have a screen, so printing to the screen is out. Printing the messages in a logfile is difficult because you don’t have a filesystem. What most device designers do is put a <em>serial port</em>, a simple three-wire communication interface, on the board. <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> goes into the details of this device.</p>
<h3 id="h2-501621c03-0002">Setting Up the Board</h3>
<p class="BodyFirst">The bottom half of the Nucleo board contains the chip and support circuitry, with lots and lots of pins broken out to connectors on the sides of the board (for connecting peripherals). Above that is the support board containing a programmer, a debugger, a serial-to-USB device, and a USB storage device.</p>
<p><a href="#figure3-2" id="figureanchor3-2">Figure 3-2</a> shows how the board is put together.</p>
<figure>
<img src="image_fi/501621c03/f03002.png" alt="f03002" class=""/>
<figcaption><p><a id="figure3-2">Figure 3-2</a>: The NUCLEO-F030R8 board</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="36" id="Page_36"/>The board also contains several jumpers and LEDs. <em>Jumpers</em> are small plastic devices that short two pins together. They are used to select hardware options, such as enabling the onboard debugger (ST-LINK), and should be installed as shown in <a href="#figure3-3" id="figureanchor3-3">Figure 3-3</a>. Follow these steps to do so:</p>
<ol class="decimal">
<li value="1">Install the ST-LINK with two jumpers (CN2). Doing so configures the onboard debugging pod (ST-LINK) to debug the onboard microcontroller. If you remove these two jumpers, you can use the ST-LINK pod to debug other boards instead.</li>
<li value="2">Do not install the power supply jumper (JP1). This configuration allows the Nucleo board to draw up to 300mA of power through the USB port, letting you power the device using the USB port. If you connected lots of power-hungry peripherals to the board, you could use JP1 to enable an external power supply. This book doesn’t use any external hardware, so leave JP1 out.</li>
<li value="3">Do not install RX-TX, a debug option that shorts the input and output of the serial port together. We’ll use the serial port as an actual serial port later, so leave this jumper off.</li>
<li value="4">Install the JP5 jumper to the right position (U5V). Doing so ensures the board will be powered through the USB port instead of through an external power source.</li>
<li value="5">Power the measurement jump (JP6). This is a lower-power device. The two pins shorted by JP6 supply power to the chip. Remove the jumper and connect an amp meter to measure power consumption.</li>
</ol>
<p>CN11 and CN12 are places to store jumpers when not in use. Installing jumpers there won’t affect the circuitry.</p>
<figure>
<img src="image_fi/501621c03/f03003.png" alt="f03003" class=""/>
<figcaption><p><a id="figure3-3">Figure 3-3</a>: Jumper and LED locations</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="37" id="Page_37"/>Now plug the device into your computer using a mini USB cable. LD1 should turn red, indicating the programmer has power. LD2 should blink, because the board comes with a preinstalled program that blinks LD2. (This is true assuming you bought the board new. If, like me, you got your first board from your buddy down the hall, it will contain your buddy’s last experiment.) LD3 should also turn red, indicating that the chip has power.</p>
<h2 id="h1-501621c03-0002">Setting Up an Embedded Project</h2>
<p class="BodyFirst">Before you begin programming, close any open editing windows in System Workbench for STM32. The editing window identifies the filename, not the project name, which causes a problem; all our projects will have a <em>main.c </em>file, and things would get pretty confusing with half a dozen <em>main.c</em> editing windows open.</p>
<p>Next, create an embedded project by selecting <b>File</b><span class="MenuArrow">▶</span><b>New</b><span class="MenuArrow">▶</span><b>C Project</b>. (A checklist detailing these steps can be found in the <span class="xref" itemid="xref_target_appendix">appendix</span>.) The C Project dialog should appear (see <a href="#figure3-4" id="figureanchor3-4">Figure 3-4</a>).</p>
<figure>
<img src="image_fi/501621c03/f03004.png" alt="f03004" class=""/>
<figcaption><p><a id="figure3-4">Figure 3-4</a>: The C Project dialog</p></figcaption>
</figure>
<p>For the project name, enter <b>03.blink</b>. For the project type, select <b>Ac6 STM32 MCU Project</b>. On first startup, the IDE downloads the GCC ARM toolchain to the directory where you installed the IDE, as well as the entire STM32 firmware library, a portion of which will get copied to your project. If you’d like to explore this library’s code and examples further, the cache directory it uses is <em>~/.ac6</em> on Linux and macOS and <em>C:\Users\&lt;username&gt;\AppData\Roaming\Ac6 </em>on Windows. Be warned, however, that these examples are designed to show off the STM chips and aren’t easily understood by novice programmers.</p>
<p><span epub:type="pagebreak" title="38" id="Page_38"/>Click <b>Next</b>. The Select Configurations dialog, shown in <a href="#figure3-5" id="figureanchor3-5">Figure 3-5</a>, should appear.</p>
<figure>
<img src="image_fi/501621c03/f03005.png" alt="f03005" class=""/>
<figcaption><p><a id="figure3-5">Figure 3-5</a>: The Select Configurations dialog</p></figcaption>
</figure>
<p>Leave <b>Debug</b> selected and deselect <b>Release</b>. To keep things simple, we’ll perform only one type of build. Click <b>Next</b>.</p>
<p>Next is the Target Configuration dialog (see <a href="#figure3-6" id="figureanchor3-6">Figure 3-6</a>).</p>
<figure>
<img src="image_fi/501621c03/f03006.png" alt="f03006" class=""/>
<figcaption><p><a id="figure3-6">Figure 3-6</a>: The Target Configuration dialog</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="39" id="Page_39"/>For the series, select <b>STM32F0</b>, and for the board, select <b>NUCLEO-F030R8</b>. Click <b>Next</b>.</p>
<p>This brings us to the Project Firmware Configuration dialog (see <a href="#figure3-7" id="figureanchor3-7">Figure 3-7</a>).</p>
<figure>
<img src="image_fi/501621c03/f03007.png" alt="f03007" class=""/>
<figcaption><p><a id="figure3-7">Figure 3-7</a>: The Project Firmware Configuration dialog</p></figcaption>
</figure>
<p>The project firmware configuration options let us use free standard code available from STMicroelectronics and other suppliers. Since someone else has written most of the hard stuff, let’s use their work. Select <b>Hardware Abstraction Layer (Cube HAL)</b> and then click the button labeled <b>Download Target Firmware</b> when it appears. Accept the license agreement, and the IDE will download the firmware library.</p>
<p>After the long download completes, the system displays additional options. Leave them to the default values and click <b>Finish</b>.</p>
<p>Back in the C/C++ Project view, you should see an entry in the project list for <em>blink</em>. Click the triangle next to <em>blink</em> to see a list of directories that make up the project, and click the triangle next to <em>src</em> to expand that directory. Double-click <em>main.c</em> to make it appear in the editing window, as shown in <a href="#figure3-8" id="figureanchor3-8">Figure 3-8</a>.</p>
<span epub:type="pagebreak" title="40" id="Page_40"/><figure>
<img src="image_fi/501621c03/f03008.png" alt="f03008" class=""/>
<figcaption><p><a id="figure3-8">Figure 3-8</a>: The editing window, showing <em>main.c</em></p></figcaption>
</figure>
<h2 id="h1-501621c03-0003">Your First Embedded Program</h2>
<p class="BodyFirst">The IDE has conveniently supplied you with a main file that has the minimal features of your program filled in: a comment, the code libraries for the Nucleo board, and a generic <code>main</code> function. The + icon next to line 3 indicates that some program lines have been <em>folded</em>, or hidden from view. Click the + icon to expand the long comment describing the file:</p>
<pre><code>1 /**
2   ************************************************************************
3  * @file    main.c
4  * @author  Ac6
5  * @version V1.0
6  * @date    01-December-2013
7  * @brief   Default main function.
8  *************************************************************************
9 */</code></pre>
<p>You may wish to update this comment with your name and information. The keywords that begin with <code>@</code> are designed to work with <em>Doxygen</em>, a complex and full-featured system that extracts documentation out of large programs. We won’t be using this tool for our small programs, so you can edit the comment any way you want.</p>
<p>The <code>main</code> function doesn’t have a <code>return</code> statement because the <code>return</code> statement returns control from the program to the operating system, but a bare metal system doesn’t have an operating system. One of the jobs of the operating system is to start and stop programs (among other things). Since we don’t have an operating system, the processor halts whenever our program stops and does absolutely nothing. So we don’t stop. Ever. To see how we accomplish this, notice the <code>for(;;);</code> on line 19. This is C code for “loop forever” (<code>for(;;)</code>) and “do nothing” (the closing semicolon).</p>
<p><span epub:type="pagebreak" title="41" id="Page_41"/>But without an operating system, how do we start? Our program starts when the processor is turned on or is reset (hence the need for a big black reset button on the board).</p>
<p>As it stands now, our program doesn’t do anything and takes forever to do it. Let’s put in some code to do something.</p>
<h3 id="h2-501621c03-0003">Initializing the Hardware</h3>
<p class="BodyFirst">First, we need to initialize the hardware. To do so, we’ll make our first use of the HAL library. The HAL software layer is designed to hide all the ugly details involved with getting the chip to work. For example, we have to initialize the on-chip clock before we can use it to time the blinks of an LED. Doing this ourselves would require programming specific <em>I/O</em> <em>registers</em> that directly control how an I/O device acts. They are part of the hardware.</p>
<p>Although we could go through the chip’s 700-page reference manual to determine what registers to program, and then do all the calculations to figure out what values to program them with, this would take a lot of work.</p>
<p>Instead, we can use the HAL software, and specifically the <code>HAL_Init</code> function, to do all that work for us. The <code>HAL_Init</code> function programs the system clock so we can use it later to time our LED. Insert a call to <code>HAL_Init</code> just after the first curly bracket in the <code>main</code> function, as follows:</p>
<pre><code>int main(void)
{
    HAL_Init();</code></pre>
<p>In general, it’s best practice to indent by four spaces for every set of curly brackets you use. The C language does not require this, but it makes understanding the program easier. (There’s nothing magical about four spaces. Some programs use two, some eight, and a few strange people use three.)</p>
<p>That takes care of the basic hardware.</p>
<h3 id="h2-501621c03-0004">Programming a GPIO Pin</h3>
<p class="BodyFirst">The chip has a number of <em>general-purpose input/output pins</em>, referred to as <em>GPIO pins</em>, which we can program to either receive input or send output for a variety of things. For example, we can program a pin for output and connect it to an LED (which is exactly what we’ll do in this program). Alternatively, we can program a pin for input and connect it to a switch (which we’ll do in the next chapter).</p>
<p>Some of the microcontroller’s pins can be used as analog input or output. Most GPIO pins can be either on or off. Analog pins can handle voltages between on and off, such as 32765/65536 on. Others can be connected to a <em>USART</em> (serial I/O controller) or an <em>I2C bus</em> (simple I/O bus) to communicate with I2C peripheral chips. The good news is that these pins can do a lot of things. The bad news is that we have to program our chip to tell it, “Don’t do all that fancy stuff. Just turn on when I want you to turn on and turn off when I want you to turn off.”</p>
<p>We will program the GPIO pin that is connected to the user LED (LED2). We need to tell the chip that we are using this pin for output; then <span epub:type="pagebreak" title="42" id="Page_42"/>we must tell it a lot about how we are going to use it. This includes setting up a GPIO clock, which controls how fast it reacts. The HAL firmware can do most of this work, but we have to tell the HAL what to do by passing a structure of configuration information to the <code>HAL_GPIO_Init</code> function (C’s structure concept is covered in more detail in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>):</p>
<pre><code>// LED clock initialization
LED2_GPIO_CLK_ENABLE();

// Initialize LED
GPIO_InitTypeDef GPIO_InitStruct;
GPIO_InitStruct.Pin = LED2_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStruct);</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The STM hardware guys labeled this LED “LD2” on the board, but the software guys call it “LED2.” Therefore, if you set the control bit <code>LED2_PIN</code>, LD2 lights up. Consistency is wonderful.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>We set the pin on in order to transmit data to <code>LED2_PIN</code>, which is the one connected to the user LED. Next, we specify that the pin will be used for output because we’re sending data to the LED rather than retrieving data, and we set the mode to push/pull. This mode is determined by what you connect to the output pin. In this case, our circuit needs push/pull. This option controls the internal hardware used to drive the GPIO pin. The STM chip reference shows you how this circuit is organized (or, better put, it shows your hardware person how the chip is organized, and they can tell you which mode to use).</p>
<p>The pullup flags configure the GPIO pin so that, in input mode, a pullup resister is part of the circuit. This is irrelevant for output pins, but it still needs to be set. We set it to <code>GPIO_PULLUP</code>, which means absolutely nothing. Finally, we set the speed to high with <code>GPIO_SPEED_FREQ_HIGH</code>.</p>
<h3 id="h2-501621c03-0005">Toggling the LED</h3>
<p class="BodyFirst">Now remove the final <code>;</code> after the <code>for(;;)</code> statement. Remember that this semicolon essentially means “do nothing.” To introduce code that the <code>for</code> loop should execute, add these new lines:</p>
<pre><code>for(;;) {
    // Toggle LED2
    HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN);
    HAL_Delay(400); // Delay 400 ms
}</code></pre>
<p>The function <code>HAL_GPIO_TogglePin</code> toggles the <code>LED2</code> GPIO pin. On our chip, GPIO pins are organized into groups of 32 bits, collectively called a <em>GPIO register</em>. Our pin is in register <code>LED2_GPIO_PORT</code>. To tell the function which of the 32 GPIO pins to toggle, we specify <code>LED2_PIN</code>.</p>
<p><span epub:type="pagebreak" title="43" id="Page_43"/>After we toggle the pin, we need to do nothing for a while; otherwise, the LED will blink so fast we can’t see it. We use the <code>HAL_Delay</code> function to delay for 400 milliseconds (ms).</p>
<h3 id="h2-501621c03-0006">Building the Completed Program</h3>
<p class="BodyFirst">Our full program looks like this:</p>
<pre><code>/*
 * Blink the user LED on the board.
 *
 * A simple program to write, but getting it
 * working is going to require learning a
 * lot of new tools.
 */

#include "stm32f0xx.h"
#include "stm32f0xx_nucleo.h"

int main(void)
{
    HAL_Init();
    // LED clock initialization
    LED2_GPIO_CLK_ENABLE();

    // Initialize LED
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.Pin = LED2_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStruct);

    for(;;) {
        // Toggle LED2
        HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN);
        HAL_Delay(400); // Delay 400 ms
    }
}</code></pre>
<p>Now build the project by selecting <b>Project</b><span class="MenuArrow">▶</span><b>Build Project</b>. If everything went okay, you should see no problems in the Problems window. If there are problems, fix them and try again.</p>
<p>In the Console window, you’ll see that the IDE invoked <code>make</code>, which then invoked the GCC compiler named <code>arm-none-eabi-gcc</code>. This is the compiler for our embedded chip.</p>
<p>Start the program by selecting <b>Run</b><span class="MenuArrow">▶</span><b>Run</b>. (Be sure to click <b>Run</b> on the main menu. You can also right-click the project, but that runs a slightly different command.) The Run command hides a lot of work. First, the IDE checks whether the project needs to be built. Then it runs a program that takes the program file and communicates with the flash programmer on our development board to flash the program in memory. Finally, the programmer tells the chip to reset and start our program.</p>
<p><span epub:type="pagebreak" title="44" id="Page_44"/>As a result, you should see the green LED blink slowly.</p>
<h2 id="h1-501621c03-0004">Exploring the Build Process</h2>
<p class="BodyFirst">The Console window shown in <a href="#figure3-9" id="figureanchor3-9">Figure 3-9</a> contains the output of the build process. (If this window is empty, you can re-create the contents with <b>Project</b><span class="MenuArrow">▶</span><b>Clean </b>followed by <b>Project</b><span class="MenuArrow">▶</span><b>Build Project</b>.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If the menu item Build Project is not enabled, select the top-level project directory in the Project Explorer and try again.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<img src="image_fi/501621c03/f03009.png" alt="f03009" class=""/>
<figcaption><p><a id="figure3-9">Figure 3-9</a>: The Console window</p></figcaption>
</figure>
<p>Let’s scroll up and look at one line in the build process, a typical invocation of the GCC compiler:</p>
<pre><code>arm-none-eabi-gcc -mcpu=cortex-m0 -mthumb -mfloat-abi=soft \
-DSTM32 -DSTM32F0 -DSTM32F030R8Tx -DNUCLEOF030R8 -DDEBUG
-DSTM32F030x8 \ 
-DUSEHALDRIVER \
-I"/home/sdo/bare/workspace/blink/HALDriver/Inc/Legacy" \
-I"/home/sdo/bare/workspace/blink/Utilities/STM32F0xx-Nucleo" \
-I"/home/sdo/bare/workspace/blink/inc" \
-I"/home/sdo/bare/workspace/blink/CMSIS/device" \
-I"/home/sdo/bare/workspace/blink/CMSIS/core" \
-I"/home/sdo/bare/workspace/blink/HALDriver/Inc" \
-O0 -g3 -Wall -fmessage-length=0 -ffunction-sections \
-c -MMD -MP -MF"HALDriver/Src/stm32f0xxlltim.d" \
-MT"HALDriver/Src/stm32f0xxlltim.o" \
-o "HALDriver/Src/stm32f0xxlltim.o" "../HALDriver/Src/stm32f0xxll_tim.c"</code></pre>
<p><span epub:type="pagebreak" title="45" id="Page_45"/>This is a single line in the Console window, broken apart for formatting. As you can see, the compiler is being given a lot of additional options. The following are the key items on this command line:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">arm-none-eabi-gcc</code></span>  This is a GCC compiler, but unlike the native GCC, which compiles for your computer, it is a cross-compiler producing code for the ARM processor. There is no underlying operating system (hence the <code>none</code> option), and the system is designed for an embedded application binary interface (<code>eabi</code>), which defines how pieces of the program communicate with one another and with the outside world.</li>
<li><span class="RunInHead"><code class="bold">-mcpu=cortex-m0</code></span>  This produces code for the <code>cortex-m0</code> version of the CPU. ARM has multiple processor variations, and this flag tells GCC which version to use.</li>
<li><span class="RunInHead"><code class="bold">-mthumb</code></span>  Some ARM processors can execute two different instruction sets. There is the full 32-bit RISC instruction set, which executes very quickly but uses lots and lots of memory, and there is the <em>thumb</em> set, which is slower but far more compact. This directive tells GCC that we want thumb code (a good idea if you are using a cheap chip with limited memory, which we are).</li>
<li><span class="RunInHead"><code class="bold">-mfloat-abi=soft</code></span>  Our processor does not have floating-point hardware, so this flag tells GCC to fake it with software. (More on floating point can be found in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>.)</li>
<li><span class="RunInHead"><code class="bold">-O0</code></span>  Specifies level <code>0</code> (that is, no) optimization. This turns off a compiler feature where the compiler analyzes your code and performs all sorts of tricks to make it go faster. These tricks make the underlying code harder to understand and debug.</li>
<li><span class="RunInHead"><code class="bold">-g3</code></span>  Turns on debugging.</li>
<li><span class="RunInHead"><code class="bold">-Wall</code></span>  Turns on the set of warnings named <code>all</code>, which contains almost all of the useful warnings.</li>
<li><span class="RunInHead"><code class="bold">-c</code></span>  Compiles a single source file into a single object file.</li>
<li><span class="RunInHead"><code class="bold">-o"HALDriver/Src/stm32f0xxll_tim.o"</code></span>  Stores the object file in the given file.</li>
<li><span class="RunInHead"><code class="bold">"../HALDriver/Src/stm32f0xxll_tim.c"</code></span>  Specifies name of the source file.</li>
</ol>
<p>The other options tell the compiler where the included files are for the library and how these files should be configured. (We discuss the <code>-D</code> directive in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>.) The <code>-I</code> directive tells the compiler to search for include files in the specified directory in addition to the standard include file directories.</p>
<p>In addition to the compilation commands, we can see the linker command:</p>
<pre><code>arm-none-eabi-gcc -mcpu=cortex-m0 -mthumb -mfloat-abi=soft \
-T"/home/sdo/bare/workspace/blink/LinkerScript.ld" \
-Wl,-Map=output.map -Wl,--gc-sections \
-o "blink.elf" @"objects.list" -lm '''</code></pre>
<p>The key directive, <code>-T"/home/sdo/bare/workspace/blink/LinkerScript.ld"</code>, tells the linker to use <em>LinkerScript.ld</em> to tell it where to put the various pieces of the program. (This is discussed in detail in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>.)</p>
<p><span epub:type="pagebreak" title="46" id="Page_46"/>The build process ends with the following two commands:</p>
<pre><code>arm-none-eabi-objcopy -O binary "blink.elf" "blink.bin"
arm-none-eabi-size "blink.elf"
   text       data	    bss	    dec	    hex	filename
   2620       1088	   1604	   5312	   14c0	blink.elf</code></pre>
<p>The <code>arm-none-eabi-objcopy</code> command takes the <em>.elf</em> file and turns it into a raw binary image. ELF is a complex file format that tells the loader where to place various things. The raw binary image is exactly what’s going into your flash memory.</p>
<p>Finally, <code>arm-none-eabi-size</code> prints out the size of the resulting program (<a href="#table3-1" id="tableanchor3-1">Table 3-1</a>).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table3-1">Table 3-1</a>: Program Memory Section Sizes</p></figcaption>
<table id="table-501621c03-0001" border="1">
<thead>
<tr>
<td><b>Segment</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td>Size of read-only data (goes into flash)</td>
</tr>
<tr>
<td><code>data</code></td>
<td>Size of read/write data that requires initialization (goes into RAM)</td>
</tr>
<tr>
<td><code>bss</code></td>
<td>Size of read/write data that is initialized to zero (goes into RAM)</td>
</tr>
<tr>
<td><code>dec</code></td>
<td>Total size in decimal</td>
</tr>
<tr>
<td><code>hex</code></td>
<td>Total size in hexadecimal</td>
</tr>
</tbody>
</table>
</figure>
<p>We will explore the different types of memory, like flash and RAM, in later chapters. For now, understand that this step is done to answer the question, “If I keep programming, when will I run out of memory?”</p>
<h2 id="h1-501621c03-0005">Exploring the Project Files</h2>
<p class="BodyFirst">System Workbench for STM32 has created and downloaded a lot of files for our project. Let’s go through the key files.</p>
<p>We can view our <em>src</em> directory by clicking the triangle next to the directory name. It contains the files listed in <a href="#table3-2" id="tableanchor3-2">Table 3-2</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table3-2">Table 3-2</a>: The<em> src</em> Directory Files</p></figcaption>
<table id="table-501621c03-0002" border="1">
<thead>
<tr>
<td><b>File</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><em>main.c</em></td>
<td>The main program, where all our code goes.</td>
</tr>
<tr>
<td><em>stm32f0xxit.c</em></td>
<td>The interrupt service routines. You will learn about interrupts in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>. For this simple program, the only interrupt we care about is the system clock, and even then, we don’t see the details of it directly. It’s used by <code>HAL_Delay</code>.</td>
</tr>
<tr>
<td><em>syscalls.c</em></td>
<td>Dummy functions that are not used.</td>
</tr>
<tr>
<td><em>Systemstm32f0xx.c</em></td>
<td>Code that supports the system clock (explained in later chapters).</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="47" id="Page_47"/>The <em>startup</em> directory contains one file: <em>startup_stm32f030x8.S</em>. This is an assembly language file that performs just enough initialization that the processor can run C code; it then jumps to the C startup code. This program contains the first instruction executed when you press the reset button.</p>
<p>The <em>inc</em> directory contains one file, <em>stm32f0xx_it.h</em>, which is used to tell other programs about the interrupt handlers in <em>stm32f0xx_it.c</em>. It’s a very small and boring file.</p>
<p>Now we come to the <em>HAL_Driver</em> directory. This directory contains approximately 130 files that provide a HAL library for use in the program. The HAL hides (abstracts) the fact that different ARM CPUs have different capabilities. For example, the function <code>HAL_Init</code> will initialize all the hardware. If you have a Cortex-M0 processor, the Cortex-M0 version will initialize all the Cortex-M0 hardware. If you have a Cortex-M4 processor, all the Cortex-M4 hardware will be set up. There are so many files in this directory because the board we are using has lots of hardware. (And this is the simple version of the system.)</p>
<p>The <em>CMSIS</em> directory contains low-level code designed to support the HAL layer.</p>
<p>Finally, the <em>Debug</em> directory contains all the files related to our Debug build. In particular, it contains a <code>make</code> input file called <em>Makefile</em> and some generated files (see <a href="#table3-3" id="tableanchor3-3">Table 3-3</a>).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table3-3">Table 3-3</a>: Generated Files in the <em>Debug</em> Directory</p></figcaption>
<table id="table-501621c03-0003" border="1">
<thead>
<tr>
<td><b>File</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><em>blink.elf</em></td>
<td>Our program in ELF format (a file format for executables)</td>
</tr>
<tr>
<td><em>blink.bin</em></td>
<td>Our program as a memory image (raw code)</td>
</tr>
<tr>
<td><em>output.map</em></td>
<td>The memory map for the program</td>
</tr>
</tbody>
</table>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Unlike the makefile we wrote in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, this makefile is machine-generated and uses tons of very advanced <code>make</code> features. If you really want to understand everything that goes on in this file, search online for “GNU Make Manual” and spend a few hours with it.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The last file on our list is at the top level: <em>LinkerScript.ld</em>. It tells the linker what the memory layout of our chip looks like and where to load the various pieces of the program. More on this in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>.</p>
<h2 id="h1-501621c03-0006">Debugging the Application</h2>
<p class="BodyFirst">Our blink program is simple and it works, but later we’re going to make more complex programs, and they will have bugs in them. Since the board we are programming has such a good debugger, we might as well get started learning how to use it. Start the debugger by selecting <b>Run</b><span class="MenuArrow">▶</span><b>Debug</b>, as shown in <a href="#figure3-10" id="figureanchor3-10">Figure 3-10</a>.</p>
<span epub:type="pagebreak" title="48" id="Page_48"/><figure>
<img src="image_fi/501621c03/f03010.png" alt="f03010" class=""/>
<figcaption><p><a id="figure3-10">Figure 3-10</a>: Starting the debugger</p></figcaption>
</figure>
<p>The IDE will then ask you for what type of debugger to run, as shown in <a href="#figure3-11" id="figureanchor3-11">Figure 3-11</a>. Select <b>Ac6 STM32 C/C++ Application</b>.</p>
<figure>
<img src="image_fi/501621c03/f03011.png" alt="f03011" class=""/>
<figcaption><p><a id="figure3-11">Figure 3-11</a>: Debugger selection</p></figcaption>
</figure>
<p>The system will ask if you want to “Switch to the Debug Perspective.” Answer <b>Yes</b>. The system then goes through a number of steps automatically:</p>
<ol class="decimal">
<li value="1">It builds the software.</li>
<li value="2">The IDE downloads the program to the chip using the flash programmer.</li>
<li value="3"><span epub:type="pagebreak" title="49" id="Page_49"/>A debugger is attached to the device through the JTAG interface.</li>
<li value="4">The debugger sets a breakpoint at the first line of <code>main</code>.</li>
<li value="5">The breakpoint tells the chip to stop just before the first line of <code>main</code> is executed.</li>
<li value="6">The microprocessor resets, and the program runs up to <code>main</code>.</li>
<li value="7">The debugger regains control when the program reaches the breakpoint at <code>main</code>.</li>
</ol>
<p>Once the debugger reaches the breakpoint, you are ready to debug the program, as seen in <a href="#figure3-12" id="figureanchor3-12">Figure 3-12</a>. At this point, the program has executed until the first statement of the <code>main</code> function and is paused before the call to <code>HAL_Init</code>.</p>
<figure>
<img src="image_fi/501621c03/f03012.png" alt="f03012" class=""/>
<figcaption><p><a id="figure3-12">Figure 3-12</a>: Debugging the program</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The light in the corner of the Nucleo board flashing red and green indicates that the board is under the control of the external debugger.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Now that we’ve got control, let’s use it. Use the command <b>Run</b><span class="MenuArrow">▶</span><b>Step Over</b> to start executing the program one line at a time. We’ll do this a number of times, so remember the shortcut key F6. Keep stepping over lines using F6 until you get into the <code>for</code> loop.</p>
<p>Notice that every time you execute the <code>HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN)</code> function, the LED turns on or off. Since you are in the <code>for</code> loop, you ping-pong back and forth indefinitely between the toggling and the delay. If you are really observant, you’ll notice that it takes a little over 400 ms (two-fifths of a second) to execute the call to <code>HAL_Delay</code>. You can change this value to something really big if you would like to better observe the delay.</p>
<h2 id="h1-501621c03-0007"><span epub:type="pagebreak" title="50" id="Page_50"/>Stepping Through the Program</h2>
<p class="BodyFirst">Now we’ll get into some of the details of this program. Most of the concepts are covered in more depth in future chapters, but I’ll give you a taste of them now. First, let’s abort the current debugging session with <b>Run</b><span class="MenuArrow">▶</span><b>Terminate</b>. Now let’s start all over again, with <b>Run</b><span class="MenuArrow">▶</span><b>Debug</b>. You should be back to the line that calls <code>HAL_Init</code>. To step through the program, use a different command, <b>Run</b><span class="MenuArrow">▶</span><b>Step Into </b>(or shortcut key F5).</p>
<p>All of a sudden, the file <em>stm32f0xx_hal.c</em> appears in our editing window (see <a href="#figure3-13" id="figureanchor3-13">Figure 3-13</a>). Where did this file come from?</p>
<figure>
<img src="image_fi/501621c03/f03013.png" alt="f03013" class=""/>
<figcaption><p><a id="figure3-13">Figure 3-13</a>: Debugging <em>stm32f0xx_hal.c</em></p></figcaption>
</figure>
<p>Well, we called the procedure <code>HAL_Init</code>. That procedure is defined in <em>stm32f0xx_hal.c</em>, so the debugger automatically opened that file when we stepped into the call to <code>HAL_Init</code>. Alternatively, the Step Over command would treat the statement (in this case, <code>HAL_INIT();</code>) as a single unit and step over the function, hiding all the details.</p>
<p>The Step Into command knows we are calling a function and steps into its code. As you can see, it takes a lot of extra code to support our little program. When you program on a PC, the code is hidden from you, and it’s very difficult to get its source. The STM32 Workbench supplies all that code for you in the <em>HAL_Driver/Src</em> directory.</p>
<p>In addition to showing the code inside functions, the debugger can show us the status of all program variables. To see this in action, select <b>Run</b><span class="MenuArrow">▶</span><b>Step Over </b>(or press F6) about half a dozen times until you wind up back in <em>main.c</em> at the line that selects the pin to use. In the upper-right corner of the screen, you’ll see a panel titled Variables (see <a href="#figure3-14" id="figureanchor3-14">Figure 3-14</a>).</p>
<figure>
<img src="image_fi/501621c03/f03014.png" alt="f03014" class=""/>
<figcaption><p><a id="figure3-14">Figure 3-14</a>: The Variables panel</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="51" id="Page_51"/>In our program, we’ve defined a variable called <code>GPIO_InitStruct</code>. In the Variables panel, the + before the name indicates that <code>GPIO_InitStruct</code> is a <em>complex</em> variable, which means that it contains more than a simple integer, Boolean, or other single value. To see the all the components inside, expand it by clicking the + icon (see <a href="#figure3-15" id="figureanchor3-15">Figure 3-15</a>).</p>
<figure>
<img src="image_fi/501621c03/f03015.png" alt="f03015" class=""/>
<figcaption><p><a id="figure3-15">Figure 3-15</a>: An expanded variable</p></figcaption>
</figure>
<p>You’ll learn about the components of <code>GPIO_InitStruct</code>, and how to create variables yourself, in later chapters. The <code>GPIO_InitStruct</code> variable was created by a programmer who read the 700-page reference manual on our chip and designed a variable to hold this information. Believe it or not, this variable significantly simplifies what’s presented in the manual: about 30 pages of compressed technical information on just the GPIO subsystem.</p>
<p>Now step through the next few statements to see the values of the components of this variable.</p>
<h2 id="h1-501621c03-0008">Summary</h2>
<p class="BodyFirst">I’ve tried to make this program as simple as possible, but as you can see, with today’s complex chips, even the simplest operation takes a bit of work. Getting a program running requires a lot of support.</p>
<p>In the first chapter, our “Hello World” program required pretty much the same number of files mentioned here, but they existed behind the scenes. For example, the initialization file was installed as part of the GCC package. In our blink project, the file <em>startup_stm32f030x8.S</em> must be explicitly included.</p>
<p>This chapter threw a ton of new concepts at you. Don’t worry if you don’t understand them all yet. We’ll dive deeper into them in future chapters.</p>
<h2 id="h1-501621c03-0009"><span epub:type="pagebreak" title="52" id="Page_52"/>Programming Problems</h2>
<ol class="decimal">
<li value="1">Experiment with changing the delay in the <code>Hal_Delay();</code> statement to make the blink frequency longer and shorter.</li>
<li value="2">Examine <em>LinkerScript.ld</em> to find the answers to the following questions:<ol class="lower-alpha">
<li value="1">How much flash (read-only) memory do you have?</li>
<li value="2">How much RAM (read/write memory) do you have?</li>
</ol>
</li>
<li value="3">Examine the file <em>output.map</em> and determine the actual address of <code>Reset_Handler</code>.</li>
<li value="4">For intermediate readers: Change the program so it turns the LED on for a short time, then off for a longer time.</li>
</ol>
<h2 id="h1-501621c03-0010">Questions</h2>
<ol class="decimal">
<li value="1">What files are generated by the IDE, and what do they contain?</li>
<li value="2">Where on your system did the IDE stash the compiler?</li>
<li value="3">What does a commercial JTAG debugger look like? How much does it cost? What does it take to hook it up to a typical development board? (And be glad you got an integrated system!)</li>
</ol>
</section>
</body></html>