<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="291" id="Page_291"/>11</span><br/>
<span class="ChapterTitle">Introduction to Shell Scripts</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">If you can enter commands into the shell, you can write shell scripts. A <em>shell script</em> (also known as a <em>Bourne shell script</em>) is a series of commands written in a file; the shell reads the commands from the file just as it would if you typed them into a terminal. </p>
<h2 id="h1-500402c11-0001">	11.1	Shell Script Basics</h2>
<p class="BodyFirst">Bourne shell scripts generally start with the following line, which indicates that the <code>/bin/sh</code> program should execute the commands in the script file. (Make sure that there’s no whitespace at the beginning of the script file.) </p>
<pre><code>#!/bin/sh</code></pre>
<p><span epub:type="pagebreak" title="292" id="Page_292"/>The <code>#!</code> part is called a <em>shebang</em>; you’ll see it in other scripts in this book. You can list any commands that you want the shell to execute following the <code>#!/bin/sh</code> line. For example: </p>
<pre><code>#!/bin/sh
#
# Print something, then run ls

echo About to run the ls command.
ls</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	With the exception of the shebang at the top of a script, a <var>#</var> character at the beginning of a line indicates a comment; that is, the shell ignores anything on the line after the <var>#</var>. Use comments to explain parts of your scripts that could be difficult to understand for others reading your code or to jog your own memory when you come back to the code later. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>As with any program on Unix systems, you need to set the executable bit for a shell script file, but you must also set the read bit in order for the shell to be able to read the file. The easiest way to do this is as follows: </p>
<pre><code>$ <b>chmod +rx</b> <var class="bold">script</var></code></pre>
<p>This <code>chmod</code> command allows other users to read and execute <var>script</var>. If you don’t want that, use the absolute mode <code>700</code> instead (and refer to <span class="xref" itemid="xref_target_Section 2.17">Section 2.17</span> for a refresher on permissions).  </p>
<p>After creating a shell script and setting read and execute permissions, you can run it by placing the script file in one of the directories in your command path and then running the script name on the command line. You can also run <code>./</code><var>script</var> if the script is located in your current working directory, or you can use the full pathname.</p>
<p>Running a script with a shebang is almost (but not quite) the same as running a command with your shell; for example, running a script called <code>myscript</code> causes the kernel to run <code>/bin/sh myscript</code>. </p>
<p>With the basics behind us, let’s look at some of the limitations of shell scripts.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The shebang doesn’t have to be <var>#!/bin/sh</var>; it can be built to run anything on your system that accepts scripting input, such as <var>#!/usr/bin/python</var> to run Python programs. In addition, you might come across scripts with a different pattern that includes <var>/usr/bin/env</var>. For example, you might see something like <var>#!/usr/bin/env python</var> as the first line. This instructs the <var>env</var> utility to run <var>python</var>. The reason for this is fairly simple; <var>env</var> looks for the command to run in the current command path, so you don’t need a standardized location for the executable. The disadvantage is that the first matching executable in the command path might not be what you want.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c11-0001">11.1.1	Limitations of Shell Scripts</h3>
<p class="BodyFirst">The Bourne shell manipulates commands and files with relative ease. In <span class="xref" itemid="xref_target_Section 2.14">Section 2.14</span>, you saw the way the shell can redirect output, one of the <span epub:type="pagebreak" title="293" id="Page_293"/>important elements of shell script programming. However, the shell script is only one tool for Unix programming, and although scripts have considerable power, they also have limitations. </p>
<p>One of the main strengths of shell scripts is that they can simplify and automate tasks that you can otherwise perform at the shell prompt, like manipulating batches of files. But if you’re trying to pick apart strings, perform repeated arithmetic computations, or access complex databases, or if you want functions and complex control structures, you’re better off using a scripting language like Python, Perl, or <code>awk</code>, or perhaps even a compiled language like C. (This is important, so you’ll see it throughout the chapter.)</p>
<p>Finally, be aware of your shell script sizes. Keep your shell scripts short. Bourne shell scripts aren’t meant to be big, though you will undoubtedly encounter some monstrosities. </p>
<h2 id="h1-500402c11-0002">	11.2	Quoting and Literals</h2>
<p class="BodyFirst">One of the most confusing elements of working with the shell and scripts is knowing when and why to use quotation marks (quotes) and other punctuation. Let’s say you want to print the string <code>$100</code> and you do the following:</p>
<pre><code>$ <b>echo $100</b>
00</code></pre>
<p>Why did this print <code>00</code>? Because <code>$1</code> has a <code>$</code> prefix, which the shell interprets as a shell variable (we’ll cover these soon). You think to yourself that maybe if you surround it with double quotes, the shell will leave the <code>$1</code> alone:</p>
<pre><code>$ <b>echo "$100"</b>
00</code></pre>
<p>That still didn’t work. You ask a friend, who says that you need to use single quotes instead:</p>
<pre><code>$ <b>echo '$100'</b>
$100</code></pre>
<p>Why did this particular incantation work?</p>
<h3 id="h2-500402c11-0002">11.2.1	Literals</h3>
<p class="BodyFirst">When you use quotes, you’re often trying to create a <em>literal</em>, a string that the shell should not analyze (or try to change) before passing it to the command line. In addition to the <code>$</code> in the example that you just saw, this often comes up when you want to pass a <code>*</code> character to a command such as <code>grep</code> instead of having the shell expand it, and when you need to use a semicolon (<code>;</code>) in a command.</p>
<p><span epub:type="pagebreak" title="294" id="Page_294"/>When writing scripts and working on the command line, remember what happens when the shell runs a command:</p>
<ol class="decimal">
<li value="1">Before running the command, the shell looks for variables, globs, and other substitutions and performs the substitutions if they appear.</li>
<li value="2">The shell passes the results of the substitutions to the command.</li>
</ol>
<p>Problems involving literals can be subtle. Let’s say you’re looking for all entries in <em>/etc/passwd</em> that match the regular expression <code>r.*t</code> (that is, a line that contains an <code>r</code> followed by a <code>t</code> later in the line, which would enable you to search for usernames such as <code>root</code> and <code>ruth</code> and <code>robot</code>). You can run this command:</p>
<pre><code>$ <b>grep r.*t /etc/passwd</b></code></pre>
<p>It works most of the time, but sometimes it mysteriously fails. Why? The answer is probably in your current directory. If that directory contains files with names such as <em>r.input</em> and <em>r.output</em>, then the shell expands <code>r.*t</code> to <code>r.input r.output</code> and creates this command:</p>
<pre><code>$ <b>grep r.input r.output /etc/passwd</b></code></pre>
<p>The key to avoiding problems like this is to first recognize the characters that can get you in trouble and then apply the correct kind of quotes to protect those characters.</p>
<h3 id="h2-500402c11-0003">11.2.2	Single Quotes</h3>
<p class="BodyFirst">The easiest way to create a literal and make the shell leave a string alone is to enclose the entire string in single quotes (<code>'</code>), as in this example with <code>grep</code> and the <code>*</code> character:</p>
<pre><code>$ <b>grep 'r.*t' /etc/passwd</b></code></pre>
<p>As far as the shell is concerned, all characters between two single quotes, including spaces, make up a single parameter. Therefore, the following command does <em>not</em> work, because it asks the <code>grep</code> command to search for the string <code>r.*t /etc/passwd</code> in the standard input (because there’s only one parameter to <code>grep</code>): </p>
<pre><code>$ <b>grep 'r.*t /etc/passwd'</b></code></pre>
<p>When you need to use a literal, you should always turn to single quotes first, because you’re guaranteed that the shell won’t try <em>any</em> substitutions. As a result, it’s a generally clean syntax. However, sometimes you need a little more flexibility, so you can turn to double quotes.</p>
<h3 id="h2-500402c11-0004"><span epub:type="pagebreak" title="295" id="Page_295"/>11.2.3	Double Quotes</h3>
<p class="BodyFirst">Double quotes (<code>"</code>) work just like single quotes, except that the shell expands any variables that appear within double quotes. You can see the difference by running the following command and then replacing the double quotes with single quotes and running it again. </p>
<pre><code>$ <b>echo "There is no * in my path: $PATH"</b></code></pre>
<p>When you run the command, notice that the shell substitutes for <code>$PATH</code> but does not substitute for the <code>*</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re using double quotes when working with large amounts of text, consider using a <span class="Regular">here</span> document, as described in <span class="xref" itemid="xref_target_Section 11.9">Section 11.9</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c11-0005">11.2.4	Literal Single Quotes</h3>
<p class="BodyFirst">Using literals with the Bourne shell can be tricky when you’re passing a literal single quote to a command. One way to do this is to place a backslash before the single quote character: </p>
<pre><code>$ <b>echo I don\'t like contractions inside shell scripts.</b></code></pre>
<p>The backslash and quote <em>must</em> appear outside any pair of single quotes. A string such as <code>'don\'t</code> results in a syntax error. Oddly enough, you can enclose the single quote inside double quotes, as shown in the following example (the output is identical to that of the preceding command): </p>
<pre><code>$ <b>echo "I don't like contractions inside shell scripts."</b></code></pre>
<p>If you’re in a bind and you need a general rule to quote an entire string with no substitutions, follow this procedure:</p>
<ol class="decimal">
<li value="1">Change all instances of <code>'</code> (single quote) to <code>'\''</code> (single quote, backslash, single quote, single quote).</li>
<li value="2">Enclose the entire string in single quotes.</li>
</ol>
<p>Therefore, you can quote an awkward string such as <code>this isn't a forward slash: \</code> as follows:</p>
<pre><code>$ <b>echo 'this isn'\''t a forward slash: \'</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	It's worth repeating that when you quote a string, the shell treats everything inside the quotes as a single parameter. Therefore, <var>a b c</var> counts as three parameters, but <var>a</var><code> </code><var>"b c"</var> is only two.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c11-0003"><span epub:type="pagebreak" title="296" id="Page_296"/>	11.3	Special Variables</h2>
<p class="BodyFirst">Most shell scripts understand command-line parameters and interact with the commands that they run. To take your scripts from being just a simple list of commands to becoming more flexible shell script programs, you need to know how to use the special Bourne shell variables. These special variables are like any other shell variable as described in <span class="xref" itemid="xref_target_Section 2.8">Section 2.8</span>, except that you can’t change the values of certain ones. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	After reading the next few sections, you’ll understand why shell scripts accumulate many special characters as they are written. If you’re trying to understand a shell script and you come across a line that looks completely incomprehensible, pick it apart piece by piece. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c11-0006">11.3.1	Individual Arguments: $1, $2, and So On</h3>
<p class="BodyFirst"><code>$1</code>, <code>$2</code>, and all variables named as positive nonzero integers contain the values of the script parameters, or <em>arguments</em>. For example, say the name of the following script is <em>pshow</em>: </p>
<pre><code>#!/bin/sh
echo First argument: $1
echo Third argument: $3</code></pre>
<p>Try running the script as follows to see how it prints the arguments: </p>
<pre><code>$ <b>./pshow one two three</b>
First argument: one
Third argument: three</code></pre>
<p>The built-in shell command <code>shift</code> can be used with argument variables to remove the first argument (<code>$1</code>) and advance the rest of the arguments so that <code>$2</code> becomes <code>$1</code>, <code>$3</code> becomes <code>$2</code>, and so on. For example, assume that the name of the following script is <em>shiftex</em>: </p>
<pre><code>#!/bin/sh
echo Argument: $1 
shift
echo Argument: $1
shift
echo Argument: $1</code></pre>
<p>Run it like this to see it work:</p>
<pre><code>$ <b>./shiftex one two three</b> 
Argument: one
Argument: two
Argument: three</code></pre>
<p><span epub:type="pagebreak" title="297" id="Page_297"/>As you can see, <code>shiftex</code> prints all three arguments by printing the first, shifting the remaining arguments, and repeating.</p>
<h3 id="h2-500402c11-0007">11.3.2	Number of Arguments: $#</h3>
<p class="BodyFirst">The <code>$#</code> variable holds the number of arguments passed to a script and is especially important when you’re running <code>shift</code> in a loop to pick through arguments. When <code>$#</code> is <code>0</code>, no arguments remain, so <code>$1</code> is empty. (See <span class="xref" itemid="xref_target_Section 11.6">Section 11.6</span> for a description of loops.) </p>
<h3 id="h2-500402c11-0008">11.3.3	All Arguments: $@</h3>
<p class="BodyFirst">The <code>$@</code> variable represents all of a script’s arguments and is very useful for passing them to a command inside the script. For example, Ghostscript commands (<code>gs</code>) are usually long and complicated. Suppose you want a shortcut for rasterizing a PostScript file at 150 dpi, using the standard output stream, while also leaving the door open for passing other options to <code>gs</code>. You could write a script like this to allow for additional command-line options: </p>
<pre><code>#!/bin/sh
gs -q -dBATCH -dNOPAUSE -dSAFER -sOutputFile=- -sDEVICE=pnmraw $@</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If a line in your shell script gets too long , making it difficult to read and manipulate in your text editor, you can split it up with a backslash ( <code>\</code>). For example, you can alter the preceding script as follows: </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<pre><code>#!/bin/sh
gs -q -dBATCH -dNOPAUSE -dSAFER <b>\</b>
   -sOutputFile=- -sDEVICE=pnmraw $@</code></pre>
<h3 id="h2-500402c11-0009">11.3.4	Script Name: $0</h3>
<p class="BodyFirst">The <code>$0</code> variable holds the name of the script and is useful for generating diagnostic messages. For example, say your script needs to report an invalid argument that is stored in the <code>$BADPARM</code> variable. You can print the diagnostic message with the following line so that the script name appears in the error message: </p>
<pre><code>echo $0: bad option $BADPARM</code></pre>
<p>All diagnostic error messages should go to the standard error. As explained in <span class="xref" itemid="xref_target_Section 2.14.1">Section 2.14.1</span>, <code>2&gt;&amp;1</code> redirects the standard error to the standard output. For writing to the standard error, you can reverse the process with <code>1&gt;&amp;2</code>. To do this for the preceding example, use this: </p>
<pre><code>echo $0: bad option $BADPARM 1&gt;&amp;2</code></pre>
<h3 id="h2-500402c11-0010"><span epub:type="pagebreak" title="298" id="Page_298"/>11.3.5	Process ID: $$</h3>
<p class="BodyFirst">The <code>$$</code> variable holds the process ID of the shell. </p>
<h3 id="h2-500402c11-0011">11.3.6	Exit Code: $?</h3>
<p class="BodyFirst">The <code>$?</code> variable holds the exit code of the last command that the shell executed. Exit codes, which are critical to mastering shell scripts, are discussed next. </p>
<h2 id="h1-500402c11-0004">	11.4	Exit Codes</h2>
<p class="BodyFirst">When a Unix program finishes, it leaves an <em>exit code</em>, a numeric value also known as an <em>error code</em> or <em>exit value</em>, for the parent process that started the program. When the exit code is zero (<code>0</code>), it typically means that the program ran without a problem. However, if the program has an error, it usually exits with a number other than <code>0</code> (but not always, as you’ll see next). </p>
<p>The shell holds the exit code of the last command in the <code>$?</code> special variable, so you can check it out at your shell prompt: </p>
<pre><code>$ <b>ls / &gt; /dev/null</b>
$ <b>echo $?</b>
0
$ <b>ls /asdfasdf &gt; /dev/null</b>
ls: /asdfasdf: No such file or directory
$ <b>echo $?</b>
1</code></pre>
<p>You can see that the successful command returned <code>0</code> and the unsuccessful command returned <code>1</code> (assuming, of course, that you don’t have a directory named <em>/asdfasdf</em> on your system).</p>
<p>If you intend to use a command’s exit code, you <em>must</em> use or store that code immediately after running the command (because the next command you run overwrites the previous code). For example, if you run <code>echo $?</code> twice in a row, the output of the second command is always <code>0</code> because the first <code>echo</code> command completes successfully. </p>
<p>When writing shell code, you may come across situations where your script needs to halt due to an error (such as a bad filename). Use <code>exit 1</code> in your script to terminate and pass an exit code of <code>1</code> back to whatever parent process ran the script. (You can use different nonzero numbers if your script has various abnormal exit conditions.)</p>
<p>Note that some programs, like <code>diff</code> and <code>grep</code>, use nonzero exit codes to indicate normal conditions. For example, <code>grep</code> returns <code>0</code> if it finds something matching a pattern and <code>1</code> if it doesn’t. For these programs, an exit code of <code>1</code> is not an error, so <code>grep</code> and <code>diff</code> use the exit code <code>2</code> if they encounter an actual problem. If you think a program might be using a nonzero exit code to indicate success, read its manual page. The exit codes are usually explained in the EXIT VALUE or DIAGNOSTICS section.</p>
<h2 id="h1-500402c11-0005"><span epub:type="pagebreak" title="299" id="Page_299"/>	11.5	Conditionals</h2>
<p class="BodyFirst">The Bourne shell has special constructs for conditionals, including <code>if</code>/<code>then</code>/<code>else</code> and <code>case</code> statements. For example, this simple script with an <code>if</code> conditional checks to see whether the script’s first argument is <code>hi</code>: </p>
<pre><code>#!/bin/sh
if [ $1 = hi ]; then
   echo 'The first argument was "hi"'
else
   echo -n 'The first argument was not "hi" -- '
   echo It was '"'$1'"'
fi</code></pre>
<p>The words <code>if</code>, <code>then</code>, <code>else</code>, and <code>fi</code> in the preceding script are shell keywords; everything else is a command. This distinction is extremely important because it’s easy to mistake the conditional, <code>[ $1 = "hi" ]</code>, for special shell syntax. In fact, the <code>[</code> character is an actual program on a Unix system. All Unix systems have a command called <code>[</code> that performs tests for shell script conditionals. This program is also known as <code>test</code>; the manual pages for <code>test</code> and <code>[</code> are the same. (You’ll soon learn that the shell doesn’t always run <code>[</code>, but for now you can think of it as a separate command.)</p>
<p>Here’s where it’s vital to understand the exit codes as explained in <span class="xref" itemid="xref_target_Section 11.4">Section 11.4</span>. Let’s look at how the previous script actually works: </p>
<ol class="decimal">
<li value="1">The shell runs the command after the <code>if</code> keyword and collects the exit code of that command. </li>
<li value="2">If the exit code is <code>0</code>, the shell executes the commands that follow the <code>then</code> keyword, stopping when it reaches an <code>else</code> or <code>fi</code> keyword. </li>
<li value="3">If the exit code is not <code>0</code> and there’s an <code>else</code> clause, the shell runs the commands after the <code>else</code> keyword. </li>
<li value="4">The conditional ends at <code>fi</code>. </li>
</ol>
<p>We’ve established that the test following <code>if</code> is a command, so let’s look at the semicolon (<code>;</code>). It’s just the regular shell marker for the end of a command, and it’s there because we put the <code>then</code> keyword on the same line. Without the semicolon, the shell passes <code>then</code> as a parameter to the <code>[</code> command, which often results in an error that isn’t easy to track. You can avoid the semicolon by placing the <code>then</code> keyword on a separate line as follows:</p>
<pre><code>if [ $1 = hi ]
then
   echo 'The first argument was "hi"'
fi</code></pre>
<h3 id="h2-500402c11-0012">11.5.1	A Workaround for Empty Parameter Lists</h3>
<p class="BodyFirst">There’s a potential problem with the conditional in the preceding example, due to a commonly overlooked scenario: <code>$1</code> could be empty, because the <span epub:type="pagebreak" title="300" id="Page_300"/>user might run the script with no parameters. If <code>$1</code> is empty, the test reads <code>[ = hi ]</code>, and the <code>[</code> command will abort with an error. You can fix this by enclosing the parameter in quotes in one of two common ways:</p>
<pre><code>if [ "$1" = hi ]; then
if [ x"$1" = x"hi" ]; then</code></pre>
<h3 id="h2-500402c11-0013">11.5.2	Other Commands for Tests</h3>
<p class="BodyFirst">There are many possibilities for using commands other than <code>[</code> for tests. Here’s an example that uses <code>grep</code>:</p>
<pre><code>#!/bin/sh
if grep -q daemon /etc/passwd; then
    echo The daemon user is in the passwd file.
else
    echo There is a big problem. daemon is not in the passwd file.
fi</code></pre>
<h3 id="h2-500402c11-0014">11.5.3	elif</h3>
<p class="BodyFirst">There is also an <code>elif</code> keyword that lets you string <code>if</code> conditionals together, as shown here: </p>
<pre><code>#!/bin/sh
if [ "$1" = "hi" ]; then
   echo 'The first argument was "hi"'
elif [ "$2" = "bye" ]; then
   echo 'The second argument was "bye"'
else
   echo -n 'The first argument was not "hi" and the second was not "bye"-- '
   echo They were '"'$1'"' and '"'$2'"'
fi</code></pre>
<p>Keep in mind that the control flows only through the first successful conditional, so if you run this script with the arguments <code>hi bye</code>, you’ll only get confirmation of the <code>hi</code> argument.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Don’t get too carried away with <code>elif</code>, because the <code>case</code> construct (which you’ll see in <span class="xref" itemid="xref_target_Section 11.5.6">Section 11.5.6</span>) is often more appropriate.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c11-0015">11.5.4	Logical Constructs</h3>
<p class="BodyFirst">There are two quick, one-line conditional constructs that you may see from time to time, using the <code>&amp;&amp;</code> (“and”) and <code>||</code> (“or”) syntax. The <code>&amp;&amp;</code> construct works like this: </p>
<pre><code><var>command1</var> <code>&amp;&amp;</code><var> command2</var></code></pre>
<p><span epub:type="pagebreak" title="301" id="Page_301"/>Here, the shell runs <var>command1</var>, and if the exit code is <code>0</code>, the shell also runs <var>command2</var>.</p>
<p>The <code>||</code> construct is similar; if the command before a <code>||</code> returns a nonzero exit code, the shell runs the second command. </p>
<p>The constructs <code>&amp;&amp;</code> and <code>||</code> are often used in <code>if</code> tests, and in both cases, the exit code of the last command run determines how the shell processes the conditional. In the case of the <code>&amp;&amp;</code> construct, if the first command fails, the shell uses its exit code for the <code>if</code> statement, but if the first command succeeds, the shell uses the exit code of the second command for the conditional. In the case of the <code>||</code> construct, the shell uses the exit code of the first command if successful, or the exit code of the second if the first is unsuccessful. </p>
<p>For example: </p>
<pre><code>#!/bin/sh
if [ "$1" = hi ] || [ "$1" = bye ]; then
    echo 'The first argument was "'$1'"'
fi</code></pre>
<p>If your conditionals include the test command (<code>[</code>), as shown here, you can use <code>-a</code> and <code>-o</code> instead of <code>&amp;&amp;</code> and <code>||</code>, for example:</p>
<pre><code>#!/bin/sh
if [ "$1" = hi  -o "$1" = bye ]; then
   echo 'The first argument was "'$1'"'
fi</code></pre>
<p>You can invert a test (that is, a logical not) by placing the <code>!</code> operator before a test. For example:</p>
<pre><code>#!/bin/sh
if [ ! "$1" = hi  ]; then
   echo 'The first argument was not hi'
fi</code></pre>
<p>In this specific case of comparisons, you might see <code>!=</code> used as an alternative, but <code>!</code> can be used with any of the condition tests described in the next section.</p>
<h3 id="h2-500402c11-0016">11.5.5	Testing Conditions</h3>
<p class="BodyFirst">You’ve seen how <code>[</code> works: the exit code is <code>0</code> if the test is true and nonzero when the test fails. You also know how to test string equality with <code>[ </code><var>str1</var><code> = </code><var>str2</var><code> ]</code>. However, remember that shell scripts are well suited to operations on entire files because many useful <code>[</code> tests involve file properties. For example, the following line checks whether <var>file</var> is a regular file (not a directory or special file): </p>
<pre><code>[ -f <var>file</var> ]</code></pre>
<p><span epub:type="pagebreak" title="302" id="Page_302"/>In a script, you might see the <code>-f</code> test in a loop similar to this one, which tests all of the items in the current working directory (you’ll learn more about loops in <span class="xref" itemid="xref_target_Section 11.6">Section 11.6</span>): </p>
<pre><code>for filename in *; do
    if [ -f $filename ]; then
        ls -l $filename
        file $filename
    else
        echo $filename is not a regular file.
    fi
done  </code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Because the <var>test</var> command is so widely used in scripts, it’s built in to many versions of the Bourne shell (including <var>bash</var>). This can speed up scripts because the shell doesn’t have to run a separate command for each test.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>There are dozens of test operations, all of which fall into three general categories: file tests, string tests, and arithmetic tests. The info manual contains complete online documentation, but the test(1) manual page is a fast reference. The following sections outline the main tests. (I’ve omitted some of the less common ones.) </p>
<h4 id="h3-500402c11-0001">File Tests</h4>
<p class="BodyFirst">Most file tests, like <code>-f</code>, are called <em>unary</em> operations because they require only one argument: the file to test. For example, here are two important file tests: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">-e</code></span>  Returns true if a file exists</li>
<li><span class="RunInHead"><code class="bold">-s</code></span>  Returns true if a file is not empty</li>
</ol>
<p>Several operations inspect a file’s type, meaning that they can determine whether something is a regular file, a directory, or some kind of special device, as listed in <a href="#table11-1" id="tableanchor11-1">Table 11-1</a>. There are also a number of unary operations that check a file’s permissions, as listed in <a href="#table11-2" id="tableanchor11-2">Table 11-2</a>. (See <span class="xref" itemid="xref_target_Section 2.17">Section 2.17</span> for an overview of permissions.)</p>
<figure>
<figcaption class="TableTitle"><p><a id="table11-1">Table 11-1</a>: File Type Operators</p></figcaption>
<table id="table-500402c11-0001" border="1">
<thead>
<tr>
<td><b>Operator</b></td><td><b>Tests for</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>-f</code></td><td>Regular file</td></tr>
<tr>
<td><code>-d</code></td><td>Directory</td></tr>
<tr>
<td><code>-h</code></td><td>Symbolic link</td></tr>
<tr>
<td><code>-b</code></td><td>Block device</td></tr>
<tr>
<td><code>-c</code></td><td>Character device</td></tr>
<tr>
<td><code>-p</code></td><td>Named pipe</td></tr>
<tr>
<td><code>-S</code></td><td>Socket</td></tr>
</tbody>
</table>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="303" id="Page_303"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	If the <var>test</var> command is used on a symbolic link, it tests the actual object being linked to, not the link itself (except for the <var>-h</var> test). That is, if  <code>link</code> is a symbolic link to a regular file, <var>[ -f </var><code>link</code><var> ]</var> returns an exit code of true (<code>0</code>). </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<figcaption class="TableTitle"><p><a id="table11-2">Table 11-2</a>: File Permissions Operators</p></figcaption>
<table id="table-500402c11-0002" border="1">
<thead>
<tr>
<td><b>Operator</b></td><td><b>Permission</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>-r</code></td><td>Readable</td></tr>
<tr>
<td><code>-w</code></td><td>Writable</td></tr>
<tr>
<td><code>-x</code></td><td>Executable</td></tr>
<tr>
<td><code>-u</code></td><td>Setuid</td></tr>
<tr>
<td><code>-g</code></td><td>Setgid</td></tr>
<tr>
<td><code>-k</code></td><td>“Sticky”</td></tr>
</tbody>
</table>
</figure>
<p>Finally, three <em>binary</em> operators (tests that need two files as arguments) are used in file tests, but they’re not terribly common. Consider this command, which includes <code>-nt</code> (“newer than”): </p>
<pre><code>[ <var>file1</var> -nt <var>file2</var> ]</code></pre>
<p>This exits true if <var>file1</var> has a newer modification date than <var>file2</var>. The <code>-ot</code> (“older than”) operator does the opposite. And if you need to detect identical hard links, <code>-ef</code> compares two files and returns true if they share inode numbers and devices. </p>
<h4 id="h3-500402c11-0002">String Tests</h4>
<p class="BodyFirst">You’ve seen the binary string operator <code>=</code>, which returns true if its operands are equal, and the <code>!=</code> operator that returns true if its operands are not equal. There are two additional unary string operations: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">-z</code></span>  Returns true if its argument is empty (<code>[ -z "" ]</code> returns <code>0</code>)</li>
<li><span class="RunInHead"><code class="bold">-n</code></span>  Returns true if its argument is not empty (<code>[ -n "" ]</code> returns <code>1</code>) </li>
</ol>
<h4 id="h3-500402c11-0003">Arithmetic Tests</h4>
<p class="BodyFirst">Note that the equal sign (<code>=</code>) looks for <em>string</em> equality, not <em>numeric</em> equality. Therefore, <code>[ 1 = 1 ]</code> returns <code>0</code> (true), but <code>[ 01 = 1 ]</code> returns false. When working with numbers, use <code>-eq</code> instead of the equal sign: <code>[ 01 -eq 1 ]</code> returns true. <a href="#table11-3" id="tableanchor11-3">Table 11-3</a> provides the full list of numeric comparison operators.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table11-3">Table 11-3</a>: Arithmetic Comparison Operators</p></figcaption>
<table id="table-500402c11-0003" border="1">
<thead>
<tr>
<td><b>Operator</b></td><td><b>Returns true when the first argument is ___________ the second</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>-eq</code></td><td>equal to</td></tr>
<tr>
<td><code><span epub:type="pagebreak" title="304" id="Page_304"/>-ne</code></td><td>not equal to</td></tr>
<tr>
<td><code>-lt</code></td><td>less than</td></tr>
<tr>
<td><code>-gt</code></td><td>greater than</td></tr>
<tr>
<td><code>-le</code></td><td>less than or equal to</td></tr>
<tr>
<td><code>-ge</code></td><td>greater than or equal to</td></tr>
</tbody>
</table>
</figure>
<h3 id="h2-500402c11-0017">11.5.6	case</h3>
<p class="BodyFirst">The <code>case</code> keyword forms another conditional construct that is exceptionally useful for matching strings. It does not execute any test commands and therefore does not evaluate exit codes. However, it can do pattern matching. This example tells most of the story: </p>
<pre><code>#!/bin/sh
case $1 in
    bye)
        echo Fine, bye.
        ;;
    hi|hello)
        echo Nice to see you.
        ;;
    what*)
        echo Whatever.
        ;;
    *)
        echo 'Huh?'
        ;;
esac</code></pre>
<p>The shell executes this as follows: </p>
<ol class="decimal">
<li value="1">The script matches <code>$1</code> against each case value demarcated with the <code>)</code> character. </li>
<li value="2">If a case value matches <code>$1</code>, the shell executes the commands below the case until it encounters <code>;;</code>, at which point it skips to the <code>esac</code> keyword. </li>
<li value="3">The conditional ends with <code>esac</code>. </li>
</ol>
<p>For each case value, you can match a single string (like <code>bye</code> in the preceding example) or multiple strings with <code>|</code> (<code>hi|hello</code> returns true if <code>$1</code> equals <code>hi</code> or <code>hello</code>), or you can use the <code>*</code> or <code>?</code> patterns (<code>what*</code>). To make a default case that catches all possible values other than the case values specified, use a single <code>*</code> as shown by the final case in the preceding example. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	End each case with a double semicolon (<code>;;</code>) to avoid a possible syntax error. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c11-0006"><span epub:type="pagebreak" title="305" id="Page_305"/>	11.6	Loops</h2>
<p class="BodyFirst">There are two kinds of loops in the Bourne shell: <code>for</code> and <code>while</code> loops. </p>
<h3 id="h2-500402c11-0018">11.6.1	for Loops</h3>
<p class="BodyFirst">The <code>for</code> loop (which is a “for each” loop) is the most common. Here’s an example: </p>
<pre><code>#!/bin/sh
for str in one two three four; do
    echo $str
done</code></pre>
<p>In this listing, <code>for</code>, <code>in</code>, <code>do</code>, and <code>done</code> are all shell keywords. The shell does the following: </p>
<ol class="decimal">
<li value="1">Sets the variable <code>str</code> to the first of the four space-delimited values following the <code>in</code> keyword (<code>one</code>). </li>
<li value="2">Runs the <code>echo</code> command between the <code>do</code> and <code>done</code>. </li>
<li value="3">Goes back to the <code>for</code> line, setting <code>str</code> to the next value (<code>two</code>), runs the commands between <code>do</code> and <code>done</code>, and repeats the process until it’s through with the values following the <code>in</code> keyword. </li>
</ol>
<p>The output of this script looks like this: </p>
<pre><code>one
two
three
four</code></pre>
<h3 id="h2-500402c11-0019">11.6.2	while Loops</h3>
<p class="BodyFirst">The Bourne shell’s <code>while</code> loop uses exit codes, like the <code>if</code> conditional. For example, this script does 10 iterations: </p>
<pre><code>#!/bin/sh
FILE=/tmp/whiletest.$$;
echo firstline &gt; $FILE

while tail -10 $FILE | grep -q firstline; do
    # add lines to $FILE until tail -10 $FILE no longer prints "firstline"
    echo -n Number of lines in $FILE:' '
    wc -l $FILE | awk '{print $1}'
    echo newline &gt;&gt; $FILE
done

rm -f $FILE</code></pre>
<p>Here, the exit code of <code>grep -q firstline</code> is the test. As soon as the exit code is nonzero (in this case, when the string <code>firstline</code> no longer appears in the last 10 lines in <code>$FILE</code>), the loop exits. </p>
<p><span epub:type="pagebreak" title="306" id="Page_306"/>You can break out of a <code>while</code> loop with the <code>break</code> statement. The Bourne shell also has an <code>until</code> loop that works just like <code>while</code>, except that it breaks the loop when it encounters a zero exit code rather than a nonzero exit code. This said, you shouldn’t need to use the <code>while</code> and <code>until</code> loops very often. In fact, if you find that you need to use <code>while</code>, you should probably be using a language more appropriate to your task, such as Python or <code>awk</code>. </p>
<h2 id="h1-500402c11-0007">	11.7	Command Substitution</h2>
<p class="BodyFirst">The Bourne shell can redirect a command’s standard output back to the shell’s own command line. That is, you can use a command’s output as an argument to another command, or you can store the command output in a shell variable by enclosing a command in <code>$()</code>. </p>
<p>This example stores a command’s output inside the <code>FLAGS</code> variable. The bold code in the second line shows the command substitution. </p>
<pre><code>#!/bin/sh
FLAGS=<b>$(grep ^flags /proc/cpuinfo | sed 's/.*://' | head -1)</b>
echo Your processor supports:
for f in $FLAGS; do
    case $f in
        fpu)    MSG="floating point unit"
                ;;
        3dnow)  MSG="3DNOW graphics extensions"
                ;;
        mtrr)   MSG="memory type range register"
                ;;
        *)      MSG="unknown"
                ;;
    esac
    echo $f: $MSG
done</code></pre>
<p>This example is somewhat complicated because it demonstrates that you can use both single quotes and pipelines inside the command substitution. The result of the <code>grep</code> command is sent to the <code>sed</code> command (more about <code>sed</code> in <span class="xref" itemid="xref_target_Section 11.10.3">Section 11.10.3</span>), which removes anything matching the expression <code>.*:</code>, and the result of <code>sed</code> is passed to <code>head</code>. </p>
<p>It’s easy to go overboard with command substitution. For example, don’t use <code>$(ls)</code> in a script, because using the shell to expand <code>*</code> is faster. Also, if you want to invoke a command on several filenames that you get as a result of a <code>find</code> command, consider using a pipeline to <code>xargs</code> rather than command substitution, or use the <code>-exec</code> option (both are discussed in <span class="xref" itemid="xref_target_Section 11.10.4">Section 11.10.4</span>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The traditional syntax for command substitution is to enclose the command in backticks (<var>``</var>), and you’ll see this in many shell scripts. The <var>$()</var> syntax is a newer form, but it is a POSIX standard and is generally easier (for humans) to read and write. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c11-0008"><span epub:type="pagebreak" title="307" id="Page_307"/>	11.8	Temporary File Management</h2>
<p class="BodyFirst">It’s sometimes necessary to create a temporary file to collect output for use by a later command. When creating such a file, make sure that the filename is distinct enough that no other programs will accidentally write to it. Sometimes using something as simple as the shell’s PID (<code>$$</code>) in a filename works, but when you need to be certain that there will be no conflicts, a utility such as <code>mktemp</code> is often a better option.</p>
<p>Here’s how to use the <code>mktemp</code> command to create temporary filenames. This script shows you the device interrupts that have occurred in the last two seconds: </p>
<pre><code>#!/bin/sh
TMPFILE1=$(mktemp /tmp/im1.XXXXXX)
TMPFILE2=$(mktemp /tmp/im2.XXXXXX)

cat /proc/interrupts &gt; $TMPFILE1
sleep 2
cat /proc/interrupts &gt; $TMPFILE2
diff $TMPFILE1 $TMPFILE2
rm -f $TMPFILE1 $TMPFILE2</code></pre>
<p>The argument to <code>mktemp</code> is a template. The <code>mktemp</code> command converts the <code>XXXXXX</code> to a unique set of characters and creates an empty file with that name. Notice that this script uses variable names to store the filenames so that you only have to change one line if you want to change a filename. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Not all Unix flavors come with <var>mktemp</var>. If you’re having portability problems, it’s best to install the GNU coreutils package for your operating system.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>A common problem with scripts that employ temporary files is that if the script is aborted, the temporary files could be left behind. In the preceding example, pressing <span class="KeyCaps">ctrl</span>-C before the second <code>cat</code> command leaves a temporary file in <em>/tmp</em>. Avoid this if possible. Instead, use the <code>trap</code> command to create a signal handler to catch the signal that <span class="KeyCaps">ctrl</span>-C generates and remove the temporary files, as in this handler: </p>
<pre><code>#!/bin/sh
TMPFILE1=$(mktemp /tmp/im1.XXXXXX)
TMPFILE2=$(mktemp /tmp/im2.XXXXXX)
trap "rm -f $TMPFILE1 $TMPFILE2; exit 1" INT
 --<var>snip</var>--</code></pre>
<p>You must use <code>exit</code> in the handler to explicitly end script execution, or the shell will continue running as usual after running the signal handler.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You don’t need to supply an argument to <var>mktemp</var>; if you don’t, the template will begin with a <var>/tmp/tmp.</var> prefix.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c11-0009"><span epub:type="pagebreak" title="308" id="Page_308"/>	11.9	Here Documents</h2>
<p class="BodyFirst">Say you want to print a large section of text or feed a lot of text to another command. Rather than using several <code>echo</code> commands, you can use the shell’s <em>here document</em> feature, as shown in the following script: </p>
<pre><code>#!/bin/sh
DATE=$(date)
cat <b>&lt;&lt;EOF</b>
Date: $DATE

The output above is from the Unix date command.
It's not a very interesting command.
<b>EOF</b></code></pre>
<p>The items in bold control the here document. <code>&lt;&lt;EOF</code> tells the shell to redirect all subsequent lines to the standard input of the command that precedes <code>&lt;&lt;EOF</code>, which in this case is <code>cat</code>. The redirection stops as soon as the <code>EOF</code> marker occurs on a line by itself. The marker can actually be any string, but remember to use the same marker at the beginning and end of the here document. Also, convention dictates that the marker be in all uppercase letters. </p>
<p>Notice the shell variable <code>$DATE</code> in the here document. The shell expands shell variables inside here documents, which is especially useful when you’re printing out reports that contain many variables. </p>
<h2 id="h1-500402c11-0010">	11.10	Important Shell Script Utilities</h2>
<p class="BodyFirst">Several programs are particularly useful in shell scripts. Certain utilities, such as <code>basename</code>, are really only practical when used with other programs, and therefore don’t often find a place outside shell scripts. However, others, such as <code>awk</code>, can be quite useful on the command line, too. </p>
<h3 id="h2-500402c11-0020">11.10.1	 basename</h3>
<p class="BodyFirst">If you need to strip the extension from a filename or get rid of the directories in a full pathname, use the <code>basename</code> command. Try these examples on the command line to see how the command works: </p>
<pre><code>$ <b>basename example.html .html</b>
$ <b>basename /usr/local/bin/example</b></code></pre>
<p>In both cases, <code>basename</code> returns <code>example</code>. The first command strips the <em>.html</em> suffix from <em>example.html</em>, and the second removes the directories from the full pathname. </p>
<p>This example shows how you can use <code>basename</code> in a script to convert GIF image files to the PNG format:</p>
<pre><code>#!/bin/sh
for file in *.gif; do
    # exit if there are no files
<span epub:type="pagebreak" title="309" id="Page_309"/>    if [ ! -f $file ]; then
        exit
    fi
    b=$(basename $file .gif)
    echo Converting $b.gif to $b.png...
    giftopnm $b.gif | pnmtopng &gt; $b.png
done</code></pre>
<h3 id="h2-500402c11-0021">11.10.2	 awk</h3>
<p class="BodyFirst">The <code>awk</code> command is not a simple single-purpose command; it’s actually a powerful programming language. Unfortunately, <code>awk</code> usage is now something of a lost art, having been replaced by larger languages such as Python. </p>
<p>There are entire books on the subject of <code>awk</code>, including <em>The AWK Programming Language </em>by Alfred V. Aho, Brian W. Kernighan, and Peter J. Weinberger (Addison-Wesley, 1988). This said, many, many people use <code>awk</code> only to do one thing—to pick a single field out of an input stream like this: </p>
<pre><code>$ <b>ls -l | awk '{print $5}'</b></code></pre>
<p>This command prints the fifth field of the <code>ls</code> output (the file size). The result is a list of file sizes. </p>
<h3 id="h2-500402c11-0022">11.10.3	 sed</h3>
<p class="BodyFirst">The <code>sed</code> (“stream editor”) program is an automatic text editor that takes an input stream (a file or the standard input), alters it according to some expression, and prints the results to standard output. In many respects, <code>sed</code> is like <code>ed</code>, the original Unix text editor. It has dozens of operations, matching tools, and addressing capabilities. As with <code>awk</code>, entire books have been written about <code>sed</code>, including a quick reference covering both, <em>sed &amp; awk Pocket Reference</em>, 2nd edition, by Arnold Robbins (O’Reilly, 2002). </p>
<p>Although <code>sed</code> is a big program and an in-depth analysis is beyond the scope of this book, it’s easy to see how it works. In general, <code>sed</code> takes an address and an operation as one argument. The address is a set of lines, and the command determines what to do with the lines.</p>
<p>A very common task for <code>sed</code> is to substitute some text for a regular expression (see <span class="xref" itemid="xref_target_Section 2.5.1">Section 2.5.1</span>), like this:</p>
<pre><code>$ <b>sed 's/</b><var class="bold">exp</var><b>/</b><var class="bold">text</var><b>/'</b></code></pre>
<p>If you wanted to replace the first colon in each line of <em>/etc/passwd</em> with a <code>%</code> and send the result to the standard output, then, you’d do it like this:</p>
<pre><code>$ <b>sed 's/:/%/' /etc/passwd</b></code></pre>
<p>To substitute <em>all</em> colons in <em>/etc/passwd</em>, add the <code>g</code> (global) modifier to the end of the operation, like this:</p>
<pre><code>$ <b>sed 's</b><var class="bold">/:/</var><b>%/g' /etc/passwd</b></code></pre>
<p><span epub:type="pagebreak" title="310" id="Page_310"/>Here’s a command that operates on a per-line basis; it reads <em>/etc/passwd</em>, deletes lines three through six, and sends the result to the standard output: </p>
<pre><code>$ <b>sed</b> <b>3,6d /etc/passwd</b></code></pre>
<p>In this example, <code>3,6</code> is the address (a range of lines), and <code>d</code> is the operation (delete). If you omit the address, <code>sed</code> operates on all lines in its input stream. The two most common <code>sed</code> operations are probably <code>s</code> (search and replace) and <code>d</code>. </p>
<p>You can also use a regular expression as the address. This command deletes any line that matches the regular expression <var>exp</var>: </p>
<pre><code>$ <b>sed '/</b><var class="bold">exp</var><b>/d'</b></code></pre>
<p>In all of these examples, <code>sed</code> writes to the standard output, and this is by far the most common usage. With no file arguments, <code>sed</code> reads from the standard input, a pattern that you’ll frequently encounter in shell pipelines.</p>
<h3 id="h2-500402c11-0023">11.10.4	 xargs</h3>
<p class="BodyFirst">When you have to run one command on a huge number of files, the command or shell may respond that it can’t fit all of the arguments in its buffer. Use <code>xargs</code> to get around this problem by running a command on each filename in its standard input stream. </p>
<p>Many people use <code>xargs</code> with the <code>find</code> command. For example, the following script can help you verify that every file in the current directory tree that ends with <em>.gif</em> is actually a GIF image: </p>
<pre><code>$ <b>find . -name '*.gif' -print | xargs file</b></code></pre>
<p>Here, <code>xargs</code> runs the <code>file</code> command. However, this invocation can cause errors or leave your system open to security problems, because filenames can include spaces and newlines. When writing a script, use the following form instead, which changes the <code>find</code> output separator and the <code>xargs</code> argument delimiter from a newline to a NULL character: </p>
<pre><code>$ <b>find . -name '*.gif' -print0 | xargs -0 file</b></code></pre>
<p><code>xargs</code> starts a <em>lot</em> of processes, so don’t expect great performance if you have a large list of files. </p>
<p>You may need to add two dashes (<code>--</code>) to the end of your <code>xargs</code> command if there’s a chance that any of the target files start with a single dash (<code>-</code>). The double dash (<code>--</code>) tells a program that any arguments that follow are filenames, not options. However, keep in mind that not all programs support the use of a double dash.</p>
<p>When you’re using <code>find</code>, there’s an alternative to <code>xargs</code>: the <code>-exec</code> option. However, the syntax is somewhat tricky because you need to supply braces, <code>{}</code>, to substitute the filename and a literal <code>;</code> to indicate the end of the command. Here’s how to perform the preceding task using only <code>find</code>:</p>
<pre><code>$ <b>find . -name '*.gif' -exec file {} \;</b></code></pre>
<h3 id="h2-500402c11-0024"><span epub:type="pagebreak" title="311" id="Page_311"/>11.10.5	 expr</h3>
<p class="BodyFirst">If you need to use arithmetic operations in your shell scripts, the <code>expr</code> command can help (and even do some string operations). For example, the command <code>expr 1 + 2</code> prints <code>3</code>. (Run <code>expr --help</code> for a full list of operations.)</p>
<p>The <code>expr</code> command is a clumsy, slow way of doing math. If you find yourself using it frequently, you should probably be using a language like Python instead of a shell script. </p>
<h3 id="h2-500402c11-0025">11.10.6	 exec</h3>
<p class="BodyFirst">The <code>exec</code> command is a built-in shell feature that replaces the current shell process with the program you name after <code>exec</code>. It carries out the <code>exec()</code> system call described in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. This feature is designed for saving system resources, but remember that there’s no return; when you run <code>exec</code> in a shell script, the script and shell running the script are gone, replaced by the new command. </p>
<p>To test this in a shell window, try running <code>exec cat</code>. After you press <span class="KeyCaps">ctrl</span>-D or <span class="KeyCaps">ctrl</span>-C to terminate the <code>cat</code> program, your window should disappear because its child process no longer exists. </p>
<h2 id="h1-500402c11-0011">	11.11	Subshells</h2>
<p class="BodyFirst">Say you need to alter the environment in a shell slightly but don’t want a permanent change. You can change and restore a part of the environment (such as the path or working directory) using shell variables, but that’s a clumsy way to go about things. The simpler option is to use a <em>subshell</em>, an entirely new shell process that you can create just to run a command or two. The new shell has a copy of the original shell’s environment, and when the new shell exits, any changes you made to its shell environment disappear, leaving the initial shell to run as normal. </p>
<p>To use a subshell, put the commands to be executed by the subshell in parentheses. For example, the following line executes the command <code>uglyprogram</code> while in <em>uglydir</em> and leaves the original shell intact: </p>
<pre><code>$ <b>(cd uglydir; uglyprogram)</b></code></pre>
<p>This example shows how to add a component to the path that might cause problems as a permanent change: </p>
<pre><code>$ <b>(PATH=/usr/confusing:$PATH; uglyprogram)</b></code></pre>
<p>Using a subshell to make a single-use alteration to an environment variable is such a common task that there’s even a built-in syntax that avoids the subshell:</p>
<pre><code>$ <b>PATH=/usr/confusing:$PATH uglyprogram</b></code></pre>
<p><span epub:type="pagebreak" title="312" id="Page_312"/>Pipes and background processes work with subshells, too. The following example uses <code>tar</code> to archive the entire directory tree within <em>orig</em> and then unpacks the archive into the new directory <em>target</em>, which effectively duplicates the files and folders in <em>orig</em> (this is useful because it preserves ownership and permissions, and it’s generally faster than using a command such as <code>cp -r</code>):</p>
<pre><code>$ <b>tar cf - </b><var class="bold">orig</var><b> | (cd </b><var class="bold">target</var><b>; tar xvf -)</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	Double-check this sort of command before you run it to make sure that the <span class="Regular">target</span> directory exists and is completely separate from the <span class="Regular">orig</span> directory (in a script, you can check for this with <code>[ -d orig -a ! orig -ef target ]</code>). </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c11-0012">	11.12	Including Other Files in Scripts</h2>
<p class="BodyFirst">If you need to include code from another file in your shell script, use the dot (<code>.</code>) operator. For example, this runs the commands in the file <em>config.sh</em>: </p>
<pre><code>. config.sh</code></pre>
<p>This method of inclusion is also called <em>sourcing</em> a file and is useful for reading variables (for example, in a shared configuration file) and other kinds of definitions. This is not the same as executing another script; when you run a script (as a command), it starts in a new shell, and you can’t get anything back other than the output and the exit code.</p>
<h2 id="h1-500402c11-0013">	11.13	Reading User Input</h2>
<p class="BodyFirst">The <code>read</code> command reads a line of text from the standard input and stores the text in a variable. For example, the following command stores the input in <code>$</code><var>var</var>:</p>
<pre><code>$ <b>read </b><var class="bold">var</var></code></pre>
<p>This built-in shell command can be useful in conjunction with other shell features not mentioned in this book. With <code>read</code>, you can create simple interactions, such as prompting a user to enter input instead of requiring them to list everything on the command line, and build “Are you sure?” confirmations preceding dangerous operations.</p>
<h2 id="h1-500402c11-0014">	11.14	When (Not) to Use Shell Scripts</h2>
<p class="BodyFirst">The shell is so feature-rich that it’s difficult to condense its important elements into a single chapter. If you’re interested in what else the shell can do, have a look at some of the books on shell programming, such as <em>Unix Shell </em><span epub:type="pagebreak" title="313" id="Page_313"/>Programming, 3rd edition, by Stephen G. Kochan and Patrick Wood (SAMS Publishing, 2003), or the shell script discussion in <em>The UNIX Programming Environment</em> by Brian W. Kernighan and Rob Pike (Prentice Hall, 1984). </p>
<p>However, at a certain point (especially when you start to overuse the <code>read</code> built-in), you have to ask yourself if you’re still using the right tool for the job. Remember what shell scripts do best: manipulate simple files and commands. As stated earlier, if you find yourself writing something that looks convoluted, especially if it involves complicated string or arithmetic operations, don’t be afraid to look to a scripting language like Python, Perl, or <code>awk</code>.</p>
</section>
</body></html>