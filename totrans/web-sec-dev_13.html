<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_103"/><strong><span class="big">11</span></strong><br/><strong>PERMISSIONS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">Users on your website will usually have different levels of permissions. In a content management system, for instance, some users are administrators who have the ability to edit the site’s content, while most users can only view and interact with the content. Social media sites have a more complex web of permissions: users may opt to share only certain content with friends or to keep their profile locked. For webmail sites, each user should be able to access only their own email! It’s important that you correctly and uniformly enforce these types of permissions across your site, or your users will lose trust in you.</p>&#13;
<p class="indent">Facebook suffered a disastrous failure in user permissions in September 2018, when hackers exploited a bug in its video uploading tool to generate access tokens for the site. Up to 50 million user accounts on the site were compromised. Hackers stole private profile details like users’ names, emails, and phone numbers. Facebook patched the bug, issued a security advisory, and did an apology tour via the press. However, this came at the <span epub:type="pagebreak" id="page_104"/>end of a year that contained a lot of unfavorable stories about Facebook’s business practices, and the company’s share price took a battering.</p>&#13;
<p class="indent">The Facebook hack was an example of <em>privilege escalation</em>, whereby a malicious user usurps the permissions of another user. The process of securing your site so the correct privileges are applied to each user is called implementing <em>access control</em>. This chapter covers both concepts and presents one common method hackers use to exploit insufficient access control, called <em>directory traversal</em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec137"><strong>Privilege Escalation</strong></h3>&#13;
<p class="noindent">Security experts divide privilege escalation attacks into two categories: vertical and horizontal escalation.</p>&#13;
<p class="indent">In <em>vertical escalation</em>, an attacker gets access to an account with broader permissions than their own. If an attacker can deploy a <em>web shell</em> on your server—an executable script that takes elements of the HTTP request and runs them on the command line—one of their first aims will be to escalate their way to <em>root privilege</em>, so they can perform any actions they wish on the server. Ordinarily, commands sent to the web shell will be executed under the same operating system account that the web server is running, which generally has limited network and disk access. Hackers have found a lot of ways to perform vertical escalation attacks on operating systems in an attempt to get root access—which allows them to infect the whole server from a web shell.</p>&#13;
<p class="indent">In <em>horizontal escalation</em>, an attacker accesses another account with similar privileges as their own. In the last couple of chapters, we’ve discussed common ways of performing this type of attack: guessing passwords, hijacking sessions, or maliciously crafting HTTP request data. The September 2018 Facebook hack was an example of horizontal escalation, caused by an API that issued access tokens without correctly verifying the user’s permissions.</p>&#13;
<p class="indent">To secure your site from escalation attacks, you need to securely implement access control for all sensitive resources. Let’s discuss how.</p>&#13;
<h3 class="h3" id="ch00lev1sec138"><strong>Access Control</strong></h3>&#13;
<p class="noindent">Your access control strategy should cover three key aspects:</p>&#13;
<p class="noindentf"><strong>Authentication</strong> Correctly identifying a user when they return to the site</p>&#13;
<p class="noindentf"><strong>Authorization</strong> Deciding which actions a user should and shouldn’t be able to perform after they’ve identified themselves</p>&#13;
<p class="noindentf"><strong>Permission checking</strong> Evaluating authorization at the point in time when a user attempts to perform an action</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09">Chapters 9</a> and <a href="ch10.xhtml#ch10">10</a> covered authentication in detail; you saw how securing login functionality and session management allows you to reliably determine which user is making HTTP requests. However, from there, you still need to determine which actions each user can perform, and this is a more open-ended problem.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_105"/>A good access control strategy consists of three stages: designing an authorization model, implementing the access control, and testing the access control. After you’ve done that, you can also add audit trails and make sure you haven’t missed common oversights. Let’s go through each of these in detail.</p>&#13;
<h4 class="h4" id="ch00lev1sec139"><strong><em>Designing an Authorization Model</em></strong></h4>&#13;
<p class="noindent">There are several common ways to model authorization rules in a software application. When you design your authorization model, it’s important to document how you’ll apply your chosen model to your users. Without an agreed-upon set of rules, it’s hard to define what a “correct” implementation looks like.</p>&#13;
<p class="indent">With that in mind, let’s look at some common ways to model authorization rules.</p>&#13;
<h5 class="h5" id="ch00lev1sec140"><strong>Access Control Lists</strong></h5>&#13;
<p class="noindent"><em>Access control lists (ACLs)</em> are a simple way of modeling authorization that attach against each object in your system a list of permissions, specifying the actions that each user or account can perform on that object. The canonical example of an ACL-based model is the Linux filesystem, which can individually grant each user read, write, or execute permissions on each file and directory. Most SQL databases also implement ACL-based authorization—the account you use to connect to the database determines which tables you can read or update, or whether you can change table structures.</p>&#13;
<h5 class="h5" id="ch00lev1sec141"><strong>Whitelists and Blacklists</strong></h5>&#13;
<p class="noindent">A simpler way to model authorization is to use a whitelist or blacklist. A <em>whitelist</em> describes the users or accounts that can access a particular resource, and bans all other users. A <em>blacklist</em> explicitly describes the users or accounts that are banned from accessing a resource, implying that the resource should be made accessible to any other user or account. Spam filters frequently use whitelists and blacklists to distinguish email addresses that the email application should send directly to the spam folder or that it should never junk.</p>&#13;
<h5 class="h5" id="ch00lev1sec142"><strong>Role-Based Access Control</strong></h5>&#13;
<p class="noindent">Probably the most comprehensive authorization model is <em>role-based access control (RBAC)</em>, which grants users <em>roles</em>, or adds users to <em>groups</em> that it has granted specific roles. <em>Policies</em> in the system define how each role can interact with specific <em>subjects</em>—resources within the computing system.</p>&#13;
<p class="indent">A simple RBAC-system might designate certain users as administrators by adding a user to the Administrators group, which in turn grants them the Administrator role. A policy would then permit users or groups with the Administrator role to edit particular pieces of content of your site.</p>&#13;
<p class="indent">The Amazon Web Services <em>identity and access management (IAM)</em> system is an example of a comprehensive role-based system, as is Microsoft’s Active <span epub:type="pagebreak" id="page_106"/>Directory. Role-based access control is powerful but often prone to complexity. Policies can contradict each other, creating conflicts that developers need to resolve, and users can belong to many groups with overlapping concerns. In such cases, it can sometimes be hard to see why a system is making certain access control decisions, or prioritizing certain rules in a particular set of circumstances.</p>&#13;
<h5 class="h5" id="ch00lev1sec143"><strong>Ownership-Based Access Control</strong></h5>&#13;
<p class="noindent">In the age of social media, it has become common to organize access control rules around the idea of <em>ownership</em>, whereby each user has full control over the photos they upload or the posts they create. Social media users are, in essence, administrators of their own content: they can create, upload, delete, and control visibility on their own posts, comments, photos, and stories. They can tag other users in content such as photos, though those other users may have to approve those tags before the tags are made public. On a social media site, each type of content has an implied privacy level: commenting on each other’s posts is usually done in public, but direct messages are private (though someone should try explaining that to my grandmother).</p>&#13;
<h4 class="h4" id="ch00lev1sec144"><strong><em>Implementing Access Control</em></strong></h4>&#13;
<p class="noindent">After you’ve chosen your authorization model and defined the access rules for your site, you’ll need to implement them in code. You should attempt to centralize access control decisions in your codebase, which makes it easier to validate them against your design documents during code reviews. You don’t necessarily need to have all access decisions flow through one code path, but it’s important to have a standard method of evaluating access control decisions.</p>&#13;
<p class="indent">There are many ways of implementing authorization rules: using function or method decorators (which tag functions with certain permission levels), URL checking (for example, prefixing sensitive paths with <em>/admin</em>), or inserting inline assertions in the code. Some implementations will defer to access control decisions from a dedicated permission component or in-house API. <a href="ch11.xhtml#ch11list1">Listing 11-1</a> shows an example of adding permission checking to Python functions.</p>&#13;
<pre>   from django.contrib.auth.decorators import login_required, permission_required<br/><br/><span class="ent">❶</span> @login_required<br/><span class="ent">❷</span> @permission_required('content.can_publish')<br/>   def publish_post(request):<br/>       # Publish a post to the front page.</pre>&#13;
<p class="caption"><a id="ch11list1"/><em>Listing 11-1: Checking permissions using the <span class="codeitalic">django</span> web server in Python</em></p>&#13;
<p class="indent">The web server requires that the user is logged in <span class="ent">❶</span> and has permissions to publish content <span class="ent">❷</span> before permitting them to publish a post.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11list2">Listing 11-2</a> shows how to check permissions inline in Ruby, using the <code>pundit</code> library.</p>&#13;
<pre><span epub:type="pagebreak" id="page_107"/>def publish<br/>  @post = Post.find(params[:id])<br/><span class="ent">❶</span> authorize @post, :update?<br/>  @post.publish!<br/>  redirect_to @post<br/>end</pre>&#13;
<p class="caption"><a id="ch11list2"/><em>Listing 11-2: Checking permissions by using the <span class="codeitalic">pundit</span> library in Ruby</em></p>&#13;
<p class="indent">The method call <span class="ent">❶</span> asks the library whether the currently logged-in user has permission to update the social media post described by the <code>@post</code> object.</p>&#13;
<p class="indent">Whatever method you use to implement permission checking, be sure to make access control decisions based on properly vetted identity data. Don’t rely on anything in the HTTP request besides the session cookie to infer which user is accessing a resource and what permissions they have! A malicious user can tamper with anything else in the request in order to commit privilege escalation attacks.</p>&#13;
<h4 class="h4" id="ch00lev1sec145"><strong><em>Testing Access Control</em></strong></h4>&#13;
<p class="noindent">It’s important to test your access control system critically. Make sure your testing procedures genuinely attempt to find holes in your access control scheme; if you treat it like an attacker would, you’ll be better prepared when your first real attack occurs.</p>&#13;
<p class="indent">Write unit tests that make assertions about who can access certain resources and, more importantly, who <em>shouldn’t</em> be able to access them. Get in the habit of writing new unit tests describing access control rules as you add features to your site. This is especially important if your site has administrative interfaces, since they’re a common backdoor that attackers exploit when hacking websites. <a href="ch11.xhtml#ch11list3">Listing 11-3</a> shows a simple unit test in Ruby that asserts that users must be logged in before performing a sensitive action.</p>&#13;
<pre>class PostsTest &lt; ApplicationSystemTestCase<br/>  test "users should be redirected to the login page if they are not logged in" do<br/>     visit publish_post_url<br/>     assert_response :redirect<br/>     assert_selector "h1", text: "Login"<br/>  end<br/>end</pre>&#13;
<p class="caption"><a id="ch11list3"/><em>Listing 11-3: A Ruby unit test that checks if an unauthorized user is redirected to the login page if they attempt to publish a post</em></p>&#13;
<p class="indent">Finally, if you have the time and budget, consider employing an external team to perform penetration testing. The team can probe for missing or erroneous access control rules that an attacker can abuse.</p>&#13;
<h4 class="h4" id="ch00lev1sec146"><strong><em>Adding Audit Trails</em></strong></h4>&#13;
<p class="noindent">Because your code will be identifying users and testing their authorization levels as they access resources, you should add audit trails to help with <span epub:type="pagebreak" id="page_108"/>troubleshooting and forensic analysis. <em>Audit trails</em> are log files or database entries that are recorded whenever a user performs an action. Simply adding logging statements as users navigate your site (<code>14:32:06 2019-02-05: User <a href="mailto:example@gmail.com">example@gmail.com</a> logged in</code>) can help you diagnose any problems as they occur at runtime, and provide vital evidence in the event that you do get hacked.</p>&#13;
<h4 class="h4" id="ch00lev1sec147"><strong><em>Avoiding Common Oversights</em></strong></h4>&#13;
<p class="noindent">A common oversight you see on many websites is that that they omit access control for resources that aren’t designed to be discoverable. It’s easy to assume that pages on your site that aren’t linked to from elsewhere will be hidden from hackers, because those pages won’t be highlighted as hackers crawl your site. This isn’t true.</p>&#13;
<p class="indent">Hacking tools can quickly enumerate private URLs that feature opaque IDs, like <em>http://example.com/item?id=423242</em>, and it’s even easier to access private URLs with a guessable structure like <em>http://example.com/profiles/user/bob</em>. Relying on an attacker being unable to guess a URL is called <em>security through obscurity</em> and is considered a risk.</p>&#13;
<p class="indent">Securing sensitive resources is particularly important for sites designed to <em>embargo</em> resources, making them accessible at a certain point in time. Financial reporting sites often operate under this constraint. Publicly traded companies are required to make quarterly or semiannual financial reports available to all investors simultaneously, from previously agreed-upon reporting channels.</p>&#13;
<p class="indent">Some websites upload these reports early (say, to URLs with the form <em>/reports/&lt;company-name&gt;/&lt;month-year&gt;</em>), and cheating investors have been known to check these URLs ahead of time in order to access reports before the rest of the market. Financial watchdogs have charged companies large fines for improper disclosure due to broken access logic! Make sure your access control rules account for any timing requirements.</p>&#13;
<p class="indent">Every sensitive resource on your site requires access control. If your site allows users to download files, hackers may try to access files that they should not be permitted to download, using a hacking method called directory traversal. Let’s see how.</p>&#13;
<h3 class="h3" id="ch00lev1sec148"><strong>Directory Traversal</strong></h3>&#13;
<p class="noindent">If any of your website’s URLs contain parameters describing paths to files, attackers can use directory traversal to bypass your access control rules. In a <em>directory traversal</em> attack, an attacker manipulates the URL parameters in order to access sensitive files that you never intended to be accessible. Directory traversal attacks usually involve replacing a URL parameter with a relative filepath that uses the <em>../</em> syntax to “climb out” of the hosting directory. Let’s break down how this works.</p>&#13;
<h4 class="h4" id="ch00lev1sec149"><strong><em>Filepaths and Relative Filepaths</em></strong></h4>&#13;
<p class="noindent">In most filesystems, the location of each file can be described by a <em>filepath</em>. For instance, the filepath <em>/tmp/logs/web.log</em> on Linux describes the location <span epub:type="pagebreak" id="page_109"/>of the file <em>web.log</em> by enumerating the <em>directories</em> (in this case, the <em>logs</em> directory within the top-level <em>tmp</em> directory) that contain the file, joined by a <em>path separator</em> character (<em>/</em>).</p>&#13;
<p class="indent">A <em>relative filepath</em> is a filepath that begins with the period (.) character, denoting it as being in the current directory; the relative path <em>./web.log</em> describes the location of the file <em>web.log</em> as being in the current directory. What’s considered the “current” directory depends on the context under which the path is being evaluated. From a command line prompt, for instance, the current directory is the one the user most recently navigated to.</p>&#13;
<p class="indent">Relative paths also use the <em>..</em> syntax to reference the containing or <em>parent</em> directory. Using the <em>..</em> syntax twice would reference the parent directory of the parent directory of the current directory. For instance, the filesystem interprets the path <em>../../etc/passwd</em> as a request to go up two directories, find a directory called <em>etc</em>, and then return the <em>passwd</em> file within that directory. Using a relative path is similar to describing a relative: your uncle is your grandparent’s son, so to find him, go back two generations in your family tree and then look for a male child.</p>&#13;
<p class="indent">If your server-side code allows an attacker to pass and evaluate relative filepaths in place of filenames, they can probe your filesystem for interesting-looking files, breaking access control. The relative path syntax lets the attacker read files outside the web server’s home directory, letting them probe for directories that commonly hold password or configuration information and read the data contained within them. Let’s look at an example of such an attack.</p>&#13;
<h4 class="h4" id="ch00lev1sec150"><strong><em>Anatomy of a Directory Traversal Attack</em></strong></h4>&#13;
<p class="noindent">Imagine you have a website that hosts restaurant menus stored as PDFs on your server’s filesystem. Your site invites users to download each PDF by clicking a link that references a filename, as shown in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>.</p>&#13;
<div class="image"><img src="Images/11fig01.jpg" alt="image" width="892" height="781"/></div>&#13;
<p class="figcap"><a id="ch11fig1"/><em>Figure 11-1: A website that allows files to be downloaded</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_110"/>If the filename parameter isn’t securely interpreted, an attacker can swap in a relative path in place of the menu filename in the URL, and get access to user account information on your server, as shown in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>.</p>&#13;
<div class="image"><img src="Images/11fig02.jpg" alt="image" width="892" height="781"/></div>&#13;
<p class="figcap"><a id="ch11fig2"/><em>Figure 11-2: Using a directory traversal attack to access a Unix file holding account information</em></p>&#13;
<p class="indent">In this instance, the hacker has replaced the name of the menu in the <code>menu</code> parameter with a relative path (<em>../../../../etc/passwd</em>) in order to download a sensitive file. Reading the <em>passwd</em> file tells the attacker which user accounts exist on the underlying Linux operating system, revealing sensitive system information that will help the attacker hack the server. You certainly don’t want an attacker to be able to read this kind of information! Let’s look at ways to defuse directory traversal.</p>&#13;
<h4 class="h4" id="ch00lev1sec151"><strong><em>Mitigation 1: Trust Your Web Server</em></strong></h4>&#13;
<p class="noindent">To protect yourself against directory traversal attacks, first familiarize yourself with how your web server resolves static content URLs. Almost all websites will transform URLs into filepaths in some fashion—often when the server answers requests for static content such as JavaScript files, images, or stylesheets. If you find yourself serving more-exotic types of static files (for example, restaurant menus), try to use the web server’s built-in URL resolution logic rather than writing your own. Your web server’s URL static hosting capabilities are generally battle-tested and secured against directory traversal attacks.</p>&#13;
<h4 class="h4" id="ch00lev1sec152"><strong><em>Mitigation 2: Use a Hosting Service</em></strong></h4>&#13;
<p class="noindent">If you serve files that aren’t part of your codebase, perhaps because users or site administrators upload them, you should strongly consider hosting them in a content delivery network, in cloud storage, or in a content management system. These software types not only mitigate file upload vulnerabilities, as <span epub:type="pagebreak" id="page_111"/>discussed in <a href="ch06.xhtml#ch06">Chapter 6</a>, but also defuse directory traversal attacks by allowing you to refer to files either by secure URLs or opaque file identifiers. Of these alternatives, CDNs typically allow for less fine-grained permissions (say, if certain files need to be available to only certain users) but are also typically easiest to integrate with.</p>&#13;
<h4 class="h4" id="ch00lev1sec153"><strong><em>Mitigation 3: Use Indirect File References</em></strong></h4>&#13;
<p class="noindent">If you write your own code to serve files from a local disk, the most secure way of defusing directory traversal attacks is via <em>indirection</em>: you assign each file an <em>opaque ID</em> that corresponds to a filepath, and then have all URLs reference each file by that ID. This requires you to keep some sort of registry that pairs each file ID to a path, say, within a database.</p>&#13;
<h4 class="h4" id="ch00lev1sec154"><strong><em>Mitigation 4: Sanitize File References</em></strong></h4>&#13;
<p class="noindent">Finally, if you do end up using direct file references in your URLs—perhaps because you inherit a legacy codebase and lack the time or resources necessary to refactor the way files are stored—you need to secure your site code to ensure that arbitrary paths can’t be passed in place of filenames. The most secure approach is simply banning any file reference that includes path separator characters, including <em>encoded</em> separator characters. (Note that Windows- and Unix-based operating systems use different path separators: <em>\</em> and <em>/</em>, respectively.)</p>&#13;
<p class="indent">Another approach is to validate filenames against a <em>regular expression (regex)</em> to filter out anything that looks like path syntax. All modern web programming languages contain some sort of regex implementation, so it’s easy to test an incoming filename parameter against a “safe” expression. Be careful with this technique, though: hackers continuously research new and obscure ways to encode pathnames, because directory traversal attacks are so common. If possible, try to use a third-party library to sanitize filenames. <a href="ch11.xhtml#ch11list4">Listing 11-4</a> shows some logic in the Ruby Sinatra gem that sanitizes path parameters.</p>&#13;
<pre>def cleanup(path)<br/>   parts     = []<br/><span class="ent">❶</span> unescaped = path.gsub(/%2e/i, dot).gsub(/%2f/i, slash).gsub(/%5c/i, backslash)<br/>   unescaped = unescaped.gsub(backslash, slash)<br/><br/><span class="ent">❷</span> unescaped.split(slash).each do |part|<br/>     next if part.empty? or part == dot<br/>     part == '..' ? parts.pop : parts &lt;&lt; part<br/>   end<br/><br/><span class="ent">❸</span> cleaned = slash + parts.join(slash)<br/>   cleaned &lt;&lt; slash if parts.any? and unescaped =~ %r{/\.{0,2}$}<br/>   cleaned<br/>end</pre>&#13;
<p class="caption"><a id="ch11list4"/><em>Listing 11-4: Logic for sanitizing path parameters in the Sinatra Ruby gem</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_112"/>First the code standardizes any obscure character encodings it identifies <span class="ent">❶</span>. Then it splits the path into separate components <span class="ent">❷</span>. Finally, it reconstitutes the path by using a standard separator <span class="ent">❸</span>, ensuring that the leading character is a slash.</p>&#13;
<p class="indent">The complexity illustrated in <a href="ch11.xhtml#ch11list4">Listing 11-4</a> is necessary because relative paths can be encoded in various ways during a directory traversal attack. <a href="ch11.xhtml#ch11list5">Listing 11-5</a> shows eight ways the parent directory syntax can be encoded on different operating systems.</p>&#13;
<pre>../<br/>..\<br/>..\/<br/>%2e%2e%2f<br/>%252e%252e%252f<br/>%c0%ae%c0%ae%c0%af<br/>%uff0e%uff0e%u2215<br/>%uff0e%uff0e%u2216</pre>&#13;
<p class="caption"><a id="ch11list5"/><em>Listing 11-5: Relative paths can be encoded in many ways for different operating systems. Gulp.</em></p>&#13;
<h3 class="h3" id="ch00lev1sec155"><strong>Summary</strong></h3>&#13;
<p class="noindent">Users on your website will usually have different levels of permissions, so you need to implement access control rules that are evaluated when a user attempts to access a resource. Access control rules need to be clearly documented, comprehensively implemented, and aggressively tested. Development timelines should include sufficient padding to allow the team to evaluate the security implications of all new code changes.</p>&#13;
<p class="indent">Static resources that are referred to by filename are vulnerable to directory traversal attacks, a common method of overcoming access control rules. Directory traversal attacks can be thwarted by using your web server’s existing method of serving static files, serving static files from a secure third-party system, or referencing static files via indirection. If you’re forced to use filenames, make sure to sanitize any HTTP parameters that are used to construct filepaths.</p>&#13;
<p class="indent">In the next chapter, you’ll look at some ways your website may be advertising the technology stack you are using, which will give hackers an idea of how to attack it.</p>&#13;
</div>



  </body></html>