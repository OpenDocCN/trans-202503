- en: Chapter 4. Staying Objective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For years, *object-oriented (OO)* development has been the de facto standard
    for developing business software, particularly within the enterprise, so you’re
    probably familiar with many of its core principles. It should come as no surprise
    that as a .NET language, F# supports the full cast of constructs—including classes,
    structs, and interfaces—available in the other .NET languages. Despite its reputation
    as a niche language useful only for academic exercises or highly specialized software,
    F#’s general-purpose, multiparadigm nature makes it suitable for most development
    situations. With C# and Visual Basic already well established, though, why choose
    F# as an OO language?
  prefs: []
  type: TYPE_NORMAL
- en: 'A large part of the decision rests on F#’s terse syntax, but features like
    type inference, object expressions, and the ability to combine object-oriented
    and functional styles make a strong argument, too. Let’s face it, though: Even
    if you’re developing in a primarily functional manner, when you’re developing
    software on the .NET Framework you’re going to have to work with objects at some
    point; that’s just the nature of the platform.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to create OO constructs in F# with less code,
    yet still build robust frameworks that can hold their own against similar frameworks
    built with more dedicated OO languages.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conceptually, classes in F# are identical to classes in other OO languages in
    that they encapsulate related data and behavior as fields, properties, methods,
    and events (collectively called *members*) to model real-world objects or concepts.
    Like classes in C# and Visual Basic, F# classes are reference types that support
    single inheritance and multiple interface implementation, and can control access
    to their members. As with all user-defined data types in F#, you declare classes
    with the `type` keyword. (Rather than requiring different keywords for every data
    type you can create, the compiler infers the construct based on its structure.)
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate, let’s take another look at the class definition introduced in
    the type inference discussion in [Chapter 3](ch03.html "Chapter 3. Fundamentals").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot of definition packed into this example. In just four lines, there’s
    a class with a *primary constructor* with three arguments and three implicit,
    read-only properties! While quite a departure from the other .NET languages, this
    terseness is just one of the ways that F# distinguishes itself.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constructors are the means by which new class instances are created and initialized.
    They’re really specialized functions that return fully initialized class instances.
    Classes in F# do not require a constructor, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The empty class in this example is valid F# but, unlike in C#, if you don’t
    define a constructor, the compiler won’t automatically generate a *default constructor*
    (a constructor with no parameters). Since a memberless class that you can’t instantiate
    is pretty useless, your classes will typically have at least one constructor and
    one member.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*One reason you might choose to omit the constructor is that each of the type’s
    members is static; that is, it applies to the type rather than an individual instance.
    We’ll examine static members in detail a bit later in this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: As with other OO languages, you create new class instances by invoking a constructor.
    In the case of our `Person` class there’s only one constructor, so the choice
    is clear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the `new` keyword to create a new class instance is optional. By convention,
    you use the `new` keyword only when creating an instance of a class that implements
    the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'F# constructors come in two flavors: primary constructors and additional constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: Primary Constructors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: F# classes can have a *primary constructor* whose arguments are embedded within
    the type definition itself. The primary constructor’s body contains a series of
    `let` and `do` bindings that represent the class’s field definitions and initialization
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the primary constructor includes the parameter list with type
    annotations ①, a single field definition for the calculated age ②, and a `do`
    binding ③ that prints the person’s name and age when the object is constructed.
    All of the primary constructor’s parameters are automatically available as fields
    throughout your class, so there’s no need to explicitly map them.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler can frequently infer the types for each constructor parameter,
    so there’s often no need to include explicit type annotations. In the preceding
    example, a type annotation (or one on an intermediate binding with a type annotation)
    would still be needed for the `dob` parameter so the compiler can resolve the
    correct subtract operator overload. However, that’s more the exception than the
    rule, as shown in the next example, where the compiler can infer the types for
    both the `name` and `age` parameters as `string` and `int`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the primary constructor is public, but you can change that by including
    an access modifier before the parameter list. You might consider changing the
    primary constructor’s accessibility if you were implementing the *Singleton pattern*,
    which specifies that only a single instance of the type can exist, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: More About Accessibility in F#
  prefs: []
  type: TYPE_NORMAL
- en: '*Access modifiers* limit the scope of bindings, types, and members throughout
    your program. F# differs from C# and Visual Basic in that it directly supports
    only the `public`, `private`, and `internal` modifiers. You can’t define `protected`
    class members in F# due in part to how they complicate the functional nature of
    the language. F# does still honor `protected` members defined in other languages,
    so they won’t be publicly accessible and you can still override them in derived
    classes without breaking the abstraction.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Constructors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Constructors that you define beyond the primary constructor are called *additional
    constructors*. Additional constructors are defined with the `new` keyword followed
    by a parameter list and constructor body, as shown next. While additional constructors
    must always invoke the primary constructor, they may do so indirectly through
    another constructor, thereby allowing you to chain constructor calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Additional constructors can contain their own `let` bindings and other expressions,
    but unlike those in the primary constructor, any such elements will be local to
    the constructor where they’re defined rather than exposed as fields.
  prefs: []
  type: TYPE_NORMAL
- en: Additional constructors can invoke additional code like a primary constructor,
    but instead of using a `do` binding they use the `then` keyword. In this example,
    each additional constructor includes the `then` keyword in order to print a message
    indicating which constructor is being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes without a primary constructor behave a bit differently at initialization.
    When you use them, you must explicitly define fields with the `val` keyword, and
    any additional constructors must initialize any fields not decorated with the
    `DefaultValue` attribute, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Self-Identifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes you’ll want to reference a class member within a constructor. By
    default, class members aren’t accessible because they require a recursive reference
    to the type, but you can enable *self-referencing* with the `as` keyword and a
    *self-identifier* like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can choose any name for your self-identifiers as long as you follow the
    normal rules for identifiers. You could even use a quoted identifier like the
    following ones if you really want to irritate your future self or anyone else
    who’s maintaining your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It’s generally best to stick with short names. Common conventions are to use
    either `x` or `this`. But whatever you choose, be consistent!
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The compiler will generate a warning if you define a self-identifier but don’t
    use it in your constructor. The reason is that using the as keyword makes the
    class definition recursive, which results in additional run time validation that
    can negatively impact initializing types in your class hierarchy. Use self-identifiers
    in primary constructors only when you actually need them.*'
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fields define the data elements associated with an object. In the previous section,
    we took a brief look at both ways to create fields. In this section, we’ll examine
    field creation in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: let Bindings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first way to create fields is with `let` bindings in the primary constructor.
    These fields, which must be initialized in the primary constructor, are *always*
    private to the class. Although they must be initialized when they’re created,
    you can make the value mutable as in any `let` binding, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, a mutable `let` binding is used to define the backing store for the `Name`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you want a little more control over a field or your class doesn’t have
    a primary constructor, create an explicit field with the `val` keyword. Explicit
    fields don’t need to be initialized immediately, but in classes with a primary
    constructor you’ll need to decorate them with the `DefaultValue` attribute to
    ensure that the value is initialized to its appropriate “zero” value, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `n` is an explicit field. Because `n` is of type `string`,
    it’s initialized to `null`, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicit fields are public by default, but you can make them private by including
    the `private` access modifier in the definition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like fields, *properties* represent data associated with an object. Unlike fields,
    though, properties offer more control over how that data is accessed or modified
    by exposing the actions through some combination of `get` and/or `set` functions
    (collectively called *accessors*).
  prefs: []
  type: TYPE_NORMAL
- en: You can define properties either implicitly or explicitly. One guideline is
    to favor implicit properties when you’re exposing a simple value; when you need
    custom logic when getting or setting a property value, use explicit properties
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Explicit properties are those where you define and control the backing store
    (typically with a `let` binding) and implement the `get` and `set` function bodies
    yourself. You define an explicit property with the `member` keyword followed by
    a self-identifier, the property name, a type annotation (if the compiler can’t
    infer it), and the function bodies, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `name` field is the private backing store for the read/write
    `Name` property. Once you’ve created an instance of this `Person` class, you can
    assign a value to the `Name` property with the assignment operator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `and` keyword, you can use an alternative syntax where
    the `get` and `set` accessors are defined as separate properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Whichever syntax you choose, properties are public by default, but you can
    control their accessibility by inserting the access modifier (`public`, `private`,
    or `internal`) after the `with` (or `and`) keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted the `Name` property to be read-only, you could revise the class
    to include the value as an argument to the primary constructor and remove the
    `and set...` line in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is F#, so although defining a read-only property is already
    easy, there’s an even easier way with the explicit syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you’re creating a read-only property, the compiler automatically generates
    the `get` accessor function for you.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Implicit, or automatic, properties were added to F# in version 3.0 (if you’re
    using 2.0, you’ll need to use explicit properties). They’re very much like auto-implemented
    properties in C# in that they allow the compiler to generate the proper backing
    store and corresponding `get`/`set` accessor bodies. Implicit properties are a
    lot like their explicit counterparts, but there are a few differences.
  prefs: []
  type: TYPE_NORMAL
- en: First, implicit properties are considered part of the type’s initialization,
    so they must appear before other member definitions, typically along with the
    primary constructor. Next, they are defined via the `member val` keyword pair
    and must be initialized to a default value, as shown next. (They must not include
    a self-identifier.) And finally, their accessibility can be changed only at the
    property level, not the accessor level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If your implicit property is read-only, you can omit the `with` expression
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Indexed Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: F# classes can also have *indexed properties*, which are useful for defining
    an array-like interface for working with sequential data. Indexed properties are
    defined like ordinary properties except that the `get` accessor includes an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are creating indexed properties, naming one `Item` makes it a *default
    indexed property* and enables convenient syntactic support through the dot operator
    and a pair of brackets enclosing the index value (`.[...]`). For example, consider
    a class that accepts a string and exposes each word through a default indexer
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `Item` property is defined like a normal property with the `get`,
    and even a `set`, accessor. Because this indexer is just a wrapper around the
    `words` array (`String.Split` returns an array), it accepts an integer value and
    returns the corresponding word.
  prefs: []
  type: TYPE_NORMAL
- en: 'F# arrays are zero-based, so you can get the second word from a sentence like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the second word, you’d reference the index in the same way and use
    the assignment operator (`<-`) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, default indexed properties can be multidimensional. For instance,
    you can define one to return a specific character from a word by including two
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can easily get the first character of the second word like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you want to define another indexed property to get a character
    out of the original string? You’ve already defined a default indexed property
    that accepts an integer, so you can’t do it that way. In C#, you’d have to create
    this as a method, but in F# any property can be an indexed property. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The only caveat is that you can’t use the dot/bracket syntax that you’d use
    with a default indexed property; you have to access the property as if it’s a
    method (as described in [Instance Methods](ch04.html#instance_methods "Instance
    Methods")) by including the index value in parentheses after the property name
    in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Though it looks like a method call, if the `Chars` indexed property included
    a `set` accessor, you’d use the assignment operator just like you would with any
    other property to change the underlying value.
  prefs: []
  type: TYPE_NORMAL
- en: Setting at Initialization
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An alternative object initialization syntax lets you set individual property
    values as part of the constructor call. To use the object initialization syntax,
    you need only include each property name and value (separated by an equal sign)
    immediately following the normal constructor arguments. Let’s reconsider one of
    the previous `Person` class examples to illustrate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `Person` class has only the single, parameterless constructor,
    you could create an instance and then assign a value to the `Name` property in
    a second operation. But it would be much more concise to do it all at once, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one catch to using this syntax: Any properties you initialize this
    way must be writable.'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods are functions that are associated with a class and that represent the
    type’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Instance Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two ways to define instance methods. The first form uses the `member`
    keyword to define a public method in much the same way as a property, as demonstrated
    by the `GetArea` method that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `Circle` class is initialized with a `diameter` value and contains
    a parameterless, public method named `GetArea` that calculates the area of the
    circle. Because `GetArea` is an instance method, you’ll need to create an instance
    of the `Circle` class to invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Method Accessibility
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with properties, you can control access to methods with accessibility modifiers.
    For example, to make a method private you would simply include the `private` keyword
    in the method’s signature, as in the `GetRadius` method here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use a `let` binding to define a private function, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Named Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you call a method, you’ll usually provide the arguments as a comma-delimited
    list with each argument corresponding to the parameter at the same position. For
    a bit of extra flexibility, though, F# allows *named arguments* for both methods
    and constructors. With named arguments, each argument is explicitly associated
    with a particular parameter by name. In some cases, named arguments can help clarify
    your code, but they also allow you to specify the arguments in any order.
  prefs: []
  type: TYPE_NORMAL
- en: The following example contains a method that calculates the Euclidean distance
    between two points in a three-dimensional space (RGB colors, to be exact).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the `GetEuclideanDistance` method normally by specifying two colors,
    or by specifying the parameter names in the argument list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can specify named arguments in any order. You can also use named arguments
    with unnamed arguments, but if you do, the unnamed arguments must appear first
    in the argument list. Finally, because named arguments are permissible only for
    methods defined with the member syntax, they can’t be used with functions created
    through `let` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *overloaded method* shares its name with one or more other methods in the
    same class but has a different set of parameters. Overloaded methods often define
    subsets of parameters, with each overload calling a more specific form with its
    supplied arguments and providing default values for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you were building a utility to tie in to your favorite version
    control system, you might define a `Commit` method that accepts a list of files,
    the description, and the target branch. To make the target branch optional, you
    could overload the `Commit` function as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the overload at ① is responsible for committing changes to
    the repository, while the overload at ② makes the branch parameter optional when
    you supply the default value shown at ③.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though F# supports method overloading, you probably won’t use it very often
    because F# also supports *optional parameters*, which are generally more convenient.
    If you prefix a parameter name with a question mark (`?`), the compiler treats
    it as an optional parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters are a bit different in F# than they are in C# and Visual
    Basic. In other languages, optional parameters are defined with a default value
    that’s used when the corresponding argument is omitted. In F#, though, the parameters
    are actually compiled to `option<_>` and default to `None`. (Optional parameter
    values behave like any other option type value, so you’ll still use `defaultArg`
    or pattern matching in your method to get a meaningful value, as appropriate.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s rewrite the `Repository` example from the previous section to use an optional
    parameter instead of an overloaded method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Although you need to manage the optional parameter within the method, you now
    need to maintain only the one method instead of multiple, overloaded versions.
    As you can see, optional parameters can reduce the likelihood of defects that
    come from using inconsistent defaults across overloads, and they simplify refactoring
    because only one method needs to change.
  prefs: []
  type: TYPE_NORMAL
- en: Slice Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Indexed properties, introduced in [Indexed Properties](ch04.html#indexed_properties
    "Indexed Properties"), are great for working with a single value in an encapsulated
    sequence, but you’ll sometimes want to work with a range of values in that sequence.
    Traditionally you’d have to get each item manually through the indexer, or implement
    `IEnumerable<'T>` and get the values through some combination of LINQ’s `Skip`
    and `Take` extension methods. *Slice expressions* resemble indexed properties,
    except that they use range expressions to identify which items should be included
    in the resulting sequence.
  prefs: []
  type: TYPE_NORMAL
- en: To use slice expressions with your class, you need to implement a `GetSlice`
    method. There’s really nothing special about the `GetSlice` method; it’s just
    the method that the compiler looks for when it encounters the slice expression
    syntax. To illustrate a slice expression, let’s revisit the `Sentence` class from
    the indexed properties section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The basic class definition is the same as before, except this time we have a
    `GetSlice()` method that accepts the lower and upper bounds. (Don’t dwell on the
    match expressions here; a full discussion is waiting for you in [Chapter 7](ch07.html
    "Chapter 7. Patterns, Patterns, Everywhere"). For now it’s enough to know that
    they’re just doing some boundary checks.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You could call this method directly in your code, but the expression form is
    much more convenient. For example, to retrieve the second, third, and fourth words
    in a sentence, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: One of the nice things about slice expressions is that the bounds parameters
    are optional, so you can use open-ended ranges. To specify a range without a lower
    bound, just omit the first value (the 1) in the slice expression, which in this
    case is equivalent to `[0..3]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can leave out the second parameter and get the items up to the
    end of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Like indexed properties, slice expressions can work on two dimensions, but
    you need to overload the `GetSlice` method to accept four parameters that define
    both pairs of lower and upper bounds. Continuing with the `Sentence` example,
    we can add a multidimensional slice overload to get a range of characters from
    a range of words like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To use this overload, just separate the range pairs in the slice expression
    with a comma.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final member type is *events*. Events are used throughout the .NET Framework
    with some notable examples found in the user interface components and ADO.NET.
    As in other .NET languages, at their core F# events are collections of functions
    invoked in response to some action like a button click or an asynchronous process
    completion.
  prefs: []
  type: TYPE_NORMAL
- en: In many ways F# events serve the same purpose as traditional .NET events, but
    they’re a completely different mechanism. However, for cross-language compatibility,
    they can tie in to the .NET event system. (We’ll see how your custom events can
    harness this capability with the `CLIEvent` attribute a bit later in this section.)
  prefs: []
  type: TYPE_NORMAL
- en: Basic Event Handling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Events in F# are instances of the `Event<'T>` class (found in `FSharp.Core.Control`).
    One of the primary features that the `Event<'T>` class enables is a more explicit
    publish/subscribe model than you might be used to. In this model you can subscribe
    to published events by adding event handlers to the event via a call to the `Add`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `System.Timers.Timer` class publishes an `Elapsed` event that
    you can subscribe to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a new instance of the `Timer` class at ①. At ②, we subscribe
    to the `Elapsed` function using a *lambda expression* (an anonymous function)
    as the event handler. Once the timer is started at ③, the event handler prints
    `tick` and increments a reference cell’s value (remember, closures like the one
    created by the lambda expression can’t use mutable `let` bindings) every half-second,
    per the timer definition. When the tick counter reaches five, the loop will terminate
    and the timer will be stopped and disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: Observing Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The other primary benefit of F# events is that they enable you to treat events
    as sequences that you can intelligently partition, filter, aggregate, or otherwise
    act upon as they’re triggered. The `Event` module defines a number of functions—such
    as `add`, `filter`, `partition`, and `pairwise`—that accept published events.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this principle in action, let’s turn to an example in ADO.NET. The `DataTable`
    class triggers a variety of events in response to certain actions like changed
    or deleted rows. If you wanted to handle the `RowChanged` event, you could add
    a single event handler (just as in the previous section) and include logic to
    filter out the events you don’t care about, or you could use the `filter` function
    from the `Event` module and invoke your handler only when it’s needed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We’ll forego a discussion of the first half of this example; for our purposes,
    all that’s important there is that it sets up a `DataTable` with three columns
    and a primary key. What’s really important here is the `partition` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we invoke the `partition` function at ③ by supplying both a
    delegate (in the form of a lambda expression) at ④ and the `Event` object published
    by the `DataTable`’s `RowChanged` event at ②. The `partition` function then returns
    two new events that we bind to `h1` and `h2` at ①. Finally, we subscribe to both
    of the new events by calling their `Add` method at ⑤ and ⑥.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the table structure and event handlers are in place, we can add some
    rows and see how the events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when the first row is added, the last name doesn’t match the
    criteria specified in the filter, so `h2` is triggered. However, the second row
    does match the criteria, so `h1` is triggered instead.
  prefs: []
  type: TYPE_NORMAL
- en: If the syntax for calling the partition function looks backward, that’s because
    it is; the *forward pipelining operator* (`|>`) applies its left operand as the
    final argument to the function specified by its right operand. (The forward pipelining
    operator is used frequently in F#, and we’ll explore it in much more detail in
    [Chapter 5](ch05.html "Chapter 5. Let’s Get Functional").)
  prefs: []
  type: TYPE_NORMAL
- en: Custom Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can define your own custom events in your types. However, doing so is a
    bit different than in other .NET languages because events exist only as objects
    in F# and they lack keyword support.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to do, aside from defining the type, is create a field
    (with a `let` binding) for your event object. This is the object used to coordinate
    publishing and triggering the event. Once the field is defined, you can expose
    the event’s `Publish` property to the outside world with a property of your own.
    Finally, you’ll need to trigger the event somewhere by calling the `Trigger` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With the type defined, you can create a new instance and subscribe to the `ToggleChanged`
    event as with any built-in type. For example, next we use a partition to create
    two new event handlers, one to handle when the toggle is turned on and another
    to handle when it is turned off. The call to `Event.map` simply rephrases the
    event by throwing away the first parameter (the source, or sender, per .NET conventions)
    before calling the `partition` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now every call to the `Toggle` method will trigger the `ToggleChanged` event
    and cause one of the two handlers to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve just seen, the `ToggleChanged` event is fully enabled within F#.
    If your class won’t be consumed outside F# assemblies, you could stop here. However,
    if you need to use it in assemblies written in different languages, you’ll have
    to do one more thing: decorate the `ToggleChanged` property with the `CLIEvent`
    attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `CLIEvent` attribute instructs the compiler to include the appropriate metadata
    that makes the event consumable from other .NET languages.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Structures*, or *structs*, are similar to classes in that they can have fields,
    properties, methods, and events. Structs are defined just like classes except
    that the type must be decorated with the `Struct` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: However, despite their similarities, behind the scenes, classes and structs
    are very different animals. The primary difference between them is that structs
    are *value types*.
  prefs: []
  type: TYPE_NORMAL
- en: This difference is significant because it affects not only how you interact
    with the data but also how value types are represented in the computer’s memory.
    With both types, the runtime allocates space in memory to store the value. Value
    types always result in a new allocation with the data copied into that space.
    With reference types, the memory is allocated once and accessed via a reference
    that identifies its location.
  prefs: []
  type: TYPE_NORMAL
- en: When you pass a reference type to a function, the runtime creates a new reference
    to that location in memory rather than a copy of the data. Therefore, reference
    types can more easily wreak havoc through side effects, because when you pass
    a reference type to a function any changes that you make to that object are immediately
    reflected wherever that object is referenced. In contrast, passing a value type
    to a function creates a copy of the value so any changes to it are isolated to
    that one instance.
  prefs: []
  type: TYPE_NORMAL
- en: Structs are also initialized differently than classes. Unlike classes, the compiler
    generates a default (parameterless) constructor for structs that initializes all
    fields to their appropriate zero value (`zero`, `null`, and so on). This means
    that you can’t use `let` bindings to create private instance fields or methods
    within a struct unless they’re static; instead, you must use `val` to define struct
    instance fields. Also, you can’t define your own default constructor, so any additional
    constructors you define must accept at least one parameter. (Your fields can still
    be mutable as long as you don’t include a primary constructor.)
  prefs: []
  type: TYPE_NORMAL
- en: Because of differences in how memory is allocated for reference and value types,
    structs cannot contain fields of their own type. Without this restriction, the
    memory requirement for a struct instance would be infinitely large because each
    instance would recursively require enough space for another instance of the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, structs can implement interfaces but cannot otherwise participate in
    inheritance. Regardless, structs still derive from `System.Object`, so you can
    override methods (like `ToString`).
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OO programming, *inheritance* describes an *identity* relationship between
    two types in the way that an apple *is* a fruit. F# classes support *single inheritance*,
    meaning that any given class can directly inherit from only one other in order
    to establish a class hierarchy. Through inheritance, public (and sometimes internal)
    members exposed by the base type are automatically available in the derived type.
    You can see this principle in action in the following snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `DerivedType` defined here doesn’t define any functionality of its own,
    but because it derives from `BaseType`, the `SayHello` method is accessible through
    `DerivedType`.
  prefs: []
  type: TYPE_NORMAL
- en: F# inheritance requires a primary constructor. To specify a base class, include
    the `inherit` keyword followed by the base type name and its constructor arguments
    in the primary constructor before any bindings or member definitions. For instance,
    a task management system might have a `WorkItem` class that represents all work
    items in the system, as well as specialized classes such as `Defect` and `Enhancement`
    that derive from the `WorkItem` class, as shown next in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Every .NET class, including the primitive types, ultimately participates in
    inheritance. Also, when you define a class without explicitly specifying a base
    class, the defined class implicitly inherits from `System.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Fundamentals") you learned how to convert
    between numeric types. Types can also be converted within their type hierarchy
    through the upcast and downcast operators.
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Until now I’ve maintained that there are no implicit conversions in F#, but
    that’s not entirely true. The only time that types are implicitly *upcast* (converted
    to a type higher in their inheritance structure) is when they’re passed to a method
    or a `let`-bound function where the corresponding parameter is a flexible type.
    In all other cases, you must explicitly cast the type with the *static cast* operator
    (`:>`).
  prefs: []
  type: TYPE_NORMAL
- en: To see the static cast operator in action, let’s continue with the `WorkItem`
    example by creating a `Defect` and immediately casting it to a `WorkItem`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The static cast operator resolves valid casts at compile time. If the code compiles,
    the conversion will always succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Downcasting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The opposite of an upcast is a *downcast*. Downcasts are used to convert a type
    to something lower in its hierarchy, that is, to convert a base type to a derived
    type. To perform a downcast, you use the *dynamic cast* operator (`:?>`)
  prefs: []
  type: TYPE_NORMAL
- en: Because the `WorkItem` instance we created in the previous example is still
    a `Defect`, we can use the dynamic cast operator to convert it back to a `WorkItem`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the static cast operator, the dynamic cast operator isn’t resolved until
    run time, so you may see an `InvalidCastException` if the target type isn’t valid
    for the source object. For instance, if you try to downcast `w` to `Enhancement`,
    the cast will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Overriding Members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aside from reusing code, you might use inheritance to change the functionality
    offered by a base class by overriding its members.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `ToString` method defined on `System.Object` is a great (and
    often overlooked) debugging tool whose default implementation isn’t particularly
    informative because it just returns the type name. To make it more useful, your
    classes can override the default functionality and return a string that actually
    describes the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, consider the `WorkItem` class from earlier. If you were to call
    its `ToString` method, you would see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In the preceding example, FSI_0002+ is an artifact of invoking the code in
    FSI. Your type name will probably differ.*'
  prefs: []
  type: TYPE_NORMAL
- en: To override the default behavior and make `ToString` return something more useful,
    define a new method with the `override` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you call `ToString` now, the result will be the summary text instead of the
    type name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can override a given function only once per type, but you can override
    it at multiple levels in the hierarchy. For instance, here’s how you could override
    `ToString` again in the `Defect` class to display the severity of the defect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When overriding a *virtual member* (an abstract member with a default implementation),
    you can call into the base functionality through the `base` keyword. The `base`
    keyword behaves like a self-identifier except that it represents the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our `ToString` override theme, to augment the default behavior
    your override could call `base.ToString()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `base` keyword is available only in classes that explicitly inherit
    from another type. To use the `base` keyword in a class that inherits from `System.Object`,
    you would need to explicitly inherit from it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Abstract Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *abstract class* is one that can’t be directly instantiated; it’s accessible
    only through derived classes. Abstract classes typically define a common interface
    and optional implementation for a group of related classes that fulfill similar
    needs in different ways. Abstract classes are used throughout the .NET Framework;
    one great example is the `TextWriter` class in the `System.IO` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The `TextWriter` class defines a common mechanism for writing characters to
    *something*. It doesn’t care where or how the characters are written, but it orchestrates
    some of the process, with the implementation details left to individual derived
    classes such as `StreamWriter`, `StringWriter`, and `HttpWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define your own abstract classes by decorating the type definition
    with the `AbstractClass` attribute. For example, to create a simple tree structure
    you could use an abstract class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Abstract Members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One reason to define an abstract class is to define *abstract members*, that
    is, members without an implementation. Abstract members are allowed only in abstract
    classes (or interfaces, described in [Interfaces](ch04.html#interfaces "Interfaces"))
    and must be implemented in a derived class. They’re handy when you want to define
    what a class does but not how it does it.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you want to define the data associated with a particular type but not how
    that data is stored or what happens when it is accessed, you can define an *abstract
    property* with the `abstract` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this abstract class contains one abstract property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`AbstractBaseClass` requires only that its subtypes implement the `SomeData`
    property, but they’re free to implement their own storage mechanism. For instance,
    one derived class may use a traditional backing store, whereas another may opt
    to use a .NET generic dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both `BindingBackedClass` and `DictionaryBackedClass` derive
    from `AbstractBaseClass`, but they implement the `SomeData` property in very different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though you can define abstract properties, you’re much more likely to use
    *abstract methods*. Like abstract properties, abstract methods allow you to define
    a capability that derived classes must implement without specifying any of the
    implementation details. For example, when calculating the area of a shape, you
    might define an abstract `Shape` class that includes an abstract `GetArea` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Because the method doesn’t have an implementation, you must explicitly define
    the entire signature. In this case, the `GetArea` method accepts `unit` and returns
    a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding a method is also similar to overriding a property, as you can see
    in the following `Circle` and `Rectangle` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Virtual Members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like C# and Visual Basic, F# allows *virtual members*—that is, properties or
    methods that can be overridden in a derived class. But unlike other .NET languages,
    F# takes a more literal approach to virtual members. For instance, in C# you include
    the `virtual` modifier in a nonprivate instance member definition, and in Visual
    Basic you use the `Overridable` modifier to achieve the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual members in F# are closely related to abstract members. In fact, in order
    to create a virtual member you first define an abstract member and then provide
    a default implementation with the `default` keyword. For example, in the following
    listing the `Node` class is the basis for a simple tree structure. It provides
    two virtual methods, `AddChild` and `RemoveChild`, which help control the tree
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: With this definition, all `Node` class instances (including any derived types)
    will allow children. To create a specialized `Node` that doesn’t allow children,
    you could define a `TerminalNode` class and override both virtual methods to prevent
    children from being added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Sealed Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *sealed class* is a class that cannot serve as the base class for another
    class. One of the most notable sealed classes in the .NET Framework is `System.String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create your own sealed classes by decorating them with the `Sealed`
    attribute, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you tried to create another class that inherits from the `NotInheritable`
    class, the compiler would raise an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Static Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields, properties, and methods are instance members by default. You can make
    each static so that it applies to the type rather than a specific instance by
    including the `static` keyword before the member definition.
  prefs: []
  type: TYPE_NORMAL
- en: A Word about Static Classes
  prefs: []
  type: TYPE_NORMAL
- en: In C# a *static class* is an implicitly sealed class that cannot be instantiated
    and in which all members are static. Most of the time in F#, when you want static
    class–like functionality, you’ll place it in a module. However, modules have certain
    limitations. For example, they don’t allow you to overload functions.
  prefs: []
  type: TYPE_NORMAL
- en: Although F# doesn’t directly support static classes the way that C# does, you
    can do a little syntactic dance to achieve a similar effect. To do so, omit the
    primary constructor (or make it private if you need a static initializer) to ensure
    that no instances can be created, and then verify that every member is static
    (the F# compiler won’t enforce this for you). For completeness, decorate the class
    with `SealedAttribute` so that nothing inherits from it.
  prefs: []
  type: TYPE_NORMAL
- en: Static Initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Static initializers*, or *static constructors*, execute only once per class
    and ensure that certain code is executed before a class is used for the first
    time. You create static initializers in F# through a series of static `let` and
    `do` bindings, just as you would when defining a primary constructor. In fact,
    if your class needs a static initializer, you must include a primary constructor
    to contain the static bindings as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Static initializers can access only the static members of their containing class.
    If you try to access an instance member from within a static initializer, you’ll
    get a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Static Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Static fields* are often useful as a single reference for something you need
    to use repeatedly. For example, to associate certain data with the class itself,
    define a static field by including the `static` keyword before a `let` binding,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: When the `DoSomething` and `DoSomethingElse` methods are called, each calls
    a function in the `Logger` module to write a log message in the same category
    but without the duplication of data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Static Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properties can also be static. Here, a read-only *static property* is used to
    expose the number of times a particular method has been called across all instances
    of your class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Every time the `Process` method is called, it increments the `itemsProcessed`
    field and prints a message. To see how many times the `Process` method has been
    called across all instances, inspect the `ItemsProcessed` property on the `Processor`
    class itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This example iterates as long as the `Process` method has been invoked fewer
    than five times. Each iteration creates a new instance of the `Processor` class
    and invokes its `Process` method (which illustrates how the static property is
    instance agnostic).
  prefs: []
  type: TYPE_NORMAL
- en: Static Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other static members, *static methods* apply to a type rather than an instance.
    For example, static methods are commonly used in the *Factory pattern* (a common
    approach to creating instances of similar classes without relying on a specific
    implementation). In some variations of the Factory pattern, a static method returns
    new instances of objects that conform to a specific interface. To illustrate this
    concept, consider an application where you need to handle different image formats.
    You may have an abstract `ImageReader` class that other types derive from in order
    to handle specific formats like JPEG, GIF, and PNG.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'A Factory method for creating instances of these classes might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The static `CreateReader` method in the preceeding snippet uses F# pattern
    matching to create the appropriate `ImageReader` implementation based on the provided
    filename. When the file extension isn’t recognized, it raises an exception indicating
    that the format isn’t supported. Because the method is static, you can call it
    without creating an instance of the `ImageReaderFactory` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Mutually Recursive Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When two or more types depend on each other such that one cannot be used without
    the other, the types are said to be *mutually recursive*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, think of a book and its pages. The book can contain a collection
    of pages, but each page might also refer back to the book. Remember, F# is evaluated
    top-down, so which type would you define first? The book or the page? Because
    the book depends on its pages and the page refers back to the book, there is mutual
    recursion here. This means that you must define the types together using the `and`
    keyword, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In OO programming, *interfaces* specify the properties, methods, and sometimes
    even events that a type must support. In some ways interfaces are like abstract
    classes, with certain important differences. For one, unlike abstract classes,
    interfaces cannot contain any implementations of their members; their members
    must be abstract. Also, because interfaces define functionality that implementers
    must support, all interface members are implicitly public. Finally, interfaces
    aren’t subject to the same inheritance restrictions as classes: A class can implement
    any number of interfaces (and structs can, too).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F# approaches interface implementation a bit differently than its .NET language
    counterparts. C# and Visual Basic allow both implicit and explicit implementations.
    With *implicit implementations*, interface members are accessible directly through
    the implementing class, whereas with *explicit implementations*, interface members
    are accessible only when the implementing type is treated as the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this C# example with two classes that both implement the `IDisposable`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Both classes implement `IDisposable`, but `ImplicitExample`① does so implicitly
    and `ExplicitExample` ② does it explicitly. This difference has a dramatic effect
    on how you call the `Dispose` method in each class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here we instantiate `ImplicitExample` at ① and `ExplicitExample` at ③. For both
    classes we call the `Dispose` method, but because `Dispose` is implicitly implemented
    in the `ImplicitExample` class we can call it directly through `ex1`, as we do
    at ②. The compiler would produce an error if we tried the same approach with `ex2`
    because `Dispose` is explicitly implemented in `ExplicitExample`. Instead, we
    need to cast `ex2` to `IDisposable`, as shown at ④, in order to call its `Dispose`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*All interface implementations in F# are explicit. Though F# honors implicit
    interface implementations on types defined in other languages, any implementations
    that you define in F# will be explicit.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing an interface in F# is similar to inheriting from another class
    except that it uses the `interface` keyword. For example, to implement `IDisposable`
    in one of your types, you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To manually invoke the `Dispose` method on the `MyDisposable` class, you’ll
    need to cast an instance to `IDisposable`, as shown here with the static cast
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Defining Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you define a type without any constructors and only abstract members,
    the F# compiler infers that the type is an interface. For example, an interface
    for working with image data might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `IImageAdapter` type contains no constructors and all of
    its four members are abstract. To define an empty, or *marker*, interface you
    can end the definition with the `interface end` keyword pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*It’s standard practice in .NET development to begin interface names with a
    capital letter* I *. You should do so for the sake of consistency.*'
  prefs: []
  type: TYPE_NORMAL
- en: Like classes, interfaces can inherit from each other to define more specialized
    contracts. Also like classes, interface inheritance is accomplished with the `inherit`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue our imaging example. The `IImageAdapter` interface is helpful
    for working with any image format, but some formats include capabilities not available
    in others. To handle these, you could define additional interfaces that represent
    these capabilities. For example, when working with a format that supports transparency
    you might create an `ITransparentImageAdapter` that derives from `IImageAdapter`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now, any types that implement the `ITransparentImageAdapter` must implement
    all members defined by both `IImageAdapter` and `ITransparentImageAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Fundamentals") you saw numerous predefined
    operators for working with the built-in data types. You can use *operator overloading*
    to extend many of these to your types as well. By overloading operators, you can
    make your custom types interact a bit more naturally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators in F# come in two forms: prefix and infix. *Prefix operators* are
    placed before their operand, whereas *infix operators* are placed between their
    operands. F# operators can also be *unary* or *binary*, meaning that they operate
    against one or two arguments, respectively. Custom operators are defined as static
    methods except that the name is the operator wrapped in parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: Prefix Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When defining a prefix operator, you must begin its name with a tilde (`~`)
    to distinguish it from infix operators with the same name. The tilde is not otherwise
    part of the operator. To demonstrate operator overloading, we’ll define a type
    that represents basic RGB colors. Consider this class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: To calculate the negative color you could define a `GetNegative` function, but
    wouldn’t it be more intuitive to prefix an instance with the negative sign (`-`)
    instead?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'With the custom operator defined, you can now create a color instance and find
    its negative with a convenient syntax like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Infix Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating infix operators is almost like creating prefix operators except that
    you omit the tilde character from the name.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the `RgbColor` example, it would be nice to add and subtract
    two colors using the familiar and natural `+` and `-` operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add and subtract colors just as we would add and subtract numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: New Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re not limited to overloading only existing operators. You can define custom
    operators using various combinations of the characters `!`, `%`, `&`, `*`, `+`,
    `-`, `.`, `/`, `<`, `=`, `>`, `?`, `@`, `^`, `|`, and `~`. Creating custom operators
    can be complicated because the combination you select determines the precedence
    (priority) and associativity (right to left or left to right) of the operation.
    Furthermore, creating custom operators can hinder the comprehensibility of your
    code if you choose something that’s not intuitive. That said, if you still want
    to define a new operator, the definition looks the same as an overload.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous section we overloaded the `+` operator to add two
    colors, but how about blending colors? The `+` operator would have been a nice
    choice for a blending operation, but because it’s already being used for adding
    colors we can define the `+=` operator instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now blending two colors is as easy as adding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Global Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not only does F# allow you to overload operators on types, but you can also
    define operators globally. This lets you create new operators even for types you
    don’t control! For example, to define any of the custom operators on the standard
    `System.Drawing.Color` struct, you could define a new operator at the global level
    using a `let` binding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Be careful when defining global operators. Any operator you define that conflicts
    with the built-in one will take priority, meaning you can inadvertently replace
    core functionality.*'
  prefs: []
  type: TYPE_NORMAL
- en: Object Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternative to formal inheritance, F# provides *object expressions*, a
    handy construct for creating ad hoc (anonymous) types based on an existing class
    or interface. Object expressions are useful when you need a one-off type but don’t
    want to create a formal type. (Although the analogy isn’t perfect, you might find
    it helpful to think of object expressions as lambda expressions for types, because
    the result of an object expression is an instance of a new type that implements
    the interface or inherits from a base class.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a simplified game scenario where a character can equip
    a weapon. You might see a weapon interface and character class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use these definitions to create a few characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: As currently written, if either character attacked the other he wouldn’t do
    much damage since he has only his fists. It would be nice to give each character
    a weapon, but all we have right now is the `IWeapon` interface. We could define
    types for every weapon we can think of, but it’s much more convenient to write
    a function that creates weapons for us via an object expression.
  prefs: []
  type: TYPE_NORMAL
- en: Object expressions, like the one in the following `forgeWeapon` function, are
    defined with the `new` keyword followed by the type name, the `with` keyword,
    and the member definitions all wrapped in braces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: With the `forgeWeapon` function in place, we can create some weapons for our
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both calls to `forgeWeapon` result in new instances of `IWeapon`.
    They can be used as if they had been formally defined through type definitions,
    as you can see by assigning each to a character and invoking the `Attack` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Despite their convenience, object expressions aren’t suitable for every situation.
    One of their primary drawbacks is that they must implement every abstract member
    from the underlying type. If the underlying interface or base class has many abstract
    members, an object expression can become cumbersome very quickly, so you would
    probably want to consider using a different construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object expressions aren’t limited to a single base type. To implement multiple
    base types with an object expression, you use an inheritance-like syntax. For
    instance, if you wanted weapons created through the `forgeWeapon` function to
    also implement `IDisposable`, you could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a new weapon is the same as earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Objects created through object expressions that include multiple base types
    are always treated as the type listed immediately after the `new` keyword, unless
    they’re explicitly cast to one of the other types. For example, in the case of
    the `forgeWeapon` function, the returned object will be `IWeapon` unless you cast
    it to `IDisposable`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Type Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When LINQ was added to the .NET Framework, one exciting feature that it introduced
    to C# and Visual Basic was extension methods. *Extension methods* allow you to
    add new methods to an existing type without relying on inheritance or other design
    patterns such as the Decorator pattern. F# provides similar capabilities except
    that it doesn’t stop with methods. In F#, you can create extension methods, properties,
    events, and even static members!
  prefs: []
  type: TYPE_NORMAL
- en: 'You extend existing types in F# through *type extensions*, or *type augmentations*.
    Type extensions come in two flavors: intrinsic and optional.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Intrinsic extensions* must be defined in the same namespace or module, and
    in the same source file as the type being extended. The new extensions become
    part of the extended type when the code is compiled and are visible through reflection.
    Intrinsic extensions are useful when you want to build up a type incrementally
    by grouping related pieces or as an alternative to building mutually recursive
    type definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Optional extensions* must be defined in a module. Like their C# and Visual
    Basic counterparts, they are accessible only when their containing namespace or
    module is open but are not visible through reflection. Optional extensions are
    most useful for adding custom functionality to types you don’t control or that
    are defined in other assemblies.'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether you’re defining intrinsic or optional extensions, the
    syntax is the same. You begin with a new type definition. The difference is that
    instead of using a primary constructor and an equal sign, you use the `with` keyword
    followed by your extension definitions. For example, here we extend the `Color`
    struct (in `System.Drawing`) with both a static and an instance method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This optional type extension enhances the `Color` struct’s usability by allowing
    you to create new instances from known hexadecimal color strings or translate
    the color into a hexadecimal color string. The type extension itself is at ②.
    The static extension method ③ relies on the regular expression (a domain-specific
    language for parsing strings) at ① to match and extract the hexadecimal value
    to convert it into the ARGB value passed to `Color`’s constructor. The instance
    extension method ④ simply returns the ARGB value formatted as a hexadecimal string.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Language Considerations
  prefs: []
  type: TYPE_NORMAL
- en: Despite serving a similar purpose, extension methods in F# are implemented differently
    than in the rest of the .NET Framework. Therefore, optional extension methods
    defined in F# aren’t accessible as extension methods in C# or Visual Basic unless
    you include the `Extension` attribute in both the type definition and extension
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite F#’s perception as a niche functional language on the .NET Framework,
    you’ve seen in this chapter that F# is also a full-featured OO language. Numerous
    examples demonstrated how F#’s concise syntax aids you in developing robust OO
    frameworks complete with classes, structures, and interfaces. You’ve even seen
    how to implement some common design patterns like Singleton and Factory.
  prefs: []
  type: TYPE_NORMAL
- en: Although F# supports the same common OO concepts as its more established counterpart
    languages, you’ve learned how it takes familiar concepts like operator overloading,
    events, and extension methods and expands them into something much more powerful
    through observation and type augmentation. Finally, you’ve seen how entirely new
    constructs like object expressions can improve code quality by allowing you to
    create ad hoc types when and where you need them.
  prefs: []
  type: TYPE_NORMAL
