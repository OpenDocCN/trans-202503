<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_861" aria-label="861"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch15">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">15</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">MANAGING COMPLEX PROJECTS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Most assembly language source files are not stand-alone programs. In general, you must call various standard library or other routines that are not defined in your main program because attempting to write such code as part of your application would be far too much work (and poor programming practice).</p>&#13;
<p class="TX">For example, the ARM doesn’t provide machine instructions like read, write, or put for doing I/O operations. The functions in this book contain thousands of lines of source code to accomplish these operations. For small programs, working with a single source file is fine, but for large programs, this gets cumbersome. Programming would be formidable if you had to merge these thousands of lines of code into your simple programs, which would then compile slowly. Furthermore, once you’ve debugged and tested a large section of your code, continuing to assemble that same code when you make a small change to another part of your program is a waste of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_862" aria-label="862"/>time. Imagine having to wait 20 or 30 minutes on a fast PC to assemble a program after making a one-line change!</p>&#13;
<p class="TX"><i>Programming in the large</i> is the term software engineers have coined to describe the processes, methodologies, and tools for reducing the development time of large software projects. While everyone has their own idea of what “large” is, <i>separate compilation</i> is one of the more popular techniques that support programming in the large. First, you break your large source files into manageable chunks. Then you compile the separate files into object code modules. Finally, you link the object modules together to form a complete program. If you need to make a small change to one of the modules, you need to reassemble only that one module rather than the entire program.</p>&#13;
<p class="TX">This chapter describes the tools that Gas and your OS provide for separate compilation and how to effectively employ these tools in your programs.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-151"/><span class="SANS_Futura_Std_Bold_B_11">15.1 The .include Directive</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive, when encountered in a source file, switches program input from the current file to the file specified in the operand field of the include directive. Section 1.5, <span class="Xref">“The</span> <i>aoaa.inc</i> <span class="Xref">Include File,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_10">page 10</a></span> described the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive as a way to include code from separate source files into the current assembly, allowing you to construct text files containing common constants, types, source code, and other Gas items into the assembly. As noted in that section, the syntax for the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive is</p>&#13;
<pre id="pre-1160"><code>.include "<var>filename</var>"</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">filename</span> must be a valid filename.</p>&#13;
<p class="TX">By this book’s convention, Gas include files have a <i>.inc</i> (include) suffix. Gas, however, does not require include files to have this suffix; any filename containing Gas assembly language source will work. Gas merges the specified file into the compilation at the point of the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive. You can nest <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> statements inside files you include; that is, a file being included into another file during assembly may itself include a third file.</p>&#13;
<p class="TX">Using the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive by itself does not provide separate compilation. You <i>could</i> use <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> to break up a large source file into separate modules and join these modules together when you compile your file. The following example would include the <i>print.inc</i> and <i>getTitle.inc</i> files during the compilation of your program:</p>&#13;
<pre id="pre-1161"><code>.include  "print.inc"&#13;
.include  "getTitle.inc"</code></pre>&#13;
<p class="TX">Your program will now benefit from modularity. Alas, you will not save any development time. The <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive inserts the source file at the point of the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> during compilation, exactly as though you had typed <span role="doc-pagebreak" epub:type="pagebreak" id="pg_863" aria-label="863"/>that code yourself. Gas still has to compile the code, and that takes time. If you are including a large number of source files (such as a huge library) into your assembly, the compilation process could take <i>forever</i>.</p>&#13;
<p class="TX">In general, you should <i>not</i> use the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive to include source code as shown in the previous example, as this code won’t allow you to take advantage of separate compilation. Instead, use the <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> directive to insert a common set of constants, types, external procedure declarations, and other such items into a program. Typically, an assembly language include file does <i>not</i> contain any machine code (outside of a macro; see <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> for details). The purpose of using <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> files in this manner will become clearer after you see how the external declarations work (see section 15.3, <span class="Xref">“Assembly Units and External Directives,”</span> on <span class="Xref">the next page</span>).</p>&#13;
<p class="TX">If your assembly language source files have a <i>.S</i> suffix, you can also use the <span class="SANS_TheSansMonoCd_W5Regular_11">#include "</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">filename</span><span class="SANS_TheSansMonoCd_W5Regular_11">"</span> directive to include a source file. This is generally preferable because you can use the CPP directives in such include files (you can’t in a standard <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span> file). The rest of this chapter assumes the use of the <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span> directive rather than <span class="SANS_TheSansMonoCd_W5Regular_11">.include</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-152"/><span class="SANS_Futura_Std_Bold_B_11">15.2 Ignoring Duplicate Include Operations</span></h3>&#13;
<p class="TNI1">As you begin to develop sophisticated modules and libraries, you will eventually discover a big problem: some header files need to include other header files. Technically, this is fine in and of itself, but issues arise when one header file includes another, and that second header file includes another, and so on, such that the final header file includes the first header file.</p>&#13;
<p class="TX">There are two problems with a header file indirectly including itself. First, this creates an infinite loop in the compiler. The compiler will happily go on about its business including all these files over and over again until it runs out of memory or another error occurs. Second, when Gas includes a header file for the second time, it starts complaining bitterly about duplicate symbol definitions. After all, the first time it reads the header file, it processes all the declarations in that file; the second time around, it views all those symbols as duplicate symbols.</p>&#13;
<p class="TX">The standard technique for resolving recursively included files, well-known to C/C++ programmers, is to use conditional assembly to have Gas ignore the content of an include file. (See <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> for a discussion of conditional assembly for CPP and the Gas CTL.) The trick is to place an <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> (if defined) statement around all statements in the include file. Specify an undefined symbol as the <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> operand (I tend to use the include file’s filename, substituting underlines for periods). Then, immediately after the <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> statement, define that symbol; using a numeric equate and assigning the symbol the constant 1 is typical. Here’s an example of this <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> usage in action:</p>&#13;
<pre id="pre-1162"><code>#ifdef  myinclude_inc   // Filename: myinclude.inc&#13;
#define myinclude_inc 1&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_864" aria-label="864"/><var> Put all the source code lines for the include file here.</var>&#13;
&#13;
// The following statement should be the last nonblank line&#13;
// in the source file:&#13;
&#13;
#endif  // myinclude_inc</code></pre>&#13;
<p class="TX">If you attempt to include <i>myinclude.inc</i> a second time, the <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> directive will cause Gas (actually, the CPP) to skip over all the text up to the corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">#endif</span> directive, thus avoiding the duplicate definition errors.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-153"/><span class="SANS_Futura_Std_Bold_B_11">15.3 Assembly Units and External Directives</span></h3>&#13;
<p class="TNI1">An <i>assembly unit</i> is the assembly of a source file plus any files it directly or indirectly includes. An assembly unit produces a single <i>.o</i> (object) file after assembly. The linker takes multiple object files (produced by Gas or other compilers, such as GCC) and combines those object files into a single executable file. The main purpose of this section, and, indeed, this whole chapter, is to describe how these assembly units (<i>.o</i> files) communicate linkage information to one another during the linking process. Assembly units are the basis for creating modular programs in assembly language.</p>&#13;
<p class="TX">To use Gas’s assembly unit facilities, you must create at least two source files. One file contains a set of variables and procedures used by the second. The second file uses those variables and procedures without knowing how they’re implemented.</p>&#13;
<p class="TX">Technically, the <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span> directive provides you with all the facilities you need to create such modular programs. You can create several modules, each containing a specific routine, and include those modules, as necessary, in your assembly language programs by using the <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span> directive. However, if you use this method, including a routine you’ve debugged in a compilation will still waste time because Gas must recompile bug-free code whenever you assemble the main program. A much better solution is to preassemble the debugged modules and link the object code modules together, using Gas’s <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">.extern</span> directives, which this section covers.</p>&#13;
<p class="TX">All the programs appearing in this book up to this point have been separately assembled modules that happen to link with a C/C++ main program rather than another assembly language module. In every program thus far, the assembly language “main program” has been named <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span>, which is nothing but a C++-compatible function that the generic <i>c.cpp</i> program has called from its main program. For example, consider the body of <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> from <span class="Xref">Listing 1-3</span> on <span class="Xref"><a href="chapter1.xhtml#pg_9">page 9</a></span> (for Linux and Pi OS systems):</p>&#13;
<pre id="pre-1163"><code>// Listing1-3.S&#13;
//&#13;
// A simple Gas module that contains&#13;
// an empty function to be called by&#13;
// the C++ code in Listing 1-2.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_865" aria-label="865"/>        .text&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
        .global asmMain&#13;
        .align  2    // Guarantee 4-byte alignment.&#13;
asmMain:&#13;
&#13;
// Empty function just returns to C++ code:&#13;
&#13;
        ret          // Returns to caller</code></pre>&#13;
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">.global asmMain</span> statement has been included in every program that has had an <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function without any definition or explanation. It’s now time to deal with that oversight.</p>&#13;
<p class="TX">Normal symbols in a Gas source file are <i>private</i> to that particular source file and are inaccessible from other source files (that don’t directly include the file containing those private symbols, of course). That is, the <i>scope</i> of most symbols in a source file is limited to those lines of code within that particular source file and any files it includes. The <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> directive tells Gas to make the specified symbol <i>global</i> to the assembly unit—accessible by other assembly units during the link phase. By placing the <span class="SANS_TheSansMonoCd_W5Regular_11">.global asmFunc</span> statement in the example programs appearing throughout this book, these sample programs have made the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> symbol global to the source file containing them so that the <i>c.cpp</i> program can call the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> function.</p>&#13;
<p class="TX">As you may recall, macOS requires an underscore prefix in front of the global name. This means you would use <span class="SANS_TheSansMonoCd_W5Regular_11">.global _asmMain</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">_asmMain:</span> if you wanted this source file to assemble under macOS. The <i>aoaa.inc</i> header file resolves this issue in a portable fashion, but the code from <i>Listing1-3.S</i> does not include <i>aoaa.inc</i>.</p>&#13;
<p class="TX">Simply making a symbol public is insufficient to use that symbol in another source file. The source file that wants to use the symbol must also declare that symbol as <i>external</i>. This notifies the linker that it will have to patch in the address of a public symbol whenever the file with the external declaration uses that symbol. For example, the <i>c.cpp</i> source file defines the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> symbol as external in the following lines of code (for what it’s worth, this declaration also defines the external symbol <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span>):</p>&#13;
<pre id="pre-1164"><code>// extern "C" namespace prevents&#13;
// "name mangling" by the C++&#13;
// compiler.&#13;
&#13;
extern "C"&#13;
{&#13;
    // Here's the external function,&#13;
    // written in assembly language,&#13;
    // that this program will call:&#13;
&#13;
    void asmMain(void);&#13;
    int readLine(char *dest, int maxLen);&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_866" aria-label="866"/>In this example, <span class="SANS_TheSansMonoCd_W5Regular_11">readLine</span> is actually a C++ function defined in the <i>c.cpp</i> source file. C/C++ does not have an explicit public declaration. Instead, if you supply the source code for a function in a source file that declares that function to be external, C/C++ will automatically make that symbol public by virtue of the external declaration.</p>&#13;
<p class="TX">When you place an <span class="SANS_TheSansMonoCd_W5Regular_11">.extern</span> directive in your program, Gas treats that declaration the same as any other symbol declaration. If the symbol already exists, Gas will generate a symbol redefinition error. Generally, you should place all external declarations near the beginning of the source file to avoid any scoping / forward reference issues.</p>&#13;
<p class="TX">Technically speaking, using the <span class="SANS_TheSansMonoCd_W5Regular_11">.extern</span> directive is optional, as Gas assumes that any symbol you use that is not defined in a source file is an external symbol. The linker will report actual undefined symbols if it fails to find a symbol when linking in all the other object code modules. However, it is good programming style to explicitly define your external symbols with <span class="SANS_TheSansMonoCd_W5Regular_11">.extern</span> in order to make your intentions clear to others reading your source code.</p>&#13;
<p class="TX">Because the <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> directive does not actually define the symbol, its placement is not as critical as the <span class="SANS_TheSansMonoCd_W5Regular_11">.extern</span> directive’s is. Some programmers put all the global declarations at the beginning of a source file; others put the global declaration right before the definition of the symbol (as I’ve done with the <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> symbol in most of the same programs). Either is fine.</p>&#13;
<p class="TX">Because a public symbol from one source file can be used by many assembly units, a problem develops: you have to replicate the <span class="SANS_TheSansMonoCd_W5Regular_11">.extern</span> directive in all the files that use that symbol. For a small number of symbols, this is not much of an issue. However, as the number of external symbols increases, maintaining all these external symbols across multiple source files becomes burdensome.</p>&#13;
<p class="TX">The Gas solution is the same as the C/C++ solution: <i>header files</i>. These are simply include files containing external (and other) declarations that are common among multiple assembly units. Header files get their name from the fact that the include statement that injects their code into a source file usually appears at the beginning (the “head”) of the source file that uses them. This turns out to be the primary use of include files in Gas.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h1-154"/><span class="SANS_Futura_Std_Bold_B_11">15.4 Creating a String Library with Separate Compilation</span></h3>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> provided several examples of string-handling functions along with macros and the string structure. The problem with these functions and declarations is that they must be cut and pasted into any source file that wants to use them. It would be far better to create a header file containing the macros, structures, and external symbol definitions and then compile the individual functions into <i>.o</i> files to link with those programs that want to use those functions. This section describes how to create linkable object modules for these string functions.</p>&#13;
<p class="TX">The header file for the strings library is <i>strings.inc</i>:</p>&#13;
<pre id="pre-1165"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_867" aria-label="867"/>// strings.inc&#13;
//&#13;
// String function header file for the assembly&#13;
// language string format&#13;
&#13;
#ifndef  strings_inc&#13;
#define strings_inc 1&#13;
&#13;
// Assembly language string data structure:&#13;
&#13;
            struct  string, -16&#13;
            dword   string.allocPtr // At offset -16&#13;
            word    string.maxlen   // At offset -8&#13;
            word    string.len      // At offset -4&#13;
            byte    string.chars    // At offset 0&#13;
&#13;
            // Note: characters in string occupy offsets&#13;
            // 0 ... in this structure.&#13;
&#13;
            ends    string&#13;
&#13;
// str.buf&#13;
//&#13;
// Allocate storage for an empty string&#13;
// with the specified maximum size:&#13;
&#13;
            .macro  str.buf strName, maxSize&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   \maxSize&#13;
            .word   0&#13;
\strName:   .space  ((\maxSize+16) &amp; 0xFFFFFFF0), 0&#13;
            .endm&#13;
&#13;
// str.literal&#13;
//&#13;
// Allocate storage for a string buffer and initialize&#13;
// it with a string literal:&#13;
&#13;
            .macro  str.literal strName, strChars&#13;
            .align  4   // Align on 16-byte boundary.&#13;
            .dword  0   // NULL ptr for allocation ptr&#13;
            .word   len_\strName    // string.maxlen&#13;
            .word   len_\strName    // string.len&#13;
&#13;
            // Emit the string data and compute the&#13;
            // string's length:&#13;
&#13;
\strName:   .ascii  "\strChars"&#13;
len_\strName=       .-\strName&#13;
            .byte   0   // Zero-terminating byte&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_868" aria-label="868"/>            // Ensure object is multiple of 16 bytes:&#13;
&#13;
            .align  4&#13;
            .endm&#13;
&#13;
// str.len&#13;
//&#13;
//          Return the length of the string pointed at by X0.&#13;
//          Returns length in X0&#13;
&#13;
            .macro  str.len&#13;
            ldr     w0, [x0, #string.len]&#13;
            .endm&#13;
&#13;
// External declarations:&#13;
&#13;
            .extern str.cpy&#13;
            .extern str.cmp&#13;
            .extern str.substr&#13;
            .extern str.bufInit&#13;
            .extern str.alloc&#13;
            .extern str.free&#13;
&#13;
// This would be a good place to include external&#13;
// declarations for any string functions you write.&#13;
&#13;
#endif</code></pre>&#13;
<p class="TX">The source file for the <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span> function is in <i>str.cpy.S</i>:</p>&#13;
<pre id="pre-1166"><code>// str.cpy.S&#13;
//&#13;
// A str.cpy string copy function&#13;
&#13;
            #include    "aoaa.inc"&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> #include    "strings.inc"&#13;
&#13;
            .code&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// str.cpy&#13;
//&#13;
// Copies the data from one string variable to another&#13;
//&#13;
// On entry:&#13;
//&#13;
// X0- Pointer to source string (string struct variable)&#13;
// X1- Pointer to destination string&#13;
//&#13;
// On exit:&#13;
//&#13;
// Carry flag clear if no errors, carry is set if&#13;
// the source string will not fit in the destination.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_869" aria-label="869"/>          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> proc    str.cpy, public&#13;
&#13;
            locals  str_cpy&#13;
            qword   str_cpy.saveV0&#13;
            qword   str_cpy.saveX2X3&#13;
            dword   str_cpy.saveX4&#13;
            byte    str_cpy.stkSpace,64&#13;
            endl    str_cpy&#13;
&#13;
            enter   str_cpy.size&#13;
&#13;
            // Preserve X2 ... X4 and V0:&#13;
&#13;
            str     q0,     [fp, #str_cpy.saveV0]&#13;
            stp     x2, x3, [fp, #str_cpy.saveX2X3]&#13;
            str     x4,     [fp, #str_cpy.saveX4]&#13;
&#13;
            // Ensure the source will fit in the destination&#13;
            // string object:&#13;
&#13;
            ldr     w4, [x0, #string.len]&#13;
            ldr     w3, [x1, #string.maxlen]&#13;
            cmp     w4, w3&#13;
            bhi     str.cpy.done    // Note: carry is set.&#13;
&#13;
            // Set the length of the destination string&#13;
            // to the length of the source string.&#13;
&#13;
            str     w4, [x1, #string.len]&#13;
&#13;
            // X4 contains the number of characters to copy;&#13;
            // while this is greater than 16, copy 16 bytes&#13;
            // at a time from source to dest:&#13;
&#13;
            mov     x2, x0  // Preserve X0 and X1.&#13;
            mov     x3, x1&#13;
&#13;
cpy16:      ldr     q0, [x2], #16&#13;
            str     q0, [x3], #16&#13;
            subs    w4, w4, #16&#13;
            bhi     cpy16&#13;
&#13;
// At this point, you have fewer than 16 bytes to copy. If&#13;
// W4 is not 0, just copy 16 remaining bytes (you know,&#13;
// because of the string data structure, that if you have at&#13;
// least 1 byte left to copy, you can safely copy&#13;
// 16 bytes):&#13;
&#13;
            beq     setZByte    // Skip if 0 bytes.&#13;
&#13;
            ldr     q0, [x2]&#13;
            str     q0, [x3]&#13;
&#13;
// Need to add a zero-terminating byte to the end of&#13;
// the string. Note that maxlen does not include the&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_870" aria-label="870"/>// 0 byte, so it's always safe to append the 0&#13;
// byte to the end of the string.&#13;
&#13;
setZByte:   ldr     w4,  [x0, #string.len]&#13;
            strb    wzr, [x1, w4, uxtw]&#13;
&#13;
            adds    wzr, wzr, wzr   // Clears the carry&#13;
&#13;
str.cpy.done:&#13;
            ldr     q0,     [fp, #str_cpy.saveV0]&#13;
            ldp     x2, x3, [fp, #str_cpy.saveX2X3]&#13;
            ldr     x4,     [fp, #str_cpy.saveX4]&#13;
            leave&#13;
            endp    str.cpy</code></pre>&#13;
<p class="TX">The <i>str.cpy.S</i> source file is created by including the <i>strings.inc</i> header file <span class="CodeAnnotation" aria-label="annotation1">❶</span> and cutting and pasting the <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> from <span class="Xref">Listing 14-2</span> on <span class="Xref"><a href="chapter14.xhtml#pg_819">page 819</a></span>. Note the public argument after the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> macro. This causes the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> macro to emit a <span class="SANS_TheSansMonoCd_W5Regular_11">.global</span> directive for the <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span> symbol so that the function is available to other source files.</p>&#13;
<p class="TX">The <i>str.cmp.S</i>, <i>str.substr.S</i>, <i>str.alloc.S</i>, <i>str.free.S</i>, and <i>str.bufInit.S</i> source files are created from their corresponding functions (in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>) in a similar fashion. I won’t include those source files here because they are redundant and consume too much space, but you can find copies in the online source files at <i><a href="https://artofarm.randallhyde.com">https://<wbr/>artofarm<wbr/>.randallhyde<wbr/>.com</a></i>.</p>&#13;
<p class="TX">If you try to use the usual <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command to assemble any of these modules, you get an error from the system complaining about missing symbols. This is because these modules are not stand-alone assembly language programs. In the following section, I describe the correct way to build these library modules; in the meantime, here are some cheesy commands that will assemble these files without error (though there will be a warning):</p>&#13;
<pre id="pre-1167"><code><span class="SANS_TheSansMonoCd_W7Bold_11">./build -c str.cpy</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">./build -c str.cmp</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">./build -c str.substr</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">./build -c str.bufInit</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">./build -c str.alloc</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">./build -c str.free</span></code></pre>&#13;
<p class="TX">This will assemble the files without running the linker (<span class="SANS_TheSansMonoCd_W5Regular_11">-c</span> means <i>compile only</i>), generating the files <i>str.cpy.o</i>, <i>str.cmp.o</i>, <i>str.substr.o</i>, <i>str.bufInit.o</i>, <i>str.alloc.o</i>, and <i>str.free.o</i>, respectively. Of course, the next question is how to link these files with an application program. Listing 15-1 is an amalgamation of various <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> functions from <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> that make calls to the <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> functions.</p>&#13;
<pre id="pre-1168"><code>// Listing15-1.S&#13;
//&#13;
// A program that calls various string functions&#13;
&#13;
            #include    "aoaa.inc"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_871" aria-label="871"/>            #include    "strings.inc"&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
            .data&#13;
&#13;
            str.buf     destination, 256&#13;
            str.literal src,    "String to copy"&#13;
            str.literal left,   "some string"&#13;
            str.literal right1, "some string"&#13;
            str.literal right2, "some string."&#13;
            str.literal right3, "some string"&#13;
&#13;
            str.buf     smallDest, 32&#13;
            str.literal dest,   "Initial destination string"&#13;
&#13;
//                             1111111111222222222233333&#13;
//                   01234567890123456789012345678901234&#13;
str.literal source, "Hello there, world! How's it going?"&#13;
&#13;
fmtStr:     .asciz      "source='%s', destination='%s'\n"&#13;
ltFmtStr:   .asciz      "Left ('%s') is less than right ('%s')\n"&#13;
gtFmtStr:   .asciz      "Left ('%s') is greater than right ('%s')\n"&#13;
eqFmtStr:   .asciz      "Left ('%s') is equal to right ('%s')\n"&#13;
&#13;
successStr: .asciz      "substr('%s', %2d, %3d)= '%s'\n"&#13;
failureStr: .asciz      "substr('%s', %2d, %3d) failed\n"&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
&#13;
            .code&#13;
ttlStr:     wastr  "Listing15-1"&#13;
&#13;
// Standard getTitle function&#13;
// Returns pointer to program name in X0&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// prtResult&#13;
//&#13;
// Utility function to print the result of a string&#13;
// comparison:&#13;
&#13;
            proc    prtResult&#13;
&#13;
            mov     x2, x1&#13;
            mov     x1, x0&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_872" aria-label="872"/>            beq     strsEQ&#13;
            bhi     strGT&#13;
&#13;
            // Must be LT at this point.&#13;
&#13;
            lea     x0, ltFmtStr&#13;
            b       printf&#13;
&#13;
strsEQ:     lea     x0, eqFmtStr&#13;
            b       printf&#13;
&#13;
strGT:      lea     x0, gtFmtStr&#13;
            b       printf&#13;
&#13;
            endp    prtResult&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
//&#13;
// testSubstr&#13;
//&#13;
// Utility function to test call to str.substr&#13;
//&#13;
// On entry:&#13;
// X0, X1, X2, X3 -- str.substr parameters&#13;
&#13;
            proc    testSubstr&#13;
&#13;
            locals  testSS&#13;
            byte    testSS.stkspace, 64&#13;
            endl    testSS&#13;
&#13;
            enter   testSS.size&#13;
&#13;
            lea     x5, successStr&#13;
            bl      str.substr&#13;
            bcc     success&#13;
            lea     x5, failureStr&#13;
&#13;
success:&#13;
            mov     x4, x3&#13;
            mov     x3, x2&#13;
            mov     x2, x1&#13;
            mov     x1, x0&#13;
            mov     x0, x5&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            mstr    x3, [sp, #16]&#13;
            mstr    x4, [sp, #24]&#13;
            bl      printf&#13;
            leave&#13;
            endp    testSubstr&#13;
&#13;
///////////////////////////////////////////////////////////&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_873" aria-label="873"/>//&#13;
// Main program to test the code:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  lcl&#13;
            byte    stkSpace, 64&#13;
            endl    lcl&#13;
&#13;
            enter   lcl.size      // Reserve space for locals.&#13;
&#13;
            lea     x0, src&#13;
            lea     x1, destination&#13;
            bl      str.cpy&#13;
&#13;
            mov     x2, x1&#13;
            mov     x1, x0&#13;
            lea     x0, fmtStr&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right1&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right2&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, left&#13;
            lea     x1, right3&#13;
            bl      str.cmp&#13;
            bl      prtResult&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #0&#13;
            mov     x2, #11&#13;
            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #20&#13;
            mov     x2, #15&#13;
            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #20&#13;
            mov     x2, #20&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_874" aria-label="874"/>            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #40&#13;
            mov     x2, #20&#13;
            lea     x3, dest&#13;
            bl      testSubstr&#13;
&#13;
            lea     x0, source&#13;
            mov     x1, #0&#13;
            mov     x2, #100&#13;
            lea     x3, smallDest&#13;
            bl      testSubstr&#13;
&#13;
AllDone:    leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">If you try to build this program with the following command</p>&#13;
<pre id="pre-1169"><code><span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing15-1</span></code></pre>&#13;
<p class="Continued1">the system will complain that it cannot locate the symbols <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr</span> in the object files provided. Unfortunately, the <i>build</i> shell script doesn’t support linking in multiple object modules (other than the <i>c.cpp</i> and the specified file’s object files). Therefore, you must specify an explicit <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command to process all the files:</p>&#13;
<pre id="pre-1170"><code><span class="SANS_TheSansMonoCd_W7Bold_11">g++ -DisMacOS c.cpp Listing15-1.S str.cpy.o str.cmp.o str.substr.o -o Listing15-1</span></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-DisMacOS</span> command line argument should be changed to <span class="SANS_TheSansMonoCd_W5Regular_11">-DisLinux</span> when compiling the code under Linux or Pi OS (rather than macOS). As you may recall from section 1.10.1, <span class="Xref">“Assembling Programs Under Multiple OSes,”</span> on <span class="Xref"><a href="chapter1.xhtml#pg_36">page 36</a></span>, the <i>build</i> shell script determines the OS and emits a <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command line define (the <span class="SANS_TheSansMonoCd_W5Regular_11">-D</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">xxxx</span> option) to make the OS known to the assembly source file (and, especially, the <i>aoaa.inc</i> header file). As this <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command will attempt to assemble the <i>Listing15-1.S</i> source file (which includes <i>aoaa.inc</i>), the command line must include a definition of either <span class="SANS_TheSansMonoCd_W5Regular_11">isMacOS</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">isLinux</span>, or the assembly will fail.</p>&#13;
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command will compile <i>c.cpp</i>, assemble <i>Listing15-1.S</i>, and link their object files together with the <i>str.cpy.o</i>, <i>str.cmp.o</i>, and <i>str.substr.o</i> object files. This assumes, of course, that you’ve already assembled the <i>str.*.S</i> source files and that their object files are sitting in the current directory. The sample program in Listing 15-1 does not call the <span class="SANS_TheSansMonoCd_W5Regular_11">str.alloc</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.free</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">str.bufInit</span> functions, so there was no need to link in their respective object code files, though doing so would not have generated an error.</p>&#13;
<p class="TX">Here’s the full set of commands needed to build all these files and generate and run the Listing 15-1 executable:</p>&#13;
<pre id="pre-1171"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_875" aria-label="875"/>% <span class="SANS_TheSansMonoCd_W7Bold_11">g++ -c -DisMacOS str.cpy.S</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">g++ -c -DisMacOS str.cmp.S</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">g++ -c -DisMacOS str.substr.S</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">g++ -DisMacOS c.cpp Listing15-1.S str.cpy.o str.cmp.o str.substr.o -o Listing15-1</span>&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing15-1</span>&#13;
Calling Listing15-1:&#13;
source='String to copy', destination='String to copy'&#13;
Left ('some string') is equal to right ('some string')&#13;
Left ('some string') is less than right ('some string.')&#13;
Left ('some string') is greater than right ('some string')&#13;
substr('Hello there, world! How's it going?',  0,  11)= 'Hello there'&#13;
substr('Hello there, world! How's it going?', 20,  15)= 'How's it going?'&#13;
substr('Hello there, world! How's it going?', 20,  20)= 'How's it going?'&#13;
substr('Hello there, world! How's it going?', 40,  20)= ''&#13;
substr('Hello there, world! How's it going?',  0, 100) failed&#13;
listing15-1 terminated</code></pre>&#13;
<p class="TX">Granted, that’s a lot of typing in order to compile and link a simple source file. You could remedy this by putting all the commands into a text file and executing them as a shell script (similar to the <i>build</i> script), but there’s a better way: makefiles.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-155"/><span class="SANS_Futura_Std_Bold_B_11">15.5 Introducing Makefiles</span></h3>&#13;
<p class="TNI1">The <i>build</i> file used throughout this book has been far more convenient than the manual commands needed to build the example of the previous section. Unfortunately, the build mechanism that <i>build</i> supports is good for only a few fixed source files. While you could easily construct a shell script to compile all the files in a large assembly project, it would largely defeat the purpose of using separate assembly, as running the script file would reassemble every source file in the project. Although you can use complex command line functions to avoid some of this, it’s easier to use makefiles.</p>&#13;
<p class="TX">A <i>makefile</i> is a script in a language (designed in early releases of Unix) that specifies how to execute a series of commands based on certain conditions. In its simplest form, a makefile can behave exactly like a shell script; you can list a sequence of commands in a text file and have the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> program execute them. Of course, there would be no benefit over using a shell script if you did this; you should take advantage of <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>’s features if you’re going to use makefiles.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> program is an executable, just like Gas (as) or GCC. As <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> is not a part of the Linux or macOS system, you must obtain a <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> program before you can use it. Fortunately, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> comes preinstalled on most Linux and macOS distributions (if you can run GCC, you can certainly run <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>). Execute it from a command line as follows:</p>&#13;
<pre id="pre-1172"><code>make <var>optionalArguments</var></code></pre>&#13;
<p class="TX">If you execute <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> on a command line without any arguments, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will search for a file named <i>Makefile</i> and attempt to process the commands <span role="doc-pagebreak" epub:type="pagebreak" id="pg_876" aria-label="876"/>in that file. For many projects, this is very convenient. If you put all your source files in a single directory (potentially with subdirectories) along with a single makefile (named <i>Makefile</i>), you can then change into that directory and execute <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>, building the project with minimal fuss.</p>&#13;
<p class="TX">If you like, you can use a different filename than <i>Makefile</i>. Rather than simply placing the filename after <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> on the command line, however, you must preface the filename with the <span class="SANS_TheSansMonoCd_W5Regular_11">make -f</span> option as follows:</p>&#13;
<pre id="pre-1173"><code>make -f mymake.mak</code></pre>&#13;
<p class="TX">You don’t need to give your filename the <i>.mak</i> extension, but this is a popular convention when using makefiles with custom names.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> program provides many command line options, and you can list common ones by using <span class="SANS_TheSansMonoCd_W5Regular_11">--help</span>. You can look up <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> documentation online (or type <span class="SANS_TheSansMonoCd_W5Regular_11">man make</span> from the command line) for a description of the other command line options, but most of them are advanced and unnecessary for most tasks.</p>&#13;
<p class="TX">Of course, to make practical use of <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>, you need to create makefiles. The following subsections describe the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> scripting language and some common conventions for makefiles.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-266"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">15.5.1 Basic Makefile Syntax</span></h4>&#13;
<p class="TNI1">A makefile is a standard ASCII text file containing a sequence of lines (or a set of multiple occurrences of this sequence) as follows:</p>&#13;
<pre id="pre-1174"><code><var>target</var>: <var>dependencies</var>&#13;
    <var>commands</var></code></pre>&#13;
<p class="TX">All components of this code—<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">target</span>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dependencies</span>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">commands</span>—are optional. The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">target</span> item is an identifier or filename of some sort that, if present, must begin in column 1 of its source line. The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dependencies</span> item is a list of filenames on which the target depends in order to be built properly. The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">commands</span> item is a list of one or more command line commands, which must have at least one tab character in front of them.</p>&#13;
<p class="TX">Consider the following makefile, which builds a set of string library functions (note that a tab appears before each <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command):</p>&#13;
<pre id="pre-1175"><code>all:&#13;
    g++ -c -DisMacOS str.cpy.S&#13;
    g++ -c -DisMacOS str.cmp.S&#13;
    g++ -c -DisMacOS str.substr.S&#13;
    g++ -DisMacOS c.cpp Listing15-1.S str.cpy.o str.cmp.o \&#13;
         str.substr.o -o Listing15-1</code></pre>&#13;
<p class="TX">If these commands appear in a file named <i>Makefile</i> and you execute <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>, they will execute exactly as the command line interpreter would have executed them, had they appeared in a shell script.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_877" aria-label="877"/>Consider the following modification of the previous makefile:</p>&#13;
<pre id="pre-1176"><code>executable:&#13;
  g++ -c -DisMacOS Listing15-1.S&#13;
  g++ -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1&#13;
&#13;
library:&#13;
  g++ -c -DisMacOS str.cpy.S&#13;
  g++ -c -DisMacOS str.cmp.S&#13;
  g++ -c -DisMacOS str.substr.S</code></pre>&#13;
<p class="TX">This separates the build commands into two groups: one specified by the <span class="SANS_TheSansMonoCd_W5Regular_11">executable</span> label and another specified by the <span class="SANS_TheSansMonoCd_W5Regular_11">library</span> label.</p>&#13;
<p class="TX">If you run <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> without any command line options, it will execute only the commands appearing after the first target in the file. Therefore, in this example, if you run <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> by itself, it will assemble <i>Listing15-1.S</i>, compile <i>c.cpp</i>, and attempt to link (the resulting) <i>c.obj</i> with <i>str.cpy.o</i>, <i>str.cmp.o</i>, <i>str.substr.o</i>, and <i>Listing15-1.o</i>. Assuming you had previously compiled the string functions, this should successfully produce the <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> executable (without having to recompile the string functions).</p>&#13;
<p class="TX">To convince <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> to process the commands after the library target, you must specify the target name as a <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> command line argument:</p>&#13;
<pre id="pre-1177"><code>make library</code></pre>&#13;
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> command compiles <i>str.cpy.S</i>, <i>str.cmp.S</i>, and <i>str.substr.S</i>. If you execute this command once (and never change the string functions thereafter), you need only execute the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> command by itself to generate the executable file. You can also use <span class="SANS_TheSansMonoCd_W5Regular_11">make executable</span> if you want to explicitly state that you are building the executable.</p>&#13;
<p class="TX">The ability to specify which targets you want to build on the command line is useful. However, as your projects get larger, with many source files and library modules, keeping track of which source files you need to recompile all the time can be burdensome and error-prone. If you’re not careful, you’ll forget to compile an obscure library module after you’ve made changes to it and wonder why the application is still failing. The <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> dependencies option helps you avoid these problems by allowing you to automate the build process.</p>&#13;
<p class="TX">A list of one or more whitespace-separated dependencies can follow a target in a makefile:</p>&#13;
<pre id="pre-1178"><code>target: <var>dependency1</var> <var>dependency2</var> <var>dependency3</var> ...</code></pre>&#13;
<p class="TX">Dependencies are either target names (of targets appearing in that makefile) or filenames. If a dependency is a target name (that is not also a filename), <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will go execute the commands associated with that target. Consider the following makefile (if compiling under Linux or Pi OS, be <span role="doc-pagebreak" epub:type="pagebreak" id="pg_878" aria-label="878"/>sure to change the <span class="SANS_TheSansMonoCd_W5Regular_11">-DisMacOS</span> command line option to <span class="SANS_TheSansMonoCd_W5Regular_11">-DisLinux</span> in this example and all that follow):</p>&#13;
<pre id="pre-1179"><code>executable:&#13;
  g++-c -DisMacOS Listing15-1.S&#13;
  g++-DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1&#13;
&#13;
library:&#13;
  g++ -c -DisMacOS str.cpy.S&#13;
  g++-c -DisMacOS str.cmp.S&#13;
  g++-c -DisMacOS str.substr.S&#13;
&#13;
all: library executable</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">all</span> target in this code does not have any commands associated with it. Instead, the <span class="SANS_TheSansMonoCd_W5Regular_11">all</span> target depends on the <span class="SANS_TheSansMonoCd_W5Regular_11">library</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">executable</span> targets, so it will go execute the commands associated with those targets, beginning with <span class="SANS_TheSansMonoCd_W5Regular_11">library</span>. This is because the <span class="SANS_TheSansMonoCd_W5Regular_11">library</span> object files must be built before the associated object modules can be linked into the executable program). The <span class="SANS_TheSansMonoCd_W5Regular_11">all</span> identifier is a common target in makefiles. Indeed, it is often the first or second target to appear in a makefile.</p>&#13;
<p class="TX">If a <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">target</span><span class="SANS_TheSansMonoCd_W5Regular_11">:</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dependencies</span> line becomes too long to be readable (<span class="SANS_TheSansMonoCd_W5Regular_11">make</span> doesn’t care much about line length), you can break the line into multiple lines by putting a backslash character (<span class="SANS_TheSansMonoCd_W5Regular_11">\</span>) as the last character on a line. The <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> program will combine source lines that end with a backslash with the next line in the makefile. The backslash must be the very last character on the line; whitespace characters (tabs and spaces) are not allowed to follow the backslash.</p>&#13;
<p class="TX">Target names and dependencies can also be filenames. Specifying a filename as a target name is generally done to tell the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> system how to build that particular file. For example, you could rewrite the current example as follows:</p>&#13;
<pre id="pre-1180"><code>executable:&#13;
  g++ -c -DisMacOS Listing15-1.1&#13;
  g++ -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1&#13;
&#13;
library: str.cpy.o str.cmp.o str.substr.o&#13;
&#13;
str.cpy.o:&#13;
  g++ -c -DisMacOS str.cpy.S&#13;
&#13;
str.cmp.o:&#13;
  g++ -c -DisMacOS str.cmp.S&#13;
&#13;
str.substr.o:&#13;
  g++ -c -DisMacOS str.substr.S&#13;
&#13;
all: library executable</code></pre>&#13;
<p class="TX">When dependencies are associated with a target that is a filename, you can read the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">target</span><span class="SANS_TheSansMonoCd_W5Regular_11">:</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dependencies</span> statement as “<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">target</span> depends on <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dependencies</span>.” <span role="doc-pagebreak" epub:type="pagebreak" id="pg_879" aria-label="879"/>When processing a command, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> compares the modification date/timestamp of the files specified as target and dependency filenames.</p>&#13;
<p class="TX">If the date/time of the target is older than <i>any</i> of the dependencies (or the target file doesn’t exist), <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will execute the commands after the target. If the target file’s modification date/time is later (newer) than <i>all</i> of the dependent files, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will not execute the commands. If one of the dependencies after a target is itself a target elsewhere, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will first execute that command (to see if it modifies the target object, changing its modification date/time, and possibly causing <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> to execute the current target’s commands). If a target or dependency is just a label (not a filename), <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will treat its modification date/time as older than any file.</p>&#13;
<p class="TX">Consider the following modification to the running makefile example:</p>&#13;
<pre id="pre-1181"><code>Listing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o&#13;
  gcc -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1&#13;
&#13;
Listing15-1.o:&#13;
  g++ -c -DisMacOS Listing15-1.S&#13;
&#13;
str.cpy.o:&#13;
  g++ -c -DisMacOS str.cpy.S&#13;
&#13;
str.cmp.o:&#13;
  g++ -c -DisMacOS str.cmp.S&#13;
&#13;
str.substr.o:&#13;
  g++ -c -DisMacOS str.substr.S</code></pre>&#13;
<p class="TX">This code has removed <span class="SANS_TheSansMonoCd_W5Regular_11">all</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">library</span> targets, as they turn out to be unnecessary, and changed <span class="SANS_TheSansMonoCd_W5Regular_11">executable</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span>, the final target executable file.</p>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy.o</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp.o</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr.o</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1.o</span> are all targets (as well as filenames), <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will first go process those targets. After that, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will compare the modification date/time of <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> against that of the four object files. If <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> is older than any of those object files, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will execute the command following the <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> target line (to compile <i>c.cpp</i> and link it with the object files). If <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> is newer than its dependent object files, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will not execute the command.</p>&#13;
<p class="TX">The same process happens, recursively, for each of the dependent object files following the <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> target. While processing the <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> target, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> will also process the <span class="SANS_TheSansMonoCd_W5Regular_11">str.cpy.o</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.cmp.o</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str.substr.o</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1.o</span> targets (in that order). In each case, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> compares the modification date/time of the <i>.o</i> file with the corresponding <i>.S</i> file. If the <i>.o</i> file is newer than the <i>.S</i> file, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> returns to processing the <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> target without doing anything; if the <i>.o</i> file is older than the <i>.S</i> file (or doesn’t exist), <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> executes the corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">g++</span> command to generate a new <i>.o</i> file.</p>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> is newer than all the <i>.o</i> files (and they are all newer than the <i>.S</i> files), then executing <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> simply reports that <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> is up-to-date, but it will not execute any of the commands in the makefile. If any of the files are out-of-date (because they’ve been modified), this makefile will compile and link only the files necessary to bring <span class="SANS_TheSansMonoCd_W5Regular_11">Listing15-1</span> up-to-date.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_880" aria-label="880"/>The makefiles have a pretty serious defect thus far: they are missing an important dependency. Since all the <i>.S</i> files include the <i>aoaa.inc</i> file, a change to <i>aoaa.inc</i> could possibly require a recompilation of these <i>.S</i> files. Listing 15-2 adds this dependency to the <i>Listing15-2.mak</i> makefile, and it also demonstrates how to include comments in a makefile by using the <span class="SANS_TheSansMonoCd_W5Regular_11">#</span> character at the beginning of a line.</p>&#13;
<pre id="pre-1182"><code># Listing15-2.mak&#13;
#&#13;
# makefile for Listing15-1&#13;
&#13;
Listing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o&#13;
  gcc -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1&#13;
&#13;
Listing15-1.o:aoaa.inc Listing15-1.S&#13;
  gcc -c -DisMacOS Listing15-1.S&#13;
&#13;
str.cpy.o:aoaa.inc str.cpy.S&#13;
  gcc -c -DisMacOS str.cpy.S&#13;
&#13;
str.cmp.o:aoaa.inc str.cmp.S&#13;
  gcc -c -DisMacOS str.cmp.S&#13;
&#13;
str.substr.o:aoaa.inc str.substr.S&#13;
  gcc -c -DisMacOS str.substr.S</code></pre>&#13;
<p class="TX">Here’s an example of executing <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> (under macOS):</p>&#13;
<pre id="pre-1183"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">make -f Listing15-2.mak</span>&#13;
gcc -c -DisMacOS Listing15-1.S&#13;
gcc -c -DisMacOS str.cpy.S&#13;
gcc -c -DisMacOS str.cmp.S&#13;
gcc -c -DisMacOS str.substr.S&#13;
gcc -DisMacOS c.cpp Listing15-1.o str.cpy.o str.cmp.o str.substr.o -o Listing15-1</code></pre>&#13;
<p class="TX">To execute this command under Linux or Pi OS, don’t forget to change all the <span class="SANS_TheSansMonoCd_W5Regular_11">-DisMacOS</span> command line options to <span class="SANS_TheSansMonoCd_W5Regular_11">-DisLinux</span> in the makefile and make sure all commands have a tab in column 1. If you want to be able to automatically compile the code for any OS, simply steal the code from the <i>build</i> script that sets up a shell variable with the appropriate command line option, as shown in Listing 15-3.</p>&#13;
<pre id="pre-1184"><code># Listing15-3.mak&#13;
#&#13;
# makefile for Listing15-1 with dependencies that will&#13;
# automatically set up the define for the OS&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> unamestr=`uname`&#13;
&#13;
Listing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o&#13;
    gcc -D$(unamestr) c.cpp Listing15-1.o str.cpy.o str.cmp.o \&#13;
        str.substr.o -o Listing15-1&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_881" aria-label="881"/>Listing15-1.o:aoaa.inc Listing15-1.S&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> gcc -c -D$(unamestr) Listing15-1.S&#13;
&#13;
str.cpy.o:aoaa.inc str.cpy.S&#13;
    gcc -c -D$(unamestr) str.cpy.S&#13;
&#13;
str.cmp.o:aoaa.inc str.cmp.S&#13;
    gcc -c -D$(unamestr) str.cmp.S&#13;
&#13;
str.substr.o:aoaa.inc str.substr.S&#13;
    gcc -c -D$(unamestr) str.substr.S</code></pre>&#13;
<p class="TX">The first statement <span class="CodeAnnotation" aria-label="annotation1">❶</span> is an example of a makefile <i>macro</i> (or <i>variable</i>). The OS command <span class="SANS_TheSansMonoCd_W5Regular_11">uname</span> will display the OS (kernel) name. Under Linux systems, this will be replaced by the string <span class="SANS_TheSansMonoCd_W5Regular_11">Linux</span>, and on macOS systems by the string <span class="SANS_TheSansMonoCd_W5Regular_11">Darwin</span> (the internal name of the macOS kernel).</p>&#13;
<p class="TX">Makefile macros use deferred execution. This means that the macro <span class="SANS_TheSansMonoCd_W5Regular_11">unamestr</span> actually contains the text <span class="SANS_TheSansMonoCd_W5Regular_11">`uname`</span> and that the <span class="SANS_TheSansMonoCd_W5Regular_11">uname</span> command will execute in place when the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> program expands the <span class="SANS_TheSansMonoCd_W5Regular_11">unamestr</span> macro. The <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> program will expand the <span class="SANS_TheSansMonoCd_W5Regular_11">-D$(unamestr)</span> command line option, producing <span class="SANS_TheSansMonoCd_W5Regular_11">-D`uname`</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The backticks (<span class="SANS_TheSansMonoCd_W5Regular_11">`</span>) tell <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> to execute the command and replace it with the text printed by the command: the OS kernel name.</p>&#13;
<p class="TX">The only issue is that the <span class="SANS_TheSansMonoCd_W5Regular_11">uname</span> command prints Linux or Darwin, so the <span class="SANS_TheSansMonoCd_W5Regular_11">-D</span> command defines one of these two symbols. The <i>build</i> script translates these strings to <span class="SANS_TheSansMonoCd_W5Regular_11">isMacOS</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">isLinux</span>. I originally did this because the symbol <span class="SANS_TheSansMonoCd_W5Regular_11">Linux</span> would likely appear in a Linux-based assembly language program. Unfortunately, the symbol translation trick didn’t work out in a makefile, so I modified <i>aoaa.inc</i> to accept <span class="SANS_TheSansMonoCd_W5Regular_11">Linux</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Darwin</span> as well as <span class="SANS_TheSansMonoCd_W5Regular_11">inLinux</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">inMacOS</span>. I modified <i>aoaa.inc</i> to do the translation and undefine Linux or Darwin, should those symbols get used:</p>&#13;
<pre id="pre-1185"><code>// Makefiles define the symbols Darwin (for macOS)&#13;
// and Linux (for Linux) rather than isMacOS and&#13;
// isLinux. Deal with that here:&#13;
&#13;
#ifdef Darwin&#13;
    #define isMacOS (1)&#13;
    #undef isLinux&#13;
    #undef Darwin&#13;
#endif&#13;
#ifdef Linux&#13;
    #define isLinux (1)&#13;
    #undef isMacOS&#13;
    #undef Linux&#13;
#endif</code></pre>&#13;
<p class="TX">Here’s the execution of the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> command to build the code for Listing 15-3 (assuming no object files were already created):</p>&#13;
<pre id="pre-1186"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">make -f Listing15-3.mak</span>&#13;
g++ -c -D`uname` Listing15-1.S&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_882" aria-label="882"/>g++ -c -D`uname` str.cpy.S&#13;
g++ -c -D`uname` str.cmp.S&#13;
g++ -c -D`uname` str.substr.S&#13;
g++ -D`uname` c.cpp Listing15-1.o str.cpy.o str.cmp.o \&#13;
    str.substr.o -o Listing15-1</code></pre>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_11">-D`uname`</span> is translated to either <span class="SANS_TheSansMonoCd_W5Regular_11">-DLinux</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">-DDarwin</span>, depending on the OS.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-267"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">15.5.2 Make Clean and Touch</span></h4>&#13;
<p class="TNI1">One common target you will find in most professionally made makefiles is <span class="SANS_TheSansMonoCd_W5Regular_11">clean</span>, which deletes an appropriate set of files to force the entire system to be remade the next time you execute the makefile. This command typically deletes all the <i>.o</i> and executable files associated with the project.</p>&#13;
<p class="TX">Listing 15-4 provides an example <span class="SANS_TheSansMonoCd_W5Regular_11">clean</span> target for the makefile appearing in Listing 15-3.</p>&#13;
<pre id="pre-1187"><code># Listing15-4.mak&#13;
#&#13;
# makefile for listing15-1 with dependencies that will&#13;
# automatically set up the define for the OS&#13;
#&#13;
# Demonstrates the clean target&#13;
&#13;
unamestr=`uname`&#13;
&#13;
Listing15-1:Listing15-1.o str.cpy.o str.cmp.o str.substr.o&#13;
    gcc -D$(unamestr) c.cpp listing15-1.o str.cpy.o str.cmp.o \&#13;
        str.substr.o -o Listing15-1&#13;
&#13;
Listing15-1.o:aoaa.inc Listing15-1.S&#13;
    gcc -c -D$(unamestr) Listing15-1.S&#13;
str.cpy.o:aoaa.inc str.cpy.S&#13;
    gcc -c -D$(unamestr) str.cpy.S&#13;
&#13;
str.cmp.o:aoaa.inc str.cmp.S&#13;
    gcc -c -D$(unamestr) str.cmp.S&#13;
&#13;
str.substr.o:aoaa.inc str.substr.S&#13;
    gcc -c -D$(unamestr) str.substr.S&#13;
clean:&#13;
    rm str.cpy.o&#13;
    rm str.cmp.o&#13;
    rm str.substr.o&#13;
    rm Listing15-1.o&#13;
    rm c.o&#13;
    rm Listing15-1</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_883" aria-label="883"/>Issuing the command</p>&#13;
<pre id="pre-1188"><code><span class="SANS_TheSansMonoCd_W7Bold_11">% make -f Listing15-4.mak clean</span></code></pre>&#13;
<p class="Continued1">will delete all the executable and object code files associated with the project.</p>&#13;
<p class="TX">To force the recompilation of a single file (without manually editing and modifying it), you can use the Unix utility <span class="SANS_TheSansMonoCd_W5Regular_11">touch</span>. This program accepts a filename as its argument and updates the modification date/time of the file (without otherwise modifying the file). For example, after building <i>Listing15-1.S</i> using the makefile in Listing 15-4, were you to execute the command</p>&#13;
<pre id="pre-1189"><code>touch Listing15-1.S</code></pre>&#13;
<p class="Continued1">and then re-execute the makefile in Listing 15-4, <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> would reassemble the code in <i>Listing15-1.S</i>, recompile <i>c.cpp</i>, and produce a new executable.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-156"/><span class="SANS_Futura_Std_Bold_B_11">15.6 Generating Library Files with the Archiver Program</span></h3>&#13;
<p class="TNI1">Many common projects reuse code the developers created long ago, or code from a source outside the developer’s organization. These libraries of code are relatively <i>static</i>: they rarely change during the development of a project that uses them. In particular, you would not usually incorporate the building of the libraries into a given project’s makefile. A specific project might list the library files as dependencies in the makefile, but the assumption is that the library files are built elsewhere and supplied as a whole to the project.</p>&#13;
<p class="TX">Beyond that, there is one major difference between a library and a set of object code files: packaging. Dealing with a myriad of separate object files becomes troublesome when you’re working with large sets of library object files. A library may contain tens, hundreds, or even thousands of object files. Listing all these object files (or even just the ones a project uses) is a lot of work and can lead to consistency errors.</p>&#13;
<p class="TX">The common way to deal with this problem is to combine object files into a separate package (file) known as a <i>library file</i>. Under Linux and macOS, library files typically have a <i>.a</i> suffix (where <i>a</i> stands for <i>archive</i>). For many projects, you will be given a library file that packages together a specific library module. You supply this file to the linker when building your program, and the linker automatically picks out the object modules it needs from the library. This is an important point: including a library while building an executable does not automatically insert all the code from that library into the executable. The linker is smart enough to extract only the object files it needs and to ignore the object files it doesn’t use (remember, a library is just a package containing a bunch of object files).</p>&#13;
<p class="TX">How do you create a library file? The short answer is, “By using the archiver program (<span class="SANS_TheSansMonoCd_W5Regular_11">ar</span>).” Here is its basic syntax</p>&#13;
<pre id="pre-1190"><code>ar rcs <var>libname.a</var> <var>list-of-.o-files</var></code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_884" aria-label="884"/>where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">libname.a</span> is the name of the library file you want to produce and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">list-of-.o-files</span> is a (space-separated) list of object filenames you want to collect together into the library. For example, here’s the command to combine the <i>print.o</i> and <i>getTitle.o</i> files into a library module (<i>aoaalib.a</i>):</p>&#13;
<pre id="pre-1191"><code>ar rcs aoaalib.a getTitle.o print.o</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">rcs</span> component is actually a series of three command options. The <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> option tells the command to replace existing (if present) object files in the archive; <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> says to create the archive (you generally don’t specify this option if you are adding object files to an existing archive file); and <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> says to add an index to the archive file, or update the index if it already exists. (For more <span class="SANS_TheSansMonoCd_W5Regular_11">ar</span> command line options, see section 15.9, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter15.xhtml#pg_887">page 887</a></span>.)</p>&#13;
<p class="TX">Once you have a library module, you can specify it on a linker (or <span class="SANS_TheSansMonoCd_W5Regular_11">ld</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">gcc</span>) command line just as you would an object file. For example, if you build a <i>strings.a</i> library module to hold the <i>str.cpy.o</i>, <i>str.cmp.o</i>, <i>str.substr.o</i>, <i>str.bufInit.o</i>, <i>str.free.o</i>, and <i>str.alloc.o</i> object files, and you want to link <i>strings.a</i> with the program in Listing 15-1, you could use the following command:</p>&#13;
<pre id="pre-1192"><code>g++ -DisMacOS c.cpp Listing15-1.S strings.a -o Listing15-1</code></pre>&#13;
<p class="TX">Listing 15-5 is an example of a makefile that will build the <i>strings.a</i> library file.</p>&#13;
<pre id="pre-1193"><code># Listing15-5.mak&#13;
#&#13;
# makefile to build the string.a library file&#13;
&#13;
unamestr=`uname`&#13;
&#13;
strings.a:str.cpy.o str.cmp.o str.substr.o str.bufInit.o \&#13;
            str.alloc.o str.free.o&#13;
    ar rcs strings.a str.cpy.o str.cmp.o str.substr.o \&#13;
        str.bufInit.o str.alloc.o str.free.o&#13;
&#13;
str.cpy.o:aoaa.inc str.cpy.S&#13;
    g++ -c -D$(unamestr) str.cpy.S&#13;
&#13;
str.cmp.o:aoaa.inc str.cmp.S&#13;
    g++ -c -D$(unamestr) str.cmp.S&#13;
&#13;
str.substr.o:aoaa.inc str.substr.S&#13;
    g++ -c -D$(unamestr) str.substr.S&#13;
&#13;
str.bufInit.o:aoaa.inc str.bufInit.S&#13;
    g++ -c -D$(unamestr) str.bufInit.S&#13;
&#13;
str.free.o:aoaa.inc str.free.S&#13;
    g++ -c -D$(unamestr) str.free.S&#13;
&#13;
str.alloc.o:aoaa.inc str.alloc.S&#13;
    g++ -c -D$(unamestr) str.alloc.S&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_885" aria-label="885"/>&#13;
clean:&#13;
    rm -f strings.a&#13;
    rm -f str.cpy.o&#13;
    rm -f str.cmp.o&#13;
    rm -f str.substr.o&#13;
    rm -f str.bufInit.o&#13;
    rm -f str.alloc.o&#13;
    rm -f str.free.o</code></pre>&#13;
<p class="TX">Listing 15-6 modifies the Listing 15-5 makefile that builds the code by using the <i>strings.a</i> library module.</p>&#13;
<pre id="pre-1194"><code># Listing15-6.mak&#13;
#&#13;
# makefile that uses the string.a library file&#13;
&#13;
unamestr=`uname`&#13;
&#13;
Listing15-1:Listing15-1.o strings.a&#13;
    g++ -D$(unamestr) c.cpp Listing15-1.o strings.a -o Listing15-1&#13;
&#13;
Listing15-1.o:aoaa.inc Listing15-1.S&#13;
    g++ -c -D$(unamestr) Listing15-1.S&#13;
&#13;
lib:&#13;
    rm -f strings.a&#13;
    rm -f str.*.o&#13;
    make -f Listing15-5.mak&#13;
&#13;
clean:&#13;
    rm -f Listing15-1&#13;
    rm -f c.o&#13;
    rm -f Listing15-1.o</code></pre>&#13;
<p class="TX">Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">clean</span> command does not delete the library files. If you want a clean library build, just specify the <span class="SANS_TheSansMonoCd_W5Regular_11">lib</span> command line option when running <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>:</p>&#13;
<pre id="pre-1195"><code>make -f Listing15-6.mak lib</code></pre>&#13;
<p class="TX">As a general rule, you build the library code independently of the application code. Most of the time, the library is prebuilt, and you don’t have to rebuild it. However, <i>strings.a</i> must be a dependency of the application, because if the library changes, you’ll probably need to rebuild the application as well.</p>&#13;
<p class="TX">One more Unix utility is useful for processing library files: <span class="SANS_TheSansMonoCd_W5Regular_11">nm</span> (names). The <span class="SANS_TheSansMonoCd_W5Regular_11">nm</span> utility will list all the global names found in a library module. For example, the command</p>&#13;
<pre id="pre-1196"><code>nm strings.a</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_886" aria-label="886"/>lists all the (global) symbols found in the <i>strings.a</i> library file (it’s rather long, so I won’t provide the printout here).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-157"/><span class="SANS_Futura_Std_Bold_B_11">15.7 Managing the Impact of Object Files on Program Size</span></h3>&#13;
<p class="TNI1">The basic unit of linkage in a program is the object file. When combining object files to form an executable, the linker will take all the data from a single object file and merge it into the final executable. This is true even if the main program doesn’t call all the functions (directly or indirectly) in the object module or use all the data in that object file. If you put 100 routines in a single assembly language source file and compile them into an object module, the linker will therefore include the code for all 100 routines in your final executable, even if you use only one of them.</p>&#13;
<p class="TX">To avoid this situation, you can break those 100 routines into 100 separate object modules and combine the resulting 100 object files into a single library. When the linker processes that library file, it will pick out the single object file containing the function the program uses and incorporate only that file into the final executable.</p>&#13;
<p class="TX">Generally, this is far more efficient than linking in a single object file with 100 functions buried in it. However, in some cases, there are good reasons to combine multiple functions into a single object file. First, consider what happens when the linker merges an object file into an executable. To ensure proper alignment, whenever the linker takes a section/segment (for example, the <span class="SANS_TheSansMonoCd_W5Regular_11">.code</span> section) from an object file, it adds sufficient padding so that the data in that section is aligned on that section’s specified alignment boundary. Most sections have a default 16-byte section alignment. This means that the linker will align each section from the object file it links on a 16-byte boundary.</p>&#13;
<p class="TX">Normally, this isn’t much of a problem, especially if your procedures are large. However, if those 100 procedures are all really short (a few bytes each), you wind up wasting a lot of space. Granted, on modern machines, a few hundred bytes of wasted space isn’t a big deal. Still, it might be more practical to combine several of these procedures into a single object module (even if you don’t call all of them) to fill in some of the wasted space. Look for elements that are naturally paired or otherwise used together or have a dependency, such as <span class="SANS_TheSansMonoCd_W5Regular_11">alloc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">free</span>. Don’t go overboard, though. Once you’ve gone beyond the alignment, whether you’re wasting space because of padding or wasting space because you’re including code that never gets called, you’re still wasting space.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-158"/><span class="SANS_Futura_Std_Bold_B_11">15.8 Moving On</span></h3>&#13;
<p class="TNI1">If you write large applications in assembly language, you’ll want to break the source code into various modules and automate building the application from those modules. This chapter began by discussing Gas’s mechanisms for sharing external and public symbols between modules. It then <span role="doc-pagebreak" epub:type="pagebreak" id="pg_887" aria-label="887"/>introduced the <span class="SANS_TheSansMonoCd_W5Regular_11">make</span> application for building applications from multiple source files, then covered how to build library modules by using the linker and archiver applications.</p>&#13;
<p class="TX">One large source of library code is the OS kernel (macOS, Linux, or Pi OS). However, don’t link OS library functions into your applications; that code is already present in memory when your application runs. To call an OS function, you use an OS API invocation sequence. The next chapter discusses how to call OS functions in the Linux (Pi OS) and macOS (Darwin) kernels.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h1-159"/><span class="SANS_Futura_Std_Bold_B_11">15.9 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">For information about makefiles, check out the following websites:&#13;
<ul class="ul">&#13;
<li class="ListBulletSub">Computer Hope: <i><a href="https://www.computerhope.com/unix/umake.htm">https://<wbr/>www<wbr/>.computerhope<wbr/>.com<wbr/>/unix<wbr/>/umake<wbr/>.htm</a></i></li>&#13;
<li class="ListBulletSub">GNU <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>: <i><a href="https://www.gnu.org/software/make/">https://<wbr/>www<wbr/>.gnu<wbr/>.org<wbr/>/software<wbr/>/make<wbr/>/</a></i></li>&#13;
<li class="ListBulletSub">Wikipedia: <i><a href="https://en.wikipedia.org/wiki/Make_(software)">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Make<wbr/>_(software)</a></i></li></ul></li>&#13;
<li class="BL">Also check out the following books on <span class="SANS_TheSansMonoCd_W5Regular_11">make</span>:&#13;
<ul class="ul">&#13;
<li class="ListBulletSub">Robert Mecklenburg, <i>Managing Projects with GNU Make: The Power of GNU Make for Building Anything</i>, 3rd edition (O’Reilly Media, 2004). You can also access this book online at <i><a href="https://www.oreilly.com/openbook/make3/book/index.csp">https://<wbr/>www<wbr/>.oreilly<wbr/>.com<wbr/>/openbook<wbr/>/make3<wbr/>/book<wbr/>/index<wbr/>.csp</a></i>.</li>&#13;
<li class="ListBulletSub">John Graham-Cumming, <i>The GNU Make Book,</i> 1st edition (No Starch Press, 2015)</li>&#13;
<li class="ListBulletSub">Andrew Oram and Steve Talbott, <i>Managing Projects with Make</i> (O’Reilly &amp; Associates, 2004)</li></ul></li>&#13;
<li class="BL">See <i><a href="https://man7.org/linux/man-pages/man1/ar.1.html">https://<wbr/>man7<wbr/>.org<wbr/>/linux<wbr/>/man<wbr/>-pages<wbr/>/man1<wbr/>/ar<wbr/>.1<wbr/>.html</a></i> for a complete list of the <span class="SANS_TheSansMonoCd_W5Regular_11">ar</span> command line options. You can also enter <span class="SANS_TheSansMonoCd_W7Bold_11">ar --help</span> or <span class="SANS_TheSansMonoCd_W7Bold_11">man ar</span> for online help.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-35">&#13;
<p class="BH" id="box-35"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What statement(s) would you use to prevent recursive include files?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  What is an assembly unit?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What directive would you use to tell Gas that a symbol is global and visible outside the current source file?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What directive(s) would you use to tell Gas to use a global symbol from another object module?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  What is the basic makefile syntax?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  What is a makefile-dependent file?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What does a makefile</span> <span class="SANS_TheSansMonoCd_W5Regular_11">clean</span> <span class="SANS_Futura_Std_Book_11">command typically do?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  What is a library file?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>