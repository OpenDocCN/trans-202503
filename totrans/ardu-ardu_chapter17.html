<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch17" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch17">
<span class="CN"><span aria-label=" Page 289. " epub:type="pagebreak" id="pg_289" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ARDUINO-TO-RS232 COMMUNICATION</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">The RS232 data bus is a popular wired method for electronic devices to communicate with one another. It was originally devised in the late 1960s and is still used today in industrial programmable logic controllers (PLCs) and applications that require reliable wired point-to-point data transfer. It’s also often used to interface computers with older devices.</p>
<p class="TX">This chapter shows you how to interface an Arduino with the RS232 bus for data transmission and remote-control applications. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Add an RS232 interface to your Arduino using a board or shield</li>
<li class="BL">Build a PC-to-Arduino remote control that operates via RS232</li>
<li class="BL">Set up communication over RS232 between two Arduino boards</li>
</ul>
<p class="TX">You can use the projects in this chapter as the framework for your own future Arduino-to-RS232 communication needs.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-124"/><span aria-label=" Page 290. " epub:type="pagebreak" id="pg_290" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">The RS232 Bus</samp></h2>
<p class="TNI">The RS232 bus was originally designed to allow connections between data terminals and modems that would then be connected to remote mainframes and minicomputers. The standard evolved over time, with each version being noted by a letter suffix, such as RS232-C. For the purposes of this chapter, I’ll refer to all versions of the standard as RS232.</p>
<p class="TX">Though the RS232 bus is an older technology, there are still many reasons to use it, including interfacing with older hardware and creating long, reliable wired data connections between devices such as your Arduino and a PC. RS232 data lines can stretch up to 15 meters in length before reliability becomes an issue, though you can extend the possible length over 15 meters by reducing the data speed. The examples in this chapter use 9,600 bps, but in your own projects, you can use lower speeds supported by the Arduino if you want.</p>
<p class="TX">RS232 is a serial data bus that operates in a similar manner to the Arduino’s serial port (usually found on pins D0 and D1). The basic RS232 connection has a TX (transmit) and RX (receive) wire, along with a common ground. The full RS232 standard has additional lines used for telephony, controlling data start/stop, and sending status between two devices, but you won’t use these lines in this chapter.</p>
<p class="TX">Although the RS232 bus sends sequential bits of data representing ones and zeros, the signal type is different from the TTL serial used with Arduino. For example, <a href="chapter17.xhtml#fig17-1">Figure 17-1</a> shows data sent from an Arduino’s serial port. You can see that the ones (known as <i>marks</i> in RS232 parlance) are at 5 V, while the zeros (<i>spaces</i>) are at 0 V.</p>
<figure class="IMG"><img alt="AN IMAGE OF TTL LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE" class="img1" id="fig17-1" src="../images/fig17-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-1: Time to live (TTL) logic data from the Arduino serial port</samp></p></figcaption>
</figure>
<p class="TX">Now consider the same piece of data being sent along RS232, as shown in <a href="chapter17.xhtml#fig17-2">Figure 17-2</a>. RS232 requires marks to be a negative voltage and spaces to be a positive voltage.<span aria-label=" Page 291. " epub:type="pagebreak" id="pg_291" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN IMAGE OF RS232 LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE" class="img1" id="fig17-2" src="../images/fig17-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-2: RS232 logic data from an RS232 port</samp></p></figcaption>
</figure>
<p class="TX">Using opposite voltages for marks and spaces clearly defines the 2 bits, avoiding potential confusion and thus increasing data accuracy. For each byte of data sent, RS232 includes a start bit and a stop bit on the ends of each 8 bits of data. (Later in this chapter, I’ll show you how to change the number of bits sent for each transmission.)</p>
<p class="TX">The voltages for a mark can range from 3 V to 15 V DC and for a space between <span class="symbol">−</span>3 V and <span class="symbol">−</span>15 V DC. Though long cables mean greater variation in signal voltage—the longer the cable, the larger the voltage drop, because of the wire’s resistance—the wide voltage range between marks and spaces means the length of the RS232 cable affects signal integrity less. If the surrounding electrical environment is noisy, there is less chance of confusion between a mark and a space.</p>
<p class="TX">The increased voltage required for the RS232 signals is generated by a TTL-to-RS232 serial converter IC, the MAX3232, found on RS232 shields and modules for Arduino. This IC uses a charge-pump circuit to convert the 5 V DC to +/<span class="symbol">−</span>10 V DC or more, but with a reduced current. Therefore, you don’t need a separate dual-rail power supply to use RS232 and the Arduino.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-125"/><samp class="SANS_Futura_Std_Bold_B_11">Connecting to RS232</samp></h2>
<p class="TNI">There are several easy ways to interface your Arduino with an RS232 connection on a device or PC. Whichever interface device you use will have a nine-pin connector for RS232 and a way to electrically connect the onboard MAX3232 IC to the Arduino’s TX/RX serial pins.</p>
<p class="TX">The most convenient interfacing method is to use an RS232 shield for Arduino (PMD Way part 954042), as shown in <a href="chapter17.xhtml#fig17-3">Figure 17-3</a>. The shield has <span aria-label=" Page 292. " epub:type="pagebreak" id="pg_292" role="doc-pagebreak"/>a convenient switch that selects between RS232 use and Arduino-to-PC communication; you turn the switch off when uploading sketches and on when using RS232.</p>
<figure class="IMG"><img alt="A PHOTO OF AN RS232 SHIELD FOR ARDUINO" class="img6" id="fig17-3" src="../images/fig17-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-3: An RS232 shield for Arduino</samp></p></figcaption>
</figure>
<p class="TX">A more compact alternative to the RS232 shield for Arduino, especially useful when making smaller Arduino-based circuits, is the RS232-to-TTL module shown in <a href="chapter17.xhtml#fig17-4">Figure 17-4</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF AN RS232 MODULE FOR ARDUINO" class="img4" id="fig17-4" src="../images/fig17-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-4: An RS232-to-TTL module</samp></p></figcaption>
</figure>
<p class="TX">This module connects to the Arduino using the inline header pins: connect V<sub>CC</sub> and GND to Arduino 5V and GND, module TXD to Arduino RX (D0), and module RXD to Arduino TX (D1). The projects in this chapter use the RS232 shield for Arduino, but you could use the module instead for the same projects.</p>
<p class="TX">For this chapter, you’ll also need an RS232 cable to bridge the Arduino and RS232 hardware with a device or computer. Based on the standard connector on RS232 shields and modules and the standard PC RS232 socket (shown at the top of <a href="chapter17.xhtml#fig17-5">Figure 17-5</a>), you’ll need a double-ended nine-pin female cable.</p>
<figure class="IMG"><img alt="A PHOTO OF AN RS232 SERIAL PORT ON THE REAR OF A DESKTOP COMPUTER" class="img4" id="fig17-5" src="../images/fig17-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-5: The back of a desktop PC showing an RS232 socket</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 293. " epub:type="pagebreak" id="pg_293" role="doc-pagebreak"/>If you’re using a Mac or laptop computer or if your PC doesn’t have an RS232 port, you’ll need a USB-to-RS232 cable such as PMD Way part 514539A, as shown in <a href="chapter17.xhtml#fig17-6">Figure 17-6</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF AN RS232-TO-USB CONVERTER CABLE" class="img6" id="fig17-6" src="../images/fig17-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-6: A USB-to-RS232 cable</samp></p></figcaption>
</figure>
<p class="TX">The RS232 connectors on your PC or Arduino shield are the nine-pin variety with two rows of pins, in either a male or female configuration. When working with old devices with 25-pin connectors, you should be able to buy a converter plug or cable like the one shown in <a href="chapter17.xhtml#fig17-7">Figure 17-7</a> from the supplier of your other RS232 gear.</p>
<figure class="IMG"><img alt="A PHOTO OF A DB9-TO-DB25 CONVERTER CABLE" class="img6" id="fig17-7" src="../images/fig17-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-7: A DB9-to-DB25 serial cable</samp></p></figcaption>
</figure>
<p class="TX">Once you’ve collected the required hardware, you’re ready to set up and test a PC-to-Arduino connection via RS232.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-126"/><span aria-label=" Page 294. " epub:type="pagebreak" id="pg_294" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Testing Arduino-to-PC Connections via USB</samp></h2>
<p class="TNI">To test your Arduino-to-PC connection, upload <a href="#LiT-17-1">Listing 17-1</a> to your Arduino board.</p>
<span id="LiT-17-1"/>

<pre><code>void setup()
{
    Serial.begin(9600);
}

void loop()
{
    Serial.print("Hello ");
    delay(1000);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-1: Testing the Arduino-to-PC connection</samp></p>
<p class="TX">Next, remove the USB cable from the Arduino and then connect the RS232 shield or module as described in the previous section. Reconnect the Arduino to USB or external power and then open your terminal software. As in previous chapters, the projects in this chapter use the free terminal emulator CoolTerm by Roger Meier, which you can download at <a href="http://freeware.the-meiers.org"><i>http://<wbr/>freeware<wbr/>.the<wbr/>-meiers<wbr/>.org</i></a>.</p>
<p class="TX">Once you have opened the terminal software, click <b>Options</b>. You should be presented with a menu of serial port options, as shown in <a href="chapter17.xhtml#fig17-8">Figure 17-8</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE COOLTERM OPTIONS MENU" class="img6" id="fig17-8" src="../images/fig17-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-8: The CoolTerm options menu</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 295. " epub:type="pagebreak" id="pg_295" role="doc-pagebreak"/>Choose your serial port (for example, COM1) from the Port drop-down menu and ensure the rest of the serial port settings match those shown in the figure. Click <b>OK</b> to close the menu and then click <b>Connect</b> to begin data transfer from the Arduino to the PC via RS232. The PC should repeatedly receive the word “Hello” and display it on the terminal window, as shown in <a href="chapter17.xhtml#fig17-9">Figure 17-9</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE RESULTS OF LISTING 17-1 IN THE COOLTERM WINDOW" class="img6" id="fig17-9" src="../images/fig17-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-9: The results of <a href="#LiT-17-1">Listing 17-1</a> in the CoolTerm window</samp></p></figcaption>
</figure>
<p class="TX">You can use this simple setup to capture data from your Arduino over a longer distance than is possible using USB cables. In CoolTerm, press <small>CTRL</small>-R to start recording any output received to a text file, and press <small>CTRL</small>-<small>SHIFT</small>-R to stop recording.</p>
<p class="TX">Keep your hardware connected; you’ll use it in the following project to make a PC-to-Arduino remote control over RS232.</p>
<p class="HeadProject"><span id="h1-127"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #49: Creating a PC-to-Arduino Remote Control</samp></p>
<p class="TNI">This project demonstrates the basic framework to remotely control your Arduino over RS232 to control devices connected to digital outputs, request information from sensors, or even add computer control to your Arduino projects with PC-based software that writes to the serial port.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">An RS232 shield or module for Arduino</li>
<li class="BL">A nine-pin cable for PC-to-RS232 connection</li>
</ul>
<p class="TX">To assemble the project, connect the Arduino to the RS232 hardware and PC as described in the previous section. Uploaded the sketch for Project #49, open the CoolTerm software, and click <b>Connect</b> to begin data communication between the Arduino and the PC via RS232.</p>
<p class="TX">Press <b>0</b> or <b>1</b> on the PC keyboard to request the values of the Arduino’s analog inputs 0 and 1, respectively, and turn the onboard LED on and off by pressing <b>2</b> and <b>3</b>. If any other key is pressed, the terminal should display the error message <samp class="SANS_TheSansMonoCd_W5Regular_11">Unrecognized command</samp>, as shown in <a href="chapter17.xhtml#fig17-10">Figure 17-10</a>.<span aria-label=" Page 296. " epub:type="pagebreak" id="pg_296" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE RESULTS OF PROJECT #49 IN THE COOLTERM WINDOW" class="img7" id="fig17-10" src="../images/fig17-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-10: Example output from Project #49</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-49"/>

<pre><code>// Project #49 - PC-to-Arduino remote control

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> void doSomething0()
{
    Serial.print("A0 value is: ");
    Serial.println(analogRead(0));
}

void doSomething1()
{
    Serial.print("A1 value is: ");
    Serial.println(analogRead(1));
}

void doSomething2()
{
    digitalWrite(13, HIGH);
    Serial.println("LED On");
}

void doSomething3()
{
    digitalWrite(13, LOW);
    Serial.println("LED Off");
}

void setup()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Serial.begin(9600);
    pinMode(13, HIGH);
    digitalWrite(13,LOW);
}

void loop()
{
    char command;
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> if(Serial.available()) // If data received by Arduino serial
    {
<span aria-label=" Page 297. " epub:type="pagebreak" id="pg_297" role="doc-pagebreak"/>        command = Serial.read(); // Save the data
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> switch (command)
        // Act on the received data:
        {
            case '0': doSomething0(); break;
            case '1': doSomething1(); break;
            case '2': doSomething2(); break;
            case '3': doSomething3(); break;
          <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> default: Serial.println("Unrecognized command.");
        }
    }
}
</code></pre>

<p class="TX">Starting at <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, the sketch creates four custom functions to be called upon receiving a matching command. The sketch then initializes the Arduino serial port <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and sets the onboard LED pin to output and turns it off.</p>
<p class="TX">In the main loop, the Arduino waits for a character of text to come in from the RS232 connection via serial <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and then acts on this character using a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If the character falls outside of the range of choices, the sketch sends an error message back to the PC <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The actions in this sketch are simply demonstrations, and you can replace the contents with your own requirements.</p>
<p class="TX">This project demonstrates that you can control or monitor any Arduino operation with a PC over an RS232 connection. You could also write your own custom PC software for remote control. Any code that can write to a COM: or serial port on the machine can control the Arduino, and any code that can receive text from the serial port can act upon it.</p>
<p class="TX">In the next project, I’ll show you how to set up communication between two Arduinos via RS232. Since RS232 is an extension of the Arduino’s serial communication, two Arduinos can communicate with each other using RS232. However, the RS232 cable required for this purpose is slightly different than a normal cable: the TX and RX data lines need to be crossed over. That is, the TX pin on one end of the cable needs to be connected to the RX pin at the other end, and vice versa. Otherwise, you’d be trying to connect the TX pins of the two Arduinos, which won’t work.</p>
<p class="TX">The solution to this problem is to use a <i>crossover</i>, or <i>null modem</i>, cable, which has the internal wiring required for direct RS232-to-RS232-device communication, such as PMD Way part 6045480L15 shown in <a href="chapter17.xhtml#fig17-11">Figure 17-11</a>.<span aria-label=" Page 298. " epub:type="pagebreak" id="pg_298" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF THE RS232 CROSSOVER/NULL-MODEM CABLE" class="img5" id="fig17-11" src="../images/fig17-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-11: An RS232 crossover cable</samp></p></figcaption>
</figure>
<p class="TX">If you’re experimenting over just a short distance, you can instead just use jumper wires to connect between the two RS232 shields or modules for Arduino: just connect the TX and RX on one side to the RX and TX on the other, and connect GND across the two.</p>
<p class="HeadProject"><span id="h1-128"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #50: Enabling Arduino-to-Arduino Communication</samp></p>
<p class="TNI">This project demonstrates how one Arduino talks to another over RS232. One Arduino board with a BMP180 temperature sensor will send the current temperature to another Arduino board via RS232, and the I<sup>2</sup>C LCD connected to the receiving Arduino will display the value.</p>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">Two Arduino Uno or compatible boards and USB cables</li>
<li class="BL">Two RS232 shields or modules for Arduino</li>
<li class="BL">A nine-pin RS232 crossover cable</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
<li class="BL">A BMP180 temperature and air pressure sensor board</li>
<li class="BL">A PCF8574 LCD module</li>
</ul>
<p class="TX">One Arduino will act as the transmitter board, the other as the receiver board. To assemble the hardware, attach an RS232 shield or module to each Arduino, then connect both via the crossover cable or jumper wires. Add the BMP180 sensor to the transmitter board, as shown in the schematic in <a href="chapter17.xhtml#fig17-12">Figure 17-12</a>.<span aria-label=" Page 299. " epub:type="pagebreak" id="pg_299" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC DIAGRAM FOR A BMP180 SENSOR TO AN ARDUINO" class="img5" id="fig17-12" src="../images/fig17-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-12: The connection diagram for a BMP180 sensor to a transmitter Arduino</samp></p></figcaption>
</figure>
<p class="TX">Next, add the LCD module to the receiver board, as shown in <a href="chapter17.xhtml#fig17-13">Figure 17-13</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC DIAGRAM FOR AN I2C LCD TO AN ARDUINO" class="img5" id="fig17-13" src="../images/fig17-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-13: The connection diagram for an LCD to a receiver Arduino</samp></p></figcaption>
</figure>
<p class="TX">If you haven’t used the BMP180 sensor before, install the library as described in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, and install the I<sup>2</sup>C LCD as described in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>.</p>
<p class="TX">Now that the Arduinos are connected, if you’re using the RS232 shields, be sure they’re switched on. To power the project, you can use either USB cables or external power if there’s a distance between the PC and Arduinos.</p>
<p class="TX">Next, enter and upload the transmitter sketch to the transmitter Arduino and then the receiver sketch to the receiver Arduino. A moment or two after this, the LCD should display the current temperature on the LCD, an example of which is shown in <a href="chapter17.xhtml#fig17-14">Figure 17-14</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF THE TEMPERATURE DISPLAYED ON AN LCD: “TEMP (C)=26”" class="img8" id="fig17-14" src="../images/fig17-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-14: Example output from Project #50</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 300. " epub:type="pagebreak" id="pg_300" role="doc-pagebreak"/>Let’s see how this works, starting with the transmitter sketch:</p>
<span id="pro-50"/>

<pre><code>// Project #50 - Arduino-to-Arduino communication with RS232C - transmitter

#include "Adafruit_BMP085.h"
Adafruit_BMP085 bmp;

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> int temperature;

void setup()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Serial.begin(9600);
    bmp.begin();
}

void loop()
{
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> temperature = bmp.readTemperature();
    Serial.print("Temp (C)= ");
    Serial.print(temperature);
    Serial.print("\n");
    delay(1000);
}
</code></pre>

<p class="TX">The transmitter sketch includes and initializes the BMP180 library and then creates a variable to store the temperature <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It starts the serial and the BMP180 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The loop takes a temperature reading from the BMP180 <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and then sends the text to the receiving Arduino, starting with the description <samp class="SANS_TheSansMonoCd_W5Regular_11">Temp (C)</samp> = and followed by the value for the temperature. This is followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>, which tells the receiving Arduino to add a new line. There’s a small delay before the process repeats.</p>
<p class="TX">Now let’s examine the receiver sketch:</p>
<span id="pro-50a"/>

<pre><code>// Project #50 - Arduino-to-Arduino communication with RS232 - receiver

#include &lt;LiquidCrystal_PCF8574.h&gt;
#include &lt;Wire.h&gt;
LiquidCrystal_PCF8574 lcd(0x27);

int length = 16;
char newLine = '\n';
char buffer[16];

void setup()
{
    Serial.begin(9600);
    Wire.begin();
    Wire.beginTransmission(0x27);
    lcd.begin(16, 2);
    lcd.setBacklight(255);
    lcd.clear();
}

<span aria-label=" Page 301. " epub:type="pagebreak" id="pg_301" role="doc-pagebreak"/>void loop()
{
    if (Serial.available())
    {
        lcd.home();
        lcd.setCursor(0, 0);
        Serial.readBytesUntil(newLine, buffer, length);
        lcd.print(buffer);
    }
}
</code></pre>

<p class="TX">The receiver sketch is tasked with displaying the line of serial data received over RS232 on the LCD. It includes and initializes the LCD library and I<sup>2</sup>C bus and then creates three required variables: <samp class="SANS_TheSansMonoCd_W5Regular_11">length</samp>, the number of characters that fit on one line of the LCD; <samp class="SANS_TheSansMonoCd_W5Regular_11">endOfLine</samp>, which holds a newline character; and a character array <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>, which holds incoming data from the RS232 bus.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch sets up serial communications, activates the I<sup>2</sup>C bus, and initializes the LCD for use by turning on the backlight and setting the cursor to the top left of the display. In the main loop, if incoming characters are detected, the LCD cursor is reset to the top left with <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.home();</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">lcd.setCursor(0, 0);</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.readBytesUntil()</samp> function captures up to 16 inbound characters from serial, until the newline character is received. The sketch stores these characters in the array buffer. Finally, it displays the characters of the buffer array on the LCD. The process repeats whenever new data is received from the transmitter Arduino.</p>
<p class="TX">For more permanent projects that involve two Arduino boards at a distance from one another, the simple demonstration in this project provides an ideal framework for reliable data transmission. For a challenge, you might create a project in which two Arduinos “talk” to each other by sending random data or sensor values.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-129"/><samp class="SANS_Futura_Std_Bold_B_11">Other RS232 Data Configurations</samp></h2>
<p class="TNI">Up until now in this chapter, you’ve used a default 9,600 bps for data speed and 8 bits in each piece of data sent, with no parity and 1 stop bit. (This is often written as “8, None, 1” after the speed in device specification sheets or user manuals.) However, in future projects, you may want to work with devices that use a different data speed or method of sending and receiving data. For example, an old terminal might use 7 bits instead of 8, and 2 stop bits instead of 1.</p>
<p class="TX">To solve this problem, you can modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.begin()</samp> function’s parameters used in the projects in this chapter. Set the first parameter to the data speed you require and the second parameter as the new data configuration:</p>

<pre><code>Serial.begin(<var>speed</var>, SERIAL_<var>XYZ</var>)
</code></pre>

<p class="TX"><span aria-label=" Page 302. " epub:type="pagebreak" id="pg_302" role="doc-pagebreak"/>In the second parameter, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp> stands for the requisite number of data bits, which can fall between 5 and 8; <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> stands for parity, which can be <samp class="SANS_TheSansMonoCd_W5Regular_11">N</samp> for none, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> for even, or <samp class="SANS_TheSansMonoCd_W5Regular_11">O</samp> for odd; and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Z</samp> stands for the number of stop bits, which can be 1 or 2.</p>
<p class="TX">For example, to start the serial (and thus RS232) at 4,800 bps with 7-bit data, no parity, and 1 stop bit, use the following function in your sketch:</p>

<pre><code>Serial.begin(4800, SERIAL_7N1)
</code></pre>

<p class="TX">This may come in handy if you decide to interface any vintage equipment with your Arduino. For some retro computing fun, keep an eye out on eBay or computer marketplaces for old computer terminals or printers. For example, check out the Arduino-controlled RS232 to parallel printer interface at <a href="https://hackaday.io/project/18140-serial-to-parallel-printer-interface"><i>https://<wbr/>hackaday<wbr/>.io<wbr/>/project<wbr/>/18140<wbr/>-serial<wbr/>-to<wbr/>-parallel<wbr/>-printer<wbr/>-interface</i></a>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h2 class="H1" id="sec5"><span id="h1-130"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">You learned how to communicate between a PC and Arduino via RS232 and between Arduinos via RS232. You now have the tools to harness the RS232 bus for remote control, data communication between Arduinos, and data capture to a PC for analysis and to communicate with RS232-based devices with an Arduino.</p>
<p class="TX">In the next chapter, you’ll learn how to use an Arduino to communicate with other devices using another data bus, the RS485 data bus.</p>
</section>
</section>
</body>
</html>