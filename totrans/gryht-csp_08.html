<html><head></head><body>
<p id="filepos620048" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">9</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">AUTOMATING SQLMAP</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">In this chapter, we make tools to automatically exploit SQL injection vectors. We use sqlmap—a popular utility you’ll learn about in this chapter—to first find and then verify HTTP parameters vulnerable to SQL injection. After that, we combine that functionality with the SOAP fuzzer we created in <a href="index_split_008.html#filepos243384">Chapter 3</a> to automatically verify any potential SQL injections in the vulnerable SOAP service. sqlmap ships with a REST API, meaning that it uses HTTP GET, PUT, POST, and DELETE requests to work with data and special URIs to reference resources in databases. We used REST APIs in <a href="index_split_010.html#filepos420379">Chapter 5</a> when we automated Nessus.</p><p class="calibre_6">The sqlmap API also uses JSON to read objects in HTTP requests sent to the API URLs (known as <span class="italic">endpoints</span> in REST parlance). JSON is like XML in that it allows two programs to pass data to each other in a standard way, but it’s also much less verbose and lighter weight than XML. Normally, sqlmap is used by hand at the command line, but driving the JSON API programmatically will allow you to automate far more tasks than normal pentesting tools do, from automatically detecting a vulnerable parameter to exploiting it.</p><p class="calibre_6">Written in Python, sqlmap is an actively developed utility available on GitHub at <a href="https://github.com/sqlmapproject/sqlmap/"><span class="italic">https://github.com/sqlmapproject/sqlmap/</span></a>. You can download sqlmap using <span class="calibre4">git</span> or by downloading a ZIP file of the current master branch. Running sqlmap requires you to have Python installed (on most Linux distributions, this is usually installed by default).</p><p class="calibre_6">If you prefer <span class="calibre4">git</span>, the following command will check out the latest master branch: $ <span class="bold">git clone https://github.com/sqlmapproject/sqlmap.git</span> If you prefer <span class="calibre4">wget</span>, you can download a ZIP archive of the latest master branch, as shown here: $ <span class="bold">wget https://github.com/sqlmapproject/sqlmap/archive/master.zip</span><br class="calibre5"/>$ <span class="bold">unzip master.zip</span> In order to follow the examples in this chapter, you should also install a JSON serialization framework such as the open source option Json.NET. Download it from <a href="https://github.com/JamesNK/Newtonsoft.Json"><span class="italic">https://github.com/JamesNK/Newtonsoft.Json</span></a> or use the NuGet package manager, available in most C# IDEs. We used this library before in <a href="index_split_007.html#filepos114239">Chapter 2</a> and <a href="index_split_010.html#filepos420379">Chapter 5</a>.</p><p id="filepos622967" class="calibre_10"><span class="calibre3"><span class="bold">Running sqlmap</span></span></p><p class="calibre_11">Most security engineers and pentesters use the Python script <span class="italic">sqlmap.py</span> (in the root of the sqlmap project or installed system-wide) to drive sqlmap from the command line. We will briefly go over how the sqlmap command line tool works before jumping into the API. Kali has sqlmap installed so that you can just call <span class="calibre4">sqlmap</span> from anywhere on the system. Although the <span class="calibre4">sqlmap</span> command line tool has the same overall functionality as the API, it isn’t as easily integrated into other programs without invoking the shell. Driving the API programmatically should be safer and more flexible than just using the command line tool when integrating with other code.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">If you are not running Kali, you may have downloaded sqlmap but not installed it on the system. You can still use sqlmap without installing it system-wide by changing to the directory that sqlmap is in and calling the</span> sqlmap.py <span class="italic">script directly with Python using the following code:</span></blockquote><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">python ./sqlmap.py [.. args ..]</span></span></blockquote><p class="calibre_6">A typical sqlmap command might look like the code in <a href="#filepos625023">Listing 9-1</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">sqlmap</span></span><span class="calibre4"> ➊</span><span class="calibre4"><span class="bold">--method=GET --level=3 --technique=b</span></span><span class="calibre4"> ➋</span><span class="calibre4"><span class="bold">--dbms=mysql \</span></span><br class="calibre5"/><span class="calibre4">➌</span><span class="calibre4"><span class="bold">-u "http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&amp;action=search"</span></span></blockquote><p id="filepos625023" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-1: A sample sqlmap command to run against BadStore</span></span></p><p class="calibre_6"> We won’t cover the output of <a href="#filepos625023">Listing 9-1</a> at the moment, but note the syntax of the command. In this listing, the arguments we pass to sqlmap tell it that we want it to test a certain URL (hopefully a familiar URL, like the one we tested in <a href="index_split_007.html#filepos114239">Chapter 2</a> with BadStore). We tell sqlmap to use <span class="calibre4">GET</span> as the HTTP method ➊ and to use MySQL ➋ payloads specifically (rather than include payloads for PostgreSQL or Microsoft SQL Server), followed by the URL ➌ we want to test. There is only a small subset of arguments you can use with the sqlmap script. If you want to try out other commands manually, you can find more detailed information at <a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage/"><span class="italic">https://github.com/sqlmapproject/sqlmap/wiki/Usage/</span></a>. We can use the sqlmap REST API to drive the same functionality as the sqlmap command in <a href="#filepos625023">Listing 9-1</a>.</p><p class="calibre_6">When running the <span class="italic">sqlmapapi.py</span> API examples, you may need to run the API server differently than with the sqlmap utility since it might not be installed like the <span class="italic">sqlmap.py</span> script, which is callable from the system shell like on Kali. If you need to download sqlmap in order to use the sqlmap API, you can find it on GitHub (<a href="https://github.com/sqlmapproject/sqlmap/"><span class="italic">https://github.com/sqlmapproject/sqlmap/</span></a>).</p><p id="filepos626661" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The sqlmap REST API</span></span></span></p><p class="calibre_11">Official documentation on the sqlmap REST API is a bit bare, but we cover everything you need to know to use it efficiently and effectively in this book. First, run <span class="calibre4">sqlmapapi.py -–server</span> (located in the root of the sqlmap project directory you downloaded earlier) to start the sqlmap API server listening at 127.0.0.1 (on port 8775 by default), as shown in <a href="#filepos627726">Listing 9-2</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./sqlmapapi.py --server</span></span><br class="calibre5"/><span class="calibre4">[22:56:24] [INFO] Running REST-JSON API server at '127.0.0.1:8775'..</span><br class="calibre5"/><span class="calibre4">[22:56:24] [INFO] Admin ID: 75d9b5817a94ff9a07450c0305c03f4f</span><br class="calibre5"/><span class="calibre4">[22:56:24] [DEBUG] IPC database: /tmp/sqlmapipc-34A3Nn</span><br class="calibre5"/><span class="calibre4">[22:56:24] [DEBUG] REST-JSON API server connected to IPC database </span><a id="filepos627726"/><span class="calibre4"><span class="italic">Listing 9-2: Starting the sqlmap server</span></span></blockquote><p class="calibre_6">sqlmap has several REST API endpoints that we need to create our automated tool. In order to use sqlmap, we need to create <span class="italic">tasks</span> and then use API requests to act on those tasks. Most of the available endpoints use GET requests, which are meant to retrieve data. To see what GET API endpoints are available, run <span class="calibre4"><span class="bold">rgrep "@get".</span></span> from the root of the sqlmap project directory, as shown in <a href="#filepos629313">Listing 9-3</a>. This command lists many of the available API endpoints, which are special URLs used in the API for certain actions.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">rgrep "@get" .</span></span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@get("/task/new➊")</span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@get("/task/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/delete➋")</span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@get("/admin/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/list")</span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@get("/admin/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/flush")</span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@get("/option/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/list")</span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@get("/scan/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/stop➌")</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span></blockquote><p id="filepos629313" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-3: Available sqlmap REST API GET requests</span></span></p><p class="calibre_6"> Soon we’ll cover how to use the API endpoints to create ➊, stop ➌, and delete ➋ sqlmap tasks. You can replace <span class="calibre4">@get</span> in this command with <span class="calibre4">@post</span> to see the API’s available endpoints for POST requests. Only three API calls require an HTTP POST request, as shown in <a href="#filepos630337">Listing 9-4</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">rgrep "@post" .</span></span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@post("/option/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/get")</span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@post("/option/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/set")</span><br class="calibre5"/><span class="calibre4">lib/utils/api.py:@post("/scan/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/start") </span><a id="filepos630337"/><span class="calibre4"><span class="italic">Listing 9-4: REST API endpoints for POST requests</span></span></blockquote><p class="calibre_6">When using the sqlmap API, we need to create a task to test a given URL for SQL injections. Tasks are identified by their task ID, which we enter in place of <span class="calibre4"><span class="italic">taskid</span></span> in the API options in <a href="#filepos629313">Listings 9-3</a> and <a href="#filepos630337">9-4</a>. We can use curl to test the sqlmap server to ensure it is running properly and to get a feel for how the API behaves and the data it sends back. This will give us a good idea of how our C# code is going to work when we begin writing our sqlmap classes.</p><p id="filepos631025" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Testing the sqlmap API with curl</span></span></span></p><p class="calibre_11">Normally, sqlmap is run on the command line using the Python script we covered earlier in this chapter, but the Python commands will hide what sqlmap is doing on the backend and won’t give us insight into how each API call will work. To get a feel for using the sqlmap API directly, we’ll use curl, which is a command line tool generally used to make HTTP requests and see the responses to those requests. For example, <a href="#filepos632101">Listing 9-5</a> shows how to make a new sqlmap task by calling to the port sqlmap is listening to.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl</span></span><span class="calibre4"> ➊</span><span class="calibre4"><span class="bold">127.0.0.1:8775/task/new</span></span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➋"taskid": "dce7f46a991c5238",</span><br class="calibre5"/><span class="calibre4"> "success": true</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos632101" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-5: Creating a new sqlmap task with curl</span></span></p><p class="calibre_6">Here, the port is 127.0.0.1:8775 ➊. This returns a new task ID after the <span class="calibre4">taskid</span> key and a colon ➋. Make sure that your sqlmap server is running as in <a href="#filepos627726">Listing 9-2</a> before making this HTTP request.</p><p class="calibre_6">After making a simple GET request with <span class="calibre4">curl</span> to the <span class="calibre4">/task/new</span> endpoint, sqlmap returns a new task ID for us to use. We’ll use this task ID to make other API calls later, including starting and stopping the task and getting the task results. To view a list of all scan options for a given task ID available for use with sqlmap, call the <span class="calibre4">/option/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/list</span> endpoint and substitute the ID you created earlier, as shown in <a href="#filepos634250">Listing 9-6</a>. Note we are using the same task ID in the API endpoint request that was returned in <a href="#filepos632101">Listing 9-5</a>. Knowing the options for a task is important for starting the SQL injection scan later.</p><blockquote class="calibre_14"><span class="calibre4"> $ </span><span class="calibre4"><span class="bold">curl 127.0.0.1:8775/option/dce7f46a991c5238/list</span></span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> "options": {</span><br class="calibre5"/><span class="calibre4"> "crawlDepth": null,</span><br class="calibre5"/><span class="calibre4"> "osShell": false,</span><br class="calibre5"/><span class="calibre4"> ➊"getUsers": false,</span><br class="calibre5"/><span class="calibre4"> ➋"getPasswordHashes": false,</span><br class="calibre5"/><span class="calibre4"> "excludeSysDbs": false,</span><br class="calibre5"/><span class="calibre4"> "uChar": null,</span><br class="calibre5"/><span class="calibre4">
</span><span class="calibre4"><span class="italic">--snip--</span></span><br class="calibre5"/><span class="calibre4"> ➌"tech": "BEUSTQ",</span><br class="calibre5"/><span class="calibre4"> "textOnly": false,</span><br class="calibre5"/><span class="calibre4"> "commonColumns": false,</span><br class="calibre5"/><span class="calibre4"> "keepAlive": false</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos634250" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-6: Listing the options for a given task ID</span></span></p><p class="calibre_6">Each of these task options corresponds with a command line argument from the command line sqlmap tool. These options tell sqlmap how it should perform a SQL injection scan and how it should exploit any injections it finds. Among the interesting options shown in <a href="#filepos634250">Listing 9-6</a> is one for setting the injection techniques (<span class="calibre4">tech</span>) to test for; here it is set to the default <span class="calibre4">BEUSTQ</span> to test for all SQL injection types ➌. You also see options for dumping the user database, which is off in this example ➊, and dumping password hashes, which is also off ➋. If you are interested in what all the options do, run <span class="calibre4">sqlmap --help</span> at the command line to see the option descriptions and usage.</p><p class="calibre_6">After creating our task and viewing its currently set options, we can set one of the options and then start a scan. To set specific options, we make a POST request and need to include some data that tells sqlmap what to set the options to. <a href="#filepos636292">Listing 9-7</a> details starting a sqlmap scan with curl to test a new URL.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl</span></span><span class="calibre4"> ➊</span><span class="calibre4"><span class="bold">-X POST</span></span><span class="calibre4"> ➋</span><span class="calibre4"><span class="bold">-H "Content-Type:application/json" \</span></span><br class="calibre5"/><span class="calibre4"> ➌</span><span class="calibre4"><span class="bold">--data '{"url":"http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&amp;action=search"}' \</span></span><br class="calibre5"/><span class="calibre4"> ➍</span><span class="calibre4"><span class="bold">http://127.0.0.1:8775/scan/dce7f46a991c5238/start</span></span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> "engineid": 7181,</span><br class="calibre5"/><span class="calibre4"> "success": true➎</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos636292" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-7: Starting a scan with new options using the sqlmap API</span></span></p><p class="calibre_6">This POST request command looks different from the GET request in <a href="#filepos632101">Listing 9-5</a>, but it is actually very similar. First, we designate the command as a POST request ➊. Then we list the data to send to the API by placing the name of the option to set in quotes (such as <span class="calibre4">"url"</span>), followed by a colon, then the data to set the option to ➌. We designate the content of the data to be JSON using the <span class="calibre4">-H</span> argument to define a new HTTP header ➋, which ensures the <span class="calibre4">Content-Type</span> header will be correctly set to the <span class="calibre4">application/json</span> MIME-type for the sqlmap server. Then we start the command with a POST request using the same API call format as the GET request in <a href="#filepos634250">Listing 9-6</a>, with the endpoint <span class="calibre4">/scan/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/start</span> ➍.</p><p class="calibre_6">Once the scan has been started and sqlmap reports success ➎, we need to get the scan status. We can do that with a simple curl call using the <span class="calibre4">status</span> endpoint, as shown in <a href="#filepos638064">Listing 9-8</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl 127.0.0.1:8775/scan/dce7f46a991c5238/status</span></span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➊"status": "terminated",</span><br class="calibre5"/><span class="calibre4"> "returncode": 0,</span><br class="calibre5"/><span class="calibre4"> "success": true</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos638064" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-8: Getting the status of a scan</span></span></p><p class="calibre_6">After the scan has finished running, sqlmap will change the status of the scan to <span class="calibre4">terminated</span> ➊. Once the scan has terminated, we can use the <span class="calibre4">log</span> endpoint to retrieve the scan log and see whether sqlmap found anything during the scan, as <a href="#filepos639457">Listing 9-9</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl 127.0.0.1:8775/scan/dce7f46a991c5238/log</span></span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> "log": [</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➊"message": "flushing session file",</span><br class="calibre5"/><span class="calibre4"> ➋"level": "INFO",</span><br class="calibre5"/><span class="calibre4"> ➌"time": "09:24:18"</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> "message": "testing connection to the target URL",</span><br class="calibre5"/><span class="calibre4"> "level": "INFO",</span><br class="calibre5"/><span class="calibre4"> "time": "09:24:18"</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4">
</span><span class="calibre4"><span class="italic">--snip--</span></span><br class="calibre5"/><span class="calibre4"> ],</span><br class="calibre5"/><span class="calibre4"> "success": true</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos639457" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-9: Making a request for the scan log</span></span></p><p class="calibre_6">The sqlmap scan log is an array of statuses that includes the message ➊, message level ➋, and timestamp ➌ for each status. The scan log gives us great visibility into what happened during a sqlmap scan of a given URL, including any injectable parameters. Once we are done with the scan and have our results, we should go ahead and clean up to conserve resources. To delete the task we just created when we’re done with it, call <span class="calibre4">/task/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/delete</span>, as shown in <a href="#filepos640641">Listing 9-10</a>. Tasks can be freely created and deleted in the API, so feel free to create new tasks, play around with them, and then delete them.</p><blockquote class="calibre_14"><span class="calibre4"> $ </span><span class="calibre4"><span class="bold">curl 127.0.0.1:8775/task/dce7f46a991c5238/delete</span></span><span class="calibre4">➊</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> "success": true➋</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos640641" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-10: Deleting a task in the sqlmap API</span></span></p><p class="calibre_6">After calling the <span class="calibre4">/task/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/delete</span> endpoint ➊, the API will return the task’s status and whether it was successfully deleted ➋. Now that we have the general workflow of creating, running, and deleting a sqlmap scan, we can begin working on our C# classes to automate the whole process from start to finish.</p><p id="filepos641198" class="calibre_10"><span class="calibre3"><span class="bold">Creating a Session for sqlmap</span></span></p><p class="calibre_11">No authentication is required to use the REST API, so we can easily use the session/manager pattern, which is a simple pattern similar to the other API patterns in previous chapters. This pattern allows us to separate the protocol’s transport (how we talk to the API) from the protocol’s exposed functionality (what the API can do). We’ll implement <span class="calibre4">SqlmapSession</span> and <span class="calibre4">SqlmapManager</span> classes to drive the sqlmap API to automatically find and exploit injections.</p><p class="calibre_6">We’ll begin by writing the <span class="calibre4">SqlmapSession</span> class. This class, shown in <a href="#filepos643558">Listing 9-11</a>, requires only a constructor and two methods called <span class="calibre4">ExecuteGet()</span> and <span class="calibre4">ExecutePost()</span>. These methods will do most of the heavy lifting of the two classes we’ll write. They will make the HTTP requests (one for GET requests and one for POST requests, respectively) that allow our classes to talk with the sqlmap REST API.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊SqlmapSession : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private string _host = string.Empty;</span><br class="calibre5"/><span class="calibre4"> private int _port = 8775; //default port</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public ➋SqlmapSession(string host, int port = 8775)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _host = host;</span><br class="calibre5"/><span class="calibre4"> _port = port;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string ➌ExecuteGet(string url)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return string.Empty;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string ➍ExecutePost(string url, string data)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return string.Empty;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public void ➎Dispose()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _host = null;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos643558" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-11: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SqlmapSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">We start by creating a public class called <span class="calibre4">SqlmapSession</span> ➊ that will implement the <span class="calibre4">IDisposable</span> interface. This lets us use the <span class="calibre4">SqlmapSession</span> with a <span class="calibre4">using</span> statement, allowing us to write cleaner code with variables managed through garbage collection. We also declare two private fields, a host and a port, which we will use when making our HTTP requests. We assign the <span class="calibre4">_host</span> variable a value of <span class="calibre4">string.Empty</span> by default. This is a feature of C# that allows you to assign an empty string to a variable without actually instantiating a string object, resulting in a slight performance boost (but for now, it’s just to assign a default value). We assign the <span class="calibre4">_port</span> variable the port that sqlmap listens on, which is 8775, the default.</p><p class="calibre_6">After declaring the private fields, we create a constructor that accepts two arguments ➋: the host and the port. We assign the private fields the values that are passed as the parameters to the constructor so we can connect to the correct API host and port. We also declare two stub methods for executing GET and POST requests that return <span class="calibre4">string.Empty</span> for the time being. We’ll define these methods next. The <span class="calibre4">ExecuteGet()</span> method ➌ only requires a URL as input. The <span class="calibre4">ExecutePost()</span> method ➍ requires a URL and the data to be posted. Finally, we write the <span class="calibre4">Dispose()</span> method ➎, which is required when implementing the <span class="calibre4">IDisposable</span> interface. Within this method, we clean up our private fields by assigning them a value of null.</p><p id="filepos645593" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a Method to Execute a GET Request</span></span></span></p><p class="calibre_11"><a href="#filepos646610">Listing 9-12</a> shows how to use <span class="calibre4">WebRequest</span> to implement the first of the two stubbed methods to execute a GET request and return a string.</p><blockquote class="calibre_14"><span class="calibre4">public string ExecuteGet(string url)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest)WebRequest.➊Create("http://" + _host + ":" + _port + url);</span><br class="calibre5"/><span class="calibre4"> req.Method = "GET";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> ➋using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.➌ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return resp;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos646610" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-12: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ExecuteGet()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">We create a <span class="calibre4">WebRequest</span> ➊ with the <span class="calibre4">_host</span>, <span class="calibre4">_port</span>, and <span class="calibre4">url</span> variables to build a full URL and then set the <span class="calibre4">Method</span> property to GET. Next, we perform the request ➋ and read the response into a string with <span class="calibre4">ReadToEnd()</span> ➌, which is then returned to the caller method. When you implement <span class="calibre4">SqlmapManager</span>, you’ll use the Json.NET library to deserialize the JSON returned in the string so that you can easily pull values from it. Deserialization is the process of converting strings into JSON objects, and serialization is the opposite process.</p><p id="filepos647563" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Executing a POST Request</span></span></span></p><p class="calibre_11">The <span class="calibre4">ExecutePost()</span> method is only slightly more complex than the <span class="calibre4">ExecuteGet()</span> method. Since <span class="calibre4">ExecuteGet()</span> can only make simple HTTP requests, <span class="calibre4">ExecutePost()</span> will allow us to send complex requests with more data (such as JSON). It will also return a string containing the JSON response that will be deserialized by the <span class="calibre4">SqlmapManager</span>. <a href="#filepos649306">Listing 9-13</a> shows how to implement the <span class="calibre4">ExecutePost()</span> method.</p><blockquote class="calibre_14"><span class="calibre4">public string ExecutePost(string url, string data)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> byte[] buffer = ➊Encoding.ASCII.GetBytes(data);</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest)WebRequest.Create("http://"+_host+":"+_port+url);</span><br class="calibre5"/><span class="calibre4"> req.Method = "POST"➋;</span><br class="calibre5"/><span class="calibre4"> req.ContentType = "application/json"➌;</span><br class="calibre5"/><span class="calibre4"> req.ContentLength = buffer.Length;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (Stream stream = req.GetRequestStream())</span><br class="calibre5"/><span class="calibre4"> stream.➍Write(buffer, 0, buffer.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (StreamReader r = new StreamReader(req.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = r.➎ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return resp;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos649306" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-13: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ExecutePost()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">This is very similar to the code we wrote when fuzzing POST requests in <a href="index_split_007.html#filepos114239">Chapters 2</a> and <a href="index_split_008.html#filepos243384">3</a>. This method expects two arguments: an absolute URI and the data to be posted into the method. The <span class="calibre4">Encoding</span> class ➊ (available in the <span class="calibre4">System.Text</span> namespace) is used to create a byte array that represents the data to be posted. We then create a <span class="calibre4">WebRequest</span> object and set it up as we did for the <span class="calibre4">ExecuteGet()</span> method, except we set the <span class="calibre4">Method</span> to <span class="calibre4">POST</span> ➋. Notice that we also specify a <span class="calibre4">ContentType</span> of <span class="calibre4">application/json</span> ➌ and a <span class="calibre4">ContentLength</span> that matches the length of the byte array. Since we will be sending the server JSON data, we need to set the appropriate content type and length of our data in the HTTP request. We write ➍ the byte array to the request TCP stream (the connection between your computer and the HTTP server) once the <span class="calibre4">WebRequest</span> is set up, sending the JSON data to the server as the HTTP request body. Finally, we read ➎ the HTTP response into a string that is returned to the calling method.</p><p id="filepos650846" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Testing the Session Class</span></span></span></p><p class="calibre_11">Now we are ready to write a small application to test the new <span class="calibre4">SqlmapSession</span> class in the <span class="calibre4">Main()</span> method. We’ll create a new task, call our methods, and then delete the task, as <a href="#filepos652523">Listing 9-14</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string host = ➊args[0];</span><br class="calibre5"/><span class="calibre4"> int port = int.Parse(args[1]);</span><br class="calibre5"/><span class="calibre4"> using (SqlmapSession session = new ➋SqlmapSession(host, port))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string response = session.➌ExecuteGet("/task/new");</span><br class="calibre5"/><span class="calibre4"> JToken token = JObject.Parse(response);</span><br class="calibre5"/><span class="calibre4"> string taskID = token.➍SelectToken("taskid").ToString();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➎Console.WriteLine("New task id: " + taskID);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Deleting task: " + taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➏response = session.ExecuteGet("/task/" + taskID + "/delete");</span><br class="calibre5"/><span class="calibre4"> token = JObject.Parse(response);</span><br class="calibre5"/><span class="calibre4"> bool success = (bool)token.➐SelectToken("success");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Delete successful: " + success);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos652523" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-14: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method of our sqlmap console application</span></span></p><p class="calibre_6">The Json.NET library makes dealing with JSON in C# simple (as you saw in <a href="index_split_010.html#filepos420379">Chapter 5</a>). We grab the host and port from the first and second arguments passed into the program ➊, respectively. Then we use <span class="calibre4">int.Parse()</span> to parse the integer from the string argument for the port. Although we’ve been using port 8775 for this whole chapter, since the port is configurable (8775 is just the default), we shouldn’t assume it will be 8775 all the time. Once we have assigned values to the variables, we instantiate a new <span class="calibre4">SqlmapSession</span> ➋ using the parameters passed into the program. We then call the <span class="calibre4">/task/new</span> endpoint ➌ to retrieve a new task ID and use the <span class="calibre4">JObject</span> class to parse the JSON returned. Once we have the response parsed, we use the <span class="calibre4">SelectToken()</span> method ➍ to retrieve the value for the <span class="calibre4">taskid</span> key and assign this value to the <span class="calibre4">taskID</span> variable.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">A few standard types in C# have a</span>
<span class="calibre4"><span class="italic">Parse()</span></span>
<span class="italic">method, like the</span>
<span class="calibre4"><span class="italic">int.Parse()</span></span>
<span class="italic">method we just used. The int type is an Int32, so it will attempt to parse a 32-bit integer. Int16 is a short integer, so</span>
<span class="calibre4"><span class="italic">short.Parse()</span></span>
<span class="italic">will attempt to parse a 16-bit integer. Int64 is a long integer, and</span>
<span class="calibre4"><span class="italic">long.Parse()</span></span>
<span class="italic">will attempt to parse a 64-bit integer. Another useful</span>
<span class="calibre4"><span class="italic">Parse()</span></span>
<span class="italic">method exists on the</span>
<span class="calibre4"><span class="italic">DateTime</span></span>
<span class="italic">class. Each of these methods is static, so no object instantiation is necessary.</span></blockquote><p class="calibre_6">After printing the new <span class="calibre4">taskID</span> to the console ➎, we can delete the task by calling the <span class="calibre4">/task/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/delete</span> endpoint ➏. We again use the <span class="calibre4">JObject</span> class to parse the JSON response and then retrieve the value for the <span class="calibre4">success</span> key ➐, cast it as a <span class="calibre4">Boolean</span>, and assign it to the <span class="calibre4">success</span> variable. This variable is printed to the console, showing the user whether the task was successfully deleted. When you run the tool, it produces output about creating and deleting a task, as shown in <a href="#filepos655824">Listing 9-15</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">mono ./ch9_automating_sqlmap.exe 127.0.0.1 8775</span></span><br class="calibre5"/><span class="calibre4">New task id: 96d9fb9d277aa082</span><br class="calibre5"/><span class="calibre4">Deleting task: 96d9fb9d277aa082</span><br class="calibre5"/><span class="calibre4">Delete successful: True </span><a id="filepos655824"/><span class="calibre4"><span class="italic">Listing 9-15: Running the program that creates a sqlmap task and then deletes it</span></span></blockquote><p class="calibre_6">Once we know we can successfully create and delete a task, we can create the <span class="calibre4">SqlmapManager</span> class to encapsulate the API functionality we want to use in the future, such as setting scan options and getting the scan results.</p><p id="filepos656245" class="calibre_10"><span class="calibre3"><span class="bold">The SqlmapManager Class</span></span></p><p class="calibre_11">The <span class="calibre4">SqlmapManager</span> class, shown in <a href="#filepos657962">Listing 9-16</a>, wraps the methods exposed through the API in an easy-to-use (and maintainable!) way. When we finish writing the methods needed for this chapter, we can start a scan on a given URL, watch it until it completes, and then retrieve the results and delete the task. We’ll also make heavy use of the Json.NET library. To reiterate, the goal of the session/manager pattern is to separate the transport of the API from the functionality exposed by the API. An added benefit to this pattern is that it allows the programmer using the library to focus on the results API calls. The programmer can, however, still interact directly with the session if needed.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊SqlmapManager : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private ➋SqlmapSession _session = null;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public ➌SqlmapManager(SqlmapSession session)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (session == null)</span><br class="calibre5"/><span class="calibre4"> throw new ArgumentNullException("session");</span><br class="calibre5"/><span class="calibre4"> _session = session;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public void ➍Dispose()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _session.Dispose();</span><br class="calibre5"/><span class="calibre4"> _session = null;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos657962" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-16: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SqlmapManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6"> We declare the <span class="calibre4">SqlmapManager</span> class ➊ and have it implement the <span class="calibre4">IDisposable</span> interface. We also declare a private field ➋ for the <span class="calibre4">SqlmapSession</span> that will be used throughout the class. Then, we create the <span class="calibre4">SqlmapManager</span> constructor ➌, which accepts a <span class="calibre4">SqlmapSession</span>, and we assign the session to the private <span class="calibre4">_session</span> field.</p><p class="calibre_6">Finally, we implement the <span class="calibre4">Dispose()</span> method ➍, which cleans up the private <span class="calibre4">SqlmapSession</span>. You may wonder why we have both the <span class="calibre4">SqlmapSession</span> and <span class="calibre4">SqlmapManager</span> implement <span class="calibre4">IDisposable</span>, when in the <span class="calibre4">Dispose()</span> method of the <span class="calibre4">SqlmapManager</span>, we call <span class="calibre4">Dispose()</span> on the <span class="calibre4">SqlmapSession</span> as well. A programmer may want to instantiate only a <span class="calibre4">SqlmapSession</span> and interact with it directly in case a new API endpoint is introduced that the manager hasn’t been updated to support. Having both classes implement <span class="calibre4">IDisposable</span> offers the greatest flexibility.</p><p class="calibre_6">Since we just implemented the methods needed to create a new task and delete an existing one when we tested the <span class="calibre4">SqlmapSession</span> class in <a href="#filepos652523">Listing 9-14</a>, we’ll add these actions as their own methods to the <span class="calibre4">SqlmapManager</span> class above the <span class="calibre4">Dispose()</span> method, as shown in <a href="#filepos660615">Listing 9-17</a>.</p><blockquote class="calibre_14"><span class="calibre4">public string NewTask()</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> JToken tok = JObject.Parse(_session.ExecuteGet("/task/new"));</span><br class="calibre5"/><span class="calibre4">➊return tok.SelectToken("taskid").ToString();</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">public bool DeleteTask(string taskid)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> JToken tok = Jobject.Parse(session.ExecuteGet("/task/" + taskid + "/delete"));</span><br class="calibre5"/><span class="calibre4">➋return (bool)tok.SelectToken("success");</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos660615" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-17: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">NewTask()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">DeleteTask()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">methods to manage a task in sqlmap</span></span></p><p class="calibre_6">The <span class="calibre4">NewTask()</span> and <span class="calibre4">DeleteTask()</span> methods make it easy to create and delete tasks as we need in the <span class="calibre4">SqlmapManager</span> class and are nearly identical to the code in <a href="#filepos652523">Listing 9-14</a>, except that they print less output and return the task ID after creating a new task ➊ or the result (success or failure) of deleting a task ➋.</p><p class="calibre_6">Now we can use these new methods to rewrite the previous command line application testing the <span class="calibre4">SqlmapSession</span> class, as seen in <a href="#filepos662569">Listing 9-18</a>.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string host = args[0];</span><br class="calibre5"/><span class="calibre4"> int port = int.Parse(args[1]);</span><br class="calibre5"/><span class="calibre4"> using (SqlmapManager mgr = new SqlmapManager(new SqlmapSession(host, port)))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string taskID = mgr.➊NewTask();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Created task: " + taskID);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Deleting task");</span><br class="calibre5"/><span class="calibre4"> bool success = mgr.➋DeleteTask(taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Delete successful: " + success);</span><br class="calibre5"/><span class="calibre4"> } //clean up and dispose manager automatically</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos662569" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-18: Rewriting the application to use the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SqlmapManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">This code is more intuitive to read and easier to understand at a quick glance than the original application in <a href="#filepos652523">Listing 9-14</a>. We’ve replaced the code to create and delete tasks with the <span class="calibre4">NewTask()</span> ➊ and <span class="calibre4">DeleteTask()</span> ➋ methods. By just reading the code, you have no idea that the API uses HTTP as its transport or that we are dealing with JSON responses.</p><p id="filepos663291" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Listing sqlmap Options</span></span></span></p><p class="calibre_11">The next method we’ll implement (shown in <a href="#filepos664854">Listing 9-19</a>) retrieves the current options for tasks. One thing to note is that because sqlmap is written in Python, it’s weakly typed. This means that a few of the responses will have a mixture of types that are a bit difficult to deal with in C#, which is strongly typed. JSON requires all keys to be strings, but the values in the JSON will have different types, such as integers, floats, Booleans, and strings. What this means for us is that we must treat all the values as generically as possible on the C# side of things. To do that, we’ll treat them as simple objects until we need to know their types.</p><blockquote class="calibre_14"><span class="calibre4">public Dictionary&lt;string, object&gt; ➊GetOptions(string taskid)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;string, object&gt; options = ➋new Dictionary&lt;string, object&gt;();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> JObject tok = JObject.➌Parse(_session.ExecuteGet ("/option/" + taskid + "/list"));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> tok = tok["options"] as JObject;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">➍foreach (var pair in tok)</span><br class="calibre5"/><span class="calibre4"> options.Add(pair.Key, ➎pair.Value);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return ➏options;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos664854" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-19: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetOptions()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">GetOptions()</span> method ➊ in <a href="#filepos664854">Listing 9-19</a> accepts a single argument: the task ID to retrieve the options for. This method will use the same API endpoint we used in <a href="#filepos632101">Listing 9-5</a> when testing the sqlmap API with curl. We begin the method by instantiating a new <span class="calibre4">Dictionary</span> ➋ that requires the key to be a string but allows you to store any kind of <span class="calibre4">object</span> as the other value of the pair. After making the API call to the options endpoint and parsing the response ➌, we loop ➍ through the key/value pairs in the JSON response from the API and add them to the <span class="calibre4">options</span> dictionary ➎. Finally, the currently set <span class="calibre4">options</span> for the task are returned ➏ so that we can update them and use them later when we start the scan.</p><p class="calibre_6"> We’ll use this dictionary of options in the <span class="calibre4">StartTask()</span> method, which we’ll implement soon, to pass <span class="calibre4">options</span> as an argument to start a task with. First, though, go ahead and add the following lines in <a href="#filepos666802">Listing 9-20</a> to your console application after calling <span class="calibre4">mgr.NewTask()</span> but before deleting the task with <span class="calibre4">mgr.DeleteTask()</span>.</p><blockquote class="calibre_14"><span class="calibre4"> Dictionary&lt;string, object&gt; ➊options = mgr.GetOptions(➋taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">➌ foreach (var pair in options)</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Key: " + pair.Key + "\t:: Value: " + pair.Value); </span><a id="filepos666802"/><span class="calibre4"><span class="italic">Listing 9-20: Lines appended to the main application to retrieve and print the current task options</span></span></blockquote><p class="calibre_6">In this code, a <span class="calibre4">taskID</span> is given to <span class="calibre4">GetOptions()</span> ➋ as an argument, and the returned <span class="calibre4">options</span> dictionary is assigned to a new <span class="calibre4">Dictionary</span>, which is also called <span class="calibre4">options</span> ➊. The code then loops through <span class="calibre4">options</span> and prints each of its key/value pairs ➌. After adding these lines, rerun your application in your IDE or in the console, and you should see the full list of options you can set with their current values printed to the console. This is shown in <a href="#filepos668338">Listing 9-21</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">mono ./ch9_automating_sqlmap.exe 127.0.0.1 8775</span></span><br class="calibre5"/><span class="calibre4">Key: crawlDepth ::Value:</span><br class="calibre5"/><span class="calibre4">Key: osShell ::Value: False</span><br class="calibre5"/><span class="calibre4">Key: getUsers ::Value: False</span><br class="calibre5"/><span class="calibre4">Key: getPasswordHashes ::Value: False</span><br class="calibre5"/><span class="calibre4">Key: excludeSysDbs ::Value: False</span><br class="calibre5"/><span class="calibre4">Key: uChar ::Value:</span><br class="calibre5"/><span class="calibre4">Key: regData ::Value:</span><br class="calibre5"/><span class="calibre4">Key: prefix ::Value:</span><br class="calibre5"/><span class="calibre4">Key: code ::Value:</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span></blockquote><p id="filepos668338" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-21: Printing the task options to the screen after retrieving them with GetOptions()</span></span></p><p class="calibre_6">Now that we’re able to see task options, it’s time to perform a scan.</p><p id="filepos668626" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Making a Method to Perform Scans</span></span></span></p><p class="calibre_11">Now we’re ready to prepare our task to perform a scan. Within our <span class="calibre4">options</span> dictionary, we have a key that’s a <span class="calibre4">url</span>, which is the URL we’ll test for SQL injections. We pass the modified <span class="calibre4">Dictionary</span> to a new <span class="calibre4">StartTask()</span> method, which posts the dictionary as a JSON object to the endpoint and uses the new options when the task begins.</p><p class="calibre_6">Using the Json.NET library makes the <span class="calibre4">StartTask()</span> method super short because it takes care of all the serialization and deserialization for us, as <a href="#filepos669967">Listing 9-22</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">public bool StartTask(string taskID, Dictionary&lt;string, object&gt; opts)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string json = JsonConvert.➊SerializeObject(opts);</span><br class="calibre5"/><span class="calibre4"> JToken tok = JObject.➋Parse(session.ExecutePost("/scan/"+taskID+"/start", json));</span><br class="calibre5"/><span class="calibre4"> ➌return(bool)tok.SelectToken("success");</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos669967" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-22: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">StartTask()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">We use the Json.NET <span class="calibre4">JsonConvert</span> class to convert a whole object into JSON. The <span class="calibre4">SerializeObject()</span> method ➊ is used to get a JSON string representing the <span class="calibre4">options</span> dictionary that we can post to the endpoint. Then we make the API request and parse the JSON response ➋. Finally, we return ➌ the value of the <span class="calibre4">success</span> key from the JSON response, which is hopefully <span class="calibre4">true</span>. This JSON key should always be present in the response for this API call, and it will be <span class="calibre4">true</span> when the task was started successfully or <span class="calibre4">false</span> if the task was not started.</p><p class="calibre_6">It would also be useful to know when a task is complete. This way, you know when you can get the full log of the task and when to delete the task. To get the task’s status, we implement a small class (shown in <a href="#filepos671779">Listing 9-23</a>) that represents a sqlmap status response from the <span class="calibre4">/scan/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/status</span> API endpoint. This can be added in a new class file if you like, even though it’s a super-short class.</p><blockquote class="calibre_14"><span class="calibre4">public class SqlmapStatus</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➊public string Status { get; set; }</span><br class="calibre5"/><span class="calibre4">➋public int ReturnCode { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos671779" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-23: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SqlmapStatus</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">For the <span class="calibre4">SqlmapStatus</span> class, we don’t need to define a constructor because, by default, every class has a public constructor. We do define two public properties on the class: a string status message ➊ and the integer return code ➋. To get the task status and store it in <span class="calibre4">SqlmapStatus</span>, we implement <span class="calibre4">GetScanStatus</span>, which takes a <span class="calibre4">taskid</span> as input and returns a <span class="calibre4">SqlmapStatus</span> object.</p><p class="calibre_6">The <span class="calibre4">GetScanStatus()</span> method is shown in <a href="#filepos673361">Listing 9-24</a>.</p><blockquote class="calibre_14"><span class="calibre4">public SqlmapStatus GetScanStatus(string taskid)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> JObject tok = JObject.Parse(_session.➊ExecuteGet("/scan/" + taskid + "/status"));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> SqlmapStatus stat = ➋new SqlmapStatus();</span><br class="calibre5"/><span class="calibre4"> stat.Status = (string)tok["status"];</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (tok["returncode"].Type != JTokenType.Null➌)</span><br class="calibre5"/><span class="calibre4"> stat.ReturnCode = (int)tok["returncode"];</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➍return stat;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos673361" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-24: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetScanStatus()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">We use the <span class="calibre4">ExecuteGet()</span> method we defined earlier to retrieve the <span class="calibre4">/scan/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/status</span> API endpoint ➊, which returns a JSON object with information about the task’s scan status. After calling the API endpoint, we create a new <span class="calibre4">SqlmapStatus</span> object ➋ and assign the <span class="calibre4">status</span> value from the API call to the <span class="calibre4">Status</span> property. If the <span class="calibre4">returncode</span> JSON value isn’t null ➌, we cast it to an integer and assign the result to the <span class="calibre4">ReturnCode</span> property. Finally, we return ➍ the <span class="calibre4">SqlmapStatus</span> object to the caller.</p><p id="filepos674358" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The New Main() Method</span></span></span></p><p class="calibre_11">Now we’ll add the logic to the command line application so that we can scan the vulnerable Search page within BadStore that we exploited in <a href="index_split_007.html#filepos114239">Chapter 2</a> and monitor the scan. Begin by adding the code shown in <a href="#filepos675728">Listing 9-25</a> to the <span class="calibre4">Main()</span> method before you call <span class="calibre4">DeleteTask</span>.</p><blockquote class="calibre_14"><span class="calibre4"> options["url"] = ➊"</span><span class="calibre4"><span class="bold">http://192.168.1.75/cgi-bin/badstore.cgi?</span></span><span class="calibre4">" +</span><br class="calibre5"/><span class="calibre4"> "</span><span class="calibre4"><span class="bold">searchquery=fdsa&amp;action=search</span></span><span class="calibre4">";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➋mgr.StartTask(taskID, options);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➌SqlmapStatus status = mgr.GetScanStatus(taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➍while (status.Status != "terminated")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.Sleep(new TimeSpan(0,0,10));</span><br class="calibre5"/><span class="calibre4"> status = mgr.GetScanStatus(taskID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">➎ Console.WriteLine("Scan finished!"); </span><a id="filepos675728"/><span class="calibre4"><span class="italic">Listing 9-25: Starting a scan and watching it finish in the main sqlmap application</span></span></blockquote><p class="calibre_6">Replace the IP address ➊ with that of the BadStore you wish to scan. After the application assigns the <span class="calibre4">url</span> key in the <span class="calibre4">options</span> dictionary, it will start the task with the new options ➋ and get the scan status ➌, which should be <span class="calibre4">running</span>. Then, the application will loop ➍ until the status of the scan is <span class="calibre4">terminated</span>, which means the scan has finished. The application will print <span class="calibre4">"Scan finished!"</span> ➎ once it exits the loop.</p><p id="filepos676446" class="calibre_10"><span class="calibre3"><span class="bold">Reporting on a Scan</span></span></p><p class="calibre_11">To see if sqlmap was able to exploit any of the vulnerable parameters, we’ll create a <span class="calibre4">SqlmapLogItem</span> class to retrieve the scan log, as shown in <a href="#filepos677165">Listing 9-26</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SqlmapLogItem</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public string Message { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Level { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Time { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos677165" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-26: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SqlmapLogItem</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">This class has only three properties: <span class="calibre4">Message</span>, <span class="calibre4">Level</span>, and <span class="calibre4">Time</span>. The <span class="calibre4">Message</span> property contains the message describing the log item. <span class="calibre4">Level</span> controls how much information sqlmap will print in the report, which will be <span class="calibre4">Error</span>, <span class="calibre4">Warn</span>, or <span class="calibre4">Info</span>. Each log item has only one of these levels, which makes it easy to search for specific types of log items later (say, when you just want to print the errors but not the warnings or informational items). Errors are generally fatal, while warnings mean something seems wrong but sqlmap can keep going. Informational items are just that: basic information about what the scan is doing or finding, such as the type of injection being tested for. Finally, <span class="calibre4">Time</span> is the time the item was logged.</p><p class="calibre_6">Next, we implement the <span class="calibre4">GetLog()</span> method to return a list of these <span class="calibre4">SqlmapLogItems</span> and then retrieve the log by executing a GET request on the <span class="calibre4">/scan/</span><span class="calibre4"><span class="italic">taskid</span></span><span class="calibre4">/log</span> endpoint, as shown in <a href="#filepos679681">Listing 9-27</a>.</p><blockquote class="calibre_14"><span class="calibre4">public List&lt;SqlmapLogItem&gt; GetLog(string taskid)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> JObject tok = JObject.Parse(session.➊ExecuteGet("/scan/" + taskid + "/log"));</span><br class="calibre5"/><span class="calibre4"> JArray items = tok ["log"]➋ as JArray;</span><br class="calibre5"/><span class="calibre4"> List&lt;SqlmapLogItem&gt; logItems = new List&lt;SqlmapLogItem&gt;();</span><br class="calibre5"/><span class="calibre4"> ➌foreach (var item in items)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➍SqlmapLogItem i = new SqlmapLogItem(); i.Message = (string)item["message"];</span><br class="calibre5"/><span class="calibre4"> i.Level = (string)item["level"];</span><br class="calibre5"/><span class="calibre4"> i.Time = (string)item["time"];</span><br class="calibre5"/><span class="calibre4"> logItems.Add(i);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> ➎return logItems;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos679681" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-27: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetLog()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The first thing we do in the <span class="calibre4">GetLog()</span> method is make the request to the endpoint ➊ and parse the request into a <span class="calibre4">JObject</span>. The <span class="calibre4">log</span> key ➋ has an array of items as its value, so we pull its value as a <span class="calibre4">JArray</span> using the <span class="calibre4">as</span> operator and assign it to the <span class="calibre4">items</span> variable ➌. This may be the first time you have seen the <span class="calibre4">as</span> operator. My main reason for using it is readability, but the primary difference between the <span class="calibre4">as</span> operator and explicit casting is that <span class="calibre4">as</span> will return null if the object to the left cannot be cast to the type on the right. You can’t use it on value types because value types can’t be null.</p><p class="calibre_6">Once we have an array of log items, we create a list of <span class="calibre4">SqlmapLogItems</span>. We loop over each item in the array and instantiate a new <span class="calibre4">SqlmapLogItem</span> each time ➍. Then we assign the new object the value in the log item returned by <span class="calibre4">sqlmap</span>. Finally, we add the log item to the list and return the list to the caller method ➎.</p><p id="filepos681181" class="calibre_10"><span class="calibre3"><span class="bold">Automating a Full sqlmap Scan</span></span></p><p class="calibre_11">We’ll call <span class="calibre4">GetLog()</span> from the console application after the scan terminates and print the log messages to the screen. Your application’s logic should look like <a href="#filepos683137">Listing 9-28</a> now.</p><blockquote class="calibre_14"><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> using (SqlmapSession session = new SqlmapSession("127.0.0.1", 8775))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (SqlmapManager manager = new SqlmapManager(session))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string taskid = manager.NewTask();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Dictionary&lt;string, object&gt; options = manager.GetOptions(taskid);</span><br class="calibre5"/><span class="calibre4"> options["url"] = args[0];</span><br class="calibre5"/><span class="calibre4"> options["flushSession"] = true;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> manager.StartTask(taskid, options);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> SqlmapStatus status = manager.GetScanStatus(taskid);</span><br class="calibre5"/><span class="calibre4"> while (status.Status != "terminated")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.Sleep(new TimeSpan(0,0,10));</span><br class="calibre5"/><span class="calibre4"> status = manager.GetScanStatus(taskid);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> List&lt;SqlmapLogItem&gt; logItems = manager.➊GetLog(taskid);</span><br class="calibre5"/><span class="calibre4"> foreach (SqlmapLogItem item in logItems)</span><br class="calibre5"/><span class="calibre4"> ➋Console.WriteLine(item.Message);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> manager.DeleteTask(taskid);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos683137" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-28: The full</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method to automate sqlmap to scan a URL</span></span></p><p class="calibre_6">After adding the call to <span class="calibre4">GetLog()</span> ➊ to the end of the sqlmap main application, we can iterate over the log messages and print them to the screen ➋ for us to see when the scan is finished. Finally, we are ready to run the full sqlmap scan and retrieve the results. Passing the BadStore URL as an argument to the application will send the scan request to sqlmap. The results should look something like <a href="#filepos686144">Listing 9-29</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch9_automating_sqlmap.exe "http://10.37.129.3/cgi-bin/badstore.cgi?</span></span><br class="calibre5"/><span class="calibre4"><span class="bold">searchquery=fdsa&amp;action=search"</span></span><br class="calibre5"/><span class="calibre4">flushing session file</span><br class="calibre5"/><span class="calibre4">testing connection to the target URL</span><br class="calibre5"/><span class="calibre4">heuristics detected web page charset 'windows-1252'</span><br class="calibre5"/><span class="calibre4">checking if the target is protected by some kind of WAF/IPS/IDS</span><br class="calibre5"/><span class="calibre4">testing if the target URL is stable</span><br class="calibre5"/><span class="calibre4">target URL is stable</span><br class="calibre5"/><span class="calibre4">testing if GET parameter 'searchquery' is dynamic</span><br class="calibre5"/><span class="calibre4">confirming that GET parameter 'searchquery' is dynamic</span><br class="calibre5"/><span class="calibre4">GET parameter 'searchquery' is dynamic</span><br class="calibre5"/><span class="calibre4">heuristics detected web page charset 'ascii'</span><br class="calibre5"/><span class="calibre4">heuristic (basic) test shows that GET parameter 'searchquery' might be</span><br class="calibre5"/><span class="calibre4">injectable</span><br class="calibre5"/><span class="calibre4"> (possible DBMS: 'MySQL')</span><br class="calibre5"/><span class="calibre4"><span class="italic">–-snip--</span></span><br class="calibre5"/><span class="calibre4">GET parameter 'searchquery➊' seems to be 'MySQL &lt;= 5.0.11 OR time-based blind</span><br class="calibre5"/><span class="calibre4">(heavy query)' injectable</span><br class="calibre5"/><span class="calibre4">testing 'Generic UNION query (NULL) - 1 to 20 columns'</span><br class="calibre5"/><span class="calibre4">automatically extending ranges for UNION query injection technique tests as</span><br class="calibre5"/><span class="calibre4">there is at least one other (potential) technique found</span><br class="calibre5"/><span class="calibre4">ORDER BY technique seems to be usable. This should reduce the time needed to</span><br class="calibre5"/><span class="calibre4">find the right number of query columns. Automatically extending the range for</span><br class="calibre5"/><span class="calibre4">current UNION query injection technique test</span><br class="calibre5"/><span class="calibre4">target URL appears to have 4 columns in query</span><br class="calibre5"/><span class="calibre4">GET parameter 'searchquery➋' is 'Generic UNION query (NULL) - 1 to 20</span><br class="calibre5"/><span class="calibre4">columns' injectable</span><br class="calibre5"/><span class="calibre4">the back-end DBMS is MySQL➌</span></blockquote><p id="filepos686144" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-29: Running the sqlmap application on a vulnerable BadStore URL</span></span></p><p class="calibre_6">It works! The output from sqlmap can be very verbose and potentially confusing for someone not used to reading it. But even though it can be a lot to take in, there are key points to look for. As you can see in the output, sqlmap finds that the <span class="calibre4">searchquery</span> parameter is vulnerable to a time-based SQL injection ➊, that there is a <span class="calibre4">UNION</span>-based SQL injection ➋, and that the database is MySQL ➌. The rest of the messages are information regarding what sqlmap is doing during the scan. With these results, we can definitely say this URL is vulnerable to at least two SQL injection techniques.</p><p id="filepos686977" class="calibre_10"><span class="calibre3"><span class="bold">Integrating sqlmap with the SOAP Fuzzer</span></span></p><p class="calibre_11">We have now seen how to use the sqlmap API to audit and exploit a simple URL. In <a href="index_split_007.html#filepos114239">Chapters 2</a> and <a href="index_split_008.html#filepos243384">3</a>, we wrote a few fuzzers for vulnerable GET and POST requests in SOAP endpoints and JSON requests. We can use the information we gather from our fuzzers to drive sqlmap and, with only a few more lines of code, go from finding potential vulnerabilities to fully validating and exploiting them.</p><p id="filepos687579" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Adding sqlmap GET Request Support to the SOAP Fuzzer</span></span></span></p><p class="calibre_11">Only two types of HTTP requests are made in the SOAP fuzzer: GET and POST requests. First, we add support to our fuzzer so it will send URLs with GET parameters to sqlmap. We also want the ability to tell sqlmap which parameter we think is vulnerable. We add the methods <span class="calibre4">TestGetRequestWithSqlmap()</span> and <span class="calibre4">TestPostRequestWithSqlmap()</span> to the bottom of the SOAP fuzzer console application to test GET and POST requests, respectively. We’ll also update the <span class="calibre4">FuzzHttpGetPort()</span>, <span class="calibre4">FuzzSoapPort()</span>, and <span class="calibre4">FuzzHttpPostPort()</span> methods in a later section to use the two new methods.</p><p class="calibre_6">Let’s start by writing the <span class="calibre4">TestGetRequestWithSqlmap()</span> method, shown in <a href="#filepos689714">Listing 9-30</a>.</p><blockquote class="calibre_14"><span class="calibre4">static void TestGetRequestWithSqlmap(string url, string parameter)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Testing url with sqlmap: " + url);</span><br class="calibre5"/><span class="calibre4"> ➊using (SqlmapSession session = new SqlmapSession("127.0.0.1", 8775))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (SqlmapManager manager = new SqlmapManager(session))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➋string taskID = manager.NewTask();</span><br class="calibre5"/><span class="calibre4"> ➌var options = manager.GetOptions(taskID);</span><br class="calibre5"/><span class="calibre4"> options["url"] = url;</span><br class="calibre5"/><span class="calibre4"> options["level"] = 1;</span><br class="calibre5"/><span class="calibre4"> options["risk"] = 1;</span><br class="calibre5"/><span class="calibre4"> options["dbms"] = ➍"postgresql";</span><br class="calibre5"/><span class="calibre4"> options["testParameter"] = ➎parameter;</span><br class="calibre5"/><span class="calibre4"> options["flushSession"] = true;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> manager.➏StartTask(taskID, options); </span><a id="filepos689714"/><span class="calibre4"><span class="italic">Listing 9-30: First half of the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">TestGetRequestWithSqlmap()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></blockquote><p class="calibre_6">The first half of the method creates our <span class="calibre4">SqlmapSession</span> ➊ and <span class="calibre4">SqlmapManager</span> objects, which we call <span class="calibre4">session</span> and <span class="calibre4">manager</span>, respectively. Then it creates a new task ➋ and retrieves and sets up the sqlmap options for our scan ➌. We explicitly set the DBMS to PostgreSQL ➍ since we know the SOAP service uses PostgreSQL. This saves us some time and bandwidth by testing only PostgreSQL payloads. We also set the <span class="calibre4">testParameter</span> option to the parameter we decided is vulnerable ➎ after previously testing it with a single apostrophe and receiving an error from the server. We then pass the task ID and the options to the <span class="calibre4">StartTask()</span> method ➏ of <span class="calibre4">manager</span> to begin the scan.</p><p class="calibre_6"><a href="#filepos691903">Listing 9-31</a> details the second half of the <span class="calibre4">TestGetRequestWithSqlmap()</span> method, similar to the code we wrote in <a href="#filepos675728">Listing 9-25</a>.</p><blockquote class="calibre_14"><span class="calibre4"> SqlmapStatus status = manager.GetScanStatus(taskid);</span><br class="calibre5"/><span class="calibre4"> while (status.Status != ➊"terminated")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.Sleep(new TimeSpan(0,0,10));</span><br class="calibre5"/><span class="calibre4"> status = manager.GetScanStatus(taskID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> List&lt;SqlmapLogItem&gt; logItems = manager.➋GetLog(taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (SqlmapLogItem item in logItems)</span><br class="calibre5"/><span class="calibre4"> Console.➌WriteLine(item.Message);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> manager.➍DeleteTask(taskID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos691903" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-31: The second half of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">TestGetRequestWithSqlmap()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The second half of the method watches the scan until it is finished, just like in our original test application. Since we have written similar code before, I won’t go over every line. After waiting until the scan is finished running ➊, we retrieve the scan results using <span class="calibre4">GetLog()</span> ➋. We then write the scan results to the screen ➌ for the user to see. Finally, the task is deleted when the task ID is passed to the <span class="calibre4">DeleteTask()</span> method ➍.</p><p id="filepos692687" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Adding sqlmap POST Request Support</span></span></span></p><p class="calibre_11">The <span class="calibre4">TestPostRequestWithSqlmap()</span> method is a bit more complex than its companion. <a href="#filepos694132">Listing 9-32</a> shows the beginning lines of the method.</p><blockquote class="calibre_14"><span class="calibre4">static void TestPostRequestWithSqlmap(➊string url, string data,</span><br class="calibre5"/><span class="calibre4"> string soapAction, string vulnValue)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➋Console.WriteLine("Testing url with sqlmap: " + url);</span><br class="calibre5"/><span class="calibre4">➌using (SqlmapSession session = new SqlmapSession("127.0.0.1", 8775))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (SqlmapManager manager = new SqlmapManager(session))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➍string taskID = manager.NewTask();</span><br class="calibre5"/><span class="calibre4"> var options = manager.GetOptions(taskID);</span><br class="calibre5"/><span class="calibre4"> options["url"] = url;</span><br class="calibre5"/><span class="calibre4"> options["level"] = 1;</span><br class="calibre5"/><span class="calibre4"> options["risk"] = 1;</span><br class="calibre5"/><span class="calibre4"> options["dbms"] = "postgresql";</span><br class="calibre5"/><span class="calibre4"> options["data"] = data.➎Replace(vulnValue, "*").Trim();</span><br class="calibre5"/><span class="calibre4"> options["flushSession"] = "true"; </span><a id="filepos694132"/><span class="calibre4"><span class="italic">Listing 9-32: Beginning lines of the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">TestPostRequestWithSqlmap()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></blockquote><p class="calibre_6">The <span class="calibre4">TestPostRequestWithSqlmap()</span> method accepts four arguments ➊. The first argument is the URL that will be sent to sqlmap. The second argument is the data that will be in the post body of the HTTP request—be it POST parameters or SOAP XML. The third argument is the value that will be passed in the <span class="calibre4">SOAPAction</span> header in the HTTP request. The last argument is the unique value that is vulnerable. It will be replaced with an asterisk in the data from the second argument before being sent to sqlmap to fuzz.</p><p class="calibre_6">After we print a message to the screen to tell the user which URL is being tested ➋, we create our <span class="calibre4">SqlmapSession</span> and <span class="calibre4">SqlmapManager</span> objects ➌. Then, as before, we create a new task and set the current options ➍. Pay special attention to the data option ➎. This is where we replace the vulnerable value in the post data with an asterisk. The asterisk is a special notation in sqlmap that says, “Ignore any kind of smart parsing of the data and just search for a SQL injection in this specific spot.”</p><p class="calibre_6">We still need to set one more option before we can start the task. We need to set the correct content type and SOAP action in the HTTP headers in the request. Otherwise, the server will just return 500 errors. This is what the next part of the method does, as detailed in <a href="#filepos696464">Listing 9-33</a>.</p><blockquote class="calibre_14"><span class="calibre4"> string headers = string.Empty;</span><br class="calibre5"/><span class="calibre4"> if (!string.➊IsNullOrWhitespace(soapAction))</span><br class="calibre5"/><span class="calibre4"> headers = "Content-Type: text/xml\nSOAPAction: " + ➋soapAction;</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> headers = "Content-Type: application/x-www-form-urlencoded";</span><br class="calibre5"/><span class="calibre4"> options["headers"] = ➌headers;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> manager.StartTask(taskID, options); </span><a id="filepos696464"/><span class="calibre4"><span class="italic">Listing 9-33: Setting the right headers in the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">TestPostRequestWithSqlmap()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></blockquote><p class="calibre_6">If the <span class="calibre4">soapAction</span> variable ➋ (the value we want in the <span class="calibre4">SOAPAction</span> header telling the SOAP server the action we want to perform) is null or an empty string ➊, we can assume this is not an XML request but rather a POST parameter request. The latter only requires the correct <span class="calibre4">Content-Type</span> to be set to <span class="calibre4">x-www-form-urlencoded</span>. If <span class="calibre4">soapAction</span> is not an empty string, however, we should assume we are dealing with an XML request and then set the <span class="calibre4">Content-Type</span> to <span class="calibre4">text/xml</span> and add a <span class="calibre4">SOAPAction</span> header with the <span class="calibre4">soapAction</span> variable as the value. After setting the correct headers in the scan options ➌, we finally pass the task ID and the options to the <span class="calibre4">StartTask()</span> method.</p><p class="calibre_6">The rest of the method, shown in <a href="#filepos698752">Listing 9-34</a>, should look familiar. It just watches the scan and returns the results, much as does the <span class="calibre4">TestGetRequestWithSqlmap()</span> method.</p><blockquote class="calibre_14"><span class="calibre4"> SqlmapStatus status = manager.➊GetScanStatus(taskID);</span><br class="calibre5"/><span class="calibre4"> while (status.Status != "terminated")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.➋Sleep(new TimeSpan(0,0,10));</span><br class="calibre5"/><span class="calibre4"> status = manager.GetScanStatus(taskID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> List&lt;SqlmapLogItem&gt; logItems = manager.➌GetLog(taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (SqlmapLogItem item in logItems)</span><br class="calibre5"/><span class="calibre4"> Console.➍WriteLine(item.Message);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> manager.➎DeleteTask(taskID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos698752" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-34: The final lines in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">TestPostRequestWithSqlmap()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">This is exactly like the code in <a href="#filepos675728">Listing 9-25</a>. We use the <span class="calibre4">GetScanStatus()</span> method ➊ to retrieve the current status of the task, and while the status isn’t terminated, we sleep for 10 seconds ➋. Then we get the status again. Once finished, we pull the log items ➌ and iterate over each item, printing the log message ➍. Finally, we delete the task ➎ when all is done.</p><p id="filepos699472" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Calling the New Methods</span></span></span></p><p class="calibre_11">In order to complete our utility, we need to call these new methods from their respective fuzzing methods in the SOAP fuzzer. First, we update the <span class="calibre4">FuzzSoapPort()</span> method that we made in <a href="index_split_008.html#filepos243384">Chapter 3</a> by adding the method call for <span class="calibre4">TestPostRequestWithSqlmap()</span> into the <span class="calibre4">if</span> statement that tests whether a syntax error has occurred due to our fuzzing, as shown in <a href="#filepos700608">Listing 9-35</a>.</p><blockquote class="calibre_14"><span class="calibre4"> if (➊resp.Contains("syntax error"))</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Console.➋WriteLine("Possible SQL injection vector in parameter: " +</span><br class="calibre5"/><span class="calibre4"> type.Parameters[k].Name);</span><br class="calibre5"/><span class="calibre4">➌TestPostRequestWithSqlmap(_endpoint, soapDoc.ToString(),</span><br class="calibre5"/><span class="calibre4"> op.SoapAction, parm.ToString());</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos700608" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-35: Adding support to use sqlmap to the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FuzzSoapPort()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method in the SOAP fuzzer from </span></span><a href="index_split_008.html#filepos243384"><span class="calibre4"><span class="italic">Chapter 3</span></span></a></p><p class="calibre_6">In our original SOAP fuzzer in the <span class="calibre4">FuzzSoapPort()</span> method at the very bottom, we tested whether the response came back with an error message reporting a syntax error ➊. If so, we printed the injection vector ➋ for the user. To make the <span class="calibre4">FuzzSoapPort()</span> method use our new method for testing a POST request with sqlmap, we just need to add a single line after the original <span class="calibre4">WriteLine()</span> method call printing the vulnerable parameter. Add a line that calls the <span class="calibre4">TestPostRequestWithSqlmap()</span> method ➌, and your fuzzer will automatically submit potentially vulnerable requests to sqlmap for processing.</p><p class="calibre_6">Similarly, we update the <span class="calibre4">FuzzHttpGetPort()</span> method in the <span class="calibre4">if</span> statement testing for a syntax error in the HTTP response, as shown in <a href="#filepos702356">Listing 9-36</a>.</p><blockquote class="calibre_14"><span class="calibre4">if (resp.Contains("syntax error"))</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Possible SQL injection vector in parameter: " +</span><br class="calibre5"/><span class="calibre4"> input.Parts[k].Name);</span><br class="calibre5"/><span class="calibre4"> TestGetRequestWithSqlmap(url, input.Parts[k].Name);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos702356" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-36: Adding sqlmap support to the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FuzzHttpGetPort()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method from the SOAP fuzzer</span></span></p><p class="calibre_6">Finally, we update the <span class="calibre4">if</span> statement testing for the syntax error in <span class="calibre4">FuzzHttpPostPort()</span> just as simply, as <a href="#filepos703295">Listing 9-37</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">if (resp.Contains("syntax error"))</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Possible SQL injection vector in parameter: " +</span><br class="calibre5"/><span class="calibre4"> input.Parts[k].Name);</span><br class="calibre5"/><span class="calibre4"> TestPostRequestWithSqlmap(url, testParams, null, guid.ToString());</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos703295" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-37: Adding sqlmap support to the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FuzzHttpPostPort()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method from the SOAP fuzzer</span></span></p><p class="calibre_6">With these lines added to the SOAP fuzzer, it should now not only output potentially vulnerable parameters but also any of the SQL injection techniques sqlmap was able to use to exploit the vulnerabilities.</p><p class="calibre_6">Running the updated SOAP fuzzer tool in your IDE or in a terminal should yield new information printed to the screen regarding sqlmap, as <a href="#filepos704856">Listing 9-38</a> shows.</p><blockquote class="calibre_14"><span class="calibre4"> $ </span><span class="calibre4"><span class="bold">mono ./ch9_automating_sqlmap_soap.exe http://172.18.20.40/Vulnerable.asmx</span></span><br class="calibre5"/><span class="calibre4"> Fetching the WSDL for service: http://172.18.20.40/Vulnerable.asmx</span><br class="calibre5"/><span class="calibre4"> Fetched and loaded the web service description.</span><br class="calibre5"/><span class="calibre4"> Fuzzing service: VulnerableService</span><br class="calibre5"/><span class="calibre4"> Fuzzing soap port: VulnerableServiceSoap</span><br class="calibre5"/><span class="calibre4"> Fuzzing operation: AddUser</span><br class="calibre5"/><span class="calibre4"> Possible SQL injection vector in parameter: username</span><br class="calibre5"/><span class="calibre4">➊ Testing url with sqlmap: http://172.18.20.40/Vulnerable.asmx</span><br class="calibre5"/><span class="calibre4">
</span><span class="calibre4"><span class="italic">--snip--</span></span></blockquote><p id="filepos704856" class="calibre_15"><span class="calibre4"><span class="italic">Listing 9-38: Running the updated SOAP fuzzer with sqlmap support against the vulnerable SOAP service from </span></span><a href="index_split_008.html#filepos243384"><span class="calibre4"><span class="italic">Chapter 3</span></span></a></p><p class="calibre_6">In the SOAP fuzzer output, note the new lines regarding testing the URL with sqlmap ➊. Once sqlmap has finished testing the SOAP request, the sqlmap log should be printed to the screen for the user to see the results.</p><p id="filepos705368" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">In this chapter, you saw how to wrap the functionality of the sqlmap API into easy-to-use C# classes to create a small application that starts basic sqlmap scans against URLs passed as an argument. After we created the basic sqlmap application, we added sqlmap support to the SOAP fuzzer from <a href="index_split_008.html#filepos243384">Chapter 3</a> to make a tool that automatically exploits and reports on potentially vulnerable HTTP requests.</p><p class="calibre_6">The sqlmap API can use any argument that the command line–based sqlmap tool can, making it just as powerful, if not more so. With sqlmap, you can use your C# skills to automatically retrieve password hashes and database users after verifying that a given URL or HTTP request is indeed vulnerable. We’ve only scratched the surface of sqlmap’s power for offensive pentesters or security-minded developers looking for more exposure to the tools hackers use. Hopefully, you can take the time to learn the more subtle nuances of the sqlmap features to really bring flexible security practices to your work.</p><div class="mbp_pagebreak" id="calibre_pb_14"/>
</body></html>