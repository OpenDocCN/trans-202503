- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BUILDING
    THE MIDDLEWARE</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The middleware is the software glue connecting the frontend we’ll create later
    to the existing MongoDB instance in the backend container. In this chapter, we’ll
    set up Mongoose, connect it to our database, and then create a Mongoose model
    for the application. In the next chapter, we’ll complete the middleware by writing
    a GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: This middleware is part of Next.js; hence, we’ll work with the application container.
    But because the Docker daemon ensures that the files in our local application
    directory are instantly available within the working directory inside the application
    container, we can use our local code editor or IDE to modify files on our local
    machine. There is no need to connect to the container shell, let alone interact
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose</samp>; you
    should see all changes instantly on *http://localhost:3000*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring Next.js to Use Absolute
    Imports</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we write our first line of code in Next.js, let’s make a minor adjustment
    to the Next.js configuration. We want the paths of any module imports to be *absolute*,
    meaning they start from the application’s root folder rather than the location
    of the file that is importing them. The imports in [Listing 12-1](chapter12.xhtml#Lis12-1),
    which come from the *pages/api/graphql.ts* file we created in [Chapter 6](chapter6.xhtml),
    are examples of relative imports.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: The import statements in pages/api/graphql.ts'
  prefs: []
  type: TYPE_NORMAL
- en: You should see that they start from the file’s location, then go up two levels
    to the root folder, and finally find the *graphql* folder containing the *resolvers*
    and *schema* TypeScript files.
  prefs: []
  type: TYPE_NORMAL
- en: The more complex our application becomes, the more levels of nesting we’ll have,
    and the more inconvenient we’ll find this manual traversing of the directories
    up to the root folder. This is why we want to use absolute imports that start
    directly from the root folder, as shown in [Listing 12-2](chapter12.xhtml#Lis12-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: The absolute import statements for pages/api/graphql.ts'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don’t need to traverse up to the root level before importing
    files. To achieve this, open the *tsconfig.json* file that <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp>
    created in the application’s code root directory, *code/foodfinder-application*,
    on your local machine, and add a line that sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">baseUrl</samp>
    to the root folder ([Listing 12-3](chapter12.xhtml#Lis12-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Using absolute URLs'
  prefs: []
  type: TYPE_NORMAL
- en: Restart the application’s container, as well as the Next.js application, with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose restart foodfinder-application</samp>
    in a new command line tab.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Connecting Mongoose</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it’s time to start working on the middleware. We’ll begin by adding Mongoose
    to the application. Connect to the application’s container terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we use <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install mongoose</samp>
    to install the package. As long as the containers are running, we don’t need to
    rebuild the frontend image immediately, as we’ve installed the packages directly
    into the running container.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Database
    Connection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To connect the Next.js application to the MongoDB instance, we’ll define the
    environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_URI</samp>
    and assign it a connection string that matches the backend’s exposed port and
    location. Create a new *.env.local* file in the application’s root directory,
    next to the *tsconfig.json* file, and add this line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we can connect the application to the MongoDB instance that the Docker container
    exposes on port 27017\. Create a folder, *middleware*, in the root folder *code/foodfinder-application*.
    Here we’ll place all the middleware-related TypeScript files. Create a new file,
    *db-connect.ts*, in this folder and paste in the code from [Listing 12-4](chapter12.xhtml#Lis12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: The TypeScript code to connect the application to the database
    in db-connect.ts'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *mongoose* package and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectOptions</samp>
    type, both of which we need to connect to the database. We then load the connection
    string from the environment variables and verify that the string is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up our connection cache. We use a global variable to maintain the
    connection across hot-reloads and ensure that multiple calls to our <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function always return the same connection. Otherwise, there is the risk that
    our application will create new connections during each hot-reload or on each
    call of the function, both of which would fill up our memory quickly. If there’s
    no cached connection, we initialize it with a dummy object.
  prefs: []
  type: TYPE_NORMAL
- en: We create the asynchronous function <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>,
    which actually opens and handles the connection. The database is remote and not
    instantly available, so we use an async function that we export as the module’s
    default function. Inside the function’s body, we first check for an already existing
    cached connection and directly return any existing ones. Otherwise, we create
    a new one. Therefore, we define the connection options, and then we create a new
    connection; here, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">promise</samp>
    pattern to remind us of the two possible ways to handle asynchronous calls. Finally,
    we <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> the connection to
    be available, and then return the Mongoose instance.
  prefs: []
  type: TYPE_NORMAL
- en: To open a cached connection to MongoDB through Mongoose, we can now import the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function from the
    *middleware/db-connect* module and await the Mongoose connection.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing the TypeScript
    Warning</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In your IDE, you should immediately see that TSC warns us about using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>. A closer look
    at the message, <samp class="SANS_TheSansMonoCd_W5Regular_11">Element implicitly
    has an 'any' type because type 'typeof globalThis' has no index signature.ts (7017)</samp>,
    tells us that we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>
    property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">globalThis</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 3](chapter3.xhtml), we use the *custom.d.ts* file
    to define custom global types. Create a new file, *custom.d.ts*, next to the *middleware*
    folder in the root directory. As soon as you paste the code from [Listing 12-5](chapter12.xhtml#Lis12-5)
    into it, the global namespace should contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>
    property typed as <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>,
    and TSC can find it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: The code in custom.d.ts used to define the custom global type
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mongoose</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: With the custom global type definition in place, the TSC should no longer complain
    about the missing type definition for <samp class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>.
    We can move on to create the Mongoose model for our full-stack application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Mongoose Model</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our application has one database containing a collection of documents representing
    location data, as you saw in the seed script from [Chapter 11](chapter11.xhtml).
    We’ll create a Mongoose model for this location collection. In [Chapter 7](chapter7.xhtml),
    you learned that this requires having an interface to type the documents for TypeScript,
    a schema to describe the documents for the model, a type definition, and a set
    of custom types to define the Mongoose model. In addition, we’ll create a set
    of custom types to perform the CRUD operations on the locations model for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Create a *mongoose* folder with the subfolder *locations* next to the *middleware*
    folder in Next.js’s root directory. The *mongoose* folder will host all files
    relevant to Mongoose in general, and the *locations* folder will contain all files
    specific to the location model.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Schema</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 7](chapter7.xhtml), you learned that the schema describes the structure
    of a database’s documents and that you need to create a TypeScript interface before
    creating a schema so that you can type the schema and model accordingly. Technically,
    in versions of Mongoose later than 6.3.1, we don’t need to define this interface
    by ourselves. Instead, we can automatically infer the interface as a type from
    the schema. Create the file *schema.ts* inside the *mongoose/locations* folder
    and paste the code from [Listing 12-6](chapter12.xhtml#Lis12-6) into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-6: The mongoose/locations/schema.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp> constructor
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InferSchemaType</samp>, the
    function for inferring the schema type, both of which are part of the Mongoose
    module. Then we define and directly export the schema. The schema itself is straightforward.
    A document in the location collection has a few self-explanatory properties that
    are all typed as strings except for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property, which is an array of strings. To keep the application simple, we will
    store the IDs of users who added a particular location to their wish list directly
    in a location’s document instead of creating a new Mongoose model and MongoDB
    document for each user’s wish list. This isn’t a great design for a real application,
    but it’s fine for our purposes. Lastly, we infer and export the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>
    directly from the schema instead of creating the interface manually.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location
    Model</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the schema and required interface in place, it’s time to create the model.
    Create the file *model.ts* in the *mongoose/location* folder and paste the code
    from [Listing 12-7](chapter12.xhtml#Lis12-7) into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-7: The mongoose/locations/model.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the required dependencies from the Mongoose package, we import
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationSchema</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp> from the *schema.ts*
    file we created previously. Then we use these to create and export our locations
    model, unless there is already a model called *locations* initialized and present.
    In this case, we return the existing one.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve successfully created the Mongoose model and connected it
    to the database. We can now access the MongoDB instance and create, read, update,
    and delete documents in the locations collection through Mongoose’s API.
  prefs: []
  type: TYPE_NORMAL
- en: To test that everything is working, try creating a temporary REST API that initializes
    a connection to the database and then queries all documents through the model.
    You can make this new file, *test-middleware.ts*, in the application’s *pages/api*
    folder and paste the code from [Listing 12-8](chapter12.xhtml#Lis12-8) into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-8: A temporary REST API to test the database connection'
  prefs: []
  type: TYPE_NORMAL
- en: This API imports required dependencies from Next.js, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp>
    model we created earlier. In the asynchronous API handler, it calls the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function and waits until
    Mongoose connects to the database. Then it calls Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    API on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp> model
    with an empty filter object. Once it receives the locations, the API handler will
    send them to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If you open *http://localhost:3000/api/test-middleware*, you should see a JSON
    object with all available locations, similar to [Figure 12-1](chapter12.xhtml#fig12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 12-1: The API to test
    the middleware returns a JSON object with all locations stored in the database.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve successfully created the Mongoose model and run your first database query.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Model’s Services</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 6](chapter6.xhtml) discussed how we usually abstract database CRUD
    operations into service calls to simplify the implementation of GraphQL APIs down
    the line. This is what we’ll do now, and as a first step, let’s outline the required
    functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: We need one public service that queries all available locations so that they
    can be displayed in the app’s overview page. To display a location’s details,
    we need another public service that can find a specific location. We’ll opt to
    use the location’s ID as a parameter for the service and then look up the location
    by ID. To handle the wish list functionality, we need a service that can update
    a user’s wish list, as well as another service that we can use to decide whether
    a given location is currently on the user’s wish list; depending on the result,
    we’ll display either an Add To or Remove From button.
  prefs: []
  type: TYPE_NORMAL
- en: To design the service calls that find and return locations, we’ll create one
    public function for each public API and a unified internal function, <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>,
    that calls Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    function. The public APIs construct the filter object that Mongoose uses to filter
    the documents in the collection. In other words, it creates the database query.
    Also, it sets up additional options we’ll pass to the Mongoose API. This design
    should reduce the amount of code we need to write and prevent repetition.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location
    Service’s Custom Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may have noticed that we’ll need two custom types for the parameters to
    the unified <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>
    function. One parameter defines the properties for a <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    operation related to the wish list, and one is a location’s ID. Create the file
    *custom.d.ts* in the *mongoose/location* folder to define these types, as shown
    in [Listing 12-9](chapter12.xhtml#Lis12-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-9: The mongoose/locations/custom.d.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We define and directly export these two custom types. <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>
    is straightforward. It defines an object with one property, the location’s ID,
    which is either a string or an array of strings. We use it to find a location
    by its ID. The second type is <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>,
    which we’ll use to find all locations that contain the user’s ID in their <samp
    class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property. We set the
    value for Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">$in</samp>
    operator as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location
    Services</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve created custom types for the services, we can implement them.
    As usual, we create a file *services.ts* in the *mongoose/location* folder and
    add the code from [Listing 12-10](chapter12.xhtml#Lis12-10) to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-10: The mongoose/locations/services.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing dependencies, we create the function that will actually call
    Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> API on the
    model and await the data from the database. This function will query the database
    for all public services that use <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>,
    so it’s the foundation of all our services. Its one parameter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object, can be passed to the model’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    function to retrieve the documents that match the filter. The filter is either
    an empty object that returns all locations or one of our custom types, <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>. As
    soon as we have the data from the database, we cast it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>
    and then return it. If there is an error, we log it and then return an empty array
    to match the defined return types: either an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationTypes</samp>
    or an empty array.'
  prefs: []
  type: TYPE_NORMAL
- en: The following three functions are the public services, which will provide database
    access to other TypeScript modules and the user interface. All follow the same
    structure. First, within the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp>
    function, we set the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object to a particular parameter. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>
    function with this service-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object. Because every service calls the same function, services also have the
    same return signature, and each returns an array of locations or an empty array.
    The first uses an empty object. Hence, it filters for nothing and instead returns
    all documents from the collection. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp>
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>
    and returns the documents that match the given location IDs.
  prefs: []
  type: TYPE_NORMAL
- en: The next function, <samp class="SANS_TheSansMonoCd_W5Regular_11">onUserWishlist</samp>,
    uses a slightly more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object. It has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>,
    and we pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>
    function to get all locations whose <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    array contains the given user ID. Note that we type the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    objects explicitly upon declaration. This deviates from the advice given in [Chapter
    3](chapter3.xhtml), but we do it here to ensure that TSC verifies the object properties,
    as it cannot infer the types from their usage in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp>
    function. It is slightly different from the previous ones, but the overall structure
    should look familiar. Again, we build the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object from the first parameter, and we use the second one, the user ID, to update
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> array. Unlike
    in previous functions, however, we use another parameter to specify whether we
    want to <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp>
    the user ID to or from the array. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp>
    statement here is a convenient way to reduce the number of exposed services. Depending
    on the action parameter, we fill the update object with either the <samp class="SANS_TheSansMonoCd_W5Regular_11">$push</samp>
    operator, which adds the user ID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    array, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">$pull</samp> operator,
    which removes the user ID. We pass the object to Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">findOneAndUpdate</samp>
    API to look for the first document that matches the filter, and we directly update
    the record and then return the updated document or an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Services</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s use our temporary REST API to evaluate the services. Open the *test-middleware.ts*
    file we created earlier and update it with the code from [Listing 12-11](chapter12.xhtml#Lis12-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-11: The pages/api/test-middleware.ts file using the services'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of directly importing the model and using Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    method on it, we import the location services and query all locations with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">findAllLocations</samp> service.
    If you open the API at *http://localhost:3000/api/test-middleware* in your browser,
    you should once again see a JSON object with all available locations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve successfully created the first part of the middleware. With the code in
    this chapter, we can use a Mongoose model to create, read, update, and delete
    documents in the MongoDB collection. To perform these actions, we set up the services
    we’ll connect to our upcoming GraphQL API. In the next chapter, we’ll delete the
    temporary testing API middleware and replace it with a proper GraphQL API.
  prefs: []
  type: TYPE_NORMAL
