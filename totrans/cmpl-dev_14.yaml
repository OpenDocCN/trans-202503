- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BUILDING
    THE MIDDLEWARE</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">构建中间件</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: The middleware is the software glue connecting the frontend we’ll create later
    to the existing MongoDB instance in the backend container. In this chapter, we’ll
    set up Mongoose, connect it to our database, and then create a Mongoose model
    for the application. In the next chapter, we’ll complete the middleware by writing
    a GraphQL API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是将我们稍后创建的前端与后端容器中现有的 MongoDB 实例连接的“软件胶水”。在本章中，我们将设置 Mongoose，将其连接到我们的数据库，并为应用程序创建一个
    Mongoose 模型。在下一章中，我们将通过编写 GraphQL API 来完成中间件的构建。
- en: This middleware is part of Next.js; hence, we’ll work with the application container.
    But because the Docker daemon ensures that the files in our local application
    directory are instantly available within the working directory inside the application
    container, we can use our local code editor or IDE to modify files on our local
    machine. There is no need to connect to the container shell, let alone interact
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose</samp>; you
    should see all changes instantly on *http://localhost:3000*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件是 Next.js 的一部分，因此我们将与应用程序容器一起工作。但由于 Docker 守护进程确保我们本地应用程序目录中的文件会即时在应用程序容器内的工作目录中可用，我们可以使用本地代码编辑器或
    IDE 修改本地机器上的文件。无需连接到容器的 shell，更不需要与 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    compose</samp> 交互；你应该可以在 *http://localhost:3000* 上立即看到所有更改。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Configuring Next.js to Use Absolute
    Imports</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">配置 Next.js 以使用绝对导入</samp>
- en: Before we write our first line of code in Next.js, let’s make a minor adjustment
    to the Next.js configuration. We want the paths of any module imports to be *absolute*,
    meaning they start from the application’s root folder rather than the location
    of the file that is importing them. The imports in [Listing 12-1](chapter12.xhtml#Lis12-1),
    which come from the *pages/api/graphql.ts* file we created in [Chapter 6](chapter6.xhtml),
    are examples of relative imports.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写 Next.js 中的第一行代码之前，让我们对 Next.js 配置做一个小的调整。我们希望任何模块的导入路径都是 *绝对的*，也就是说，它们应该从应用程序的根文件夹开始，而不是从导入它们的文件的位置开始。在
    [清单 12-1](chapter12.xhtml#Lis12-1) 中的导入，来自我们在 [第 6 章](chapter6.xhtml) 创建的 *pages/api/graphql.ts*
    文件，是相对导入的例子。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 12-1: The import statements in pages/api/graphql.ts'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-1：pages/api/graphql.ts 中的导入语句
- en: You should see that they start from the file’s location, then go up two levels
    to the root folder, and finally find the *graphql* folder containing the *resolvers*
    and *schema* TypeScript files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到它们是从文件所在的位置开始的，然后向上移动两级到根文件夹，最后找到包含 *resolvers* 和 *schema* TypeScript 文件的
    *graphql* 文件夹。
- en: The more complex our application becomes, the more levels of nesting we’ll have,
    and the more inconvenient we’ll find this manual traversing of the directories
    up to the root folder. This is why we want to use absolute imports that start
    directly from the root folder, as shown in [Listing 12-2](chapter12.xhtml#Lis12-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变得越来越复杂，我们将拥有更多层次的嵌套，而且手动向上遍历目录直到根文件夹会变得越来越不方便。这就是为什么我们希望使用从根文件夹直接开始的绝对导入，如
    [清单 12-2](chapter12.xhtml#Lis12-2) 所示。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 12-2: The absolute import statements for pages/api/graphql.ts'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-2：pages/api/graphql.ts 的绝对导入语句
- en: Notice that we don’t need to traverse up to the root level before importing
    files. To achieve this, open the *tsconfig.json* file that <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp>
    created in the application’s code root directory, *code/foodfinder-application*,
    on your local machine, and add a line that sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">baseUrl</samp>
    to the root folder ([Listing 12-3](chapter12.xhtml#Lis12-3)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要在导入文件之前先遍历到根目录。为此，请打开 *tsconfig.json* 文件，该文件由 <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp>
    在应用程序的代码根目录 *code/foodfinder-application* 下创建，并添加一行代码，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">baseUrl</samp>
    设置为根文件夹 ([清单 12-3](chapter12.xhtml#Lis12-3))。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 12-3: Using absolute URLs'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-3：使用绝对 URL
- en: Restart the application’s container, as well as the Next.js application, with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose restart foodfinder-application</samp>
    in a new command line tab.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose restart foodfinder-application</samp>
    在新命令行标签页中重启应用程序的容器和 Next.js 应用程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Connecting Mongoose</samp>
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">连接Mongoose</samp>
- en: 'Now it’s time to start working on the middleware. We’ll begin by adding Mongoose
    to the application. Connect to the application’s container terminal:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始编写中间件了。我们将从将Mongoose添加到应用程序开始。连接到应用程序的容器终端：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we use <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install mongoose</samp>
    to install the package. As long as the containers are running, we don’t need to
    rebuild the frontend image immediately, as we’ve installed the packages directly
    into the running container.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">npm install mongoose</samp>来安装包。只要容器正在运行，我们就不需要立即重建前端镜像，因为我们已经将包直接安装到了运行中的容器中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Database
    Connection</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写数据库连接</samp>
- en: 'To connect the Next.js application to the MongoDB instance, we’ll define the
    environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_URI</samp>
    and assign it a connection string that matches the backend’s exposed port and
    location. Create a new *.env.local* file in the application’s root directory,
    next to the *tsconfig.json* file, and add this line to it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Next.js应用程序连接到MongoDB实例，我们需要定义环境变量<samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_URI</samp>并为其分配一个连接字符串，该字符串必须与后端暴露的端口和位置匹配。在应用程序的根目录中创建一个新的*.env.local*文件，位于*tsconfig.json*文件旁边，并向其中添加以下内容：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we can connect the application to the MongoDB instance that the Docker container
    exposes on port 27017\. Create a folder, *middleware*, in the root folder *code/foodfinder-application*.
    Here we’ll place all the middleware-related TypeScript files. Create a new file,
    *db-connect.ts*, in this folder and paste in the code from [Listing 12-4](chapter12.xhtml#Lis12-4).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将应用程序连接到Docker容器在27017端口上暴露的MongoDB实例。创建一个名为*middleware*的文件夹，放置在根文件夹*code/foodfinder-application*中。我们将在此文件夹中放置所有与中间件相关的TypeScript文件。创建一个新的文件，*db-connect.ts*，并将[清单12-4](chapter12.xhtml#Lis12-4)中的代码粘贴到该文件中。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 12-4: The TypeScript code to connect the application to the database
    in db-connect.ts'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-4：在db-connect.ts中将应用程序连接到数据库的TypeScript代码
- en: We import the *mongoose* package and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectOptions</samp>
    type, both of which we need to connect to the database. We then load the connection
    string from the environment variables and verify that the string is not empty.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了*mongoose*包和<samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectOptions</samp>类型，它们都是连接数据库所必需的。然后，我们从环境变量中加载连接字符串，并验证该字符串是否为空。
- en: Next, we set up our connection cache. We use a global variable to maintain the
    connection across hot-reloads and ensure that multiple calls to our <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function always return the same connection. Otherwise, there is the risk that
    our application will create new connections during each hot-reload or on each
    call of the function, both of which would fill up our memory quickly. If there’s
    no cached connection, we initialize it with a dummy object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置连接缓存。我们使用一个全局变量来保持连接，以便在热重载期间维持连接，并确保多次调用我们的<samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>函数时始终返回相同的连接。否则，我们的应用程序可能会在每次热重载或每次函数调用时创建新的连接，这样会迅速占满内存。如果没有缓存的连接，我们会使用一个虚拟对象来初始化它。
- en: We create the asynchronous function <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>,
    which actually opens and handles the connection. The database is remote and not
    instantly available, so we use an async function that we export as the module’s
    default function. Inside the function’s body, we first check for an already existing
    cached connection and directly return any existing ones. Otherwise, we create
    a new one. Therefore, we define the connection options, and then we create a new
    connection; here, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">promise</samp>
    pattern to remind us of the two possible ways to handle asynchronous calls. Finally,
    we <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> the connection to
    be available, and then return the Mongoose instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了异步函数<samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>，该函数实际打开并处理连接。由于数据库是远程的，并且不能立即访问，因此我们使用一个异步函数，并将其作为模块的默认函数进行导出。在函数体内，我们首先检查是否已经存在缓存的连接，并直接返回任何已存在的连接。否则，我们创建一个新的连接。因此，我们定义连接选项，然后创建一个新的连接；在这里，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">promise</samp>模式来提醒我们如何处理异步调用的两种可能方式。最后，我们<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp>连接可用后，返回Mongoose实例。
- en: To open a cached connection to MongoDB through Mongoose, we can now import the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function from the
    *middleware/db-connect* module and await the Mongoose connection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过Mongoose打开一个缓存的MongoDB连接，我们现在可以从*middleware/db-connect*模块导入<samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>函数，并等待Mongoose连接。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing the TypeScript
    Warning</samp>
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修复TypeScript警告</samp>
- en: In your IDE, you should immediately see that TSC warns us about using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>. A closer look
    at the message, <samp class="SANS_TheSansMonoCd_W5Regular_11">Element implicitly
    has an 'any' type because type 'typeof globalThis' has no index signature.ts (7017)</samp>,
    tells us that we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>
    property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">globalThis</samp>
    object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE中，你应该会立刻看到TSC警告我们使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>。对信息的仔细查看，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Element implicitly has an 'any' type because
    type 'typeof globalThis' has no index signature.ts (7017)</samp>，告诉我们需要将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>属性添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">globalThis</samp>对象中。
- en: As we discussed in [Chapter 3](chapter3.xhtml), we use the *custom.d.ts* file
    to define custom global types. Create a new file, *custom.d.ts*, next to the *middleware*
    folder in the root directory. As soon as you paste the code from [Listing 12-5](chapter12.xhtml#Lis12-5)
    into it, the global namespace should contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>
    property typed as <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>,
    and TSC can find it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](chapter3.xhtml)中讨论的那样，我们使用*custom.d.ts*文件来定义自定义全局类型。创建一个新的文件*custom.d.ts*，并将其放在根目录下的*middleware*文件夹旁边。一旦将[清单12-5](chapter12.xhtml#Lis12-5)中的代码粘贴到该文件中，全局命名空间应包含类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>的<samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>属性，并且TSC可以找到它。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 12-5: The code in custom.d.ts used to define the custom global type
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mongoose</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-5：在custom.d.ts文件中定义自定义全局类型<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mongoose</samp>的代码
- en: With the custom global type definition in place, the TSC should no longer complain
    about the missing type definition for <samp class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>.
    We can move on to create the Mongoose model for our full-stack application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了自定义全局类型定义后，TSC应该不再抱怨找不到<samp class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>的类型定义。我们可以继续创建适用于我们全栈应用的Mongoose模型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Mongoose Model</samp>
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">Mongoose模型</samp>
- en: Our application has one database containing a collection of documents representing
    location data, as you saw in the seed script from [Chapter 11](chapter11.xhtml).
    We’ll create a Mongoose model for this location collection. In [Chapter 7](chapter7.xhtml),
    you learned that this requires having an interface to type the documents for TypeScript,
    a schema to describe the documents for the model, a type definition, and a set
    of custom types to define the Mongoose model. In addition, we’ll create a set
    of custom types to perform the CRUD operations on the locations model for the
    application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序包含一个数据库，其中包含表示位置数据的文档集合，正如您在 [第 11 章](chapter11.xhtml) 的种子脚本中看到的那样。我们将为这个位置集合创建一个
    Mongoose 模型。在 [第 7 章](chapter7.xhtml) 中，您已经学习过，创建模型时需要一个接口来为 TypeScript 类型化文档，一个用于描述文档的模式，一个类型定义，以及一组自定义类型来定义
    Mongoose 模型。此外，我们还将创建一组自定义类型来执行应用程序中对位置模型的 CRUD 操作。
- en: Create a *mongoose* folder with the subfolder *locations* next to the *middleware*
    folder in Next.js’s root directory. The *mongoose* folder will host all files
    relevant to Mongoose in general, and the *locations* folder will contain all files
    specific to the location model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Next.js 根目录下，创建一个名为 *mongoose* 的文件夹，并在其中创建一个名为 *locations* 的子文件夹，放置在 *middleware*
    文件夹旁边。*mongoose* 文件夹将包含所有与 Mongoose 相关的文件，而 *locations* 文件夹将包含与位置模型相关的所有文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Schema</samp>
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建模式</samp>
- en: In [Chapter 7](chapter7.xhtml), you learned that the schema describes the structure
    of a database’s documents and that you need to create a TypeScript interface before
    creating a schema so that you can type the schema and model accordingly. Technically,
    in versions of Mongoose later than 6.3.1, we don’t need to define this interface
    by ourselves. Instead, we can automatically infer the interface as a type from
    the schema. Create the file *schema.ts* inside the *mongoose/locations* folder
    and paste the code from [Listing 12-6](chapter12.xhtml#Lis12-6) into it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](chapter7.xhtml) 中，您已经学到模式描述了数据库文档的结构，并且在创建模式之前，您需要先创建 TypeScript 接口，这样您才能为模式和模型类型化。从技术上讲，在
    Mongoose 版本 6.3.1 之后，我们不需要自己定义这个接口。相反，我们可以直接从模式中自动推断出接口类型。请在 *mongoose/locations*
    文件夹中创建一个名为 *schema.ts* 的文件，并将 [列表 12-6](chapter12.xhtml#Lis12-6) 中的代码粘贴到其中。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 12-6: The mongoose/locations/schema.ts file'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-6：mongoose/locations/schema.ts 文件
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp> constructor
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InferSchemaType</samp>, the
    function for inferring the schema type, both of which are part of the Mongoose
    module. Then we define and directly export the schema. The schema itself is straightforward.
    A document in the location collection has a few self-explanatory properties that
    are all typed as strings except for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property, which is an array of strings. To keep the application simple, we will
    store the IDs of users who added a particular location to their wish list directly
    in a location’s document instead of creating a new Mongoose model and MongoDB
    document for each user’s wish list. This isn’t a great design for a real application,
    but it’s fine for our purposes. Lastly, we infer and export the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>
    directly from the schema instead of creating the interface manually.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp> 构造函数和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InferSchemaType</samp>，这是用于推断模式类型的函数，它们都是
    Mongoose 模块的一部分。然后我们定义并直接导出模式。该模式本身是直接明了的。位置集合中的文档包含一些自解释的属性，除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    属性是一个字符串数组外，其他属性都是字符串类型。为了保持应用程序的简洁，我们将直接在位置文档中存储将某个位置添加到愿望清单中的用户 ID，而不是为每个用户的愿望清单创建新的
    Mongoose 模型和 MongoDB 文档。这对于真实的应用程序来说不是一个很好的设计，但对我们的目的来说是足够的。最后，我们直接从模式中推断并导出 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>，而不是手动创建接口。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location
    Model</samp>
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建位置模型</samp>
- en: With the schema and required interface in place, it’s time to create the model.
    Create the file *model.ts* in the *mongoose/location* folder and paste the code
    from [Listing 12-7](chapter12.xhtml#Lis12-7) into it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式和所需接口完成后，接下来是创建模型。请在 *mongoose/location* 文件夹中创建一个名为 *model.ts* 的文件，并将 [列表
    12-7](chapter12.xhtml#Lis12-7) 中的代码粘贴到其中。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-7: The mongoose/locations/model.ts file'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-7：mongoose/locations/model.ts 文件
- en: After importing the required dependencies from the Mongoose package, we import
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationSchema</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp> from the *schema.ts*
    file we created previously. Then we use these to create and export our locations
    model, unless there is already a model called *locations* initialized and present.
    In this case, we return the existing one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 Mongoose 包所需的依赖后，我们从之前创建的 *schema.ts* 文件中导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationSchema</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>。然后，我们使用这些来创建并导出我们的
    locations 模型，除非已经存在一个名为 *locations* 的模型被初始化并存在。如果是这种情况，我们将返回现有的模型。
- en: At this point, we’ve successfully created the Mongoose model and connected it
    to the database. We can now access the MongoDB instance and create, read, update,
    and delete documents in the locations collection through Mongoose’s API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经成功创建了 Mongoose 模型并将其连接到数据库。现在我们可以访问 MongoDB 实例，并通过 Mongoose 的 API 在
    locations 集合中进行创建、读取、更新和删除文档操作。
- en: To test that everything is working, try creating a temporary REST API that initializes
    a connection to the database and then queries all documents through the model.
    You can make this new file, *test-middleware.ts*, in the application’s *pages/api*
    folder and paste the code from [Listing 12-8](chapter12.xhtml#Lis12-8) into it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一切是否正常工作，尝试创建一个临时的 REST API，初始化与数据库的连接，然后通过模型查询所有文档。你可以在应用程序的*pages/api*文件夹中创建这个新文件
    *test-middleware.ts*，并将[Listing 12-8](chapter12.xhtml#Lis12-8)中的代码粘贴进去。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-8: A temporary REST API to test the database connection'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-8: 测试数据库连接的临时 REST API'
- en: This API imports required dependencies from Next.js, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp>
    model we created earlier. In the asynchronous API handler, it calls the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function and waits until
    Mongoose connects to the database. Then it calls Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    API on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp> model
    with an empty filter object. Once it receives the locations, the API handler will
    send them to the client.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 导入了 Next.js 所需的依赖，<samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    函数，以及我们之前创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp> 模型。在异步的
    API 处理程序中，它调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> 函数，并等待
    Mongoose 连接到数据库。然后，它在 <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp>
    模型上调用 Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> API，传入一个空的过滤对象。一旦接收到位置数据，API
    处理程序将其发送给客户端。
- en: If you open *http://localhost:3000/api/test-middleware*, you should see a JSON
    object with all available locations, similar to [Figure 12-1](chapter12.xhtml#fig12-1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 *http://localhost:3000/api/test-middleware*，你应该会看到一个包含所有可用位置的 JSON 对象，类似于[图12-1](chapter12.xhtml#fig12-1)。
- en: '![](../images/Figure12-1.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 12-1: The API to test
    the middleware returns a JSON object with all locations stored in the database.</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图12-1：测试中间件的 API 返回一个包含数据库中所有位置的
    JSON 对象。</samp>
- en: You’ve successfully created the Mongoose model and run your first database query.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功创建了 Mongoose 模型并执行了第一次数据库查询。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Model’s Services</samp>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">模型的服务</samp>
- en: '[Chapter 6](chapter6.xhtml) discussed how we usually abstract database CRUD
    operations into service calls to simplify the implementation of GraphQL APIs down
    the line. This is what we’ll do now, and as a first step, let’s outline the required
    functionality.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](chapter6.xhtml)讨论了我们通常如何将数据库的 CRUD 操作抽象为服务调用，以简化后续实现 GraphQL API 的过程。这正是我们接下来要做的，首先，让我们概述所需的功能。'
- en: We need one public service that queries all available locations so that they
    can be displayed in the app’s overview page. To display a location’s details,
    we need another public service that can find a specific location. We’ll opt to
    use the location’s ID as a parameter for the service and then look up the location
    by ID. To handle the wish list functionality, we need a service that can update
    a user’s wish list, as well as another service that we can use to decide whether
    a given location is currently on the user’s wish list; depending on the result,
    we’ll display either an Add To or Remove From button.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个公共服务来查询所有可用位置，以便它们可以显示在应用程序的概览页面中。为了显示位置的详细信息，我们需要另一个公共服务来查找特定位置。我们选择使用位置的
    ID 作为服务的参数，然后通过 ID 查找位置。为了处理愿望清单功能，我们需要一个服务来更新用户的愿望清单，以及另一个可以用来判断给定位置是否当前在用户愿望清单中的服务；根据结果，我们将显示“添加到”或“从中移除”按钮。
- en: To design the service calls that find and return locations, we’ll create one
    public function for each public API and a unified internal function, <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>,
    that calls Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    function. The public APIs construct the filter object that Mongoose uses to filter
    the documents in the collection. In other words, it creates the database query.
    Also, it sets up additional options we’ll pass to the Mongoose API. This design
    should reduce the amount of code we need to write and prevent repetition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计查找并返回位置的服务调用，我们将为每个公共 API 创建一个公共函数，并创建一个统一的内部函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>，该函数调用
    Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> 函数。公共 API
    构造 Mongoose 用于筛选集合中文档的过滤器对象。换句话说，它创建了数据库查询。同时，它设置了我们将传递给 Mongoose API 的附加选项。这种设计应该能减少我们需要编写的代码量，并防止重复。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location
    Service’s Custom Types</samp>
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建位置服务的自定义类型</samp>
- en: You may have noticed that we’ll need two custom types for the parameters to
    the unified <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>
    function. One parameter defines the properties for a <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    operation related to the wish list, and one is a location’s ID. Create the file
    *custom.d.ts* in the *mongoose/location* folder to define these types, as shown
    in [Listing 12-9](chapter12.xhtml#Lis12-9).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们需要两个自定义类型作为统一的 <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>
    函数的参数。一个参数定义了与愿望清单相关的 <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    操作的属性，另一个是位置的 ID。创建一个 *custom.d.ts* 文件，在 *mongoose/location* 文件夹中定义这些类型，如 [Listing
    12-9](chapter12.xhtml#Lis12-9) 所示。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 12-9: The mongoose/locations/custom.d.ts file'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-9: mongoose/locations/custom.d.ts 文件'
- en: We define and directly export these two custom types. <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>
    is straightforward. It defines an object with one property, the location’s ID,
    which is either a string or an array of strings. We use it to find a location
    by its ID. The second type is <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>,
    which we’ll use to find all locations that contain the user’s ID in their <samp
    class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property. We set the
    value for Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">$in</samp>
    operator as an array of strings.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义并直接导出这两个自定义类型。<samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>
    是直接的，它定义了一个包含位置 ID 的对象，ID 可以是一个字符串或一个字符串数组。我们用它根据 ID 查找位置。第二个类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>，我们将用它来查找所有包含用户
    ID 在其 <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> 属性中的位置。我们将
    Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">$in</samp> 操作符的值设置为字符串数组。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location
    Services</samp>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建位置服务</samp>
- en: Now that we’ve created custom types for the services, we can implement them.
    As usual, we create a file *services.ts* in the *mongoose/location* folder and
    add the code from [Listing 12-10](chapter12.xhtml#Lis12-10) to it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为服务创建了自定义类型，可以开始实现它们。像往常一样，我们在 *mongoose/location* 文件夹中创建一个 *services.ts*
    文件，并将 [Listing 12-10](chapter12.xhtml#Lis12-10) 中的代码添加到其中。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 12-10: The mongoose/locations/services.ts file'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-10: mongoose/locations/services.ts 文件'
- en: 'After importing dependencies, we create the function that will actually call
    Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> API on the
    model and await the data from the database. This function will query the database
    for all public services that use <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>,
    so it’s the foundation of all our services. Its one parameter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object, can be passed to the model’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    function to retrieve the documents that match the filter. The filter is either
    an empty object that returns all locations or one of our custom types, <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>. As
    soon as we have the data from the database, we cast it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>
    and then return it. If there is an error, we log it and then return an empty array
    to match the defined return types: either an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationTypes</samp>
    or an empty array.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入依赖项后，我们创建了一个实际调用 Mongoose 的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>`
    API 的函数，并等待来自数据库的数据。这个函数将查询数据库中所有使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>`
    的公共服务，因此它是所有服务的基础。它的一个参数 `<samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>`
    对象，可以传递给模型的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>` 函数，以检索与过滤器匹配的文档。该过滤器可以是一个空对象，返回所有位置，或者是我们的自定义类型之一，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>` 或 `<samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>`。一旦我们从数据库中获得数据，就将其转换为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp>`，然后返回。如果出现错误，我们会记录错误，并返回一个空数组，以匹配已定义的返回类型：要么是
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">LocationTypes</samp>` 数组，要么是空数组。
- en: The following three functions are the public services, which will provide database
    access to other TypeScript modules and the user interface. All follow the same
    structure. First, within the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp>
    function, we set the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object to a particular parameter. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>
    function with this service-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object. Because every service calls the same function, services also have the
    same return signature, and each returns an array of locations or an empty array.
    The first uses an empty object. Hence, it filters for nothing and instead returns
    all documents from the collection. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp>
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>
    and returns the documents that match the given location IDs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个功能是公共服务，它们将为其他 TypeScript 模块和用户界面提供数据库访问。这些功能都遵循相同的结构。首先，在 `<samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp>`
    函数中，我们将 `<samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>` 对象设置为特定的参数。然后我们使用此特定服务的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>` 对象调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>`
    函数。因为每个服务都调用相同的函数，所以各个服务也有相同的返回签名，并且每个服务返回的是一个位置数组或一个空数组。第一个使用的是一个空对象。因此，它不会过滤任何内容，而是返回集合中的所有文档。函数
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp>` 使用 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp>` 并返回与给定位置 ID
    匹配的文档。
- en: The next function, <samp class="SANS_TheSansMonoCd_W5Regular_11">onUserWishlist</samp>,
    uses a slightly more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object. It has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>,
    and we pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>
    function to get all locations whose <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    array contains the given user ID. Note that we type the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    objects explicitly upon declaration. This deviates from the advice given in [Chapter
    3](chapter3.xhtml), but we do it here to ensure that TSC verifies the object properties,
    as it cannot infer the types from their usage in this case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数<samp class="SANS_TheSansMonoCd_W5Regular_11">onUserWishlist</samp>使用了一个稍微复杂的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>对象。它的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>，我们将其传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>函数，以获取所有其<samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>数组中包含给定用户ID的位置。注意，我们在声明时明确指定了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>对象的类型。这与[第3章](chapter3.xhtml)中的建议有所不同，但我们这么做是为了确保TSC验证对象的属性，因为在这种情况下它无法从使用方式推断出类型。
- en: Finally, we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp>
    function. It is slightly different from the previous ones, but the overall structure
    should look familiar. Again, we build the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>
    object from the first parameter, and we use the second one, the user ID, to update
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> array. Unlike
    in previous functions, however, we use another parameter to specify whether we
    want to <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp>
    the user ID to or from the array. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp>
    statement here is a convenient way to reduce the number of exposed services. Depending
    on the action parameter, we fill the update object with either the <samp class="SANS_TheSansMonoCd_W5Regular_11">$push</samp>
    operator, which adds the user ID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    array, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">$pull</samp> operator,
    which removes the user ID. We pass the object to Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">findOneAndUpdate</samp>
    API to look for the first document that matches the filter, and we directly update
    the record and then return the updated document or an empty object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了<samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp>函数。它与之前的函数稍有不同，但整体结构应该很熟悉。我们再次从第一个参数构建<samp
    class="SANS_TheSansMonoCd_W5Regular_11">filter</samp>对象，使用第二个参数——用户ID——来更新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>数组。不过，与之前的函数不同，我们使用另一个参数来指定是否要将用户ID<samp
    class="SANS_TheSansMonoCd_W5Regular_11">添加</samp>到数组中或<samp class="SANS_TheSansMonoCd_W5Regular_11">移除</samp>。在这里使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp>语句是一种便捷的方式，能减少暴露的服务数量。根据操作参数，我们用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$push</samp>操作符填充更新对象，该操作符将用户ID添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>数组中，或者用<samp class="SANS_TheSansMonoCd_W5Regular_11">$pull</samp>操作符将用户ID移除。我们将该对象传递给Mongoose的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">findOneAndUpdate</samp> API，查找第一个匹配筛选条件的文档，直接更新记录，然后返回更新后的文档或空对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Services</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测试服务</samp>
- en: Let’s use our temporary REST API to evaluate the services. Open the *test-middleware.ts*
    file we created earlier and update it with the code from [Listing 12-11](chapter12.xhtml#Lis12-11).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用临时的REST API来评估这些服务。打开我们之前创建的*test-middleware.ts*文件，并用[列表12-11](chapter12.xhtml#Lis12-11)中的代码更新它。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 12-11: The pages/api/test-middleware.ts file using the services'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12-11：使用服务的pages/api/test-middleware.ts文件
- en: Instead of directly importing the model and using Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    method on it, we import the location services and query all locations with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">findAllLocations</samp> service.
    If you open the API at *http://localhost:3000/api/test-middleware* in your browser,
    you should once again see a JSON object with all available locations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有直接导入模型并使用 Mongoose 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>
    方法，而是导入了位置服务，并通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">findAllLocations</samp>
    服务查询所有位置。如果你在浏览器中打开 *http://localhost:3000/api/test-middleware* 的 API，你应该再次看到一个包含所有可用位置的
    JSON 对象。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: We’ve successfully created the first part of the middleware. With the code in
    this chapter, we can use a Mongoose model to create, read, update, and delete
    documents in the MongoDB collection. To perform these actions, we set up the services
    we’ll connect to our upcoming GraphQL API. In the next chapter, we’ll delete the
    temporary testing API middleware and replace it with a proper GraphQL API.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功创建了中间件的第一部分。通过本章的代码，我们可以使用 Mongoose 模型在 MongoDB 集合中创建、读取、更新和删除文档。为了执行这些操作，我们设置了将与即将到来的
    GraphQL API 连接的服务。在下一章中，我们将删除临时的测试 API 中间件，并用一个正式的 GraphQL API 替换它。
