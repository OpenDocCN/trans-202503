- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UTILITIES**
  prefs: []
  type: TYPE_NORMAL
- en: “*See, the world is full of things more powerful than us. But if you know how
    to catch a ride, you can go places,” Raven says.
  prefs: []
  type: TYPE_NORMAL
- en: “Right. I’m totally hip to what you’re saying.”
  prefs: []
  type: TYPE_NORMAL
- en: —Neal Stephenson*, Snow Crash
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The stdlib and Boost libraries provide a throng of types, classes, and functions
    that satisfy common programming needs. Together, this motley collection of tools
    is called *utilities*. Aside from their small, uncomplicated, and focused nature,
    utilities vary functionally.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about several simple *data structures* that handle
    many routine situations where you need objects to contain other objects. A discussion
    of *dates and times* follows, including coverage of several provisions for encoding
    calendars and clocks and for measuring elapsed time. The chapter wraps up with
    a trek through many *numerical and mathematical tools* available to you.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The discussions of dates/times and numerics/math will be of great interest
    to certain readers and of only passing interest to others. If you are in the latter
    category, feel free to skim these sections.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Structures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Between them, the stdlib and Boost libraries provide a venerable collection
    of useful *data structures*. A *data structure* is a type that stores objects
    and permits some set of operations over those stored objects. There is no magic
    compiler pixie dust that makes the utility data structures in this section work;
    you could implement your own versions with sufficient time and effort. But why
    reinvent the wheel?
  prefs: []
  type: TYPE_NORMAL
- en: '***tribool***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *tribool* is a `bool`-like type that supports three states rather than
    two: true, false, and indeterminate. Boost offers `boost::logic::tribool` in the
    `<boost/logic/tribool.hpp>` header. [Listing 12-1](ch12.xhtml#ch12ex01) demonstrates
    how to initialize Boost a `tribool` using `true`, `false`, and the `boost::logic::indeterminate`
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: Initializing Boost `tribool`*'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, a `using` declaration pulls in `indeterminate` from `boost::logic`
    ➊. Then you initialize the `tribool t` equal to `true` ➋, `f` equal to `false`
    ➌, and `i` equal to `indeterminate` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: The `tribool` class implicitly converts to `bool`. If a `tribool` is `true`,
    it converts to `true`; otherwise, it converts to `false`. The `tribool` class
    also supports `operator!`, which returns `true` if `tribool` is `false`; otherwise,
    it returns `false`. Finally, `indeterminate` supports `operator()`, which takes
    a single `tribool` argument and returns `true` if that argument is `indeterminate`;
    otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-2](ch12.xhtml#ch12ex02) samples these Boolean conversions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: Converting a `tribool` to a `bool`*'
  prefs: []
  type: TYPE_NORMAL
- en: This test demonstrates the basic results from `bool` conversion ➊➋, `operator!`
    ➌➍, and `indeterminate` ➍➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `tribool` class supports all the Boolean operators. Whenever a `tribool`
    expression doesn’t involve an `indeterminate` value, the result is the same as
    the equivalent Boolean expression. Whenever an `indeterminate` is involved, the
    result can be `indeterminate`, as [Listing 12-3](ch12.xhtml#ch12ex03) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-3: The `boost::tribool` supports Boolean operations.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because neither `t` nor `f` is indeterminate, `t || f` evaluates just like an
    ordinary Boolean expression, so `t_or_f` is `true` ➊. Boolean expressions that
    involve an indeterminate can be indeterminate. Boolean AND ➋, OR ➌, and NOT ➍
    evaluate to `indeterminate` if there isn’t enough information.
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use tribool**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Aside from describing the vital status of Schrödinger’s cat, you can use `tri``bool`
    in settings in which operations can take a long time. In such settings, a `tribool`
    could describe whether the operation was successful. An `indeterminate` value
    could model that the operation is still pending.
  prefs: []
  type: TYPE_NORMAL
- en: The `tribool` class makes for neat, concise `if` statements, as shown in [Listing
    12-4](ch12.xhtml#ch12ex04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-4: Using an `if` statement with `tribool`*'
  prefs: []
  type: TYPE_NORMAL
- en: The first expression ➊ evaluates only if the `tribool` is `true`, the second
    expression ➋ evaluates only if it’s `false`, and the third only executes in the
    `indeterminate` case ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The mere mention of a `tribool` might have caused you to scrunch up your face
    in disgust. Why, you might ask, couldn’t you just use an integer where 0 is false,
    1 is true, and any other value is indeterminate? You could, but consider that
    the `tribool` type supports all the usual Boolean operations while correctly propagating
    indeterminate values. Again, why reinvent the wheel?*'
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-1](ch12.xhtml#ch12tab01) provides a list of the most supported `boost::tribool`
    operations. In this table, `tb` is a `boost::tribool`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** The Most Supported `boost::tribool` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `tribool{}` `tribool{ false }` | Constructs a `tribool` with value `false`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tribool{ true }` | Constructs a `tribool` with value `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tribool{ indeterminate }` | Constructs a `tribool` with value `indeterminate`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| tb`.safe_bool()` | Evaluates to `true` if tb is `true`, else `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `indeterminate(`tb`)` | Evaluates to `true` if tb is `indeterminate`, else
    `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| !tb | Evaluates to `true` if tb is `false`, else `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| tb1 `&&` tb2 | Evaluates to `true` if tb1 and tb2 are `true`; evaluates to
    `false` if tb1 or tb2 are `false`; otherwise, `indeterminate`. |'
  prefs: []
  type: TYPE_TB
- en: '| tb1 `&#124;&#124;` tb2 | Evaluates to `true` if tb1 or tb2 are `true`; evaluates
    to `false` if tb1 and tb2 are `false`; otherwise, `indeterminate`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool{` tb `}` | Evaluates to `true` if tb is true, else `false`. |'
  prefs: []
  type: TYPE_TB
- en: '***optional***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *optional* is a class template that contains a value that might or might
    not be present. The primary use case for an `optional` is the return type of a
    function that might fail. Rather than throwing an exception or returning multiple
    values, a function can instead return an `optional` that will contain a value
    if the function succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib has `std::optional` in the `<optional>` header, and Boost has `boost::optional`
    in the `<boost/optional.hpp>` header.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the setup in [Listing 12-5](ch12.xhtml#ch12ex05). The function `take`
    wants to return an instance of `TheMatrix` only if you take a `Pill::Blue`; otherwise,
    `take` returns a `std::nullopt`, which is a stdlib-provided constant `std::optional`
    type with uninitialized state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-5: A `take` function returning a `std::optional`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `TheMatrix` type takes a single `int` constructor argument and stores it
    into the `iteration` member ➊. The `enum` called `Pill` takes the values `Red`
    and `Blue` ➋. The `take` function returns a `std::optional<TheMatrix>` ➌ and accepts
    a single `Pill` argument ➍. If you pass `Pill::Blue` to the take function, it
    returns a `TheMatrix` instance ➎; otherwise, it returns a `std::nullopt` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: First, consider [Listing 12-6](ch12.xhtml#ch12ex06), where you take the blue
    pill.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-6: A test exploring the `std::optional` type with `Pill::Blue`*'
  prefs: []
  type: TYPE_NORMAL
- en: You take the blue pill, which results in the `std::optional` result containing
    an initialized `TheMatrix`, so the `if` statement’s conditional expression evaluates
    to `true` ➊. [Listing 12-6](ch12.xhtml#ch12ex06) also demonstrates the use of
    `operator->` ➋ and `value()` ➌ to access the underlying value.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you take the red pill? Consider [Listing 12-7](ch12.xhtml#ch12ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-7: A test exploring the `std::optional` type with `Pill::Red`*'
  prefs: []
  type: TYPE_NORMAL
- en: You take the red pill ➊, and the resulting `matrix_opt` is empty. This means
    `matrix_opt` converts to `false` ➋ and `has_value()` also returns `false` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-2](ch12.xhtml#ch12tab02) provides a list of the most supported `std::optional`
    operations. In this table, `opt` is a `std::optional<T>` and `t` is an object
    of type `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-2:** The Most Supported `std::optional` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `optional<T>{}` `optional<T>{std::nullopt}` | Constructs an empty `optional`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `optional<T>{` opt `}` | Copy constructs an `optional` from opt. |'
  prefs: []
  type: TYPE_TB
- en: '| `optional<T>{ move(`opt`) }` | Move constructs an `optional` from opt, which
    is empty after the constructor completes. |'
  prefs: []
  type: TYPE_TB
- en: '| `optional<T>{` `t` `}` opt `=` t | Copies t into `optional`. |'
  prefs: []
  type: TYPE_TB
- en: '| `optional<T>{ move(``t``) }` opt = `move(`t`)` | Moves t into `optional`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| opt`->`mbr | Member dereference; accesses the mbr member of object contained
    by opt. |'
  prefs: []
  type: TYPE_TB
- en: '| `*`opt opt`.value()` | Returns a reference to the object contained by opt;
    `value()` checks for empty and throws `bad_optional_access`. |'
  prefs: []
  type: TYPE_TB
- en: '| opt`.value_or(`T`{ ... })` | If opt contains an object, returns a copy; else
    returns the argument. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool{` opt `}` opt`.has_value()` | Returns `true` if opt contains an object,
    else `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| opt1`.swap(`opt2`)` `swap(`opt1`,` opt2`)` | Swaps the objects contained
    by opt1 and opt2. |'
  prefs: []
  type: TYPE_TB
- en: '| opt`.reset()` | Destroys object contained by opt, which is empty after `reset`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| opt`.emplace(...)` | Constructs a type in place, forwarding all arguments
    to the appropriate constructor. |'
  prefs: []
  type: TYPE_TB
- en: '| `make_optional<T>(...)` | Convenience function for constructing an `optional`;
    forwards arguments to the appropriate constructor. |'
  prefs: []
  type: TYPE_TB
- en: '| opt1 `==` opt2opt1 `!=` opt2opt1 `>` opt2opt1 `>=` opt2opt1 `<` opt2opt1
    `<=` opt2 | When evaluating equality of two `optional` objects, `true` if both
    are empty or if both contain objects and those objects are equal; else `false`.
    For comparison, an empty `optional` is always less than an optional containing
    a value. Otherwise, the result is the comparison of the contained types. |'
  prefs: []
  type: TYPE_TB
- en: '***pair***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *pair* is a class template that contains two objects of different types in
    a single object. The objects are ordered, and you can access them via the members
    `first` and `second`. A `pair` supports comparison operators, has defaulted copy/move
    constructors, and works with structured binding syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib has `std::pair` in the `<utility>` header, and Boost has `boost::pair`
    in the `<boost/pair.hpp>` header.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost also has `boost::compressed_pair` available in the `<boost/compressed_pair.hpp>`
    header. It’s slightly more efficient when one of the members is empty.*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you create some simple types to make a pair out of, such as the simple
    `Socialite` and `Valet` classes in [Listing 12-8](ch12.xhtml#ch12ex08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-8: The `Socialite` and `Valet` classes*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a `Socialite` and a `Valet`, `bertie` and `reginald`, you
    can construct a `std::pair` and experiment with extracting elements. [Listing
    12-9](ch12.xhtml#ch12ex09) uses the `first` and `second` members to access the
    contained types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-9: The `std::pair` supports member extraction.*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `std::pair` by passing in the objects you want to copy ➊. You
    use the `first` and `second` members of `std::pair` to extract the `Socialite`
    ➋ and `Valet` ➌ out of `inimitable_duo`. Then you can compare the `birthname`
    and `surname` members of these to their originals.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-10](ch12.xhtml#ch12ex10) shows `std::pair` member extraction and
    structured binding syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-10: The `std::pair` supports structured binding syntax.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here you use the structured binding syntax ➊ to extract references to the `first`
    and `second` members of `inimitable_duo` into `idle_rich` and `butler`. As in
    [Listing 12-9](ch12.xhtml#ch12ex09), you ensure that the `birthname` ➋ and `surname`
    ➌ match the originals.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-3](ch12.xhtml#ch12tab03) provides a list of the most supported `std::pair`
    operations. In this table, `pr` is a `std::pair<A, B>`, `a` is an object of type
    `A`, and `b` is an object of type `B`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-3:** The Most Supported `std::pair` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `pair<...>{}` | Constructs an empty `pair`. |'
  prefs: []
  type: TYPE_TB
- en: '| `pair<...>{` pr `}` | Copy constructs from pr. |'
  prefs: []
  type: TYPE_TB
- en: '| `pair<...>{ move(`pr`) }` | Move constructs from pr. |'
  prefs: []
  type: TYPE_TB
- en: '| `pair<...>{` a`,` b `}` | Constructs a `pair` by copying a and b. |'
  prefs: []
  type: TYPE_TB
- en: '| `pair<...>{ move(`a`), move(`b`) }` | Constructs a `pair` by moving a and
    b. |'
  prefs: []
  type: TYPE_TB
- en: '| pr1 `=` pr2 | Copy assigns from pr2. |'
  prefs: []
  type: TYPE_TB
- en: '| pr1 = `move(`pr2`)` | Move assigns from pr2. |'
  prefs: []
  type: TYPE_TB
- en: '| pr`.first` `get<0>(`pr`)` | Returns a reference to the `first` element. |'
  prefs: []
  type: TYPE_TB
- en: '| pr`.second` `get<1>(`pr`)` | Returns a reference to the `second` element.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get<`T`>(`pr`)` | If `first` and `second` have different types, returns
    a reference to the element of type T. |'
  prefs: []
  type: TYPE_TB
- en: '| pr1`.swap(`pr2`)` `swap(`pr1`,` pr2`)` | Swaps the objects contained by pr1
    and pr2. |'
  prefs: []
  type: TYPE_TB
- en: '| `make_pair<...>(`a`,` b`)` | Convenience function for constructing a `pair`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| pr1 `==` pr2pr1 `!=` pr2pr1 `>` pr2pr1 `>=` pr2pr1 `<` pr2pr1 `<=` pr2 |
    Equal if both `first` and `second` are equal. Greater than/less than comparisons
    begin with `first`. If `first` members are equal, compare `second` members. |'
  prefs: []
  type: TYPE_TB
- en: '***tuple***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *tuple* is a class template that takes an arbitrary number of heterogeneous
    elements. It’s a generalization of `pair`, but a `tuple` doesn’t expose its members
    as `first`, `second`, and so on like a `pair`. Instead, you use the non-member
    function template `get` to extract elements.
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib has `std::tuple` and `std::get` in the `<tuple>` header, and Boost
    has `boost::tuple` and `boost::get` in the `<boost/tuple/tuple.hpp>` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a third class, `Acquaintance`, to test a `tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To extract these elements, you have two modes of using `get`. In the primary
    case, you can always provide a template parameter corresponding to the zero-based
    index of the element you want to extract. In the event the `tuple` doesn’t contain
    elements with the same types, you can alternatively provide a template parameter
    corresponding to the type of the element you want to extract, as [Listing 12-11](ch12.xhtml#ch12ex11)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-11: A `std::tuple` supports member extraction and structured binding
    syntax.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can build a `std::tuple` in an analogous way to how you built a `std::pair`.
    First, you extract the `Socialite` member with `get<0>` ➊. Because `Socialite`
    is the first template parameter, you use 0 for the `std::get` template parameter.
    Then you extract the `Acquaintance` member with `std::get<Acquaintance>` ➋. Because
    there’s only one element of type `Acquaintance`, you’re permitted to use this
    mode of `get` access.
  prefs: []
  type: TYPE_NORMAL
- en: Like `pair`, `tuple` also allows structured binding syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-4](ch12.xhtml#ch12tab04) provides a list of the most supported `std::tuple`
    operations. In this table, `tp` is a `std::tuple<A, B>`, `a` is an object of type
    `A`, and `b` is an object of type `B`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-4:** The Most Supported `std::tuple` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple<...>{` [alc] `}` | Constructs an empty `tuple`. Uses `std::allocate`
    as default allocator alc. |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple<...>{` [alc]`,` tp `}` | Copy constructs from tp. Uses `std::allocate`
    as default allocator alc. |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple<...>{` [alc]`,move(`tp`) }` | Move constructs from tp. Uses `std::allocate`
    as default allocator alc. |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple<...>{` [alc]`,` a`,` b `}` | Constructs a `tuple` by copying a and
    b. Uses `std::allocate` as default allocator alc. |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple<...>{` [alc]`, move(`a`), move(`b`) }` | Constructs a `tuple` by moving
    a and b. Uses `std::allocate` as default allocator alc. |'
  prefs: []
  type: TYPE_TB
- en: '| tp1 `=` tp2 | Copy assigns from tp2. |'
  prefs: []
  type: TYPE_TB
- en: '| tp1 = `move(`tp2`)` | Move assigns from tp2. |'
  prefs: []
  type: TYPE_TB
- en: '| `get<`i`>(`tp`)` | Returns a reference to the ith element (zero-based). |'
  prefs: []
  type: TYPE_TB
- en: '| `get<`T`>(`tp`)` | Returns a reference to the element of type T. Fails to
    compile if more than one element share this type. |'
  prefs: []
  type: TYPE_TB
- en: '| tp1`.swap(`tp2`)` `swap(`tp1`,` tp2`)` | Swaps the objects contained by tp1
    and tp2. |'
  prefs: []
  type: TYPE_TB
- en: '| `make_tuple<...>(`a`,` b`)` | Convenience function for constructing a `tuple`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple_cat<...>(`tp1`,` tp2`)` | Concatenates all the tuples passed in as
    arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| tp1 `==` tp2tp1 `!=` tp2tp1 `>` tp2tp1 `>=` tp2tp1 `<` tp2tp1 `<=` tp2 |
    Equal if all elements are equal. Greater than/less than comparisons proceed from
    first element to last. |'
  prefs: []
  type: TYPE_TB
- en: '***any***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *any* is a class that stores single values of any type. It is *not* a class
    template. To convert an `any` into a concrete type, you use an *any cast*, which
    is a non-member function template. Any cast conversions are type safe; if you
    attempt to cast an `any` and the type doesn’t match, you get an exception. With
    `any`, you can perform some kinds of generic programming *without templates*.
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib has `std::any` in the `<any>` header, and Boost has `boost::any`
    in the `<boost/any.hpp>` header.
  prefs: []
  type: TYPE_NORMAL
- en: To store a value into an `any`, you use the `emplace` method template. It takes
    a single template parameter corresponding to the type you want to store into `any`
    (the *storage type*). Any arguments you pass into `emplace` get forwarded to an
    appropriate constructor for the given storage type. To extract the value, you
    use `any_cast`, which takes a template parameter corresponding to the current
    storage type of `any` (called the *state* of `any`). You pass the `any` as the
    sole parameter to `any_cast`. As long as the state of `any` matches the template
    parameter, you get the desired type out. If the state doesn’t match, you get a
    `bad_any_cast` exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-12](ch12.xhtml#ch12ex12) illustrates these basic interactions with
    a `std::any`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-12: The `std::any` and `std::any_cast` allow you to extract concrete
    types.*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare the `EscapeCapsule` class ➊. Within the test, you construct an empty
    `std::any` called `hagunemnon` ➋. Next, you use `emplace` to store an `EscapeCapsule`
    with `weight_kg = 600` ➌. You can extract the `EscapeCapsule` back out using `std::any_cast`
    ➍, which you store into a new `EscapeCapsule` called `capsule`. Finally, you show
    that attempting to invoke `any_cast` to cast the `hagunemnon` into a `float` results
    in a `std::bad_any_cast` exception ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-5](ch12.xhtml#ch12tab05) provides a list of the most supported `std::any`
    operations. In this table, `ay` is a `std::any` and `t` is an object of type `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-5:** The Most Supported `std::any` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `any{}` | Constructs an empty `any` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `any{` ay `}` | Copy constructs from ay. |'
  prefs: []
  type: TYPE_TB
- en: '| `any{ move(`ay`) }` | Move constructs from ay. |'
  prefs: []
  type: TYPE_TB
- en: '| `any{ move(`t`) }` | Constructs an `any` object containing an in-place constructed
    object from t. |'
  prefs: []
  type: TYPE_TB
- en: '| ay `=` t | Destructs the object currently contained by ay; copies t. |'
  prefs: []
  type: TYPE_TB
- en: '| ay `= move(`t`)` | Destructs the object currently contained by ay; moves
    t. |'
  prefs: []
  type: TYPE_TB
- en: '| ay1 `=` ay2 | Copy assigns from ay2. |'
  prefs: []
  type: TYPE_TB
- en: '| ay1 `= move(`ay2`)` | Move assigns from ay2. |'
  prefs: []
  type: TYPE_TB
- en: '| ay`.emplace<`T`>(...)` | Destructs the object currently contained by ay;
    constructs a T in place, forwarding the arguments `...` to the appropriate constructor.
    |'
  prefs: []
  type: TYPE_TB
- en: '| ay`.reset()` | Destroys the currently contained object. |'
  prefs: []
  type: TYPE_TB
- en: '| ay1`.swap(`ay2`)` `swap(`ay1`,` ay2`)` | Swaps the objects contained by ay1
    and ay2. |'
  prefs: []
  type: TYPE_TB
- en: '| `make_any<`T`>(...)` | Convenience function for constructing an `any` constructs
    a T in place, forwarding the arguments `...` to the appropriate constructor. |'
  prefs: []
  type: TYPE_TB
- en: '| t `= any_cast<`T`>(`ay`)` | Casts ay into type T. Throws a `std::bad_any_cast`
    if the type T doesn’t match the contained object’s type. |'
  prefs: []
  type: TYPE_TB
- en: '***variant***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *variant* is a class template that stores single values whose types are restricted
    to the user-defined list provided as template parameters. The variant is a type-safe
    `union` (refer to “Unions” on [page 53](ch02.xhtml#page_53)). It shares a lot
    of functionality with the `any` type, but `variant` requires that you explicitly
    enumerate all the types that you’ll store.
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib has `std::variant` in the `<variant>` header, and Boost has `boost::variant`
    in the `<boost/variant.hpp>` header.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-13](ch12.xhtml#ch12ex13) demonstrates creating another type called
    `BugblatterBeast` for `variant` to contain alongside `EscapeCapsule`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-13: The `std::variant` can hold an object from one of a list of
    predefined types.*'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from also containing a `weight_kg` member ➊, `BugblatterBeast` is totally
    independent from `EscapeCapsule`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructing a variant**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A `variant` can only be default constructed if one of two conditions is met:'
  prefs: []
  type: TYPE_NORMAL
- en: The first template parameter is default constructible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is `monostate`, a type intended to communicate that a variant can have an
    empty state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because `BugblatterBeast` is default constructible (meaning it has a default
    constructor), make it the first type in the template parameter list so your variant
    is also default constructible, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To store a value into a `variant`, you use the `emplace` method template. As
    with `any`, a `variant` takes a single template parameter corresponding to the
    type you want to store. This template parameter must be contained in the list
    of template parameters for the `variant`. To extract a value, you use either of
    the non-member function templates `get` or `get_if`. These accept either the desired
    type or the index into the template parameter list corresponding to the desired
    type. If `get` fails, it throws a `bad_variant_access` exception, while `get_if`
    returns a `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: You can determine which type corresponds with the current state of `variant`
    using the `index()` member, which returns the index of the current object’s type
    within the template parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-14](ch12.xhtml#ch12ex14) illustrates how to use `emplace` to change
    the state of a `vari``ant` and `index` to determine the type of the contained
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-14: A `std::get` allows you to extract concrete types from `std::variant`.*'
  prefs: []
  type: TYPE_NORMAL
- en: After default constructing `hagunemnon`, invoking `index` yields 0 because this
    is the index of the correct template parameter ➊. Next, you emplace an `EscapeCapsule`
    ➋, which causes `index` to return 1 instead ➌. Both `std::get<EscapeCapsule>`
    ➍ and `std::get<1>` ➎ illustrate identical ways of extracting the contained type.
    Finally, attempting to invoke `std::get` to obtain a type that doesn’t correspond
    with the current state of `variant` results in a `bad_variant_access` ➏.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the non-member function `std::visit` to apply a callable object
    to a variant. This has the advantage of dispatching the correct function to handle
    whatever the contained object is without having to specify it explicitly with
    `std::get`. [Listing 12-15](ch12.xhtml#ch12ex15) illustrates the basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-15: The `std::visit` allows you to apply a callable object to a
    contained type of `std::variant`.*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you invoke `emplace` to store the value 600 into `hagunemnon` ➊. Because
    both `BugblatterBeast` and `EscapeCapsule` have a `weight_kg` member, you can
    use `std::visit` on `hagunemnon` with a lambda that performs the correct conversion
    (2.2 lbs per kg) to the `weight_kg` field ➋ and returns the result ➌ (notice that
    you don’t have to include any type information).
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparing variant and any**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The universe is big enough to accommodate both `any` and `variant`. It’s not
    possible to recommend one over the other generally, because each has its strengths
    and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: An `any` is more flexible; it can take *any* type, whereas `variant` is only
    allowed to contain an object of a predetermined type. It also mostly avoids templates,
    so it’s generally easier to program with.
  prefs: []
  type: TYPE_NORMAL
- en: A `variant` is less flexible, making it safer. Using the `visit` function, you
    can check for the safety of operations at compile time. With `any`, you would
    need to build your own `visit`-like functionality, and it would require runtime
    checking (for example, of the result of `any_cast`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `variant` can be more performant than `any`. Although `any` is allowed
    to perform dynamic allocation if the contained type is too large, `variant` is
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Supported Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-6](ch12.xhtml#ch12tab06) provides a list of the most supported `std::variant`
    operations. In this table, `vt` is a `std::variant` and `t` is an object of type
    `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-6:** The Most Supported `std::variant` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `variant<...>{}` | Constructs an empty `variant` object. First template parameter
    must be default constructible. |'
  prefs: []
  type: TYPE_TB
- en: '| `variant<...>{` vt `}` | Copy constructs from vt. |'
  prefs: []
  type: TYPE_TB
- en: '| `variant<...>{ move(`vt`) }` | Move constructs from vt. |'
  prefs: []
  type: TYPE_TB
- en: '| `variant<...>{ move(`t`) }` | Constructs an `variant` object containing an
    in-place constructed object. |'
  prefs: []
  type: TYPE_TB
- en: '| vt `=` t | Destructs the object currently contained by vt; copies t. |'
  prefs: []
  type: TYPE_TB
- en: '| vt `= move(`t`)` | Destructs the object currently contained by vt; moves
    t. |'
  prefs: []
  type: TYPE_TB
- en: '| vt1 `=` vt2 | Copy assigns from vt2. |'
  prefs: []
  type: TYPE_TB
- en: '| vt1 `= move(`vt2`)` | Move assigns from vt2. |'
  prefs: []
  type: TYPE_TB
- en: '| vt`.emplace<`T`>(...)` | Destructs the object currently contained by vt;
    constructs a T in place, forwarding the arguments `...` to the appropriate constructor.
    |'
  prefs: []
  type: TYPE_TB
- en: '| vt`.reset()` | Destroys the currently contained object. |'
  prefs: []
  type: TYPE_TB
- en: '| vt`.index()` | Returns the zero-based index of the type of the currently
    contained object. (Order determined by template parameters of the `std::variant`.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| vt1`.swap(`vt2`)` `swap(`vt1`,` vt2`)` | Swaps the objects contained by vt1
    and vt2. |'
  prefs: []
  type: TYPE_TB
- en: '| `make_variant<`T`>(...)` | Convenience function for constructing a `tuple`;
    constructs a T in place, forwarding the arguments `...` to the appropriate constructor.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::visit(`vt`,` callable`)` | Invokes callable with contained object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::holds_alternative<`T`>(`vt`)` | Returns `true` if the contained object’s
    type is T. |'
  prefs: []
  type: TYPE_TB
- en: '| `std::get<`I`>(`vt`)` `std::get<`T`>(`vt`)` | Returns contained object if
    its type is T or the ith type. Otherwise, throws std::bad_variant_access exception.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::get_if<`I`>(&`vt`)` `std::get_if<`T`>(&`vt`)` | Returns a pointer to
    the contained object if its type is T or the ith type. Otherwise, returns `nullptr`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| vt1 `==` vt2vt1 `!=` vt2vt1 `>` vt2vt1 `>=` vt2vt1 `<` vt2vt1 `<=` vt2 |
    Compares the contained objects of vt1 and vt2. |'
  prefs: []
  type: TYPE_TB
- en: '**Date and Time**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Between stdlib and Boost, a number of libraries are available that handle dates
    and times. When handling calendar dates and times, look to Boost’s DateTime library.
    When you’re trying get the current time or measure elapsed time, look to Boost’s
    or stdlib’s Chrono libraries and to Boost’s Timer library.
  prefs: []
  type: TYPE_NORMAL
- en: '***Boost DateTime***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Boost DateTime library supports date programming with a rich system based on
    the Gregorian calendar, which is the most widely used civil calendar internationally.
    Calendars are more complicated than they might seem at first glance. For example,
    consider the following excerpt from the US Naval Observatory’s Introduction to
    Calendars, which describes the basics of leap years:'
  prefs: []
  type: TYPE_NORMAL
- en: Every year that is exactly divisible by four is a leap year, except for years
    that are exactly divisible by 100, but these centurial years are leap years if
    they are exactly divisible by 400\. For example, the years 1700, 1800, and 1900
    are not leap years, but the year 2000 is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than attempting to build your own solar calendar functions, just include
    DateTime’s date-programming facilities with the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The principal type you’ll use is the `boost::gregorian::date`, which is the
    primary interface for date-programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructing a date**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Several options are available for constructing a `date`. You can default construct
    a `date`, which sets its value to the special date `boost::gregorian::not_a_``date_time`.
    To construct a `date` with a valid date, you can use a constructor that accepts
    three arguments: a year, a month, and a date. The following statement constructs
    a `date d` with the date September 15, 1986:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can construct a date from a string using the `boost:: gregorian::from_string`
    utility function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you pass an invalid date, the `date` constructor will throw an exception,
    such as `bad_year`, `bad_day_of_month`, or `bad_month`. For example, [Listing
    12-16](ch12.xhtml#ch12ex16) attempts to construct a date with September 32, 1986.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-16: The `boost::gregorian::date` constructor throws exceptions
    for bad dates.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because September 32 isn’t a valid day of the month, the `date` constructor
    throws a `bad_day_of_month` exception ➊.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Due to a limitation in Catch, you cannot use braced initialization for date
    in the `REQUIRE_THROWS_AS` macro* ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain the current day from the environment using the non-member function
    `boost::gregorian::day_clock::local_day` or `boost::gregorian:: day_clock::universal_day`
    to obtain the local day based on the system’s time zone settings and the UTC day,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once you construct a date, you can’t change its value (it’s *immutable*). However,
    dates support copy construction and copy assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing Date Members**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can inspect the features of a `date` through its many `const` methods. [Table
    12-7](ch12.xhtml#ch12tab07) provides a partial list. In this table, `d` is a `date`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-7:** The Most Supported `boost::gregorian::date` Accessors'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Accessor** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| d`.year()` | Returns the year portion of the `date`. |'
  prefs: []
  type: TYPE_TB
- en: '| d`.month()` | Returns the month portion of the `date`. |'
  prefs: []
  type: TYPE_TB
- en: '| d`.day()` | Returns the day portion of the `date`. |'
  prefs: []
  type: TYPE_TB
- en: '| d`.day_of_week()` | Returns the day of the week as an `enum` of type `greg_day_of_week`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| d`.day_of_year()` | Returns the day of the year (from 1 to 366 inclusive).
    |'
  prefs: []
  type: TYPE_TB
- en: '| d`.end_of_month()` | Returns a date object set to the last day of the month
    of d. |'
  prefs: []
  type: TYPE_TB
- en: '| d`.is_not_a_date()` | Returns `true` if d is not a date. |'
  prefs: []
  type: TYPE_TB
- en: '| d`.week_number()` | Returns the ISO 8601 week number. |'
  prefs: []
  type: TYPE_TB
- en: '[Listing 12-17](ch12.xhtml#ch12ex17) illustrates how to construct a `date`
    and use the accessors in [Table 12-7](ch12.xhtml#ch12tab07).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-17: The `boost::gregorian::date` supports basic calendar functions.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you construct a `date` from September 15, 1986 ➊. From there, you extract
    the year ➋, month ➌, day ➍, day of the year ➎, and day of the week ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calendar Math**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can perform simple calendar math on dates. When you subtract one date from
    another, you get a `boost::gregorian::date_duration`. The main functionality of
    `date_duration` is storing an integral number of days, which you can extract using
    the `days` method. [Listing 12-18](ch12.xhtml#ch12ex18) illustrates how to compute
    the number of days elapsed between two `date` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-18: Subtracting `boost::gregorian::date` objects yields a `boost::gregorian::
    date_duration`.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you construct a `date` for September 15, 1986 ➊ and for August 1, 2019
    ➋. You subtract these two dates to yield a `date_duration` ➌. Using the `days`
    method, you can extract the number of days between the two dates ➍.
  prefs: []
  type: TYPE_NORMAL
- en: You can also construct a `date_duration` using a `long` argument corresponding
    to the number of days. You can add a `date_duration` to a date to obtain another
    date, as [Listing 12-19](ch12.xhtml#ch12ex19) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-19: Adding a `date_duration` to a `date` yields another `date`.*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `date` for September 15, 1986 ➊ and 12,008 days for `duration`
    ➋. From [Listing 12-18](ch12.xhtml#ch12ex18), you know that this day plus 12008
    yields August 1, 2019\. So after adding them ➌, the resulting day is as you expect
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Date Periods**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *date period* represents the interval between two dates. DateTime provides
    a `boost::gregorian::date_period` class, which has three constructors, as described
    in [Table 12-8](ch12.xhtml#ch12tab08). In this table, constructors `d1` and `d2`
    are `date` arguments and `dp` is a `date_period`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-8:** Supported `boost::gregorian::date_period` Constructors'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Accessor** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `date_period{` d1`,` d2 `}` | Creates a period including d1 but not d2; invalid
    if d2 <= d1. |'
  prefs: []
  type: TYPE_TB
- en: '| `date_period{` d`,` n_days `}` | Creates a period frome d to d+n_days. |'
  prefs: []
  type: TYPE_TB
- en: '| `date_period{` dp `}` | Copy constructor. |'
  prefs: []
  type: TYPE_TB
- en: The `date_period` class supports many operations, such as the `contain` method,
    which takes a `date` argument and returns `true` if the argument is contained
    in the `period`. [Listing 12-20](ch12.xhtml#ch12ex20) illustrates this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-20: Using the `contains` method on a `boost::gregorian::date_period`
    to determine whether a date falls within a particular time interval*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you construct two dates, September 15, 1986 ➊ and August 1, 2019 ➋, which
    you use to construct a `date_period` ➌. Using the `contains` method, you can determine
    that the `date_period` contains the date October 27, 1987 ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-9](ch12.xhtml#ch12tab09) contains a partial list of other `date_period`
    operations. In this table, `p`, `p1`, and `p2` are `date_period` classes and `d`
    is a `date`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-9:** Supported `boost::gregorian::date_period` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Accessor** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| p`.begin()` | Returns the first day. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.last()` | Returns the last day. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.length()` | Returns the number of days contained. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.is_null()` | Returns `true` if the period is invalid (for example, end
    is before start). |'
  prefs: []
  type: TYPE_TB
- en: '| p`.contains(`d`)` | Returns `true` if d falls within p. |'
  prefs: []
  type: TYPE_TB
- en: '| p1`.contains(`p2`)` | Returns `true` if all of p2 falls within p1. |'
  prefs: []
  type: TYPE_TB
- en: '| p1`.intersects(`p2`)` | Returns `true` if any of p2 falls within p1. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.is_after(`d`)` | Returns `true` if p falls after d. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.is_before(`d`)` | Returns `true` if p falls before d. |'
  prefs: []
  type: TYPE_TB
- en: '**Other DateTime Features**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Boost DateTime library contains three broad categories of programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date** Date programming is the calendar-based programming you just toured.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time** Time programming, which allows you to work with clocks with microsecond
    resolution, is available in the `<boost/date_time/posix_time/``posix_time.hpp>`
    header. The mechanics are similar to date programming, but you work with clocks
    instead of Gregorian calendars.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local-time** Local-time programming is simply time-zone-aware time programming.
    It’s available in the `<boost/date_time/time_zone_base.hpp>` header.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For brevity, this chapter won’t go into detail about time and local-time programming.
    See the Boost documentation for information and examples.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Chrono***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The stdlib Chrono library provides a variety of clocks in the `<chrono>` header.
    You typically use these when you need to program something that depends on time
    or for timing your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost also offers a Chrono library in the `<boost/chrono.hpp>` header. It’s
    a superset of stdlib’s Chrono library, which includes, for example, process- and
    thread-specific clocks and user-defined output formats for time.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clocks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Three clocks are available in Chrono library; each provides a different guarantee,
    and all reside in the `std::chrono` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::chrono::system_clock` is the system-wide, real-time clock. It’s sometimes
    also called the *wall clock*, the elapsed real time since an implementation-specific
    start date. Most implementations specify the Unix start date of January 1, 1970,
    at midnight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::chrono::steady_clock` guarantees that its value will never decrease.
    This might seem absurd to guarantee, but measuring time is more complicated than
    it seems. For example, a system might have to contend with leap seconds or inaccurate
    clocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `std::chrono::high_resolution_clock` has the shortest *tick* period available:
    a tick is the smallest atomic change that the clock can measure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these three clocks supports the static member function `now`, which
    returns a time point corresponding to the current value of the clock.
  prefs: []
  type: TYPE_NORMAL
- en: '**Time Points**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *time point* represents a moment in time, and Chrono encodes time points using
    the `std::chrono::time_point` type. From a user perspective, `time_point` objects
    are very simple. They provide a `time_since_epoch` method that returns the amount
    of time elapsed between the time point and the clock’s *epoch*. This elapsed time
    is called a *duration*.
  prefs: []
  type: TYPE_NORMAL
- en: An epoch is an implementation-defined reference time point denoting the beginning
    of a clock. The Unix Epoch (or POSIX time) begins on January 1, 1970, whereas
    the Windows Epoch begins on January 1, 1601 (corresponding with the beginning
    of a 400-year, Gregorian-calendar cycle).
  prefs: []
  type: TYPE_NORMAL
- en: The `time_since_epoch` method is not the only way to obtain a duration from
    a `time_point`. You can obtain the duration between two `time_point` objects by
    subtracting them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Durations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `std::chrono::duration` represents the time between the two `time_point` objects.
    Durations expose a `count` method, which returns the number of clock ticks in
    the duration.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-21](ch12.xhtml#ch12ex21) shows how to obtain the current time from
    each of the three available clocks, extract the time since each clock’s epoch
    as a duration, and then convert them to ticks.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-21: The `std::chrono` supports several kinds of clocks.*'
  prefs: []
  type: TYPE_NORMAL
- en: You obtain the current time from the `system_clock` ➊, the `high_resolu`tion
    _clock ➋, and the `steady_clock` ➌. For each clock, you convert the time point
    into a `duration` since the clock’s epoch using the `time_since_epoch` method.
    You immediately call `count` on the resulting duration to yield a tick count,
    which should be greater than zero ➍ ➎ ➏.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to deriving durations from time points, you can construct them directly.
    The `std::chrono` namespace contains helper functions to generate durations. For
    convenience, Chrono offers a number of user-defined duration literals in the `std::literals::chrono_literals`
    namespace. These provide some syntactic sugar, convenient language syntax that
    makes life easier for the developer, for defining duration literals.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-10](ch12.xhtml#ch12tab10) shows the helper functions and their literal
    equivalents, where each expression corresponds to an hour’s duration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-10:** `std::chrono` Helper Functions and User-Defined Literals for
    Creating Durations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Helper function** | **Literal equivalent** |'
  prefs: []
  type: TYPE_TB
- en: '| `nanoseconds(3600000000000)` | `3600000000000ns` |'
  prefs: []
  type: TYPE_TB
- en: '| `microseconds(3600000000)` | `3600000000us` |'
  prefs: []
  type: TYPE_TB
- en: '| `milliseconds(3600000)` | `3600000ms` |'
  prefs: []
  type: TYPE_TB
- en: '| `seconds(3600)` | `3600s` |'
  prefs: []
  type: TYPE_TB
- en: '| `minutes(60)` | `60m` |'
  prefs: []
  type: TYPE_TB
- en: '| `hours(1)` | `1h` |'
  prefs: []
  type: TYPE_TB
- en: For example, [Listing 12-22](ch12.xhtml#ch12ex22) illustrates how to construct
    a duration of 1 second with `std::chrono::seconds` and another duration of 1,000
    milliseconds using the `ms` duration literal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-22: The `std::chrono` supports many units of measurement, which
    are comparable.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you bring in the `std::literals::chrono_literals` namespace so you have
    access to the duration literals ➊. You construct a duration called `one_s` from
    the `seconds` helper function ➋ and another called `thousand_ms` from the `ms`
    duration literal ➌. These are equivalent because a second contains a thousand
    milliseconds ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Chrono provides the function template `std::chrono::duration_cast` to cast a
    duration from one unit to another. As with other cast-related function templates,
    such as `static_cast`, `duration_cast` takes a single template parameter corresponding
    to the target duration and a single argument corresponding to the duration you
    want to cast.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-23](ch12.xhtml#ch12ex23) illustrates how to cast a `nanosecond`
    duration into a `second` duration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-23: The `std::chrono` supports `std::chrono::duration_cast`.*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you bring in the `std::chrono` namespace for easy access to `duration_cast`,
    the duration helper functions, and the duration literals ➊. Next, you use the
    `ns` duration literal to specify a billion-nanosecond duration ➌, which you pass
    as the argument to `duration_cast`. You specify the template parameter of `duration_cast`
    as seconds ➋, so the resulting duration, `billion_ns_as_s`, equals 1 second ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes, you’ll use durations to specify some period of time for your program
    to wait. The stdlib provides concurrency primitives in the `<thread>` header,
    which contains the non-member function `std::this_thread::sleep_``for`. The `sleep_for`
    function accepts a `duration` argument corresponding to how long you want the
    current thread of execution to wait or “sleep.”
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-24](ch12.xhtml#ch12ex24) shows how to employ `sleep_for`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-24: The `std::chrono` works with `<thread>` to put the current
    thread to sleep.*'
  prefs: []
  type: TYPE_NORMAL
- en: As before, you bring in the `chrono_literals` namespace so you have access to
    the duration literals ➊. You record the current time according to `sys``tem_``clock`,
    saving the resulting `time_point` into the `start` variable ➋. Next, you invoke
    `sleep_for` with a 100-millisecond duration (a tenth of a second) ➌. You then
    record the current time again, saving the resulting `time_point` into `end` ➍.
    Because the program slept for 100 milliseconds between calls to `std::chrono::system_clock`,
    the duration resulting from subtracting `start` from `end` should be at least
    `100ms` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**Timing**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To optimize code, you absolutely need accurate measurements. You can use Chrono
    to measure how long a series of operations takes. This enables you to establish
    that a particular code path is actually responsible for observed performance issues.
    It also enables you to establish an objective measure for the progress of your
    optimization efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Boost’s Timer library contains the `boost::timer::auto_cpu_timer` class in the
    `<boost/timer/timer.hpp>` header, which is an RAII object that begins timing in
    its constructor and stops timing in its destructor.
  prefs: []
  type: TYPE_NORMAL
- en: You can build your own makeshift `Stopwatch` class using just the stdlib Chrono
    library. The `Stopwatch` class can keep a reference to a `duration` object. In
    the `Stopwatch` destructor, you can set the `duration` via its reference. [Listing
    12-25](ch12.xhtml#ch12ex25) provides an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-25: A simple `Stopwatch` class that computes the duration of its
    lifetime*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Stopwatch` constructor requires a single `nanoseconds` reference ➊, which
    you store into the `result` field with a member initializer ➋. You also save the
    current time of the `high_resolution_clock` by setting the `start` field to the
    result of `now()` ➌. In the `Stopwatch` destructor, you again invoke `now()` on
    the `high_resolution_clock` and subtract `start` to obtain the duration of the
    lifetime of `Stopwatch`. You use the `result` reference to write the `duration`
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-26](ch12.xhtml#ch12ex26) shows the `Stopwatch` in action, performing
    a million floating-point divisions within a loop and computing the average time
    elapsed per iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-26: Using the `Stopwatch` to estimate the time taken for `double`
    division*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you initialize a variable `n` to a million, which stores the total number
    of iterations your program will make ➊. You declare the `elapsed` variable, which
    will store the time elapsed across all the iterations ➋. Within a block, you declare
    a `Stopwatch` and pass an `elapsed` reference to the constructor ➌. Next, you
    declare a `double` called `result` with a junk value in it ➍. You declare this
    variable `volatile` so the compiler doesn’t try to optimize the loop away. Within
    the loop, you do some arbitrary, floating-point division ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Once the block completes, `stopwatch` destructs. This writes the duration of
    `stopwatch` to `elapsed`, which you use to compute the average number of nanoseconds
    per loop iteration and store into the `time_per_addition` variable ➏. You conclude
    the program by printing `time_per_division` with `printf` ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '**Numerics**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section discusses handling numbers with a focus on common mathematical
    functions and constants; handling complex numbers; generating random numbers,
    numeric limits, and conversions; and computing ratios.
  prefs: []
  type: TYPE_NORMAL
- en: '***Numeric Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The stdlib Numerics and Boost Math libraries provide a profusion of numeric/mathematical
    functions. For the sake of brevity, this chapter presents only quick references.
    For detailed treatment, see [numerics] in the ISO C++ 17 Standard and the Boost
    Math documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-11](ch12.xhtml#ch12tab11) provides a partial list of many common,
    non-member mathematical functions available in the stdlib’s Math library.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-11:** A Partial List of Common Math Functions in the stdlib'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Computes the . . .** | **Ints** | **Floats** | **Header**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `abs(`x`)` | Absolute value of x. | ✓ |  | `<cstdlib>` |'
  prefs: []
  type: TYPE_TB
- en: '| `div(`x`,` y`)` | Quotient and remainder of x divided by y. | ✓ |  | `<cstdlib>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `abs(`x`)` | Absolute value of x. |  | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `fmod(`x`,` y`)` | Remainder of floating-point division of x by y. |  | ✓
    | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `remainder(`x`,` y`)` | Signed remainder of dividing x by y. | ✓ | ✓ | `<cmath>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fma(`x`,` y`,` z`)` | Multiply the first two arguments and add their product
    to the third argument; also called fused multiplication addition; that is, x *
    y `+` z. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(`x`,` y`)` | Maximum of x and y. | ✓ | ✓ | `<algorithm>` |'
  prefs: []
  type: TYPE_TB
- en: '| `min(`x`,` y`)` | Minimum of x and y. | ✓ | ✓ | `<algorithm>` |'
  prefs: []
  type: TYPE_TB
- en: '| `exp(`x`)` | Value of `e`^x. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `exp2(`x`)` | Value of `2^x`. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `log(`x`)` | Natural log of x; that is, ln x. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `log10(`x`)` | Common log of x; that is, log10 x. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `log2(`x`)` | Base 2 log of x; that is, log10 x. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `gcd(`x`,` y`)` | Greatest common denominator of x and y. | ✓ |  | `<numeric>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `lcm(`x`,` y`)` | Least common multiple of x and y. | ✓ |  | `<numeric>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `erf(`x`)` | Gauss error function of x. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `pow(`x`,` y`)` | Value of x^y. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt(`x`)` | Square root of x. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `cbrt(`x`)` | Cube root of x. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `hypot(`x`,` y`)` | Square root of x² `+` y². | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `sin(`x`)``cos(`x`)``tan(`x`)``asin(`x`)``acos(`x`)``atan(`x`)` | Associated
    trigonometric function value. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `sinh(`x`)``cosh(`x`)``tanh(`x`)``asinh(`x`)``acosh(`x`)``atanh(`x`)` | Associated
    hyperbolic function value. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil(`x`)` | Nearest integer greater than or equal to x. | ✓ | ✓ | `<cmath>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `floor(`x`)` | Nearest integer less than or equal to x. | ✓ | ✓ | `<cmath>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `round(`x`)` | Nearest integer equal to x; rounds away from zero in midpoint
    cases. | ✓ | ✓ | `<cmath>` |'
  prefs: []
  type: TYPE_TB
- en: '| `isfinite(`x`)` | Value `true` if x is a finite number. | ✓ | ✓ | `<cmath>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isinf(`x`)` | Value `true` if x is an infinite number. | ✓ | ✓ | `<cmath>`
    |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Other specialized mathematical functions are in the `<cmath>` header. For
    example, functions to compute Laguerre and Hermite polynomials, elliptic integrals,
    cylindrical Bessel and Neumann functions, and the Riemann zeta function appear
    in the header.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Complex Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *complex number* is of the form `a+bi`, where `i` is an *imaginary number*
    that, when multiplied by itself, equals negative one; that is, `i*i=-1`. Imaginary
    numbers have applications in control theory, fluid dynamics, electrical engineering,
    signal analysis, number theory, and quantum physics, among other fields. The `a`
    portion of a complex number is called its *real component*, and the `b` portion
    is called the *imaginary component*.
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib offers the `std::complex` class template in the `<complex>` header.
    It accepts a template parameter for the underlying type of the real and imaginary
    component. This template parameter must be one of the fundamental floating-point
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct a `complex`, you can pass in two arguments: the real and the imaginary
    components. The `complex` class also supports copy construction and copy assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: The non-member functions `std::real` and `std::imag` can extract the real and
    imaginary components from a `complex`, respectively, as [Listing 12-27](ch12.xhtml#ch12ex27)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-27: Constructing a `std::complex` and extracting its components*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `std::complex` with a real component of 0.5 and an imaginary
    component of 14.13 ➊. You use `std::real` to extract the real component ➋ and
    `std::imag` to extract the imaginary component ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-12](ch12.xhtml#ch12tab12) contains a partial list of supported operations
    with `std::complex`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-12:** A Partial List of `std::complex` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| c1+c2c1-c2c1*c2c1/c2 | Performs addition, subtraction, multiplication, and
    division. |'
  prefs: []
  type: TYPE_TB
- en: '| c+sc-sc*sc/s | Converts the scalar s into a complex number with the real
    component equal to the scalar value and the imaginary component equal to zero.
    This conversion supports the corresponding complex operation (addition, subtraction,
    multiplication, or division) in the preceding row. |'
  prefs: []
  type: TYPE_TB
- en: '| `real``(`c`)` | Extracts real component. |'
  prefs: []
  type: TYPE_TB
- en: '| `imag``(`c`)` | Extracts imaginary component. |'
  prefs: []
  type: TYPE_TB
- en: '| `abs``(`c`)` | Computes magnitude. |'
  prefs: []
  type: TYPE_TB
- en: '| `arg``(`c`)` | Computes the phase angle. |'
  prefs: []
  type: TYPE_TB
- en: '| `norm``(`c`)` | Computes the squared magnitude. |'
  prefs: []
  type: TYPE_TB
- en: '| `conj``(`c`)` | Computes the complex conjugate. |'
  prefs: []
  type: TYPE_TB
- en: '| `proj``(`c`)` | Computes Riemann sphere projection. |'
  prefs: []
  type: TYPE_TB
- en: '| `sin``(`c`)` | Computes the sine. |'
  prefs: []
  type: TYPE_TB
- en: '| `cos``(`c`)` | Computes the cosine. |'
  prefs: []
  type: TYPE_TB
- en: '| `tan``(`c`)` | Computes the tangent. |'
  prefs: []
  type: TYPE_TB
- en: '| `asin``(`c`)` | Computes the arcsine. |'
  prefs: []
  type: TYPE_TB
- en: '| `acos``(`c`)` | Computes the arccosine. |'
  prefs: []
  type: TYPE_TB
- en: '| `atan``(`c`)` | Computes the arctangent. |'
  prefs: []
  type: TYPE_TB
- en: '| c `= polar(`m`,` a`)` | Computes complex number determined by magnitude m
    and angle a. |'
  prefs: []
  type: TYPE_TB
- en: '***Mathematical Constants***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Boost offers a suite of commonly used mathematical constants in the `<boost
    /math/constants/constants.hpp>` header. More than 70 constants are available,
    and you can obtain them in `float`, `double`, or `long double` form by obtaining
    the relevant global variable from the `boost::math::float_constants`, `boost::math::double_constants`,
    and `boost::math::long_double_constants` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: One of the many constants available is `four_thirds_pi`, which approximates
    4`π`/3\. The formula for computing the volume of a sphere of radius *r* is 4π*r*³/3,
    so you could pull in this constant to make computing such a volume easy. [Listing
    12-28](ch12.xhtml#ch12ex28) illustrates how to compute the volume of a sphere
    with radius 10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-28: The `boost::math` namespace offers constants*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you pull in the namespace `boost::math::double_constants`, which brings
    all the `double` versions of the Boost Math constants ➊. Next, you calculate the
    `sphere_volume` by computing `four_thirds_pi` times 10³ ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-13](ch12.xhtml#ch12tab13) provides some of the more commonly used
    constants in Boost Math.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-13:** Some of the Most Common Boost Math Constants'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constant** | **Value** | **Approx.** | **Note** |'
  prefs: []
  type: TYPE_TB
- en: '| `half` | 1/2 | 0.5 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `third` | 1/3 | 0.333333 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `two_thirds` | 2/3 | 0.66667 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `three_quarters` | 3/4 | 0.75 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `root_two` | √2 | 1.41421 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `root_three` | √3 | 1.73205 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `half_root_two` | √2 / 2 | 0.707106 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ln_two` | ln(2) | 0.693147 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ln_ten` | ln(10) | 2.30258 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `pi` | π | 3.14159 | Archimedes’ constant |'
  prefs: []
  type: TYPE_TB
- en: '| `two_pi` | 2π | 6.28318 | Circumference of unit circle |'
  prefs: []
  type: TYPE_TB
- en: '| `four_thirds_pi` | 4π/3 | 4.18879 | Volume of unit sphere |'
  prefs: []
  type: TYPE_TB
- en: '| `one_div_two_pi` | 1/(2π) | 1.59155 | Gaussian integrals |'
  prefs: []
  type: TYPE_TB
- en: '| `root_pi` | √ π | 1.77245 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | e | 2.71828 | Euler’s constant e |'
  prefs: []
  type: TYPE_TB
- en: '| `e_pow_pi` | e^π | 23.14069 | Gelfond’s constant |'
  prefs: []
  type: TYPE_TB
- en: '| `root_e` | √e | 1.64872 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `log10_e` | log10(e) | 0.434294 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `degree` | π / 180 | 0.017453 | Number of radians per degree |'
  prefs: []
  type: TYPE_TB
- en: '| `radian` | 180 / π | 57.2957 | Number of degrees per radian |'
  prefs: []
  type: TYPE_TB
- en: '| `sin_one` | sin(1) | 0.84147 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cos_one` | cos(1) | 0.5403 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `phi` | (1 + √5) / 2 | 1.61803 | Phidias’ golden ratio φ |'
  prefs: []
  type: TYPE_TB
- en: '| `ln_phi` | ln(φ) | 0.48121 |  |'
  prefs: []
  type: TYPE_TB
- en: '***Random Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some settings, it’s often necessary to generate random numbers. In scientific
    computing, you might need to run large numbers of simulations based on random
    numbers. Such numbers need to emulate draws from random processes with certain
    characteristics, such as coming from a Poisson or normal distribution. In addition,
    you usually want these simulations to be repeatable, so the code responsible for
    generating randomness—the random number engine—should produce the same output
    given the same input. Such random number engines are sometimes called pseudo-random
    number engines.
  prefs: []
  type: TYPE_NORMAL
- en: In cryptography, you might require random numbers to instead secure information.
    In such settings, it must be virtually impossible for someone to obtain a similar
    stream of random numbers; so accidental use of pseudorandom number engines often
    seriously compromises an otherwise secure cryptosystem.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons and others, *you should never attempt to build your own random
    number generator*. Building a correct random number generator is surprisingly
    difficult. It’s too easy to introduce patterns into your random number generator,
    which can have nasty and hard to diagnose side effects on systems that use your
    random numbers as input.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re interested in random number generation, refer to [Chapter 2](ch02.xhtml#ch02)
    of Stochastic Simulation by Brian D. Ripley for scientific applications and [Chapter
    2](ch02.xhtml#ch02) of Serious Cryptography by Jean-Philippe Aumasson for cryptographic
    applications.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re in the market for random numbers, look no further than the Random
    libraries available in the stdlib in the `<random>` header or in Boost in the
    `<boost/math/...>` headers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Random Number Engines**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Random number engines generate random bits. Between Boost and stdlib, there
    is a dizzying array of candidates. Here’s a general rule: if you need repeatable
    pseudo-random numbers, consider using the Mersenne Twister engine `std::mtt19937_64`.
    If you need cryptographically secure random numbers, consider using `std::random_device`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Mersenne Twister has some desirable statistical properties for simulations.
    You provide its constructor with an integer seed value, which completely determines
    the sequence of random numbers. All random engines are function objects; to obtain
    a random number, use the function call `operator()`. [Listing 12-29](ch12.xhtml#ch12ex29)
    shows how to construct a Mersenne Twister engine with the seed 91586 and invoke
    the resulting engine three times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-29: The `mt19937_64` is a pseudo-random number engine.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you construct an `mt19937_64` Mersenne Twister engine with the seed 91586
    ➊. Because it’s a pseudo-random engine, you’re guaranteed to get the same sequence
    of random numbers ➋ ➌ ➍ each time. This sequence is determined entirely by the
    seed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-30](ch12.xhtml#ch12ex30) illustrates how to construct a `random_device`
    and invoke it to obtain a cryptographically secure random value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-30: The `random_device` is a function object.*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `random_device` using the default constructor ➊. The resulting
    object `rd_engine` ➋ is invokable, but you should treat the object as opaque.
    Unlike the Mersenne Twister in [Listing 12-29](ch12.xhtml#ch12ex29), `random_device`
    is unpredictable by design.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because computers are deterministic by design, the `std::random_device` cannot
    make any strong guarantees about cryptographic security.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random Number Distributions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *random number distribution* is a mathematical function that maps a number
    to a probability density. Roughly, the idea is that if you take infinite samples
    from a random variable that has a particular distribution and you plot the relative
    frequencies of your sample values, that plot would look like the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Distributions break out into two broad categories: *discrete* and *continu**ous*.
    A simple analogy is that discrete distributions map integral values, and continuous
    distributions map floating-point values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most distributions accept customization parameters. For example, the normal
    distribution is a continuous distribution that accepts two parameters: a mean
    and a variance. Its density has a familiar bell shape centered around the mean,
    as shown in [Figure 12-1](ch12.xhtml#ch12fig01). The discrete uniform distribution
    is a random number distribution that assigns equal probability to the numbers
    between some minimum and maximum. Its density looks perfectly flat across its
    range from minimum to maximum, as shown in [Figure 12-2](ch12.xhtml#ch12fig02).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: A representation of the normal distribution’s probability density
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: A representation of the uniform distribution’s probability density
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily generate random numbers from common statistical distributions,
    such as the uniform and the normal, using the same stdlib Random library. Each
    distribution accepts some parameters in its constructor, corresponding to the
    underlying distribution’s parameters. To draw a random variable from the distribution,
    you use the function call `operator()` and pass in an instance of a random number
    engine, such as a Mersenne Twister.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::uniform_int_distribution` is a class template available in the `<random>`
    header that takes a single template parameter corresponding to the type you want
    returned by draws from the distribution, like an `int`. You specify the uniform
    distribution’s minimum and maximum by passing them in as constructor parameters.
    Each number in the range has equal probability. It’s perhaps the most common distribution
    to arise in general software engineering contexts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-31](ch12.xhtml#ch12ex31) illustrates how to take a million draws
    from a uniform distribution with a minimum of 1 and a maximum of 10 and compute
    the sample mean.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-31: The `uniform_int_distribution` simulates draws from the discrete
    uniform distribution.*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a Mersenne Twister with the seed 102787 ➊ and then construct a
    `uniform_int_distribution` with a minimum of 0 and a maximum of 10 ➋. Then you
    initialize a variable `n` to hold the number of iterations ➌ and initialize a
    variable to hold the `sum` of all the uniform random variables ➍. In the loop,
    you draw random variables from the uniform distribution with `operator()`, passing
    in the Mersenne Twister instance ➎.
  prefs: []
  type: TYPE_NORMAL
- en: The mean of a discrete uniform distribution is the minimum plus the maximum
    divided by 2\. Here, `int_d` has a mean of 5\. You can compute a sample mean by
    dividing `sum` by the number of samples `n` ➏. With high confidence, you assert
    that this `sample_mean` is approximately 5 ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Random Number Distributions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-14](ch12.xhtml#ch12tab14) contains a partial list of the random number
    distributions in `<random>`, their default template parameters, and their constructor
    parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-14:** Random Number Distributions in `<random>`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Distribution** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `uniform_int_distribution<int>{` min`,` max `}` | Discrete uniform distribution
    with minimum min and maximum max. |'
  prefs: []
  type: TYPE_TB
- en: '| `uniform_real_distribution<double>{` min`,` max `}` | Continuous uniform
    distribution with minimum min and maximum max. |'
  prefs: []
  type: TYPE_TB
- en: '| `normal_distribution<double>{` m`,` s `}` | Normal distribution with mean
    m and standard deviation s. Commonly used to model the additive product of many
    independent random variables. Also called the Gaussian distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `lognormal_distribution<double>{` m`,` s `}` | Log-normal distribution with
    mean m and standard deviation s. Commonly used to model the multiplicative product
    of many independent random variables. Also called Galton’s distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `chi_squared_distribution<double>{` n `}` | Chi-squared distribution with
    degrees of freedom n. Commonly used in inferential statistics. |'
  prefs: []
  type: TYPE_TB
- en: '| `cauchy_distribution<double>{` a`,` b `}` | Cauchy distribution with location
    parameter a and scale parameter b. Used in physics. Also called the Lorentz distribution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fisher_f_distribution<double>{` m`,` n `}` | F distribution with degrees
    of freedom m and n. Commonly used in inferential statistics. Also called the Snedecor
    distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `student_t_distribution<double>{` n `}` | T distribution with degrees of
    freedom n. Commonly used in inferential statistics. Also called the Student’s
    T distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `bernoulli_distribution{` p `}` | Bernoulli distribution with success probability
    p. Commonly used to model the result of a single, Boolean-valued outcome. |'
  prefs: []
  type: TYPE_TB
- en: '| `binomial_distribution<int>{` n`,` p `}` | Binomial distribution with n trials
    and success probability p. Commonly used to model the number of successes when
    sampling with replacement in a series of Bernoulli experiments. |'
  prefs: []
  type: TYPE_TB
- en: '| `geometric_distribution<int>{` p `}` | Geometric distribution with success
    probability p. Commonly used to model the number of failures occurring before
    the first success in a series of Bernoulli experiments. |'
  prefs: []
  type: TYPE_TB
- en: '| `poisson_distribution<int>{` m `}` | Poisson distribution with mean m. Commonly
    used to model the number of events occurring in a fixed interval of time. |'
  prefs: []
  type: TYPE_TB
- en: '| `exponential_distribution<double>{` l `}` | Exponential distribution with
    mean 1/l, where l is known as the lambda parameter. Commonly used to model the
    amount of time between events in a Poisson process. |'
  prefs: []
  type: TYPE_TB
- en: '| `gamma_distribution<double>{` a`,` b `}` | Gamma distribution with shape
    parameter a and scale parameter b. Generalization of the exponential distribution
    and chi-squared distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| `weibull_distribution<double>{` k`,` l `}` | Weibull distribution with shape
    parameter k and scale parameter l. Commonly used to model time to failure. |'
  prefs: []
  type: TYPE_TB
- en: '| `extreme_value_distribution<double>{` a`,` b `}` | Extreme value distribution
    with location parameter a and scale parameter b. Commonly used to model maxima
    of independent random variables. Also called the Gumbel type-I distribution. |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost Math offers more random number distributions in the `<boost/math/...>`
    series of headers, for example, the beta, hypergeometric, logistic, and inverse
    normal distributions.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Numeric Limits***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The stdlib offers the class template `std::numeric_limits` in the `<limits>`
    header to provide you with compile time information about various properties for
    arithmetic types. For example, if you want to identify the smallest finite value
    for a given type `T`, you can use the static member function `std::numeric_limits<T>::min()`
    to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-32](ch12.xhtml#ch12ex32) illustrates how to use `min` to facilitate
    an underflow.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-32: Using `std::numeric_limits<T>::min()` to facilitate an `int`
    underflow. Although at press time the major compilers produce code that passes
    the test, this program contains undefined behavior.*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you set the `my_cup` variable equal to the smallest possible `int` value
    by using `std::numeric_limits<int>::min()` ➊. Next, you intentionally cause an
    underflow by subtracting 1 from `my_cup` ➋. Because `my_cup` is the minimum value
    an `int` can take, `my_cup` runneth under, as the saying goes. This causes the
    deranged situation that `underfloweth` is greater than `my_cup` ➌, even though
    you initialized `underfloweth` by subtracting from `my_cup`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Such silent underflows have been the cause of untold numbers of software security
    vulnerabilities. Don’t rely on this undefined behavior!*'
  prefs: []
  type: TYPE_NORMAL
- en: Many static member functions and member constants are available on `std::numeric_limits`.
    [Table 12-15](ch12.xhtml#ch12tab15) lists some of the most common.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-15:** Some Common Member Constants in `std::numeric_limits`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric_limits<`T`>::is_signed` | `true` if T is signed. |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric_limits<`T`>::is_integer` | `true` if T is an integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric_limits<`T`>::has_infinity` | Identifies whether T can encode an
    infinite value. (Usually, all floating-point types have an infinite value, whereas
    integral types don’t.) |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric_limits<`T`>::digits10` | Identifies the number of digits T can represent.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric_limits<`T`>::min()` | Returns the smallest value of T. |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric_limits<`T`>::max()` | Returns the largest value of T. |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Boost Integer provides some additional facilities for introspecting integer
    types, such as determining the fastest or smallest integer, or the smallest integer
    with at least *N* bits.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Boost Numeric Conversion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Boost provides the Numeric Conversion library, which contains a collection
    of tools to convert between numeric objects. The `boost::converter` class template
    in the `<boost/numeric/conversion/converter.hpp>` header encapsulates code to
    perform a specific numeric conversion from one type to another. You must provide
    two template parameters: the target type `T` and the source type S. You can specify
    a numeric converter that takes a `double` and converts it to an `int` with the
    simple type alias `double_to_int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To convert with your new type alias `double_to_int`, you have several options.
    First, you can use its static method `convert`, which accepts a `double` ➋ and
    returns an `int` ➊, as [Listing 12-33](ch12.xhtml#ch12ex33) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-33: The `boost::converter` offers the static method `convert`.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you simply invoke the `convert` method with the value 3.14159, which `boost::convert`
    converts to 3.
  prefs: []
  type: TYPE_NORMAL
- en: Because `boost::convert` provides the function call `operator()`, you can construct
    a function object `double_to_int` and use it to convert, as in [Listing 12-34](ch12.xhtml#ch12ex34).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-34: The `boost::converter` implements `operator()`.*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a `double_to_int` function object called `dti` ➊, which you invoke
    with the same argument, 3.14159 ➋, as in [Listing 12-33](ch12.xhtml#ch12ex33).
    The result is the same. You also have the option of constructing a temporary function
    object and using `operator()` directly, which yields identical results ➌.
  prefs: []
  type: TYPE_NORMAL
- en: A major advantage of using `boost::converter` instead of alternatives like `static_cast`
    is runtime bounds checking. If a conversion would cause an overflow, `boost::converter`
    will throw a `boost::numeric::positive_overflow` or `boost::numeric::negative_overflow`.
    [Listing 12-35](ch12.xhtml#ch12ex35) illustrates this behavior when you attempt
    to convert a very large `double` into an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-35: The `boost::converter` checks for overflow.*'
  prefs: []
  type: TYPE_NORMAL
- en: You use `numeric_limits` to obtain a `yuge` value ➊. You construct a `double
    _``to_int` converter ➋, which you use to attempt a conversion of `yuge` to an
    `int` ➌. This throws a `positive_overflow` exception because the value is too
    large to store ➍.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to customize the conversion behavior of `boost::converter` using
    template parameters. For example, you can customize the overflow handling to throw
    a custom exception or perform some other operation. You can also customize rounding
    behavior so that rather than truncating off the decimal from a floating-point
    value, you perform custom rounding. See the Boost Numeric Conversion documentation
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re happy with the default `boost::converter` behavior, you can use the
    `boost::numeric_cast` function template as a shortcut. This function template
    accepts a single template parameter corresponding to the target type of the conversion
    and a single argument corresponding to the source number. [Listing 12-36](ch12.xhtml#ch12ex36)
    provides an update to [Listing 12-35](ch12.xhtml#ch12ex35) that uses `boost::numeric_cast`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-36: The `boost::numeric_cast` function template also performs runtime
    bounds checking.*'
  prefs: []
  type: TYPE_NORMAL
- en: As before, you use `numeric_limits` to obtain a `yuge` value ➊. When you try
    to `numeric_cast` `yuge` into an `int` ➋, you get a `positive_overflow` exception
    because the value is too large to store ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `boost::numeric_cast` function template is a suitable replacement for
    the `narrow_cast` you hand-rolled in [Listing 6-6](ch06.xhtml#ch06ex06) on [page
    154](ch06.xhtml#page_154).*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Compile-Time Rational Arithmetic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The stdlib `std::ratio` in the `<ratio>` header is a class template that enables
    you to compute rational arithmetic at compile time. You provide two template parameters
    to `std::ratio`: a numerator and a denominator. This defines a new type that you
    can use to compute rational expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: The way you perform compile-time computation with `std::ratio` is by using template
    metaprogramming techniques. For example, to multiply two `ratio` types, you can
    use the `std::ratio_multiply` type, which takes the two `ratio` types as template
    parameters. You can extract the numerator and denominator of the result using
    static member variables on the resulting type.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-37](ch12.xhtml#ch12ex37) illustrates how to multiply 10 by 2/3
    at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-37: Compile time rational arithmetic with `std::ratio`*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare the `std::ratio` types `ten` ➊ and `two_thirds` ➋ as type aliases.
    To compute the product of `ten` and `two_thirds`, you again declare another type,
    `result`, using the `std::ratio_multiply` template ➌. Using the static members
    `num` and `den`, you can extract the result, 20/3 ➍ ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’s always better to do computation at compile time rather than
    at runtime when you can. Your programs will be more efficient because they’ll
    need to do less computation when they run.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Partial List of Random Number Distributions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Table 12-16](ch12.xhtml#ch12tab16) contains a partial list of the operations
    provided by stdlib’s `<ratio>` library.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-16:** A Partial List of Operations Available in `<ratio>`'
  prefs: []
  type: TYPE_NORMAL
- en: '| Distribution | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_add<`r1`,` r2`>` | Adds r1 and r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_subtract<`r1`,` r2`>` | Subtracts r2 from r1 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_multiply<`r1`,` r2`>` | Multiplies r1 and r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_divide<`r1`,` r2`>` | Divides r1 by r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_equal<`r1`,` r2`>` | Tests whether r1 equals r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_not_equal<`r1`,` r2`>` | Tests whether r1 is not equal to r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_less<`r1`,` r2`>` | Tests whether r1 is less than r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_greater<`r1`,` r2`>` | Tests whether r1 is greater than r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_less_equal<`r1`,` r2`>` | Tests whether r1 is less than or equal to
    r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `ratio_greater_equal<`r1`,` r2`>` | Tests whether r1 is greater than or equal
    to r2 |'
  prefs: []
  type: TYPE_TB
- en: '| `micro` | Literal: `ratio<1, 1000000>` |'
  prefs: []
  type: TYPE_TB
- en: '| `milli` | Literal: `ratio<1, 1000>` |'
  prefs: []
  type: TYPE_TB
- en: '| `centi` | Literal: `ratio<1, 100>` |'
  prefs: []
  type: TYPE_TB
- en: '| `deci` | Literal: `ratio<1, 10>` |'
  prefs: []
  type: TYPE_TB
- en: '| `deca` | Literal: `ratio<10, 1>` |'
  prefs: []
  type: TYPE_TB
- en: '| `hecto` | Literal: `ratio<100, 1>` |'
  prefs: []
  type: TYPE_TB
- en: '| `kilo` | Literal: `ratio<1000, 1>` |'
  prefs: []
  type: TYPE_TB
- en: '| `mega` | Literal: `ratio<1000000, 1>` |'
  prefs: []
  type: TYPE_TB
- en: '| `giga` | Literal: `ratio<1000000000, 1>` |'
  prefs: []
  type: TYPE_TB
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you examined a potpourri of small, simple, focused utilities
    that service common programming needs. Data structures, such as `tribool`, `optional`,
    `pair`, `tuple`, `any`, and `variant` handle many commonplace scenarios in which
    you need to contain objects within a common structure. In the coming chapters,
    a few of these data structures will make repeat appearances throughout the stdlib.
    You also learned about date/time and numerics/math facilities. These libraries
    implement very specific functionality, but when you have such requirements, these
    libraries are invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: '**12-1.** Reimplement the `narrow_cast` in [Listing 6-6](ch06.xhtml#ch06ex06)
    to return a `std::optional`. If the cast would result in a narrowing conversion,
    return an empty optional rather than throwing an exception. Write a unit test
    that ensures your solution works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**12-2.** Implement a program that generates random alphanumeric passwords
    and writes them to the console. You can store the alphabet of possible characters
    into a `char[]` and use the discrete uniform distribution with a minimum of zero
    and a maximum of the last index of your alphabet array. Use a cryptographically
    secure random number engine.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    M. Josuttis (Addison-Wesley Professional, 2012)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
