- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: UTILITIES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实用工具**
- en: “*See, the world is full of things more powerful than us. But if you know how
    to catch a ride, you can go places,” Raven says.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “*看，世界上有比我们更强大的东西。但如果你知道怎么搭顺风车，你就能去到任何地方，” Raven 说。
- en: “Right. I’m totally hip to what you’re saying.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “没错，我完全理解你在说什么。”
- en: —Neal Stephenson*, Snow Crash
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: — Neal Stephenson，《雪崩》
- en: '![Image](../images/common.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: The stdlib and Boost libraries provide a throng of types, classes, and functions
    that satisfy common programming needs. Together, this motley collection of tools
    is called *utilities*. Aside from their small, uncomplicated, and focused nature,
    utilities vary functionally.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: stdlib 和 Boost 库提供了大量满足常见编程需求的类型、类和函数。合起来，这些五花八门的工具被称为 *实用工具*。除了它们小巧、简洁且专注的特点，实用工具在功能上各不相同。
- en: In this chapter, you’ll learn about several simple *data structures* that handle
    many routine situations where you need objects to contain other objects. A discussion
    of *dates and times* follows, including coverage of several provisions for encoding
    calendars and clocks and for measuring elapsed time. The chapter wraps up with
    a trek through many *numerical and mathematical tools* available to you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习几种简单的 *数据结构*，它们处理许多常见情境，其中你需要让对象包含其他对象。接下来是关于 *日期和时间* 的讨论，涵盖了若干编码日历和时钟的方式以及测量经过时间的手段。本章的最后，我们将深入了解许多可用的
    *数值和数学工具*。
- en: '**NOTE**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The discussions of dates/times and numerics/math will be of great interest
    to certain readers and of only passing interest to others. If you are in the latter
    category, feel free to skim these sections.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*日期/时间和数值/数学的讨论将对某些读者非常有兴趣，而对其他人只是略有兴趣。如果你属于后者，可以随意浏览这些章节。*'
- en: '**Data Structures**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据结构**'
- en: Between them, the stdlib and Boost libraries provide a venerable collection
    of useful *data structures*. A *data structure* is a type that stores objects
    and permits some set of operations over those stored objects. There is no magic
    compiler pixie dust that makes the utility data structures in this section work;
    you could implement your own versions with sufficient time and effort. But why
    reinvent the wheel?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些库中，stdlib 和 Boost 提供了一个宝贵的有用的 *数据结构* 集合。*数据结构* 是一种存储对象并允许对这些存储对象进行一组操作的类型。并没有什么神奇的编译器魔法让本节中的实用数据结构工作；你完全可以在足够的时间和精力下实现你自己的版本。但是，为什么要重新发明轮子呢？
- en: '***tribool***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tribool***'
- en: 'The *tribool* is a `bool`-like type that supports three states rather than
    two: true, false, and indeterminate. Boost offers `boost::logic::tribool` in the
    `<boost/logic/tribool.hpp>` header. [Listing 12-1](ch12.xhtml#ch12ex01) demonstrates
    how to initialize Boost a `tribool` using `true`, `false`, and the `boost::logic::indeterminate`
    type.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*tribool* 是一种类似 `bool` 的类型，支持三种状态，而不是两种：真、假和不确定。Boost 提供了 `<boost/logic/tribool.hpp>`
    头文件中的 `boost::logic::tribool`。 [示例 12-1](ch12.xhtml#ch12ex01) 演示了如何使用 `true`、`false`
    和 `boost::logic::indeterminate` 类型初始化 Boost 的 `tribool`。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12-1: Initializing Boost `tribool`*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-1：初始化 Boost `tribool`*'
- en: For convenience, a `using` declaration pulls in `indeterminate` from `boost::logic`
    ➊. Then you initialize the `tribool t` equal to `true` ➋, `f` equal to `false`
    ➌, and `i` equal to `indeterminate` ➍.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，`using` 声明将 `indeterminate` 从 `boost::logic` 中拉入 ➊。然后，你将 `tribool t` 初始化为
    `true` ➋，`f` 初始化为 `false` ➌，`i` 初始化为 `indeterminate` ➍。
- en: The `tribool` class implicitly converts to `bool`. If a `tribool` is `true`,
    it converts to `true`; otherwise, it converts to `false`. The `tribool` class
    also supports `operator!`, which returns `true` if `tribool` is `false`; otherwise,
    it returns `false`. Finally, `indeterminate` supports `operator()`, which takes
    a single `tribool` argument and returns `true` if that argument is `indeterminate`;
    otherwise, it returns `false`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`tribool` 类会隐式转换为 `bool`。如果 `tribool` 是 `true`，它将转换为 `true`；否则，转换为 `false`。`tribool`
    类还支持 `operator!`，当 `tribool` 为 `false` 时返回 `true`；否则返回 `false`。最后，`indeterminate`
    支持 `operator()`，它接受一个 `tribool` 参数，如果该参数是 `indeterminate`，则返回 `true`；否则返回 `false`。'
- en: '[Listing 12-2](ch12.xhtml#ch12ex02) samples these Boolean conversions.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-2](ch12.xhtml#ch12ex02) 采样了这些布尔转换。'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 12-2: Converting a `tribool` to a `bool`*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-2：将 `tribool` 转换为 `bool`*'
- en: This test demonstrates the basic results from `bool` conversion ➊➋, `operator!`
    ➌➍, and `indeterminate` ➍➎.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试演示了 `bool` 转换 ➊➋、`operator!` ➌➍ 和 `indeterminate` ➍➎ 的基本结果。
- en: '**Boolean Operations**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔操作**'
- en: The `tribool` class supports all the Boolean operators. Whenever a `tribool`
    expression doesn’t involve an `indeterminate` value, the result is the same as
    the equivalent Boolean expression. Whenever an `indeterminate` is involved, the
    result can be `indeterminate`, as [Listing 12-3](ch12.xhtml#ch12ex03) illustrates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`tribool` 类支持所有布尔运算符。每当 `tribool` 表达式不涉及 `indeterminate` 值时，结果与等效的布尔表达式相同。当涉及
    `indeterminate` 时，结果可以是 `indeterminate`，正如[清单 12-3](ch12.xhtml#ch12ex03)所示。'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 12-3: The `boost::tribool` supports Boolean operations.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3：`boost::tribool` 支持布尔操作。*'
- en: Because neither `t` nor `f` is indeterminate, `t || f` evaluates just like an
    ordinary Boolean expression, so `t_or_f` is `true` ➊. Boolean expressions that
    involve an indeterminate can be indeterminate. Boolean AND ➋, OR ➌, and NOT ➍
    evaluate to `indeterminate` if there isn’t enough information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `t` 和 `f` 都不是 `indeterminate`，因此 `t || f` 的求值就像普通的布尔表达式一样，所以 `t_or_f` 为 `true`
    ➊。涉及 `indeterminate` 的布尔表达式可能会得到 `indeterminate`。布尔与 ➋、或 ➌、非 ➍ 操作在没有足够信息的情况下会求值为
    `indeterminate`。
- en: '**When to Use tribool**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**何时使用 tribool**'
- en: Aside from describing the vital status of Schrödinger’s cat, you can use `tri``bool`
    in settings in which operations can take a long time. In such settings, a `tribool`
    could describe whether the operation was successful. An `indeterminate` value
    could model that the operation is still pending.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了描述薛定谔的猫的生死状态，你还可以在某些操作可能需要较长时间的设置中使用 `tribool`。在这种情况下，`tribool` 可以描述操作是否成功。一个
    `indeterminate` 值可以表示操作仍在进行中。
- en: The `tribool` class makes for neat, concise `if` statements, as shown in [Listing
    12-4](ch12.xhtml#ch12ex04).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`tribool` 类使得 `if` 语句变得简洁明了，正如[清单 12-4](ch12.xhtml#ch12ex04)所示。'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 12-4: Using an `if` statement with `tribool`*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-4：使用 `if` 语句与 `tribool`*'
- en: The first expression ➊ evaluates only if the `tribool` is `true`, the second
    expression ➋ evaluates only if it’s `false`, and the third only executes in the
    `indeterminate` case ➌.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式 ➊ 仅在 `tribool` 为 `true` 时求值，第二个表达式 ➋ 仅在其为 `false` 时求值，第三个表达式 ➌ 仅在 `indeterminate`
    情况下执行。
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The mere mention of a `tribool` might have caused you to scrunch up your face
    in disgust. Why, you might ask, couldn’t you just use an integer where 0 is false,
    1 is true, and any other value is indeterminate? You could, but consider that
    the `tribool` type supports all the usual Boolean operations while correctly propagating
    indeterminate values. Again, why reinvent the wheel?*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*提到 `tribool` 可能会让你不禁皱眉头，心想，为什么不用整数表示，0 为 false，1 为 true，其他值为 indeterminate
    呢？你可以这样做，但考虑到 `tribool` 类型支持所有常见的布尔操作，同时能正确传播 `indeterminate` 值。为什么要重新发明轮子呢？*'
- en: '**A Partial List of Supported Operations**'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**部分支持的操作列表**'
- en: '[Table 12-1](ch12.xhtml#ch12tab01) provides a list of the most supported `boost::tribool`
    operations. In this table, `tb` is a `boost::tribool`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](ch12.xhtml#ch12tab01) 提供了最常用的 `boost::tribool` 操作列表。在此表中，`tb` 是一个
    `boost::tribool`。'
- en: '**Table 12-1:** The Most Supported `boost::tribool` Operations'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-1：** 最常用的 `boost::tribool` 操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `tribool{}` `tribool{ false }` | Constructs a `tribool` with value `false`.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `tribool{}` `tribool{ false }` | 构造一个值为 `false` 的 `tribool`。 |'
- en: '| `tribool{ true }` | Constructs a `tribool` with value `true`. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `tribool{ true }` | 构造一个值为 `true` 的 `tribool`。 |'
- en: '| `tribool{ indeterminate }` | Constructs a `tribool` with value `indeterminate`.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `tribool{ indeterminate }` | 构造一个值为 `indeterminate` 的 `tribool`。 |'
- en: '| tb`.safe_bool()` | Evaluates to `true` if tb is `true`, else `false`. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| tb`.safe_bool()` | 如果 tb 为 `true`，则结果为 `true`，否则为 `false`。 |'
- en: '| `indeterminate(`tb`)` | Evaluates to `true` if tb is `indeterminate`, else
    `false`. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `indeterminate(`tb`)` | 如果 tb 是 `indeterminate`，则结果为 `true`，否则为 `false`。
    |'
- en: '| !tb | Evaluates to `true` if tb is `false`, else `false`. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| !tb | 如果 tb 为 `false`，则结果为 `true`，否则为 `false`。 |'
- en: '| tb1 `&&` tb2 | Evaluates to `true` if tb1 and tb2 are `true`; evaluates to
    `false` if tb1 or tb2 are `false`; otherwise, `indeterminate`. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| tb1 `&&` tb2 | 如果 tb1 和 tb2 都为 `true`，则结果为 `true`；如果 tb1 或 tb2 为 `false`，则结果为
    `false`；否则，结果为 `indeterminate`。 |'
- en: '| tb1 `&#124;&#124;` tb2 | Evaluates to `true` if tb1 or tb2 are `true`; evaluates
    to `false` if tb1 and tb2 are `false`; otherwise, `indeterminate`. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| tb1 `&#124;&#124;` tb2 | 如果 tb1 或 tb2 为 `true`，则结果为 `true`；如果 tb1 和 tb2 都为
    `false`，则结果为 `false`；否则，结果为 `indeterminate`。 |'
- en: '| `bool{` tb `}` | Evaluates to `true` if tb is true, else `false`. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `bool{` tb `}` | 如果 tb 为 true，则结果为 `true`，否则为 `false`。 |'
- en: '***optional***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可选***'
- en: An *optional* is a class template that contains a value that might or might
    not be present. The primary use case for an `optional` is the return type of a
    function that might fail. Rather than throwing an exception or returning multiple
    values, a function can instead return an `optional` that will contain a value
    if the function succeeded.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*optional* 是一个类模板，包含一个可能存在也可能不存在的值。`optional` 的主要使用场景是作为可能失败的函数的返回类型。与其抛出异常或返回多个值，不如让函数返回一个
    `optional`，如果函数成功执行，`optional` 会包含一个值。'
- en: The stdlib has `std::optional` in the `<optional>` header, and Boost has `boost::optional`
    in the `<boost/optional.hpp>` header.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在 `<optional>` 头文件中提供了 `std::optional`，Boost 在 `<boost/optional.hpp>` 头文件中提供了
    `boost::optional`。
- en: Consider the setup in [Listing 12-5](ch12.xhtml#ch12ex05). The function `take`
    wants to return an instance of `TheMatrix` only if you take a `Pill::Blue`; otherwise,
    `take` returns a `std::nullopt`, which is a stdlib-provided constant `std::optional`
    type with uninitialized state.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [清单 12-5](ch12.xhtml#ch12ex05) 中的设置。`take` 函数仅在你选择 `Pill::Blue` 时才返回一个 `TheMatrix`
    实例；否则，`take` 返回一个 `std::nullopt`，这是一个未初始化状态的标准库提供的 `std::optional` 类型常量。
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 12-5: A `take` function returning a `std::optional`*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-5：一个返回 `std::optional` 的 `take` 函数*'
- en: The `TheMatrix` type takes a single `int` constructor argument and stores it
    into the `iteration` member ➊. The `enum` called `Pill` takes the values `Red`
    and `Blue` ➋. The `take` function returns a `std::optional<TheMatrix>` ➌ and accepts
    a single `Pill` argument ➍. If you pass `Pill::Blue` to the take function, it
    returns a `TheMatrix` instance ➎; otherwise, it returns a `std::nullopt` ➏.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`TheMatrix` 类型接受一个 `int` 类型的构造函数参数，并将其存储到 `iteration` 成员中 ➊。`enum` 类型 `Pill`
    包含 `Red` 和 `Blue` 两个值 ➋。`take` 函数返回一个 `std::optional<TheMatrix>` ➌，并接受一个 `Pill`
    类型的参数 ➍。如果传入 `Pill::Blue` 给 `take` 函数，它会返回一个 `TheMatrix` 实例 ➎；否则，它会返回一个 `std::nullopt`
    ➏。'
- en: First, consider [Listing 12-6](ch12.xhtml#ch12ex06), where you take the blue
    pill.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，参考 [清单 12-6](ch12.xhtml#ch12ex06)，你选择了蓝色药丸。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-6: A test exploring the `std::optional` type with `Pill::Blue`*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-6：测试探索 `std::optional` 类型与 `Pill::Blue` 的使用*'
- en: You take the blue pill, which results in the `std::optional` result containing
    an initialized `TheMatrix`, so the `if` statement’s conditional expression evaluates
    to `true` ➊. [Listing 12-6](ch12.xhtml#ch12ex06) also demonstrates the use of
    `operator->` ➋ and `value()` ➌ to access the underlying value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择了蓝色药丸，结果是 `std::optional` 结果中包含一个初始化的 `TheMatrix`，因此 `if` 语句的条件表达式会计算为 `true`
    ➊。[清单 12-6](ch12.xhtml#ch12ex06) 还演示了如何使用 `operator->` ➋ 和 `value()` ➌ 来访问底层值。
- en: What happens when you take the red pill? Consider [Listing 12-7](ch12.xhtml#ch12ex07).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，选择红色药丸会发生什么呢？参考 [清单 12-7](ch12.xhtml#ch12ex07)。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 12-7: A test exploring the `std::optional` type with `Pill::Red`*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-7：测试探索 `std::optional` 类型与 `Pill::Red`*'
- en: You take the red pill ➊, and the resulting `matrix_opt` is empty. This means
    `matrix_opt` converts to `false` ➋ and `has_value()` also returns `false` ➌.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择了红色药丸 ➊，结果是 `matrix_opt` 为空。这意味着 `matrix_opt` 转换为 `false` ➋，并且 `has_value()`
    也返回 `false` ➌。
- en: '**A Partial List of Supported Operations**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**部分支持的操作列表**'
- en: '[Table 12-2](ch12.xhtml#ch12tab02) provides a list of the most supported `std::optional`
    operations. In this table, `opt` is a `std::optional<T>` and `t` is an object
    of type `T`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-2](ch12.xhtml#ch12tab02) 提供了最常见的 `std::optional` 操作列表。在此表中，`opt` 是 `std::optional<T>`
    类型，`t` 是类型为 `T` 的对象。'
- en: '**Table 12-2:** The Most Supported `std::optional` Operations'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-2：** 最常见的 `std::optional` 操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `optional<T>{}` `optional<T>{std::nullopt}` | Constructs an empty `optional`.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `optional<T>{}` `optional<T>{std::nullopt}` | 构造一个空的 `optional`。 |'
- en: '| `optional<T>{` opt `}` | Copy constructs an `optional` from opt. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `optional<T>{` opt `}` | 从 opt 复制构造一个 `optional`。 |'
- en: '| `optional<T>{ move(`opt`) }` | Move constructs an `optional` from opt, which
    is empty after the constructor completes. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `optional<T>{ move(`opt`) }` | 从 opt 移动构造一个 `optional`，构造完成后 opt 为空。 |'
- en: '| `optional<T>{` `t` `}` opt `=` t | Copies t into `optional`. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `optional<T>{` `t` `}` opt `=` t | 将 t 复制到 `optional` 中。 |'
- en: '| `optional<T>{ move(``t``) }` opt = `move(`t`)` | Moves t into `optional`.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `optional<T>{ move(``t``) }` opt = `move(`t`)` | 将 t 移动到 `optional` 中。 |'
- en: '| opt`->`mbr | Member dereference; accesses the mbr member of object contained
    by opt. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| opt`->`mbr | 成员解引用；访问由 opt 包含的对象的 mbr 成员。 |'
- en: '| `*`opt opt`.value()` | Returns a reference to the object contained by opt;
    `value()` checks for empty and throws `bad_optional_access`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `*`opt opt`.value()` | 返回对 opt 中包含的对象的引用；`value()` 检查是否为空，并抛出 `bad_optional_access`
    异常。 |'
- en: '| opt`.value_or(`T`{ ... })` | If opt contains an object, returns a copy; else
    returns the argument. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| opt`.value_or(`T`{ ... })` | 如果 `opt` 包含对象，则返回该对象的副本；否则返回该参数。 |'
- en: '| `bool{` opt `}` opt`.has_value()` | Returns `true` if opt contains an object,
    else `false`. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `bool{` opt `}` opt`.has_value()` | 如果 `opt` 包含对象，则返回 `true`；否则返回 `false`。
    |'
- en: '| opt1`.swap(`opt2`)` `swap(`opt1`,` opt2`)` | Swaps the objects contained
    by opt1 and opt2. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| opt1`.swap(`opt2`)` `swap(`opt1`,` opt2`)` | 交换 `opt1` 和 `opt2` 中包含的对象。 |'
- en: '| opt`.reset()` | Destroys object contained by opt, which is empty after `reset`.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| opt`.reset()` | 销毁 `opt` 中包含的对象，`opt` 在 `reset` 后为空。 |'
- en: '| opt`.emplace(...)` | Constructs a type in place, forwarding all arguments
    to the appropriate constructor. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| opt`.emplace(...)` | 在原地构造一个类型，将所有参数转发给适当的构造函数。 |'
- en: '| `make_optional<T>(...)` | Convenience function for constructing an `optional`;
    forwards arguments to the appropriate constructor. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `make_optional<T>(...)` | 构造 `optional` 的便捷函数；将参数转发给适当的构造函数。 |'
- en: '| opt1 `==` opt2opt1 `!=` opt2opt1 `>` opt2opt1 `>=` opt2opt1 `<` opt2opt1
    `<=` opt2 | When evaluating equality of two `optional` objects, `true` if both
    are empty or if both contain objects and those objects are equal; else `false`.
    For comparison, an empty `optional` is always less than an optional containing
    a value. Otherwise, the result is the comparison of the contained types. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| opt1 `==` opt2opt1 `!=` opt2opt1 `>` opt2opt1 `>=` opt2opt1 `<` opt2opt1
    `<=` opt2 | 在评估两个 `optional` 对象的相等性时，如果两个都为空或都包含对象且这些对象相等，则返回 `true`；否则返回 `false`。进行比较时，空的
    `optional` 总是小于包含值的 `optional`。否则，结果是比较所包含的类型。 |'
- en: '***pair***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***pair***'
- en: A *pair* is a class template that contains two objects of different types in
    a single object. The objects are ordered, and you can access them via the members
    `first` and `second`. A `pair` supports comparison operators, has defaulted copy/move
    constructors, and works with structured binding syntax.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*pair* 是一个类模板，包含两个不同类型的对象作为一个整体。对象是有序的，你可以通过 `first` 和 `second` 成员访问它们。`pair`
    支持比较运算符，具有默认的复制/移动构造函数，并支持结构化绑定语法。'
- en: The stdlib has `std::pair` in the `<utility>` header, and Boost has `boost::pair`
    in the `<boost/pair.hpp>` header.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在 `<utility>` 头文件中有 `std::pair`，而 Boost 在 `<boost/pair.hpp>` 头文件中有 `boost::pair`。
- en: '**NOTE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost also has `boost::compressed_pair` available in the `<boost/compressed_pair.hpp>`
    header. It’s slightly more efficient when one of the members is empty.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 还在 `<boost/compressed_pair.hpp>` 头文件中提供了 `boost::compressed_pair`。当其中一个成员为空时，它会稍微更高效。*'
- en: First, you create some simple types to make a pair out of, such as the simple
    `Socialite` and `Valet` classes in [Listing 12-8](ch12.xhtml#ch12ex08).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一些简单的类型来构造一个对，例如[清单12-8](ch12.xhtml#ch12ex08) 中的简单 `Socialite` 和 `Valet`
    类。
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 12-8: The `Socialite` and `Valet` classes*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-8：`Socialite` 和 `Valet` 类*'
- en: Now that you have a `Socialite` and a `Valet`, `bertie` and `reginald`, you
    can construct a `std::pair` and experiment with extracting elements. [Listing
    12-9](ch12.xhtml#ch12ex09) uses the `first` and `second` members to access the
    contained types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了 `Socialite` 和 `Valet` 类型的对象 `bertie` 和 `reginald`，你可以构造一个 `std::pair`
    并尝试提取元素。[清单12-9](ch12.xhtml#ch12ex09) 使用 `first` 和 `second` 成员来访问所包含的类型。
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 12-9: The `std::pair` supports member extraction.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-9：`std::pair` 支持成员提取。*'
- en: You construct a `std::pair` by passing in the objects you want to copy ➊. You
    use the `first` and `second` members of `std::pair` to extract the `Socialite`
    ➋ and `Valet` ➌ out of `inimitable_duo`. Then you can compare the `birthname`
    and `surname` members of these to their originals.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过传入想要复制的对象来构造一个 `std::pair` ➊。你可以使用 `std::pair` 的 `first` 和 `second` 成员从 `inimitable_duo`
    中提取出 `Socialite` ➋ 和 `Valet` ➌。然后，你可以将它们的 `birthname` 和 `surname` 成员与原始数据进行比较。
- en: '[Listing 12-10](ch12.xhtml#ch12ex10) shows `std::pair` member extraction and
    structured binding syntax.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-10](ch12.xhtml#ch12ex10) 显示了 `std::pair` 成员提取和结构化绑定语法。'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 12-10: The `std::pair` supports structured binding syntax.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-10：`std::pair` 支持结构化绑定语法。*'
- en: Here you use the structured binding syntax ➊ to extract references to the `first`
    and `second` members of `inimitable_duo` into `idle_rich` and `butler`. As in
    [Listing 12-9](ch12.xhtml#ch12ex09), you ensure that the `birthname` ➋ and `surname`
    ➌ match the originals.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用结构化绑定语法 ➊ 将 `inimitable_duo` 的 `first` 和 `second` 成员的引用提取到 `idle_rich`
    和 `butler` 中。正如[清单12-9](ch12.xhtml#ch12ex09)所示，你确保 `birthname` ➋ 和 `surname` ➌
    与原始数据匹配。
- en: '**A Partial List of Supported Operations**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持操作的部分列表**'
- en: '[Table 12-3](ch12.xhtml#ch12tab03) provides a list of the most supported `std::pair`
    operations. In this table, `pr` is a `std::pair<A, B>`, `a` is an object of type
    `A`, and `b` is an object of type `B`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[表12-3](ch12.xhtml#ch12tab03)提供了最常见的`std::pair`操作列表。在此表中，`pr`是一个`std::pair<A,
    B>`，`a`是`A`类型的对象，`b`是`B`类型的对象。'
- en: '**Table 12-3:** The Most Supported `std::pair` Operations'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-3：** 最常见的`std::pair`操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `pair<...>{}` | Constructs an empty `pair`. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `pair<...>{}` | 构造一个空的`pair`。 |'
- en: '| `pair<...>{` pr `}` | Copy constructs from pr. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `pair<...>{` pr `}` | 从pr进行复制构造。 |'
- en: '| `pair<...>{ move(`pr`) }` | Move constructs from pr. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `pair<...>{ move(`pr`) }` | 从pr进行移动构造。 |'
- en: '| `pair<...>{` a`,` b `}` | Constructs a `pair` by copying a and b. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `pair<...>{` a`,` b `}` | 通过复制a和b构造一个`pair`。 |'
- en: '| `pair<...>{ move(`a`), move(`b`) }` | Constructs a `pair` by moving a and
    b. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `pair<...>{ move(`a`), move(`b`) }` | 通过移动a和b构造一个`pair`。 |'
- en: '| pr1 `=` pr2 | Copy assigns from pr2. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| pr1 `=` pr2 | 从pr2进行复制赋值。 |'
- en: '| pr1 = `move(`pr2`)` | Move assigns from pr2. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| pr1 = `move(`pr2`)` | 从pr2进行移动赋值。 |'
- en: '| pr`.first` `get<0>(`pr`)` | Returns a reference to the `first` element. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| pr`.first` `get<0>(`pr`)` | 返回对`first`元素的引用。 |'
- en: '| pr`.second` `get<1>(`pr`)` | Returns a reference to the `second` element.
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| pr`.second` `get<1>(`pr`)` | 返回对`second`元素的引用。 |'
- en: '| `get<`T`>(`pr`)` | If `first` and `second` have different types, returns
    a reference to the element of type T. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `get<`T`>(`pr`)` | 如果`first`和`second`具有不同类型，返回类型T的元素的引用。 |'
- en: '| pr1`.swap(`pr2`)` `swap(`pr1`,` pr2`)` | Swaps the objects contained by pr1
    and pr2. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| pr1`.swap(`pr2`)` `swap(`pr1`,` pr2`)` | 交换pr1和pr2所包含的对象。 |'
- en: '| `make_pair<...>(`a`,` b`)` | Convenience function for constructing a `pair`.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `make_pair<...>(`a`,` b`)` | 构造`pair`的便利函数。 |'
- en: '| pr1 `==` pr2pr1 `!=` pr2pr1 `>` pr2pr1 `>=` pr2pr1 `<` pr2pr1 `<=` pr2 |
    Equal if both `first` and `second` are equal. Greater than/less than comparisons
    begin with `first`. If `first` members are equal, compare `second` members. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| pr1 `==` pr2pr1 `!=` pr2pr1 `>` pr2pr1 `>=` pr2pr1 `<` pr2pr1 `<=` pr2 |
    如果`first`和`second`都相等，则相等。大于/小于比较从`first`开始。如果`first`成员相等，则比较`second`成员。 |'
- en: '***tuple***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tuple***'
- en: A *tuple* is a class template that takes an arbitrary number of heterogeneous
    elements. It’s a generalization of `pair`, but a `tuple` doesn’t expose its members
    as `first`, `second`, and so on like a `pair`. Instead, you use the non-member
    function template `get` to extract elements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*tuple*是一个类模板，接受任意数量的异质元素。它是`pair`的泛化，但`tuple`不像`pair`那样暴露其成员为`first`、`second`等。相反，你使用非成员函数模板`get`来提取元素。'
- en: The stdlib has `std::tuple` and `std::get` in the `<tuple>` header, and Boost
    has `boost::tuple` and `boost::get` in the `<boost/tuple/tuple.hpp>` header.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了`std::tuple`和`std::get`在`<tuple>`头文件中，Boost提供了`boost::tuple`和`boost::get`在`<boost/tuple/tuple.hpp>`头文件中。
- en: 'Let’s add a third class, `Acquaintance`, to test a `tuple`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个第三个类，`Acquaintance`，来测试一个`tuple`：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To extract these elements, you have two modes of using `get`. In the primary
    case, you can always provide a template parameter corresponding to the zero-based
    index of the element you want to extract. In the event the `tuple` doesn’t contain
    elements with the same types, you can alternatively provide a template parameter
    corresponding to the type of the element you want to extract, as [Listing 12-11](ch12.xhtml#ch12ex11)
    illustrates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取这些元素，你有两种使用`get`的方式。在主要情况下，你可以始终提供一个对应于你要提取的元素的零基索引的模板参数。如果`tuple`不包含具有相同类型的元素，你还可以提供一个对应于你要提取的元素类型的模板参数，如[列表12-11](ch12.xhtml#ch12ex11)所示。
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 12-11: A `std::tuple` supports member extraction and structured binding
    syntax.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-11：`std::tuple`支持成员提取和结构绑定语法。*'
- en: You can build a `std::tuple` in an analogous way to how you built a `std::pair`.
    First, you extract the `Socialite` member with `get<0>` ➊. Because `Socialite`
    is the first template parameter, you use 0 for the `std::get` template parameter.
    Then you extract the `Acquaintance` member with `std::get<Acquaintance>` ➋. Because
    there’s only one element of type `Acquaintance`, you’re permitted to use this
    mode of `get` access.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与构建`std::pair`类似的方式构建`std::tuple`。首先，使用`get<0>`提取`Socialite`成员 ➊。由于`Socialite`是第一个模板参数，因此使用0作为`std::get`模板参数。然后，使用`std::get<Acquaintance>`提取`Acquaintance`成员
    ➋。由于只有一个`Acquaintance`类型的元素，你可以使用这种`get`访问模式。
- en: Like `pair`, `tuple` also allows structured binding syntax.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像`pair`一样，`tuple`也允许使用结构绑定语法。
- en: '**A Partial List of Supported Operations**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持操作的部分列表**'
- en: '[Table 12-4](ch12.xhtml#ch12tab04) provides a list of the most supported `std::tuple`
    operations. In this table, `tp` is a `std::tuple<A, B>`, `a` is an object of type
    `A`, and `b` is an object of type `B`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-4](ch12.xhtml#ch12tab04)列出了最常用的`std::tuple`操作。在此表中，`tp`是一个`std::tuple<A,
    B>`，`a`是类型为`A`的对象，`b`是类型为`B`的对象。'
- en: '**Table 12-4:** The Most Supported `std::tuple` Operations'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-4：** 最常用的`std::tuple`操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **说明** |'
- en: '| `tuple<...>{` [alc] `}` | Constructs an empty `tuple`. Uses `std::allocate`
    as default allocator alc. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `tuple<...>{` [alc] `}` | 构造一个空的`tuple`。默认使用`std::allocate`作为分配器alc。 |'
- en: '| `tuple<...>{` [alc]`,` tp `}` | Copy constructs from tp. Uses `std::allocate`
    as default allocator alc. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `tuple<...>{` [alc]`,` tp `}` | 从tp复制构造。默认使用`std::allocate`作为分配器alc。 |'
- en: '| `tuple<...>{` [alc]`,move(`tp`) }` | Move constructs from tp. Uses `std::allocate`
    as default allocator alc. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `tuple<...>{` [alc]`,move(`tp`) }` | 从tp移动构造。默认使用`std::allocate`作为分配器alc。
    |'
- en: '| `tuple<...>{` [alc]`,` a`,` b `}` | Constructs a `tuple` by copying a and
    b. Uses `std::allocate` as default allocator alc. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `tuple<...>{` [alc]`,` a`,` b `}` | 通过复制a和b构造一个`tuple`。默认使用`std::allocate`作为分配器alc。
    |'
- en: '| `tuple<...>{` [alc]`, move(`a`), move(`b`) }` | Constructs a `tuple` by moving
    a and b. Uses `std::allocate` as default allocator alc. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `tuple<...>{` [alc]`, move(`a`), move(`b`) }` | 通过移动a和b构造一个`tuple`。默认使用`std::allocate`作为分配器alc。
    |'
- en: '| tp1 `=` tp2 | Copy assigns from tp2. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| tp1 `=` tp2 | 从tp2复制赋值。 |'
- en: '| tp1 = `move(`tp2`)` | Move assigns from tp2. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| tp1 = `move(`tp2`)` | 从tp2移动赋值。 |'
- en: '| `get<`i`>(`tp`)` | Returns a reference to the ith element (zero-based). |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `get<`i`>(`tp`)` | 返回第i个元素的引用（从零开始）。 |'
- en: '| `get<`T`>(`tp`)` | Returns a reference to the element of type T. Fails to
    compile if more than one element share this type. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `get<`T`>(`tp`)` | 返回类型为T的元素的引用。如果有多个元素共享此类型，编译会失败。 |'
- en: '| tp1`.swap(`tp2`)` `swap(`tp1`,` tp2`)` | Swaps the objects contained by tp1
    and tp2. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| tp1`.swap(`tp2`)` `swap(`tp1`,` tp2`)` | 交换tp1和tp2中包含的对象。 |'
- en: '| `make_tuple<...>(`a`,` b`)` | Convenience function for constructing a `tuple`.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `make_tuple<...>(`a`,` b`)` | 用于构造`tuple`的便捷函数。 |'
- en: '| `tuple_cat<...>(`tp1`,` tp2`)` | Concatenates all the tuples passed in as
    arguments. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `tuple_cat<...>(`tp1`,` tp2`)` | 连接所有作为参数传入的tuple。 |'
- en: '| tp1 `==` tp2tp1 `!=` tp2tp1 `>` tp2tp1 `>=` tp2tp1 `<` tp2tp1 `<=` tp2 |
    Equal if all elements are equal. Greater than/less than comparisons proceed from
    first element to last. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| tp1 `==` tp2tp1 `!=` tp2tp1 `>` tp2tp1 `>=` tp2tp1 `<` tp2tp1 `<=` tp2 |
    如果所有元素相等，则为相等。大于/小于的比较从第一个元素到最后一个元素进行。 |'
- en: '***any***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***any***'
- en: An *any* is a class that stores single values of any type. It is *not* a class
    template. To convert an `any` into a concrete type, you use an *any cast*, which
    is a non-member function template. Any cast conversions are type safe; if you
    attempt to cast an `any` and the type doesn’t match, you get an exception. With
    `any`, you can perform some kinds of generic programming *without templates*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*any*是一个类，用于存储任何类型的单个值。它*不是*一个类模板。要将`any`转换为具体类型，你使用*any cast*，它是一个非成员函数模板。任何类型转换都是类型安全的；如果你尝试转换`any`且类型不匹配，将抛出异常。使用`any`，你可以进行某些类型的泛型编程，而*无需模板*。'
- en: The stdlib has `std::any` in the `<any>` header, and Boost has `boost::any`
    in the `<boost/any.hpp>` header.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有`std::any`（在`<any>`头文件中），而Boost库中有`boost::any`（在`<boost/any.hpp>`头文件中）。
- en: To store a value into an `any`, you use the `emplace` method template. It takes
    a single template parameter corresponding to the type you want to store into `any`
    (the *storage type*). Any arguments you pass into `emplace` get forwarded to an
    appropriate constructor for the given storage type. To extract the value, you
    use `any_cast`, which takes a template parameter corresponding to the current
    storage type of `any` (called the *state* of `any`). You pass the `any` as the
    sole parameter to `any_cast`. As long as the state of `any` matches the template
    parameter, you get the desired type out. If the state doesn’t match, you get a
    `bad_any_cast` exception.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个值存储到`any`中，使用`emplace`方法模板。它接受一个模板参数，对应你想要存储到`any`中的类型（即*存储类型*）。你传递给`emplace`的任何参数都会转发到给定存储类型的适当构造函数中。要提取值，使用`any_cast`，它接受一个模板参数，对应`any`当前的存储类型（称为`any`的*状态*）。你将`any`作为唯一参数传递给`any_cast`。只要`any`的状态与模板参数匹配，你就能获得所需的类型。如果状态不匹配，会抛出`bad_any_cast`异常。
- en: '[Listing 12-12](ch12.xhtml#ch12ex12) illustrates these basic interactions with
    a `std::any`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-12](ch12.xhtml#ch12ex12)演示了与`std::any`的这些基本交互。'
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 12-12: The `std::any` and `std::any_cast` allow you to extract concrete
    types.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-12：`std::any`和`std::any_cast`允许你提取具体类型。*'
- en: You declare the `EscapeCapsule` class ➊. Within the test, you construct an empty
    `std::any` called `hagunemnon` ➋. Next, you use `emplace` to store an `EscapeCapsule`
    with `weight_kg = 600` ➌. You can extract the `EscapeCapsule` back out using `std::any_cast`
    ➍, which you store into a new `EscapeCapsule` called `capsule`. Finally, you show
    that attempting to invoke `any_cast` to cast the `hagunemnon` into a `float` results
    in a `std::bad_any_cast` exception ➎.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了`EscapeCapsule`类 ➊。在测试中，你构造了一个名为`hagunemnon`的空`std::any`对象 ➋。接下来，你使用`emplace`存储了一个`weight_kg
    = 600`的`EscapeCapsule`对象 ➌。你可以使用`std::any_cast`将`EscapeCapsule`取回，存储到一个名为`capsule`的新`EscapeCapsule`对象中
    ➍。最后，你展示了尝试将`hagunemnon`转换为`float`类型时会导致`std::bad_any_cast`异常的情况 ➎。
- en: '**A Partial List of Supported Operations**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**支持操作的部分列表**'
- en: '[Table 12-5](ch12.xhtml#ch12tab05) provides a list of the most supported `std::any`
    operations. In this table, `ay` is a `std::any` and `t` is an object of type `T`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-5](ch12.xhtml#ch12tab05) 提供了最受支持的`std::any`操作列表。在这个表中，ay是一个`std::any`对象，t是类型为T的对象。'
- en: '**Table 12-5:** The Most Supported `std::any` Operations'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-5：** 最受支持的`std::any`操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **注释** |'
- en: '| `any{}` | Constructs an empty `any` object. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `any{}` | 构造一个空的`any`对象。 |'
- en: '| `any{` ay `}` | Copy constructs from ay. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `any{` ay `}` | 从ay进行复制构造。 |'
- en: '| `any{ move(`ay`) }` | Move constructs from ay. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `any{ move(`ay`) }` | 从ay进行移动构造。 |'
- en: '| `any{ move(`t`) }` | Constructs an `any` object containing an in-place constructed
    object from t. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `any{ move(`t`) }` | 构造一个包含从t原地构造的对象的`any`对象。 |'
- en: '| ay `=` t | Destructs the object currently contained by ay; copies t. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| ay `=` t | 销毁当前由ay包含的对象；复制t。 |'
- en: '| ay `= move(`t`)` | Destructs the object currently contained by ay; moves
    t. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| ay `= move(`t`)` | 销毁当前由ay包含的对象；移动t。 |'
- en: '| ay1 `=` ay2 | Copy assigns from ay2. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| ay1 `=` ay2 | 从ay2进行复制赋值。 |'
- en: '| ay1 `= move(`ay2`)` | Move assigns from ay2. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| ay1 `= move(`ay2`)` | 从ay2进行移动赋值。 |'
- en: '| ay`.emplace<`T`>(...)` | Destructs the object currently contained by ay;
    constructs a T in place, forwarding the arguments `...` to the appropriate constructor.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| ay`.emplace<`T`>(...)` | 销毁当前由ay包含的对象；在原地构造一个T对象，将参数`...`转发给适当的构造函数。 |'
- en: '| ay`.reset()` | Destroys the currently contained object. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| ay`.reset()` | 销毁当前包含的对象。 |'
- en: '| ay1`.swap(`ay2`)` `swap(`ay1`,` ay2`)` | Swaps the objects contained by ay1
    and ay2. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| ay1`.swap(`ay2`)` `swap(`ay1`,` ay2`)` | 交换ay1和ay2包含的对象。 |'
- en: '| `make_any<`T`>(...)` | Convenience function for constructing an `any` constructs
    a T in place, forwarding the arguments `...` to the appropriate constructor. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `make_any<`T`>(...)` | 用于构造`any`的便利函数，在原地构造一个T对象，将参数`...`转发给适当的构造函数。 |'
- en: '| t `= any_cast<`T`>(`ay`)` | Casts ay into type T. Throws a `std::bad_any_cast`
    if the type T doesn’t match the contained object’s type. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| t `= any_cast<`T`>(`ay`)` | 将ay转换为类型T。如果类型T与包含对象的类型不匹配，则抛出`std::bad_any_cast`异常。
    |'
- en: '***variant***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***variant***'
- en: A *variant* is a class template that stores single values whose types are restricted
    to the user-defined list provided as template parameters. The variant is a type-safe
    `union` (refer to “Unions” on [page 53](ch02.xhtml#page_53)). It shares a lot
    of functionality with the `any` type, but `variant` requires that you explicitly
    enumerate all the types that you’ll store.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*variant*是一个类模板，用于存储类型受限于用户定义的模板参数列表的单个值。variant是类型安全的`union`（参见“Unions”[第53页](ch02.xhtml#page_53)）。它与`any`类型共享许多功能，但`variant`要求您明确列举所有要存储的类型。'
- en: The stdlib has `std::variant` in the `<variant>` header, and Boost has `boost::variant`
    in the `<boost/variant.hpp>` header.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中在`<variant>`头文件中有`std::variant`，Boost库中在`<boost/variant.hpp>`头文件中有`boost::variant`。
- en: '[Listing 12-13](ch12.xhtml#ch12ex13) demonstrates creating another type called
    `BugblatterBeast` for `variant` to contain alongside `EscapeCapsule`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-13](ch12.xhtml#ch12ex13) 演示了创建另一个名为`BugblatterBeast`的类型，以便`variant`可以与`EscapeCapsule`一起包含。'
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 12-13: The `std::variant` can hold an object from one of a list of
    predefined types.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-13：`std::variant`可以包含预定义类型列表中的一个对象。*'
- en: Aside from also containing a `weight_kg` member ➊, `BugblatterBeast` is totally
    independent from `EscapeCapsule`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了还包含一个`weight_kg`成员变量 ➊，`BugblatterBeast`与`EscapeCapsule`完全独立。
- en: '**Constructing a variant**'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造variant**'
- en: 'A `variant` can only be default constructed if one of two conditions is met:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant`只有在满足以下两个条件之一时才能进行默认构造：'
- en: The first template parameter is default constructible.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个模板参数是默认可构造的。
- en: It is `monostate`, a type intended to communicate that a variant can have an
    empty state.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是`monostate`，一个旨在表明variant可以具有空状态的类型。
- en: 'Because `BugblatterBeast` is default constructible (meaning it has a default
    constructor), make it the first type in the template parameter list so your variant
    is also default constructible, like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`BugblatterBeast`是可默认构造的（意味着它有一个默认构造函数），将其作为模板参数列表中的第一个类型，使得你的variant也可以默认构造，如下所示：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To store a value into a `variant`, you use the `emplace` method template. As
    with `any`, a `variant` takes a single template parameter corresponding to the
    type you want to store. This template parameter must be contained in the list
    of template parameters for the `variant`. To extract a value, you use either of
    the non-member function templates `get` or `get_if`. These accept either the desired
    type or the index into the template parameter list corresponding to the desired
    type. If `get` fails, it throws a `bad_variant_access` exception, while `get_if`
    returns a `nullptr`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个值存储到`variant`中，你使用`emplace`方法模板。与`any`一样，`variant`接受一个模板参数，表示你希望存储的类型。这个模板参数必须包含在`variant`的模板参数列表中。要提取一个值，你可以使用非成员函数模板`get`或`get_if`。这些函数接受所需类型或模板参数列表中的索引，表示所需类型。如果`get`失败，它会抛出一个`bad_variant_access`异常，而`get_if`返回一个`nullptr`。
- en: You can determine which type corresponds with the current state of `variant`
    using the `index()` member, which returns the index of the current object’s type
    within the template parameter list.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`index()`成员函数来确定与`variant`当前状态对应的类型，它返回当前对象类型在模板参数列表中的索引。
- en: '[Listing 12-14](ch12.xhtml#ch12ex14) illustrates how to use `emplace` to change
    the state of a `vari``ant` and `index` to determine the type of the contained
    object.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[列出12-14](ch12.xhtml#ch12ex14)展示了如何使用`emplace`来更改`variant`的状态，并使用`index`来确定包含对象的类型。'
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 12-14: A `std::get` allows you to extract concrete types from `std::variant`.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出12-14：`std::get`允许你从`std::variant`中提取具体类型。*'
- en: After default constructing `hagunemnon`, invoking `index` yields 0 because this
    is the index of the correct template parameter ➊. Next, you emplace an `EscapeCapsule`
    ➋, which causes `index` to return 1 instead ➌. Both `std::get<EscapeCapsule>`
    ➍ and `std::get<1>` ➎ illustrate identical ways of extracting the contained type.
    Finally, attempting to invoke `std::get` to obtain a type that doesn’t correspond
    with the current state of `variant` results in a `bad_variant_access` ➏.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认构造`hagunemnon`之后，调用`index`返回0，因为这是正确模板参数的索引➊。接下来，你插入一个`EscapeCapsule` ➋，这使得`index`返回1➌。`std::get<EscapeCapsule>`
    ➍和`std::get<1>` ➎都展示了提取包含类型的相同方法。最后，尝试调用`std::get`来获取一个与`variant`当前状态不符的类型会导致抛出`bad_variant_access`异常➏。
- en: You can use the non-member function `std::visit` to apply a callable object
    to a variant. This has the advantage of dispatching the correct function to handle
    whatever the contained object is without having to specify it explicitly with
    `std::get`. [Listing 12-15](ch12.xhtml#ch12ex15) illustrates the basic usage.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用非成员函数`std::visit`将一个可调用对象应用到一个variant。这有一个优点，即可以派发正确的函数来处理包含的对象，而不必通过`std::get`显式指定类型。[列出12-15](ch12.xhtml#ch12ex15)展示了基本用法。
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 12-15: The `std::visit` allows you to apply a callable object to a
    contained type of `std::variant`.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出12-15：`std::visit`允许你将一个可调用对象应用到`std::variant`的包含类型。*'
- en: First, you invoke `emplace` to store the value 600 into `hagunemnon` ➊. Because
    both `BugblatterBeast` and `EscapeCapsule` have a `weight_kg` member, you can
    use `std::visit` on `hagunemnon` with a lambda that performs the correct conversion
    (2.2 lbs per kg) to the `weight_kg` field ➋ and returns the result ➌ (notice that
    you don’t have to include any type information).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你调用`emplace`将值600存储到`hagunemnon` ➊中。因为`BugblatterBeast`和`EscapeCapsule`都有一个`weight_kg`成员，你可以使用`std::visit`在`hagunemnon`上调用一个lambda，该lambda执行正确的转换（每公斤2.2磅）到`weight_kg`字段➋并返回结果➌（注意你不需要包含任何类型信息）。
- en: '**Comparing variant and any**'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**比较variant和any**'
- en: The universe is big enough to accommodate both `any` and `variant`. It’s not
    possible to recommend one over the other generally, because each has its strengths
    and weaknesses.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 宇宙足够大，可以容纳`any`和`variant`。通常无法推荐一个优于另一个，因为它们各自有其优缺点。
- en: An `any` is more flexible; it can take *any* type, whereas `variant` is only
    allowed to contain an object of a predetermined type. It also mostly avoids templates,
    so it’s generally easier to program with.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`更为灵活；它可以接受*任何*类型，而`variant`只能包含一个预定类型的对象。它通常避免使用模板，因此一般来说编程更为简单。'
- en: A `variant` is less flexible, making it safer. Using the `visit` function, you
    can check for the safety of operations at compile time. With `any`, you would
    need to build your own `visit`-like functionality, and it would require runtime
    checking (for example, of the result of `any_cast`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant` 的灵活性较差，因此更安全。通过使用 `visit` 函数，你可以在编译时检查操作的安全性。使用 `any` 时，你需要构建自己的类似
    `visit` 的功能，并且需要在运行时检查（例如，检查 `any_cast` 的结果）。'
- en: Finally, `variant` can be more performant than `any`. Although `any` is allowed
    to perform dynamic allocation if the contained type is too large, `variant` is
    not.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`variant` 比 `any` 更具性能优势。尽管当包含的类型过大时，`any` 可以执行动态分配，但 `variant` 不会这样做。
- en: '**A Partial List of Supported Operations**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**部分支持的操作列表**'
- en: '[Table 12-6](ch12.xhtml#ch12tab06) provides a list of the most supported `std::variant`
    operations. In this table, `vt` is a `std::variant` and `t` is an object of type
    `T`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-6](ch12.xhtml#ch12tab06) 提供了最常见的 `std::variant` 操作列表。在该表中，`vt` 是一个 `std::variant`，`t`
    是类型为 `T` 的对象。'
- en: '**Table 12-6:** The Most Supported `std::variant` Operations'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-6：** 最常用的 `std::variant` 操作'
- en: '| **Operation** | **Notes** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| `variant<...>{}` | Constructs an empty `variant` object. First template parameter
    must be default constructible. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `variant<...>{}` | 构造一个空的 `variant` 对象。第一个模板参数必须是可默认构造的。 |'
- en: '| `variant<...>{` vt `}` | Copy constructs from vt. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `variant<...>{` vt `}` | 从 vt 复制构造。 |'
- en: '| `variant<...>{ move(`vt`) }` | Move constructs from vt. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `variant<...>{ move(`vt`) }` | 从 vt 移动构造。 |'
- en: '| `variant<...>{ move(`t`) }` | Constructs an `variant` object containing an
    in-place constructed object. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `variant<...>{ move(`t`) }` | 构造一个包含原地构造对象的 `variant` 对象。 |'
- en: '| vt `=` t | Destructs the object currently contained by vt; copies t. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| vt `=` t | 解构当前由 vt 包含的对象；复制 t。 |'
- en: '| vt `= move(`t`)` | Destructs the object currently contained by vt; moves
    t. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| vt `= move(`t`)` | 解构当前由 vt 包含的对象；移动 t。 |'
- en: '| vt1 `=` vt2 | Copy assigns from vt2. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| vt1 `=` vt2 | 从 vt2 复制赋值。 |'
- en: '| vt1 `= move(`vt2`)` | Move assigns from vt2. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| vt1 `= move(`vt2`)` | 从 vt2 移动赋值。 |'
- en: '| vt`.emplace<`T`>(...)` | Destructs the object currently contained by vt;
    constructs a T in place, forwarding the arguments `...` to the appropriate constructor.
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| vt`.emplace<`T`>(...)` | 解构当前由 vt 包含的对象；在原地构造一个 T，并将参数 `...` 转发给适当的构造函数。
    |'
- en: '| vt`.reset()` | Destroys the currently contained object. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| vt`.reset()` | 销毁当前包含的对象。 |'
- en: '| vt`.index()` | Returns the zero-based index of the type of the currently
    contained object. (Order determined by template parameters of the `std::variant`.)
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| vt`.index()` | 返回当前包含对象类型的零基索引。（顺序由 `std::variant` 的模板参数确定。） |'
- en: '| vt1`.swap(`vt2`)` `swap(`vt1`,` vt2`)` | Swaps the objects contained by vt1
    and vt2. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| vt1`.swap(`vt2`)` `swap(`vt1`,` vt2`)` | 交换 vt1 和 vt2 中包含的对象。 |'
- en: '| `make_variant<`T`>(...)` | Convenience function for constructing a `tuple`;
    constructs a T in place, forwarding the arguments `...` to the appropriate constructor.
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `make_variant<`T`>(...)` | 用于构造 `tuple` 的便捷函数；在原地构造一个 T，并将参数 `...` 转发给适当的构造函数。
    |'
- en: '| `std::visit(`vt`,` callable`)` | Invokes callable with contained object.
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `std::visit(`vt`,` callable`)` | 使用包含的对象调用 callable。 |'
- en: '| `std::holds_alternative<`T`>(`vt`)` | Returns `true` if the contained object’s
    type is T. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `std::holds_alternative<`T`>(`vt`)` | 如果包含的对象类型是 T，则返回 `true`。 |'
- en: '| `std::get<`I`>(`vt`)` `std::get<`T`>(`vt`)` | Returns contained object if
    its type is T or the ith type. Otherwise, throws std::bad_variant_access exception.
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `std::get<`I`>(`vt`)` `std::get<`T`>(`vt`)` | 如果包含的对象类型是 T 或第 i 种类型，则返回该对象。否则，抛出
    std::bad_variant_access 异常。 |'
- en: '| `std::get_if<`I`>(&`vt`)` `std::get_if<`T`>(&`vt`)` | Returns a pointer to
    the contained object if its type is T or the ith type. Otherwise, returns `nullptr`.
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `std::get_if<`I`>(&`vt`)` `std::get_if<`T`>(&`vt`)` | 如果包含的对象类型是 T 或第 i 种类型，则返回指向该对象的指针。否则，返回
    `nullptr`。 |'
- en: '| vt1 `==` vt2vt1 `!=` vt2vt1 `>` vt2vt1 `>=` vt2vt1 `<` vt2vt1 `<=` vt2 |
    Compares the contained objects of vt1 and vt2. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| vt1 `==` vt2 vt1 `!=` vt2 vt1 `>` vt2 vt1 `>=` vt2 vt1 `<` vt2 vt1 `<=` vt2
    | 比较 vt1 和 vt2 中包含的对象。 |'
- en: '**Date and Time**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**日期和时间**'
- en: Between stdlib and Boost, a number of libraries are available that handle dates
    and times. When handling calendar dates and times, look to Boost’s DateTime library.
    When you’re trying get the current time or measure elapsed time, look to Boost’s
    or stdlib’s Chrono libraries and to Boost’s Timer library.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库和 Boost 之间，有许多库可以处理日期和时间。当处理日历日期和时间时，可以查看 Boost 的 DateTime 库。当你需要获取当前时间或测量经过时间时，可以查看
    Boost 或标准库的 Chrono 库，以及 Boost 的 Timer 库。
- en: '***Boost DateTime***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Boost DateTime***'
- en: 'Boost DateTime library supports date programming with a rich system based on
    the Gregorian calendar, which is the most widely used civil calendar internationally.
    Calendars are more complicated than they might seem at first glance. For example,
    consider the following excerpt from the US Naval Observatory’s Introduction to
    Calendars, which describes the basics of leap years:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Boost DateTime库通过一个基于格里历的丰富系统支持日期编程，格里历是全球最广泛使用的民用历法。日历比表面看起来更复杂。例如，考虑以下摘自美国海军天文台的《日历简介》的段落，它描述了闰年的基本知识：
- en: Every year that is exactly divisible by four is a leap year, except for years
    that are exactly divisible by 100, but these centurial years are leap years if
    they are exactly divisible by 400\. For example, the years 1700, 1800, and 1900
    are not leap years, but the year 2000 is.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个能被4整除的年份都是闰年，除了能被100整除的年份，但这些世纪年份如果能被400整除，则为闰年。例如，1700年、1800年和1900年不是闰年，但2000年是闰年。
- en: 'Rather than attempting to build your own solar calendar functions, just include
    DateTime’s date-programming facilities with the following header:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与其尝试自己构建太阳历函数，不如包含DateTime的日期编程功能，使用以下头文件：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The principal type you’ll use is the `boost::gregorian::date`, which is the
    primary interface for date-programming.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的主要类型是`boost::gregorian::date`，它是日期编程的主要接口。
- en: '**Constructing a date**'
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构造日期**'
- en: 'Several options are available for constructing a `date`. You can default construct
    a `date`, which sets its value to the special date `boost::gregorian::not_a_``date_time`.
    To construct a `date` with a valid date, you can use a constructor that accepts
    three arguments: a year, a month, and a date. The following statement constructs
    a `date d` with the date September 15, 1986:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种构造`date`的选项。你可以默认构造一个`date`，其值为特殊日期`boost::gregorian::not_a_``date_time`。要构造一个有效日期的`date`，你可以使用一个接受三个位数参数的构造函数：年份、月份和日期。以下语句构造了一个日期为1986年9月15日的`date
    d`：
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, you can construct a date from a string using the `boost:: gregorian::from_string`
    utility function, like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用`boost::gregorian::from_string`工具函数从字符串构造日期，如下所示：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you pass an invalid date, the `date` constructor will throw an exception,
    such as `bad_year`, `bad_day_of_month`, or `bad_month`. For example, [Listing
    12-16](ch12.xhtml#ch12ex16) attempts to construct a date with September 32, 1986.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递一个无效的日期，`date`构造函数将抛出一个异常，如`bad_year`、`bad_day_of_month`或`bad_month`。例如，[示例
    12-16](ch12.xhtml#ch12ex16)试图构造一个日期为1986年9月32日的日期。
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 12-16: The `boost::gregorian::date` constructor throws exceptions
    for bad dates.*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-16：`boost::gregorian::date`构造函数会对无效日期抛出异常。*'
- en: Because September 32 isn’t a valid day of the month, the `date` constructor
    throws a `bad_day_of_month` exception ➊.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因为9月32日不是一个有效的日期，`date`构造函数会抛出`bad_day_of_month`异常 ➊。
- en: '**NOTE**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Due to a limitation in Catch, you cannot use braced initialization for date
    in the `REQUIRE_THROWS_AS` macro* ➊.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于Catch的限制，你不能在`REQUIRE_THROWS_AS`宏中使用大括号初始化日期* ➊。'
- en: 'You can obtain the current day from the environment using the non-member function
    `boost::gregorian::day_clock::local_day` or `boost::gregorian:: day_clock::universal_day`
    to obtain the local day based on the system’s time zone settings and the UTC day,
    respectively:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过非成员函数`boost::gregorian::day_clock::local_day`或`boost::gregorian::day_clock::universal_day`来获取当前日期，分别获取基于系统时区设置的本地日期和UTC日期：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once you construct a date, you can’t change its value (it’s *immutable*). However,
    dates support copy construction and copy assignment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构造了一个日期，你不能改变它的值（它是*不可变的*）。然而，日期支持复制构造和复制赋值。
- en: '**Accessing Date Members**'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**访问日期成员**'
- en: You can inspect the features of a `date` through its many `const` methods. [Table
    12-7](ch12.xhtml#ch12tab07) provides a partial list. In this table, `d` is a `date`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过日期的许多`const`方法来检查一个`date`的特性。[表12-7](ch12.xhtml#ch12tab07)提供了部分列表。在这个表中，`d`是一个`date`。
- en: '**Table 12-7:** The Most Supported `boost::gregorian::date` Accessors'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-7：** 支持最多的`boost::gregorian::date`访问器'
- en: '| **Accessor** | **Notes** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **访问器** | **说明** |'
- en: '| d`.year()` | Returns the year portion of the `date`. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| d`.year()` | 返回`date`的年份部分。 |'
- en: '| d`.month()` | Returns the month portion of the `date`. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| d`.month()` | 返回`date`的月份部分。 |'
- en: '| d`.day()` | Returns the day portion of the `date`. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| d`.day()` | 返回`date`的天数部分。 |'
- en: '| d`.day_of_week()` | Returns the day of the week as an `enum` of type `greg_day_of_week`.
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| d`.day_of_week()` | 返回一周中的星期几，作为`greg_day_of_week`类型的`enum`。 |'
- en: '| d`.day_of_year()` | Returns the day of the year (from 1 to 366 inclusive).
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| d`.day_of_year()` | 返回一年中的第几天（从 1 到 366）。 |'
- en: '| d`.end_of_month()` | Returns a date object set to the last day of the month
    of d. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| d`.end_of_month()` | 返回一个设置为 d 所在月份最后一天的日期对象。 |'
- en: '| d`.is_not_a_date()` | Returns `true` if d is not a date. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| d`.is_not_a_date()` | 如果 d 不是一个日期，返回 `true`。 |'
- en: '| d`.week_number()` | Returns the ISO 8601 week number. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| d`.week_number()` | 返回 ISO 8601 周数。 |'
- en: '[Listing 12-17](ch12.xhtml#ch12ex17) illustrates how to construct a `date`
    and use the accessors in [Table 12-7](ch12.xhtml#ch12tab07).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-17](ch12.xhtml#ch12ex17) 展示了如何构造一个 `date` 并使用 [表格 12-7](ch12.xhtml#ch12tab07)
    中的访问器。'
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 12-17: The `boost::gregorian::date` supports basic calendar functions.*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-17：`boost::gregorian::date` 支持基本的日历功能。*'
- en: Here, you construct a `date` from September 15, 1986 ➊. From there, you extract
    the year ➋, month ➌, day ➍, day of the year ➎, and day of the week ➏.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个表示1986年9月15日的 `date` ➊。然后，从中提取出年份 ➋、月份 ➌、日期 ➍、年份中的天数 ➎ 和星期几 ➏。
- en: '**Calendar Math**'
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**日历运算**'
- en: You can perform simple calendar math on dates. When you subtract one date from
    another, you get a `boost::gregorian::date_duration`. The main functionality of
    `date_duration` is storing an integral number of days, which you can extract using
    the `days` method. [Listing 12-18](ch12.xhtml#ch12ex18) illustrates how to compute
    the number of days elapsed between two `date` objects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对日期进行简单的日历运算。当你将一个日期减去另一个日期时，得到的是一个 `boost::gregorian::date_duration`。`date_duration`
    的主要功能是存储一个整数天数，你可以通过 `days` 方法提取出来。[清单 12-18](ch12.xhtml#ch12ex18) 展示了如何计算两个 `date`
    对象之间的天数差。
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 12-18: Subtracting `boost::gregorian::date` objects yields a `boost::gregorian::
    date_duration`.*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-18：减去 `boost::gregorian::date` 对象得到一个 `boost::gregorian::date_duration`。*'
- en: Here, you construct a `date` for September 15, 1986 ➊ and for August 1, 2019
    ➋. You subtract these two dates to yield a `date_duration` ➌. Using the `days`
    method, you can extract the number of days between the two dates ➍.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个表示1986年9月15日的 `date` ➊ 和一个表示2019年8月1日的 `date` ➋。你将这两个日期相减，得到一个 `date_duration`
    ➌。使用 `days` 方法，你可以提取这两个日期之间的天数 ➍。
- en: You can also construct a `date_duration` using a `long` argument corresponding
    to the number of days. You can add a `date_duration` to a date to obtain another
    date, as [Listing 12-19](ch12.xhtml#ch12ex19) illustrates.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一个表示天数的 `long` 参数来构造一个 `date_duration`。你可以将一个 `date_duration` 加到一个日期上，得到另一个日期，正如
    [清单 12-19](ch12.xhtml#ch12ex19) 所展示的那样。
- en: '[PRE24]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 12-19: Adding a `date_duration` to a `date` yields another `date`.*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-19：将一个 `date_duration` 加到一个 `date` 上得到另一个 `date`。*'
- en: You construct a `date` for September 15, 1986 ➊ and 12,008 days for `duration`
    ➋. From [Listing 12-18](ch12.xhtml#ch12ex18), you know that this day plus 12008
    yields August 1, 2019\. So after adding them ➌, the resulting day is as you expect
    ➍.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个表示1986年9月15日的 `date` ➊ 和一个表示12008天的 `duration` ➋。根据 [清单 12-18](ch12.xhtml#ch12ex18)，你知道这一天加上12008天将得到2019年8月1日。因此，将它们相加后
    ➌，得到的日期符合预期 ➍。
- en: '**Date Periods**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**日期区间**'
- en: A *date period* represents the interval between two dates. DateTime provides
    a `boost::gregorian::date_period` class, which has three constructors, as described
    in [Table 12-8](ch12.xhtml#ch12tab08). In this table, constructors `d1` and `d2`
    are `date` arguments and `dp` is a `date_period`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*日期区间* 表示两个日期之间的时间间隔。DateTime 提供了一个 `boost::gregorian::date_period` 类，具有三个构造函数，如
    [表格 12-8](ch12.xhtml#ch12tab08) 中所描述。在此表格中，构造函数 `d1` 和 `d2` 是 `date` 类型的参数，`dp`
    是一个 `date_period`。'
- en: '**Table 12-8:** Supported `boost::gregorian::date_period` Constructors'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 12-8：** 支持的 `boost::gregorian::date_period` 构造函数'
- en: '| **Accessor** | **Notes** |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **访问器** | **说明** |'
- en: '| `date_period{` d1`,` d2 `}` | Creates a period including d1 but not d2; invalid
    if d2 <= d1. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `date_period{` d1`,` d2 `}` | 创建一个包括 d1 但不包括 d2 的时间段；如果 d2 <= d1，则无效。 |'
- en: '| `date_period{` d`,` n_days `}` | Creates a period frome d to d+n_days. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `date_period{` d`,` n_days `}` | 创建一个从 d 到 d+n_days 的时间段。 |'
- en: '| `date_period{` dp `}` | Copy constructor. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `date_period{` dp `}` | 复制构造函数。 |'
- en: The `date_period` class supports many operations, such as the `contain` method,
    which takes a `date` argument and returns `true` if the argument is contained
    in the `period`. [Listing 12-20](ch12.xhtml#ch12ex20) illustrates this operation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`date_period` 类支持许多操作，例如 `contain` 方法，它接受一个 `date` 参数，如果该参数包含在 `period` 中，则返回
    `true`。[清单 12-20](ch12.xhtml#ch12ex20) 展示了这个操作。'
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 12-20: Using the `contains` method on a `boost::gregorian::date_period`
    to determine whether a date falls within a particular time interval*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-20：使用 `contains` 方法判断一个日期是否在特定时间区间内，应用于 `boost::gregorian::date_period`*'
- en: Here, you construct two dates, September 15, 1986 ➊ and August 1, 2019 ➋, which
    you use to construct a `date_period` ➌. Using the `contains` method, you can determine
    that the `date_period` contains the date October 27, 1987 ➍.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了两个日期，1986 年 9 月 15 日 ➊ 和 2019 年 8 月 1 日 ➋，然后用它们构造一个 `date_period` ➌。使用
    `contains` 方法，你可以确定 `date_period` 包含了 1987 年 10 月 27 日 ➍ 这个日期。
- en: '[Table 12-9](ch12.xhtml#ch12tab09) contains a partial list of other `date_period`
    operations. In this table, `p`, `p1`, and `p2` are `date_period` classes and `d`
    is a `date`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-9](ch12.xhtml#ch12tab09) 包含了其他一些 `date_period` 操作的部分列表。在此表中，`p`、`p1`
    和 `p2` 是 `date_period` 类，而 `d` 是一个 `date`。'
- en: '**Table 12-9:** Supported `boost::gregorian::date_period` Operations'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-9：** 支持的 `boost::gregorian::date_period` 操作'
- en: '| **Accessor** | **Notes** |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **访问器** | **说明** |'
- en: '| p`.begin()` | Returns the first day. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| p`.begin()` | 返回第一个日期。|'
- en: '| p`.last()` | Returns the last day. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| p`.last()` | 返回最后一天。|'
- en: '| p`.length()` | Returns the number of days contained. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| p`.length()` | 返回包含的天数。|'
- en: '| p`.is_null()` | Returns `true` if the period is invalid (for example, end
    is before start). |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| p`.is_null()` | 如果时间段无效（例如，结束时间在开始时间之前），返回 `true`。|'
- en: '| p`.contains(`d`)` | Returns `true` if d falls within p. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| p`.contains(`d`)` | 如果 d 在 p 内，返回 `true`。|'
- en: '| p1`.contains(`p2`)` | Returns `true` if all of p2 falls within p1. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| p1`.contains(`p2`)` | 如果 p2 的所有部分都在 p1 内，返回 `true`。|'
- en: '| p1`.intersects(`p2`)` | Returns `true` if any of p2 falls within p1. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| p1`.intersects(`p2`)` | 如果 p2 中的任何部分落在 p1 中，返回 `true`。|'
- en: '| p`.is_after(`d`)` | Returns `true` if p falls after d. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| p`.is_after(`d`)` | 如果 p 在 d 之后，返回 `true`。|'
- en: '| p`.is_before(`d`)` | Returns `true` if p falls before d. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| p`.is_before(`d`)` | 如果 p 在 d 之前，返回 `true`。|'
- en: '**Other DateTime Features**'
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**其他 DateTime 特性**'
- en: 'The Boost DateTime library contains three broad categories of programming:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 的 DateTime 库包含了三大类编程：
- en: '**Date** Date programming is the calendar-based programming you just toured.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期** 日期编程就是你刚才了解的基于日历的编程。'
- en: '**Time** Time programming, which allows you to work with clocks with microsecond
    resolution, is available in the `<boost/date_time/posix_time/``posix_time.hpp>`
    header. The mechanics are similar to date programming, but you work with clocks
    instead of Gregorian calendars.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间** 时间编程允许你处理具有微秒分辨率的时钟，位于 `<boost/date_time/posix_time/posix_time.hpp>`
    头文件中。其原理与日期编程类似，但你处理的是时钟而非公历。'
- en: '**Local-time** Local-time programming is simply time-zone-aware time programming.
    It’s available in the `<boost/date_time/time_zone_base.hpp>` header.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地时间** 本地时间编程仅仅是具有时区意识的时间编程。它位于 `<boost/date_time/time_zone_base.hpp>` 头文件中。'
- en: '**NOTE**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For brevity, this chapter won’t go into detail about time and local-time programming.
    See the Boost documentation for information and examples.*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简洁起见，本章不会详细讨论时间和本地时间编程。有关信息和示例，请参见 Boost 文档。*'
- en: '***Chrono***'
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Chrono***'
- en: The stdlib Chrono library provides a variety of clocks in the `<chrono>` header.
    You typically use these when you need to program something that depends on time
    or for timing your code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: stdlib 的 Chrono 库提供了多种时钟，位于 `<chrono>` 头文件中。当你需要编写依赖时间的程序或对代码进行计时时，通常会使用这些时钟。
- en: '**NOTE**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost also offers a Chrono library in the `<boost/chrono.hpp>` header. It’s
    a superset of stdlib’s Chrono library, which includes, for example, process- and
    thread-specific clocks and user-defined output formats for time.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost 还提供了一个位于 `<boost/chrono.hpp>` 头文件中的 Chrono 库。它是 stdlib Chrono 库的超集，包含了例如进程特定时钟、线程特定时钟以及用户定义的时间输出格式等功能。*'
- en: '**Clocks**'
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**时钟**'
- en: 'Three clocks are available in Chrono library; each provides a different guarantee,
    and all reside in the `std::chrono` namespace:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Chrono 库中有三种时钟可供使用；每种时钟提供不同的保证，且都位于 `std::chrono` 命名空间中：
- en: The `std::chrono::system_clock` is the system-wide, real-time clock. It’s sometimes
    also called the *wall clock*, the elapsed real time since an implementation-specific
    start date. Most implementations specify the Unix start date of January 1, 1970,
    at midnight.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::system_clock` 是系统范围的实时时钟。有时也称为 *挂钟*，即从特定实现的开始日期算起的实际经过时间。大多数实现都指定从
    Unix 开始日期 1970 年 1 月 1 日午夜起算。'
- en: The `std::chrono::steady_clock` guarantees that its value will never decrease.
    This might seem absurd to guarantee, but measuring time is more complicated than
    it seems. For example, a system might have to contend with leap seconds or inaccurate
    clocks.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::steady_clock` 保证它的值永远不会减少。这看起来可能是一个荒谬的保证，但计量时间比看起来复杂。比如，系统可能需要处理闰秒或不准确的时钟。'
- en: 'The `std::chrono::high_resolution_clock` has the shortest *tick* period available:
    a tick is the smallest atomic change that the clock can measure.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::high_resolution_clock` 具有最短的*滴答*周期：滴答是时钟能够测量的最小原子变化。'
- en: Each of these three clocks supports the static member function `now`, which
    returns a time point corresponding to the current value of the clock.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种时钟都支持静态成员函数 `now`，该函数返回一个时间点，表示当前时钟的时间值。
- en: '**Time Points**'
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**时间点**'
- en: A *time point* represents a moment in time, and Chrono encodes time points using
    the `std::chrono::time_point` type. From a user perspective, `time_point` objects
    are very simple. They provide a `time_since_epoch` method that returns the amount
    of time elapsed between the time point and the clock’s *epoch*. This elapsed time
    is called a *duration*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间点* 表示一个特定时刻，Chrono 使用 `std::chrono::time_point` 类型来编码时间点。从用户的角度来看，`time_point`
    对象非常简单。它们提供了一个 `time_since_epoch` 方法，返回从时间点到时钟的*纪元*之间经过的时间。这个经过的时间称为*时长*。'
- en: An epoch is an implementation-defined reference time point denoting the beginning
    of a clock. The Unix Epoch (or POSIX time) begins on January 1, 1970, whereas
    the Windows Epoch begins on January 1, 1601 (corresponding with the beginning
    of a 400-year, Gregorian-calendar cycle).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 纪元是一个实现定义的参考时间点，表示时钟的起始点。Unix 纪元（或 POSIX 时间）从 1970 年 1 月 1 日开始，而 Windows 纪元从
    1601 年 1 月 1 日开始（对应于 400 年公历周期的开始）。
- en: The `time_since_epoch` method is not the only way to obtain a duration from
    a `time_point`. You can obtain the duration between two `time_point` objects by
    subtracting them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`time_since_epoch` 方法并不是从 `time_point` 获取时长的唯一方法。你还可以通过相减两个 `time_point` 对象来获取它们之间的时长。'
- en: '**Durations**'
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**时长**'
- en: A `std::chrono::duration` represents the time between the two `time_point` objects.
    Durations expose a `count` method, which returns the number of clock ticks in
    the duration.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono::duration` 表示两个 `time_point` 对象之间的时间。时长暴露了一个 `count` 方法，用于返回该时长中的时钟滴答数。'
- en: '[Listing 12-21](ch12.xhtml#ch12ex21) shows how to obtain the current time from
    each of the three available clocks, extract the time since each clock’s epoch
    as a duration, and then convert them to ticks.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-21](ch12.xhtml#ch12ex21) 显示了如何从三种可用的时钟中获取当前时间，提取每个时钟纪元以来的时长，并将它们转换为滴答数。'
- en: '[PRE26]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 12-21: The `std::chrono` supports several kinds of clocks.*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-21：`std::chrono` 支持多种类型的时钟。*'
- en: You obtain the current time from the `system_clock` ➊, the `high_resolu`tion
    _clock ➋, and the `steady_clock` ➌. For each clock, you convert the time point
    into a `duration` since the clock’s epoch using the `time_since_epoch` method.
    You immediately call `count` on the resulting duration to yield a tick count,
    which should be greater than zero ➍ ➎ ➏.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 `system_clock` ➊、`high_resolution_clock` ➋ 和 `steady_clock` ➌ 获取当前时间。对于每个时钟，你都可以使用
    `time_since_epoch` 方法将时间点转换为自该时钟纪元以来的时长。接着，你立即调用 `count` 方法，得到一个滴答数，该滴答数应该大于零
    ➍ ➎ ➏。
- en: In addition to deriving durations from time points, you can construct them directly.
    The `std::chrono` namespace contains helper functions to generate durations. For
    convenience, Chrono offers a number of user-defined duration literals in the `std::literals::chrono_literals`
    namespace. These provide some syntactic sugar, convenient language syntax that
    makes life easier for the developer, for defining duration literals.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过时间点推导时长外，你还可以直接构造时长。`std::chrono` 命名空间包含了一些辅助函数来生成时长。为了方便起见，Chrono 提供了许多用户自定义的时长字面量，这些字面量位于
    `std::literals::chrono_literals` 命名空间中。它们提供了一些语法糖，是便捷的语言语法，旨在简化开发者的工作，用于定义时长字面量。
- en: '[Table 12-10](ch12.xhtml#ch12tab10) shows the helper functions and their literal
    equivalents, where each expression corresponds to an hour’s duration.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-10](ch12.xhtml#ch12tab10) 显示了这些辅助函数及其字面量等价物，每个表达式都对应一个小时的时长。'
- en: '**Table 12-10:** `std::chrono` Helper Functions and User-Defined Literals for
    Creating Durations'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-10：** `std::chrono` 辅助函数和用于创建时长的用户定义字面量'
- en: '| **Helper function** | **Literal equivalent** |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **辅助函数** | **字面量等价物** |'
- en: '| `nanoseconds(3600000000000)` | `3600000000000ns` |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `nanoseconds(3600000000000)` | `3600000000000ns` |'
- en: '| `microseconds(3600000000)` | `3600000000us` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `microseconds(3600000000)` | `3600000000us` |'
- en: '| `milliseconds(3600000)` | `3600000ms` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `milliseconds(3600000)` | `3600000ms` |'
- en: '| `seconds(3600)` | `3600s` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `seconds(3600)` | `3600s` |'
- en: '| `minutes(60)` | `60m` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `minutes(60)` | `60m` |'
- en: '| `hours(1)` | `1h` |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `hours(1)` | `1h` |'
- en: For example, [Listing 12-22](ch12.xhtml#ch12ex22) illustrates how to construct
    a duration of 1 second with `std::chrono::seconds` and another duration of 1,000
    milliseconds using the `ms` duration literal.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单 12-22](ch12.xhtml#ch12ex22)展示了如何使用`std::chrono::seconds`构造1秒的持续时间，以及使用`ms`持续时间字面量构造1,000毫秒的持续时间。
- en: '[PRE27]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 12-22: The `std::chrono` supports many units of measurement, which
    are comparable.*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-22：`std::chrono`支持多种度量单位，它们是可比较的。*'
- en: Here, you bring in the `std::literals::chrono_literals` namespace so you have
    access to the duration literals ➊. You construct a duration called `one_s` from
    the `seconds` helper function ➋ and another called `thousand_ms` from the `ms`
    duration literal ➌. These are equivalent because a second contains a thousand
    milliseconds ➍.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你引入`std::literals::chrono_literals`命名空间，以便访问持续时间字面量 ➊。你从`seconds`辅助函数 ➋
    构造了一个名为`one_s`的持续时间，从`ms`持续时间字面量 ➌ 构造了另一个名为`thousand_ms`的持续时间。这两个是等价的，因为一秒包含一千毫秒
    ➍。
- en: Chrono provides the function template `std::chrono::duration_cast` to cast a
    duration from one unit to another. As with other cast-related function templates,
    such as `static_cast`, `duration_cast` takes a single template parameter corresponding
    to the target duration and a single argument corresponding to the duration you
    want to cast.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Chrono提供了函数模板`std::chrono::duration_cast`，用于将持续时间从一种单位转换为另一种单位。与其他与类型转换相关的函数模板（例如`static_cast`）一样，`duration_cast`接受一个对应目标持续时间的单一模板参数，以及一个对应要转换的持续时间的单一参数。
- en: '[Listing 12-23](ch12.xhtml#ch12ex23) illustrates how to cast a `nanosecond`
    duration into a `second` duration.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-23](ch12.xhtml#ch12ex23)展示了如何将`纳秒`持续时间转换为`秒`持续时间。'
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 12-23: The `std::chrono` supports `std::chrono::duration_cast`.*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-23：`std::chrono`支持`std::chrono::duration_cast`。*'
- en: First, you bring in the `std::chrono` namespace for easy access to `duration_cast`,
    the duration helper functions, and the duration literals ➊. Next, you use the
    `ns` duration literal to specify a billion-nanosecond duration ➌, which you pass
    as the argument to `duration_cast`. You specify the template parameter of `duration_cast`
    as seconds ➋, so the resulting duration, `billion_ns_as_s`, equals 1 second ➍.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你引入`std::chrono`命名空间，以便轻松访问`duration_cast`、持续时间辅助函数和持续时间字面量 ➊。接下来，你使用`ns`持续时间字面量来指定一个十亿纳秒的持续时间
    ➌，并将其作为参数传递给`duration_cast`。你将`duration_cast`的模板参数指定为秒 ➋，因此结果持续时间`billion_ns_as_s`等于1秒
    ➍。
- en: '**Waiting**'
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**等待**'
- en: Sometimes, you’ll use durations to specify some period of time for your program
    to wait. The stdlib provides concurrency primitives in the `<thread>` header,
    which contains the non-member function `std::this_thread::sleep_``for`. The `sleep_for`
    function accepts a `duration` argument corresponding to how long you want the
    current thread of execution to wait or “sleep.”
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会使用持续时间来指定程序等待的时间段。标准库提供了位于`<thread>`头文件中的并发原语，其中包含了非成员函数`std::this_thread::sleep_for`。`sleep_for`函数接受一个`duration`参数，表示你希望当前执行线程等待或“休眠”的时间长度。
- en: '[Listing 12-24](ch12.xhtml#ch12ex24) shows how to employ `sleep_for`.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-24](ch12.xhtml#ch12ex24)展示了如何使用`sleep_for`。'
- en: '[PRE29]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 12-24: The `std::chrono` works with `<thread>` to put the current
    thread to sleep.*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-24：`std::chrono`与`<thread>`一起使用，以使当前线程休眠。*'
- en: As before, you bring in the `chrono_literals` namespace so you have access to
    the duration literals ➊. You record the current time according to `sys``tem_``clock`,
    saving the resulting `time_point` into the `start` variable ➋. Next, you invoke
    `sleep_for` with a 100-millisecond duration (a tenth of a second) ➌. You then
    record the current time again, saving the resulting `time_point` into `end` ➍.
    Because the program slept for 100 milliseconds between calls to `std::chrono::system_clock`,
    the duration resulting from subtracting `start` from `end` should be at least
    `100ms` ➎.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所述，你引入了`chrono_literals`命名空间，以便访问持续时间字面量 ➊。你根据`system_clock`记录了当前时间，并将结果`time_point`保存到`start`变量中
    ➋。接下来，你调用`sleep_for`，传入一个100毫秒的持续时间（即十分之一秒） ➌。然后你再次记录当前时间，将结果`time_point`保存到`end`
    ➍。因为程序在调用`std::chrono::system_clock`之间休眠了100毫秒，所以从`start`减去`end`得到的持续时间应该至少为`100ms`
    ➎。
- en: '**Timing**'
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计时**'
- en: To optimize code, you absolutely need accurate measurements. You can use Chrono
    to measure how long a series of operations takes. This enables you to establish
    that a particular code path is actually responsible for observed performance issues.
    It also enables you to establish an objective measure for the progress of your
    optimization efforts.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化代码，你必须进行准确的测量。你可以使用 Chrono 来衡量一系列操作所需的时间。这让你能够确认某个特定的代码路径实际上是导致观察到的性能问题的原因。它还使你能够为优化工作进展建立一个客观的衡量标准。
- en: Boost’s Timer library contains the `boost::timer::auto_cpu_timer` class in the
    `<boost/timer/timer.hpp>` header, which is an RAII object that begins timing in
    its constructor and stops timing in its destructor.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 的 Timer 库包含了位于 `<boost/timer/timer.hpp>` 头文件中的 `boost::timer::auto_cpu_timer`
    类，这是一个 RAII 对象，它在构造函数中开始计时，在析构函数中停止计时。
- en: You can build your own makeshift `Stopwatch` class using just the stdlib Chrono
    library. The `Stopwatch` class can keep a reference to a `duration` object. In
    the `Stopwatch` destructor, you can set the `duration` via its reference. [Listing
    12-25](ch12.xhtml#ch12ex25) provides an implementation.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以仅使用 stdlib Chrono 库构建你自己的简易 `Stopwatch` 类。`Stopwatch` 类可以保存一个 `duration`
    对象的引用。在 `Stopwatch` 的析构函数中，你可以通过引用设置 `duration`。[列表 12-25](ch12.xhtml#ch12ex25)
    提供了一个实现。
- en: '[PRE30]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 12-25: A simple `Stopwatch` class that computes the duration of its
    lifetime*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-25：一个简单的 `Stopwatch` 类，用于计算其生命周期的持续时间*'
- en: The `Stopwatch` constructor requires a single `nanoseconds` reference ➊, which
    you store into the `result` field with a member initializer ➋. You also save the
    current time of the `high_resolution_clock` by setting the `start` field to the
    result of `now()` ➌. In the `Stopwatch` destructor, you again invoke `now()` on
    the `high_resolution_clock` and subtract `start` to obtain the duration of the
    lifetime of `Stopwatch`. You use the `result` reference to write the `duration`
    ➍.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 构造函数需要一个 `nanoseconds` 类型的引用 ➊，你将其存储到 `result` 字段中，使用成员初始化器 ➋。你还通过将
    `start` 字段设置为 `now()` 的结果来保存当前的 `high_resolution_clock` 时间 ➌。在 `Stopwatch` 的析构函数中，你再次调用
    `now()` 来获取 `high_resolution_clock` 的时间，并用 `start` 减去它，得到 `Stopwatch` 生命周期的持续时间。你使用
    `result` 引用来写入 `duration` ➍。'
- en: '[Listing 12-26](ch12.xhtml#ch12ex26) shows the `Stopwatch` in action, performing
    a million floating-point divisions within a loop and computing the average time
    elapsed per iteration.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-26](ch12.xhtml#ch12ex26) 展示了 `Stopwatch` 的实际应用，在一个循环中执行百万次浮点除法，并计算每次迭代的平均时间。'
- en: '[PRE31]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 12-26: Using the `Stopwatch` to estimate the time taken for `double`
    division*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-26：使用 `Stopwatch` 来估算 `double` 除法所需的时间*'
- en: First, you initialize a variable `n` to a million, which stores the total number
    of iterations your program will make ➊. You declare the `elapsed` variable, which
    will store the time elapsed across all the iterations ➋. Within a block, you declare
    a `Stopwatch` and pass an `elapsed` reference to the constructor ➌. Next, you
    declare a `double` called `result` with a junk value in it ➍. You declare this
    variable `volatile` so the compiler doesn’t try to optimize the loop away. Within
    the loop, you do some arbitrary, floating-point division ➎.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个变量 `n` 为一百万，这表示程序将执行的总迭代次数 ➊。然后，你声明了 `elapsed` 变量，用于存储所有迭代过程中所用的时间
    ➋。在一个代码块中，你声明了一个 `Stopwatch` 并将 `elapsed` 引用传递给构造函数 ➌。接着，你声明了一个名为 `result` 的 `double`
    类型变量，并为其赋一个无意义的初值 ➍。你将这个变量声明为 `volatile`，以防编译器尝试优化掉循环。在循环内，你执行一些任意的浮点除法操作 ➎。
- en: Once the block completes, `stopwatch` destructs. This writes the duration of
    `stopwatch` to `elapsed`, which you use to compute the average number of nanoseconds
    per loop iteration and store into the `time_per_addition` variable ➏. You conclude
    the program by printing `time_per_division` with `printf` ➐.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码块执行完毕，`stopwatch` 将被析构。这会将 `stopwatch` 的持续时间写入 `elapsed`，然后你可以使用它来计算每次循环迭代的纳秒平均数，并将结果存入
    `time_per_addition` 变量 ➏。你通过 `printf` 打印 `time_per_division` 来结束程序 ➐。
- en: '**Numerics**'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数值运算**'
- en: This section discusses handling numbers with a focus on common mathematical
    functions and constants; handling complex numbers; generating random numbers,
    numeric limits, and conversions; and computing ratios.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何处理数字，重点是常见的数学函数和常量；如何处理复数；生成随机数、数字极限和转换；以及计算比率。
- en: '***Numeric Functions***'
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数值函数***'
- en: The stdlib Numerics and Boost Math libraries provide a profusion of numeric/mathematical
    functions. For the sake of brevity, this chapter presents only quick references.
    For detailed treatment, see [numerics] in the ISO C++ 17 Standard and the Boost
    Math documentation.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: stdlib 数值和 Boost 数学库提供了大量的数值/数学函数。为了简洁起见，本章仅提供快速参考。有关详细内容，请参见 ISO C++ 17 标准中的
    [numerics] 和 Boost 数学文档。
- en: '[Table 12-11](ch12.xhtml#ch12tab11) provides a partial list of many common,
    non-member mathematical functions available in the stdlib’s Math library.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-11](ch12.xhtml#ch12tab11) 提供了 stdlib 数学库中许多常见的非成员数学函数的部分列表。'
- en: '**Table 12-11:** A Partial List of Common Math Functions in the stdlib'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-11：** stdlib 中常用数学函数的部分列表'
- en: '| **Function** | **Computes the . . .** | **Ints** | **Floats** | **Header**
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '**函数** | **计算 . . .** | **整数** | **浮点数** | **头文件** |'
- en: '| `abs(`x`)` | Absolute value of x. | ✓ |  | `<cstdlib>` |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `abs(`x`)` | x 的绝对值。 | ✓ |  | `<cstdlib>` |'
- en: '| `div(`x`,` y`)` | Quotient and remainder of x divided by y. | ✓ |  | `<cstdlib>`
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `div(`x`,` y`)` | x 除以 y 的商和余数。 | ✓ |  | `<cstdlib>` |'
- en: '| `abs(`x`)` | Absolute value of x. |  | ✓ | `<cmath>` |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `abs(`x`)` | x 的绝对值。 |  | ✓ | `<cmath>` |'
- en: '| `fmod(`x`,` y`)` | Remainder of floating-point division of x by y. |  | ✓
    | `<cmath>` |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `fmod(`x`,` y`)` | x 除以 y 的浮点数余数。 |  | ✓ | `<cmath>` |'
- en: '| `remainder(`x`,` y`)` | Signed remainder of dividing x by y. | ✓ | ✓ | `<cmath>`
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `remainder(`x`,` y`)` | x 除以 y 的带符号余数。 | ✓ | ✓ | `<cmath>` |'
- en: '| `fma(`x`,` y`,` z`)` | Multiply the first two arguments and add their product
    to the third argument; also called fused multiplication addition; that is, x *
    y `+` z. | ✓ | ✓ | `<cmath>` |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `fma(`x`,` y`,` z`)` | 将前两个参数相乘，并将其乘积加到第三个参数；也称为融合乘法加法；即，x * y `+` z。 | ✓
    | ✓ | `<cmath>` |'
- en: '| `max(`x`,` y`)` | Maximum of x and y. | ✓ | ✓ | `<algorithm>` |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `max(`x`,` y`)` | x 和 y 的最大值。 | ✓ | ✓ | `<algorithm>` |'
- en: '| `min(`x`,` y`)` | Minimum of x and y. | ✓ | ✓ | `<algorithm>` |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `min(`x`,` y`)` | x 和 y 的最小值。 | ✓ | ✓ | `<algorithm>` |'
- en: '| `exp(`x`)` | Value of `e`^x. | ✓ | ✓ | `<cmath>` |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `exp(`x`)` | `e^x` 的值。 | ✓ | ✓ | `<cmath>` |'
- en: '| `exp2(`x`)` | Value of `2^x`. | ✓ | ✓ | `<cmath>` |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `exp2(`x`)` | `2^x` 的值。 | ✓ | ✓ | `<cmath>` |'
- en: '| `log(`x`)` | Natural log of x; that is, ln x. | ✓ | ✓ | `<cmath>` |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `log(`x`)` | x 的自然对数；即，ln x。 | ✓ | ✓ | `<cmath>` |'
- en: '| `log10(`x`)` | Common log of x; that is, log10 x. | ✓ | ✓ | `<cmath>` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `log10(`x`)` | x 的常用对数；即，log10 x。 | ✓ | ✓ | `<cmath>` |'
- en: '| `log2(`x`)` | Base 2 log of x; that is, log10 x. | ✓ | ✓ | `<cmath>` |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `log2(`x`)` | x 的以 2 为底的对数；即，log10 x。 | ✓ | ✓ | `<cmath>` |'
- en: '| `gcd(`x`,` y`)` | Greatest common denominator of x and y. | ✓ |  | `<numeric>`
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `gcd(`x`,` y`)` | x 和 y 的最大公约数。 | ✓ |  | `<numeric>` |'
- en: '| `lcm(`x`,` y`)` | Least common multiple of x and y. | ✓ |  | `<numeric>`
    |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `lcm(`x`,` y`)` | x 和 y 的最小公倍数。 | ✓ |  | `<numeric>` |'
- en: '| `erf(`x`)` | Gauss error function of x. | ✓ | ✓ | `<cmath>` |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `erf(`x`)` | x 的高斯误差函数。 | ✓ | ✓ | `<cmath>` |'
- en: '| `pow(`x`,` y`)` | Value of x^y. | ✓ | ✓ | `<cmath>` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `pow(`x`,` y`)` | x^y 的值。 | ✓ | ✓ | `<cmath>` |'
- en: '| `sqrt(`x`)` | Square root of x. | ✓ | ✓ | `<cmath>` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `sqrt(`x`)` | x 的平方根。 | ✓ | ✓ | `<cmath>` |'
- en: '| `cbrt(`x`)` | Cube root of x. | ✓ | ✓ | `<cmath>` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `cbrt(`x`)` | x 的立方根。 | ✓ | ✓ | `<cmath>` |'
- en: '| `hypot(`x`,` y`)` | Square root of x² `+` y². | ✓ | ✓ | `<cmath>` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `hypot(`x`,` y`)` | x² `+` y² 的平方根。 | ✓ | ✓ | `<cmath>` |'
- en: '| `sin(`x`)``cos(`x`)``tan(`x`)``asin(`x`)``acos(`x`)``atan(`x`)` | Associated
    trigonometric function value. | ✓ | ✓ | `<cmath>` |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `sin(`x`)``cos(`x`)``tan(`x`)``asin(`x`)``acos(`x`)``atan(`x`)` | 相关的三角函数值。
    | ✓ | ✓ | `<cmath>` |'
- en: '| `sinh(`x`)``cosh(`x`)``tanh(`x`)``asinh(`x`)``acosh(`x`)``atanh(`x`)` | Associated
    hyperbolic function value. | ✓ | ✓ | `<cmath>` |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `sinh(`x`)``cosh(`x`)``tanh(`x`)``asinh(`x`)``acosh(`x`)``atanh(`x`)` | 相关的双曲函数值。
    | ✓ | ✓ | `<cmath>` |'
- en: '| `ceil(`x`)` | Nearest integer greater than or equal to x. | ✓ | ✓ | `<cmath>`
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `ceil(`x`)` | 大于或等于 x 的最小整数。 | ✓ | ✓ | `<cmath>` |'
- en: '| `floor(`x`)` | Nearest integer less than or equal to x. | ✓ | ✓ | `<cmath>`
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `floor(`x`)` | 小于或等于 x 的最大整数。 | ✓ | ✓ | `<cmath>` |'
- en: '| `round(`x`)` | Nearest integer equal to x; rounds away from zero in midpoint
    cases. | ✓ | ✓ | `<cmath>` |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `round(`x`)` | 与 x 最接近的整数；在中点情况下远离零。 | ✓ | ✓ | `<cmath>` |'
- en: '| `isfinite(`x`)` | Value `true` if x is a finite number. | ✓ | ✓ | `<cmath>`
    |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `isfinite(`x`)` | 如果 x 是有限数，则值为 `true`。 | ✓ | ✓ | `<cmath>` |'
- en: '| `isinf(`x`)` | Value `true` if x is an infinite number. | ✓ | ✓ | `<cmath>`
    |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `isinf(`x`)` | 如果 x 是无限大数，则值为 `true`。 | ✓ | ✓ | `<cmath>` |'
- en: '**NOTE**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Other specialized mathematical functions are in the `<cmath>` header. For
    example, functions to compute Laguerre and Hermite polynomials, elliptic integrals,
    cylindrical Bessel and Neumann functions, and the Riemann zeta function appear
    in the header.*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*其他专门的数学函数位于 `<cmath>` 头文件中。例如，用于计算拉盖尔多项式和厄尔米特多项式、椭圆积分、圆柱贝塞尔函数和诺伊曼函数以及黎曼ζ函数的函数都出现在该头文件中。*'
- en: '***Complex Numbers***'
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复数***'
- en: A *complex number* is of the form `a+bi`, where `i` is an *imaginary number*
    that, when multiplied by itself, equals negative one; that is, `i*i=-1`. Imaginary
    numbers have applications in control theory, fluid dynamics, electrical engineering,
    signal analysis, number theory, and quantum physics, among other fields. The `a`
    portion of a complex number is called its *real component*, and the `b` portion
    is called the *imaginary component*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*复数* 的形式为 `a+bi`，其中 `i` 是 *虚数*，它与自身相乘等于负一；即 `i*i=-1`。虚数在控制理论、流体动力学、电气工程、信号分析、数论和量子物理等多个领域都有应用。复数的
    `a` 部分称为其 *实部*，`b` 部分称为其 *虚部*。'
- en: The stdlib offers the `std::complex` class template in the `<complex>` header.
    It accepts a template parameter for the underlying type of the real and imaginary
    component. This template parameter must be one of the fundamental floating-point
    types.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了 `<complex>` 头文件中的 `std::complex` 类模板。它接受一个模板参数，用于指定实部和虚部的底层类型。这个模板参数必须是基本的浮点类型之一。
- en: 'To construct a `complex`, you can pass in two arguments: the real and the imaginary
    components. The `complex` class also supports copy construction and copy assignment.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个 `complex`，你可以传入两个参数：实部和虚部。`complex` 类还支持拷贝构造和拷贝赋值。
- en: The non-member functions `std::real` and `std::imag` can extract the real and
    imaginary components from a `complex`, respectively, as [Listing 12-27](ch12.xhtml#ch12ex27)
    illustrates.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 非成员函数 `std::real` 和 `std::imag` 可以分别从 `complex` 中提取实部和虚部，如[列表 12-27](ch12.xhtml#ch12ex27)所示。
- en: '[PRE32]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 12-27: Constructing a `std::complex` and extracting its components*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-27：构造一个 `std::complex` 并提取其组成部分*'
- en: You construct a `std::complex` with a real component of 0.5 and an imaginary
    component of 14.13 ➊. You use `std::real` to extract the real component ➋ and
    `std::imag` to extract the imaginary component ➌.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个实部为 0.5，虚部为 14.13 的 `std::complex` ➊。你使用 `std::real` 提取实部 ➋，使用 `std::imag`
    提取虚部 ➌。
- en: '[Table 12-12](ch12.xhtml#ch12tab12) contains a partial list of supported operations
    with `std::complex`.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-12](ch12.xhtml#ch12tab12) 包含了 `std::complex` 支持的部分操作列表。'
- en: '**Table 12-12:** A Partial List of `std::complex` Operations'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-12：** `std::complex` 操作的部分列表'
- en: '| **Operation** | **Notes** |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **备注** |'
- en: '| c1+c2c1-c2c1*c2c1/c2 | Performs addition, subtraction, multiplication, and
    division. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| c1+c2c1-c2c1*c2c1/c2 | 执行加法、减法、乘法和除法。|'
- en: '| c+sc-sc*sc/s | Converts the scalar s into a complex number with the real
    component equal to the scalar value and the imaginary component equal to zero.
    This conversion supports the corresponding complex operation (addition, subtraction,
    multiplication, or division) in the preceding row. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| c+sc-sc*sc/s | 将标量 s 转换为一个复数，其中实部等于标量值，虚部为零。此转换支持上一行中的相应复数操作（加法、减法、乘法或除法）。|'
- en: '| `real``(`c`)` | Extracts real component. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `real``(`c`)` | 提取实部。|'
- en: '| `imag``(`c`)` | Extracts imaginary component. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `imag``(`c`)` | 提取虚部。|'
- en: '| `abs``(`c`)` | Computes magnitude. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `abs``(`c`)` | 计算幅度。|'
- en: '| `arg``(`c`)` | Computes the phase angle. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `arg``(`c`)` | 计算相位角。|'
- en: '| `norm``(`c`)` | Computes the squared magnitude. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `norm``(`c`)` | 计算平方幅度。|'
- en: '| `conj``(`c`)` | Computes the complex conjugate. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `conj``(`c`)` | 计算复共轭。|'
- en: '| `proj``(`c`)` | Computes Riemann sphere projection. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `proj``(`c`)` | 计算黎曼球投影。|'
- en: '| `sin``(`c`)` | Computes the sine. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `sin``(`c`)` | 计算正弦。|'
- en: '| `cos``(`c`)` | Computes the cosine. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `cos``(`c`)` | 计算余弦。|'
- en: '| `tan``(`c`)` | Computes the tangent. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `tan``(`c`)` | 计算正切。|'
- en: '| `asin``(`c`)` | Computes the arcsine. |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `asin``(`c`)` | 计算反正弦。|'
- en: '| `acos``(`c`)` | Computes the arccosine. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `acos``(`c`)` | 计算反余弦。|'
- en: '| `atan``(`c`)` | Computes the arctangent. |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `atan``(`c`)` | 计算反正切。|'
- en: '| c `= polar(`m`,` a`)` | Computes complex number determined by magnitude m
    and angle a. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| c `= polar(`m`,` a`)` | 计算由幅度 m 和角度 a 确定的复数。|'
- en: '***Mathematical Constants***'
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数学常数***'
- en: Boost offers a suite of commonly used mathematical constants in the `<boost
    /math/constants/constants.hpp>` header. More than 70 constants are available,
    and you can obtain them in `float`, `double`, or `long double` form by obtaining
    the relevant global variable from the `boost::math::float_constants`, `boost::math::double_constants`,
    and `boost::math::long_double_constants` respectively.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 提供了一套常用的数学常数，这些常数定义在 `<boost /math/constants/constants.hpp>` 头文件中。共有超过
    70 个常数可用，您可以通过从 `boost::math::float_constants`、`boost::math::double_constants`
    和 `boost::math::long_double_constants` 中获取相关的全局变量，分别获得 `float`、`double` 或 `long
    double` 类型的常数。
- en: One of the many constants available is `four_thirds_pi`, which approximates
    4`π`/3\. The formula for computing the volume of a sphere of radius *r* is 4π*r*³/3,
    so you could pull in this constant to make computing such a volume easy. [Listing
    12-28](ch12.xhtml#ch12ex28) illustrates how to compute the volume of a sphere
    with radius 10.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个可用常数是 `four_thirds_pi`，它近似为 4`π`/3。计算半径为 *r* 的球体体积的公式是 4π*r³/3，因此您可以引入这个常数，轻松计算这种体积。[列表
    12-28](ch12.xhtml#ch12ex28) 说明了如何计算半径为 10 的球体体积。
- en: '[PRE33]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 12-28: The `boost::math` namespace offers constants*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-28：`boost::math` 命名空间提供常数*'
- en: Here, you pull in the namespace `boost::math::double_constants`, which brings
    all the `double` versions of the Boost Math constants ➊. Next, you calculate the
    `sphere_volume` by computing `four_thirds_pi` times 10³ ➋.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，您引入了命名空间 `boost::math::double_constants`，它带来了所有 Boost 数学常数的 `double` 类型版本
    ➊。接下来，您通过计算 `four_thirds_pi` 乘以 10³ 来计算 `sphere_volume` ➋。
- en: '[Table 12-13](ch12.xhtml#ch12tab13) provides some of the more commonly used
    constants in Boost Math.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-13](ch12.xhtml#ch12tab13) 提供了一些 Boost 数学库中常用的常数。'
- en: '**Table 12-13:** Some of the Most Common Boost Math Constants'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-13：** 一些最常用的 Boost 数学常数'
- en: '| **Constant** | **Value** | **Approx.** | **Note** |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| **常数** | **值** | **近似值** | **备注** |'
- en: '| `half` | 1/2 | 0.5 |  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `half` | 1/2 | 0.5 |  |'
- en: '| `third` | 1/3 | 0.333333 |  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `third` | 1/3 | 0.333333 |  |'
- en: '| `two_thirds` | 2/3 | 0.66667 |  |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `two_thirds` | 2/3 | 0.66667 |  |'
- en: '| `three_quarters` | 3/4 | 0.75 |  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `three_quarters` | 3/4 | 0.75 |  |'
- en: '| `root_two` | √2 | 1.41421 |  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `root_two` | √2 | 1.41421 |  |'
- en: '| `root_three` | √3 | 1.73205 |  |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `root_three` | √3 | 1.73205 |  |'
- en: '| `half_root_two` | √2 / 2 | 0.707106 |  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `half_root_two` | √2 / 2 | 0.707106 |  |'
- en: '| `ln_two` | ln(2) | 0.693147 |  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `ln_two` | ln(2) | 0.693147 |  |'
- en: '| `ln_ten` | ln(10) | 2.30258 |  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `ln_ten` | ln(10) | 2.30258 |  |'
- en: '| `pi` | π | 3.14159 | Archimedes’ constant |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `pi` | π | 3.14159 | 阿基米德常数 |'
- en: '| `two_pi` | 2π | 6.28318 | Circumference of unit circle |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `two_pi` | 2π | 6.28318 | 单位圆的周长 |'
- en: '| `four_thirds_pi` | 4π/3 | 4.18879 | Volume of unit sphere |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `four_thirds_pi` | 4π/3 | 4.18879 | 单位球的体积 |'
- en: '| `one_div_two_pi` | 1/(2π) | 1.59155 | Gaussian integrals |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `one_div_two_pi` | 1/(2π) | 1.59155 | 高斯积分 |'
- en: '| `root_pi` | √ π | 1.77245 |  |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `root_pi` | √ π | 1.77245 |  |'
- en: '| `e` | e | 2.71828 | Euler’s constant e |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `e` | e | 2.71828 | 欧拉常数 e |'
- en: '| `e_pow_pi` | e^π | 23.14069 | Gelfond’s constant |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `e_pow_pi` | e^π | 23.14069 | 盖尔方德常数 |'
- en: '| `root_e` | √e | 1.64872 |  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `root_e` | √e | 1.64872 |  |'
- en: '| `log10_e` | log10(e) | 0.434294 |  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `log10_e` | log10(e) | 0.434294 |  |'
- en: '| `degree` | π / 180 | 0.017453 | Number of radians per degree |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `degree` | π / 180 | 0.017453 | 每度的弧度数 |'
- en: '| `radian` | 180 / π | 57.2957 | Number of degrees per radian |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `radian` | 180 / π | 57.2957 | 每弧度的度数 |'
- en: '| `sin_one` | sin(1) | 0.84147 |  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `sin_one` | sin(1) | 0.84147 |  |'
- en: '| `cos_one` | cos(1) | 0.5403 |  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `cos_one` | cos(1) | 0.5403 |  |'
- en: '| `phi` | (1 + √5) / 2 | 1.61803 | Phidias’ golden ratio φ |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `phi` | (1 + √5) / 2 | 1.61803 | 费迪亚斯黄金比例 φ |'
- en: '| `ln_phi` | ln(φ) | 0.48121 |  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `ln_phi` | ln(φ) | 0.48121 |  |'
- en: '***Random Numbers***'
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***随机数***'
- en: In some settings, it’s often necessary to generate random numbers. In scientific
    computing, you might need to run large numbers of simulations based on random
    numbers. Such numbers need to emulate draws from random processes with certain
    characteristics, such as coming from a Poisson or normal distribution. In addition,
    you usually want these simulations to be repeatable, so the code responsible for
    generating randomness—the random number engine—should produce the same output
    given the same input. Such random number engines are sometimes called pseudo-random
    number engines.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些场景中，生成随机数是常见的需求。在科学计算中，您可能需要基于随机数运行大量模拟。这些随机数需要模拟来自具有特定特性的随机过程，例如来自泊松分布或正态分布的抽取。此外，通常希望这些模拟是可重复的，因此负责生成随机数的代码——即随机数引擎——应在相同输入下生成相同的输出。这类随机数引擎有时被称为伪随机数引擎。
- en: In cryptography, you might require random numbers to instead secure information.
    In such settings, it must be virtually impossible for someone to obtain a similar
    stream of random numbers; so accidental use of pseudorandom number engines often
    seriously compromises an otherwise secure cryptosystem.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，你可能需要随机数来保护信息。在这种情况下，必须几乎不可能有人获得相似的随机数流；因此，偶然使用伪随机数引擎往往会严重破坏本应安全的加密系统。
- en: For these reasons and others, *you should never attempt to build your own random
    number generator*. Building a correct random number generator is surprisingly
    difficult. It’s too easy to introduce patterns into your random number generator,
    which can have nasty and hard to diagnose side effects on systems that use your
    random numbers as input.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因以及其他原因，*你不应尝试自行构建随机数生成器*。构建一个正确的随机数生成器出乎意料地困难。很容易在你的随机数生成器中引入模式，这可能会对使用你的随机数作为输入的系统造成严重且难以诊断的副作用。
- en: '**NOTE**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re interested in random number generation, refer to [Chapter 2](ch02.xhtml#ch02)
    of Stochastic Simulation by Brian D. Ripley for scientific applications and [Chapter
    2](ch02.xhtml#ch02) of Serious Cryptography by Jean-Philippe Aumasson for cryptographic
    applications.*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对随机数生成感兴趣，请参考Brian D. Ripley的《随机模拟》第2章，了解科学应用，或者Jean-Philippe Aumasson的《严肃的密码学》第2章，了解密码学应用。*'
- en: If you’re in the market for random numbers, look no further than the Random
    libraries available in the stdlib in the `<random>` header or in Boost in the
    `<boost/math/...>` headers.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要随机数，可以直接查看标准库中的`<random>`头文件，或者Boost中的`<boost/math/...>`头文件中的随机库。
- en: '**Random Number Engines**'
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机数引擎**'
- en: 'Random number engines generate random bits. Between Boost and stdlib, there
    is a dizzying array of candidates. Here’s a general rule: if you need repeatable
    pseudo-random numbers, consider using the Mersenne Twister engine `std::mtt19937_64`.
    If you need cryptographically secure random numbers, consider using `std::random_device`.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数引擎生成随机位。在Boost和标准库之间，有众多候选者可供选择。这里有一个通用规则：如果你需要可重复的伪随机数，可以考虑使用梅森旋转引擎`std::mtt19937_64`。如果你需要密码学上安全的随机数，可以考虑使用`std::random_device`。
- en: The Mersenne Twister has some desirable statistical properties for simulations.
    You provide its constructor with an integer seed value, which completely determines
    the sequence of random numbers. All random engines are function objects; to obtain
    a random number, use the function call `operator()`. [Listing 12-29](ch12.xhtml#ch12ex29)
    shows how to construct a Mersenne Twister engine with the seed 91586 and invoke
    the resulting engine three times.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 梅森旋转引擎具有一些在模拟中理想的统计特性。你为它的构造函数提供一个整数种子值，这完全决定了随机数序列。所有的随机引擎都是函数对象；要获得一个随机数，使用函数调用`operator()`。
    [清单12-29](ch12.xhtml#ch12ex29)展示了如何使用种子91586构造梅森旋转引擎并调用该引擎三次。
- en: '[PRE34]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 12-29: The `mt19937_64` is a pseudo-random number engine.*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-29：`mt19937_64`是一个伪随机数引擎。*'
- en: Here, you construct an `mt19937_64` Mersenne Twister engine with the seed 91586
    ➊. Because it’s a pseudo-random engine, you’re guaranteed to get the same sequence
    of random numbers ➋ ➌ ➍ each time. This sequence is determined entirely by the
    seed.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你构造了一个`mt19937_64`梅森旋转引擎，种子为91586 ➊。因为它是一个伪随机引擎，所以你每次都会得到相同的随机数序列 ➋ ➌ ➍。这个序列完全由种子决定。
- en: '[Listing 12-30](ch12.xhtml#ch12ex30) illustrates how to construct a `random_device`
    and invoke it to obtain a cryptographically secure random value.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-30](ch12.xhtml#ch12ex30)展示了如何构造一个`random_device`并调用它以获得密码学安全的随机值。'
- en: '[PRE35]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 12-30: The `random_device` is a function object.*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-30：`random_device`是一个函数对象。*'
- en: You construct a `random_device` using the default constructor ➊. The resulting
    object `rd_engine` ➋ is invokable, but you should treat the object as opaque.
    Unlike the Mersenne Twister in [Listing 12-29](ch12.xhtml#ch12ex29), `random_device`
    is unpredictable by design.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用默认构造函数 ➊ 构造一个`random_device`。结果对象`rd_engine` ➋ 是可调用的，但你应该将该对象视为不透明的。与[清单12-29](ch12.xhtml#ch12ex29)中的梅森旋转引擎不同，`random_device`是按设计不可预测的。
- en: '**NOTE**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because computers are deterministic by design, the `std::random_device` cannot
    make any strong guarantees about cryptographic security.*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于计算机本身是确定性的，`std::random_device`无法对密码学安全性做出任何强有力的保证。*'
- en: '**Random Number Distributions**'
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机数分布**'
- en: A *random number distribution* is a mathematical function that maps a number
    to a probability density. Roughly, the idea is that if you take infinite samples
    from a random variable that has a particular distribution and you plot the relative
    frequencies of your sample values, that plot would look like the distribution.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机数分布* 是一个数学函数，它将数字映射到概率密度。大致的思路是，如果你从一个具有特定分布的随机变量中抽取无限样本，并绘制样本值的相对频率，那么该图形将呈现该分布的形状。'
- en: 'Distributions break out into two broad categories: *discrete* and *continu**ous*.
    A simple analogy is that discrete distributions map integral values, and continuous
    distributions map floating-point values.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 分布分为两大类：*离散* 和 *连续*。一个简单的类比是，离散分布映射整数值，而连续分布映射浮点值。
- en: 'Most distributions accept customization parameters. For example, the normal
    distribution is a continuous distribution that accepts two parameters: a mean
    and a variance. Its density has a familiar bell shape centered around the mean,
    as shown in [Figure 12-1](ch12.xhtml#ch12fig01). The discrete uniform distribution
    is a random number distribution that assigns equal probability to the numbers
    between some minimum and maximum. Its density looks perfectly flat across its
    range from minimum to maximum, as shown in [Figure 12-2](ch12.xhtml#ch12fig02).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数分布接受自定义参数。例如，正态分布是一个连续分布，接受两个参数：均值和方差。其密度呈现一个熟悉的钟形曲线，围绕均值对称，如 [图 12-1](ch12.xhtml#ch12fig01)
    所示。离散均匀分布是一个随机数分布，它将均等的概率分配给介于最小值和最大值之间的数字。其密度在最小值到最大值的范围内呈平坦状，如 [图 12-2](ch12.xhtml#ch12fig02)
    所示。
- en: '![image](../images/fig12_1.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12_1.jpg)'
- en: '*Figure 12-1: A representation of the normal distribution’s probability density
    function*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：正态分布概率密度函数的表示*'
- en: '![image](../images/fig12_2.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig12_2.jpg)'
- en: '*Figure 12-2: A representation of the uniform distribution’s probability density
    function*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：均匀分布概率密度函数的表示*'
- en: You can easily generate random numbers from common statistical distributions,
    such as the uniform and the normal, using the same stdlib Random library. Each
    distribution accepts some parameters in its constructor, corresponding to the
    underlying distribution’s parameters. To draw a random variable from the distribution,
    you use the function call `operator()` and pass in an instance of a random number
    engine, such as a Mersenne Twister.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的标准库 Random 库轻松生成来自常见统计分布的随机数，例如均匀分布和正态分布。每个分布在其构造函数中接受一些参数，这些参数对应于基础分布的参数。要从分布中抽取一个随机变量，你可以使用函数调用
    `operator()` 并传入一个随机数引擎的实例，例如梅森旋转算法。
- en: The `std::uniform_int_distribution` is a class template available in the `<random>`
    header that takes a single template parameter corresponding to the type you want
    returned by draws from the distribution, like an `int`. You specify the uniform
    distribution’s minimum and maximum by passing them in as constructor parameters.
    Each number in the range has equal probability. It’s perhaps the most common distribution
    to arise in general software engineering contexts.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::uniform_int_distribution` 是一个类模板，位于 `<random>` 头文件中，它接受一个模板参数，指定你希望从分布中抽取的值类型，例如
    `int`。你通过将最小值和最大值作为构造函数参数传入来指定均匀分布的范围。范围内的每个数字都有相等的概率。这可能是最常见的分布，出现在一般的软件工程上下文中。'
- en: '[Listing 12-31](ch12.xhtml#ch12ex31) illustrates how to take a million draws
    from a uniform distribution with a minimum of 1 and a maximum of 10 and compute
    the sample mean.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-31](ch12.xhtml#ch12ex31) 演示了如何从最小值为 1、最大值为 10 的均匀分布中抽取一百万个样本，并计算样本均值。'
- en: '[PRE36]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 12-31: The `uniform_int_distribution` simulates draws from the discrete
    uniform distribution.*'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-31：`uniform_int_distribution` 模拟了来自离散均匀分布的抽取。*'
- en: You construct a Mersenne Twister with the seed 102787 ➊ and then construct a
    `uniform_int_distribution` with a minimum of 0 and a maximum of 10 ➋. Then you
    initialize a variable `n` to hold the number of iterations ➌ and initialize a
    variable to hold the `sum` of all the uniform random variables ➍. In the loop,
    you draw random variables from the uniform distribution with `operator()`, passing
    in the Mersenne Twister instance ➎.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 你用种子值 102787 ➊ 构造了一个梅森旋转算法实例，然后用最小值 0 和最大值 10 ➋ 构造一个 `uniform_int_distribution`。接着你初始化一个变量
    `n` 来存储迭代次数 ➌，并初始化一个变量来保存所有均匀随机变量的 `sum` ➍。在循环中，你通过 `operator()` 从均匀分布中抽取随机变量，并传入梅森旋转算法实例
    ➎。
- en: The mean of a discrete uniform distribution is the minimum plus the maximum
    divided by 2\. Here, `int_d` has a mean of 5\. You can compute a sample mean by
    dividing `sum` by the number of samples `n` ➏. With high confidence, you assert
    that this `sample_mean` is approximately 5 ➐.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 离散均匀分布的均值是最小值与最大值之和除以2。这里，`int_d`的均值为5。你可以通过将`sum`除以样本数量`n`来计算样本均值 ➏。你可以有很高的信心断言，这个`sample_mean`大约为5
    ➐。
- en: '**A Partial List of Random Number Distributions**'
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机数分布部分列表**'
- en: '[Table 12-14](ch12.xhtml#ch12tab14) contains a partial list of the random number
    distributions in `<random>`, their default template parameters, and their constructor
    parameters.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[表12-14](ch12.xhtml#ch12tab14)包含了`<random>`中随机数分布的部分列表，它们的默认模板参数和构造函数参数。'
- en: '**Table 12-14:** Random Number Distributions in `<random>`'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-14：** `<random>`中的随机数分布'
- en: '| **Distribution** | **Notes** |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| **分布** | **说明** |'
- en: '| `uniform_int_distribution<int>{` min`,` max `}` | Discrete uniform distribution
    with minimum min and maximum max. |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| `uniform_int_distribution<int>{` min`,` max `}` | 具有最小值min和最大值max的离散均匀分布。
    |'
- en: '| `uniform_real_distribution<double>{` min`,` max `}` | Continuous uniform
    distribution with minimum min and maximum max. |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| `uniform_real_distribution<double>{` min`,` max `}` | 具有最小值min和最大值max的连续均匀分布。
    |'
- en: '| `normal_distribution<double>{` m`,` s `}` | Normal distribution with mean
    m and standard deviation s. Commonly used to model the additive product of many
    independent random variables. Also called the Gaussian distribution. |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `normal_distribution<double>{` m`,` s `}` | 具有均值m和标准差s的正态分布。通常用于建模多个独立随机变量的加法积。也称为高斯分布。
    |'
- en: '| `lognormal_distribution<double>{` m`,` s `}` | Log-normal distribution with
    mean m and standard deviation s. Commonly used to model the multiplicative product
    of many independent random variables. Also called Galton’s distribution. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `lognormal_distribution<double>{` m`,` s `}` | 具有均值m和标准差s的对数正态分布。通常用于建模多个独立随机变量的乘法积。也称为Galton分布。
    |'
- en: '| `chi_squared_distribution<double>{` n `}` | Chi-squared distribution with
    degrees of freedom n. Commonly used in inferential statistics. |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `chi_squared_distribution<double>{` n `}` | 具有自由度n的卡方分布。通常用于推理统计学中。 |'
- en: '| `cauchy_distribution<double>{` a`,` b `}` | Cauchy distribution with location
    parameter a and scale parameter b. Used in physics. Also called the Lorentz distribution.
    |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `cauchy_distribution<double>{` a`,` b `}` | 具有位置参数a和尺度参数b的Cauchy分布。用于物理学中。也称为Lorentz分布。
    |'
- en: '| `fisher_f_distribution<double>{` m`,` n `}` | F distribution with degrees
    of freedom m and n. Commonly used in inferential statistics. Also called the Snedecor
    distribution. |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `fisher_f_distribution<double>{` m`,` n `}` | 具有自由度m和n的F分布。通常用于推理统计学中。也称为Snedecor分布。
    |'
- en: '| `student_t_distribution<double>{` n `}` | T distribution with degrees of
    freedom n. Commonly used in inferential statistics. Also called the Student’s
    T distribution. |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| `student_t_distribution<double>{` n `}` | 具有自由度n的T分布。通常用于推理统计学中。也称为学生T分布。
    |'
- en: '| `bernoulli_distribution{` p `}` | Bernoulli distribution with success probability
    p. Commonly used to model the result of a single, Boolean-valued outcome. |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| `bernoulli_distribution{` p `}` | 具有成功概率p的伯努利分布。通常用于建模单次布尔值结果的实验。 |'
- en: '| `binomial_distribution<int>{` n`,` p `}` | Binomial distribution with n trials
    and success probability p. Commonly used to model the number of successes when
    sampling with replacement in a series of Bernoulli experiments. |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| `binomial_distribution<int>{` n`,` p `}` | 具有n次试验和成功概率p的二项分布。通常用于建模在一系列伯努利实验中有放回抽样时的成功次数。
    |'
- en: '| `geometric_distribution<int>{` p `}` | Geometric distribution with success
    probability p. Commonly used to model the number of failures occurring before
    the first success in a series of Bernoulli experiments. |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `geometric_distribution<int>{` p `}` | 具有成功概率p的几何分布。通常用于建模在一系列伯努利实验中，第一次成功前发生的失败次数。
    |'
- en: '| `poisson_distribution<int>{` m `}` | Poisson distribution with mean m. Commonly
    used to model the number of events occurring in a fixed interval of time. |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `poisson_distribution<int>{` m `}` | 具有均值m的泊松分布。通常用于建模固定时间间隔内发生的事件数量。 |'
- en: '| `exponential_distribution<double>{` l `}` | Exponential distribution with
    mean 1/l, where l is known as the lambda parameter. Commonly used to model the
    amount of time between events in a Poisson process. |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `exponential_distribution<double>{` l `}` | 具有均值1/l的指数分布，其中l被称为lambda参数。通常用于建模泊松过程中的事件间隔时间。
    |'
- en: '| `gamma_distribution<double>{` a`,` b `}` | Gamma distribution with shape
    parameter a and scale parameter b. Generalization of the exponential distribution
    and chi-squared distribution. |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `gamma_distribution<double>{` a`,` b `}` | 具有形状参数a和尺度参数b的Gamma分布。指数分布和卡方分布的推广。
    |'
- en: '| `weibull_distribution<double>{` k`,` l `}` | Weibull distribution with shape
    parameter k and scale parameter l. Commonly used to model time to failure. |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `weibull_distribution<double>{` k`,` l `}` | 具有形状参数k和尺度参数l的Weibull分布。常用于建模故障时间。
    |'
- en: '| `extreme_value_distribution<double>{` a`,` b `}` | Extreme value distribution
    with location parameter a and scale parameter b. Commonly used to model maxima
    of independent random variables. Also called the Gumbel type-I distribution. |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `extreme_value_distribution<double>{` a`,` b `}` | 具有位置参数a和尺度参数b的极值分布。常用于建模独立随机变量的最大值。也称为Gumbel类型-I分布。
    |'
- en: '**NOTE**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost Math offers more random number distributions in the `<boost/math/...>`
    series of headers, for example, the beta, hypergeometric, logistic, and inverse
    normal distributions.*'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost Math提供了更多的随机数分布，位于`<boost/math/...>`系列头文件中，例如beta分布、超几何分布、对数分布和反正态分布。*'
- en: '***Numeric Limits***'
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数值限制***'
- en: The stdlib offers the class template `std::numeric_limits` in the `<limits>`
    header to provide you with compile time information about various properties for
    arithmetic types. For example, if you want to identify the smallest finite value
    for a given type `T`, you can use the static member function `std::numeric_limits<T>::min()`
    to obtain it.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了`std::numeric_limits`类模板，该模板位于`<limits>`头文件中，用于在编译时提供关于各种算术类型的属性信息。例如，如果你想要确定给定类型`T`的最小有限值，可以使用静态成员函数`std::numeric_limits<T>::min()`来获取该值。
- en: '[Listing 12-32](ch12.xhtml#ch12ex32) illustrates how to use `min` to facilitate
    an underflow.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例12-32](ch12.xhtml#ch12ex32)展示了如何使用`min`来促进下溢。'
- en: '[PRE37]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 12-32: Using `std::numeric_limits<T>::min()` to facilitate an `int`
    underflow. Although at press time the major compilers produce code that passes
    the test, this program contains undefined behavior.*'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例12-32：使用`std::numeric_limits<T>::min()`来促进`int`下溢。尽管在本文发布时，主要的编译器生成的代码通过了测试，但该程序包含未定义行为。*'
- en: First, you set the `my_cup` variable equal to the smallest possible `int` value
    by using `std::numeric_limits<int>::min()` ➊. Next, you intentionally cause an
    underflow by subtracting 1 from `my_cup` ➋. Because `my_cup` is the minimum value
    an `int` can take, `my_cup` runneth under, as the saying goes. This causes the
    deranged situation that `underfloweth` is greater than `my_cup` ➌, even though
    you initialized `underfloweth` by subtracting from `my_cup`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将`my_cup`变量设置为最小的`int`值，通过使用`std::numeric_limits<int>::min()` ➊。接下来，你故意通过从`my_cup`中减去1来引发下溢
    ➋。因为`my_cup`是`int`类型可以取的最小值，所以`my_cup`发生了下溢，正如俗话所说的那样。这导致了一个荒谬的情况，即`underfloweth`大于`my_cup`
    ➌，尽管你是通过从`my_cup`中减去得到`underfloweth`的。
- en: '**NOTE**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Such silent underflows have been the cause of untold numbers of software security
    vulnerabilities. Don’t rely on this undefined behavior!*'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种静默下溢已成为无数软件安全漏洞的根源。不要依赖这种未定义的行为！*'
- en: Many static member functions and member constants are available on `std::numeric_limits`.
    [Table 12-15](ch12.xhtml#ch12tab15) lists some of the most common.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 许多静态成员函数和成员常量可用于`std::numeric_limits`。[表12-15](ch12.xhtml#ch12tab15)列出了其中一些最常用的。
- en: '**Table 12-15:** Some Common Member Constants in `std::numeric_limits`'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-15：** `std::numeric_limits`中的一些常见成员常量'
- en: '| Operation | Notes |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 说明 |'
- en: '| `numeric_limits<`T`>::is_signed` | `true` if T is signed. |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `numeric_limits<`T`>::is_signed` | 如果T是有符号类型，则为`true`。 |'
- en: '| `numeric_limits<`T`>::is_integer` | `true` if T is an integer. |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `numeric_limits<`T`>::is_integer` | 如果T是整数，则为`true`。 |'
- en: '| `numeric_limits<`T`>::has_infinity` | Identifies whether T can encode an
    infinite value. (Usually, all floating-point types have an infinite value, whereas
    integral types don’t.) |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `numeric_limits<`T`>::has_infinity` | 标识T是否可以编码无限值。（通常，所有浮点类型都具有无限值，而整数类型则没有。）
    |'
- en: '| `numeric_limits<`T`>::digits10` | Identifies the number of digits T can represent.
    |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `numeric_limits<`T`>::digits10` | 标识T可以表示的数字位数。 |'
- en: '| `numeric_limits<`T`>::min()` | Returns the smallest value of T. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `numeric_limits<`T`>::min()` | 返回T的最小值。 |'
- en: '| `numeric_limits<`T`>::max()` | Returns the largest value of T. |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `numeric_limits<`T`>::max()` | 返回T的最大值。 |'
- en: '**NOTE**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Boost Integer provides some additional facilities for introspecting integer
    types, such as determining the fastest or smallest integer, or the smallest integer
    with at least *N* bits.*'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '*Boost Integer 提供了一些额外的功能，用于反射整数类型，比如确定最快或最小的整数，或具有至少 *N* 位的最小整数。*'
- en: '***Boost Numeric Conversion***'
  id: totrans-521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Boost 数值转换***'
- en: 'Boost provides the Numeric Conversion library, which contains a collection
    of tools to convert between numeric objects. The `boost::converter` class template
    in the `<boost/numeric/conversion/converter.hpp>` header encapsulates code to
    perform a specific numeric conversion from one type to another. You must provide
    two template parameters: the target type `T` and the source type S. You can specify
    a numeric converter that takes a `double` and converts it to an `int` with the
    simple type alias `double_to_int`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Boost 提供了数值转换库，其中包含了一组用于在数字对象之间转换的工具。`boost::converter` 类模板位于 `<boost/numeric/conversion/converter.hpp>`
    头文件中，封装了从一种类型到另一种类型的特定数值转换代码。你必须提供两个模板参数：目标类型 `T` 和源类型 `S`。你可以指定一个数值转换器，将 `double`
    转换为 `int`，通过简单的类型别名 `double_to_int`：
- en: '[PRE38]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To convert with your new type alias `double_to_int`, you have several options.
    First, you can use its static method `convert`, which accepts a `double` ➋ and
    returns an `int` ➊, as [Listing 12-33](ch12.xhtml#ch12ex33) illustrates.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你新建的类型别名 `double_to_int` 进行转换，你有几个选择。首先，你可以使用它的静态方法 `convert`，该方法接受一个 `double`
    ➋ 并返回一个 `int` ➊，正如 [列表 12-33](ch12.xhtml#ch12ex33) 所示。
- en: '[PRE39]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 12-33: The `boost::converter` offers the static method `convert`.*'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-33：`boost::converter` 提供了静态方法 `convert`。*'
- en: Here, you simply invoke the `convert` method with the value 3.14159, which `boost::convert`
    converts to 3.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需调用 `convert` 方法并传入值 3.14159，`boost::convert` 会将其转换为 3。
- en: Because `boost::convert` provides the function call `operator()`, you can construct
    a function object `double_to_int` and use it to convert, as in [Listing 12-34](ch12.xhtml#ch12ex34).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `boost::convert` 提供了函数调用 `operator()`，你可以构造一个函数对象 `double_to_int` 并使用它来进行转换，正如
    [列表 12-34](ch12.xhtml#ch12ex34) 所示。
- en: '[PRE40]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 12-34: The `boost::converter` implements `operator()`.*'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-34：`boost::converter` 实现了 `operator()`。*'
- en: You construct a `double_to_int` function object called `dti` ➊, which you invoke
    with the same argument, 3.14159 ➋, as in [Listing 12-33](ch12.xhtml#ch12ex33).
    The result is the same. You also have the option of constructing a temporary function
    object and using `operator()` directly, which yields identical results ➌.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你构造了一个名为 `dti` 的 `double_to_int` 函数对象 ➊，并用相同的参数 3.14159 ➋ 调用它，正如 [列表 12-33](ch12.xhtml#ch12ex33)
    所示。结果是相同的。你还可以选择构造一个临时函数对象并直接使用 `operator()`，这将得到相同的结果 ➌。
- en: A major advantage of using `boost::converter` instead of alternatives like `static_cast`
    is runtime bounds checking. If a conversion would cause an overflow, `boost::converter`
    will throw a `boost::numeric::positive_overflow` or `boost::numeric::negative_overflow`.
    [Listing 12-35](ch12.xhtml#ch12ex35) illustrates this behavior when you attempt
    to convert a very large `double` into an `int`.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `boost::converter` 的一个主要优点，相比于 `static_cast` 等替代方案，是运行时边界检查。如果一个转换会导致溢出，`boost::converter`
    将抛出 `boost::numeric::positive_overflow` 或 `boost::numeric::negative_overflow`
    异常。[列表 12-35](ch12.xhtml#ch12ex35) 展示了当你尝试将一个非常大的 `double` 转换为 `int` 时的这种行为。
- en: '[PRE41]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 12-35: The `boost::converter` checks for overflow.*'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-35：`boost::converter` 检查溢出。*'
- en: You use `numeric_limits` to obtain a `yuge` value ➊. You construct a `double
    _``to_int` converter ➋, which you use to attempt a conversion of `yuge` to an
    `int` ➌. This throws a `positive_overflow` exception because the value is too
    large to store ➍.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `numeric_limits` 来获得一个 `yuge` 值 ➊。你构造了一个 `double _``to_int` 转换器 ➋，并用它尝试将
    `yuge` 转换为 `int` ➌。这会抛出一个 `positive_overflow` 异常，因为该值太大，无法存储 ➍。
- en: It’s possible to customize the conversion behavior of `boost::converter` using
    template parameters. For example, you can customize the overflow handling to throw
    a custom exception or perform some other operation. You can also customize rounding
    behavior so that rather than truncating off the decimal from a floating-point
    value, you perform custom rounding. See the Boost Numeric Conversion documentation
    for details.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用模板参数自定义 `boost::converter` 的转换行为。例如，你可以自定义溢出处理，使其抛出一个自定义异常或执行其他操作。你还可以自定义舍入行为，这样就不会从浮动值中截断小数，而是执行自定义的舍入操作。详细信息请参见
    Boost 数值转换文档。
- en: If you’re happy with the default `boost::converter` behavior, you can use the
    `boost::numeric_cast` function template as a shortcut. This function template
    accepts a single template parameter corresponding to the target type of the conversion
    and a single argument corresponding to the source number. [Listing 12-36](ch12.xhtml#ch12ex36)
    provides an update to [Listing 12-35](ch12.xhtml#ch12ex35) that uses `boost::numeric_cast`
    instead.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对默认的 `boost::converter` 行为满意，你可以使用 `boost::numeric_cast` 函数模板作为快捷方式。该函数模板接受一个模板参数，表示转换目标类型，并接受一个参数，表示源数值。[列表
    12-36](ch12.xhtml#ch12ex36) 提供了对 [列表 12-35](ch12.xhtml#ch12ex35) 的更新，使用了 `boost::numeric_cast`。
- en: '[PRE42]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 12-36: The `boost::numeric_cast` function template also performs runtime
    bounds checking.*'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-36：`boost::numeric_cast` 函数模板也执行运行时边界检查。*'
- en: As before, you use `numeric_limits` to obtain a `yuge` value ➊. When you try
    to `numeric_cast` `yuge` into an `int` ➋, you get a `positive_overflow` exception
    because the value is too large to store ➌.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，你使用 `numeric_limits` 获取一个 `yuge` 值 ➊。当你尝试将 `yuge` 转换为 `int` ➋ 时，你会得到一个
    `positive_overflow` 异常，因为该值太大，无法存储 ➌。
- en: '**NOTE**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `boost::numeric_cast` function template is a suitable replacement for
    the `narrow_cast` you hand-rolled in [Listing 6-6](ch06.xhtml#ch06ex06) on [page
    154](ch06.xhtml#page_154).*'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*`boost::numeric_cast` 函数模板是你在 [列表 6-6](ch06.xhtml#ch06ex06)（[第 154 页](ch06.xhtml#page_154)）中自定义的
    `narrow_cast` 的合适替代。*'
- en: '***Compile-Time Rational Arithmetic***'
  id: totrans-543
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编译时有理数算术运算***'
- en: 'The stdlib `std::ratio` in the `<ratio>` header is a class template that enables
    you to compute rational arithmetic at compile time. You provide two template parameters
    to `std::ratio`: a numerator and a denominator. This defines a new type that you
    can use to compute rational expressions.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: stdlib 中的 `std::ratio`（位于 `<ratio>` 头文件中）是一个类模板，使你能够在编译时进行有理数算术运算。你向 `std::ratio`
    提供两个模板参数：一个分子和一个分母。这定义了一个新类型，你可以使用该类型来计算有理数表达式。
- en: The way you perform compile-time computation with `std::ratio` is by using template
    metaprogramming techniques. For example, to multiply two `ratio` types, you can
    use the `std::ratio_multiply` type, which takes the two `ratio` types as template
    parameters. You can extract the numerator and denominator of the result using
    static member variables on the resulting type.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用模板元编程技术来执行 `std::ratio` 的编译时计算。例如，要乘以两个 `ratio` 类型，你可以使用 `std::ratio_multiply`
    类型，该类型将两个 `ratio` 类型作为模板参数。你可以通过结果类型的静态成员变量来提取分子和分母。
- en: '[Listing 12-37](ch12.xhtml#ch12ex37) illustrates how to multiply 10 by 2/3
    at compile time.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-37](ch12.xhtml#ch12ex37) 说明了如何在编译时将 10 乘以 2/3。'
- en: '[PRE43]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 12-37: Compile time rational arithmetic with `std::ratio`*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-37：使用 `std::ratio` 进行编译时有理数算术运算*'
- en: You declare the `std::ratio` types `ten` ➊ and `two_thirds` ➋ as type aliases.
    To compute the product of `ten` and `two_thirds`, you again declare another type,
    `result`, using the `std::ratio_multiply` template ➌. Using the static members
    `num` and `den`, you can extract the result, 20/3 ➍ ➎.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明了 `std::ratio` 类型的 `ten` ➊ 和 `two_thirds` ➋ 作为类型别名。为了计算 `ten` 和 `two_thirds`
    的积，你再次声明了另一个类型 `result`，使用 `std::ratio_multiply` 模板 ➌。通过使用静态成员 `num` 和 `den`，你可以提取结果
    20/3 ➍ ➎。
- en: Of course, it’s always better to do computation at compile time rather than
    at runtime when you can. Your programs will be more efficient because they’ll
    need to do less computation when they run.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当你能在编译时进行计算时，最好尽量避免在运行时进行计算。这样你的程序将更加高效，因为它们在运行时需要做的计算更少。
- en: '**A Partial List of Random Number Distributions**'
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机数分布的部分列表**'
- en: '[Table 12-16](ch12.xhtml#ch12tab16) contains a partial list of the operations
    provided by stdlib’s `<ratio>` library.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-16](ch12.xhtml#ch12tab16) 包含了 stdlib `<ratio>` 库提供的部分操作列表。'
- en: '**Table 12-16:** A Partial List of Operations Available in `<ratio>`'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-16：** `<ratio>` 中可用操作的部分列表'
- en: '| Distribution | Notes |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 分布 | 说明 |'
- en: '| `ratio_add<`r1`,` r2`>` | Adds r1 and r2 |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_add<`r1`,` r2`>` | 将 r1 和 r2 相加 |'
- en: '| `ratio_subtract<`r1`,` r2`>` | Subtracts r2 from r1 |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_subtract<`r1`,` r2`>` | 从 r1 中减去 r2 |'
- en: '| `ratio_multiply<`r1`,` r2`>` | Multiplies r1 and r2 |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_multiply<`r1`,` r2`>` | 计算 r1 和 r2 的乘积 |'
- en: '| `ratio_divide<`r1`,` r2`>` | Divides r1 by r2 |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_divide<`r1`,` r2`>` | 将 r1 除以 r2 |'
- en: '| `ratio_equal<`r1`,` r2`>` | Tests whether r1 equals r2 |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_equal<`r1`,` r2`>` | 测试 r1 是否等于 r2 |'
- en: '| `ratio_not_equal<`r1`,` r2`>` | Tests whether r1 is not equal to r2 |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_not_equal<`r1`,` r2`>` | 测试 r1 是否不等于 r2 |'
- en: '| `ratio_less<`r1`,` r2`>` | Tests whether r1 is less than r2 |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_less<`r1`,` r2`>` | 测试 r1 是否小于 r2 |'
- en: '| `ratio_greater<`r1`,` r2`>` | Tests whether r1 is greater than r2 |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_greater<`r1`,` r2`>` | 测试r1是否大于r2 |'
- en: '| `ratio_less_equal<`r1`,` r2`>` | Tests whether r1 is less than or equal to
    r2 |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_less_equal<`r1`,` r2`>` | 测试r1是否小于或等于r2 |'
- en: '| `ratio_greater_equal<`r1`,` r2`>` | Tests whether r1 is greater than or equal
    to r2 |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| `ratio_greater_equal<`r1`,` r2`>` | 测试r1是否大于或等于r2 |'
- en: '| `micro` | Literal: `ratio<1, 1000000>` |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| `micro` | 字面值：`ratio<1, 1000000>` |'
- en: '| `milli` | Literal: `ratio<1, 1000>` |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| `milli` | 字面值：`ratio<1, 1000>` |'
- en: '| `centi` | Literal: `ratio<1, 100>` |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| `centi` | 字面值：`ratio<1, 100>` |'
- en: '| `deci` | Literal: `ratio<1, 10>` |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| `deci` | 字面值：`ratio<1, 10>` |'
- en: '| `deca` | Literal: `ratio<10, 1>` |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| `deca` | 字面值：`ratio<10, 1>` |'
- en: '| `hecto` | Literal: `ratio<100, 1>` |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| `hecto` | 字面值：`ratio<100, 1>` |'
- en: '| `kilo` | Literal: `ratio<1000, 1>` |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| `kilo` | 字面值：`ratio<1000, 1>` |'
- en: '| `mega` | Literal: `ratio<1000000, 1>` |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| `mega` | 字面值：`ratio<1000000, 1>` |'
- en: '| `giga` | Literal: `ratio<1000000000, 1>` |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| `giga` | 字面值：`ratio<1000000000, 1>` |'
- en: '**Summary**'
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you examined a potpourri of small, simple, focused utilities
    that service common programming needs. Data structures, such as `tribool`, `optional`,
    `pair`, `tuple`, `any`, and `variant` handle many commonplace scenarios in which
    you need to contain objects within a common structure. In the coming chapters,
    a few of these data structures will make repeat appearances throughout the stdlib.
    You also learned about date/time and numerics/math facilities. These libraries
    implement very specific functionality, but when you have such requirements, these
    libraries are invaluable.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了一些小巧、简单、聚焦的实用工具，它们服务于常见的编程需求。数据结构，如`tribool`、`optional`、`pair`、`tuple`、`any`和`variant`，处理了许多常见场景，在这些场景中，你需要将对象包含在一个通用的结构中。在接下来的章节中，这些数据结构中的一些将在整个标准库中多次出现。你还学习了日期/时间和数字/数学功能。这些库实现了非常具体的功能，但当你有此类需求时，这些库是无价的。
- en: '**EXERCISES**'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**12-1.** Reimplement the `narrow_cast` in [Listing 6-6](ch06.xhtml#ch06ex06)
    to return a `std::optional`. If the cast would result in a narrowing conversion,
    return an empty optional rather than throwing an exception. Write a unit test
    that ensures your solution works.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**12-1.** 重新实现[Listing 6-6](ch06.xhtml#ch06ex06)中的`narrow_cast`，使其返回一个`std::optional`。如果强制转换会导致精度丢失，请返回一个空的optional，而不是抛出异常。编写单元测试，确保你的解决方案有效。'
- en: '**12-2.** Implement a program that generates random alphanumeric passwords
    and writes them to the console. You can store the alphabet of possible characters
    into a `char[]` and use the discrete uniform distribution with a minimum of zero
    and a maximum of the last index of your alphabet array. Use a cryptographically
    secure random number engine.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**12-2.** 实现一个程序，生成随机字母数字密码并将其写入控制台。你可以将可能字符的字母表存储到一个`char[]`数组中，并使用离散均匀分布，最小值为零，最大值为字母表数组的最后一个索引。使用加密安全的随机数引擎。'
- en: '**FURTHER READING**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO国际标准ISO/IEC (2017) — C++编程语言*（国际标准化组织；瑞士日内瓦； *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*）'
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Boost C++库》，第2版，博里斯·谢林著（XML Press，2014年）*'
- en: '*The C++ Standard Library: A Tutorial and Reference*, 2nd Edition, by Nicolai
    M. Josuttis (Addison-Wesley Professional, 2012)'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++标准库：教程与参考》，第2版，尼科莱·M·乔苏提斯著（Addison-Wesley Professional，2012年）*'
