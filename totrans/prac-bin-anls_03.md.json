["```\ntypedef struct {\n  unsigned char e_ident[16];   /* Magic number and other info       */\n  uint16_t     e_type;         /* Object file type                  */\n  uint16_t     e_machine;      /* Architecture                      */\n  uint32_t     e_version;      /* Object file version               */\n  uint64_t     e_entry;        /* Entry point virtual address       */\n  uint64_t     e_phoff;        /* Program header table file offset  */\n  uint64_t     e_shoff;        /* Section header table file offset  */\n  uint32_t     e_flags;        /* Processor-specific flags          */\n  uint16_t     e_ehsize;       /* ELF header size in bytes          */\n  uint16_t     e_phentsize;    /* Program header table entry size   */\n  uint16_t     e_phnum;        /* Program header table entry count  */\n  uint16_t     e_shentsize;    /* Section header table entry size   */\n  uint16_t     e_shnum;        /* Section header table entry count  */\n  uint16_t     e_shstrndx;     /* Section header string table index */\n} Elf64_Ehdr;\n```", "```\n  $ readelf -h a.out\n  ELF Header:\n➊ Magic:     7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n➋ Class:                               ELF64\n   Data:                                2's complement, little endian\n   Version:                             1 (current)\n   OS/ABI:                              UNIX - System V\n   ABI Version:                         0\n➌ Type:                                EXEC (Executable file)\n➍ Machine:                             Advanced Micro Devices X86-64\n➎ Version:                             0x1\n➏ Entry point address:                 0x400430\n➐ Start of program headers:            64 (bytes into file)\n   Start of section headers:            6632 (bytes into file)\n   Flags:                               0x0\n➑ Size of this header:                 64 (bytes)\n➒ Size of program headers:             56 (bytes)\n   Number of program headers:           9\n   Size of section headers:             64 (bytes)\n   Number of section headers:           31\n➓ Section header string table index:   28\n```", "```\n$ readelf -x .shstrtab a.out\n\nHex dump of section '.shstrtab':\n  0x00000000 002e7379 6d746162 002e7374 72746162 ➊..symtab..strtab\n  0x00000010 002e7368 73747274 6162002e 696e7465 ..shstrtab..inte\n  0x00000020 7270002e 6e6f7465 2e414249 2d746167 rp..note.ABI-tag\n  0x00000030 002e6e6f 74652e67 6e752e62 75696c64 ..note.gnu.build\n  0x00000040 2d696400 2e676e75 2e686173 68002e64 -id..gnu.hash..d\n  0x00000050 796e7379 6d002e64 796e7374 72002e67 ynsym..dynstr..g\n  0x00000060 6e752e76 65727369 6f6e002e 676e752e nu.version..gnu.\n  0x00000070 76657273 696f6e5f 72002e72 656c612e version_r..rela.\n  0x00000080 64796e00 2e72656c 612e706c 74002e69 dyn..rela.plt..i\n  0x00000090 6e697400 2e706c74 2e676f74 002e7465 nit..plt.got..te\n  0x000000a0 7874002e 66696e69 002e726f 64617461 xt..fini..rodata\n  0x000000b0 002e6568 5f667261 6d655f68 6472002e ..eh_frame_hdr..\n  0x000000c0 65685f66 72616d65 002e696e 69745f61 eh_frame..init_a\n  0x000000d0 72726179 002e6669 6e695f61 72726179 rray..fini_array\n  0x000000e0 002e6a63 72002e64 796e616d 6963002e ..jcr..dynamic..\n  0x000000f0 676f742e 706c7400 2e646174 61002e62 got.plt..data..b\n  0x00000100 7373002e 636f6d6d 656e7400          ss..comment.\n```", "```\ntypedef struct {\n  uint32_t  sh_name;       /* Section name (string tbl index)   */\n  uint32_t  sh_type;       /* Section type                      */\n  uint64_t  sh_flags;      /* Section flags                     */\n  uint64_t  sh_addr;       /* Section virtual addr at execution */\n  uint64_t  sh_offset;     /* Section file offset               */\n  uint64_t  sh_size;       /* Section size in bytes             */\n  uint32_t  sh_link;       /* Link to another section           */\n  uint32_t  sh_info;       /* Additional section information    */\n  uint64_t  sh_addralign;  /* Section alignment                 */\n  uint64_t  sh_entsize;    /* Entry size if section holds table */\n} Elf64_Shdr;\n```", "```\n$ readelf --sections --wide a.out\nThere are 31 section headers, starting at offset 0x19e8:\n\nSection Headers:\n  [Nr] Name             Type             Address          Off    Size   ES  Flg Lk Inf Al\n  [ 0]                 ➊NULL             0000000000000000 000000 000000 00      0  0  0\n  [ 1] .interp          PROGBITS         0000000000400238 000238 00001c 00     A  0  0  1\n  [ 2] .note.ABI-tag    NOTE             0000000000400254 000254 000020 00     A  0  0  4\n [ 3] .note.gnu.build-id NOTE           0000000000400274 000274 000024 00     A  0  0  4\n  [ 4] .gnu.hash        GNU_HASH        0000000000400298 000298 00001c 00     A  5  0  8\n  [ 5] .dynsym          DYNSYM          00000000004002b8 0002b8 000060 18     A  6  1  8\n  [ 6] .dynstr          STRTAB          0000000000400318 000318 00003d 00     A  0  0  1\n  [ 7] .gnu.version     VERSYM          0000000000400356 000356 000008 02     A  5  0  2\n  [ 8] .gnu.version_r   VERNEED         0000000000400360 000360 000020 00     A  6  1  8\n  [ 9] .rela.dyn        RELA            0000000000400380 000380 000018 18     A  5  0  8\n  [10] .rela.plt        RELA            0000000000400398 000398 000030 18    AI  5 24  8\n  [11] .init            PROGBITS        00000000004003c8 0003c8 00001a 00  ➋AX  0  0  4\n  [12] .plt             PROGBITS        00000000004003f0 0003f0 000030 10    AX  0  0 16\n  [13] .plt.got         PROGBITS        0000000000400420 000420 000008 00    AX  0  0  8\n  [14] .text           ➌PROGBITS        0000000000400430 000430 000192 00  ➍AX  0  0 16\n  [15] .fini            PROGBITS        00000000004005c4 0005c4 000009 00    AX  0  0  4\n  [16] .rodata          PROGBITS        00000000004005d0 0005d0 000011 00     A  0  0  4\n  [17] .eh_frame_hdr    PROGBITS        00000000004005e4 0005e4 000034 00     A  0  0  4\n  [18] .eh_frame        PROGBITS        0000000000400618 000618 0000f4 00     A  0  0  8\n  [19] .init_array      INIT_ARRAY      0000000000600e10 000e10 000008 00    WA  0  0  8\n  [20] .fini_array      FINI_ARRAY      0000000000600e18 000e18 000008 00    WA  0  0  8\n  [21] .jcr             PROGBITS        0000000000600e20 000e20 000008 00    WA  0  0  8\n  [22] .dynamic         DYNAMIC         0000000000600e28 000e28 0001d0 10    WA  6  0  8\n  [23] .got             PROGBITS        0000000000600ff8 000ff8 000008 08    WA  0  0  8\n  [24] .got.plt         PROGBITS        0000000000601000 001000 000028 08    WA  0  0  8\n  [25] .data            PROGBITS        0000000000601028 001028 000010 00    WA  0  0  8\n  [26] .bss             NOBITS          0000000000601038 001038 000008 00    WA  0  0  1\n  [27] .comment         PROGBITS        0000000000000000 001038 000034 01    MS  0  0  1\n  [28] .shstrtab        STRTAB          0000000000000000 0018da 00010c 00        0  0  1\n  [29] .symtab          SYMTAB          0000000000000000 001070 000648 18       30 47  8\n  [30] .strtab          STRTAB          0000000000000000 0016b8 000222 00        0  0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n```", "```\n  $ objdump -M intel -d a.out\n  ...\n\n  Disassembly of section .text:\n\n➊ 0000000000400430 <_start>:\n    400430: 31 ed                   xor    ebp,ebp\n    400432: 49 89 d1                mov    r9,rdx\n    400435: 5e                      pop    rsi\n    400436: 48 89 e2                       mov  rdx,rsp\n    400439: 48 83 e4 f0                    and  rsp,0xfffffffffffffff0\n    40043d: 50                             push rax\n    40043e: 54                             push rsp\n    40043f: 49 c7 c0 c0 05 40 00    mov    r8,0x4005c0\n    400446: 48 c7 c1 50 05 40 00    mov    rcx,0x400550\n    40044d: 48 c7 c7 26 05 40 00    mov  ➋rdi,0x400526\n    400454: e8 b7 ff ff ff          call   400410 ➌<__libc_start_main@plt>\n    400459: f4                      hlt\n    40045a: 66 0f 1f 44 00 00       nop    WORD PTR [rax+rax*1+0x0]\n  ...\n\n➍ 0000000000400526 <main>:\n    400526: 55                             push   rbp\n    400527: 48 89 e5                       mov    rbp,rsp\n    40052a: 48 83 ec 10                    sub    rsp,0x10\n    40052e: 89 7d fc                       mov    DWORD PTR [rbp-0x4],edi\n    400531: 48 89 75 f0                    mov    QWORD PTR [rbp-0x10],rsi\n    400535: bf d4 05 40 00                 mov    edi,0x4005d4\n    40053a: e8 c1 fe ff ff                 call   400400 <puts@plt>\n    40053f: b8 00 00 00 00                 mov    eax,0x0\n    400544: c9                             leave\n    400545: c3                             ret\n    400546: 66 2e 0f 1f 84 00 00           nop    WORD PTR cs:[rax+rax*1+0x0]\n    40054d: 00 00 00\n...\n```", "```\n  $ objdump -M intel --section .plt -d a.out\n\n  a.out:        file format elf64-x86-64\n\n  Disassembly of section .plt:\n\n➊ 00000000004003f0 <puts@plt-0x10>:\n   4003f0: push QWORD PTR [rip+0x200c12] # 601008 <_GLOBAL_OFFSET_TABLE_+0x8>\n   4003f6: jmp  QWORD PTR [rip+0x200c14] # 601010 <_GLOBAL_OFFSET_TABLE_+0x10>\n 4003fc: nop  DWORD PTR [rax+0x0]\n\n➋ 0000000000400400 <puts@plt>:\n   400400: jmp  QWORD PTR [rip+0x200c12] # 601018 <_GLOBAL_OFFSET_TABLE_+0x18>\n   400406: push ➌0x0\n   40040b: jmp  4003f0 <_init+0x28>\n\n➍ 0000000000400410 <__libc_start_main@plt>:\n   400410: jmp  QWORD PTR [rip+0x200c0a] # 601020 <_GLOBAL_OFFSET_TABLE_+0x20>\n   400416: push ➎0x1\n   40041b: jmp  4003f0 <_init+0x28>\n```", "```\n   $ readelf --relocs a.out\n\n   Relocation section '.rela.dyn' at offset 0x380 contains 1 entries:\n    Offset       Info           Type           Sym. Value    Sym. Name + Addend\n➊ 0000600ff8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0\n\n   Relocation section '.rela.plt' at offset 0x398 contains 2 entries:\n    Offset       Info           Type           Sym. Value    Sym. Name + Addend\n➋ 0000601018 000100000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0\n➌ 0000601020 000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0\n```", "```\n   $ readelf --dynamic a.out\n\n   Dynamic section at offset 0xe28 contains 24 entries:\n     Tag                Type                 Name/Value\n➊ 0x0000000000000001  (NEEDED)             Shared library: [libc.so.6]\n   0x000000000000000c  (INIT)               0x4003c8\n   0x000000000000000d  (FINI)               0x4005c4\n   0x0000000000000019  (INIT_ARRAY)         0x600e10\n   0x000000000000001b  (INIT_ARRAYSZ)       8 (bytes)\n   0x000000000000001a  (FINI_ARRAY)         0x600e18\n   0x000000000000001c  (FINI_ARRAYSZ)       8 (bytes)\n   0x000000006ffffef5  (GNU_HASH)           0x400298\n   0x0000000000000005  (STRTAB)             0x400318\n   0x0000000000000006  (SYMTAB)             0x4002b8\n   0x000000000000000a  (STRSZ)              61 (bytes)\n   0x000000000000000b  (SYMENT)             24 (bytes)\n   0x0000000000000015  (DEBUG)              0x0\n   0x0000000000000003  (PLTGOT)             0x601000\n   0x0000000000000002  (PLTRELSZ)           48 (bytes)\n   0x0000000000000014  (PLTREL)             RELA\n   0x0000000000000017  (JMPREL)             0x400398\n   0x0000000000000007  (RELA)               0x400380\n   0x0000000000000008  (RELASZ)             24 (bytes)\n   0x0000000000000009  (RELAENT)            24 (bytes)\n➋ 0x000000006ffffffe  (VERNEED)            0x400360\n➌ 0x000000006fffffff  (VERNEEDNUM)         1\n   0x000000006ffffff0  (VERSYM)             0x400356\n   0x0000000000000000  (NULL)               0x0\n```", "```\n➊ $ objdump -d --section .init_array a.out\n\n  a.out:      file format elf64-x86-64\n\n  Disassembly of section .init_array:\n\n  0000000000600e10 <__frame_dummy_init_array_entry>:\n    600e10:  ➋00 05 40 00 00 00 00 00 ..@.....\n\n➌ $ objdump -d a.out | grep '<frame_dummy>'\n  0000000000400500 <frame_dummy>:\n```", "```\ntypedef struct {\n  uint32_t  p_type;   /* Segment type             */\n  uint32_t  p_flags;  /* Segment flags            */\n  uint64_t  p_offset; /* Segment file offset      */\n  uint64_t  p_vaddr;  /* Segment virtual address  */\n  uint64_t  p_paddr;  /* Segment physical address */\n  uint64_t  p_filesz; /* Segment size in file     */\n  uint64_t  p_memsz;  /* Segment size in memory   */\n  uint64_t  p_align;  /* Segment alignment        */\n} Elf64_Phdr;\n```", "```\n $ readelf --wide --segments a.out\n\n Elf file type is EXEC (Executable file)\n Entry point 0x400430\n There are 9 program headers, starting at offset 64\n\n Program Headers:\n   Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n   PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R E 0x8\n   INTERP         0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R   0x1\n       [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]          \n   LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x00070c 0x00070c R E 0x200000\n   LOAD           0x000e10 0x0000000000600e10 0x0000000000600e10 0x000228 0x000230 RW  0x200000\n   DYNAMIC        0x000e28 0x0000000000600e28 0x0000000000600e28 0x0001d0 0x0001d0 RW  0x8\n   NOTE           0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R   0x4\n   GNU_EH_FRAME   0x0005e4 0x00000000004005e4 0x00000000004005e4 0x000034 0x000034 R   0x4\n   GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10\n   GNU_RELRO      0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R   0x1\n\n➊ Section to Segment mapping:\n   Segment Sections...\n    00\n    01     .interp\n    02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version\n           .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata\n           .eh_frame_hdr .eh_frame\n    03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss\n    04     .dynamic\n    05     .note.ABI-tag .note.gnu.build-id\n    06     .eh_frame_hdr\n    07\n    08     .init_array .fini_array .jcr .dynamic .got\n```"]