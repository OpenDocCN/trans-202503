- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CARRIAGE RETURN LINE FEED INJECTION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some vulnerabilities allow users to input encoded characters that have special
    meanings in HTML and HTTP responses. Normally, applications sanitize these characters
    when they are included in user input to prevent attackers from maliciously manipulating
    HTTP messages, but in some cases, applications either forget to sanitize input
    or fail to do so properly. When this happens, servers, proxies, and browsers may
    interpret the special characters as code and alter the original HTTP message,
    allowing attackers to manipulate an application’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Two examples of encoded characters are `%0D` and `%0A`, which represent `\n`
    (a carriage return) and `\r` (a line feed). These encoded characters are commonly
    referred to as *carriage return line feeds (CRLFs)*. Servers and browsers rely
    on CRLF characters to identify sections of HTTP messages, such as headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *carriage return line feed injection (CRLF injection)* vulnerability occurs
    when an application doesn’t sanitize user input or does so improperly. If attackers
    can inject CRLF characters into HTTP messages, they can achieve the two types
    of attacks we’ll discuss in this chapter: HTTP request smuggling and HTTP response
    splitting attacks. Additionally, you can usually chain a CRLF injection with another
    vulnerability to demonstrate a greater impact in a bug report, as I’ll demonstrate
    later in the chapter. For the purpose of this book, we’ll only provide examples
    of how to exploit a CRLF injection to achieve HTTP request smuggling.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Request Smuggling**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*HTTP request smuggling* occurs when an attacker exploits a CRLF injection
    vulnerability to append a second HTTP request to the initial, legitimate request.
    Because the application does not anticipate the injected CRLF, it initially treats
    the two requests as a single request. The request is passed through the receiving
    server (typically a proxy or firewall), processed, and then sent on to another
    server, such as an application server that performs the actions on behalf of the
    site. This type of vulnerability can result in cache poisoning, firewall evasion,
    request hijacking, or HTTP response splitting.'
  prefs: []
  type: TYPE_NORMAL
- en: In *cache poisoning*, an attacker can change entries in an application’s cache
    and serve malicious pages instead of a proper page. *Firewall evasion* occurs
    when a request is crafted using CRLFs to avoid security checks. In a *request-hijacking*
    situation, an attacker can steal `httponly` cookies and HTTP authentication information
    with no interaction between the attacker and client. These attacks work because
    servers interpret CRLF characters as indicators of where HTTP headers start, so
    if they see another header, they interpret it as the start of a new HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP response splitting*, which we’ll focus on in the rest of this chapter,
    allows an attacker to split a single HTTP response by injecting new headers that
    browsers interpret. An attacker can exploit a split HTTP response using one of
    two methods depending on the nature of the vulnerability. Using the first method,
    an attacker uses CRLF characters to complete the initial server response and insert
    additional headers to generate a new HTTP response. However, sometimes an attacker
    can only modify a response and not inject a completely new HTTP response. For
    example, they can only inject a limited number of characters. This leads to the
    second method of exploiting response splitting, inserting new HTTP response headers,
    such as a `Location` header. Injecting a `Location` header would allow an attacker
    to chain the CRLF vulnerability with a redirect, sending a target to a malicious
    website, or cross-site scripting (XSS), an attack we’ll cover in [Chapter 7](ch07.xhtml#ch07).'
  prefs: []
  type: TYPE_NORMAL
- en: '**v.shopify.com Response Splitting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *v.shopify.com/last_shop?<YOURSITE>.myshopify.com*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/106427/](https://hackerone.com/reports/106427/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** December 22, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: 'In December 2015, HackerOne user krankopwnz reported that Shopify wasn’t validating
    the shop parameter passed into the URL *v.shopify.com/last_shop?<YOURSITE>.myshopify.com*.
    Shopify sent a `GET` request to this URL in order to set a cookie that recorded
    the last store a user had logged in to. As a result, an attacker could include
    the CRLF characters `%0d%0a` (capitalization doesn’t matter to encoding) in the
    URL as part of the `last_shop` parameter. When these characters were submitted,
    Shopify would use the full `last_shop` parameter to generate new headers in the
    HTTP response. Here is the malicious code krankopwnz injected as part of a shop
    name to test whether this exploit would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because Shopify used the unsanitized `last_shop` parameter to set a cookie in
    the HTTP response, the response included content that the browser interpreted
    as two responses. The `%20` characters represent encoded spaces, which are decoded
    when the response is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response received by the browser was decoded to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the response would appear after the original HTTP headers.
    The content length of the original response is declared as `0` ➊, which tells
    the browser no content is in the response body. Next, a CRLF starts a new line
    and new headers. The text sets up the new header information to tell the browser
    there is a second response that is HTML and that its length is `19`. Then the
    header information gives the browser HTML to render at ➋. When a malicious attacker
    uses the injected HTTP header, a variety of vulnerabilities are possible; these
    include XSS, which we will cover in [Chapter 7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Be on the lookout for opportunities where a site accepts input that it uses
    as part of its return headers, particularly when it’s setting cookies. If you
    see this behavior on a site, try submitting `%0D%0A` (or just `%0A%20` in Internet
    Explorer) to check whether the site is properly protecting against CRLF injections.
    If it isn’t, test to see whether you’re able to add new headers or an entire additional
    HTTP response. This vulnerability is best exploited when it occurs with little
    user interaction, such as in a `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter HTTP Response Splitting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://twitter.com/i/safety/report_story/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/52042/](https://hackerone.com/reports/52042/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** March 15, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $3,500'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re looking for vulnerabilities, remember to think outside the box and
    submit encoded values to see how a site handles the input. In some cases, sites
    will protect against CRLF injection by using a blacklist. In other words, the
    site will check for any blacklisted characters in inputs, then respond accordingly
    by removing those characters or not allowing the HTTP request to be made. However,
    an attacker can sometimes circumvent a blacklist by using character encoding.
  prefs: []
  type: TYPE_NORMAL
- en: In March 2015, FileDescriptor manipulated how Twitter handled character encoding
    to find a vulnerability that allowed him to set a cookie through an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP request that FileDescriptor tested included a `reported_tweet_id` parameter
    when sent to *https://twitter.com/i/safety/report_story/* (a Twitter relic that
    allowed users to report inappropriate ads). When responding, Twitter would also
    return a cookie that included the parameter submitted with the HTTP request. During
    his tests, FileDescriptor noted that the CR and LF characters were blacklisted
    and sanitized. Twitter would replace any LFs with a space and send back an HTTP
    400 (Bad Request Error) when it received any CRs, thus protecting against CRLF
    injections. But FileDescriptor knew of a Firefox bug that incorrectly decoded
    cookies and potentially could allow users to inject malicious payloads to a website.
    The knowledge of this bug led him to test whether a similar bug could exist on
    Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: In the Firefox bug, Firefox would strip any Unicode characters in cookies outside
    of the ASCII character range. However, Unicode characters can consist of multiple
    bytes. If certain bytes in a multibyte character were stripped, the remaining
    bytes could result in malicious characters being rendered on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by the Firefox bug, FileDescriptor tested whether an attacker could
    sneak a malicious character through Twitter’s blacklist using the same multibyte
    character technique. So FileDescriptor found a Unicode character whose encoding
    ended with `%0A` (a LF) but whose other bytes were not included in the HTTP character
    set. He used the Unicode character ![Image](../images/f0053-01.jpg), which is
    hex encoded as U+560A (`56 0A`). But when this character is used in a URL, it
    is URL encoded with UTF-8 as `%E5%98%8A`. These three bytes, `%E3`, `%98`, `%8A`,
    circumvented Twitter’s blacklist because they are not malicious characters.
  prefs: []
  type: TYPE_NORMAL
- en: When FileDescriptor submitted this value, he found that Twitter wouldn’t sanitize
    the URL-encoded character but would still decode the UTF-8 `%E5%98%8A` value back
    to its Unicode value `56 0A`. Twitter would drop the `56` as an invalid character,
    leaving the line feed characters `0A` untouched. In addition, he found that the
    character ![Image](../images/f0053-02.jpg) (which is encoded to `56 0D`) could
    be used to insert the necessary carriage return (`%0D`) into the HTTP response
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once he confirmed that the method worked, FileDescriptor passed the value `%E5%98%8A%E5%98%8DSet-Cookie:%20test`
    into Twitter’s URL parameter. Twitter would decode the characters, strip the out-of-range
    characters, and leave `%0A` and `%0D` in the HTTP request, resulting in the value
    `%0A%0DSet-Cookie:%20test`. The CRLF would split the HTTP response into two so
    the second response would consist of just the `Set-Cookie: test` value, which
    is the HTTP header used to set cookies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CRLF attacks can be even more dangerous when they allow for XSS attacks. While
    the details of exploiting XSS aren’t important for this example, it should be
    noted that FileDescriptor went further with this proof of concept. He demonstrated
    to Twitter how this CRLF vulnerability could be exploited to execute malicious
    JavaScript with the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The important details are the 3-byte values peppered throughout: `%E5%98%8A`,
    `%E5%98%8D`, `%E5%98%BC`, and `%E5%98%BE`. After character stripping, these values
    are decoded to `%0A`, `%0D`, `%3C`, and `%3E`, respectively, all of which are
    HTML special characters. The byte `%3C` is the left angle bracket (`<`), and `%3E`
    is the right angle bracket (`>`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other characters in the URL are included in the HTTP response as written.
    Therefore, when the encoded byte characters are decoded with line breaks, the
    header looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The payload is decoded to inject the header `content-type text/html`, which
    tells the browser the response will contain HTML. The `Location` header uses a
    `<svg>` tag to execute the JavaScript code `alert(innerHTML)`. The alert creates
    an alert box that contains the contents of the web page using the DOM `innerHTML`
    property (the `innerHTML` property returns the HTML of a given element). In this
    case, the alert would include the logged-in user’s session and authentication
    cookies, demonstrating that an attacker could steal these values. Stealing the
    authentication cookie would have allowed an attacker to log into a target’s account,
    which explains why FileDescriptor was awarded a $3,500 bounty for finding this
    vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a server is somehow sanitizing the characters `%0D%0A`, think about how the
    website might be doing that and whether you can circumvent its efforts, such as
    through double encoding. You can test whether the site is mishandling extra values
    by passing multibyte characters and determining whether they are decoded into
    other characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CRLF vulnerabilities allow attackers to manipulate HTTP responses by altering
    their headers. Exploiting CRLF vulnerabilities can lead to cache poisoning, firewall
    evasion, request hijacking, or HTTP response splitting. Because a CRLF vulnerability
    is caused by a site reflecting back the unsanitized user input `%0D%0A` in its
    headers, it’s important to monitor and review all HTTP responses when hacking.
    Additionally, if you do find input you can control being returned in HTTP headers,
    but the characters `%0D%0A` are being sanitized, try including multibyte-encoded
    input as FileDescriptor did to determine how the site handles decoding it.
  prefs: []
  type: TYPE_NORMAL
