- en: '**12**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**STAYING HIDDEN**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Game hacking is an ever-evolving practice, a game of cat and mouse between hackers
    and game developers where each party works to subvert the other. As long as people
    make bots, game companies will find ways to hinder bot advances and ban players
    who use bots. Rather than making their games inherently harder to hack, though,
    game companies focus on *detection*.
  prefs: []
  type: TYPE_NORMAL
- en: The largest game companies have very sophisticated detection suites called *anti-cheat
    software*. In the beginning of this chapter, I’ll discuss the capabilities of
    the most common anti-cheat suites. After revealing how these suites detect bots,
    I’ll teach you some powerful ways to evade them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prominent Anti-Cheat Software**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best-known anti-cheat suites use the same methods as most antivirus software
    to scan for bots and flag them as threats. Some anti-cheat suites are also dynamic,
    meaning their inner workings and capabilities can change based on the game they’re
    protecting. Anti-cheat software developers also track down and patch their suites
    against bypass software, so always do your own in-depth research of any anti-cheat
    software that you might face.
  prefs: []
  type: TYPE_NORMAL
- en: When these suites detect a botter, they flag the botter’s account for banishment.
    Every few weeks, game company administrators ban the flagged players in a *ban
    wave*. Game companies use ban waves instead of instantaneous bans because banning
    in waves is more profitable. If botters are banned after a few weeks of playing,
    their familiarity with the game will make them more likely to buy a new account
    than if they were banned the moment their bot started running.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are dozens of anti-cheat suites, but I’ll focus on the five packages
    that are the most common and thoroughly understood: *PunkBuster*, *ESEA Anti-Cheat*,
    *Valve Anti-Cheat (VAC)*, *GameGuard*, and *Warden*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The PunkBuster Toolkit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PunkBuster, made by Even Balance Inc., is the original anti-cheat toolkit. Many
    games use PunkBuster, but it’s most common in first-person shooter games like
    *Medal of Honor*, *Far Cry 3*, and several installments of the *Battlefield* series.
  prefs: []
  type: TYPE_NORMAL
- en: The toolkit uses a myriad of detection methods, the most formidable of which
    are signature-based detection (SBD), screenshots, and hash validation. PunkBuster
    is also known for imposing hardware bans that permanently ban a cheater’s computer,
    rather than just their game account, by saving a fingerprint of the hardware’s
    serial numbers and blocking logins from a machine that matches it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Signature-Based Detection***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PunkBuster scans the memory of all processes on a system running a game that
    employs it, searching for byte patterns unique to known cheat software, called
    *signatures*. If PunkBuster detects a signature, the player is flagged for a ban.
    PunkBuster carries out memory scans from user mode using the `NtQueryVirtualMemory()`
    Windows API function, and it sometimes runs scans from multiple hidden processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signature-based detection is blind to context by design, and it ultimately
    suffers from a fatal flaw: false positives. On March 23, 2008, a team of hackers
    set out to prove the existence of this flaw by spamming public chatrooms with
    a text string that PunkBuster would identify as a bot signature. Since SBD blindly
    scans process memory for matching patterns, any and all legitimate players inside
    these public chatrooms were flagged as botters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This caused thousands of fair players to be banned with no justification. A
    similar situation happened again in November 2013: PunkBuster falsely banned thousands
    of players on *Battlefield 4*. That time, no one was trying to prove a point;
    the company had just added a bad signature to its software.'
  prefs: []
  type: TYPE_NORMAL
- en: PunkBuster resolved both of these issues by restoring the players’ accounts,
    but these incidents show just how aggressive its flavor of SBD is. In the time
    since these attacks, though, PunkBuster’s SBD has reduced the number of false
    positives by checking only for signatures at predefined binary offsets.
  prefs: []
  type: TYPE_NORMAL
- en: '***Screenshots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As another method of bot detection, PunkBuster also periodically takes screenshots
    of a player’s screen and sends them to the central game server. This form of detection
    is a nuisance, and it’s weak compared to SDB. Game-hacking communities speculate
    that PunkBuster implemented this feature to give game admins proof against botters
    who dispute bans.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hash Validation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to employing SBD and screenshots, PunkBuster detects bots by creating
    cryptographic hashes of a game’s executable binaries on a player’s system and
    comparing them to hashes stored on a central server. If the hashes do not match,
    the player is flagged for a ban. This check is carried out only on the binaries
    on the filesystem, not on in-memory binaries.
  prefs: []
  type: TYPE_NORMAL
- en: '**The ESEA Anti-Cheat Toolkit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ESEA Anti-Cheat toolkit is used by the *E-Sports Entertainment Association
    (ESEA)*, primarily for its *Counter-Strike: Global Offensive* league. Unlike PunkBuster,
    this suite is known for generating very few false positives and being highly effective
    at catching cheaters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ESEA Anti-Cheat’s detection capabilities resemble those of PunkBuster, with
    one noteworthy difference. ESEA Anti-Cheat’s SBD algorithm is carried out from
    a kernel-mode driver using three different Windows Kernel functions: the `MmGetPhysicalMemoryRanges()`
    function, the `ZwOpenSection()` function, and the `ZwMapViewOfSection()` function.
    This implementation makes the anti-cheat system nearly immune to memory spoofing
    (a common way to defeat SBD), as the functions used by the scan are much harder
    to hook when they’re called from a driver.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The VAC Toolkit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VAC is the toolkit Valve Corporation applies to its own games and many of the
    third-party games available on its Steam gaming platform. VAC uses SDB and hash
    validation methods that resemble PunkBuster’s detection techniques, and it also
    uses Domain Name System (DNS) cache scans and binary validation.
  prefs: []
  type: TYPE_NORMAL
- en: '***DNS Cache Scans***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: DNS is a protocol that converts between domain names and IP addresses smoothly,
    and the DNS cache is where that information gets stored on a computer. When VAC’s
    SBD algorithm detects cheat software, VAC scans the player’s DNS cache for any
    domain names associated with cheating websites. It’s not certain whether a positive
    DNS cache scan is required for VAC’s SBD algorithm to flag a player for banishment,
    or if the DNS cache scan simply acts as another nail in the coffin for players
    who are already flagged by SBD.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To see your DNS cache, enter **`ipconfig /displaydns`** at a command prompt.
    Yes, VAC looks at all of that.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Binary Validation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: VAC also uses binary validation to prevent in-memory tampering of executable
    binaries. It scans for modifications like IAT, jump, and code hooking by comparing
    hashes of in-memory binary code to hashes of the same code in the binaries on
    the filesystem. If it finds a mismatch, VAC flags the player for a ban.
  prefs: []
  type: TYPE_NORMAL
- en: This detection method is formidable, but Valve’s initial implementation of the
    algorithm was flawed. In July 2010, VAC’s binary validation falsely banned 12,000
    *Call of Duty* players. The binary validation module failed to account for a Steam
    update, and it banned the players when their in-memory code did not match the
    updated binaries on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '***False Positives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: VAC has had other issues with false positives. Its initial release routinely
    banned fair players for “faulty memory.” This same early version banned players
    for using *Cedega*, a platform that ran Windows games on Linux. And on April 1,
    2004, Valve falsely banned a couple thousand players due to a server-side glitch.
    On two separate occasions, one in June 2011 and one in February 2014, VAC also
    falsely banned thousands of *Team Fortress 2* and *Counter-Strike* players due
    to bugs that the company refuses to disclose. As with PunkBuster, these incidents
    show that VAC is very aggressive.
  prefs: []
  type: TYPE_NORMAL
- en: '**The GameGuard Toolkit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GameGuard is an anti-cheat toolkit made by INCA Internet Co. Ltd. and used by
    many MMORPGs, including *Lineage II*, *Cabal Online*, and *Ragnarok Online*. In
    addition to some mildly aggressive SBD, GameGuard uses rootkits to proactively
    prevent cheat software from running.
  prefs: []
  type: TYPE_NORMAL
- en: '***User-Mode Rootkit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GameGuard utilizes a user-mode rootkit to deny bots access to the Windows API
    functions they use to operate. The rootkit hooks the functions at their lowest-level
    entry point, often inside undocumented functions in *ntdll.dll*, *user32.dll*,
    and *kernel32.dll*. These are the most notable API functions GameGuard hooks,
    and here’s what GameGuard does from inside each hooked function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NtOpenProcess()` Blocks any `OpenProcess()` attempts on the game being protected.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NtProtectVirtualMemory()` Blocks any `VirtualProtect()` or `VirtualProtectEx()`
    attempts on the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NtReadVirtualMemory()` **and** `NtWriteVirtualMemory()` Block any `ReadProcessMemory()`
    and `WriteProcessMemory()` attempts on the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NtSuspendProcess()` **and** `NtSuspendThread()` Block any attempts to suspend
    GameGuard.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NtTerminateProcess()` **and** `NtTerminateThread()` Block any attempts to
    terminate GameGuard.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostMessage()`, `SendMessage()`**, and** `SendInput()` Block any attempts
    to send programmatic input to the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetWindowsHookEx()` Prevents bots from globally intercepting mouse and keyboard
    input.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateProcessInternal()` Automatically detects and hooks into new processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetProcAddress()`, `LoadLibraryEx()`**, and** `MapViewOfFileEx()` Prevent
    any attempt to inject libraries into the game or GameGuard.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel-Mode Rootkit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GameGuard also uses a driver-based rootkit to prevent bots that work in the
    kernel. This rootkit has the same abilities as its user-mode counterpart, and
    it works by hooking `ZwProtectVirtualMemory()`, `ZwReadVirtualMemory()`, `ZwWriteVirtualMemory()`,
    `SendInput()`, and similar functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Warden Toolkit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Warden, made exclusively for Blizzard’s games, is by far the most advanced
    anti-bot toolkit I’ve encountered. It’s hard to say what exactly Warden does,
    because it downloads dynamic code at runtime. This code, delivered as compiled
    shellcode, typically has two responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: • Detect bots.
  prefs: []
  type: TYPE_NORMAL
- en: • Periodically send a heartbeat signal to the game server. The value sent is
    not predefined but instead is generated by some subset of the detection code.
  prefs: []
  type: TYPE_NORMAL
- en: If Warden fails to complete the second task or sends the wrong value, the game
    server will know that it’s been disabled or tampered with. Furthermore, a bot
    can’t disable the detection code and leave the heartbeat code running.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE HALTING PROBLEM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bot that could disable Warden’s detection code and still send the heartbeat
    signal would solve the *halting problem*, which Alan Turing proved to be impossible
    in 1936\. The halting problem is the problem of determining, with a generic algorithm,
    whether a program will finish running or continue forever. Because Warden does
    two tasks using the same shellcode, writing a generic algorithm that can disable
    just one task is a variation of the halting problem: the algorithm can’t be sure
    which parts of the code will definitely execute, which parts won’t, and which
    parts are responsible for each task.'
  prefs: []
  type: TYPE_NORMAL
- en: Warden is formidable because you not only have no way to know what you’re hiding
    from but also have no way to disable the toolkit. Even if you manage to avoid
    detection today, a new detection method might be used tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan on publicly distributing bots, you will eventually meet one of the
    anti-cheat solutions described in the previous sections—and you’ll have to beat
    it. Depending on your bot’s footprint, the type of detection in the game you’re
    botting, and your implementation, the difficulty of evading one of these toolkits
    can range from trivial to extremely hard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Carefully Managing a Bot’s Footprint**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A bot’s *footprint* is how many unique, detectable characteristics it has. For
    example, a bot that hooks 100 functions will typically be easier to detect than
    a bot that hooks only 10 functions because the former makes an order of magnitude
    more changes to a game’s code than the latter. Since a targeted detection system
    needs to detect only one hook, the developer of the former bot needs to spend
    much more time making sure all of the bot’s hooks are as stealthy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Another footprint characteristic is how detailed a bot’s user interface is.
    If a known bot has many dialog boxes that all have specific titles, a game company
    can just have its anti-cheat software detect the bot by searching for windows
    that have those titles. This same basic reasoning can be used with process names
    and filenames.
  prefs: []
  type: TYPE_NORMAL
- en: '***Minimizing a Bot’s Footprint***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on how your bot works, there are many ways to minimize its footprint.
    If your bot relies heavily on hooks, for instance, you can avoid directly hooking
    a game’s code and instead focus on hooking Windows API functions. Windows API
    hooking is surprisingly common, so developers can’t assume a program that hooks
    the Windows API is a bot.
  prefs: []
  type: TYPE_NORMAL
- en: If your bot has a well-defined user interface, you can mask the interface by
    removing all strings from window bars, buttons, and so on. Instead, display images
    that show text. If you’re worried about specific process names or filenames being
    detected by the anti-cheat software, use generic filenames and make your bot copy
    itself to a new, randomized directory every time it launches.
  prefs: []
  type: TYPE_NORMAL
- en: '***Masking Your Footprint***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Minimizing your footprint is a preferred way to avoid detection, but it’s not
    necessary. You can also obfuscate your bot, making it harder for anyone to figure
    out how it works. Obfuscation can prevent both anti-bot developers from trying
    to detect your bot and other bot developers from analyzing your bot to steal proprietary
    functionality. If you sell your bot, obfuscation prevents people from cracking
    it to bypass your purchase verification, too.
  prefs: []
  type: TYPE_NORMAL
- en: One common type of obfuscation is called *packing*. Packing an executable encrypts
    it and hides it inside another executable. When the container executable is launched,
    the packed executable is decrypted and executed in-memory. When a bot is packed,
    analyzing the binary to learn what the bot does is impossible, and debugging the
    bot process is much harder. Some common packer programs are *UPX*, *Armadillo*,
    *Themida*, and *ASPack*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Teaching a Bot to Detect Debuggers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When anti-bot developers (or other bot creators) can debug a bot, they can figure
    out how it works and thus how to stop it. If someone is actively trying to pick
    apart a bot, packing the executable may not be enough to evade them. To protect
    against this, bots often employ *anti-debugging* techniques, which obfuscate control
    flow by changing the bot’s behavior when a debugger is detected. In this section,
    I’ll quickly cover some well-known methods for detecting when a debugger is attached
    to your bot, and in the next, I’ll show you some tricks for obfuscation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling CheckRemoteDebuggerPresent()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`CheckRemoteDebuggerPresent()` is a Windows API function that can tell you
    if a debugger is attached to the current process. Code to check for a debugger
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This check is pretty straightforward—it calls `CheckRemoteDebuggerPresent()`
    with the current process and a pointer to the `dbg` Boolean. Calling this function
    is the easiest way to detect a debugger, but it’s also very easy for a debugger
    to evade.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for Interrupt Handlers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Interrupts* are signals the processor sends to trigger a corresponding handler
    in the Windows kernel. Interrupts are typically generated by hardware events,
    but they can also be generated in software using the INT assembly instruction.
    The kernel allows some interrupts—namely, interrupts 0x2D and 0x03—to trigger
    user-mode interrupt handlers in the form of exception handlers. You can take advantage
    of these interrupts to detect debuggers.'
  prefs: []
  type: TYPE_NORMAL
- en: When a debugger sets a breakpoint on an instruction, it replaces that instruction
    with a breakpoint instruction, such as INT 0x03\. When the interrupt is executed,
    the debugger is notified via an exception handler, where it handles the breakpoint,
    replaces the original code, and allows the application to resume execution seamlessly.
    When faced with an unrecognized interrupt, some debuggers even silently step over
    that interrupt and allow execution to continue normally, without triggering any
    other exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: You can detect this behavior by purposely generating interrupts within exception
    handlers in your code, as shown in [Listing 12-1](ch12.xhtml#ch12exe1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: Detecting interrupt handlers*'
  prefs: []
  type: TYPE_NORMAL
- en: During normal execution, these interrupts trigger the exception handlers surrounding
    them in the code. During a debugging session, some debuggers might intercept the
    exceptions generated by these interrupts and silently ignore them, preventing
    the surrounding exception handlers from executing. Thus, if the interrupts don’t
    trigger your exception handler, then a debugger is present.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for Hardware Breakpoints**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Debuggers can also set breakpoints using the processor’s debug registers; these
    are called *hardware breakpoints*. A debugger can set a hardware breakpoint on
    an instruction by writing the address of the instruction to one of the four debug
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an address present on a debug register is executed, the debugger is notified.
    To detect hardware breakpoints (and thus, the presence of a debugger), you can
    check for nonzero values on any of the four debug registers like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Printing Debug Strings**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`OutputDebugString()` is a Windows API function that can be used to print log
    messages to a debugger console. If no debugger is present, the function will return
    with an error code. If a debugger is present, however, the function will return
    with no error code. Here’s how you can use this function as a trivial debugger
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like the `CheckRemoteDebuggerPresent()` method, this method is very straightforward
    but also very easy for a debugger to evade.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for DBG_RIPEXCEPTION Handlers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Debuggers typically have exception handlers that blindly catch exceptions with
    Windows’ `DBG_RIPEXCEPTION` exception code, making that code a clear way to spot
    a debugger. You can detect these exception handlers in much the same way [Listing
    12-1](ch12.xhtml#ch12exe1) detects interrupt handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Timing Control-Critical Routines**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If an anti-bot developer is debugging your bot, the developer will likely place
    breakpoints on and single-step through parts of your code that are critical to
    the bot’s behavior. You can detect this activity by measuring code execution times;
    when someone steps through code, execution takes a lot longer than usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a function only places some hooks, you can be sure that the
    code shouldn’t take more than a tenth of a second to do the memory protection.
    You could check the execution time for memory protection with help from the `GetTickCount()`
    Windows API function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Checking for Debug Drivers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some debuggers load kernel-mode drivers to assist their operation. You can
    detect these debuggers by attempting to get a handle to their kernel-mode drivers,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are a few common kernel-mode driver device names to check for, like `\\\\.\\EXTREM`
    and the others shown in the `drivers` array. If this handle-fetching code succeeds,
    then there’s a debugger running on the system. Unlike with the previous methods,
    though, obtaining a handle to one of those drivers doesn’t always mean the debugger
    is attached to your bot.
  prefs: []
  type: TYPE_NORMAL
- en: '***Anti-Debugging Techniques***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you detect a debugger, there are multiple ways to obfuscate your control
    flow. For instance, you might try to crash the debugger. The following code crashes
    OllyDbg v1.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The string `"%s%s%s%s"` contains format specifiers, and OllyDbg passes it to
    `printf()` without any extra parameters, which is why the debugger crashes. You
    could place this code in a function that gets called in response to detecting
    a debugger, but this option works only against OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '**Causing an Unavoidable Infinite Loop**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another obfuscation method to try is overloading the system until the person
    debugging your bot is forced to close the bot and debugger. This function does
    the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The infinite `while` loop just keeps adding elements to `explosion` until the
    process runs out of memory or someone pulls the plug.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overflowing the Stack**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want to really confuse the analyst, you can make a chain of functions
    that eventually cause a stack overflow, but in an indirect way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, these functions randomly and infinitely recurse until there’s
    no room left on the call stack. Causing the overflow indirectly makes it hard
    for the analyst to pause and examine previous calls before they realize what’s
    happened.
  prefs: []
  type: TYPE_NORMAL
- en: '**Causing a BSOD**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you’re serious about obfuscation, you can even trigger a Blue Screen of
    Death (BSOD) when you detect a debugger. One way to do that is to set your bot’s
    process as critical using the `SetProcessIsCritical()` Windows API function and
    then call `exit()`, since Windows will trigger a BSOD when a critical process
    is killed. Here’s how you might do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or maybe you’re evil, in which case you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Assuming you’ve implemented all of the techniques described in this section,
    this code would cause a BSOD, crash the debugger (if it’s OllyDbg v1.10), overflow
    the stack, and exit the running program. If any one of the methods fails or gets
    patched, the analyst still has to deal with the remaining ones before they can
    continue debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defeating Signature-Based Detection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even with amazing obfuscation, you won’t easily beat signature detection. Engineers
    who analyze bots and write signatures are very skilled, and obfuscation is, at
    best, a nuisance that makes their job marginally harder.
  prefs: []
  type: TYPE_NORMAL
- en: To completely evade SBD, you need to subvert the detection code. This requires
    knowing exactly how the SBD works. PunkBuster, for instance, uses `NtQueryVirtualMemory()`
    to scan the memory of all running processes for any signatures. If you want to
    bypass this, you can inject code into all PunkBuster processes with a hook on
    the `NtQueryVirtualMemory()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the function tries to query memory from your bot process, you can give
    it whatever data you want, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This `onNtQueryVirtualMemory()` hook returns `STATUS_ACCESS_DENIED` ➊ when `NtQueryVirtualMemory()`
    tries to query the hook DLL’s memory, but it gives zeroed memory ➋ when `NtQueryVirtualMemory()`
    tries to query the bot’s memory. The difference isn’t for any specific reason;
    I’m just showing two ways you can hide from the `NtQueryVirtualMemory()` function
    call. If you’re really paranoid, you can even replace the entire buffer with a
    random byte sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this method works only for SBD that happens from user mode, like
    the SBD in PunkBuster or VAC. SBD that happens from the driver, like ESEA’s, or
    that isn’t predictable, like Warden’s, isn’t as easy to bypass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those cases, you can take precautions to eliminate unique signatures in
    your bot. If you’re distributing the bot to more than a dozen or so people, however,
    removing all distinguishing properties is tricky. To throw analysts off the scent,
    each time you give somebody a copy of the bot, you could try some combination
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Compiling the bot using a different compiler
  prefs: []
  type: TYPE_NORMAL
- en: • Changing the compiler optimization settings
  prefs: []
  type: TYPE_NORMAL
- en: • Toggling between using `__fastcall` and `__cdecl`
  prefs: []
  type: TYPE_NORMAL
- en: • Packing the binaries using a different packer
  prefs: []
  type: TYPE_NORMAL
- en: • Switching between static and dynamic linking of runtime libraries
  prefs: []
  type: TYPE_NORMAL
- en: Varying these elements creates a different assembly for each user, but there’s
    a limit on how many unique versions of the bot you can produce that way. Past
    some point, this method doesn’t scale to demand, and eventually, game companies
    will have signatures for every incarnation of your bot.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from obfuscation and code mutation, there aren’t many ways to defeat advanced
    SBD mechanisms. You could implement your bot in a driver or create a kernel-mode
    rootkit to hide your bot, but even those methods aren’t foolproof.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This book doesn’t cover implementing a bot in a driver or creating a rootkit
    to hide a bot, as both topics are pretty complex. Rootkit development alone is
    a subject that dozens of books have covered already. I’d recommend Bill Blunden’s*
    The Rootkit Arsenal: Escape and Evasion in The Dark Corners of The System *(Jones
    & Bartlett Learning, 2009).*'
  prefs: []
  type: TYPE_NORMAL
- en: Some game hackers try to cover every single base, hooking every memory-reading
    function and the entire filesystem API, but still get caught by determined systems
    like Warden. In fact, I recommend staying away from Warden and Blizzard at all
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defeating Screenshots**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you encounter a detection mechanism that uses screenshots as additional
    proof to nail botters, you’re in luck. Bypassing screenshot mechanisms is easy:
    don’t let your bot be seen.'
  prefs: []
  type: TYPE_NORMAL
- en: You can subvert this type of detection by keeping a minimal UI and making no
    visibly distinguishable changes to the game client. If your bot requires a HUD
    or other distinctive UI displays, though, don’t fret—you can have your cake and
    eat it, too. As long as you can intercept the screenshot code, you can hide your
    fingerprints while a screenshot is taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some versions of PunkBuster, for example, the Windows API function `GetSystemTimeAsFileTime()`
    is called just before a screenshot is taken. You can use a hook on this function
    to quickly hide your UI for a few seconds to ensure it’s not seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Just hook `GetSystemTimeAsFileTime()` using the techniques described in “[Hooking
    to Redirect Game Execution](ch08.xhtml#ch00lev1sec151)” on [page 153](ch08.xhtml#page_153),
    write a `hideUI()` function, and call the `hideUI()` function before execution
    resumes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defeating Binary Validation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defeating binary validation is as simple as not placing hooks inside game-specific
    binaries. Jump hooks and IAT hooks on Windows API functions are extremely common,
    so wherever you can, try to get away with using those methods instead of using
    jump or near-call hooks in a game binary. In cases where you must directly hook
    a game’s code, you can trick the anti-cheat software’s binary validation routines
    by intercepting the binary scan and spoofing the data to match what the software
    expects to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like SBD, binary validation often uses `NtQueryVirtualMemory()` to scan memory.
    To trick the validation code, start with a hook on that function. Then, write
    a function like this one to spoof the data when `NtQueryVirtualMemory()` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Inside this hook, you’ll need to watch for any memory scans over memory that
    has been modified by one of your hooks.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This example assumes the bot has only one hook and that variables prefixed
    with `HOOK_` already exist and describe the code the hook replaces.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-2](ch12.xhtml#ch12exe2) shows some scan-monitoring code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: Checking whether hooked memory is being scanned*'
  prefs: []
  type: TYPE_NORMAL
- en: When a memory scan over the hooked code happens (which makes `currentProcess`
    and `containsHook` become `true` at the same time), code inside the `if()` statement
    ➊ updates the output buffer to reflect the original code. This means you must
    know where the hooked code is within the scanned block, taking into account the
    fact that the block may span only a subset of the hooked code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if `baseAddress` marks the address where the scan starts, `HOOK_START_ ADDRESS`
    marks the spot where the modified code starts, `endAddress` marks the address
    where the scan ends, and `HOOK_END_ADDRESS` marks the address where the modified
    code ends, you can use some simple math to calculate which parts of the modified
    code are present in which parts of the buffer. You do so as follows, using `writeStart`
    to store the offset of the modified code in the scan buffer and `readStart` to
    store the offset of the scan buffer relative to the modified code, in case the
    scan buffer starts in the middle of the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you know how many bytes you need to replace, where to put them, and where
    to get them, you can do the spoof with three lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Completely assembled, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you had multiple hooks that you needed to hide from binary validation
    scans, you would need to implement this functionality in a more robust way that
    would allow it to track multiple modified code regions accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defeating an Anti-Cheat Rootkit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GameGuard and some other anti-cheat suites come with user-mode rootkits that
    not only detect bots but also proactively prevent them from running. To defeat
    this type of protection, rather than think outside the box, you can completely
    copy the box and work inside that copy.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to write memory to a game, you must call the `WriteProcessMemory()`
    function, which is exported by *kernel32.dll*. When you call this function, it
    directly calls `NtWriteVirtualMemory()` from *ntdll.dll*. GameGuard hooks `ntdll.NtWriteVirtualMemory()`
    to prevent you from writing memory. But if `NtWriteVirtualMemory()` is exported
    from, say, *ntdll_copy.dll*, GameGuard won’t hook that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'That means you can copy *ntdll.dll* and dynamically import all of the functions
    you need, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After copying *ntdll.dll*, this code imports the `NtWriteVirtualMemory()` from
    the copy with the name `myWriteVirtualMemory()`. From there, the bot can use this
    function in place of the `NtWriteVirtualMemory()` function. They’re effectively
    the same code in the same library, just loaded under different names.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a function that anti-cheat software hooks works only if you call that
    function at its lowest-level entry point, though. If this code copied *kernel32.dll*
    and dynamically imported the `WriteProcessMemory()` function, an anti-cheat rootkit
    would still stop the bot, because *kernel32_copy.dll* would still rely on `ntdll.NtWriteVirtualMemory()`
    when calling the `WriteProcessMemory()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defeating Heuristics**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to all of the advanced client-side detection mechanisms we’ve just
    discussed, game companies will employ server-side heuristics that can detect bots
    simply by monitoring a player’s behavior. These systems learn to distinguish between
    human and autonomous player behavior through machine-learning algorithms. Their
    decision-making process is often internal and incomprehensible to humans, so it’s
    difficult to pinpoint exactly what features of gameplay lead to detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to know how such algorithms work to trick them; your bot just
    needs to act human. Here are some common behaviors that are distinguishably different
    between humans and bots:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intervals between actions**'
  prefs: []
  type: TYPE_NORMAL
- en: Many bots perform actions unreasonably fast or at consistent intervals. Bots
    will seem more human-like if they have a reasonable cooldown period between actions.
    They should also have some form of randomization to prevent them from repeating
    an action at a constant rate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Path repetition**'
  prefs: []
  type: TYPE_NORMAL
- en: Bots that farm enemies automatically visit a preprogrammed list of locations
    to kill creatures. These waypoint lists are often extremely accurate, indicating
    each location as an exact pixel. Humans, conversely, move in less predictable
    ways and visit more unique locations along the way to a familiar area. To replicate
    this behavior, a bot might walk to a random location within a certain range of
    a target location, rather than to the target location itself. Also, if the bot
    randomizes the order in which it visits target locations, the variety of paths
    it takes will increase further.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unrealistic play**'
  prefs: []
  type: TYPE_NORMAL
- en: Some botters run their bots in the same location for hundreds of consecutive
    hours, but humans can’t play a game that long. Encourage your users to refrain
    from botting for more than eight hours at a time and warn them that doing the
    same thing for seven straight days will definitely trigger alarms in a heuristic
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Perfect accuracy**'
  prefs: []
  type: TYPE_NORMAL
- en: Bots can hit a thousand head shots in a row without firing a single extra bullet,
    and they can hit every skill shot with consistent precision. But it’s virtually
    impossible for a human to do the same, so a smart bot should be intentionally
    inaccurate at times.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples, but in general, you can sneak past heuristic
    checks if you just use common sense. Don’t try to have a bot do something a human
    can’t, and don’t have the bot do any single thing for too long.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Game hackers and game developers are engaged in a constant battle of wits. Hackers
    will keep finding ways to subvert detection, and developers will keep finding
    better ways to detect them. If you’re determined, however, the knowledge in this
    chapter should help you defeat any anti-cheat software you encounter.
  prefs: []
  type: TYPE_NORMAL
