- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**STAYING HIDDEN**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**保持隐蔽**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Game hacking is an ever-evolving practice, a game of cat and mouse between hackers
    and game developers where each party works to subvert the other. As long as people
    make bots, game companies will find ways to hinder bot advances and ban players
    who use bots. Rather than making their games inherently harder to hack, though,
    game companies focus on *detection*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏作弊是一个不断发展的行为，是黑客和游戏开发者之间的猫鼠游戏，双方都在努力颠覆对方。只要有人制造机器人，游戏公司就会找到阻碍机器人进展并封禁使用机器人玩家的方法。不过，游戏公司并不将游戏本身变得更难破解，而是专注于*检测*。
- en: The largest game companies have very sophisticated detection suites called *anti-cheat
    software*. In the beginning of this chapter, I’ll discuss the capabilities of
    the most common anti-cheat suites. After revealing how these suites detect bots,
    I’ll teach you some powerful ways to evade them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的游戏公司拥有非常复杂的检测套件，称为*反作弊软件*。在本章的开始部分，我将讨论最常见的反作弊套件的功能。在揭示这些套件如何检测机器人后，我将教你一些强大的规避方法。
- en: '**Prominent Anti-Cheat Software**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**著名的反作弊软件**'
- en: The best-known anti-cheat suites use the same methods as most antivirus software
    to scan for bots and flag them as threats. Some anti-cheat suites are also dynamic,
    meaning their inner workings and capabilities can change based on the game they’re
    protecting. Anti-cheat software developers also track down and patch their suites
    against bypass software, so always do your own in-depth research of any anti-cheat
    software that you might face.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的反作弊套件使用与大多数杀毒软件相同的方法来扫描机器人并将其标记为威胁。一些反作弊套件也是动态的，这意味着它们的内部工作原理和功能可以根据它们保护的游戏而有所变化。反作弊软件开发人员还会追踪并修补他们的套件，以应对绕过软件，因此在面对任何反作弊软件时，务必进行深入的自我研究。
- en: When these suites detect a botter, they flag the botter’s account for banishment.
    Every few weeks, game company administrators ban the flagged players in a *ban
    wave*. Game companies use ban waves instead of instantaneous bans because banning
    in waves is more profitable. If botters are banned after a few weeks of playing,
    their familiarity with the game will make them more likely to buy a new account
    than if they were banned the moment their bot started running.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些套件检测到机器人时，它们会将机器人的账户标记为待封禁。每隔几周，游戏公司管理员会在*封禁波*中封禁被标记的玩家。游戏公司使用封禁波而不是即时封禁，因为波次封禁更有利可图。如果机器人在几周的游戏后被封禁，由于他们对游戏的熟悉，可能更容易购买新账户，而不是在机器人开始运行的瞬间就被封禁。
- en: 'There are dozens of anti-cheat suites, but I’ll focus on the five packages
    that are the most common and thoroughly understood: *PunkBuster*, *ESEA Anti-Cheat*,
    *Valve Anti-Cheat (VAC)*, *GameGuard*, and *Warden*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种反作弊套件，但我将重点讨论五个最常见且被彻底了解的套件：*PunkBuster*、*ESEA反作弊*、*Valve反作弊（VAC）*、*GameGuard*和*Warden*。
- en: '**The PunkBuster Toolkit**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**PunkBuster工具包**'
- en: PunkBuster, made by Even Balance Inc., is the original anti-cheat toolkit. Many
    games use PunkBuster, but it’s most common in first-person shooter games like
    *Medal of Honor*, *Far Cry 3*, and several installments of the *Battlefield* series.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PunkBuster由Even Balance公司制作，是最早的反作弊工具包。许多游戏使用PunkBuster，但它在第一人称射击游戏中最为常见，如*荣誉勋章*、*孤岛惊魂3*和*战地*系列的多个版本。
- en: The toolkit uses a myriad of detection methods, the most formidable of which
    are signature-based detection (SBD), screenshots, and hash validation. PunkBuster
    is also known for imposing hardware bans that permanently ban a cheater’s computer,
    rather than just their game account, by saving a fingerprint of the hardware’s
    serial numbers and blocking logins from a machine that matches it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具包使用了多种检测方法，其中最强大的包括基于签名的检测（SBD）、截图和哈希验证。PunkBuster还因实施硬件封禁而闻名，它通过保存硬件序列号的指纹来永久封禁作弊者的计算机，而不仅仅是他们的游戏账户，并阻止来自匹配该指纹的机器的登录。
- en: '***Signature-Based Detection***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于签名的检测***'
- en: PunkBuster scans the memory of all processes on a system running a game that
    employs it, searching for byte patterns unique to known cheat software, called
    *signatures*. If PunkBuster detects a signature, the player is flagged for a ban.
    PunkBuster carries out memory scans from user mode using the `NtQueryVirtualMemory()`
    Windows API function, and it sometimes runs scans from multiple hidden processes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PunkBuster扫描运行该软件的系统上所有进程的内存，搜索已知作弊软件的独特字节模式，称为*签名*。如果PunkBuster检测到签名，玩家将被标记为待封禁。PunkBuster使用`NtQueryVirtualMemory()`
    Windows API函数从用户模式执行内存扫描，并有时从多个隐藏进程中运行扫描。
- en: 'Signature-based detection is blind to context by design, and it ultimately
    suffers from a fatal flaw: false positives. On March 23, 2008, a team of hackers
    set out to prove the existence of this flaw by spamming public chatrooms with
    a text string that PunkBuster would identify as a bot signature. Since SBD blindly
    scans process memory for matching patterns, any and all legitimate players inside
    these public chatrooms were flagged as botters.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于签名的检测方法从设计上是盲目的，最终会面临一个致命缺陷：误报。2008 年 3 月 23 日，一组黑客团队试图通过向公共聊天室发送一个 PunkBuster
    会识别为机器人签名的文本字符串来证明这个缺陷的存在。由于 SBD 会盲目扫描进程内存中的匹配模式，所有在这些公共聊天室中的合法玩家都被标记为机器人玩家。
- en: 'This caused thousands of fair players to be banned with no justification. A
    similar situation happened again in November 2013: PunkBuster falsely banned thousands
    of players on *Battlefield 4*. That time, no one was trying to prove a point;
    the company had just added a bad signature to its software.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致成千上万的公平玩家被禁赛，且没有任何正当理由。2013 年 11 月，类似的情况再次发生：PunkBuster 错误地禁止了成千上万的玩家在 *Battlefield
    4* 中的账号。那次，没有人试图证明某种观点；公司只是在软件中添加了一个错误的签名。
- en: PunkBuster resolved both of these issues by restoring the players’ accounts,
    but these incidents show just how aggressive its flavor of SBD is. In the time
    since these attacks, though, PunkBuster’s SBD has reduced the number of false
    positives by checking only for signatures at predefined binary offsets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PunkBuster 通过恢复玩家账户解决了这两个问题，但这些事件显示出它的 SBD 在执行时有多么激进。然而，经过这些攻击之后，PunkBuster
    的 SBD 通过仅在预定义的二进制偏移量上检查签名，减少了误报的数量。
- en: '***Screenshots***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***截图***'
- en: As another method of bot detection, PunkBuster also periodically takes screenshots
    of a player’s screen and sends them to the central game server. This form of detection
    is a nuisance, and it’s weak compared to SDB. Game-hacking communities speculate
    that PunkBuster implemented this feature to give game admins proof against botters
    who dispute bans.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种机器人检测方法，PunkBuster 还会定期截图玩家的屏幕，并将截图发送到中央游戏服务器。这种检测方式很麻烦，而且与 SDB 相比效果较差。游戏作弊社区推测，PunkBuster
    实施这个功能是为了给游戏管理员提供证据，以应对那些对禁令提出异议的机器人玩家。
- en: '***Hash Validation***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***哈希验证***'
- en: In addition to employing SBD and screenshots, PunkBuster detects bots by creating
    cryptographic hashes of a game’s executable binaries on a player’s system and
    comparing them to hashes stored on a central server. If the hashes do not match,
    the player is flagged for a ban. This check is carried out only on the binaries
    on the filesystem, not on in-memory binaries.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了采用 SBD 和截图，PunkBuster 还通过在玩家系统上创建游戏可执行文件的加密哈希，并将其与存储在中央服务器上的哈希进行比较来检测机器人。如果哈希不匹配，玩家将被标记为禁赛。这个检查只会在文件系统中的二进制文件上进行，而不会在内存中的二进制文件上进行。
- en: '**The ESEA Anti-Cheat Toolkit**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ESEA 反作弊工具包**'
- en: 'The ESEA Anti-Cheat toolkit is used by the *E-Sports Entertainment Association
    (ESEA)*, primarily for its *Counter-Strike: Global Offensive* league. Unlike PunkBuster,
    this suite is known for generating very few false positives and being highly effective
    at catching cheaters.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'ESEA 反作弊工具包被 *E-Sports Entertainment Association (ESEA)* 使用，主要用于其 *Counter-Strike:
    Global Offensive* 联赛。与 PunkBuster 不同，这个工具包以产生非常少的误报并且在抓取作弊者方面非常有效而闻名。'
- en: 'ESEA Anti-Cheat’s detection capabilities resemble those of PunkBuster, with
    one noteworthy difference. ESEA Anti-Cheat’s SBD algorithm is carried out from
    a kernel-mode driver using three different Windows Kernel functions: the `MmGetPhysicalMemoryRanges()`
    function, the `ZwOpenSection()` function, and the `ZwMapViewOfSection()` function.
    This implementation makes the anti-cheat system nearly immune to memory spoofing
    (a common way to defeat SBD), as the functions used by the scan are much harder
    to hook when they’re called from a driver.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ESEA 反作弊的检测能力与 PunkBuster 相似，但有一个显著的不同。ESEA 反作弊的 SBD 算法是通过一个内核模式驱动程序执行的，使用了三个不同的
    Windows 内核函数：`MmGetPhysicalMemoryRanges()` 函数、`ZwOpenSection()` 函数和 `ZwMapViewOfSection()`
    函数。这个实现使得反作弊系统几乎免疫于内存伪造（这是一种常见的绕过 SBD 的方式），因为这些扫描函数在从驱动程序调用时更难被挂钩。
- en: '**The VAC Toolkit**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**VAC 工具包**'
- en: VAC is the toolkit Valve Corporation applies to its own games and many of the
    third-party games available on its Steam gaming platform. VAC uses SDB and hash
    validation methods that resemble PunkBuster’s detection techniques, and it also
    uses Domain Name System (DNS) cache scans and binary validation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: VAC 是 Valve 公司应用于自家游戏和许多第三方游戏（通过其 Steam 游戏平台提供）的工具包。VAC 使用与 PunkBuster 检测技术相似的
    SDB 和哈希验证方法，还使用了域名系统（DNS）缓存扫描和二进制验证。
- en: '***DNS Cache Scans***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DNS 缓存扫描***'
- en: DNS is a protocol that converts between domain names and IP addresses smoothly,
    and the DNS cache is where that information gets stored on a computer. When VAC’s
    SBD algorithm detects cheat software, VAC scans the player’s DNS cache for any
    domain names associated with cheating websites. It’s not certain whether a positive
    DNS cache scan is required for VAC’s SBD algorithm to flag a player for banishment,
    or if the DNS cache scan simply acts as another nail in the coffin for players
    who are already flagged by SBD.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 是一种平滑转换域名和 IP 地址的协议，DNS 缓存是存储这些信息的地方。当 VAC 的 SBD 算法检测到作弊软件时，VAC 会扫描玩家的 DNS
    缓存，查找与作弊网站相关的任何域名。目前尚不确定是否需要进行 DNS 缓存扫描，才能让 VAC 的 SBD 算法标记玩家为封禁对象，或者 DNS 缓存扫描是否仅仅是对已经被
    SBD 标记的玩家的进一步确认。
- en: '**NOTE**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To see your DNS cache, enter **`ipconfig /displaydns`** at a command prompt.
    Yes, VAC looks at all of that.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*要查看您的 DNS 缓存，请在命令提示符下输入 **`ipconfig /displaydns`**。是的，VAC 会查看所有这些信息。*'
- en: '***Binary Validation***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制验证***'
- en: VAC also uses binary validation to prevent in-memory tampering of executable
    binaries. It scans for modifications like IAT, jump, and code hooking by comparing
    hashes of in-memory binary code to hashes of the same code in the binaries on
    the filesystem. If it finds a mismatch, VAC flags the player for a ban.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: VAC 还使用二进制验证来防止可执行二进制文件在内存中被篡改。它通过将内存中的二进制代码的哈希与文件系统中相同代码的哈希进行比较，扫描如 IAT、跳转和代码钩取等修改。如果发现不匹配，VAC
    会标记该玩家为作弊并进行封禁。
- en: This detection method is formidable, but Valve’s initial implementation of the
    algorithm was flawed. In July 2010, VAC’s binary validation falsely banned 12,000
    *Call of Duty* players. The binary validation module failed to account for a Steam
    update, and it banned the players when their in-memory code did not match the
    updated binaries on the filesystem.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种检测方法非常强大，但 Valve 最初实施该算法时存在缺陷。2010年7月，VAC 的二进制验证错误地封禁了 12,000 名 *使命召唤* 玩家。二进制验证模块未考虑到
    Steam 更新，导致玩家的内存中的代码与文件系统中的更新二进制文件不匹配时被封禁。
- en: '***False Positives***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***虚假正例***'
- en: VAC has had other issues with false positives. Its initial release routinely
    banned fair players for “faulty memory.” This same early version banned players
    for using *Cedega*, a platform that ran Windows games on Linux. And on April 1,
    2004, Valve falsely banned a couple thousand players due to a server-side glitch.
    On two separate occasions, one in June 2011 and one in February 2014, VAC also
    falsely banned thousands of *Team Fortress 2* and *Counter-Strike* players due
    to bugs that the company refuses to disclose. As with PunkBuster, these incidents
    show that VAC is very aggressive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: VAC 也曾出现过虚假正例。其最初版本经常因为“内存故障”错误地封禁公正玩家。这个早期版本还因玩家使用 *Cedega*（一个在 Linux 上运行 Windows
    游戏的平台）而封禁玩家。2004年4月1日，Valve 由于服务器端故障错误地封禁了几千名玩家。在2011年6月和2014年2月的两次事件中，VAC 也因公司拒绝披露的漏洞错误地封禁了数千名
    *Team Fortress 2* 和 *Counter-Strike* 玩家。与 PunkBuster 类似，这些事件表明 VAC 非常具有攻击性。
- en: '**The GameGuard Toolkit**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GameGuard 工具包**'
- en: GameGuard is an anti-cheat toolkit made by INCA Internet Co. Ltd. and used by
    many MMORPGs, including *Lineage II*, *Cabal Online*, and *Ragnarok Online*. In
    addition to some mildly aggressive SBD, GameGuard uses rootkits to proactively
    prevent cheat software from running.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: GameGuard 是由 INCA Internet Co. Ltd. 开发的反作弊工具包，被许多 MMORPG 游戏使用，包括 *天堂 II*、*Cabal
    Online* 和 *仙境传说 Online*。除了使用一些较为激进的 SBD，GameGuard 还利用根工具包积极防止作弊软件运行。
- en: '***User-Mode Rootkit***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用户模式根工具包***'
- en: 'GameGuard utilizes a user-mode rootkit to deny bots access to the Windows API
    functions they use to operate. The rootkit hooks the functions at their lowest-level
    entry point, often inside undocumented functions in *ntdll.dll*, *user32.dll*,
    and *kernel32.dll*. These are the most notable API functions GameGuard hooks,
    and here’s what GameGuard does from inside each hooked function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GameGuard 使用用户模式根工具包来拒绝机器人访问它们操作所需的 Windows API 函数。根工具包在函数的最低级入口点进行钩取，通常位于 *ntdll.dll*、*user32.dll*
    和 *kernel32.dll* 中的未文档函数内。这些是 GameGuard 最常钩取的 API 函数，下面是 GameGuard 在每个被钩取函数中的行为：
- en: '`NtOpenProcess()` Blocks any `OpenProcess()` attempts on the game being protected.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`NtOpenProcess()` 阻止任何对被保护游戏的 `OpenProcess()` 尝试。'
- en: '`NtProtectVirtualMemory()` Blocks any `VirtualProtect()` or `VirtualProtectEx()`
    attempts on the game.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`NtProtectVirtualMemory()` 阻止任何 `VirtualProtect()` 或 `VirtualProtectEx()` 对游戏的尝试。'
- en: '`NtReadVirtualMemory()` **and** `NtWriteVirtualMemory()` Block any `ReadProcessMemory()`
    and `WriteProcessMemory()` attempts on the game.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`NtReadVirtualMemory()` **和** `NtWriteVirtualMemory()` 阻止任何对游戏的 `ReadProcessMemory()`
    和 `WriteProcessMemory()` 尝试。'
- en: '`NtSuspendProcess()` **and** `NtSuspendThread()` Block any attempts to suspend
    GameGuard.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`NtSuspendProcess()` **和** `NtSuspendThread()` 阻止任何试图暂停 GameGuard 的行为。'
- en: '`NtTerminateProcess()` **and** `NtTerminateThread()` Block any attempts to
    terminate GameGuard.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`NtTerminateProcess()` **和** `NtTerminateThread()` 阻止任何试图终止 GameGuard 的行为。'
- en: '`PostMessage()`, `SendMessage()`**, and** `SendInput()` Block any attempts
    to send programmatic input to the game.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostMessage()`、`SendMessage()`**和** `SendInput()` 阻止任何试图向游戏发送程序化输入的行为。'
- en: '`SetWindowsHookEx()` Prevents bots from globally intercepting mouse and keyboard
    input.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetWindowsHookEx()` 阻止机器人全局拦截鼠标和键盘输入。'
- en: '`CreateProcessInternal()` Automatically detects and hooks into new processes.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateProcessInternal()` 自动检测并钩住新进程。'
- en: '`GetProcAddress()`, `LoadLibraryEx()`**, and** `MapViewOfFileEx()` Prevent
    any attempt to inject libraries into the game or GameGuard.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetProcAddress()`、`LoadLibraryEx()`**和** `MapViewOfFileEx()` 阻止任何向游戏或 GameGuard
    注入库的尝试。'
- en: '***Kernel-Mode Rootkit***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核模式 Rootkit***'
- en: GameGuard also uses a driver-based rootkit to prevent bots that work in the
    kernel. This rootkit has the same abilities as its user-mode counterpart, and
    it works by hooking `ZwProtectVirtualMemory()`, `ZwReadVirtualMemory()`, `ZwWriteVirtualMemory()`,
    `SendInput()`, and similar functions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: GameGuard 还使用基于驱动的 rootkit 来防止在内核中工作的机器人。这个 rootkit 具有与其用户模式对等体相同的能力，它通过钩住 `ZwProtectVirtualMemory()`、`ZwReadVirtualMemory()`、`ZwWriteVirtualMemory()`、`SendInput()`
    等函数来工作。
- en: '**The Warden Toolkit**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Warden 工具包**'
- en: 'Warden, made exclusively for Blizzard’s games, is by far the most advanced
    anti-bot toolkit I’ve encountered. It’s hard to say what exactly Warden does,
    because it downloads dynamic code at runtime. This code, delivered as compiled
    shellcode, typically has two responsibilities:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Warden，是暴雪专门为其游戏开发的工具包，是我遇到的最先进的反机器人工具包。很难说 Warden 究竟做了什么，因为它在运行时下载动态代码。这些代码以编译后的
    shellcode 形式交付，通常有两个主要职责：
- en: • Detect bots.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: • 检测机器人。
- en: • Periodically send a heartbeat signal to the game server. The value sent is
    not predefined but instead is generated by some subset of the detection code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: • 定期向游戏服务器发送心跳信号。发送的值不是预定义的，而是由某些检测代码的子集生成。
- en: If Warden fails to complete the second task or sends the wrong value, the game
    server will know that it’s been disabled or tampered with. Furthermore, a bot
    can’t disable the detection code and leave the heartbeat code running.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Warden 无法完成第二个任务或发送错误的值，游戏服务器就会知道它已被禁用或篡改。此外，机器人无法禁用检测代码并保持心跳代码运行。
- en: '**THE HALTING PROBLEM**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**停机问题**'
- en: 'A bot that could disable Warden’s detection code and still send the heartbeat
    signal would solve the *halting problem*, which Alan Turing proved to be impossible
    in 1936\. The halting problem is the problem of determining, with a generic algorithm,
    whether a program will finish running or continue forever. Because Warden does
    two tasks using the same shellcode, writing a generic algorithm that can disable
    just one task is a variation of the halting problem: the algorithm can’t be sure
    which parts of the code will definitely execute, which parts won’t, and which
    parts are responsible for each task.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个能够禁用 Warden 检测代码并仍能发送心跳信号的机器人，将解决*停机问题*，该问题由艾伦·图灵于 1936 年证明是不可能解决的。停机问题是指通过一个通用算法判断一个程序是否会完成执行或永远运行下去。由于
    Warden 使用相同的 shellcode 执行两个任务，编写一个通用算法只禁用其中一个任务是停机问题的一个变种：该算法无法确定哪些代码部分一定会执行，哪些不会，哪些部分负责执行每个任务。
- en: Warden is formidable because you not only have no way to know what you’re hiding
    from but also have no way to disable the toolkit. Even if you manage to avoid
    detection today, a new detection method might be used tomorrow.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Warden 很强大，因为你不仅无法知道自己在隐藏什么，还无法禁用这个工具包。即使你今天设法避免了检测，明天也可能会使用新的检测方法。
- en: If you plan on publicly distributing bots, you will eventually meet one of the
    anti-cheat solutions described in the previous sections—and you’ll have to beat
    it. Depending on your bot’s footprint, the type of detection in the game you’re
    botting, and your implementation, the difficulty of evading one of these toolkits
    can range from trivial to extremely hard.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划公开分发机器人，你最终会遇到前面描述的某种反作弊解决方案——你必须战胜它。根据你机器人的足迹、游戏中的检测类型以及你的实现方式，躲避这些工具包的难度可能从微不足道到极其困难不等。
- en: '**Carefully Managing a Bot’s Footprint**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**谨慎管理机器人足迹**'
- en: A bot’s *footprint* is how many unique, detectable characteristics it has. For
    example, a bot that hooks 100 functions will typically be easier to detect than
    a bot that hooks only 10 functions because the former makes an order of magnitude
    more changes to a game’s code than the latter. Since a targeted detection system
    needs to detect only one hook, the developer of the former bot needs to spend
    much more time making sure all of the bot’s hooks are as stealthy as possible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的*足迹*是指其拥有的独特、可检测的特征。例如，一个挂钩了100个函数的机器人通常比一个只挂钩10个函数的机器人更容易被检测到，因为前者对游戏代码的改动比后者多了一个数量级。由于目标检测系统只需要检测一个挂钩，前者机器人的开发者需要花费更多的时间确保机器人的所有挂钩都尽可能隐蔽。
- en: Another footprint characteristic is how detailed a bot’s user interface is.
    If a known bot has many dialog boxes that all have specific titles, a game company
    can just have its anti-cheat software detect the bot by searching for windows
    that have those titles. This same basic reasoning can be used with process names
    and filenames.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个足迹特征是机器人的用户界面有多详细。如果一个已知的机器人有很多对话框，并且每个对话框都有特定的标题，游戏公司可以让其反作弊软件通过搜索具有这些标题的窗口来检测该机器人。同样的基本推理也适用于进程名称和文件名。
- en: '***Minimizing a Bot’s Footprint***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最小化机器人的足迹***'
- en: Depending on how your bot works, there are many ways to minimize its footprint.
    If your bot relies heavily on hooks, for instance, you can avoid directly hooking
    a game’s code and instead focus on hooking Windows API functions. Windows API
    hooking is surprisingly common, so developers can’t assume a program that hooks
    the Windows API is a bot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的机器人如何工作，有很多方法可以最小化它的足迹。例如，如果你的机器人大量依赖挂钩，你可以避免直接挂钩游戏的代码，而是专注于挂钩Windows API函数。Windows
    API挂钩出乎意料地常见，因此开发者不能假设挂钩Windows API的程序就是机器人。
- en: If your bot has a well-defined user interface, you can mask the interface by
    removing all strings from window bars, buttons, and so on. Instead, display images
    that show text. If you’re worried about specific process names or filenames being
    detected by the anti-cheat software, use generic filenames and make your bot copy
    itself to a new, randomized directory every time it launches.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器人有一个明确的用户界面，你可以通过去除所有窗口条、按钮等的字符串来掩盖界面。你可以改为显示带有文本的图像。如果你担心特定的进程名称或文件名会被反作弊软件检测到，可以使用通用的文件名，并让你的机器人每次启动时将自己复制到一个新的、随机的目录中。
- en: '***Masking Your Footprint***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***掩盖你的足迹***'
- en: Minimizing your footprint is a preferred way to avoid detection, but it’s not
    necessary. You can also obfuscate your bot, making it harder for anyone to figure
    out how it works. Obfuscation can prevent both anti-bot developers from trying
    to detect your bot and other bot developers from analyzing your bot to steal proprietary
    functionality. If you sell your bot, obfuscation prevents people from cracking
    it to bypass your purchase verification, too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化你的足迹是避免被检测的首选方法，但这不是必须的。你也可以对你的机器人进行混淆，使得任何人都更难理解它是如何工作的。混淆可以防止反机器人开发者试图检测你的机器人，也可以防止其他机器人开发者分析你的机器人以窃取专有功能。如果你出售你的机器人，混淆还可以防止别人破解它来绕过你的购买验证。
- en: One common type of obfuscation is called *packing*. Packing an executable encrypts
    it and hides it inside another executable. When the container executable is launched,
    the packed executable is decrypted and executed in-memory. When a bot is packed,
    analyzing the binary to learn what the bot does is impossible, and debugging the
    bot process is much harder. Some common packer programs are *UPX*, *Armadillo*,
    *Themida*, and *ASPack*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的混淆方式叫做*打包*。打包一个可执行文件会将其加密，并隐藏在另一个可执行文件中。当容器可执行文件启动时，打包的可执行文件会在内存中被解密并执行。打包后的机器人，分析其二进制文件以了解机器人做了什么几乎是不可能的，而且调试机器人进程也变得更加困难。一些常见的打包程序有*UPX*、*Armadillo*、*Themida*和*ASPack*。
- en: '***Teaching a Bot to Detect Debuggers***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***教会机器人检测调试器***'
- en: When anti-bot developers (or other bot creators) can debug a bot, they can figure
    out how it works and thus how to stop it. If someone is actively trying to pick
    apart a bot, packing the executable may not be enough to evade them. To protect
    against this, bots often employ *anti-debugging* techniques, which obfuscate control
    flow by changing the bot’s behavior when a debugger is detected. In this section,
    I’ll quickly cover some well-known methods for detecting when a debugger is attached
    to your bot, and in the next, I’ll show you some tricks for obfuscation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当反机器人开发者（或其他机器人的创建者）能够调试一个机器人时，他们可以搞清楚它是如何工作的，从而知道如何阻止它。如果有人正在积极试图拆解一个机器人，那么仅仅打包可执行文件可能不足以避开他们。为了防范这种情况，机器人通常采用*反调试*技术，当检测到调试器时，通过改变机器人的行为来混淆控制流。在这一节中，我将简要介绍一些检测调试器附加到机器人上的常用方法，接下来我将展示一些混淆的技巧。
- en: '**Calling CheckRemoteDebuggerPresent()**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调用 CheckRemoteDebuggerPresent()**'
- en: '`CheckRemoteDebuggerPresent()` is a Windows API function that can tell you
    if a debugger is attached to the current process. Code to check for a debugger
    might look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckRemoteDebuggerPresent()` 是一个 Windows API 函数，可以告诉你当前进程是否附加了调试器。检测调试器的代码可能如下所示：'
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This check is pretty straightforward—it calls `CheckRemoteDebuggerPresent()`
    with the current process and a pointer to the `dbg` Boolean. Calling this function
    is the easiest way to detect a debugger, but it’s also very easy for a debugger
    to evade.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查非常简单——它调用 `CheckRemoteDebuggerPresent()`，传入当前进程和指向 `dbg` 布尔值的指针。调用这个函数是检测调试器的最简单方法，但调试器也很容易规避。
- en: '**Checking for Interrupt Handlers**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查中断处理程序**'
- en: '*Interrupts* are signals the processor sends to trigger a corresponding handler
    in the Windows kernel. Interrupts are typically generated by hardware events,
    but they can also be generated in software using the INT assembly instruction.
    The kernel allows some interrupts—namely, interrupts 0x2D and 0x03—to trigger
    user-mode interrupt handlers in the form of exception handlers. You can take advantage
    of these interrupts to detect debuggers.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*中断* 是处理器发送的信号，用于触发 Windows 内核中的相应处理程序。中断通常由硬件事件生成，但也可以通过使用 INT 汇编指令在软件中生成。内核允许一些中断——即中断
    0x2D 和 0x03——触发用户模式的中断处理程序，形式为异常处理程序。你可以利用这些中断来检测调试器。'
- en: When a debugger sets a breakpoint on an instruction, it replaces that instruction
    with a breakpoint instruction, such as INT 0x03\. When the interrupt is executed,
    the debugger is notified via an exception handler, where it handles the breakpoint,
    replaces the original code, and allows the application to resume execution seamlessly.
    When faced with an unrecognized interrupt, some debuggers even silently step over
    that interrupt and allow execution to continue normally, without triggering any
    other exception handlers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器在某条指令上设置断点时，它会用断点指令（例如 INT 0x03）替换该指令。当中断被执行时，调试器通过异常处理程序得到通知，在那里它处理断点、替换原始代码，并允许应用程序无缝地恢复执行。当遇到无法识别的中断时，一些调试器甚至会悄无声息地跳过该中断，并允许执行正常继续，而不触发任何其他异常处理程序。
- en: You can detect this behavior by purposely generating interrupts within exception
    handlers in your code, as shown in [Listing 12-1](ch12.xhtml#ch12exe1).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过故意在代码中的异常处理程序内生成中断来检测这种行为，正如[示例 12-1](ch12.xhtml#ch12exe1)所示。
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 12-1: Detecting interrupt handlers*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-1：检测中断处理程序*'
- en: During normal execution, these interrupts trigger the exception handlers surrounding
    them in the code. During a debugging session, some debuggers might intercept the
    exceptions generated by these interrupts and silently ignore them, preventing
    the surrounding exception handlers from executing. Thus, if the interrupts don’t
    trigger your exception handler, then a debugger is present.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常执行期间，这些中断会触发代码中围绕它们的异常处理程序。在调试会话中，一些调试器可能会拦截这些中断生成的异常并悄无声息地忽略它们，从而阻止周围的异常处理程序执行。因此，如果中断没有触发你的异常处理程序，那么说明存在调试器。
- en: '**Checking for Hardware Breakpoints**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查硬件断点**'
- en: Debuggers can also set breakpoints using the processor’s debug registers; these
    are called *hardware breakpoints*. A debugger can set a hardware breakpoint on
    an instruction by writing the address of the instruction to one of the four debug
    registers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器还可以使用处理器的调试寄存器设置断点；这些被称为*硬件断点*。调试器可以通过将指令的地址写入其中一个调试寄存器来在某条指令上设置硬件断点。
- en: 'When an address present on a debug register is executed, the debugger is notified.
    To detect hardware breakpoints (and thus, the presence of a debugger), you can
    check for nonzero values on any of the four debug registers like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Printing Debug Strings**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`OutputDebugString()` is a Windows API function that can be used to print log
    messages to a debugger console. If no debugger is present, the function will return
    with an error code. If a debugger is present, however, the function will return
    with no error code. Here’s how you can use this function as a trivial debugger
    check:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like the `CheckRemoteDebuggerPresent()` method, this method is very straightforward
    but also very easy for a debugger to evade.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for DBG_RIPEXCEPTION Handlers**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Debuggers typically have exception handlers that blindly catch exceptions with
    Windows’ `DBG_RIPEXCEPTION` exception code, making that code a clear way to spot
    a debugger. You can detect these exception handlers in much the same way [Listing
    12-1](ch12.xhtml#ch12exe1) detects interrupt handlers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Timing Control-Critical Routines**'
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If an anti-bot developer is debugging your bot, the developer will likely place
    breakpoints on and single-step through parts of your code that are critical to
    the bot’s behavior. You can detect this activity by measuring code execution times;
    when someone steps through code, execution takes a lot longer than usual.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a function only places some hooks, you can be sure that the
    code shouldn’t take more than a tenth of a second to do the memory protection.
    You could check the execution time for memory protection with help from the `GetTickCount()`
    Windows API function, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Checking for Debug Drivers**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some debuggers load kernel-mode drivers to assist their operation. You can
    detect these debuggers by attempting to get a handle to their kernel-mode drivers,
    like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a few common kernel-mode driver device names to check for, like `\\\\.\\EXTREM`
    and the others shown in the `drivers` array. If this handle-fetching code succeeds,
    then there’s a debugger running on the system. Unlike with the previous methods,
    though, obtaining a handle to one of those drivers doesn’t always mean the debugger
    is attached to your bot.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '***Anti-Debugging Techniques***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you detect a debugger, there are multiple ways to obfuscate your control
    flow. For instance, you might try to crash the debugger. The following code crashes
    OllyDbg v1.10:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The string `"%s%s%s%s"` contains format specifiers, and OllyDbg passes it to
    `printf()` without any extra parameters, which is why the debugger crashes. You
    could place this code in a function that gets called in response to detecting
    a debugger, but this option works only against OllyDbg.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Causing an Unavoidable Infinite Loop**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another obfuscation method to try is overloading the system until the person
    debugging your bot is forced to close the bot and debugger. This function does
    the trick:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The infinite `while` loop just keeps adding elements to `explosion` until the
    process runs out of memory or someone pulls the plug.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 无限的`while`循环不断向`explosion`中添加元素，直到进程耗尽内存或有人断开电源。
- en: '**Overflowing the Stack**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈溢出**'
- en: 'If you want to really confuse the analyst, you can make a chain of functions
    that eventually cause a stack overflow, but in an indirect way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想真正让分析人员困惑，你可以创建一个函数链，最终导致栈溢出，但以间接的方式：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In a nutshell, these functions randomly and infinitely recurse until there’s
    no room left on the call stack. Causing the overflow indirectly makes it hard
    for the analyst to pause and examine previous calls before they realize what’s
    happened.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这些函数会随机且无限递归，直到调用栈没有空间为止。间接导致溢出使得分析人员很难在他们意识到发生了什么之前暂停并检查之前的调用。
- en: '**Causing a BSOD**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导致蓝屏死机（BSOD）**'
- en: 'If you’re serious about obfuscation, you can even trigger a Blue Screen of
    Death (BSOD) when you detect a debugger. One way to do that is to set your bot’s
    process as critical using the `SetProcessIsCritical()` Windows API function and
    then call `exit()`, since Windows will trigger a BSOD when a critical process
    is killed. Here’s how you might do that:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认真对待混淆，你甚至可以在检测到调试器时触发蓝屏死机（BSOD）。一种方法是使用`SetProcessIsCritical()` Windows
    API函数将你的机器人的进程设置为关键进程，然后调用`exit()`，因为当关键进程被终止时，Windows会触发蓝屏死机。你可以这样做：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or maybe you’re evil, in which case you can do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也许你是个坏人，在这种情况下你可以这样做：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Assuming you’ve implemented all of the techniques described in this section,
    this code would cause a BSOD, crash the debugger (if it’s OllyDbg v1.10), overflow
    the stack, and exit the running program. If any one of the methods fails or gets
    patched, the analyst still has to deal with the remaining ones before they can
    continue debugging.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经实现了本节中描述的所有技巧，这段代码将导致蓝屏死机（BSOD），崩溃调试器（如果是OllyDbg v1.10），溢出栈并退出正在运行的程序。如果任何一种方法失败或被修补，分析人员仍然需要处理剩下的方法，才能继续调试。
- en: '**Defeating Signature-Based Detection**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**击败基于签名的检测**'
- en: Even with amazing obfuscation, you won’t easily beat signature detection. Engineers
    who analyze bots and write signatures are very skilled, and obfuscation is, at
    best, a nuisance that makes their job marginally harder.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有令人惊叹的混淆技术，你也不容易打败签名检测。分析机器人并编写签名的工程师非常熟练，而混淆技术充其量只是让他们的工作变得稍微困难一些。
- en: To completely evade SBD, you need to subvert the detection code. This requires
    knowing exactly how the SBD works. PunkBuster, for instance, uses `NtQueryVirtualMemory()`
    to scan the memory of all running processes for any signatures. If you want to
    bypass this, you can inject code into all PunkBuster processes with a hook on
    the `NtQueryVirtualMemory()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全躲避基于签名的检测，你需要颠覆检测代码。这要求你准确了解SBD的工作原理。例如，PunkBuster使用`NtQueryVirtualMemory()`扫描所有正在运行的进程内存中的任何签名。如果你想绕过它，你可以通过在`NtQueryVirtualMemory()`函数上设置钩子，将代码注入所有PunkBuster进程。
- en: 'When the function tries to query memory from your bot process, you can give
    it whatever data you want, like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数尝试从你的机器人进程查询内存时，你可以给它任何你想要的数据，像这样：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `onNtQueryVirtualMemory()` hook returns `STATUS_ACCESS_DENIED` ➊ when `NtQueryVirtualMemory()`
    tries to query the hook DLL’s memory, but it gives zeroed memory ➋ when `NtQueryVirtualMemory()`
    tries to query the bot’s memory. The difference isn’t for any specific reason;
    I’m just showing two ways you can hide from the `NtQueryVirtualMemory()` function
    call. If you’re really paranoid, you can even replace the entire buffer with a
    random byte sequence.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`onNtQueryVirtualMemory()`钩子在`NtQueryVirtualMemory()`尝试查询钩子DLL的内存时返回`STATUS_ACCESS_DENIED`
    ➊，但是当`NtQueryVirtualMemory()`尝试查询机器人内存时，它返回零填充的内存 ➋。这种差异并没有特别的原因；我只是展示了两种可以躲避`NtQueryVirtualMemory()`函数调用的方式。如果你真的很疑心，你甚至可以用随机字节序列替换整个缓冲区。
- en: Of course, this method works only for SBD that happens from user mode, like
    the SBD in PunkBuster or VAC. SBD that happens from the driver, like ESEA’s, or
    that isn’t predictable, like Warden’s, isn’t as easy to bypass.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法只对来自用户模式的基于签名的检测（SBD）有效，例如PunkBuster或VAC中的SBD。来自驱动程序的SBD，如ESEA，或不可预测的SBD，如Warden的，不容易绕过。
- en: 'In those cases, you can take precautions to eliminate unique signatures in
    your bot. If you’re distributing the bot to more than a dozen or so people, however,
    removing all distinguishing properties is tricky. To throw analysts off the scent,
    each time you give somebody a copy of the bot, you could try some combination
    of the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可以采取预防措施来消除你机器人中的独特标识符。然而，如果你将机器人分发给十几个人以上，去除所有的区分特征是非常棘手的。为了迷惑分析师，每次你给某人一个副本时，你可以尝试以下几种组合：
- en: • Compiling the bot using a different compiler
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用不同的编译器编译机器人
- en: • Changing the compiler optimization settings
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: • 更改编译器优化设置
- en: • Toggling between using `__fastcall` and `__cdecl`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: • 在使用`__fastcall`和`__cdecl`之间切换
- en: • Packing the binaries using a different packer
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用不同的打包工具打包二进制文件
- en: • Switching between static and dynamic linking of runtime libraries
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: • 在静态链接和动态链接运行时库之间切换
- en: Varying these elements creates a different assembly for each user, but there’s
    a limit on how many unique versions of the bot you can produce that way. Past
    some point, this method doesn’t scale to demand, and eventually, game companies
    will have signatures for every incarnation of your bot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 改变这些元素会为每个用户创建不同的汇编代码，但通过这种方式，你可以生产的独特版本数量是有限的。超过某个点后，这种方法就无法满足需求了，最终，游戏公司将会为你的机器人每一个版本都创建特征。
- en: Apart from obfuscation and code mutation, there aren’t many ways to defeat advanced
    SBD mechanisms. You could implement your bot in a driver or create a kernel-mode
    rootkit to hide your bot, but even those methods aren’t foolproof.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了混淆和代码变异外，几乎没有其他方法能击败高级的SBD机制。你可以将机器人实现为驱动程序，或者创建一个内核模式的rootkit来隐藏你的机器人，但即使是这些方法也并非万无一失。
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This book doesn’t cover implementing a bot in a driver or creating a rootkit
    to hide a bot, as both topics are pretty complex. Rootkit development alone is
    a subject that dozens of books have covered already. I’d recommend Bill Blunden’s*
    The Rootkit Arsenal: Escape and Evasion in The Dark Corners of The System *(Jones
    & Bartlett Learning, 2009).*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书没有涉及如何在驱动程序中实现机器人或创建rootkit来隐藏机器人，因为这两个主题都相当复杂。单单是rootkit开发就是一个已经被许多书籍详细讨论的主题。我推荐Bill
    Blunden的*《Rootkit Arsenal: Escape and Evasion in The Dark Corners of The System》*（Jones
    & Bartlett Learning，2009年）。*'
- en: Some game hackers try to cover every single base, hooking every memory-reading
    function and the entire filesystem API, but still get caught by determined systems
    like Warden. In fact, I recommend staying away from Warden and Blizzard at all
    costs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏黑客试图覆盖每一个细节，挂钩每个内存读取函数和整个文件系统API，但仍然会被像Warden这样的系统抓到。事实上，我建议你避免与Warden和暴雪有任何接触。
- en: '**Defeating Screenshots**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**击败截图**'
- en: 'If you encounter a detection mechanism that uses screenshots as additional
    proof to nail botters, you’re in luck. Bypassing screenshot mechanisms is easy:
    don’t let your bot be seen.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一种检测机制，利用截图作为额外证据来抓捕机器人使用者，那么你很幸运。绕过截图机制非常简单：不要让你的机器人被看到。
- en: You can subvert this type of detection by keeping a minimal UI and making no
    visibly distinguishable changes to the game client. If your bot requires a HUD
    or other distinctive UI displays, though, don’t fret—you can have your cake and
    eat it, too. As long as you can intercept the screenshot code, you can hide your
    fingerprints while a screenshot is taken.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过保持最小的用户界面并且不对游戏客户端做出明显可区分的改动来规避这种类型的检测。如果你的机器人需要一个HUD或者其他独特的UI显示，别担心——你完全可以两者兼得。只要你能够拦截截图代码，你就可以在截图时隐藏你的“指纹”。
- en: 'In some versions of PunkBuster, for example, the Windows API function `GetSystemTimeAsFileTime()`
    is called just before a screenshot is taken. You can use a hook on this function
    to quickly hide your UI for a few seconds to ensure it’s not seen:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些版本的PunkBuster中，例如，Windows API函数`GetSystemTimeAsFileTime()`会在截图拍摄前被调用。你可以在这个函数上设置钩子，以便快速隐藏你的UI几秒钟，确保它不会被看到：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just hook `GetSystemTimeAsFileTime()` using the techniques described in “[Hooking
    to Redirect Game Execution](ch08.xhtml#ch00lev1sec151)” on [page 153](ch08.xhtml#page_153),
    write a `hideUI()` function, and call the `hideUI()` function before execution
    resumes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用在“[重定向游戏执行的挂钩](ch08.xhtml#ch00lev1sec151)”中描述的技术钩住`GetSystemTimeAsFileTime()`函数，[第153页](ch08.xhtml#page_153)上有详细说明，编写一个`hideUI()`函数，并在执行继续前调用该`hideUI()`函数。
- en: '**Defeating Binary Validation**'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**击败二进制验证**'
- en: Defeating binary validation is as simple as not placing hooks inside game-specific
    binaries. Jump hooks and IAT hooks on Windows API functions are extremely common,
    so wherever you can, try to get away with using those methods instead of using
    jump or near-call hooks in a game binary. In cases where you must directly hook
    a game’s code, you can trick the anti-cheat software’s binary validation routines
    by intercepting the binary scan and spoofing the data to match what the software
    expects to see.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 击败二进制验证的方法很简单——不要在游戏特定的二进制文件中放置挂钩。Windows API函数中的跳转挂钩和IAT挂钩非常常见，所以只要可能，尽量使用这些方法，而不是在游戏的二进制文件中使用跳转或近调用挂钩。在必须直接挂钩游戏代码的情况下，你可以通过拦截二进制扫描并伪造数据，使其匹配反作弊软件预期的数据，从而欺骗反作弊软件的二进制验证过程。
- en: 'Like SBD, binary validation often uses `NtQueryVirtualMemory()` to scan memory.
    To trick the validation code, start with a hook on that function. Then, write
    a function like this one to spoof the data when `NtQueryVirtualMemory()` is called:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 像SBD一样，二进制验证通常使用`NtQueryVirtualMemory()`来扫描内存。为了欺骗验证代码，从挂钩这个函数开始。然后，写一个像这样的函数，当`NtQueryVirtualMemory()`被调用时伪造数据：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Inside this hook, you’ll need to watch for any memory scans over memory that
    has been modified by one of your hooks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挂钩内，你需要监控任何对已被你的挂钩修改的内存进行的扫描。
- en: '**NOTE**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This example assumes the bot has only one hook and that variables prefixed
    with `HOOK_` already exist and describe the code the hook replaces.*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个示例假设机器人只有一个挂钩，并且以`HOOK_`为前缀的变量已经存在，并描述了挂钩替换的代码。*'
- en: '[Listing 12-2](ch12.xhtml#ch12exe2) shows some scan-monitoring code.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表12-2](ch12.xhtml#ch12exe2)展示了一些扫描监控代码。'
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 12-2: Checking whether hooked memory is being scanned*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表12-2：检查是否挂钩的内存正在被扫描*'
- en: When a memory scan over the hooked code happens (which makes `currentProcess`
    and `containsHook` become `true` at the same time), code inside the `if()` statement
    ➊ updates the output buffer to reflect the original code. This means you must
    know where the hooked code is within the scanned block, taking into account the
    fact that the block may span only a subset of the hooked code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当对已挂钩代码进行内存扫描时（这会使得`currentProcess`和`containsHook`同时变为`true`），`if()`语句内的代码➊会更新输出缓冲区，以反映原始代码。这意味着你必须知道挂钩代码在扫描块中的位置，考虑到该块可能只跨越挂钩代码的一个子集。
- en: 'So if `baseAddress` marks the address where the scan starts, `HOOK_START_ ADDRESS`
    marks the spot where the modified code starts, `endAddress` marks the address
    where the scan ends, and `HOOK_END_ADDRESS` marks the address where the modified
    code ends, you can use some simple math to calculate which parts of the modified
    code are present in which parts of the buffer. You do so as follows, using `writeStart`
    to store the offset of the modified code in the scan buffer and `readStart` to
    store the offset of the scan buffer relative to the modified code, in case the
    scan buffer starts in the middle of the modified code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果`baseAddress`标记了扫描开始的地址，`HOOK_START_ADDRESS`标记了修改后的代码开始的位置，`endAddress`标记了扫描结束的地址，`HOOK_END_ADDRESS`标记了修改后的代码结束的位置，你可以使用一些简单的数学计算来确定修改后的代码在缓冲区的哪些部分。你可以按照以下步骤操作，使用`writeStart`来存储修改代码在扫描缓冲区中的偏移量，使用`readStart`来存储扫描缓冲区相对于修改代码的偏移量，以防扫描缓冲区开始的位置在修改代码的中间：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you know how many bytes you need to replace, where to put them, and where
    to get them, you can do the spoof with three lines of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道需要替换多少字节、放置它们的位置以及从哪里获取它们，你可以通过三行代码来完成欺骗：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Completely assembled, the code looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完全组装后的代码如下所示：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, if you had multiple hooks that you needed to hide from binary validation
    scans, you would need to implement this functionality in a more robust way that
    would allow it to track multiple modified code regions accordingly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你有多个挂钩需要隐藏免受二进制验证扫描的影响，你需要以更健壮的方式实现此功能，以便能够相应地跟踪多个修改过的代码区域。
- en: '**Defeating an Anti-Cheat Rootkit**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**击败反作弊Rootkit**'
- en: GameGuard and some other anti-cheat suites come with user-mode rootkits that
    not only detect bots but also proactively prevent them from running. To defeat
    this type of protection, rather than think outside the box, you can completely
    copy the box and work inside that copy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: GameGuard和一些其他反作弊套件带有用户模式的Rootkit，这些Rootkit不仅能检测机器人程序，还能主动防止它们运行。为了击败这种保护方式，你不必跳出框框思考，你可以完全复制这个框，并在这个副本内进行工作。
- en: For example, if you want to write memory to a game, you must call the `WriteProcessMemory()`
    function, which is exported by *kernel32.dll*. When you call this function, it
    directly calls `NtWriteVirtualMemory()` from *ntdll.dll*. GameGuard hooks `ntdll.NtWriteVirtualMemory()`
    to prevent you from writing memory. But if `NtWriteVirtualMemory()` is exported
    from, say, *ntdll_copy.dll*, GameGuard won’t hook that function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想向游戏写入内存，必须调用由*kernel32.dll*导出的`WriteProcessMemory()`函数。当你调用这个函数时，它会直接调用*ntdll.dll*中的`NtWriteVirtualMemory()`函数。GameGuard会钩住`ntdll.NtWriteVirtualMemory()`函数，防止你写入内存。但如果`NtWriteVirtualMemory()`从另一个文件，如*ntdll_copy.dll*中导出，GameGuard就无法钩住这个函数。
- en: 'That means you can copy *ntdll.dll* and dynamically import all of the functions
    you need, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以复制*ntdll.dll*并动态导入所有需要的函数，如下所示：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After copying *ntdll.dll*, this code imports the `NtWriteVirtualMemory()` from
    the copy with the name `myWriteVirtualMemory()`. From there, the bot can use this
    function in place of the `NtWriteVirtualMemory()` function. They’re effectively
    the same code in the same library, just loaded under different names.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 复制*ntdll.dll*后，这段代码从复制的文件中导入`NtWriteVirtualMemory()`，并将其命名为`myWriteVirtualMemory()`。从此，机器人可以使用这个函数来替代`NtWriteVirtualMemory()`函数。它们实际上是相同的代码，位于相同的库中，只是以不同的名称加载。
- en: Copying a function that anti-cheat software hooks works only if you call that
    function at its lowest-level entry point, though. If this code copied *kernel32.dll*
    and dynamically imported the `WriteProcessMemory()` function, an anti-cheat rootkit
    would still stop the bot, because *kernel32_copy.dll* would still rely on `ntdll.NtWriteVirtualMemory()`
    when calling the `WriteProcessMemory()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一个被反作弊软件钩住的函数，只能在你以最低级别的入口点调用该函数时有效。如果这段代码复制了*kernel32.dll*并动态导入了`WriteProcessMemory()`函数，反作弊根套件依然会阻止机器人，因为*kernel32_copy.dll*在调用`WriteProcessMemory()`时仍然依赖于`ntdll.NtWriteVirtualMemory()`。
- en: '**Defeating Heuristics**'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**击败启发式算法**'
- en: In addition to all of the advanced client-side detection mechanisms we’ve just
    discussed, game companies will employ server-side heuristics that can detect bots
    simply by monitoring a player’s behavior. These systems learn to distinguish between
    human and autonomous player behavior through machine-learning algorithms. Their
    decision-making process is often internal and incomprehensible to humans, so it’s
    difficult to pinpoint exactly what features of gameplay lead to detection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才讨论的所有先进的客户端检测机制，游戏公司还会采用服务器端的启发式算法，通过监控玩家的行为来检测机器人。这些系统通过机器学习算法学会区分人类玩家和自动化玩家的行为。它们的决策过程通常是内部的，人类难以理解，因此很难确切指出哪些游戏特征会导致被检测出来。
- en: 'You don’t need to know how such algorithms work to trick them; your bot just
    needs to act human. Here are some common behaviors that are distinguishably different
    between humans and bots:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要了解这些算法如何工作来欺骗它们；你的机器人只需要表现得像人类。以下是一些常见的行为模式，它们在人类和机器人之间有明显的区别：
- en: '**Intervals between actions**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作之间的间隔**'
- en: Many bots perform actions unreasonably fast or at consistent intervals. Bots
    will seem more human-like if they have a reasonable cooldown period between actions.
    They should also have some form of randomization to prevent them from repeating
    an action at a constant rate.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 许多机器人执行操作的速度异常快，或者按照固定的间隔进行。机器人如果在操作之间有合理的冷却时间，它们看起来会更加像人类。机器人还应具备某种随机化机制，以防止它们以固定的频率重复执行某个操作。
- en: '**Path repetition**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径重复**'
- en: Bots that farm enemies automatically visit a preprogrammed list of locations
    to kill creatures. These waypoint lists are often extremely accurate, indicating
    each location as an exact pixel. Humans, conversely, move in less predictable
    ways and visit more unique locations along the way to a familiar area. To replicate
    this behavior, a bot might walk to a random location within a certain range of
    a target location, rather than to the target location itself. Also, if the bot
    randomizes the order in which it visits target locations, the variety of paths
    it takes will increase further.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自动刷怪的机器人会访问一个预先编程的地点列表，去击杀怪物。这些路径列表通常非常精确，将每个位置标记为一个精确的像素。相比之下，人类玩家的移动方式较不规则，会沿着熟悉的区域访问一些更加独特的地方。为了模拟这种行为，机器人可能会走到目标地点的某个范围内的随机位置，而不是直接到达目标位置。而且，如果机器人随机化访问目标地点的顺序，它所走的路径种类将会进一步增加。
- en: '**Unrealistic play**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**不真实的游戏方式**'
- en: Some botters run their bots in the same location for hundreds of consecutive
    hours, but humans can’t play a game that long. Encourage your users to refrain
    from botting for more than eight hours at a time and warn them that doing the
    same thing for seven straight days will definitely trigger alarms in a heuristic
    system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些机器人使用者会让他们的机器人在同一个位置运行数百小时，但人类不可能连续玩这么长时间。建议你的用户避免一次使用机器人超过八小时，并警告他们，如果连续七天做同样的事情，肯定会在启发式系统中触发警报。
- en: '**Perfect accuracy**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**完美的准确度**'
- en: Bots can hit a thousand head shots in a row without firing a single extra bullet,
    and they can hit every skill shot with consistent precision. But it’s virtually
    impossible for a human to do the same, so a smart bot should be intentionally
    inaccurate at times.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人可以连续打出一千个爆头，不打多余的一发子弹，且能稳定地命中每一个技能射击。但对于人类来说，几乎不可能做到这一点，所以一个聪明的机器人有时应该故意不那么精准。
- en: These are just a few examples, but in general, you can sneak past heuristic
    checks if you just use common sense. Don’t try to have a bot do something a human
    can’t, and don’t have the bot do any single thing for too long.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些例子，但一般来说，只要你运用常识，你就能绕过启发式检测。不要让机器人做出人类无法做到的事情，也不要让机器人做某一件事做得太久。
- en: '**Closing Thoughts**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: Game hackers and game developers are engaged in a constant battle of wits. Hackers
    will keep finding ways to subvert detection, and developers will keep finding
    better ways to detect them. If you’re determined, however, the knowledge in this
    chapter should help you defeat any anti-cheat software you encounter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏黑客和游戏开发者之间一直在进行着智力的较量。黑客会不断寻找规避检测的方法，而开发者则会不断寻找更好的检测方式。然而，如果你决心要胜利，本章的知识应该能帮助你击败你遇到的任何反作弊软件。
