<html><head></head><body>
<section><header><h1 class="BackmatterTitle"><span epub:type="pagebreak" title="281" id="Page_281"/>Afterword</h1></header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This book should give you a good start with embedded C programming, but there’s a whole world outside <em>Bare Metal C</em> waiting for you to explore it. In closing, here are some helpful tips for starting down the road to professional programming.</p>
<h2 id="h1-501621b01-0001">Learn How to Write</h2>
<p class="BodyFirst">By far, the most important skill a professional programmer can have is being able to write well, as the programming process includes writing several types of documents, such as proposals, requirements, design documents, user documentation, and sales literature.</p>
<p>Take a creative writing course where your work is reviewed by others in your class. The feedback I got from the San Diego Writing Workshop was some of the most valuable training I’ve received in my life.</p>
<p><span epub:type="pagebreak" title="282" id="Page_282"/>Here’s a pro tip: if you’re writing the design or requirements for a project, you have great power in steering the direction of the project.</p>
<h2 id="h1-501621b01-0002">Learn How to Read</h2>
<p class="BodyFirst">You can learn a lot by “reading” technical documentation. I’ve put “reading” in quotation marks because you don’t read most technical documents in their entirety. You scan them to find the information you need at the time.</p>
<p>Here’s a list of the documents I’ve used in preparation for this book:</p>
<ul>
<li>ISO/IEC9899:2017, “Programing Languages: C” (500 pages)</li>
<li>RM0360 reference manual, “STM32F030x4/x6/x8/xC and STM32F070x6/xB Advanced ARM®-based 32-bit MCUs” (800 pages)</li>
<li>ARM® Developer Suite Assembler Guide Version 1.2, <a href="https://developer.arm.com/documentation/dui0068/b" class="LinkURL">https://developer.arm.com/documentation/dui0068/b</a> (400 pages)</li>
<li>“Using the GNU Compiler Collection” (GCC documentation, 1,000 pages)</li>
<li>GNU Make Manual, <a href="https://www.gnu.org/software/make/manual" class="LinkURL">https://www.gnu.org/software/make/manual</a> (225 pages)</li>
</ul>
<p>I did not read all these documents cover to cover. I probably used about 0.5 to 15 percent of them. I’ve become proficient at using the <code>find</code> command to locate the portion of the documentation I’m interested in.</p>
<h2 id="h1-501621b01-0003">Collaboration and Creative Theft</h2>
<p class="BodyFirst">No matter how experienced you are, you are only one person. By getting together with other people and reviewing each other’s work, you can expand your own knowledge and the knowledge of others. A good example of where this has worked well is the Linux kernel. Thousands of people have shared their code, received feedback, improved their code, and then collected it into the most powerful operating system in the world.</p>
<p>Looking through publicly available code to see how other programmers do things is also helpful. One example is the HAL firmware that comes with the STM32 Workbench. It is professional code that provides great internal documentation. (See the upcoming “Doxygen” section.) The bad news is that it’s designed to be used on a whole set of different chips, so you have to deal with the land of 200 <code>#ifdef</code>s. Lots of good source is available. Browse through some and see what you pick up.</p>
<h2 id="h1-501621b01-0004">Useful Open Source Tools</h2>
<p class="BodyFirst">The open source community has a long history of developing quality tools to aid in program creation and editing. These free tools are created by the <span epub:type="pagebreak" title="283" id="Page_283"/>people who want to use them, as opposed to commercial programs that add features that help sell the programs but might not be useful. This section describes a few helpful open source tools.</p>
<h3 id="h2-501621b01-0001">Cppcheck</h3>
<p class="BodyFirst">The Cppcheck program is a static program checker. In other words, it looks for problems in your program that the compiler didn’t find, which is getting tough these days as the compilers have become quite sophisticated.</p>
<p>This program was responsible for finding my favorite bit of C code. This was the error message:</p>
<pre><code>Detect matching 'if' and 'else if' conditions</code></pre>
<p>In other words, the body of the <code>if</code> and the body of the <code>else</code> contained the same code. There’s no need for the condition if the computer does the same thing when the condition is true or false.</p>
<p>Here’s the code in question:</p>
<pre><code>if (flag) {
    //(removed) processMessage()
} else {
    //(removed) processMessage()
}</code></pre>
<p>That’s right, the body of the <code>if</code> was one commented-out procedure call, and the body of the <code>else</code> was the same commented-out procedure call!</p>
<p>I prefer Cppcheck over most commercial static program analyzers because it generates a minimum number of false positives. If Cppcheck flags a line in your code, it’s a good idea to look at that code.</p>
<h3 id="h2-501621b01-0002">Doxygen</h3>
<p class="BodyFirst">Ever since the first program grew to be longer than 50 lines, people have tried to make programming languages that are self-documenting. So far, they’ve failed. The people behind Doxygen created a system where through structured comments in your program, you can create documentation for it (at least in theory).</p>
<p>The first difficulty is that you have to put the comments in the code, and many engineers fail to comment their code at all. Another issue is that the documentation looks like it was automatically generated. Although it’s actually very good for automatically generated documentation, it’s still automatically generated documentation.</p>
<p>The Cppcheck program mentioned in the previous section uses Doxygen for its internal documentation.</p>
<h3 id="h2-501621b01-0003">Valgrind</h3>
<p class="BodyFirst">The Valgrind project is a suite of tools designed to look at your program to check for errors dynamically. One of the most popular tools in the suite is <span epub:type="pagebreak" title="284" id="Page_284"/>memcheck, which looks for memory errors such as array overflows, pointers being used after they are freed, and so on. It’s very effective at detecting most simple runtime errors.</p>
<h3 id="h2-501621b01-0004">SQLite</h3>
<p class="BodyFirst">SQLite is an embedded database library that’s good for small databases (up to 100,000 records). It’s not the fastest database in the world, but for small embedded systems where you don’t want the overhead of a major database, it works well. You’ll need to learn SQL to use it, but it’s a valuable skill to learn.</p>
<h2 id="h1-501621b01-0005">Never Stop Learning</h2>
<p class="BodyFirst">Computer technology is changing at an amazing rate. That one little 38¢ STM microchip we use in this book has more power than all the computers in the world had in 1950. The technology will never stop changing, so you should never stop learning. You never know what new discovery you’ll find around the corner.</p>
</section>
</body></html>