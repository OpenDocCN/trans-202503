- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: INTRODUCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This book deals with two basic concepts in computer science: data structures
    and algorithms. It follows a structure similar to university curricula and adds
    examples taken from coding challenges and interview questions, using them to discuss
    the relative advantages and disadvantages of specific algorithms and data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: All examples are fully coded in JavaScript, with particular attention given
    to modern language features that simplify coding. Performance is also considered,
    from both a theoretical point of view (order of algorithms) and a practical one
    (scaffolding, measuring). Each chapter ends with a series of questions that amplify
    the concepts covered in the chapter and provide further examples for the reader
    to apply. The answers to the questions are provided at the end of the book.
  prefs: []
  type: TYPE_NORMAL
- en: '## Who Should Read This Book?'
  prefs: []
  type: TYPE_NORMAL
- en: This book is geared toward three groups of readers. The first and main group
    is JavaScript frontend (web) and backend (Node.js) developers, as it explores
    how we can apply data structures and algorithms to solve and optimize complex
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: The second group of readers is computer science (CS) students, as the book covers
    topics that appear in most CS courses. These students should be familiar with
    several programming languages, so the JavaScript focus shouldn’t be a hindrance.
    The algorithms don’t heavily depend on aspects of the language and can be translated
    into other languages with little difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the third group of readers includes programmers who are preparing for
    coding interviews or are interested in competitive programming. These readers
    will profit from actual implementation of algorithms and data structures and from
    seeing examples of the kinds of questions they’ll encounter.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the Book’s Approach?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The book always takes a practical approach to real-life use cases. It considers
    common problems and discusses appropriate algorithms and data structures. We’ll
    explore multiple versions and optimizations and develop several implementation
    variants to provide a deeper understanding of alternative possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: All of the algorithms are programmed using JavaScript, as it’s a widely available
    language that could be applied for both frontend and backend work. JavaScript
    is also well known and commonly used today, and it should be applicable to all
    kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: What’s in the Book?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The book is structured in three parts. [Part I](part1.xhtml) covers the basics
    and highlights important aspects of JavaScript that are used throughout the rest
    of the book. We’ll explore functional programming to understand some design considerations
    that are applied in later chapters. We’ll also consider abstract data types (ADTs),
    which is a concept that involves data structures and algorithms. Finally, we’ll
    study the topic of performance as it relates to algorithms, which will be applied
    often in the rest of the book. The following chapters are in [Part I](part1.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1](chapter1.xhtml): Using JavaScript **In this chapter we’ll cover
    important features of JavaScript that are used in the rest of the book, but we’ll
    just consider the highlights, as it is assumed you are already familiar with the
    language. Topics will include the current JavaScript version, transpilation, typing,
    arrow functions, spreading, destructuring, modules, and more. I’ll also introduce
    some of the many tools that are available to help you develop JavaScript code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2](chapter2.xhtml): Functional Programming in JavaScript **Here
    we’ll consider functional programming to highlight some design features that are
    used in the rest of the book. Topics will include what functional programming
    is, why you should use it, whether JavaScript is a functional programming language,
    the declarative programming style, side effects, and higher-order functions, among
    others.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3](chapter3.xhtml): Abstract Data Types **In this chapter I’ll introduce
    the concept of abstract data types as a basis for considering data structures
    and their associated operations. In later chapters, all structures will be considered
    as ADTs to highlight their pros and cons as well as their performance. The key
    topics will include what ADTs are and how to implement them in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4](chapter4.xhtml): Analyzing Algorithms **Here we’ll consider the
    performance aspects of algorithms in terms of both space and speed. We’ll discuss
    the concept of complexity classes and how (and when) it applies to the design
    of algorithms and data structures. The topics we’ll explore include what an algorithm’s
    performance is; the big *O* notation; complexity classes; the differences among
    best, average, worst, and amortized cases; how to measure performance; and time
    versus space trade-offs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part II](part2.xhtml) of the book focuses on algorithms, and it’s concerned
    with strategies for algorithm design. In particular, we’ll consider searching,
    sorting, shuffling, and sampling—all of which have well-known algorithms. The
    chapters in this part are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5](chapter5.xhtml): Designing Algorithms **In this chapter we’ll
    consider strategies for the design of algorithms and look at examples of each
    case. We’ll discuss general practices, recursion, brute-force search, greedy algorithms,
    divide-and-conquer algorithms, backtracking, dynamic programming, branch-and-bound,
    transform-and-conquer, and problem reduction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6](chapter6.xhtml): Sorting **Here we’ll discuss several common
    and important sorting algorithms to produce an ordered sequence of data out of
    unordered data. Some algorithms (such as heapsort) will receive only a brief mention,
    because they will be further analyzed in later chapters where the corresponding
    data structure is described. Topics include a description of the sorting problem,
    internal versus external sorting, JavaScript’s own sort function, comparison-based
    algorithms (such as bubblesort, selection sort, insertion sort, quicksort, and
    mergesort, among others), and comparison-less sorting algorithms (like bitmap
    sort, counting sort, and radix sort).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7](chapter7.xhtml): Selecting **This chapter will show algorithms
    for just finding the *k*th smallest value in a list or array, as opposed to sorting
    where we wanted to order the complete set. We’ll discuss the selection problem
    in general, using JavaScript’s minimum and maximum functions; doing selection
    by sorting (or partial sorting); and several other algorithms like quickselect,
    Floyd-Rivest, median of medians, and sorting by selection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8](chapter8.xhtml): Shuffling and Sampling **This chapter can be
    considered a complement to [Chapter 6](chapter6.xhtml). In this case we want to
    produce a random disordered sequence of data, instead of a totally ordered one,
    as might be needed for a computer card game or statistical sampling. We’ll look
    at the shuffling problem, how to do random sorting, the Fisher-Yates algorithm,
    random key sorting, and random sampling algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9](chapter9.xhtml): Searching **Here we’ll consider several common
    searching algorithms meant to quickly answer whether a specific value is or isn’t
    included in some set of data. Some algorithms will just be introduced here, but
    we’ll explore them more thoroughly in later chapters where the corresponding data
    structures are described and analyzed. Topics in this chapter include a description
    of the searching problem, JavaScript’s own search functions, linear searching
    (with or without sentinels), jump searching, binary searching, and interpolation
    searching.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part III](part3.xhtml) of the book is devoted to data structures, and it considers
    several data structure types, starting with simple, linear ones and finishing
    with more complex nonlinear structures. The following chapters are included in
    this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10](chapter10.xhtml): Lists **This chapter discusses the simplest
    structure, a linked list, which also includes several variants. We’ll delve into
    lists in detail (what they are; their various types; their ADT; single-, double-,
    and circular-linked lists), stacks (what they are and several implementations),
    queues (what queues are and what they’re used for, their ADT, and many implementations),
    and deques (their objective, ADT, and implementation).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11](chapter11.xhtml): Bags, Sets, and Maps **Here we’ll discuss
    structures that let you represent sets (no repeated elements) and bags (repeated
    elements allowed), with maps (key/value pairs) as a special important case. We’ll
    see what bags and sets are and their implementation (including JavaScript’s own
    versions as well as array- and list-based versions), finishing with hashing and
    bitmaps.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12](chapter12.xhtml): Binary Trees **This chapter considers binary
    trees, and in particular binary search trees (BSTs), which are the basis for many
    algorithms. We’ll discuss what a tree is, tree traversal (pre-, in-, and postorder
    algorithms), and using binary search trees for searching (including splay trees,
    balanced search trees like AVL and red-black trees, and randomized binary search
    trees).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13](chapter13.xhtml): Trees and Forests **Here we’ll study more
    general variants of trees, including forests (sets of trees). Topics include what
    trees and forests are, how to represent them in several ways, traversal algorithms
    (breadth- and depth-first algorithms), B-trees and variants that are oriented
    for searching, and red-black trees as a variant of BSTs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 14](chapter14.xhtml): Heaps **In this chapter we’ll consider heaps,
    a variant of binary trees that are stored without the need for dynamic memory
    and allow easy implementation of priority queues and sorting. We’ll discuss what
    heaps are, binary heaps and variants (ternary or d-ary heaps), heapsort (a heap-based
    sorting algorithm), heap-based sampling algorithms, and treaps, a heap-related
    BST.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 15](chapter15.xhtml): Extended Heaps **This chapter expands on the
    concept of heaps, considering variants that allow extra operations such as changing
    (altering the value of a key) and melding or merging (joining two or more heaps
    into one). Topics include binomial heaps, lazy binomial heaps, Fibonacci heaps,
    and pairing heaps.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 16](chapter16.xhtml): Digital Search Trees **Here we’ll consider
    trees specially designed to search for strings, as in a common “dictionary” where
    we’d look up words. We’ll include tries, radix tries, ternary tries, and other
    variants of these structures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 17](chapter17.xhtml): Graphs **In this chapter we’ll consider graphs,
    which are currently used in many applications, such as Google Maps or for calculating
    dependencies in a software project. Topics include what graphs are, different
    ways of representing them (such as adjacency lists or adjacency matrices), graph
    traversals and path finding (including shortest-path algorithms), and topological
    sorting.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 18](chapter18.xhtml): Immutability and Functional Data Structures **This
    final chapter will discuss the immutability aspect and explore how algorithms
    can be altered to avoid modifying the input structures, producing a new one instead.
    We’ll see what functional data structures are, what immutability means, object
    freezing, algorithms needed to avoid modifying data structures, and some examples
    of specific functional data structures such as lists, queues, and trees.'
  prefs: []
  type: TYPE_NORMAL
- en: The book finishes with the answers to the questions found at the end of each
    chapter; sometimes answers are given in full, and other times hints or links to
    solutions are provided.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*All of the source code for this book is available at* [https://github.com/fkereki/data-structures-and-algorithms-book](https://github.com/fkereki/data-structures-and-algorithms-book).'
  prefs: []
  type: TYPE_NORMAL
