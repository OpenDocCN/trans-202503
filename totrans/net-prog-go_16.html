<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_269" title="269"/>12</span><br/>&#13;
<span class="ChapterTitle">Data Serialization</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">A sizable portion of our work as developers involves integrating our network services with existing services, including legacy or third-party ones implemented in languages other than Go. These services must communicate by exchanging bytes of data in a way that is meaningful to both the sender and receiver, despite the different programming languages they’re using. To do this, the sender converts data into bytes using a standard format and transfers the bytes over the network to the receiver. If the receiver understands the format used by the sender, it can convert the bytes back into structured data. This process of transforming structured data into successive bytes is known as <em>data serialization</em>. </p>&#13;
<p><span epub:type="pagebreak" id="Page_270" title="270"/>Services can use data serialization to convert structured data to a series of bytes suitable for transport over a network or for persistence to storage. No matter whether the serialized data came from a network or disk, any code that understands the serialization format should be able to deserialize it to reconstruct a clone of the original object.</p>&#13;
<p>While writing this chapter, I initially struggled to explain the concept of data serialization. Then I realized we serialize data as we speak. Electrical impulses in my brain form words. My brain instructs my voice box to <em>serialize</em> these words into sound waves, which travel through the air and reach your ear. The sound waves vibrate your eardrum, which in turn transmits the vibrations to your inner ear. Hair-like structures in your inner ear deserialize these vibrations into electrical signals that your brain interprets as the original words I formed in my brain. We’ve just communicated using the serialization format of English, since it’s a format we both understand. </p>&#13;
<p>You already have a bit of experience serializing data in your Go code too. The type-length-value binary encoding you learned in Chapter 4 and the JavaScript Object Notation (JSON) you posted over HTTP in Chapter 8 are examples of translating objects into well-known data serialization formats. We also PEM-encoded the certificates and private keys in Chapter 11 for persistence to disk.</p>&#13;
<p>This chapter will take a deeper dive into using data serialization for the purposes of storing data or sending between systems, which can make it accessible to services written in other languages. We could cover many data serialization formats, but we’ll focus on the three that get the most use in Go network programming: JSON, protocol buffers, and Gob. We’ll also spend some time on how to execute code on remote machines using a framework named gRPC. By the end of this chapter, you will know how to serialize data for storage or transmission and decode that data into meaningful data structures. You should be able to use techniques in this chapter to build services that can exchange complex data over a network or write code to communicate with existing network services.</p>&#13;
<h2 id="h1-500884c12-0001">Serializing Objects</h2>&#13;
<p class="BodyFirst">Objects or structured data cannot traverse a network connection as is. In other words, you cannot pass in an object to <code>net.Conn</code>’s <code>Write</code> method, since it accepts only a byte slice. Therefore, you need to serialize the object to a byte slice, which you can then pass to the <code>Write</code> method. Thankfully, Go makes this easy.</p>&#13;
<p>Go’s standard library includes excellent support for popular data serialization formats in its <code>encoding</code> package. You’ve already used <code>encoding/binary</code> to serialize numbers into byte sequences, <code>encoding/json</code> to serialize objects into JSON for submission over HTTP, and <code>encoding/pem</code> to serialize TLS certificates and private keys to files. (Anytime you encounter a function or method whose name includes <em>encode</em> or <em>marshal</em>, it likely serializes data. Likewise, <em>decode</em> and <em>unmarshal</em> are synonymous with deserializing data.) </p>&#13;
<p><span epub:type="pagebreak" id="Page_271" title="271"/>This section will build an application that serializes data into three binary encoding formats: JSON, protocol buffers, and Gob. Since I often have trouble keeping track of housework, the application will document chores to do around the house. The application’s state will persist between executions because you don’t want it to forget the chores when it exits. You’ll serialize each task to a file and use your app to update it as needed. </p>&#13;
<p>To keep this program simple, you need a description of the chore and a way to determine whether it’s complete. <a href="#listing12-1" id="listinganchor12-1">Listing 12-1</a> defines a new package with a type that represents a household chore.</p>&#13;
<pre><code>package housework&#13;
&#13;
type Chore struct {&#13;
    Complete    bool&#13;
    Description string&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-1">Listing 12-1</a>: A type to represent a household chore (<em>housework/housework.go</em>)</p>&#13;
<p>Go’s JSON and Gob encoding packages can serialize exported struct fields only, so you define <code>Chore</code> as a struct, making sure to export its fields. The <code>Complete</code> field’s value will be <code>true</code> if you’ve completed the chore. The <code>Description</code> field is the human-readable description of the chore. </p>&#13;
<p>You could use struct tags to instruct the encoders on how to treat each field, if necessary. For example, you could place the struct tag <code>`json:"-"`</code> on the <code>Complete</code> field to tell Go’s JSON encoder to ignore this field instead of encoding it. Since you’re perfectly happy to pass along all field values, you omit struct tags.</p>&#13;
<p>Once you’ve defined a chore structure, you can use it in an application that tracks chores on the command line. This application should show a list of chores and their status, allow you to add chores to the list, and mark chores as complete. <a href="#listing12-2" id="listinganchor12-2">Listing 12-2</a> includes the initial code for this housework application, including its command line usage details.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "flag"&#13;
    "fmt"&#13;
    "log"&#13;
    "os"&#13;
    "path/filepath"&#13;
    "strconv"&#13;
    "strings"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch12/housework"&#13;
 <span class="CodeAnnotation">1</span> storage "github.com/awoodbeck/gnp/ch12/json"&#13;
    // storage "github.com/awoodbeck/gnp/ch12/gob"&#13;
    // storage "github.com/awoodbeck/gnp/ch12/protobuf"&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="Page_272" title="272"/>var dataFile string&#13;
&#13;
func init() {&#13;
    flag.StringVar(&amp;dataFile, "file", "housework.db", "data file")&#13;
&#13;
    flag.Usage = func() {&#13;
        fmt.Fprintf(flag.CommandLine.Output(),&#13;
         <span class="CodeAnnotation">2</span> `Usage: %s [flags] [add chore, ...|complete #]&#13;
    add         add comma-separated chores&#13;
    complete    complete designated chore&#13;
&#13;
Flags:&#13;
`, filepath.Base(os.Args[0]))&#13;
        flag.PrintDefaults()&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-2">Listing 12-2</a>: Initial housework application code (<em>cmd/housework.go</em>)</p>&#13;
<p>This bit of code sets up the command line arguments and their usage <span class="CodeAnnotation">2</span>: you can specify the <code>add</code> argument, followed by a comma-separated list of chores to add to the list, or you can pass the argument <code>complete</code> and a chore number to mark the chore as complete. In the absence of command line options, the app will display the current list of chores.</p>&#13;
<p>Since the ultimate purpose of this application is to demonstrate data serialization, you’ll use multiple serialization formats to store the data. This should show you how easy it is to switch between various formats. To prepare for that, you include <code>import</code> statements for those formats <span class="CodeAnnotation">1</span>. This will make it easier for you to switch between the formats later.</p>&#13;
<p>Let’s write the code to load chores from storage (see <a href="#listing12-3" id="listinganchor12-3">Listing 12-3</a>).</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func load() ([]*housework.Chore, error) {&#13;
    if _, err := os.Stat(dataFile); <span class="CodeAnnotation">1</span>os.IsNotExist(err) {&#13;
        return make([]*housework.Chore, 0), nil&#13;
    }&#13;
&#13;
    df, err := <span class="CodeAnnotation">2</span>os.Open(dataFile)&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
    defer func() {&#13;
        if err := df.Close(); err != nil {&#13;
            fmt.Printf("closing data file: %v", err)&#13;
        }&#13;
    }()&#13;
&#13;
    return <span class="CodeAnnotation">3</span>storage.Load(df)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-3">Listing 12-3</a>: Deserializing chores from a file (<em>cmd/housework.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_273" title="273"/>This function returns a slice of pointers to <code>housework.Chore</code> structs from <a href="#listing12-1">Listing 12-1</a>. If the data file does not exist <span class="CodeAnnotation">1</span>, you exit early, returning an empty slice. This default case will occur when you first run the application.</p>&#13;
<p>If the app finds a data file, you open it <span class="CodeAnnotation">2</span> and pass it along to the storage’s <code>Load</code> function <span class="CodeAnnotation">3</span>, which expects an <code>io.Reader</code>. You used the same pattern of accepting an interface and returning a concrete type in previous chapters.</p>&#13;
<p><a href="#listing12-4" id="listinganchor12-4">Listing 12-4</a> defines a function that flushes the chores in memory to your storage for persistence.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func flush(chores []*housework.Chore) error {&#13;
    df, err := <span class="CodeAnnotation">1</span>os.Create(dataFile)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    defer func() {&#13;
        if err := df.Close(); err != nil {&#13;
            fmt.Printf("closing data file: %v", err)&#13;
        }&#13;
    }()&#13;
&#13;
    return <span class="CodeAnnotation">2</span>storage.Flush(df, chores)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-4">Listing 12-4</a>: Flushing chores to the storage (<em>cmd/housework.go</em>)</p>&#13;
<p>Here, you create a new file or truncate the existing file <span class="CodeAnnotation">1</span> and pass the file pointer and slice of chores to the storage’s <code>Flush</code> function <span class="CodeAnnotation">2</span>. This function accepts an <code>io.Writer</code> and your slice. There’s certainly room for improvement in the way you handle the existing serialized file. But for the purposes of demonstration, this will suffice.</p>&#13;
<p>You need a way to display the chores on the command line. <a href="#listing12-5" id="listinganchor12-5">Listing 12-5</a> adds such a function to your application.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func list() error {&#13;
    chores, err := <span class="CodeAnnotation">1</span>load()&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    if len(chores) == 0 {&#13;
        fmt.Println("You're all caught up!")&#13;
        return nil&#13;
    }&#13;
&#13;
    fmt.Println("#\t[X]\tDescription")&#13;
    for i, chore := range chores {&#13;
        c := " "&#13;
<span epub:type="pagebreak" id="Page_274" title="274"/>        if chore.Complete {&#13;
            c = "X"&#13;
        }&#13;
        fmt.Printf("%d\t[%s]\t%s\n", i+1, c, chore.Description)&#13;
    }&#13;
&#13;
    return nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-5">Listing 12-5</a>: Printing the list of chores to standard output (<em>cmd/housework.go</em>)</p>&#13;
<p>First, you load the list of chores from storage <span class="CodeAnnotation">1</span>. If there are no chores in your list, you simply print as much to standard output. Otherwise, you print a header and the list of chores, which looks something like this (see <a href="#listing12-6" id="listinganchor12-6">Listing 12-6</a>).</p>&#13;
<pre><code>#       [X]     Description&#13;
1       [ ]     Mop floors&#13;
2       [ ]     Clean dishes&#13;
3       [ ]     Mow the lawn</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-6">Listing 12-6</a>: Example output of the list function with three chores in the list</p>&#13;
<p>The first column represents the chore number. You can reference this number to mark the chore complete, which will add an X between its brackets in the second column. The third column describes the chore.</p>&#13;
<p><a href="#listing12-7" id="listinganchor12-7">Listing 12-7</a> implements the <code>add</code> function, which allows you to add chores to the list.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func add(s string) error {&#13;
    chores, err := <span class="CodeAnnotation">1</span>load()&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    for _, chore := range <span class="CodeAnnotation">2</span>strings.Split(s, ",") {&#13;
        if desc := strings.TrimSpace(chore); desc != "" {&#13;
            chores = append(chores, &amp;housework.Chore{&#13;
                Description: desc,&#13;
            })&#13;
        }&#13;
    }&#13;
&#13;
    return <span class="CodeAnnotation">3</span>flush(chores)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-7">Listing 12-7</a>: Adding chores to the list (<em>cmd/housework.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_275" title="275"/>Unlike a long-running service, this application’s lifetime starts when you execute it on the command line and ends when it completes whatever task you ask it to perform. Therefore, because you want your list of chores to persist between executions of the application, you need to store the chore state on disk. In other words, you retrieve the chores from storage <span class="CodeAnnotation">1</span>, modify them, and flush the changes to storage <span class="CodeAnnotation">3</span>. The changes persist until the next time you run the app.</p>&#13;
<p>You want the option to add more than one chore at a time, so you split the incoming chore description by commas <span class="CodeAnnotation">2</span> and append each chore to the slice. Granted, this keeps you from using commas in individual chore descriptions, so the members of your household will have to keep their requests short (which isn’t all bad, in my opinion). As an exercise, figure out a way around this limitation. One approach may be to use a different delimiter, but keep in mind, whatever you choose as a delimiter may have significance on the command line. Another approach may be to add support for quoted strings containing commas.</p>&#13;
<p>The last piece of this puzzle is my favorite part about working on chores: marking them as complete (see <a href="#listing12-8" id="listinganchor12-8">Listing 12-8</a>).</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func complete(s string) error {&#13;
    i, err := strconv.Atoi(s)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    chores, err := load()&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    if i &lt; 1 || i &gt; len(chores) {&#13;
        return fmt.Errorf("chore %d not found", i)&#13;
    }&#13;
&#13;
 <span class="CodeAnnotation">1</span> chores[i-1].Complete = true&#13;
&#13;
    return flush(chores)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-8">Listing 12-8</a>: Marking a chore as complete (<em>cmd/housework.go</em>)</p>&#13;
<p>The <code>complete</code> function accepts the command line argument representing the chore you want to complete and converts it to an integer. I find I’m more efficient if I perform tasks one by one, so I’ll have you mark only one complete at a time. You then load the chores from storage and make sure the integer is within range. If so, you mark the chore complete. Since you’re <span epub:type="pagebreak" id="Page_276" title="276"/>numbering chores starting with 1 when displaying the list, you need to account for placement in the slice by subtracting 1 <span class="CodeAnnotation">1</span>. Finally, you flush the chores to storage.</p>&#13;
<p>Now, let’s tie everything together by implementing the app’s <code>main</code> function in <a href="#listing12-9" id="listinganchor12-9">Listing 12-9</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    var err error&#13;
&#13;
    switch strings.ToLower(flag.Arg(0)) {&#13;
    case "add":&#13;
        err = add(strings.Join(flag.Args()[1:], " "))&#13;
    case "complete":&#13;
        err = complete(flag.Arg(1))&#13;
    }&#13;
&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    err = list()&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-9">Listing 12-9</a>: The main logic of the housework application (<em>cmd/housework.go</em>)</p>&#13;
<p>You’ve put as much logic in the previous functions as possible, so this <code>main</code> function is quite minimal. You check the first argument to determine whether it’s an expected subcommand. If so, you call the appropriate function. You call the <code>list</code> function if <code>err</code> is still nil after accounting for the optional subcommand and its arguments.</p>&#13;
<p>All that’s left to do now is implement the storage <code>Load</code> and <code>Flush</code> functions for JSON, Gob, and protocol buffers.</p>&#13;
<h3 id="h2-500884c12-0001">JSON</h3>&#13;
<p class="BodyFirst">JSON is a common, human-readable, text-based data serialization format that uses key-value pairs and arrays to represent complex data structures. Most contemporary languages offer official library support for JSON, which is one reason it’s the customary encoding format for RESTful APIs.</p>&#13;
<p>JSON’s types include strings, Booleans, numbers, arrays, key-value objects, and nil values specified by the keyword <em>null</em>. JSON numbers do not differentiate between floating-points and integers. You can read more about Go’s JSON implementation at <a href="https://blog.golang.org/json">https://blog.golang.org/json</a>.</p>&#13;
<p><span epub:type="pagebreak" id="Page_277" title="277"/>Let’s look at what the contents of the <em>housework.db</em> file would be if we JSON-encoded the chores from <a href="#listing12-6">Listing 12-6</a>. I’ve formatted the JSON for easier reading in <a href="#listing12-10" id="listinganchor12-10">Listing 12-10</a>, though you could use the encoder’s <code>SetIndent</code> method to do it for you.</p>&#13;
<pre><code><span class="CodeAnnotation">1</span>[&#13;
<span class="CodeAnnotation">2</span> {&#13;
    "Complete": false,&#13;
    "Description": "Mop floors"&#13;
  },&#13;
  {&#13;
    "Complete": false,&#13;
    "Description": "Clean dishes"&#13;
  },&#13;
  {&#13;
    "Complete": false,&#13;
    "Description": "Mow the lawn"&#13;
  }&#13;
]</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-10">Listing 12-10</a>: Formatted contents of the <em>housework.db</em> file after serializing the chores to JSON</p>&#13;
<p>As you can see, the JSON is an array of objects <span class="CodeAnnotation">1</span>, and each object <span class="CodeAnnotation">2</span> includes <code>Complete</code> and <code>Description</code> fields and corresponding values.</p>&#13;
<p><a href="#listing12-11" id="listinganchor12-11">Listing 12-11</a> details the JSON storage implementation using Go’s <code>encoding/json</code> package.</p>&#13;
<pre><code>package json&#13;
&#13;
import (&#13;
    "encoding/json"&#13;
    "io"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch12/housework"&#13;
)&#13;
&#13;
func Load(r io.Reader) ([]*housework.Chore, error) {&#13;
    var chores []*housework.Chore&#13;
&#13;
    return chores, <span class="CodeAnnotation">1</span>json.NewDecoder(r).Decode(&amp;chores)&#13;
}&#13;
&#13;
func Flush(w io.Writer, chores []*housework.Chore) error {&#13;
    return <span class="CodeAnnotation">2</span>json.NewEncoder(w).Encode(chores)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-11">Listing 12-11</a>: JSON storage implementation (<em>json/housework.go</em>)</p>&#13;
<p>The <code>Load</code> function passes the <code>io.Reader</code> to the <code>json.NewDecoder</code> function <span class="CodeAnnotation">1</span> and returns a decoder. You then call the decoder’s <code>Decode</code> method, passing it a pointer to the <code>chores</code> slice. The decoder reads JSON from the <code>io.Reader</code>, deserializes it, and populates the <code>chores</code> slice.</p>&#13;
<p><span epub:type="pagebreak" id="Page_278" title="278"/>The <code>Flush</code> function accepts an <code>io.Writer</code> and a <code>chores</code> slice. It then passes the <code>io.Writer</code> to the <code>json.NewEncoder</code> function <span class="CodeAnnotation">2</span>, which returns an encoder. You pass the <code>chores</code> slice to the encoder’s <code>Encode</code> function, which serializes the <code>chores</code> slice into JSON and writes it to the <code>io.Writer</code>.</p>&#13;
<p>Now that you’ve implemented a JSON package that can serve as storage for your application, let’s try it out in <a href="#listing12-12" id="listinganchor12-12">Listing 12-12</a>.</p>&#13;
<pre><code>$ <b>go run cmd/housework.go</b>&#13;
You're all caught up!&#13;
$ <b>go run cmd/housework.go add Mop floors, Clean dishes, Mow the lawn</b>&#13;
#       [X]     Description&#13;
1       [ ]     Mop floors&#13;
2       [ ]     Clean dishes&#13;
3       [ ]     Mow the lawn&#13;
$ <b>go run cmd/housework.go complete 2</b>&#13;
#       [X]     Description&#13;
1       [ ]     Mop floors&#13;
2       [X]     Clean dishes&#13;
3       [ ]     Mow the lawn&#13;
$ <b>cat housework.db</b>&#13;
[{"Complete":false,"Description":"Mop floors"},&#13;
{"Complete":true,"Description":"Clean dishes"},&#13;
{"Complete":false,"Description":"Mow the lawn"}]</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-12">Listing 12-12</a>: Testing the housework application with JSON storage on the command line</p>&#13;
<p>Your first execution of the app lets you know you have nothing in your list of chores. You then add three comma-separated chores and complete the second one. Looks good. Notice also that the <em>housework.db</em> file contains readable JSON (to see this on Windows, use the <code>type</code> command instead of <code>cat</code>). Let’s modify this application to use a binary encoding format native to Go.</p>&#13;
<h3 id="h2-500884c12-0002">Gob</h3>&#13;
<p class="BodyFirst"><em>Gob</em>, as in “gobs of binary data,” is a binary serialization format native to Go. Engineers on the Go team developed Gob to combine the efficiency of protocol buffers, arguably the most popular binary serialization format, with JSON’s ease of use. For example, protocol buffers don’t let us simply instantiate a new encoder and throw data structures at it, as you did in the JSON example in <a href="#listing12-11">Listing 12-11</a>. On the other hand, Gob functions much the same way as the JSON encoder, in that Gob can intelligently infer an object’s structure and serialize it. </p>&#13;
<p>If you’re interested in exploring the motivation and finer points of Gob, give Rob Pike’s “Gobs of Data” blog post a read (<a href="https://blog.golang.org/gob">https://blog.golang.org/gob</a>). In the meantime, let’s implement our storage backend in Gob (see <a href="#listing12-13" id="listinganchor12-13">Listing 12-13</a>).</p>&#13;
<pre><code>package gob&#13;
&#13;
import (&#13;
    "encoding/gob"&#13;
    "io"&#13;
&#13;
<span epub:type="pagebreak" id="Page_279" title="279"/>    "github.com/awoodbeck/gnp/ch12/housework"&#13;
)&#13;
&#13;
func Load(r io.Reader) ([]*housework.Chore, error) {&#13;
    var chores []*housework.Chore&#13;
&#13;
    return chores, gob.NewDecoder(r).Decode(&amp;chores)&#13;
}&#13;
&#13;
func Flush(w io.Writer, chores []*housework.Chore) error {&#13;
    return gob.NewEncoder(w).Encode(chores)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-13">Listing 12-13</a>: Gob storage implementation (<em>gob/housework.go</em>)</p>&#13;
<p>If you’re looking at this code and observing that it replaces all occurrences of <code>json</code> from <a href="#listing12-11">Listing 12-11</a> with <code>gob</code>, you’re not wrong. In Go, Gob is as easy to use as JSON, since it infers what it needs to encode from the object itself. You’ll see how this differs from protocol buffers in the next section.</p>&#13;
<p>All that’s left to do is swap out the JSON storage implementation for the Gob one by modifying the imports from <a href="#listing12-2">Listing 12-2</a> (<a href="#listing12-14" id="listinganchor12-14">Listing 12-14</a>).</p>&#13;
<pre><code><var>--snip--</var>&#13;
    "github.com/awoodbeck/gnp/ch12/housework"&#13;
 <span class="CodeAnnotation">1</span> // storage "github.com/awoodbeck/gnp/ch12/json"&#13;
 <span class="CodeAnnotation">2</span> storage "github.com/awoodbeck/gnp/ch12/gob"&#13;
    // storage "github.com/awoodbeck/gnp/ch12/protobuf"&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-14">Listing 12-14</a>: Swapping the JSON storage package for the Gob storage package (<em>cmd/housework.go</em>)</p>&#13;
<p>Comment out the JSON storage package import <span class="CodeAnnotation">1</span> in <a href="#listing12-2">Listing 12-2</a> and uncomment the Gob storage package one <span class="CodeAnnotation">2</span>. </p>&#13;
<p>Since your current <em>housework.db</em> file contains JSON, it isn’t compatible with Gob. Therefore, the housework application will throw an error when attempting to decode it using Gob. Remove the <em>housework.db</em> file and retest the application (see <a href="#listing12-15" id="listinganchor12-15">Listing 12-15</a>).</p>&#13;
<pre><code>$ <b>rm housework.db</b>&#13;
$ <b>go run cmd/housework.go</b>&#13;
You're all caught up!&#13;
$ <b>go run cmd/housework.go add Mop floors, Clean dishes, Mow the lawn</b>&#13;
#       [X]     Description&#13;
1       [ ]     Mop floors&#13;
2       [ ]     Clean dishes&#13;
3       [ ]     Mow the lawn&#13;
$ <b>go run cmd/housework.go complete 2</b>&#13;
#       [X]     Description&#13;
1       [ ]     Mop floors&#13;
2       [X]     Clean dishes&#13;
3       [ ]     Mow the lawn&#13;
$ <b>hexdump -c housework.db</b>&#13;
0000000  \r 377 203 002 001 002 377 204  \0 001 377 202  \0  \0   ) 377&#13;
<span epub:type="pagebreak" id="Page_280" title="280"/>0000010 201 003 001 002 377 202  \0 001 002 001  \b   C   o   m   p   l&#13;
0000020   e   t   e 001 002  \0 001  \v   D   e   s   c   r   i   p   t&#13;
0000030   i   o   n 001  \f  \0  \0  \0   1 377 204  \0 003 002  \n   M&#13;
0000040   o   p       f   l   o   o   r   s  \0 001 001 001  \f   C   l&#13;
0000050   e   a   n       d   i   s   h   e   s  \0 002  \f   M   o   w&#13;
0000060       t   h   e       l   a   w   n  \0                        &#13;
000006a</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-15">Listing 12-15</a>: Testing the housework application with Gob storage on the command line</p>&#13;
<p>Everything still works as expected. Using the <code>hexdump</code> tool, you can see that the <em>housework.db</em> file now includes binary data. It’s certainly not human-readable as JSON was in <a href="#listing12-12">Listing 12-12</a>, but Go happily deserializes the Gob-encoded data, even though it’s harder for us to make sense of it. (My Windows friends can find a <code>hexdump</code> binary at <em>https://www.di-mgt.com.au/hexdump-for-windows.html</em>, though you’ll have to use the <code>-C</code> flag to get the same effect.)</p>&#13;
<p>If you are communicating with other Go services that support Gob, I recommend you use Gob over JSON. Go’s <code>encoding/gob</code> is more performant than <code>encoding/json</code>. Gob encoding is also more succinct, in that Gob uses less data to represent objects than JSON does. This can make a difference when storing or transmitting serialized data</p>&#13;
<p>Now that you have a taste for serializing data using <code>encoding/json</code> and <code>encoding/gob</code>, let’s add protocol buffer support to your storage backend.</p>&#13;
<h3 id="h2-500884c12-0003">Protocol Buffers</h3>&#13;
<p class="BodyFirst">Like Gob, <em>protocol buffers</em> use binary encoding to store or exchange information across various platforms. It’s faster and more succinct than Go’s JSON encoding. Unlike Gob and like JSON, protocol buffers are language neutral and enjoy wide support among popular programming languages. This makes them ideally suited for using in Go-based services that you hope to integrate with services written in other programming languages. This chapter assumes you’re using the <em>proto3</em> version of the format.</p>&#13;
<p>Protocol buffers use a definition file, conventionally suffixed with <em>.proto</em>, to define messages. <em>Messages</em> describe the structured data you want to serialize for storage or transmission. For example, a protocol buffer message representing the <code>Chore</code> type looks like the definition in <a href="#listing12-16" id="listinganchor12-16">Listing 12-16</a>.</p>&#13;
<pre><code>message Chore {&#13;
  bool complete = 1;&#13;
  string description = 2;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-16">Listing 12-16</a>: Protocol buffer message definition representing a <var>Chore</var> type</p>&#13;
<p>You define a new message by using the <code>message</code> keyword, followed by the unique name of the message. Convention dictates you use Pascal case. (<em>Pascal casing</em> is a style of code formatting in which you concatenate capitalized words: <em>ThisIsPascalCasing</em>.) You then add fields to the <code>Chore</code> message. Each field definition includes a type, a snake-cased name, and a field number unique to <span epub:type="pagebreak" id="Page_281" title="281"/>the message. (<em>Snake casing</em> is like Pascal casing except the first word is lowercase: <em>thisIsSnakeCasing</em>.) The field’s type and number identify the field in the binary payload, so these must not change once used or you’ll break backward compatibility. However, it’s fine to add new messages and message fields to an existing <em>.proto</em> file.</p>&#13;
<p>Speaking of backward compatibility, it’s a good practice to treat your protocol buffer definitions as you would an API. If third parties use your protocol buffer definition to communicate with your service, consider versioning your definition; this allows you to create new versions anytime you need to break backward compatibility. Your development can move forward with the latest version while clients continue to use the previous version until they’re ready to target the latest version. You’ll see one method of versioning the protocol buffer definitions later in this section.</p>&#13;
<p>You’ll have to compile the <em>.proto</em> file to generate Go code from it. This code allows you to serialize and deserialize the messages defined in the <em>.proto</em> file. Third parties that want to exchange messages with you can use the same <em>.proto</em> file to generate code for their target programming language. The resulting code can exchange messages with you too. Therefore, before you can start using protocol buffers in earnest, you must install the protocol buffer compiler and its Go generation module. Your operating system’s package manager may allow you to easily install the protocol buffer compiler. For example, on Debian 10, run the following:</p>&#13;
<pre><code>$ <b>sudo apt install protobuf-compiler</b></code></pre>&#13;
<p>On macOS with Homebrew, run this:</p>&#13;
<pre><code>$ <b>brew install protobuf</b></code></pre>&#13;
<p>On Windows, download the latest protocol buffer compiler ZIP file from <a href="https://github.com/protocolbuffers/protobuf/releases/">https://github.com/protocolbuffers/protobuf/releases/</a>, extract it, and add its <em>bin</em> subdirectory to your <code>PATH</code>. You should now be able to run the <em>protoc</em> binary on your command line.</p>&#13;
<p>A simple <code>go get</code> will install the protocol buffer’s Go generator on your system. Make sure you have the resulting <em>protoc-gen-go</em> binary in your <code>PATH</code> or <em>protoc</em> won’t recognize the plug-in:</p>&#13;
<pre><code>$ <b>GO111MODULE=on go get -u github.com/golang/protobuf/protoc-gen-go</b></code></pre>&#13;
<p>Now that you’ve installed the protocol buffer compiler and Go generation module, let’s create a new <em>.proto</em> file for your housework application (see <a href="#listing12-17" id="listinganchor12-17">Listing 12-17</a>). You’ll create this file in <em>housework/v1/housework.proto</em>. The <code>v1</code> in the path stands for <em>version 1</em> and allows you to introduce future versions of this package.</p>&#13;
<pre><code><span class="CodeAnnotationHang">1</span> syntax = "proto3";&#13;
<span class="CodeAnnotationHang">2</span> package housework;&#13;
&#13;
<span class="CodeAnnotationHang">3</span> option go_package = "github.com/awoodbeck/gnp/ch12/housework/v1/housework";&#13;
&#13;
<span epub:type="pagebreak" id="Page_282" title="282"/>message Chore {&#13;
  bool complete = 1;&#13;
  string description = 2;&#13;
}&#13;
&#13;
message Chores {&#13;
<span class="CodeAnnotation">4</span>repeated Chore chores = 1;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-17">Listing 12-17</a>: Protocol buffer definition for your housework application (<em>housework/v1/housework.proto</em>)</p>&#13;
<p>First, you specify that you’re using the proto3 syntax <span class="CodeAnnotation">1</span> and that you want any generated code to have the package name <code>housework</code><span class="CodeAnnotation">2</span>. Next, you add a <code>go_package</code> option <span class="CodeAnnotation">3</span> with the full import path of the generated module. Then you define the <code>Chore</code> message and a second message named <code>Chores</code> that represents a collection of <code>Chore</code> messages based on the <code>repeated</code> field type <span class="CodeAnnotation">4</span>.</p>&#13;
<p>Now, let’s compile the <em>.proto</em> file to Go code:</p>&#13;
<pre><code>$ <b>protoc </b><span class="CodeAnnotation">1</span><b>--go_out=. </b><span class="CodeAnnotation">2</span><b>--go_opt=paths=source_relative housework/v1/housework.proto</b></code></pre>&#13;
<p>You call <em>protoc</em> with flags indicating you want to generate Go code <span class="CodeAnnotation">1</span> from the <em>housework/v1/housework.proto</em> file you created in <a href="#listing12-17">Listing 12-17</a> and output the generated code to the <em>.proto</em> file’s current directory, with relative paths <span class="CodeAnnotation">2</span>.</p>&#13;
<p>If you receive the following error indicating <em>protoc</em> cannot find the <em>protoc-gen-go</em> binary, make sure <em>protoc-gen-go</em>’s location (likely <em>$GOPATH/bin</em>) is in your <code>PATH</code> environment variable:</p>&#13;
<pre><code>protoc-gen-go: program not found or is not executable&#13;
--go_out: protoc-gen-go: Plugin failed with status code 1.</code></pre>&#13;
<p>If <em>protoc</em> is happy with the <em>.proto</em> file and successfully generated the Go code, you’ll find that a new file named <em>housework/v1/housework.pb.go</em> exists with these first few lines, though the version numbers may differ. I’ll use the <code>head</code> command on Linux/macOS to print the first seven lines:</p>&#13;
<pre><code>$ <b>head -n 7 housework/v1/housework.pb.go</b>&#13;
// Code generated by protoc-gen-go. DO NOT EDIT.&#13;
// versions:&#13;
//      protoc-gen-go v1.25.0&#13;
//      protoc        v3.6.1&#13;
// source: housework/v1/housework.proto&#13;
&#13;
package housework</code></pre>&#13;
<p>As the comments indicate, you shouldn’t edit this module. Instead, make any necessary changes to the <em>.proto</em> file and recompile it.</p>&#13;
<p><span epub:type="pagebreak" id="Page_283" title="283"/>Now that you’ve generated a Go module from the <em>.proto</em> file, you can put it to effective use in <a href="#listing12-18" id="listinganchor12-18">Listing 12-18</a> by implementing your storage backend with protocol buffers.</p>&#13;
<pre><code>package protobuf&#13;
&#13;
import (&#13;
    "io"&#13;
    "io/ioutil"&#13;
&#13;
    "google.golang.org/protobuf/proto"&#13;
&#13;
 <span class="CodeAnnotation">1</span> "github.com/awoodbeck/gnp/ch12/housework/v1"&#13;
)&#13;
&#13;
func Load(r io.Reader) ([]*housework.Chore, error) {&#13;
    b, err := ioutil.ReadAll(r)&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    var chores housework.Chores&#13;
&#13;
    return chores.Chores, proto.Unmarshal(b, &amp;chores)&#13;
}&#13;
&#13;
func Flush(w io.Writer, chores []*housework.Chore) error {&#13;
    b, err := proto.Marshal(<span class="CodeAnnotation">2</span>&amp;housework.Chores{Chores: chores})&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    _, err = w.Write(b)&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-18">Listing 12-18</a>: Protocol buffers storage implementation (<em>protobuf/housework.go</em>)</p>&#13;
<p>Instead of relying on the <code>housework</code> package from <a href="#listing12-1">Listing 12-1</a>, as you did when working with JSON and Gob, you import version 1 of the <em>protoc</em>-generated package, which you also named <code>housework</code><span class="CodeAnnotation">1</span>. The generated <code>Chores</code> type <span class="CodeAnnotation">2</span> is a struct with a <code>Chores</code> field, which itself is a slice of <code>Chore</code> pointers. Also, Go’s protocol buffers package doesn’t implement encoders and decoders. Therefore, you must marshal objects to bytes, write them to the <code>io.Writer</code>, and unmarshal bytes from the <code>io.Reader</code> yourself.</p>&#13;
<p>Revisit the code in <a href="#listing12-2">Listing 12-2</a> and plug in the protocol buffers implementation with the two simple changes shown in <a href="#listing12-19" id="listinganchor12-19">Listing 12-19</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
 <span class="CodeAnnotation">1</span> "github.com/awoodbeck/gnp/ch12/housework/v1"&#13;
    // storage "github.com/awoodbeck/gnp/ch12/json"&#13;
<span epub:type="pagebreak" id="Page_284" title="284"/>    // storage "github.com/awoodbeck/gnp/ch12/gob"&#13;
 <span class="CodeAnnotation">2</span> storage "github.com/awoodbeck/gnp/ch12/protobuf"&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-19">Listing 12-19</a>: Swapping the JSON storage package for the <var>protobuf</var> storage package (<em>cmd/housework.go</em>)</p>&#13;
<p>You replace the housework package from <a href="#listing12-1">Listing 12-1</a> with your generated package <span class="CodeAnnotation">1</span>, make sure to comment out the <code>json</code> and <code>gob</code> imports, and uncomment the <code>protobuf</code> storage import <span class="CodeAnnotation">2</span>. The actual functionality of the housework application remains unchanged.</p>&#13;
<h2 id="h1-500884c12-0002">Transmitting Serialized Objects</h2>&#13;
<p class="BodyFirst">Although you may sometimes need to serialize and store objects locally, you’re more likely to build a network service that serializes data. For example, an online store may have a web service that communicates with inventory, user accounting, billing, shipping, and notification services to facilitate customer orders. If these services ran on the same server, you’d have to buy a larger server to scale the online store as business grows. Another approach would be to run each service on its own server and increase the number of servers. But then you’d have a new problem: how can you share data among services when they no longer reside on a single server and so can’t access the same memory? </p>&#13;
<p>Large technology companies facilitate this with <em>remote procedure calls (RPCs)</em>, a technique by which a client can transparently call a subroutine on a server as if the call were local. From your application’s perspective, RPC services take code that appears to run locally and distribute it over a network. Your code may call a function that transparently relays a message to a server. The server would locally execute the function, then respond with the results, which your code receives as the function’s return value. As far as your code is concerned, the function call is local, despite RPC’s transparent interaction with the server. This approach allows you to scale services across servers while abstracting the details away from your code. In other words, your code functions the same no matter whether the function call runs on the same computer or on one over the network.</p>&#13;
<p>Most companies now implement RPC with <em>gRPC</em>, a cross-platform framework that leverages HTTP/2 and protocol buffers. Let’s use it here to build something more sophisticated than an app to keep track of the housework you have yet to do. You’ll write a service that can send tasks to Rosie, the robotic maid from the classic animated series <em>The Jetsons</em>, who can take over your domestic responsibilities. Granted, she won’t be available until the year 2062, but you can get a head start on the code.</p>&#13;
<h3 id="h2-500884c12-0004">Connecting Services with gRPC</h3>&#13;
<p class="BodyFirst">The gRPC framework is a collection of libraries that abstracts many of the RPC implementation details. It is platform neutral and programming-language agnostic; you can use it to integrate a Go service running on <span epub:type="pagebreak" id="Page_285" title="285"/>Windows with a Rust service running on Linux, for example. Now that you know how to work with protocol buffers, you have the foundation needed to add gRPC support to your application. You’ll reuse the <em>.proto </em>file from the previous section.</p>&#13;
<p>First, make sure your gRPC package is up-to-date:</p>&#13;
<pre><code>$ <b>go get -u google.golang.org/grpc</b></code></pre>&#13;
<p>Next, get the appropriate module for generating gRPC Go code:</p>&#13;
<pre><code>$ <b>go get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc</b></code></pre>&#13;
<p>The protocol buffer compiler includes a gRPC module. This module will output Go code that lets you easily add gRPC support. First, you need to add definitions to the <em>.proto</em> file. <a href="#listing12-20" id="listinganchor12-20">Listing 12-20</a> defines a new service and two additional messages.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
service RobotMaid {&#13;
<span class="CodeAnnotationHang">1</span>   rpc Add (Chores) returns (Response);&#13;
  rpc Complete (CompleteRequest) returns (Response);&#13;
  rpc List (Empty) returns (Chores);&#13;
}&#13;
&#13;
message CompleteRequest {&#13;
  int32 <span class="CodeAnnotation">2</span>chore_number = 1;&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang">3</span> message Empty {}&#13;
&#13;
message Response {&#13;
  string message = 1;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-20">Listing 12-20</a>: Additional definitions to support a gRPC RobotMaid service (<em>housework/v1/housework.proto</em>)</p>&#13;
<p>The service needs to support the same three calls you used on the command line: <code>add</code>, <code>complete</code>, and <code>list</code>. You define a new service named <code>RobotMaid</code>, then add three RPC methods to it. These RPC methods correspond to the functions defined in Listings 12-5, 12-7, and 12-8 for use on the command line: the <code>list</code>, <code>add</code>, and <code>complete</code> functions, respectively. Instead of calling these functions locally, you’ll call the corresponding method on the <code>RobotMaid</code> to execute these commands via RPC. You prefix each method with the <code>rpc</code> keyword and follow this with the Pascal-cased method name. Next, you write the request message type in parentheses, the <code>returns</code> keyword, and the return message type in parentheses <span class="CodeAnnotation">1</span>. </p>&#13;
<p>The <code>List</code> method doesn’t require any user input, but as in the command line application, you still must provide a request message type for it, even if it’s nil. In gRPC, the message type equivalent to nil is an empty message, which you call <code>Empty</code><span class="CodeAnnotation">3</span>.</p>&#13;
<p><span epub:type="pagebreak" id="Page_286" title="286"/>Until you’ve had the opportunity to add proper artificial intelligence (AI) to the robot, you’ll need to tell Rosie when her current chore is complete so she can move on to the next one. For this, you add a new message that informs her of the completed chore number <span class="CodeAnnotation">2</span>. Since you expect feedback from Rosie, you also add a response message that contains a string.</p>&#13;
<p>Now compile the <em>.proto</em> file to use the new service and messages. Tell <em>protoc</em> to use the <em>protoc</em><em>-gen-go-grpc</em> binary, which must also be in your <code>PATH</code> environment variable, like this:</p>&#13;
<pre><code>$ <b>protoc </b><span class="CodeAnnotation">1</span><b>--go-grpc_out=. </b><span class="CodeAnnotation">2</span>--go-grpc_opt=paths=source_relative \&#13;
<b>housework/v1/housework.proto</b></code></pre>&#13;
<p>The <code>--go-grpc_out</code> flag <span class="CodeAnnotation">1</span> invokes the <em>protoc-gen-go-grpc</em> binary to add gRPC support to the generated code. This binary generates the relevant gRPC service code for you and writes gRPC-specific code to the <em>housework/v1/housework_grpc.pb.go</em> file since you told <em>protoc-gen-go-grpc</em> to use relative paths <span class="CodeAnnotation">2</span>. You can now use the generated code to build a gRPC server and client.</p>&#13;
<h3 id="h2-500884c12-0005">Creating a TLS-Enabled gRPC Server</h3>&#13;
<p class="BodyFirst">Now let’s implement a gRPC client and server. By default, gRPC requires a secure connection, so you’ll add TLS support to your server. You’ll use the server’s <em>cert.pem</em> and <em>key.pem</em> files created in the preceding chapter for your gRPC server and pin the server’s certificate to your client. See the “Generating Certificates for Authentication” section <span class="xref" itemid="xref_target_on page 256">on page 256</span> for details.</p>&#13;
<p>You’ll leverage the Go code generated by your <em>.proto</em> file to define a new <code>RobotMaid</code> client and server and use the client to communicate with the server over the network using gRPC. First, let’s create the server portion of your robot maid. The <code>RobotMaidServer</code> interface generated from your <em>.proto</em> file looks like this:</p>&#13;
<pre><code>type RobotMaidServer interface {&#13;
    Add(context.Context, *Chores) (*Response, error)&#13;
    Complete(context.Context, *CompleteRequest) (*Response, error)&#13;
    List(context.Context, *empty.Empty) (*Chores, error)&#13;
    mustEmbedUnimplementedRobotMaidServer()&#13;
}</code></pre>&#13;
<p>You’ll implement this interface in <a href="#listing12-21" id="listinganchor12-21">Listing 12-21</a> by creating a new type named <code>Rosie</code>.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "context"&#13;
    "fmt"&#13;
    "sync"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch12/housework/v1"&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="Page_287" title="287"/>type Rosie struct {&#13;
    mu sync.Mutex&#13;
 <span class="CodeAnnotation">1</span> chores []*housework.Chore&#13;
}&#13;
&#13;
func (r *Rosie) Add(_ context.Context, chores *housework.Chores) (&#13;
    *housework.Response, error) {&#13;
    r.mu.Lock()&#13;
    r.chores = append(r.chores, chores.Chores...)&#13;
    r.mu.Unlock()&#13;
&#13;
    return <span class="CodeAnnotation">2</span>&amp;housework.Response{Message: "ok"}, nil&#13;
}&#13;
&#13;
func (r *Rosie) Complete(_ context.Context,&#13;
    req *housework.CompleteRequest) (*housework.Response, error) {&#13;
    r.mu.Lock()&#13;
    defer r.mu.Unlock()&#13;
&#13;
    if r.chores == nil || req.ChoreNumber &lt; 1 ||&#13;
        int(req.ChoreNumber) &gt; len(r.chores) {&#13;
        return nil, fmt.Errorf("chore %d not found", req.ChoreNumber)&#13;
    }&#13;
&#13;
    r.chores[req.ChoreNumber-1].Complete = true&#13;
&#13;
    return &amp;housework.Response{Message: "ok"}, nil&#13;
}&#13;
&#13;
func (r *Rosie) List(_ context.Context, _ *housework.Empty) (&#13;
    *housework.Chores, error) {&#13;
    r.mu.Lock()&#13;
    defer r.mu.Unlock()&#13;
&#13;
    if r.chores == nil {&#13;
        r.chores = make([]*housework.Chore, 0)&#13;
    }&#13;
&#13;
    return &amp;housework.Chores{Chores: r.chores}, nil&#13;
}&#13;
&#13;
func (r *Rosie) Service() *housework.RobotMaidService {&#13;
    return <span class="CodeAnnotation">3</span>&amp;housework.RobotMaidService{&#13;
        Add:      r.Add,&#13;
        Complete: r.Complete,&#13;
        List:     r.List,&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-21">Listing 12-21</a>: Building a <var>RobotMaid</var>-compatible type named <var>Rosie</var> (<em>server/rosie.go</em>)</p>&#13;
<p>The new <code>Rosie</code> struct keeps its list of chores in memory <span class="CodeAnnotation">1</span>, guarded by a mutex, since more than one client can concurrently use the service. The <code>Add</code>, <code>Complete</code>, and <code>List</code> methods all return either a response message type <span class="CodeAnnotation">2</span> or an error, both of which ultimately make their way back to the client. <span epub:type="pagebreak" id="Page_288" title="288"/>The <code>Service</code> method returns a pointer to a new <code>housework.RobotMaidService</code> instance <span class="CodeAnnotation">3</span> where <code>Rosie</code>’s <code>Add</code>, <code>Complete</code>, and <code>List</code> methods map to their corresponding method on the new instance.</p>&#13;
<p>Now, let’s set up a new gRPC server instance by using the <code>Rosie</code> struct (<a href="#listing12-22" id="listinganchor12-22">Listing 12-22</a>).</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "crypto/tls"&#13;
    "flag"&#13;
    "fmt"&#13;
    "log"&#13;
    "net"&#13;
&#13;
    "google.golang.org/grpc"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch12/housework/v1"&#13;
)&#13;
&#13;
var addr, certFn, keyFn string&#13;
&#13;
func init() {&#13;
    flag.StringVar(&amp;addr, "address", "localhost:34443", "listen address")&#13;
    flag.StringVar(&amp;certFn, "cert", "cert.pem", "certificate file")&#13;
    flag.StringVar(&amp;keyFn, "key", "key.pem", "private key file")&#13;
}&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    server := <span class="CodeAnnotation">1</span>grpc.NewServer()&#13;
    rosie := new(Rosie)&#13;
  <span class="CodeAnnotation">2</span>housework.RegisterRobotMaidServer(server, <span class="CodeAnnotation">3</span>rosie.Service())&#13;
&#13;
    cert, err := tls.LoadX509KeyPair(certFn, keyFn)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    listener, err := net.Listen("tcp", addr)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    fmt.Printf("Listening for TLS connections on %s ...", addr)&#13;
    log.Fatal(&#13;
     <span class="CodeAnnotation">4</span> server.Serve(&#13;
         <span class="CodeAnnotation">5</span> tls.NewListener(&#13;
                listener,&#13;
                &amp;tls.Config{&#13;
                    Certificates:             []tls.Certificate{cert},&#13;
                    CurvePreferences:         []tls.CurveID{tls.CurveP256},&#13;
                    MinVersion:               tls.VersionTLS12,&#13;
<span epub:type="pagebreak" id="Page_289" title="289"/>                    PreferServerCipherSuites: true,&#13;
                },&#13;
            ),&#13;
        ),&#13;
    )&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-22">Listing 12-22</a>: Creating a new gRPC server using <var>Rosie</var> (<em>server/server.go</em>)</p>&#13;
<p>First, you retrieve a new server instance <span class="CodeAnnotation">1</span>. You pass it and a new <code>*housework.RobotMaidService</code> from <code>Rosie</code>’s <code>Service</code><span class="CodeAnnotation">3</span> method to the <code>RegisterRobotMaidServer</code> function <span class="CodeAnnotation">2</span> in the generated gRPC code. This registers <code>Rosie</code>’s <code>RobotMaidService</code> implementation with the gRPC server. You must do this before you call the server’s <code>Serve</code> method <span class="CodeAnnotation">4</span>. You then load the server’s key pair and create a new TLS listener <span class="CodeAnnotation">5</span>, which you pass to the server when calling <code>Serve</code>.</p>&#13;
<p>Now that you have a gRPC server implementation, let’s work on the client.</p>&#13;
<h3 id="h2-500884c12-0006">Creating a gRPC Client to Test the Server</h3>&#13;
<p class="BodyFirst">The client-side code isn’t much different from what you wrote in the “Serializing Objects” section on <span class="xref" itemid="xref_target_page 270">page 270</span>. The main difference is that you need to instantiate a new gRPC client and modify the <code>add</code>, <code>complete</code>, and <code>list</code> functions to use it. Remember, you can implement the client portion in a separate programming language if the programming language offers <code>protobuf</code> support. You can generate code for your target language from your <em>.proto</em> file with the expectation it will work seamlessly with your server in <a href="#listing12-22">Listing 12-22</a>.</p>&#13;
<p><a href="#listing12-23" id="listinganchor12-23">Listing 12-23</a> details the changes to <a href="#listing12-2">Listing 12-2</a> necessary to add gRPC support to the housework application.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
 <span class="CodeAnnotation">1</span> "context"&#13;
 <span class="CodeAnnotation">2</span> "crypto/tls"&#13;
 <span class="CodeAnnotation">3</span> "crypto/x509"&#13;
    "flag"&#13;
    "fmt"&#13;
 <span class="CodeAnnotation">4</span> "io/ioutil"&#13;
    "log"&#13;
    "os"&#13;
    "path/filepath"&#13;
    "strconv"&#13;
    "strings"&#13;
&#13;
    "google.golang.org/grpc"&#13;
    "google.golang.org/grpc/credentials"&#13;
&#13;
    "github.com/awoodbeck/gnp/ch12/housework/v1"&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="Page_290" title="290"/>var addr, caCertFn string&#13;
&#13;
func init() {&#13;
 <span class="CodeAnnotation">5</span> flag.StringVar(&amp;addr, "address", "localhost:34443", "server address")&#13;
 <span class="CodeAnnotation">6</span> flag.StringVar(&amp;caCertFn, "ca-cert", "cert.pem", "CA certificate")&#13;
&#13;
    flag.Usage = func() {&#13;
        fmt.Fprintf(flag.CommandLine.Output(),&#13;
            `Usage: %s [flags] [add chore, ...|complete #]&#13;
    add         add comma-separated chores&#13;
    complete    complete designated chore&#13;
&#13;
Flags:&#13;
`, filepath.Base(os.Args[0]))&#13;
        flag.PrintDefaults()&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-23">Listing 12-23</a>: Initial gRPC client code for our housework application (<em>client/client.go</em>)</p>&#13;
<p>Aside from all the new imports <span class="CodeAnnotation">1</span><span class="CodeAnnotation">2</span><span class="CodeAnnotation">3</span><span class="CodeAnnotation">4</span>, you add flags for the gRPC server address <span class="CodeAnnotation">5</span> and its certificate <span class="CodeAnnotation">6</span>.</p>&#13;
<p><a href="#listing12-24" id="listinganchor12-24">Listing 12-24</a> uses the gRPC client to list the current chores.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func list(ctx context.Context, client housework.RobotMaidClient) error {&#13;
    chores, err := client.List(ctx, <span class="CodeAnnotation">1</span>new(housework.Empty))&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    if len(chores.Chores) == 0 {&#13;
        fmt.Println("You have nothing to do!")&#13;
        return nil&#13;
    }&#13;
&#13;
    fmt.Println("#\t[X]\tDescription")&#13;
    for i, chore := range chores.Chores {&#13;
        c := " "&#13;
        if chore.Complete {&#13;
            c = "X"&#13;
        }&#13;
        fmt.Printf("%d\t[%s]\t%s\n", i+1, c, chore.Description)&#13;
    }&#13;
&#13;
    return nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-24">Listing 12-24</a>: Using the gRPC client to list the current chores (<em>client/client.go</em>)</p>&#13;
<p>This code is quite like <a href="#listing12-5">Listing 12-5</a>, except you’re asking the gRPC client for the list of chores, which retrieves them from the server. You need to pass along an empty message to make gRPC happy <span class="CodeAnnotation">1</span>.</p>&#13;
<p><span epub:type="pagebreak" id="Page_291" title="291"/><a href="#listing12-25" id="listinganchor12-25">Listing 12-25</a> uses the gRPC client to add new chores to the gRPC server’s chores.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func add(ctx context.Context, client housework.RobotMaidClient,&#13;
    s string) error {&#13;
    chores := new(housework.Chores)&#13;
&#13;
    for _, chore := range strings.Split(s, ",") {&#13;
        if desc := strings.TrimSpace(chore); desc != "" {&#13;
            chores.Chores = append(chores.Chores, &amp;housework.Chore{&#13;
                Description: desc,&#13;
            })&#13;
        }&#13;
    }&#13;
&#13;
    var err error&#13;
    if len(chores.Chores) &gt; 0 {&#13;
        _, <span class="CodeAnnotation">1</span>err = client.Add(ctx, chores)&#13;
    }&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-25">Listing 12-25</a>: Adding new chores using the gRPC client (<em>client/client.go</em>)</p>&#13;
<p>As you did in the previous section, you parse the comma-separated list of chores. Instead of flushing these chores to disk, you pass them along to the gRPC client. The gRPC client transparently sends them to the gRPC server and returns the response to you. Since you know <code>Rosie</code> returns a non-nil error when the <code>Add</code> call fails, you return the error <span class="CodeAnnotation">1</span> as the result of the <code>add</code> function.</p>&#13;
<p>In <a href="#listing12-26" id="listinganchor12-26">Listing 12-26</a>, you write the code to mark chores complete. Doing this over gRPC requires a bit less code than <a href="#listing12-8">Listing 12-8</a> since most of the logic is in the server.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func complete(ctx context.Context, client housework.RobotMaidClient,&#13;
    s string) error {&#13;
    i, err := strconv.Atoi(s)&#13;
    if err == nil {&#13;
        _, err = client.Complete(ctx,&#13;
            &amp;housework.CompleteRequest{<span class="CodeAnnotation">1</span>ChoreNumber: int32(i)})&#13;
    }&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-26">Listing 12-26</a>: Marking chores complete by using the gRPC client (<em>client/client.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_292" title="292"/>Notice the <em>protoc-gen-go</em> module, which converts the snake-cased <code>chore_number</code> field in <a href="#listing12-20">Listing 12-20</a> to Pascal case in the generated Go code <span class="CodeAnnotation">1</span>. You must also convert the <code>int</code> returned by <code>strconv.Atoi</code> to an <code>int32</code> before assigning it to the complete request message’s chore number since <code>ChoreNumber</code> is an <code>int32</code>.</p>&#13;
<p><a href="#listing12-27" id="listinganchor12-27">Listing 12-27</a> creates a new gRPC connection and pins the server’s certificate to its TLS configuration.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    caCert, err := ioutil.ReadFile(caCertFn)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    certPool := x509.NewCertPool()&#13;
    if ok := certPool.AppendCertsFromPEM(caCert); !ok {&#13;
        log.Fatal("failed to add certificate to pool")&#13;
    }&#13;
&#13;
    conn, err := <span class="CodeAnnotation">1</span>grpc.Dial(&#13;
        addr,&#13;
     <span class="CodeAnnotation">2</span> grpc.WithTransportCredentials(&#13;
         <span class="CodeAnnotation">3</span> credentials.NewTLS(&#13;
                &amp;tls.Config{&#13;
                    CurvePreferences: []tls.CurveID{tls.CurveP256},&#13;
                    MinVersion:       tls.VersionTLS12,&#13;
                    RootCAs:          certPool,&#13;
                },&#13;
            ),&#13;
        ),&#13;
    )&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-27">Listing 12-27</a>: Creating a new gRPC connection using TLS and certificate pinning (<em>client/client.go</em>)</p>&#13;
<p>On the client side, you first create a new gRPC network connection <span class="CodeAnnotation">1</span> and then use the network connection to instantiate a new gRPC client. For most use cases, you can simply pass the address to <code>grpc.Dial</code>. But you want to pin the server’s certificate to the client connection. Therefore, you need to explicitly pass in a <code>grpc.DialOption</code> with the appropriate TLS credentials. This involves using the <code>grpc.WithTransportCredentials</code> function <span class="CodeAnnotation">2</span> to return the <code>grpc.DialOption</code> and the <code>credentials.NewTLS</code> function <span class="CodeAnnotation">3</span> to create the transport credentials from your TLS configuration. The result is a gRPC network connection that speaks TLS with the server and authenticates the server by using the pinned certificate.</p>&#13;
<p><span epub:type="pagebreak" id="Page_293" title="293"/>You use this gRPC network connection to instantiate a new gRPC client in <a href="#listing12-28" id="listinganchor12-28">Listing 12-28</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    rosie := <span class="CodeAnnotation">1</span>housework.NewRobotMaidClient(conn)&#13;
    ctx := context.Background()&#13;
&#13;
    switch strings.ToLower(flag.Arg(0)) {&#13;
    case "add":&#13;
        err = add(ctx, rosie, strings.Join(flag.Args()[1:], " "))&#13;
    case "complete":&#13;
        err = complete(ctx, rosie, flag.Arg(1))&#13;
    }&#13;
&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
&#13;
    err = list(ctx, rosie)&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing12-28">Listing 12-28</a>: Instantiating a new gRPC client and making calls (<em>client/client.go</em>)</p>&#13;
<p>Aside from instantiating a new gRPC client from the gRPC network connection <span class="CodeAnnotation">1</span>, this bit of code doesn’t vary much from <a href="#listing12-9">Listing 12-9</a>. The difference, of course, lies in the fact that any interaction with the list of chores transparently takes place over a TLS connection to the gRPC server.</p>&#13;
<p>Give it a try. In one terminal, start the server:</p>&#13;
<pre><code>$ <b>go run server/server.go server/rosie.go -cert server/cert.pem -key server/key.pem</b>&#13;
Listening for TLS connections on localhost:34443 ...</code></pre>&#13;
<p>And in another terminal, run the client:</p>&#13;
<pre><code>$ <b>go run client/client.go -ca-cert server/cert.pem</b>&#13;
You have nothing to do!&#13;
$ <b>go run client/client.go -ca-cert server/cert.pem add Mop floors, Wash dishes</b>&#13;
#       [X]     Description&#13;
1       [ ]     Mop floors&#13;
2       [ ]     Wash dishes&#13;
$ <b>go run client/client.go -ca-cert server/cert.pem complete 2</b>&#13;
#       [X]     Description&#13;
1       [ ]     Mop floors&#13;
2       [X]     Wash dishes</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_294" title="294"/>Of course, restarting the server wipes out the list of chores. I’ll leave it as an exercise for you to implement persistence on the server. One approach is to have the server load the chores from and flush chores to disk as you did earlier in this chapter.</p>&#13;
<h2 id="h1-500884c12-0003">What You’ve Learned</h2>&#13;
<p class="BodyFirst">Data serialization allows you to exchange data in a platform-neutral and language-neutral way. You can also serialize data for long-term storage, retrieve and deserialize the data, and pick up where your application left off.</p>&#13;
<p>JSON is arguably the most popular text-based data serialization format. Contemporary programming languages offer good support for JSON, which is one reason for its ubiquity in RESTful APIs. Go offers good support for binary-based data serialization formats as well, including Gob, which is nearly a drop-in replacement for JSON. Gob is Go’s native binary data serialization format, and it’s designed to be efficient and easy to use.</p>&#13;
<p>If you’re looking for a binary data serialization format with wider support, consider protocol buffers. Google designed protocol buffers to facilitate the exchange of serialized binary data across its supported platforms and programming languages. Many contemporary programming languages currently offer support for protocol buffers. Although protocol buffers aren’t the same drop-in replacement in Go as Gob is for JSON, Go has excellent protocol buffer support, nonetheless. You first need to add definitions that define the data structures you intend to serialize in a <em>.proto</em> file. You then use the protocol buffer compiler and its Go module to generate Go code that corresponds to your defined data structures. Finally, you use the generated code to serialize your data structures into protocol buffer-formatted binary data and deserialize that binary data back into your data structures.</p>&#13;
<p>The gRPC framework is a high-performance, platform-neutral standard for making distributed function calls across a network. The <em>RPC</em> in <em>gRPC</em> stands for <em>remote procedure call</em>, which is a technique for transparently calling a function on a remote system and receiving the result as if you had executed the function on your local system. gRPC uses protocol buffers as its underlying data serialization format. Go’s protocol buffer module allows you to easily add gRPC support by defining services in your <em>.proto</em> file and leveraging the generated code. This lets you quickly and efficiently stand up distributed services or integrate with existing gRPC services.</p>&#13;
</section>&#13;
</body></html>