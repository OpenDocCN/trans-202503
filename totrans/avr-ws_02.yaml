- en: '[2](nsp-boxall502581-0008.xhtml#rch02)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve installed the requisite software and are prepared to enter the
    world of AVR microcontrollers, this chapter will ease you into your first AVR
    projects with some basic circuits and code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Test your setup for making AVR-based projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Read basic circuit schematics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Control LEDs with the digital output pins on both AVR microcontrollers, the
    ATtiny85 and the ATmega328P-PU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll also show you how to start coding with `#define` macros and `for` loops,
    and how to use bitwise arithmetic and bit shifting to generate outputs efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '[Testing the Hardware and Toolchain](nsp-boxall502581-0008.xhtml#rah0401)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, it’s wise to check that the USBasp programmer and the previously
    installed toolchain are working as expected. We’ll do this in three stages: by
    building a simple circuit, testing the USBasp, and uploading code to the microcontroller.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Build the Circuit](nsp-boxall502581-0008.xhtml#rbh0401)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section you’ll build a simple device that flashes an LED on and off,
    which is a fun and simple way to test your hardware and toolchain. To get started,
    you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85–20PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 5 mm red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Seven jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s focus on the practical steps of putting the circuit together to make
    sure your toolchain works correctly and will hold up when we dig into meatier
    projects. To connect the components of your test circuit, first place the solderless
    breadboard on a flat surface, as shown in [Figure 2-1](nsp-boxall502581-0012.xhtml#f02001)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a 400-hole solderless breadboard](images/nsp-boxall502581-f02001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: A solderless breadboard'
  prefs: []
  type: TYPE_NORMAL
- en: Insert your ATtiny85 into the breadboard so that it sits across the vertical
    gap in the board’s top four rows, as shown in [Figure 2-2](nsp-boxall502581-0012.xhtml#f02002)
    , making sure you insert the microcontroller’s pin 1—indicated by the small circle
    beside the leg, as described in [Chapter 1](nsp-boxall502581-0011.xhtml#ch01)
    —into column e, row 1 of the breadboard. The pins are numbered in a counterclockwise
    direction from 1, so pin 4 is at the bottom left in this figure, and pin 8 is
    at the top right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of an ATtiny85 microcontroller positioned at the top of a solderless
    breadboard](images/nsp-boxall502581-f02002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: The AVR in the breadboard'
  prefs: []
  type: TYPE_NORMAL
- en: Now take the 560 Ω resistor and insert one leg in the same row as pin 2 of the
    ATtiny85 and the other leg a few rows farther along. In [Figure 2-3](nsp-boxall502581-0012.xhtml#f02003)
    , I’ve inserted the second leg into row 8.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the first resistor to the solderless breadboard from pin 2 of the
    microcontroller](images/nsp-boxall502581-f02003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: The resistor in the breadboard'
  prefs: []
  type: TYPE_NORMAL
- en: Next, take a look at your LED. Note that one leg is longer than the other, as
    shown in [Figure 2-4](nsp-boxall502581-0012.xhtml#f02004) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a red LED](images/nsp-boxall502581-f02004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: A typical LED'
  prefs: []
  type: TYPE_NORMAL
- en: Insert the LED into the solderless breadboard, with the longer leg in the same
    row as the lower end of the resistor (row 8 in our example) and the shorter leg
    two rows farther along, using [Figure 2-5](nsp-boxall502581-0012.xhtml#f02005)
    as a guide.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the red LED inserted into the solderless breadboard, with the anode
    connected to the other end of the resistor](images/nsp-boxall502581-f02005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: Your circuit so far'
  prefs: []
  type: TYPE_NORMAL
- en: Take a jumper wire and insert one end into the same row as the LED’s shorter
    leg, then the other end into the same row as pin 4 of the ATtiny85, as demonstrated
    in [Figure 2-6](nsp-boxall502581-0012.xhtml#f02006) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the circuit with a jumper wire between the LED cathode and microcontroller
    ground pin](images/nsp-boxall502581-f02006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: The wiring begins!'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve placed the components, I’ll show you how to get the code from
    your computer to the microcontroller with the AVR programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Connect and Run the Programmer](nsp-boxall502581-0008.xhtml#rbh0402)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To connect the USBasp programmer to the breadboard, first connect six male to
    female jumper wires to the six connection pins on the USBasp, shown in [Figure 2-7](nsp-boxall502581-0012.xhtml#f02007)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the connection pins on the USBasp programmer that connect to the
    circuit](images/nsp-boxall502581-f02007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7: USBasp connection pins'
  prefs: []
  type: TYPE_NORMAL
- en: Next, connect each of the USBasp’s six pins to the ATtiny85 using the mapping
    in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201) . You’ll use these same connections
    every time you program an ATtiny85 microcontroller. Don’t worry for now about
    the meaning of the pin labels; I’ll explain them to you as we go along in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 2-1 : USBasp to ATtiny85 Connections |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| USBasp pin | ATtiny85 pin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RST | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| GND | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| VCC | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| SCK | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| MISO | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| MOSI | 5 |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 2-8](nsp-boxall502581-0012.xhtml#f02008) illustrates the connections
    between the USBasp and an ATtiny85 described in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201)
    . I’ve removed the rest of the circuit to show just an example of the connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo showing the six connections between the USBasp programmer and the microcontroller
    on the solderless breadboard](images/nsp-boxall502581-f02008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: A USBasp connected to an ATtiny85 on a solderless breadboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check the USBasp is working correctly by connecting your USBasp programmer
    to your computer. To do this, you’ll use a program that’s part of the installed
    toolchain called AVRDUDE, which is a utility to upload code to AVR microcontrollers.
    Open a terminal window and enter the command `avrdude -p t85 -c usbasp -B 4` .
    This command includes the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: • `-p` selects the type of microcontroller being used in the project. You used
    `t85` just now for the ATtiny85, and later you’ll use `m328p` for the ATmega328P-PU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `-c` selects the type of hardware programmer being used. In this case you’ve
    specified `usbasp` , representing your USBasp programmer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `-B` sets the processing speed of the microcontroller in the USBasp programmer.
    You set this value to `4` to bring the speed down to 187.5 kHz. This is necessary
    for new microcontrollers, as they are set at the factory with a clock speed of
    1 MHz, which is slower than the USBasp’s default speed. I’ll explain more about
    speeds in [Chapter 12](nsp-boxall502581-0022.xhtml#ch12) .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The software toolchain should interrogate the programmer and microcontroller,
    and your terminal should look something like this afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By reporting the *device signature* , a unique identifier for the type of AVR
    microcontroller, the software toolchain has indicated that all is well.
  prefs: []
  type: TYPE_NORMAL
- en: The AVRDUDE documentation ( [http://www.nongnu.org/avrdude/user-manual/avrdude_4.html](http://www.nongnu.org/avrdude/user-manual/avrdude_4.html)
    ) describes other options beyond those included in this `avrdude` command, if
    you’re curious. For now, if you saw the correct output after entering that command,
    skip ahead to [Project 0](nsp-boxall502581-0012.xhtml#pro0) . You’re ready to
    program your AVR!
  prefs: []
  type: TYPE_NORMAL
- en: '[What If It Didn’t Work?](nsp-boxall502581-0008.xhtml#rbh0403)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If, after running the command in the previous step, you got an error like the
    following, then there was a problem with the hardware connection between the programmer
    and the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don’t use `-F` to override the check, as the error message suggests. Instead,
    double-check the wiring between the USBasp and the solderless breadboard to make
    sure no connections are loose. Then check the circuit itself to confirm the components
    are connected to one another according to the instructions given in the “Build
    the Circuit” section. In particular, check that the ATtiny85’s pin 1 is aligned
    with the top-left corner of the breadboard. Orienting a chip incorrectly is one
    of the most common circuit errors!
  prefs: []
  type: TYPE_NORMAL
- en: If everything looks correct, try running the `avrdude` command again. It should
    work, but if it doesn’t, walk away for a few moments, then review the process
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Using AVR Safely
  prefs: []
  type: TYPE_NORMAL
- en: 'As we move on to our [first project](nsp-boxall502581-0012.xhtml#pro0) , a
    reminder about safety: as with any hobby or craft, it’s up to you to take care
    of yourself and those around you. In this book, I discuss working with basic hand
    tools, battery-powered electrical devices, sharp knives, cutters, and sometimes
    hot soldering irons. *At no point in your projects should you work directly with
    AC mains current* . That is, don’t directly wire anything you make to the wall
    outlets. Leave that to a licensed electrician who is trained for such work. Remember
    that direct contact with AC current could kill you.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve got your circuit working, keep it together, including the USBasp,
    as you’ll need all of this for the [first project](nsp-boxall502581-0012.xhtml#pro0)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 0: Blinking an LED](nsp-boxall502581-0008.xhtml#rpro0)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a working circuit and programmer connection, it’s time to
    create and upload your first *program* (also known as *code* ), a set of instructions
    that tells the microcontroller how to accomplish a particular task.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this book, our programs will increase in length as the projects
    get more complex. Instead of typing out each piece of code included in the book,
    please download the ZIP file containing the book’s code from [http://www.nostarch.com/avr-workshop](http://www.nostarch.com/avr-workshop)
    . This file includes folders for each project (organized by chapter) that contain
    the code and anything else required to program the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note If you’re reading an electronic version of this book, don’t copy and paste
    the code from the book into your text editor. Use the downloaded code files instead.
  prefs: []
  type: TYPE_NORMAL
- en: Projects in this book use the C programming language. Since C is popular across
    many microcontroller and computer platforms, it should be easy to find help if
    you need it and to share your work with others.
  prefs: []
  type: TYPE_NORMAL
- en: '[Uploading Your First AVR Code](nsp-boxall502581-0008.xhtml#rbh0404)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve downloaded and extracted the book’s code files, use a text editor
    to open the *main.c* file located in the *Project 0* subfolder of the *Chapter
    2* folder. This C file contains a small program that should cause your LED to
    blink on and off once you compile the code and upload it to the microcontroller.
    However, to get the desired effect, you’ll need to pair the C files for each of
    your projects with a *Makefile* .
  prefs: []
  type: TYPE_NORMAL
- en: A Makefile contains a set of instructions for the toolchain to use when compiling
    and uploading your code to the microcontroller, including the microcontroller
    type, the CPU speed the microcontroller requires, and the type of programmer you
    plan to use. Every time you start a new project of your own, you should create
    a new folder for that project and place the *main.c* file and Makefile inside
    that folder. To save you time I’ve already done this for the [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    files and for all the other projects in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious about the contents of the Makefile, open the one for [Project
    0](nsp-boxall502581-0012.xhtml#pro0) with a text editor and take a look. I’ll
    introduce any necessary changes to the Makefiles in the download bundle for this
    book as you progress with the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with these file types, it’s time to bring your [first
    project](nsp-boxall502581-0012.xhtml#pro0) to life using the circuit you constructed
    earlier in this chapter. If you closed it earlier, open a terminal window just
    as you did when testing the toolchain. Next, navigate to the folder containing
    the two files for [Project 0](nsp-boxall502581-0012.xhtml#pro0) , and enter the
    command `make flash` .
  prefs: []
  type: TYPE_NORMAL
- en: 'After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. The microcontroller should
    then start running the program; in this case, your LED should start blinking.
    During this process, the status should appear in the terminal window, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at the code to see how this program works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of *main.c* ❶ is a *comment* naming the program and describing
    what it’s intended to accomplish. When writing programs, it’s a good idea to add
    comments like these explaining how to use the program or highlighting other important
    details; they may prove useful when you revisit your code or share it with others.
    Comments can be any length you like, and you can use them anywhere in your program.
    To add a comment on a single line, enter two forward slashes and then the comment,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The forward slashes tell the compiler in the software toolchain to ignore the
    rest of the text on the line when compiling the program. In your own projects,
    you can include comments spanning two or more lines by entering the characters
    `/*` on a line before the comment text, then ending the comment with the characters
    `*/` , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Returning to *main.c* , the `include` statements ❷ tell the compiler to look
    inside a library file, like *avr/io.h* , for more information required to compile
    the program. There are many libraries, each allowing you to use different functions
    in your code, and you can even create your own if necessary. You’ll learn about
    that in [Chapter 10](nsp-boxall502581-0020.xhtml#ch10) .
  prefs: []
  type: TYPE_NORMAL
- en: All the instructions to run the program appear between the curly brackets after
    `int main(void)` , where the main section of the program begins ❸. Within these
    brackets, the program configures certain *parameters* of the microcontroller—that
    is, certain settings to make various operations take place. First, the program
    tells the microcontroller which physical pins will be inputs or outputs ❹. You
    hooked your LED up to pin 2, which the AVR knows as PB3, so the code activates
    that pin as an output. (Don’t worry if this is a little confusing right now; I’ll
    cover inputs and outputs in detail in the next few chapters.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code between the curly brackets after `while(1)` ❺ should execute
    repeatedly, blinking the LED by continuously toggling whether pin 2 outputs a
    1 or a 0, until the microcontroller loses power or you reset it. A 1 supplies
    power to the LED, so that should turn the LED on, while a 0 should turn the LED
    off.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with the speed of the LED’s blinking, go back to *main.c* and
    replace `1000` in the two lines that read `_delay_ms(1000);` with any non-negative
    number you like. Then save the *main.c* file and rerun the `make flash` command.
    The LED should blink faster or slower, depending on the value you use.
  prefs: []
  type: TYPE_NORMAL
- en: '[What If It Didn’t Work?](nsp-boxall502581-0008.xhtml#rbh0405)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If there is an error in your code, the compiler will indicate which line in
    the code contains the error, or a line very close to it. For example, here’s what
    happened when I ran the `make flash` command with a spelling mistake in line 10
    of the [Project 0](nsp-boxall502581-0012.xhtml#pro0) code. The compiler found
    the error and gave the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If this happens to you, open the *main.c* file in your text editor and locate
    and fix the mistake before trying another upload. To compile your program for
    this purpose without uploading it, just run the `make` command by itself in the
    terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: Running `make` is a good way to check for errors like typos in the code, but
    it may not help you catch errors in logic—that is, whether you’ve correctly told
    the microcontroller what you want it to do. As a general rule, remember that even
    if your program compiles, it may not behave as you expect if you don’t carefully
    plan your instructions to the microcontroller before you write the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling Digital Outputs](nsp-boxall502581-0008.xhtml#rah0402)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve seen the electronic components you’ll use in this book, let’s
    talk a bit more about the digital output pins on the ATtiny85 and the ATmega328P-PU.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, a digital output pin is a source of electrical current that you can
    control; it can be either on or off. On the ATtiny85 up to six pins can operate
    as outputs, and on the ATmega328P-PU up to eight pins can operate as outputs.
    I say “up to” because some pins can have more than one function, depending on
    how you set them up. I’ll explain how to select pin functions later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Each output pin offers a maximum amount of current. On the ATtiny85, that maximum
    is 40 mA. However, the total maximum current you can run through the IC is 200
    mA. Drawing too much current can cause problems, so to avoid any issues, assume
    you can have a maximum of 20 mA per output pin on the ATtiny85 and the ATmega328P-PU.
    Keep these ratings in the back of your mind when creating your own projects; all the
    projects in this book are designed to avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[Hardware Registers](nsp-boxall502581-0008.xhtml#rbh0406)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The key to understanding digital outputs is to learn about the *hardware registers*
    . Our AVR microcontrollers all have multiple registers that store information
    related to all the possible settings for the microcontroller’s operations. The
    numerical values placed inside these registers control digital outputs.
  prefs: []
  type: TYPE_NORMAL
- en: The first AVR register to consider is called the *DDR* , for *data-direction
    register* . This is used to tell the microcontroller which pins are outputs and
    which are inputs. Some microcontrollers, such as the ATtiny85, will have only
    one DDR register, and some, like the ATmega328P-PU, will have more. The second
    register to consider is called *PORT* . You’ll use this to set which pins are
    on or off.
  prefs: []
  type: TYPE_NORMAL
- en: Each register is 8 bits in size, where a bit can be either a 0 or a 1, just
    like a binary number. Each bit relates to a physical pin on the microcontroller.
    In the DDR *x* registers, 1s indicate that a pin is an output and 0s indicate
    that a pin is an input. In the PORT *x* registers, 1s indicate that a pin is on
    and 0s indicate that a pin is off.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out how many pins and registers are available by looking at the
    data sheet for your microcontroller (you can download the ATtiny85’s data sheet
    from the Microchip website at [https://www.microchip.com/wwwproducts/en/ATtiny85](https://www.microchip.com/wwwproducts/en/ATtiny85)
    ). For example, the diagram in [Figure 2-9](nsp-boxall502581-0012.xhtml#f02009)
    shows that there is one PORT register on the ATtiny85: the PORTB register, which
    spans pins 5, 6, 7, 3, 2, and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the ATtiny85 microcontroller’s pins and their functions](images/nsp-boxall502581-f02009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: Pinouts and PORT registers for the ATtiny85'
  prefs: []
  type: TYPE_NORMAL
- en: PORT register names are usually abbreviated on diagrams and data sheets; in
    [Figure 2-9](nsp-boxall502581-0012.xhtml#f02009) , the PORTB register is referred
    to as PB, with each pin labeled as PB *x* , where *x* is the number of the pin.
    You’ll refer to this register as `PORTB` in your code. The matching DDR register
    is called DDRB, as it controls the data direction for PORTB. Please note that
    you can only use pins PB0 through PB4, as PB5 has other functions, which we’ll
    examine later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set some of the pins in the DDRB register to outputs, just set the respective
    bits to 1s. As an example, let’s revisit the code from [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sets the physical pin 2 to an output ❶. To set all the PORTB pins
    to outputs, you could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine how this works. The physical pins of the DDRB register of your
    ATtiny85 are 1, 3, 2, 7, 6, and 5\. Each pin corresponds to a single bit in the
    register; from left to right, those pins are bits 5, 3, 4, 2, 1, and 0, respectively.
    So, for example, to set physical pin 6 (PB1) as an output and the rest as inputs
    you would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as we saw in the [Project 0](nsp-boxall502581-0012.xhtml#pro0) code, to
    set physical pin 2 (PB3) as an output and the rest as inputs you would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We call the bit on the right-hand side of the register the *first bit* or *least
    significant bit (LSB)* and the bit on the left-hand side the *last bit* or *most
    significant bit (MSB)* . This may seem backward at first, but bits are the equivalent
    of binary numbers, whose contents are referenced using the same method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the ATtiny85 has only six outputs, you can leave the last two bits
    (6 and 7) as 0s or 1s in the DDRB statement. Once you’ve set a pin to an output,
    use the `PORT` `x` function to switch the output on or off. To turn all the outputs
    on, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn them all off, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to turn, say, pins 3 (PB4) and 5 (PB0) on and the rest off, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To experiment with these functions, in the [next project](nsp-boxall502581-0012.xhtml#pro1)
    you’ll build a new circuit like the one in [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    , but this time with four LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 1: Experimenting with ATtiny85 Digital Outputs](nsp-boxall502581-0008.xhtml#rpro1)'
  prefs: []
  type: TYPE_NORMAL
- en: To practice and increase your understanding of using the ATtiny85’s DDRB and
    PORTB registers, in this project you’ll control four output devices (LEDs). Although
    blinking LEDs may seem a somewhat trivial example, the ability to control digital
    outputs is the foundation for controlling a wide range of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0407)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85–20PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circuit for this project is similar to the one in [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    , but with three more LEDs. Assemble your circuit as shown in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the physical circuit layout for Project 1](images/nsp-boxall502581-f02010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10: A physical layout diagram of the main circuit for [Project 1](nsp-boxall502581-0012.xhtml#pro1)'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve assembled your circuit, connect the USBasp programmer. Repeat the
    connections as shown in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201) .
  prefs: []
  type: TYPE_NORMAL
- en: Note If you’d like to try creating diagrams like the one in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    , use Autodesk Tinkercad, available at [https://www.tinkercad.com/](https://www.tinkercad.com/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0408)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the folder containing the two files for
    [Project 1](nsp-boxall502581-0012.xhtml#pro1) , and enter the command `make flash`
    . After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. Then the microcontroller
    should run the program that turns the digital outputs on and off, causing all
    four of the LEDs to blink.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file located in the *Project 1* subfolder
    of the *Chapter 2* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'First we use `DDRB` to set all the pins to outputs ❶. The `_delay_ms()` function
    ❷ tells the microcontroller to stop everything for a set period of time. To use
    a delay, just enter the number of milliseconds you want the program to pause inside
    the parentheses: `_delay_ms(250)` sets the delay to 250 milliseconds. Next, we
    turn on the digital outputs so current will flow from the pins, through the resistors
    and LEDs, and then to GND, completing the electrical circuit ❸. After another
    delay we turn off the digital outputs, causing the LEDs to turn off ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: By now you should understand how to set the pins on the ATtiny85 to outputs,
    turn them on and off, and create a delay. Experiment with the delay and pins by
    changing which LEDs turn on and off, the length of the delay, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Schematic Diagrams](nsp-boxall502581-0008.xhtml#rah0403)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Projects 0](nsp-boxall502581-0012.xhtml#pro0) and [1](nsp-boxall502581-0012.xhtml#pro1)
    showed you how to build circuits using a picture and a physical layout diagram,
    respectively. Physical layout diagrams like the one in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    may seem like the easiest way to diagram a circuit, but as you add more components,
    direct representations make physical diagrams a real mess. Because your circuits
    are about to get more complicated, from now on I’ll use *schematic diagrams* (also
    known as *circuit diagrams* ) to illustrate them, like the one shown in [Figure
    2-11](nsp-boxall502581-0012.xhtml#f02011) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a simple microcontroller circuit schematic](images/nsp-boxall502581-f02011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: An example schematic diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Schematics are road maps that show where electrical current flows through various
    components, with the lines between components indicating those paths. Instead
    of showing components and wires, a schematic uses symbols and lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[Components in Schematics](nsp-boxall502581-0008.xhtml#rbh0409)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you know what the symbols mean, reading a schematic is easy. To begin,
    let’s examine the symbols for the components you’ve already used.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-12](nsp-boxall502581-0012.xhtml#f02012) shows the ATtiny85 microcontroller
    symbol. The pin numbers are labeled clearly; don’t forget that pin 1 is at the
    top left on the physical chip. Other microcontrollers and ICs use similar symbols,
    but their size depends on the number of pins.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the ATtiny85–20PU microcontroller](images/nsp-boxall502581-f02012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: The ATtiny85 microcontroller symbol'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-13](nsp-boxall502581-0012.xhtml#f02013) shows the resistor symbol.
    It’s good practice to display the resistor value and part designator along with
    the resistor symbol (220 Ω and R1, in this case). This makes life a lot easier
    for everyone trying to make sense of the schematic, including you!'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a common resistor](images/nsp-boxall502581-f02013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: The resistor symbol'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-14](nsp-boxall502581-0012.xhtml#f02014) shows the LED symbol. All
    members of the diode family share a common symbol, the triangle and vertical line,
    but LED symbols show two parallel arrows pointing away from the triangle to indicate
    that light is being emitted.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a common LED](images/nsp-boxall502581-f02014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14: The LED symbol'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of the various component schematic symbols,
    I’ll show you how the wired connections between the components are shown in circuit
    schematics.
  prefs: []
  type: TYPE_NORMAL
- en: '[Wires in Schematics](nsp-boxall502581-0008.xhtml#rbh0410)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When wires cross or connect in schematics, they are drawn in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Crossing but not connected wires
  prefs: []
  type: TYPE_NORMAL
- en: When two wires cross but are not connected, the crossing can be represented
    in one of two ways, as shown in [Figure 2-15](nsp-boxall502581-0012.xhtml#f02015)
    . Either way is correct; it’s just a matter of preference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Two ways of representing non-connecting wires in circuit schematics](images/nsp-boxall502581-f02015.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2-15: Non-connecting crossed wires'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connected wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When wires are physically connected, a *junction dot* is drawn at the point
    of connection, as shown in [Figure 2-16](nsp-boxall502581-0012.xhtml#f02016) .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Representation of connected wires in a circuit schematic](images/nsp-boxall502581-f02016.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2-16: Two wires that are connected'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wire connected to ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The symbol shown in [Figure 2-17](nsp-boxall502581-0012.xhtml#f02017) indicates
    when a wire is connected to ground (GND).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Schematic symbol for circuit ground](images/nsp-boxall502581-f02017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2-17: The GND symbol'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The GND symbol at the end of a line in a schematic tells you that the wire is
    physically connected to the microcontroller’s GND pin. For your circuits, this
    is also known as the *negative* .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Dissecting a Schematic](nsp-boxall502581-0008.xhtml#rbh0411)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know the symbols for the parts you’ve used so far, let’s dissect
    the schematic you’d draw for [Project 1](nsp-boxall502581-0012.xhtml#pro1) . Compare
    the schematic shown in [Figure 2-18](nsp-boxall502581-0012.xhtml#f02018) with
    physical image of the circuit in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 1](images/nsp-boxall502581-f02018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-18: Schematic for [Project 1](nsp-boxall502581-0012.xhtml#pro1)'
  prefs: []
  type: TYPE_NORMAL
- en: The arrow with +5V written above it represents the 5 V power supply on the breadboard,
    and the ATtiny85 is labeled with its chip name. LEDs 1 through 4 are connected
    to the ATtiny85 at the same pins you saw in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    , and just like in the original circuit, all four resistors attached to the LEDs
    go to GND, pin 4 on the microcontroller. Note the dots at the junctions of R1,
    R2, R3, and R4, which indicate that those resistors are all connected to the same
    place (GND). The Xs on pins 1 and 3 in [Figure 2-18](nsp-boxall502581-0012.xhtml#f02018)
    signal that those pins are not connected to anything.
  prefs: []
  type: TYPE_NORMAL
- en: In this schematic, you can trace the flow of current from the power supply through
    the circuit to ground. Current is sourced from the 5 V power supply and enters
    the microcontroller. Our code then allows the current to flow from digital output
    pins when required. This current goes through an LED (which causes the LED to
    glow) and the resistor (which regulates the current) before reaching ground and
    completing the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Note If you’d like to create your own computer-drawn schematics, try the open
    source KiCad package, available for free or with a donation from [https://www.kicad.org/](https://www.kicad.org/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Along with using the ATmega328P-PU for the first time, the [following project](nsp-boxall502581-0012.xhtml#pro2)
    will also put your new knowledge of reading circuit schematics to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 2: Experimenting with ATmega328P-PU Digital Outputs](nsp-boxall502581-0008.xhtml#rpro2)'
  prefs: []
  type: TYPE_NORMAL
- en: You can tell at a glance that the ATmega328P-PU has more digital outputs than
    the ATtiny85\. The pinout diagram from the data sheet in [Figure 2-19](nsp-boxall502581-0012.xhtml#f02019)
    gives the details.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the ATmega328P-PU’s pins and their functions](images/nsp-boxall502581-f02019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-19: The ATmega328P-PU pinout and port register diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two registers you can use for digital outputs: PORTB (PB) and PORTD
    (PD). For this and the following few projects, you’ll use the PORTB register.
    In this project, you’ll put the ATmega328P-PU’s digital outputs to work using
    more LEDs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0412)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Eight LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Eight 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ve provided both a physical layout diagram and the schematic for the required
    circuit, which you can use to assemble your circuit. The diagram in [Figure 2-20](nsp-boxall502581-0012.xhtml#f02020)
    indicates the physical connections you see with your own eyes, and the schematic
    in [Figure 2-21](nsp-boxall502581-0012.xhtml#f02021) indicates the same electrical
    connections between the various components in a more compact and easier-to-follow
    form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the physical circuit layout for Project 2](images/nsp-boxall502581-f02020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-20: Diagram for [Project 2](nsp-boxall502581-0012.xhtml#pro2)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 2](images/nsp-boxall502581-f02021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-21: Schematic for [Project 2](nsp-boxall502581-0012.xhtml#pro2)'
  prefs: []
  type: TYPE_NORMAL
- en: Connect your USBasp programmer to the circuit, then connect jumper wires between
    the programmer and the microcontroller using the information in [Table 2-2](nsp-boxall502581-0012.xhtml#tab0202)
    . Take note of the connections, as they will be the same every time you program
    an ATmega328P-PU microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 2-2 : USBasp to ATmega328P-PU Connections |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| USBasp pin | ATmega328P-PU pin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RST | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| GND | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| VCC | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| SCK | 19 |'
  prefs: []
  type: TYPE_TB
- en: '| MISO | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| MOSI | 17 |'
  prefs: []
  type: TYPE_TB
- en: 'Before uploading code to the microcontroller, test that the programmer is communicating
    with the ATmega328P-PU. Connect your USBasp programmer to your computer and open
    a terminal window. Enter the command `avrdude -p m328p -c usbasp -B 4` and press
    enter . The software toolchain should interrogate the programmer and microcontroller,
    and you should see the following output in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this `avrdude` command and the command used earlier
    to test your setup with the ATtiny85 is that we changed the microcontroller parameter
    `-p` to `m328p` . If you saw the correct output after entering this command, you
    can move forward; otherwise, review the “What If It Didn’t Work?” section on [page
    35](nsp-boxall502581-0012.xhtml#p35) .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0413)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the folder containing the two files for
    [Project 2](nsp-boxall502581-0012.xhtml#pro2) , and enter the command `make flash`
    . After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. Then the microcontroller
    should run the program, causing all eight of the LEDs to blink together.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, open the *main.c* file located in the *Project 2* subfolder
    of the *Chapter 2* folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in this project is identical to that of [Project 1](nsp-boxall502581-0012.xhtml#pro1)
    . However, because the ATmega328P-PU has a full PORTB register (that is, eight
    outputs), you can control all of them with the `PORTB` function. For some practice,
    change the `PORTB` lines to experiment with blinking LEDs. Try turning half of
    them on and half of them off by changing the line at ❶ to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'and the line at ❷ to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also increase the effects by adding more `PORTB` lines with different
    on/off states. Go crazy! Keep this circuit together when you’re done experimenting,
    since you’ll use it for the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll soon see how each bit of the PORTB register relates to a digital output
    on the microcontroller. However, there’s a better way to control the outputs to
    create complicated patterns. In the [next project](nsp-boxall502581-0012.xhtml#pro3)
    , you’ll use the same circuit to control outputs more efficiently with variables,
    functions, bit shifting, and bitwise arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 3: Bit-Shifting Digital Outputs](nsp-boxall502581-0008.xhtml#rpro3)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn more efficient ways to control the digital outputs.
    These techniques will give you more control over the outputs without excessive
    code, so that you don’t waste program memory in the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: This project uses the same hardware as [Project 2](nsp-boxall502581-0012.xhtml#pro2)
    , so you should have that set up already. Open a terminal window, navigate to
    the folder containing the two files for [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    , and enter the command `make flash` . Once again, the toolchain should process
    the code, and in a moment the LEDs should start blinking on and off in a repeating
    pattern from left to right, then from right to left, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the *main.c* file located in the *Project 3* subfolder of the *Chapter
    2* folder for a closer look at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code introduces some new concepts. First, the `#define` macro lets you
    assign values to words, which are called *constant values* or just *constants*
    for short. Constants make it possible to reference values later in your code and
    make your code easier to read. For example, `#define TIME 100` ❶ tells the compiler
    to replace the word `TIME` with the value 100 anywhere you use `TIME` in your
    code, as in the `__delay_ms_` lines ❹. To change the blink delay you only need
    to change the value in the original `#define` macro, and the compiler takes care
    of the rest. Whenever you use `#define` , you must place it before the main `int
    main(void)` loop in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main loop we define a *variable* , which that represents data. A
    variable’s value can change while the code is being executed, whereas the value
    of a constant defined by the `#define` macro cannot. You can think of a variable
    as a part of the microcontroller’s memory that stores a number you can change
    as needed during program execution. The first type of variable you’ll use in this
    book is an *integer* . In programming terms, this type can hold a whole number;
    that is, a number that can be positive, negative, or zero, without a fractional
    or decimal part.
  prefs: []
  type: TYPE_NORMAL
- en: To define a variable, first enter the type and then the label. The line `uint8_t
    i;` ❷ defines a variable called `i` of type `uint8_t` . This type of variable
    can store a whole number between 0 and 255 (the `u` stands for *unsigned* ; an
    unsigned integer cannot store negative numbers). The letter `i` now represents
    an integer whose value you can change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six types of integer variables you can make use of:'
  prefs: []
  type: TYPE_NORMAL
- en: • `uint8_t` is an 8-bit unsigned integer (0 to 255).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `int8_t` is an 8-bit signed integer (–128 to 127).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `uint16_t` is a 16-bit unsigned integer (0 to 65,535).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `int16_t` is a 16-bit signed integer (–32,768 to 32,767).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `uint32_t` is a 32-bit unsigned integer (0 to 4,294,967,295).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `int32_t` is a 32-bit signed integer (–2,147,483,648 to 2,147,483,647).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At first glance, you may think that the smaller integer types are redundant
    and that you should just use `int32_t` for all your integer needs. However, the
    larger the integer type, the more time it takes your microcontroller to process
    those numbers. To maximize efficiency, bear in mind the needs of your project
    when selecting an integer type, and use the smallest type that will accommodate
    the largest possible value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code also introduces `for` *loops* , which allow you to repeat a section
    of code without retyping it. Retyping is inefficient and wastes memory; `for`
    loops simply let you set how many times the code inside the loop will repeat.
    There are two `for` loops in the [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    code. Let’s look at the first one ❸:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A `for` loop repeats the code between the curly brackets as long as a certain
    condition is true. In this case, this loop will repeat until the value of the
    variable `i` is 8\. In the first section of the loop, we set the initial value of
    `i` to 0 using `i = 0` . The second section of the loop checks to see if the condition
    is true: in this case, if `i < 8` . The third section of the loop keeps track
    of how many times the code loops; `i++` means “add one to the value of `i` after
    each loop.” Every time the code between the curly brackets is executed, the value
    of `i` increases by one and the code checks to see if `i` is less than 8\. When
    `i` equals 8, the looping stops and the microcontroller moves on to the code after
    the `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final concept this project introduces is *bit shifting* , a technique that
    moves the bits in a binary number to the left or right. This helps you to efficiently
    use binary numbers in your `PORT` `x` functions to turn the output pins on and
    off. The `for` loop at ❸ shifts the first bit one to the left every time the loop
    completes. This is faster than using the equivalent eight `PORTB` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of wasting code on such functions, you can shift the first bit to the
    left with `<<` or to the right with `>>` , followed by the number of bits to move.
    For example, to turn the first three outputs in PORTB on and off in sequence,
    you could enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop at ❸ demonstrates shifting bits to the left with `<< i` . Here,
    `i` starts with a value of 0 in the first loop, meaning the first output is on.
    When the code loops again, `i` has a value of 1, meaning the second output is
    on, and so forth. In the same manner, the `for` loop at ❺ turns on the LEDs from
    left to right with `>>` .
  prefs: []
  type: TYPE_NORMAL
- en: You can manipulate outputs even more effectively with some deeper manipulation
    of the PORT *x* register using *bitwise arithmetic* . This is a way of manipulating
    numbers in the form of their individual bits that is directly supported by the
    microcontroller. Don’t let past experiences in math class scare you; it’s quite
    simple. The four operators you can use with numbers or variables to change the
    bits in a register are NOT, AND, OR, and XOR. You’ll see how they work in [Projects
    4](nsp-boxall502581-0012.xhtml#pro4) through [7](nsp-boxall502581-0012.xhtml#pro7)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 4: Experimenting with NOT](nsp-boxall502581-0008.xhtml#rpro4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The NOT ( `~` ) operator inverts all the bits in a number or register. If you
    place a tilde ( `~` ) in front of a number, it will be interpreted as the binary
    opposite. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Try this yourself by replacing the main loop from [Project 2](nsp-boxall502581-0012.xhtml#pro2)
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After the `~` line, all the pins on PORTB should be turned on. NOT (and all
    the other bitwise operators) is a useful tool to keep in your arsenal when planning
    out projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 5: Experimenting with AND](nsp-boxall502581-0008.xhtml#rpro5)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The AND ( `&` ) operator compares two binary numbers and returns a new binary
    number. If both numbers have 1s at the same position, the new number will have
    a 1 at that position, and the other bits will be 0s. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'AND is useful when you only want to turn outputs on depending on a certain
    value. [Project 5](nsp-boxall502581-0012.xhtml#pro5) demonstrates this by displaying
    binary numbers from 0 to 255\. Use the same circuit from [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    , and open the *main.c* file located in the *Project 5* subfolder of the *Chapter
    2* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `for` loop counts from 0 to 255\. Every time the code loops,
    it performs an AND on `0b11111111` and the variable `i` and sets `PORTB` to the
    result of the operation. For example, let’s say `i` has a value of 9, which is
    `0b00001001` . The result of `0b00001001 & 0b11111111` will be `0b00001001` because
    the bits in the ones and eights columns match. Thus, the `PORTB` setting will
    be `0b00001001` and all the LEDs for 1 and 4 will turn on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 6: Experimenting with OR](nsp-boxall502581-0008.xhtml#rpro6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The OR ( `|` ) operator compares two binary numbers and returns another binary
    number with 1s in any position where either operand had a bit set to 1\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This operator is useful when you want to turn outputs on when bits in either
    of two numbers have a certain value. To try it out, use the same circuit from
    [Project 3](nsp-boxall502581-0012.xhtml#pro3) and open the *main.c* file in the
    *Project 6* subfolder of the *Chapter 2* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The main loop counts from 0 to 255, as in the previous example. Every time the
    code loops, it performs an OR on `0b00001111` and the variable `i` and sets `PORTB`
    to the result of the operation. If `i` has a value of, for example, 0, which is
    `0b00000000` , the result of `0b00001111 | 0b00000000` will be `0b00001111` .
    Thus, the `PORTB` setting will be `0b0001111` , and the four LEDs on the right
    side will stay on.
  prefs: []
  type: TYPE_NORMAL
- en: As the value of `i` increases, the number of bits in `i` increases and more
    LEDs will turn on. For example, when `i` has a value of 128, or `0b10000000` ,
    the resulting `PORTB` is `0b10001111` . Load this code onto your AVR to see it
    in action, then experiment with the code and create your own OR situations to
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 7: Experimenting with XOR](nsp-boxall502581-0008.xhtml#rpro7)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final operator, XOR ( `^` ), compares the same bits in two numbers and
    returns a new binary number. Anywhere the two numbers had opposite bits in the
    same position, the new number will have a 1; anywhere the two numbers had identical
    bits, the new number will have a 0\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'XOR operators are useful when you want to turn outputs on when bits in two
    numbers have different values. To see how this works, use the same circuit from
    [Project 3](nsp-boxall502581-0012.xhtml#pro3) and open the *main.c* file located
    in the *Project 7* subfolder of the *Chapter 2* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the code’s main loop counts from 0 to 255\. Every time the code
    loops, it performs an XOR on `0b11111111` and the variable `i` and sets `PORTB`
    to the result of the operation. For example, if `i` has a value of 15, or `0b00001111`
    , the result of `0b11111111 ^ 0b00001111` is `0b11110000` .
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code on your AVR, it should demonstrate counting in binary
    from 0 to 255\. However, in this case the LEDs are lit in an inverse fashion—that
    is, numbers are shown with LEDs that are off, not on.
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter concludes, I encourage you to experiment with the code samples.
    Enjoy creating patterns, learning about bitwise arithmetic, and bit shifting using
    your newfound knowledge. In the [next chapter](nsp-boxall502581-0013.xhtml#ch03)
    , you’ll learn to use the inputs of your microcontrollers to create interactive
    devices.
  prefs: []
  type: TYPE_NORMAL
