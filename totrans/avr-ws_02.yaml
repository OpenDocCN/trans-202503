- en: '[2](nsp-boxall502581-0008.xhtml#rch02)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[2](nsp-boxall502581-0008.xhtml#rch02)'
- en: First Steps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一阶段
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: Now that you’ve installed the requisite software and are prepared to enter the
    world of AVR microcontrollers, this chapter will ease you into your first AVR
    projects with some basic circuits and code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经安装了所需的软件，并准备好进入 AVR 微控制器的世界，本章将通过一些基础电路和代码带您轻松进入第一个 AVR 项目。
- en: 'In this chapter, you’ll learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: • Test your setup for making AVR-based projects.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 测试您的 AVR 项目设置。
- en: • Read basic circuit schematics.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 阅读基础电路原理图。
- en: • Control LEDs with the digital output pins on both AVR microcontrollers, the
    ATtiny85 and the ATmega328P-PU.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 AVR 微控制器的数字输出引脚控制 LED，包括 ATtiny85 和 ATmega328P-PU。
- en: I’ll also show you how to start coding with `#define` macros and `for` loops,
    and how to use bitwise arithmetic and bit shifting to generate outputs efficiently.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将向您展示如何使用 `#define` 宏和 `for` 循环开始编写代码，以及如何使用按位算术和位移操作高效生成输出。
- en: '[Testing the Hardware and Toolchain](nsp-boxall502581-0008.xhtml#rah0401)'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[测试硬件和工具链](nsp-boxall502581-0008.xhtml#rah0401)'
- en: 'At this point, it’s wise to check that the USBasp programmer and the previously
    installed toolchain are working as expected. We’ll do this in three stages: by
    building a simple circuit, testing the USBasp, and uploading code to the microcontroller.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，明智的做法是检查 USBasp 编程器和之前安装的工具链是否按预期工作。我们将通过三个阶段来检查：构建一个简单的电路，测试 USBasp，并将代码上传到微控制器。
- en: '[Build the Circuit](nsp-boxall502581-0008.xhtml#rbh0401)'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[构建电路](nsp-boxall502581-0008.xhtml#rbh0401)'
- en: 'In this section you’ll build a simple device that flashes an LED on and off,
    which is a fun and simple way to test your hardware and toolchain. To get started,
    you’ll need the following hardware:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将构建一个简单的设备，使 LED 闪烁，这是测试硬件和工具链的一种有趣且简单的方法。要开始，您需要以下硬件：
- en: • USBasp programmer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATtiny85–20PU microcontroller
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATtiny85–20PU 微控制器
- en: • One 5 mm red LED
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 5 毫米红色 LED
- en: • One 560 Ω resistor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 560 Ω 电阻
- en: • Seven jumper wires
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 七根跳线
- en: Now let’s focus on the practical steps of putting the circuit together to make
    sure your toolchain works correctly and will hold up when we dig into meatier
    projects. To connect the components of your test circuit, first place the solderless
    breadboard on a flat surface, as shown in [Figure 2-1](nsp-boxall502581-0012.xhtml#f02001)
    .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于实际步骤，将电路连接起来，以确保您的工具链正常工作，并在我们深入更复杂的项目时能够稳定运行。要连接测试电路的组件，首先将无焊面包板放置在平坦的表面上，如[图
    2-1](nsp-boxall502581-0012.xhtml#f02001)所示。
- en: '![Photo of a 400-hole solderless breadboard](images/nsp-boxall502581-f02001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![400 孔无焊面包板的照片](images/nsp-boxall502581-f02001.jpg)'
- en: 'Figure 2-1: A solderless breadboard'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：无焊面包板
- en: Insert your ATtiny85 into the breadboard so that it sits across the vertical
    gap in the board’s top four rows, as shown in [Figure 2-2](nsp-boxall502581-0012.xhtml#f02002)
    , making sure you insert the microcontroller’s pin 1—indicated by the small circle
    beside the leg, as described in [Chapter 1](nsp-boxall502581-0011.xhtml#ch01)
    —into column e, row 1 of the breadboard. The pins are numbered in a counterclockwise
    direction from 1, so pin 4 is at the bottom left in this figure, and pin 8 is
    at the top right.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ATtiny85 插入面包板，使其横跨面包板顶部四行的垂直间隙，如[图 2-2](nsp-boxall502581-0012.xhtml#f02002)所示，确保将微控制器的引脚
    1——由引脚旁的小圆圈标记，如[第 1 章](nsp-boxall502581-0011.xhtml#ch01)中所描述——插入面包板的 e 列，第 1 行。引脚编号是按逆时针方向排列的，因此图中的引脚
    4 位于左下角，而引脚 8 位于右上角。
- en: '![Photo of an ATtiny85 microcontroller positioned at the top of a solderless
    breadboard](images/nsp-boxall502581-f02002.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![ATtiny85 微控制器放置在无焊面包板顶部的照片](images/nsp-boxall502581-f02002.jpg)'
- en: 'Figure 2-2: The AVR in the breadboard'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：AVR 微控制器在面包板中的位置
- en: Now take the 560 Ω resistor and insert one leg in the same row as pin 2 of the
    ATtiny85 and the other leg a few rows farther along. In [Figure 2-3](nsp-boxall502581-0012.xhtml#f02003)
    , I’ve inserted the second leg into row 8.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拿起 560 Ω 电阻，将一脚插入与 ATtiny85 引脚 2 相同的行，另一脚插入更远几行的位置。如[图 2-3](nsp-boxall502581-0012.xhtml#f02003)所示，我将第二脚插入第
    8 行。
- en: '![Adding the first resistor to the solderless breadboard from pin 2 of the
    microcontroller](images/nsp-boxall502581-f02003.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![将第一个电阻从微控制器引脚 2 插入无焊面包板的照片](images/nsp-boxall502581-f02003.jpg)'
- en: 'Figure 2-3: The resistor in the breadboard'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：面包板中的电阻
- en: Next, take a look at your LED. Note that one leg is longer than the other, as
    shown in [Figure 2-4](nsp-boxall502581-0012.xhtml#f02004) .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a red LED](images/nsp-boxall502581-f02004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: A typical LED'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Insert the LED into the solderless breadboard, with the longer leg in the same
    row as the lower end of the resistor (row 8 in our example) and the shorter leg
    two rows farther along, using [Figure 2-5](nsp-boxall502581-0012.xhtml#f02005)
    as a guide.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the red LED inserted into the solderless breadboard, with the anode
    connected to the other end of the resistor](images/nsp-boxall502581-f02005.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: Your circuit so far'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Take a jumper wire and insert one end into the same row as the LED’s shorter
    leg, then the other end into the same row as pin 4 of the ATtiny85, as demonstrated
    in [Figure 2-6](nsp-boxall502581-0012.xhtml#f02006) .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the circuit with a jumper wire between the LED cathode and microcontroller
    ground pin](images/nsp-boxall502581-f02006.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: The wiring begins!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve placed the components, I’ll show you how to get the code from
    your computer to the microcontroller with the AVR programmer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[Connect and Run the Programmer](nsp-boxall502581-0008.xhtml#rbh0402)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To connect the USBasp programmer to the breadboard, first connect six male to
    female jumper wires to the six connection pins on the USBasp, shown in [Figure 2-7](nsp-boxall502581-0012.xhtml#f02007)
    .
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of the connection pins on the USBasp programmer that connect to the
    circuit](images/nsp-boxall502581-f02007.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7: USBasp connection pins'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Next, connect each of the USBasp’s six pins to the ATtiny85 using the mapping
    in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201) . You’ll use these same connections
    every time you program an ATtiny85 microcontroller. Don’t worry for now about
    the meaning of the pin labels; I’ll explain them to you as we go along in the
    book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 2-1 : USBasp to ATtiny85 Connections |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| USBasp pin | ATtiny85 pin |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| RST | 1 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| GND | 4 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| VCC | 8 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| SCK | 7 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| MISO | 6 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| MOSI | 5 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '[Figure 2-8](nsp-boxall502581-0012.xhtml#f02008) illustrates the connections
    between the USBasp and an ATtiny85 described in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201)
    . I’ve removed the rest of the circuit to show just an example of the connections.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo showing the six connections between the USBasp programmer and the microcontroller
    on the solderless breadboard](images/nsp-boxall502581-f02008.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: A USBasp connected to an ATtiny85 on a solderless breadboard'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check the USBasp is working correctly by connecting your USBasp programmer
    to your computer. To do this, you’ll use a program that’s part of the installed
    toolchain called AVRDUDE, which is a utility to upload code to AVR microcontrollers.
    Open a terminal window and enter the command `avrdude -p t85 -c usbasp -B 4` .
    This command includes the following options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: • `-p` selects the type of microcontroller being used in the project. You used
    `t85` just now for the ATtiny85, and later you’ll use `m328p` for the ATmega328P-PU.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `-p` 选择项目中使用的微控制器类型。你刚才使用了 `t85` 代表 ATtiny85，稍后你将使用 `m328p` 代表 ATmega328P-PU。
- en: • `-c` selects the type of hardware programmer being used. In this case you’ve
    specified `usbasp` , representing your USBasp programmer.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `-c` 选择正在使用的硬件编程器类型。在这种情况下，你指定了 `usbasp`，代表你的 USBasp 编程器。
- en: • `-B` sets the processing speed of the microcontroller in the USBasp programmer.
    You set this value to `4` to bring the speed down to 187.5 kHz. This is necessary
    for new microcontrollers, as they are set at the factory with a clock speed of
    1 MHz, which is slower than the USBasp’s default speed. I’ll explain more about
    speeds in [Chapter 12](nsp-boxall502581-0022.xhtml#ch12) .
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `-B` 设置 USBasp 编程器中微控制器的处理速度。你将该值设置为 `4`，将速度降低到 187.5 kHz。这对新微控制器是必要的，因为它们在出厂时的时钟速度为
    1 MHz，低于 USBasp 的默认速度。关于速度的更多内容，我将在[第 12 章](nsp-boxall502581-0022.xhtml#ch12)
    中解释。
- en: 'The software toolchain should interrogate the programmer and microcontroller,
    and your terminal should look something like this afterward:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工具链应该与编程器和微控制器进行通信，你的终端显示应该像下面这样：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By reporting the *device signature* , a unique identifier for the type of AVR
    microcontroller, the software toolchain has indicated that all is well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过报告*设备签名*，即 AVR 微控制器类型的唯一标识符，软件工具链表示一切正常。
- en: The AVRDUDE documentation ( [http://www.nongnu.org/avrdude/user-manual/avrdude_4.html](http://www.nongnu.org/avrdude/user-manual/avrdude_4.html)
    ) describes other options beyond those included in this `avrdude` command, if
    you’re curious. For now, if you saw the correct output after entering that command,
    skip ahead to [Project 0](nsp-boxall502581-0012.xhtml#pro0) . You’re ready to
    program your AVR!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: AVRDUDE 文档（[http://www.nongnu.org/avrdude/user-manual/avrdude_4.html](http://www.nongnu.org/avrdude/user-manual/avrdude_4.html)）描述了除了
    `avrdude` 命令中包含的选项之外的其他选项，如果你感兴趣的话。目前，如果你在输入该命令后看到正确的输出，可以跳到[项目 0](nsp-boxall502581-0012.xhtml#pro0)。你已经准备好编程你的
    AVR 了！
- en: '[What If It Didn’t Work?](nsp-boxall502581-0008.xhtml#rbh0403)'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如果它没有成功怎么办？](nsp-boxall502581-0008.xhtml#rbh0403)'
- en: 'If, after running the command in the previous step, you got an error like the
    following, then there was a problem with the hardware connection between the programmer
    and the circuit:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行上一步骤中的命令后，出现类似下面的错误，那么说明编程器和电路之间的硬件连接存在问题：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don’t use `-F` to override the check, as the error message suggests. Instead,
    double-check the wiring between the USBasp and the solderless breadboard to make
    sure no connections are loose. Then check the circuit itself to confirm the components
    are connected to one another according to the instructions given in the “Build
    the Circuit” section. In particular, check that the ATtiny85’s pin 1 is aligned
    with the top-left corner of the breadboard. Orienting a chip incorrectly is one
    of the most common circuit errors!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不要像错误信息建议的那样使用 `-F` 来覆盖检查。相反，请仔细检查 USBasp 与无焊接面包板之间的连线，确保没有连接松动。然后检查电路本身，确认各个组件按“构建电路”部分的说明互相连接。特别是，检查
    ATtiny85 的引脚 1 是否与面包板的左上角对齐。错误地放置芯片是最常见的电路错误之一！
- en: If everything looks correct, try running the `avrdude` command again. It should
    work, but if it doesn’t, walk away for a few moments, then review the process
    again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切看起来都正确，再次尝试运行 `avrdude` 命令。它应该可以工作，但如果不行，离开几分钟，然后再回过头来复查整个过程。
- en: Using AVR Safely
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安全使用 AVR
- en: 'As we move on to our [first project](nsp-boxall502581-0012.xhtml#pro0) , a
    reminder about safety: as with any hobby or craft, it’s up to you to take care
    of yourself and those around you. In this book, I discuss working with basic hand
    tools, battery-powered electrical devices, sharp knives, cutters, and sometimes
    hot soldering irons. *At no point in your projects should you work directly with
    AC mains current* . That is, don’t directly wire anything you make to the wall
    outlets. Leave that to a licensed electrician who is trained for such work. Remember
    that direct contact with AC current could kill you.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入[第一个项目](nsp-boxall502581-0012.xhtml#pro0)之前，提醒大家注意安全：与任何爱好或手工艺一样，保护自己和周围的人是你的责任。在本书中，我讨论了使用基本手工工具、电池驱动的电器、锋利的刀具、切割工具，以及有时使用热烙铁。*在你的项目中，绝对不要直接接触交流电源*。也就是说，不要将你制作的任何东西直接连接到墙壁插座。把这部分交给经过训练的持证电工来处理。记住，直接接触交流电流可能致命。
- en: Once you’ve got your circuit working, keep it together, including the USBasp,
    as you’ll need all of this for the [first project](nsp-boxall502581-0012.xhtml#pro0)
    .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 0: Blinking an LED](nsp-boxall502581-0008.xhtml#rpro0)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a working circuit and programmer connection, it’s time to
    create and upload your first *program* (also known as *code* ), a set of instructions
    that tells the microcontroller how to accomplish a particular task.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this book, our programs will increase in length as the projects
    get more complex. Instead of typing out each piece of code included in the book,
    please download the ZIP file containing the book’s code from [http://www.nostarch.com/avr-workshop](http://www.nostarch.com/avr-workshop)
    . This file includes folders for each project (organized by chapter) that contain
    the code and anything else required to program the projects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Note If you’re reading an electronic version of this book, don’t copy and paste
    the code from the book into your text editor. Use the downloaded code files instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Projects in this book use the C programming language. Since C is popular across
    many microcontroller and computer platforms, it should be easy to find help if
    you need it and to share your work with others.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[Uploading Your First AVR Code](nsp-boxall502581-0008.xhtml#rbh0404)'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve downloaded and extracted the book’s code files, use a text editor
    to open the *main.c* file located in the *Project 0* subfolder of the *Chapter
    2* folder. This C file contains a small program that should cause your LED to
    blink on and off once you compile the code and upload it to the microcontroller.
    However, to get the desired effect, you’ll need to pair the C files for each of
    your projects with a *Makefile* .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: A Makefile contains a set of instructions for the toolchain to use when compiling
    and uploading your code to the microcontroller, including the microcontroller
    type, the CPU speed the microcontroller requires, and the type of programmer you
    plan to use. Every time you start a new project of your own, you should create
    a new folder for that project and place the *main.c* file and Makefile inside
    that folder. To save you time I’ve already done this for the [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    files and for all the other projects in this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: If you’re curious about the contents of the Makefile, open the one for [Project
    0](nsp-boxall502581-0012.xhtml#pro0) with a text editor and take a look. I’ll
    introduce any necessary changes to the Makefiles in the download bundle for this
    book as you progress with the projects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with these file types, it’s time to bring your [first
    project](nsp-boxall502581-0012.xhtml#pro0) to life using the circuit you constructed
    earlier in this chapter. If you closed it earlier, open a terminal window just
    as you did when testing the toolchain. Next, navigate to the folder containing
    the two files for [Project 0](nsp-boxall502581-0012.xhtml#pro0) , and enter the
    command `make flash` .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. The microcontroller should
    then start running the program; in this case, your LED should start blinking.
    During this process, the status should appear in the terminal window, as shown
    here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s take a look at the code to see how this program works:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line of *main.c* ❶ is a *comment* naming the program and describing
    what it’s intended to accomplish. When writing programs, it’s a good idea to add
    comments like these explaining how to use the program or highlighting other important
    details; they may prove useful when you revisit your code or share it with others.
    Comments can be any length you like, and you can use them anywhere in your program.
    To add a comment on a single line, enter two forward slashes and then the comment,
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The forward slashes tell the compiler in the software toolchain to ignore the
    rest of the text on the line when compiling the program. In your own projects,
    you can include comments spanning two or more lines by entering the characters
    `/*` on a line before the comment text, then ending the comment with the characters
    `*/` , as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Returning to *main.c* , the `include` statements ❷ tell the compiler to look
    inside a library file, like *avr/io.h* , for more information required to compile
    the program. There are many libraries, each allowing you to use different functions
    in your code, and you can even create your own if necessary. You’ll learn about
    that in [Chapter 10](nsp-boxall502581-0020.xhtml#ch10) .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: All the instructions to run the program appear between the curly brackets after
    `int main(void)` , where the main section of the program begins ❸. Within these
    brackets, the program configures certain *parameters* of the microcontroller—that
    is, certain settings to make various operations take place. First, the program
    tells the microcontroller which physical pins will be inputs or outputs ❹. You
    hooked your LED up to pin 2, which the AVR knows as PB3, so the code activates
    that pin as an output. (Don’t worry if this is a little confusing right now; I’ll
    cover inputs and outputs in detail in the next few chapters.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code between the curly brackets after `while(1)` ❺ should execute
    repeatedly, blinking the LED by continuously toggling whether pin 2 outputs a
    1 or a 0, until the microcontroller loses power or you reset it. A 1 supplies
    power to the LED, so that should turn the LED on, while a 0 should turn the LED
    off.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with the speed of the LED’s blinking, go back to *main.c* and
    replace `1000` in the two lines that read `_delay_ms(1000);` with any non-negative
    number you like. Then save the *main.c* file and rerun the `make flash` command.
    The LED should blink faster or slower, depending on the value you use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验LED闪烁的速度，返回到*main.c*文件，将两行`_delay_ms(1000);`中的`1000`替换为你喜欢的任何非负数值。然后保存*main.c*文件，并重新运行`make
    flash`命令。LED应该会根据你使用的值闪烁得更快或更慢。
- en: '[What If It Didn’t Work?](nsp-boxall502581-0008.xhtml#rbh0405)'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[如果它没有工作怎么办？](nsp-boxall502581-0008.xhtml#rbh0405)'
- en: 'If there is an error in your code, the compiler will indicate which line in
    the code contains the error, or a line very close to it. For example, here’s what
    happened when I ran the `make flash` command with a spelling mistake in line 10
    of the [Project 0](nsp-boxall502581-0012.xhtml#pro0) code. The compiler found
    the error and gave the resulting output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码中有错误，编译器会指示出包含错误的代码行，或与其非常接近的行。例如，当我在[项目0](nsp-boxall502581-0012.xhtml#pro0)的第10行代码中拼写错误时，运行`make
    flash`命令时会发生如下情况。编译器找到了错误，并给出了相应的输出：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this happens to you, open the *main.c* file in your text editor and locate
    and fix the mistake before trying another upload. To compile your program for
    this purpose without uploading it, just run the `make` command by itself in the
    terminal window.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，打开*main.c*文件，在文本编辑器中找到并修正错误，然后再尝试上传。为了在不上传程序的情况下编译程序，只需在终端窗口中单独运行`make`命令。
- en: Running `make` is a good way to check for errors like typos in the code, but
    it may not help you catch errors in logic—that is, whether you’ve correctly told
    the microcontroller what you want it to do. As a general rule, remember that even
    if your program compiles, it may not behave as you expect if you don’t carefully
    plan your instructions to the microcontroller before you write the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make`命令是检查代码中错误（如拼写错误）的一种好方法，但它可能无法帮助你发现逻辑错误——即你是否正确地告诉了微控制器你希望它执行的操作。作为一般规则，记住即使程序能编译成功，如果你在编写代码前没有仔细规划给微控制器的指令，它也可能无法按预期行为运行。
- en: '[Controlling Digital Outputs](nsp-boxall502581-0008.xhtml#rah0402)'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[控制数字输出](nsp-boxall502581-0008.xhtml#rah0402)'
- en: Now that you’ve seen the electronic components you’ll use in this book, let’s
    talk a bit more about the digital output pins on the ATtiny85 and the ATmega328P-PU.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了本书中将使用的电子元件，让我们再谈谈ATtiny85和ATmega328P-PU上的数字输出引脚。
- en: To recap, a digital output pin is a source of electrical current that you can
    control; it can be either on or off. On the ATtiny85 up to six pins can operate
    as outputs, and on the ATmega328P-PU up to eight pins can operate as outputs.
    I say “up to” because some pins can have more than one function, depending on
    how you set them up. I’ll explain how to select pin functions later in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，数字输出引脚是一个可以控制的电流源；它可以是开（on）或关（off）。在ATtiny85上最多有六个引脚可以作为输出工作，在ATmega328P-PU上最多有八个引脚可以作为输出工作。我说“最多”是因为有些引脚可以有多个功能，具体取决于你如何设置它们。稍后我会在本章中解释如何选择引脚功能。
- en: Each output pin offers a maximum amount of current. On the ATtiny85, that maximum
    is 40 mA. However, the total maximum current you can run through the IC is 200
    mA. Drawing too much current can cause problems, so to avoid any issues, assume
    you can have a maximum of 20 mA per output pin on the ATtiny85 and the ATmega328P-PU.
    Keep these ratings in the back of your mind when creating your own projects; all the
    projects in this book are designed to avoid this problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输出引脚提供的最大电流量是有限的。在ATtiny85上，这个最大值是40 mA。然而，你可以通过IC的总最大电流为200 mA。过多的电流可能会引发问题，因此为了避免任何问题，假设你在ATtiny85和ATmega328P-PU的每个输出引脚上最大电流为20
    mA。在创建自己的项目时，请记住这些额定值；本书中的所有项目都设计得能避免这个问题。
- en: '[Hardware Registers](nsp-boxall502581-0008.xhtml#rbh0406)'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件寄存器](nsp-boxall502581-0008.xhtml#rbh0406)'
- en: The key to understanding digital outputs is to learn about the *hardware registers*
    . Our AVR microcontrollers all have multiple registers that store information
    related to all the possible settings for the microcontroller’s operations. The
    numerical values placed inside these registers control digital outputs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数字输出的关键是学习*硬件寄存器*。我们的AVR微控制器都有多个寄存器，用于存储与微控制器操作的所有可能设置相关的信息。放入这些寄存器中的数值控制数字输出。
- en: The first AVR register to consider is called the *DDR* , for *data-direction
    register* . This is used to tell the microcontroller which pins are outputs and
    which are inputs. Some microcontrollers, such as the ATtiny85, will have only
    one DDR register, and some, like the ATmega328P-PU, will have more. The second
    register to consider is called *PORT* . You’ll use this to set which pins are
    on or off.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Each register is 8 bits in size, where a bit can be either a 0 or a 1, just
    like a binary number. Each bit relates to a physical pin on the microcontroller.
    In the DDR *x* registers, 1s indicate that a pin is an output and 0s indicate
    that a pin is an input. In the PORT *x* registers, 1s indicate that a pin is on
    and 0s indicate that a pin is off.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out how many pins and registers are available by looking at the
    data sheet for your microcontroller (you can download the ATtiny85’s data sheet
    from the Microchip website at [https://www.microchip.com/wwwproducts/en/ATtiny85](https://www.microchip.com/wwwproducts/en/ATtiny85)
    ). For example, the diagram in [Figure 2-9](nsp-boxall502581-0012.xhtml#f02009)
    shows that there is one PORT register on the ATtiny85: the PORTB register, which
    spans pins 5, 6, 7, 3, 2, and 1.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the ATtiny85 microcontroller’s pins and their functions](images/nsp-boxall502581-f02009.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: Pinouts and PORT registers for the ATtiny85'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: PORT register names are usually abbreviated on diagrams and data sheets; in
    [Figure 2-9](nsp-boxall502581-0012.xhtml#f02009) , the PORTB register is referred
    to as PB, with each pin labeled as PB *x* , where *x* is the number of the pin.
    You’ll refer to this register as `PORTB` in your code. The matching DDR register
    is called DDRB, as it controls the data direction for PORTB. Please note that
    you can only use pins PB0 through PB4, as PB5 has other functions, which we’ll
    examine later.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'To set some of the pins in the DDRB register to outputs, just set the respective
    bits to 1s. As an example, let’s revisit the code from [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    :'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code sets the physical pin 2 to an output ❶. To set all the PORTB pins
    to outputs, you could use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s examine how this works. The physical pins of the DDRB register of your
    ATtiny85 are 1, 3, 2, 7, 6, and 5\. Each pin corresponds to a single bit in the
    register; from left to right, those pins are bits 5, 3, 4, 2, 1, and 0, respectively.
    So, for example, to set physical pin 6 (PB1) as an output and the rest as inputs
    you would use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And, as we saw in the [Project 0](nsp-boxall502581-0012.xhtml#pro0) code, to
    set physical pin 2 (PB3) as an output and the rest as inputs you would use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We call the bit on the right-hand side of the register the *first bit* or *least
    significant bit (LSB)* and the bit on the left-hand side the *last bit* or *most
    significant bit (MSB)* . This may seem backward at first, but bits are the equivalent
    of binary numbers, whose contents are referenced using the same method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the ATtiny85 has only six outputs, you can leave the last two bits
    (6 and 7) as 0s or 1s in the DDRB statement. Once you’ve set a pin to an output,
    use the `PORT` `x` function to switch the output on or off. To turn all the outputs
    on, use:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ATtiny85只有六个输出，你可以在DDRB语句中将最后两个位（6和7）设置为0或1。一旦你将引脚设置为输出，可以使用`PORT` `x`函数来切换输出的开关。要将所有输出打开，请使用：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To turn them all off, use:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们全部关闭，请使用：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or to turn, say, pins 3 (PB4) and 5 (PB0) on and the rest off, use:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要打开3号引脚（PB4）和5号引脚（PB0），并将其余引脚关闭，可以使用：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To experiment with these functions, in the [next project](nsp-boxall502581-0012.xhtml#pro1)
    you’ll build a new circuit like the one in [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    , but this time with four LEDs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验这些功能，在[下一个项目](nsp-boxall502581-0012.xhtml#pro1)中，你将构建一个类似于[项目 0](nsp-boxall502581-0012.xhtml#pro0)的电路，但这次将使用四颗LED。
- en: '[Project 1: Experimenting with ATtiny85 Digital Outputs](nsp-boxall502581-0008.xhtml#rpro1)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 1：实验 ATtiny85 数字输出](nsp-boxall502581-0008.xhtml#rpro1)'
- en: To practice and increase your understanding of using the ATtiny85’s DDRB and
    PORTB registers, in this project you’ll control four output devices (LEDs). Although
    blinking LEDs may seem a somewhat trivial example, the ability to control digital
    outputs is the foundation for controlling a wide range of objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习并增加对使用ATtiny85的DDRB和PORTB寄存器的理解，在这个项目中你将控制四个输出设备（LED）。尽管闪烁的LED看起来可能是一个相对简单的例子，但控制数字输出的能力是控制各种对象的基础。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0407)'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh0407)'
- en: 'You will need the following hardware:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATtiny85–20PU microcontroller
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATtiny85–20PU 微控制器
- en: • Four LEDs
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 四个LED
- en: • Four 560 Ω resistors
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 四个 560 Ω 电阻
- en: • Jumper wires
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: The circuit for this project is similar to the one in [Project 0](nsp-boxall502581-0012.xhtml#pro0)
    , but with three more LEDs. Assemble your circuit as shown in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的电路与[项目 0](nsp-boxall502581-0012.xhtml#pro0)中的类似，只是多了三颗LED。请按照[图 2-10](nsp-boxall502581-0012.xhtml#f02010)中的方式组装电路。
- en: '![Diagram of the physical circuit layout for Project 1](images/nsp-boxall502581-f02010.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![项目 1 物理电路布局图](images/nsp-boxall502581-f02010.jpg)'
- en: 'Figure 2-10: A physical layout diagram of the main circuit for [Project 1](nsp-boxall502581-0012.xhtml#pro1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-10：用于[项目 1](nsp-boxall502581-0012.xhtml#pro1)的主电路物理布局图
- en: Once you’ve assembled your circuit, connect the USBasp programmer. Repeat the
    connections as shown in [Table 2-1](nsp-boxall502581-0012.xhtml#tab0201) .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你组装好电路，连接USBasp编程器。按照[表 2-1](nsp-boxall502581-0012.xhtml#tab0201)中的连接方式进行重复连接。
- en: Note If you’d like to try creating diagrams like the one in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    , use Autodesk Tinkercad, available at [https://www.tinkercad.com/](https://www.tinkercad.com/)
    .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试创建像[图 2-10](nsp-boxall502581-0012.xhtml#f02010)中的图示一样的图表，可以使用Autodesk
    Tinkercad，网址：[https://www.tinkercad.com/](https://www.tinkercad.com/)。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0408)'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0408)'
- en: Open a terminal window, navigate to the folder containing the two files for
    [Project 1](nsp-boxall502581-0012.xhtml#pro1) , and enter the command `make flash`
    . After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. Then the microcontroller
    should run the program that turns the digital outputs on and off, causing all
    four of the LEDs to blink.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到包含[项目 1](nsp-boxall502581-0012.xhtml#pro1)两个文件的文件夹，并输入命令`make flash`。稍等片刻，工具链应会编译程序文件，并创建所需的数据文件上传到微控制器。然后，微控制器将运行该程序，控制数字输出的开关，从而使四个LED灯闪烁。
- en: 'To see how this works, open the *main.c* file located in the *Project 1* subfolder
    of the *Chapter 2* folder:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个是如何工作的，请打开位于*Chapter 2*文件夹中*Project 1*子文件夹中的*main.c*文件：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'First we use `DDRB` to set all the pins to outputs ❶. The `_delay_ms()` function
    ❷ tells the microcontroller to stop everything for a set period of time. To use
    a delay, just enter the number of milliseconds you want the program to pause inside
    the parentheses: `_delay_ms(250)` sets the delay to 250 milliseconds. Next, we
    turn on the digital outputs so current will flow from the pins, through the resistors
    and LEDs, and then to GND, completing the electrical circuit ❸. After another
    delay we turn off the digital outputs, causing the LEDs to turn off ❹.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: By now you should understand how to set the pins on the ATtiny85 to outputs,
    turn them on and off, and create a delay. Experiment with the delay and pins by
    changing which LEDs turn on and off, the length of the delay, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Schematic Diagrams](nsp-boxall502581-0008.xhtml#rah0403)'
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Projects 0](nsp-boxall502581-0012.xhtml#pro0) and [1](nsp-boxall502581-0012.xhtml#pro1)
    showed you how to build circuits using a picture and a physical layout diagram,
    respectively. Physical layout diagrams like the one in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    may seem like the easiest way to diagram a circuit, but as you add more components,
    direct representations make physical diagrams a real mess. Because your circuits
    are about to get more complicated, from now on I’ll use *schematic diagrams* (also
    known as *circuit diagrams* ) to illustrate them, like the one shown in [Figure
    2-11](nsp-boxall502581-0012.xhtml#f02011) .'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a simple microcontroller circuit schematic](images/nsp-boxall502581-f02011.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: An example schematic diagram'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Schematics are road maps that show where electrical current flows through various
    components, with the lines between components indicating those paths. Instead
    of showing components and wires, a schematic uses symbols and lines.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[Components in Schematics](nsp-boxall502581-0008.xhtml#rbh0409)'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you know what the symbols mean, reading a schematic is easy. To begin,
    let’s examine the symbols for the components you’ve already used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-12](nsp-boxall502581-0012.xhtml#f02012) shows the ATtiny85 microcontroller
    symbol. The pin numbers are labeled clearly; don’t forget that pin 1 is at the
    top left on the physical chip. Other microcontrollers and ICs use similar symbols,
    but their size depends on the number of pins.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for the ATtiny85–20PU microcontroller](images/nsp-boxall502581-f02012.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: The ATtiny85 microcontroller symbol'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-13](nsp-boxall502581-0012.xhtml#f02013) shows the resistor symbol.
    It’s good practice to display the resistor value and part designator along with
    the resistor symbol (220 Ω and R1, in this case). This makes life a lot easier
    for everyone trying to make sense of the schematic, including you!'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a common resistor](images/nsp-boxall502581-f02013.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: The resistor symbol'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-14](nsp-boxall502581-0012.xhtml#f02014) shows the LED symbol. All
    members of the diode family share a common symbol, the triangle and vertical line,
    but LED symbols show two parallel arrows pointing away from the triangle to indicate
    that light is being emitted.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a common LED](images/nsp-boxall502581-f02014.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14: The LED symbol'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of the various component schematic symbols,
    I’ll show you how the wired connections between the components are shown in circuit
    schematics.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[Wires in Schematics](nsp-boxall502581-0008.xhtml#rbh0410)'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When wires cross or connect in schematics, they are drawn in the following ways:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Crossing but not connected wires
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: When two wires cross but are not connected, the crossing can be represented
    in one of two ways, as shown in [Figure 2-15](nsp-boxall502581-0012.xhtml#f02015)
    . Either way is correct; it’s just a matter of preference.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Two ways of representing non-connecting wires in circuit schematics](images/nsp-boxall502581-f02015.jpg)'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2-15: Non-connecting crossed wires'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connected wires
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When wires are physically connected, a *junction dot* is drawn at the point
    of connection, as shown in [Figure 2-16](nsp-boxall502581-0012.xhtml#f02016) .
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Representation of connected wires in a circuit schematic](images/nsp-boxall502581-f02016.jpg)'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2-16: Two wires that are connected'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wire connected to ground
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The symbol shown in [Figure 2-17](nsp-boxall502581-0012.xhtml#f02017) indicates
    when a wire is connected to ground (GND).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Schematic symbol for circuit ground](images/nsp-boxall502581-f02017.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2-17: The GND symbol'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The GND symbol at the end of a line in a schematic tells you that the wire is
    physically connected to the microcontroller’s GND pin. For your circuits, this
    is also known as the *negative* .
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Dissecting a Schematic](nsp-boxall502581-0008.xhtml#rbh0411)'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know the symbols for the parts you’ve used so far, let’s dissect
    the schematic you’d draw for [Project 1](nsp-boxall502581-0012.xhtml#pro1) . Compare
    the schematic shown in [Figure 2-18](nsp-boxall502581-0012.xhtml#f02018) with
    physical image of the circuit in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 1](images/nsp-boxall502581-f02018.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-18: Schematic for [Project 1](nsp-boxall502581-0012.xhtml#pro1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The arrow with +5V written above it represents the 5 V power supply on the breadboard,
    and the ATtiny85 is labeled with its chip name. LEDs 1 through 4 are connected
    to the ATtiny85 at the same pins you saw in [Figure 2-10](nsp-boxall502581-0012.xhtml#f02010)
    , and just like in the original circuit, all four resistors attached to the LEDs
    go to GND, pin 4 on the microcontroller. Note the dots at the junctions of R1,
    R2, R3, and R4, which indicate that those resistors are all connected to the same
    place (GND). The Xs on pins 1 and 3 in [Figure 2-18](nsp-boxall502581-0012.xhtml#f02018)
    signal that those pins are not connected to anything.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In this schematic, you can trace the flow of current from the power supply through
    the circuit to ground. Current is sourced from the 5 V power supply and enters
    the microcontroller. Our code then allows the current to flow from digital output
    pins when required. This current goes through an LED (which causes the LED to
    glow) and the resistor (which regulates the current) before reaching ground and
    completing the circuit.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Note If you’d like to create your own computer-drawn schematics, try the open
    source KiCad package, available for free or with a donation from [https://www.kicad.org/](https://www.kicad.org/)
    .
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Along with using the ATmega328P-PU for the first time, the [following project](nsp-boxall502581-0012.xhtml#pro2)
    will also put your new knowledge of reading circuit schematics to use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 2: Experimenting with ATmega328P-PU Digital Outputs](nsp-boxall502581-0008.xhtml#rpro2)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: You can tell at a glance that the ATmega328P-PU has more digital outputs than
    the ATtiny85\. The pinout diagram from the data sheet in [Figure 2-19](nsp-boxall502581-0012.xhtml#f02019)
    gives the details.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the ATmega328P-PU’s pins and their functions](images/nsp-boxall502581-f02019.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-19: The ATmega328P-PU pinout and port register diagram'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two registers you can use for digital outputs: PORTB (PB) and PORTD
    (PD). For this and the following few projects, you’ll use the PORTB register.
    In this project, you’ll put the ATmega328P-PU’s digital outputs to work using
    more LEDs.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0412)'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Eight LEDs
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Eight 560 Ω resistors
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ve provided both a physical layout diagram and the schematic for the required
    circuit, which you can use to assemble your circuit. The diagram in [Figure 2-20](nsp-boxall502581-0012.xhtml#f02020)
    indicates the physical connections you see with your own eyes, and the schematic
    in [Figure 2-21](nsp-boxall502581-0012.xhtml#f02021) indicates the same electrical
    connections between the various components in a more compact and easier-to-follow
    form.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of the physical circuit layout for Project 2](images/nsp-boxall502581-f02020.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-20: Diagram for [Project 2](nsp-boxall502581-0012.xhtml#pro2)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 2](images/nsp-boxall502581-f02021.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-21: Schematic for [Project 2](nsp-boxall502581-0012.xhtml#pro2)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Connect your USBasp programmer to the circuit, then connect jumper wires between
    the programmer and the microcontroller using the information in [Table 2-2](nsp-boxall502581-0012.xhtml#tab0202)
    . Take note of the connections, as they will be the same every time you program
    an ATmega328P-PU microcontroller.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 2-2 : USBasp to ATmega328P-PU Connections |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| USBasp pin | ATmega328P-PU pin |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| RST | 1 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| GND | 8 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| VCC | 7 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| SCK | 19 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| MISO | 18 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| MOSI | 17 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: 'Before uploading code to the microcontroller, test that the programmer is communicating
    with the ATmega328P-PU. Connect your USBasp programmer to your computer and open
    a terminal window. Enter the command `avrdude -p m328p -c usbasp -B 4` and press
    enter . The software toolchain should interrogate the programmer and microcontroller,
    and you should see the following output in your terminal:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only difference between this `avrdude` command and the command used earlier
    to test your setup with the ATtiny85 is that we changed the microcontroller parameter
    `-p` to `m328p` . If you saw the correct output after entering this command, you
    can move forward; otherwise, review the “What If It Didn’t Work?” section on [page
    35](nsp-boxall502581-0012.xhtml#p35) .
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0413)'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the folder containing the two files for
    [Project 2](nsp-boxall502581-0012.xhtml#pro2) , and enter the command `make flash`
    . After a moment, the toolchain should compile the program file and create the
    required data file to upload to the microcontroller. Then the microcontroller
    should run the program, causing all eight of the LEDs to blink together.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, open the *main.c* file located in the *Project 2* subfolder
    of the *Chapter 2* folder.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code in this project is identical to that of [Project 1](nsp-boxall502581-0012.xhtml#pro1)
    . However, because the ATmega328P-PU has a full PORTB register (that is, eight
    outputs), you can control all of them with the `PORTB` function. For some practice,
    change the `PORTB` lines to experiment with blinking LEDs. Try turning half of
    them on and half of them off by changing the line at ❶ to:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and the line at ❷ to:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also increase the effects by adding more `PORTB` lines with different
    on/off states. Go crazy! Keep this circuit together when you’re done experimenting,
    since you’ll use it for the rest of this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: You’ll soon see how each bit of the PORTB register relates to a digital output
    on the microcontroller. However, there’s a better way to control the outputs to
    create complicated patterns. In the [next project](nsp-boxall502581-0012.xhtml#pro3)
    , you’ll use the same circuit to control outputs more efficiently with variables,
    functions, bit shifting, and bitwise arithmetic.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 3: Bit-Shifting Digital Outputs](nsp-boxall502581-0008.xhtml#rpro3)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn more efficient ways to control the digital outputs.
    These techniques will give you more control over the outputs without excessive
    code, so that you don’t waste program memory in the microcontroller.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: This project uses the same hardware as [Project 2](nsp-boxall502581-0012.xhtml#pro2)
    , so you should have that set up already. Open a terminal window, navigate to
    the folder containing the two files for [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    , and enter the command `make flash` . Once again, the toolchain should process
    the code, and in a moment the LEDs should start blinking on and off in a repeating
    pattern from left to right, then from right to left, and so on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the *main.c* file located in the *Project 3* subfolder of the *Chapter
    2* folder for a closer look at how this works:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code introduces some new concepts. First, the `#define` macro lets you
    assign values to words, which are called *constant values* or just *constants*
    for short. Constants make it possible to reference values later in your code and
    make your code easier to read. For example, `#define TIME 100` ❶ tells the compiler
    to replace the word `TIME` with the value 100 anywhere you use `TIME` in your
    code, as in the `__delay_ms_` lines ❹. To change the blink delay you only need
    to change the value in the original `#define` macro, and the compiler takes care
    of the rest. Whenever you use `#define` , you must place it before the main `int
    main(void)` loop in the code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main loop we define a *variable* , which that represents data. A
    variable’s value can change while the code is being executed, whereas the value
    of a constant defined by the `#define` macro cannot. You can think of a variable
    as a part of the microcontroller’s memory that stores a number you can change
    as needed during program execution. The first type of variable you’ll use in this
    book is an *integer* . In programming terms, this type can hold a whole number;
    that is, a number that can be positive, negative, or zero, without a fractional
    or decimal part.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: To define a variable, first enter the type and then the label. The line `uint8_t
    i;` ❷ defines a variable called `i` of type `uint8_t` . This type of variable
    can store a whole number between 0 and 255 (the `u` stands for *unsigned* ; an
    unsigned integer cannot store negative numbers). The letter `i` now represents
    an integer whose value you can change.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six types of integer variables you can make use of:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: • `uint8_t` is an 8-bit unsigned integer (0 to 255).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `int8_t` is an 8-bit signed integer (–128 to 127).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `uint16_t` is a 16-bit unsigned integer (0 to 65,535).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `int16_t` is a 16-bit signed integer (–32,768 to 32,767).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `uint32_t` is a 32-bit unsigned integer (0 to 4,294,967,295).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `int32_t` is a 32-bit signed integer (–2,147,483,648 to 2,147,483,647).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At first glance, you may think that the smaller integer types are redundant
    and that you should just use `int32_t` for all your integer needs. However, the
    larger the integer type, the more time it takes your microcontroller to process
    those numbers. To maximize efficiency, bear in mind the needs of your project
    when selecting an integer type, and use the smallest type that will accommodate
    the largest possible value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'This code also introduces `for` *loops* , which allow you to repeat a section
    of code without retyping it. Retyping is inefficient and wastes memory; `for`
    loops simply let you set how many times the code inside the loop will repeat.
    There are two `for` loops in the [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    code. Let’s look at the first one ❸:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A `for` loop repeats the code between the curly brackets as long as a certain
    condition is true. In this case, this loop will repeat until the value of the
    variable `i` is 8\. In the first section of the loop, we set the initial value of
    `i` to 0 using `i = 0` . The second section of the loop checks to see if the condition
    is true: in this case, if `i < 8` . The third section of the loop keeps track
    of how many times the code loops; `i++` means “add one to the value of `i` after
    each loop.” Every time the code between the curly brackets is executed, the value
    of `i` increases by one and the code checks to see if `i` is less than 8\. When
    `i` equals 8, the looping stops and the microcontroller moves on to the code after
    the `for` loop.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The final concept this project introduces is *bit shifting* , a technique that
    moves the bits in a binary number to the left or right. This helps you to efficiently
    use binary numbers in your `PORT` `x` functions to turn the output pins on and
    off. The `for` loop at ❸ shifts the first bit one to the left every time the loop
    completes. This is faster than using the equivalent eight `PORTB` functions:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Instead of wasting code on such functions, you can shift the first bit to the
    left with `<<` or to the right with `>>` , followed by the number of bits to move.
    For example, to turn the first three outputs in PORTB on and off in sequence,
    you could enter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `for` loop at ❸ demonstrates shifting bits to the left with `<< i` . Here,
    `i` starts with a value of 0 in the first loop, meaning the first output is on.
    When the code loops again, `i` has a value of 1, meaning the second output is
    on, and so forth. In the same manner, the `for` loop at ❺ turns on the LEDs from
    left to right with `>>` .
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You can manipulate outputs even more effectively with some deeper manipulation
    of the PORT *x* register using *bitwise arithmetic* . This is a way of manipulating
    numbers in the form of their individual bits that is directly supported by the
    microcontroller. Don’t let past experiences in math class scare you; it’s quite
    simple. The four operators you can use with numbers or variables to change the
    bits in a register are NOT, AND, OR, and XOR. You’ll see how they work in [Projects
    4](nsp-boxall502581-0012.xhtml#pro4) through [7](nsp-boxall502581-0012.xhtml#pro7)
    .
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 4: Experimenting with NOT](nsp-boxall502581-0008.xhtml#rpro4)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The NOT ( `~` ) operator inverts all the bits in a number or register. If you
    place a tilde ( `~` ) in front of a number, it will be interpreted as the binary
    opposite. For example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Try this yourself by replacing the main loop from [Project 2](nsp-boxall502581-0012.xhtml#pro2)
    with the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the `~` line, all the pins on PORTB should be turned on. NOT (and all
    the other bitwise operators) is a useful tool to keep in your arsenal when planning
    out projects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 5: Experimenting with AND](nsp-boxall502581-0008.xhtml#rpro5)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The AND ( `&` ) operator compares two binary numbers and returns a new binary
    number. If both numbers have 1s at the same position, the new number will have
    a 1 at that position, and the other bits will be 0s. For example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'AND is useful when you only want to turn outputs on depending on a certain
    value. [Project 5](nsp-boxall502581-0012.xhtml#pro5) demonstrates this by displaying
    binary numbers from 0 to 255\. Use the same circuit from [Project 3](nsp-boxall502581-0012.xhtml#pro3)
    , and open the *main.c* file located in the *Project 5* subfolder of the *Chapter
    2* folder:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this code, the `for` loop counts from 0 to 255\. Every time the code loops,
    it performs an AND on `0b11111111` and the variable `i` and sets `PORTB` to the
    result of the operation. For example, let’s say `i` has a value of 9, which is
    `0b00001001` . The result of `0b00001001 & 0b11111111` will be `0b00001001` because
    the bits in the ones and eights columns match. Thus, the `PORTB` setting will
    be `0b00001001` and all the LEDs for 1 and 4 will turn on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 6: Experimenting with OR](nsp-boxall502581-0008.xhtml#rpro6)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The OR ( `|` ) operator compares two binary numbers and returns another binary
    number with 1s in any position where either operand had a bit set to 1\. For example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This operator is useful when you want to turn outputs on when bits in either
    of two numbers have a certain value. To try it out, use the same circuit from
    [Project 3](nsp-boxall502581-0012.xhtml#pro3) and open the *main.c* file in the
    *Project 6* subfolder of the *Chapter 2* folder:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The main loop counts from 0 to 255, as in the previous example. Every time the
    code loops, it performs an OR on `0b00001111` and the variable `i` and sets `PORTB`
    to the result of the operation. If `i` has a value of, for example, 0, which is
    `0b00000000` , the result of `0b00001111 | 0b00000000` will be `0b00001111` .
    Thus, the `PORTB` setting will be `0b0001111` , and the four LEDs on the right
    side will stay on.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: As the value of `i` increases, the number of bits in `i` increases and more
    LEDs will turn on. For example, when `i` has a value of 128, or `0b10000000` ,
    the resulting `PORTB` is `0b10001111` . Load this code onto your AVR to see it
    in action, then experiment with the code and create your own OR situations to
    practice.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 7: Experimenting with XOR](nsp-boxall502581-0008.xhtml#rpro7)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The final operator, XOR ( `^` ), compares the same bits in two numbers and
    returns a new binary number. Anywhere the two numbers had opposite bits in the
    same position, the new number will have a 1; anywhere the two numbers had identical
    bits, the new number will have a 0\. For example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'XOR operators are useful when you want to turn outputs on when bits in two
    numbers have different values. To see how this works, use the same circuit from
    [Project 3](nsp-boxall502581-0012.xhtml#pro3) and open the *main.c* file located
    in the *Project 7* subfolder of the *Chapter 2* folder:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once again, the code’s main loop counts from 0 to 255\. Every time the code
    loops, it performs an XOR on `0b11111111` and the variable `i` and sets `PORTB`
    to the result of the operation. For example, if `i` has a value of 15, or `0b00001111`
    , the result of `0b11111111 ^ 0b00001111` is `0b11110000` .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code on your AVR, it should demonstrate counting in binary
    from 0 to 255\. However, in this case the LEDs are lit in an inverse fashion—that
    is, numbers are shown with LEDs that are off, not on.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter concludes, I encourage you to experiment with the code samples.
    Enjoy creating patterns, learning about bitwise arithmetic, and bit shifting using
    your newfound knowledge. In the [next chapter](nsp-boxall502581-0013.xhtml#ch03)
    , you’ll learn to use the inputs of your microcontrollers to create interactive
    devices.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
