- en: '**12  PIC18F452 ICSP and HID**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in 2010, there was a lot of interest in exploiting RFID tags that hold
    symmetric keys. The cards themselves were reasonably well protected from memory
    extraction, and keys might be unique to each customer’s installation, so researchers
    would instead attack the readers. These readers often used commodity microcontrollers
    and trusted their readout protection to keep the symmetric keys safe.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll cover two such exploits that were used to extract keys
    from HID iClass readers. Both of them exploit nuances in ICSP, Microchip’s in
    circuit serial programming standard. The first, published at 27C3 as Meriac (2010),
    involves erasing a protected page of flash memory over ICSP and replacing it with
    shellcode that dumps the rest. The second, Huffstutter (2011), involves using
    the same ICSP protocol to dump RAM, rather than flash memory, because the chip
    has no protection bits set for RAM.
  prefs: []
  type: TYPE_NORMAL
- en: The target reader in this case is the HID RW400, which was chosen by Meriac
    because it was the oldest programmer to support the iClass cards. This is shown
    in [Figure 12.1](ch12.xhtml#ch12fig1), where an opaque epoxy potting covers the
    circuits that we can see in X-ray in [Figure 12.2](ch12.xhtml#ch12fig2).
  prefs: []
  type: TYPE_NORMAL
- en: There are many minor variants of the ICSP protocol, each explained in a “FLASH
    Microcontroller Programming Specification” document that covers ten or twenty
    part numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Older chips require a high voltage for erasure to be externally applied, while
    modern chips also support a low-voltage mode in which the programming voltage
    is internally generated. If no other vulnerabilities are handy, it would certainly
    be worth experimenting with bad voltages and timing here. [Chapter H.1](app08.xhtml#app08_1)
    describes just such an attack from the Nineties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0120-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: HID RW400 Card Reader'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0121-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: HID RW400 in X-ray'
  prefs: []
  type: TYPE_NORMAL
- en: PIC18 is a bit less threadbare than the earlier PIC architectures, but it is
    still designed around a philosophy of reusing as many components as possible in
    order to keep the transistor count as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The ICSP protocol looks much like SPI, except that there is a single data pin
    whose direction changes as appropriate. See [Figure 12.3](ch12.xhtml#ch12fig3)
    for the pinout of the six pins to the left of the piezoelectric buzzer in [Figure
    12.1](ch12.xhtml#ch12fig1). All transactions are exactly twenty bits, consisting
    of a 4-bit opcode command and a 16-bit parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In ICSP, command `0000` executes the parameter as a raw PIC18 instruction. `0010`
    reads out the `TABLAT` (Table Latch) register, while `1000` to `1011` are Table
    Read commands and `1100` to `1111` are Table Write commands. This is a rather
    roundabout way to read code memory, but it is roughly in line with the table pointer
    operations in PIC18 assembly language. The programming specification contains
    example pairs of commands and instructions for erasing memory and writing code
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: Flash (code), RAM, and EEPROM are in separate address spaces, and a series of
    Configuration Words describe the protection settings, along with settings for
    the oscillators, timers, brownout protection, and other configurable features.
    These 16-bit words begin at `0x300000` in flash memory. To the developer, these
    settings are defined as `#pragma` lines, such as those in [Figure 12.4](ch12.xhtml#ch12fig4).
  prefs: []
  type: TYPE_NORMAL
- en: Code memory is divided into pages of somewhat awkward sizes. The first is a
    bootloader page of 512 bytes at `0x0000`, followed by 7,680 bytes of Page 0 from
    `0x0200` to `0x1fff`. The remaining pages are each 8kB. See [Figure 12.6](ch12.xhtml#ch12fig6)
    for a diagram of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0123-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Custom ICSP Pinout on the HID RW400'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0123-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Configuration Words of the HID RW400 Reader'
  prefs: []
  type: TYPE_NORMAL
- en: Each page has a `CP` bit. This bit is cleared to enable Code Protection, a `WRT`
    bit to enable Write Protection, and an `EBT` bit to enable Table Read Protection
    so that code running from another page may not read this page as data through
    the table interface. These bits are set by erasing the page in question.
  prefs: []
  type: TYPE_NORMAL
- en: '**Meriac’s Boot Block Exploit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Milosch Meriac wanted to dump this chip from an HID RW400 reader in Meriac
    (2010), he found that the `CP` and `WRT` bits had been cleared so that instructions
    executing from the ICSP context were not permitted to read or write any blocks
    of flash memory. He chose these readers because they were the oldest to support
    the iClass cards, and you can find the configuration bits of a reader in [Figure
    12.4](ch12.xhtml#ch12fig4).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `EBT` bits had not been cleared. If they had been, code running
    from one page of flash memory would not be allowed to perform table reads on any
    other page. Because these bits are still set, the entire chip’s memory can be
    dumped from code running in any page.
  prefs: []
  type: TYPE_NORMAL
- en: Meriac observed that by erasing a page, he could set the `CP`, `WRT`, and `EBT`
    bits of that page.^([1](footnotes.xhtml#ch12fn1)) This then allowed him to write
    a bit of shellcode into the page, which would dump the rest of memory out the
    serial port.
  prefs: []
  type: TYPE_NORMAL
- en: He packaged this as a C`++` application for Windows, that bit-bangs ICSP into
    the debug interface through an FTDI chip’s GPIO pins and then reads back the firmware
    through that same chip’s UART. His shellcode is shown in [Figure 12.5](ch12.xhtml#ch12fig5);
    it simply dumps the firmware to the UART.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0125-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Meriac’s PIC18 Dumper Source'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0126-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: PIC18F452 Flash Map'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0126-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Meriac’s PIC18 Dumper Shellcode'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0127-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Microchip PIC18F452'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0128-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Huffstutter’s ICSP RAM Extraction'
  prefs: []
  type: TYPE_NORMAL
- en: For his target, it was sufficient to erase and rewrite the 512-byte bootloader
    page with the shellcode binary, as this page conveniently had no contents worth
    missing. Other targets might have something important in the boot block, and on
    those targets, a second victim device is required. This second device has every
    page *except* for the first page erased. These pages are then overwritten with
    a sled of repeated NOP instructions, leading to the shellcode at the very end
    of memory. The idea is that the boot block will eventually branch somewhere in
    the other blocks, and that almost every legal address will then slide to the shellcode
    to dump the very first block.
  prefs: []
  type: TYPE_NORMAL
- en: '**Huffstutter’s ICSP SRAM Exploit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Carl Huffstutter describes a different exploit for the same firmware image on
    the same chip in Huffstutter (2011). He saw that while every bank of flash memory
    and EEPROM has its own protection fuse bits, there are no such bits for protecting
    RAM. Sure enough, the ICSP transactions in [Figure 12.9](ch12.xhtml#ch12fig9)
    cleanly and non-destructively extract all RAM from a locked microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: In RAM, he found the 64-bit HID Master authentication key, two 64-bit Triple
    DES keys for encrypting comms between the reader and the card, the 128-byte key
    table for use with High Security cards, and all the details of the last card read.
    This information wasn’t erased after use, but had it been, the machine might still
    be interrupted mid-read to reveal the contents in use.
  prefs: []
  type: TYPE_NORMAL
- en: Many other devices expose SRAM while protecting flash memory, so it’s worth
    considering this attack whenever you need data from a chip and don’t necessarily
    need a copy of the code. On the defensive side, it might help to declare any important
    keys and tables as `const` so that they are located only in flash memory and never
    copied into RAM.
  prefs: []
  type: TYPE_NORMAL
