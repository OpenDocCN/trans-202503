- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: THE OPERATING SYSTEM
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: The *operating system* (OS) is a special system software layer that sits between
    the computer hardware and application programs running on the computer (see [Figure
    13-1](ch13.xhtml#ch13fig1)). The OS software is persistent on the computer, from
    power-on to power-off. Its primary purpose is to *manage* the underlying hardware
    components to efficiently run program workloads and to make the computer *easy
    to use*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作系统*（OS）是一个特殊的系统软件层，位于计算机硬件和运行在计算机上的应用程序之间（见[图13-1](ch13.xhtml#ch13fig1)）。操作系统软件在计算机上是持久存在的，从开机到关机。它的主要目的是*管理*底层硬件组件，以高效运行程序工作负载，并使计算机*易于使用*。'
- en: '![image](../images/13fig01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig01.jpg)'
- en: '*Figure 13-1: The OS is special system software between the user and the hardware.
    It manages the computer’s hardware and implements abstractions to make the hardware
    easier to use.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：操作系统是位于用户和硬件之间的特殊系统软件。它管理计算机硬件，并实现抽象以使硬件更易于使用。*'
- en: One of the ways in which the OS makes the computer hardware easy to use is in
    its support for initiating programs to run on the computer. Consider what happens
    when a user double-clicks an icon or types the name of a program executable at
    a shell prompt (e.g., `./a.out`) to start a program running on the underlying
    system. The OS handles all the details of this operation, such as loading the
    program from disk into RAM and initializing the CPU to start running the program
    instructions; the OS hides from users these types of low-level actions that are
    necessary to run the user’s program on the computer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统使计算机硬件易于使用的方式之一，是它对启动程序进行支持。当用户双击图标或在命令行提示符下输入程序可执行文件的名称（例如`./a.out`）来启动程序时，操作系统会处理所有这些操作的细节，例如从磁盘加载程序到内存，并初始化CPU开始执行程序指令；操作系统将这些必要的低级操作隐藏起来，用户不需要了解如何在计算机上运行程序。
- en: One example of how the OS makes efficient use of system resources is by implementing
    *multiprogramming*, which means allowing more than a single program to run on
    the computer at a time. Multiprogramming does not necessarily mean that all the
    programs are running simultaneously on the computer hardware. In fact, the set
    of running programs in the system is typically much larger than the number of
    CPU cores. Instead, it means that the OS shares hardware resources, including
    the CPU, among several programs running in the system. For example, when one program
    needs data that is currently on disk, the OS can put another program on the CPU
    while the first program waits for the data to become available. Without multiprogramming,
    the CPU would sit idle whenever the program running on the computer accesses slower
    hardware devices. To support multiprogramming, the OS needs to implement an abstraction
    of a running program, called a *process*. The process abstraction enables the
    OS to manage the set of multiple programs that are running on the system at any
    given time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通过实现*多程序设计*来有效利用系统资源，这意味着允许多于一个的程序同时在计算机上运行。多程序设计并不一定意味着所有程序都在计算机硬件上同时运行。事实上，系统中运行的程序集通常比CPU核心数要多。相反，它意味着操作系统在多个程序之间共享硬件资源，包括CPU。例如，当一个程序需要从磁盘读取数据时，操作系统可以让另一个程序使用CPU，同时第一个程序等待数据变得可用。如果没有多程序设计，当程序访问较慢的硬件设备时，CPU会闲置。为了支持多程序设计，操作系统需要实现一个关于运行程序的抽象，称为*进程*。进程抽象使操作系统能够管理系统中任意时刻正在运行的多个程序。
- en: Some example operating systems include Microsoft’s Windows, Apple’s macOS and
    iOS, Oracle’s Solaris, and open-source Unix variants such as OpenBSD and Linux.
    We use Linux examples in this book. However, all of these other general-purpose
    operating systems implement similar functionality, albeit sometimes in different
    ways.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例操作系统包括微软的Windows、苹果的macOS和iOS、甲骨文的Solaris，以及开源的Unix变种，如OpenBSD和Linux。本书使用Linux作为示例。然而，所有这些通用操作系统都实现了类似的功能，尽管有时方式不同。
- en: The Kernel
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 内核
- en: The term *operating system* is often used to refer to a large set of system-level
    software that performs some kind of resource management and that implements “easy-to-use”
    abstractions of the underlying system. In this chapter, we focus on the operating
    system *kernel*; thus, when we use the term OS alone, we mean the OS kernel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “操作系统”这一术语通常用于指代一组大型的系统级软件，这些软件执行某种形式的资源管理，并实现底层系统的“易于使用”的抽象。在本章中，我们将重点讨论操作系统的*内核*；因此，当我们单独提到操作系统（OS）时，我们指的是操作系统内核。
- en: The OS kernel implements core OS functionality—the functionality necessary for
    any use of the system. This functionality includes managing the computer hardware
    layer to run programs, implementing and managing OS abstractions exported to users
    of the system (e.g., files are an OS abstraction on top of stored data), and implementing
    interfaces to the user applications layer and to the hardware device layer. The
    kernel implements *mechanisms* to enable the hardware to run programs and to implement
    its abstractions such as processes. Mechanisms are the “how” part of OS functionality.
    The kernel also implements *policies* for efficiently managing the computer hardware
    and for governing its abstractions. Policies dictate the “what,” “when,” and “to
    whom” part of OS functionality. For example, a mechanism implements initializing
    the CPU to run instructions from a particular process, and a policy decides which
    process gets to run next on the CPU.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 操系统内核实现了核心操作系统功能——任何使用系统所必需的功能。这些功能包括管理计算机硬件层以运行程序，实施并管理操作系统提供给用户的抽象（例如，文件是基于存储数据之上的操作系统抽象），以及实现与用户应用层和硬件设备层的接口。内核实现了*机制*，以便使硬件能够运行程序，并实现诸如进程等抽象。机制是操作系统功能中的“如何”部分。内核还实现了*策略*，用于高效管理计算机硬件以及管理其抽象。策略决定了操作系统功能中的“什么”、“何时”和“向谁”部分。例如，机制实现了初始化
    CPU 以运行来自特定进程的指令，而策略决定了下一个哪个进程将在 CPU 上运行。
- en: 'The kernel implements a programming interface for users of the system: the
    *system call interface*. Users and programs interact with the OS through its system
    call interface. For example, if a program wants to know the current time of day,
    it can obtain that information from the OS by invoking the `gettimeofday` system
    call system call.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 内核为系统用户提供编程接口：*系统调用接口*。用户和程序通过系统调用接口与操作系统进行交互。例如，如果一个程序想要获取当前时间，它可以通过调用 `gettimeofday`
    系统调用从操作系统获取该信息。
- en: The kernel also provides an interface for interacting with hardware devices
    (the *device interface*). Typically, I/O devices such as hard disk drives (HDDs),
    keyboards, and solid-state drives (SSDs) interact with the kernel through this
    interface. These devices come with special device driver software that runs in
    the OS and handles transferring data to or from a specific device. The device
    driver software interacts with the OS through the OS’s device interface; a new
    device can be added to a computer system by loading its device driver code, written
    to conform to the OS’s device interface, into the OS. The kernel directly manages
    other hardware devices, such as the CPU and RAM. [Figure 13-2](ch13.xhtml#ch13fig2)
    shows the OS kernel layer between the user applications and the computer hardware,
    including its programming interface to users and its hardware device interface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内核还提供了与硬件设备交互的接口（*设备接口*）。通常，硬盘驱动器（HDD）、键盘和固态硬盘（SSD）等 I/O 设备通过此接口与内核交互。这些设备配有在操作系统中运行的特殊设备驱动程序软件，负责将数据传输到特定设备或从设备传输数据。设备驱动程序软件通过操作系统的设备接口与操作系统交互；通过加载符合操作系统设备接口要求的设备驱动程序代码，可以将新设备添加到计算机系统中。内核直接管理其他硬件设备，如
    CPU 和 RAM。[图 13-2](ch13.xhtml#ch13fig2)展示了操作系统内核层在用户应用和计算机硬件之间的位置，包括其面向用户的编程接口和硬件设备接口。
- en: '![image](../images/13fig02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig02.jpg)'
- en: '*Figure 13-2: The OS kernel: core OS functionality necessary to use the system
    and facilitate cooperation between I/O devices and users of the system*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：操作系统内核：使用系统并促进 I/O 设备与系统用户之间协作所必需的核心操作系统功能*'
- en: 'In the rest of this chapter, we examine the role the operating system plays
    in running programs and in efficiently managing system resources. Our discussion
    is primarily focused on the mechanism (the “how”) of the OS functionality and
    the implementation of two primary OS abstractions: a *process* (a running program)
    and *virtual memory* (a view of process memory space that is abstracted from its
    underlying physical storage in RAM or secondary storage).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将探讨操作系统在运行程序和高效管理系统资源方面的作用。我们的讨论主要集中在操作系统功能的机制（“如何”）以及两个主要操作系统抽象的实现：*进程*（正在运行的程序）和*虚拟内存*（从底层物理存储器或二级存储器中抽象出来的进程内存空间视图）。
- en: 13.1 How the OS Works and How It Runs
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1 操作系统的工作原理及其运行方式
- en: Part of the job of the OS is to support programs running on the system. To start
    a program running on a computer, the OS allocates a portion of RAM for the running
    program, loads the program’s binary executable from disk into RAM, creates and
    initializes OS state for the process associated with this running program, and
    initializes the CPU to start executing the process’s instructions (e.g., the CPU
    registers need to be initialized by the OS to fetch and execute the process’s
    instructions). [Figure 13-3](ch13.xhtml#ch13fig3) illustrates these steps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的部分工作是支持在系统上运行的程序。为了启动计算机上的程序，操作系统会为运行中的程序分配一部分RAM，将程序的二进制可执行文件从磁盘加载到RAM中，创建并初始化与该运行程序相关的操作系统进程状态，并初始化CPU以开始执行进程的指令（例如，操作系统需要初始化CPU寄存器以获取并执行进程的指令）。[图13-3](ch13.xhtml#ch13fig3)展示了这些步骤。
- en: '![image](../images/13fig03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig03.jpg)'
- en: '*Figure 13-3: The steps that the OS takes to start a new program running on
    the underlying hardware*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-3：操作系统启动新程序在底层硬件上运行的步骤*'
- en: 'Like user programs, the OS is also software that runs on the computer hardware.
    The OS, however, is special system software that manages all system resources
    and implements the interface for users of the computer system; it is necessary
    for using the computer system. Because the OS is software, its binary executable
    code runs on the hardware just like any other program: its data and instructions
    are stored in RAM and its instructions are fetched and executed by the CPU just
    like a user’s program instructions are. As a result, for the OS to run, its binary
    executable needs to be loaded into RAM and the CPU initialized to start running
    OS code. However, because the OS is responsible for the task of running code on
    the hardware, it needs some help to get started running.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户程序一样，操作系统也是在计算机硬件上运行的软件。然而，操作系统是特别的系统软件，负责管理所有系统资源，并实现计算机系统用户的接口；它是使用计算机系统所必需的。因为操作系统是软件，它的二进制可执行代码就像其他程序一样在硬件上运行：它的数据和指令存储在RAM中，并且其指令像用户程序的指令一样由CPU获取并执行。因此，为了让操作系统运行，其二进制可执行文件需要加载到RAM中，并且CPU需要初始化以开始运行操作系统代码。然而，由于操作系统负责在硬件上运行代码，它需要一些帮助才能开始运行。
- en: 13.1.1 OS Booting
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1 操作系统启动
- en: The process of the OS loading and initializing itself on the computer is known
    as *booting*—the OS “pulls itself up by its bootstraps,” or *boots* itself on
    the computer. The OS needs a little help to initially get loaded onto the computer
    and to begin running its boot code. To initiate the OS code to start running,
    code stored in computer firmware (nonvolatile memory in the hardware) runs when
    the computer first powers up; *BIOS* (Basic Input/Output System) and *UEFI* (Unified
    Extensible Firmware Interface) are two examples of this type of firmware. On power-up,
    BIOS or UEFI runs and does just enough hardware initialization to load the first
    chunk of the OS (its boot block) from disk into RAM and to start running boot
    block instructions on the CPU. Once the OS starts running, it loads the rest of
    itself from disk, discovers and initializes hardware resources, and initializes
    its data structures and abstractions to make the system ready for users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统在计算机上加载并初始化自身的过程被称为*引导*——操作系统“自力更生”或*自启动*。操作系统在最初加载到计算机并开始运行其引导代码时需要一点帮助。为了启动操作系统代码的运行，存储在计算机固件中的代码（硬件中的非易失性内存）会在计算机首次通电时运行；*BIOS*（基本输入/输出系统）和*UEFI*（统一可扩展固件接口）就是这种类型的固件的两个例子。在开机时，BIOS或UEFI会运行并进行足够的硬件初始化，以便将操作系统的第一部分（引导块）从磁盘加载到RAM中，并开始在CPU上执行引导块指令。一旦操作系统开始运行，它会从磁盘加载其余部分，发现并初始化硬件资源，并初始化其数据结构和抽象，以便使系统准备好供用户使用。
- en: '13.1.2 Getting the OS to Do Something: Interrupts and Traps'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2 让操作系统做点什么：中断与陷阱
- en: After the OS finishes booting and initializing the system for use, it then just
    waits for something to do. Most operating systems are implemented as *interrupt-driven
    systems*, meaning that the OS doesn’t run until some entity needs it to do something—the
    OS is woken up (interrupted from its sleep) to handle a request.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统完成引导并初始化系统以供使用后，它将等待任务的到来。大多数操作系统被实现为*中断驱动系统*，这意味着操作系统在某个实体需要它做某件事之前不会运行——操作系统在某个请求到来时会被唤醒（从睡眠中被中断）。
- en: Devices in the hardware layer may need the OS to do something for them. For
    example, a *network interface card* (NIC) is a hardware interface between a computer
    and a network. When the NIC receives data over its network connection, it interrupts
    (or wakes up) the OS to handle the received data (see [Figure 13-4](ch13.xhtml#ch13fig4)).
    For example, the OS may determine that the data received by the NIC is part of
    a web page that was requested by a web browser; it then delivers the data from
    the NIC to the waiting web browser process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件层的设备可能需要操作系统为它们做某些事情。例如，*网络接口卡*（NIC）是计算机与网络之间的硬件接口。当NIC通过其网络连接接收到数据时，它会中断（或唤醒）操作系统来处理接收到的数据（见[图
    13-4](ch13.xhtml#ch13fig4)）。例如，操作系统可能会判断NIC接收到的数据是网页的一部分，且该网页是由网页浏览器请求的；然后，它将数据从NIC传递给等待中的网页浏览器进程。
- en: Requests to the OS also come from user applications when they need access to
    protected resources. For example, when an application wants to write to a file,
    it makes a *system call* to the OS, which wakes up the OS to perform the write
    on its behalf (see [Figure 13-4](ch13.xhtml#ch13fig4)). The OS handles the system
    call by writing the data to a file stored on disk.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户应用程序需要访问受保护的资源时，也会向操作系统发出请求。例如，当一个应用程序想要写入文件时，它会向操作系统发出一个*系统调用*，操作系统会唤醒并代表应用程序执行写入操作（见[图
    13-4](ch13.xhtml#ch13fig4)）。操作系统通过将数据写入磁盘上的文件来处理该系统调用。
- en: '![image](../images/13fig04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig04.jpg)'
- en: '*Figure 13-4: In an interrupt-driven system, user-level programs make system
    calls, and hardware devices issue interrupts to initiate OS actions.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：在一个中断驱动系统中，用户级程序发出系统调用，硬件设备发出中断来启动操作系统的动作。*'
- en: Interrupts that come from the hardware layer, such as when a NIC receives data
    from the network, are typically referred to as hardware interrupts, or just *interrupts*.
    Interrupts that come from the software layer as the result of instruction execution,
    such as when an application makes a system call, are typically referred to as
    *traps*. That is, a system call “traps into the OS,” which handles the request
    on behalf of the user-level program. Exceptions from either layer may also interrupt
    the OS. For example, a hard disk drive may interrupt the OS if a read fails due
    to a bad disk block, and an application program may trigger a trap to the OS if
    it executes a divide instruction that divides by zero.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 来自硬件层的中断，例如网络接口卡（NIC）接收到网络数据，通常被称为硬件中断，或简称为*中断*。来自软件层的中断，通常是由于指令执行导致的，例如当应用程序发出系统调用时，通常被称为*陷阱*。也就是说，系统调用“陷阱进入操作系统”，操作系统代表用户级程序处理请求。来自任一层的异常也可能会中断操作系统。例如，如果硬盘驱动器因磁盘块损坏而读取失败，它可能会中断操作系统；如果应用程序执行除法指令并除以零，它也可能触发陷阱到操作系统。
- en: System calls are implemented using special trap instructions that are defined
    as part of the CPU’s instruction set architecture (ISA). The OS associates each
    of its system calls with a unique identification number. When an application wants
    to invoke a system call, it places the desired call’s number in a known location
    (the location varies according to the ISA) and issues a trap instruction to interrupt
    the OS. The trap instruction triggers the CPU to stop executing instructions from
    the application program and to start executing OS instructions that handle the
    trap (run the OS trap handler code). The trap handler reads the user-provided
    system call number and executes the corresponding system call implementation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用是通过特殊的陷阱指令实现的，这些指令作为CPU指令集架构（ISA）的一部分被定义。操作系统将每个系统调用与一个独特的标识号关联。当应用程序想要调用一个系统调用时，它会将所需调用的编号放在一个已知位置（该位置根据ISA的不同而不同），并发出陷阱指令来中断操作系统。陷阱指令触发CPU停止执行应用程序中的指令，转而开始执行处理该陷阱的操作系统指令（运行操作系统的陷阱处理程序代码）。陷阱处理程序读取用户提供的系统调用编号并执行相应的系统调用实现。
- en: 'Here’s an example of what a `write` system call might look like on an IA32
    Linux system:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个`write`系统调用在IA32 Linux系统中的示例：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first instruction (`movl $4, %eax`) puts the system call number for `write`
    (4) into register `eax`. The second instruction (`int $0x80`) triggers the trap.
    When the OS trap handler code runs, it uses the value in register `eax` (4) to
    determine which system call is being invoked and runs the appropriate trap handler
    code (in this case it runs the `write` handler code). After the OS handler runs,
    the OS continues the program’s execution at the instruction right after the trap
    instruction (`addl` in this example).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令（`movl $4, %eax`）将 `write` 系统调用的编号（4）放入寄存器 `eax`。第二条指令（`int $0x80`）触发陷阱。当操作系统陷阱处理程序运行时，它使用寄存器
    `eax` 中的值（4）来确定调用了哪个系统调用，并运行相应的陷阱处理代码（在这个例子中，运行的是 `write` 处理代码）。操作系统处理程序运行后，操作系统继续执行程序，恢复到陷阱指令后面的指令（在这个例子中是
    `addl`）。
- en: Unlike system calls, which come from executing program instructions, hardware
    interrupts are delivered to the CPU on an interrupt bus. A device places a signal,
    typically a number indicating the type of interrupt, on the CPU’s interrupt bus
    (see [Figure 13-5](ch13.xhtml#ch13fig5)). When the CPU detects the signal on its
    interrupt bus, it stops executing the current process’s instructions and starts
    executing OS interrupt handler code. After the OS handler code runs, the OS continues
    the process’s execution at the application instruction that was being executed
    when the interrupt occurred.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统调用不同，硬件中断是通过中断总线传递给 CPU 的。设备会将一个信号，通常是一个表示中断类型的数字，放置在 CPU 的中断总线上（见 [图 13-5](ch13.xhtml#ch13fig5)）。当
    CPU 检测到中断总线上的信号时，它会停止执行当前进程的指令，并开始执行操作系统的中断处理程序。操作系统处理程序执行完毕后，操作系统继续执行该进程，在中断发生时正在执行的应用指令处恢复。
- en: '![image](../images/13fig05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig05.jpg)'
- en: '*Figure 13-5: A hardware device (disk) sends a signal to the CPU on the interrupt
    bus to trigger OS execution on its behalf.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-5：硬件设备（磁盘）通过中断总线向 CPU 发送信号，代表其触发操作系统执行。*'
- en: If a user program is running on the CPU when an interrupt (or trap) occurs,
    the CPU runs the OS’s interrupt (or trap) handler code. When the OS is done handling
    an interrupt, it resumes executing the interrupted user program at the point it
    was interrupted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户程序在 CPU 上运行时发生中断（或陷阱），CPU 会运行操作系统的中断（或陷阱）处理程序。当操作系统处理完中断后，它会恢复并从中断发生时的地方继续执行被中断的用户程序。
- en: Because the OS is software, and its code is loaded into RAM and run on the CPU
    just like user program code, the OS must protect its code and state from regular
    processes running in the system. The CPU helps by defining two execution modes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作系统是软件，并且它的代码像用户程序代码一样被加载到 RAM 中并在 CPU 上运行，因此操作系统必须保护其代码和状态，避免被系统中运行的常规进程所访问。CPU
    通过定义两种执行模式来提供帮助。
- en: 1\. In *user mode*, a CPU executes only user-level instructions and accesses
    only the memory locations that the operating system makes available to it. The
    OS typically prevents a CPU in user mode from accessing the OS’s instructions
    and data. User mode also restricts which hardware components the CPU can directly
    access. In *kernel mode*, a CPU executes any instructions and accesses any memory
    location (including those that store OS instructions and data). It can also directly
    access hardware components and execute special instructions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在*用户模式*下，CPU 仅执行用户级指令，并且只能访问操作系统为其提供的内存位置。操作系统通常会阻止用户模式下的 CPU 访问操作系统的指令和数据。用户模式还限制了
    CPU 可以直接访问的硬件组件。在*内核模式*下，CPU 可以执行任何指令并访问任何内存位置（包括存储操作系统指令和数据的内存位置）。它还可以直接访问硬件组件并执行特殊指令。
- en: When OS code is run on the CPU, the system runs in kernel mode, and when user-level
    programs run on the CPU, the system runs in user mode. If the CPU is in user mode
    and receives an interrupt, the CPU switches to kernel mode, fetches the interrupt
    handler routine, and starts executing the OS handler code. In kernel mode, the
    OS can access hardware and memory locations that are not allowed in user mode.
    When the OS is done handling the interrupt, it restores the CPU state to continue
    executing user-level code at the point at which the program left off when interrupted
    and returns the CPU back to user mode (see [Figure 13-6](ch13.xhtml#ch13fig6)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统代码在 CPU 上运行时，系统处于内核模式；而当用户级程序在 CPU 上运行时，系统则处于用户模式。如果 CPU 处于用户模式并接收到中断，CPU
    会切换到内核模式，获取中断处理程序，并开始执行操作系统的处理代码。在内核模式下，操作系统可以访问用户模式下无法访问的硬件和内存位置。当操作系统处理完中断后，它会恢复
    CPU 状态，以在程序被中断时的地方继续执行用户级代码，并将 CPU 重新切换回用户模式（见 [图 13-6](ch13.xhtml#ch13fig6)）。
- en: '![image](../images/13fig06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig06.jpg)'
- en: '*Figure 13-6: The CPU and interrupts. User code running on the CPU is interrupted
    (at time X on the time line), and OS interrupt handler code runs. After the OS
    is done handling the interrupt, user code execution is resumed (at time Y on the
    time line).*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-6：CPU和中断。CPU上运行的用户代码被中断（在时间线的X时刻），然后操作系统中断处理程序代码运行。操作系统处理完中断后，用户代码执行继续（在时间线的Y时刻）。*'
- en: In an interrupt-driven system, interrupts can happen at any time, meaning that
    the OS can switch from running user code to interrupt handler code at any machine
    cycle. One way to efficiently support this execution context switch from user
    mode to kernel mode is to allow the kernel to run within the execution context
    of every process in the system. At boot time, the OS loads its code at a fixed
    location in RAM that is mapped into the top of the address space of every process
    (see [Figure 13-7](ch13.xhtml#ch13fig7)), and initializes a CPU register with
    the starting address of the OS handler function. On an interrupt, the CPU switches
    to kernel mode and executes OS interrupt handler code instructions that are accessible
    at the top addresses in every process’s address space. Because every process has
    the OS mapped to the same location at the top of its address space, the OS interrupt
    handler code is able to execute quickly in the context of any process that is
    running on the CPU when an interrupt occurs. This OS code can be accessed only
    in kernel mode, protecting the OS from user-mode accesses; during regular execution
    a process runs in user mode and cannot read or write to the OS addresses mapped
    into the top of its address space.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个中断驱动的系统中，中断可以在任何时候发生，这意味着操作系统可以在任何机器周期内从运行用户代码切换到中断处理程序代码。有效支持从用户模式到内核模式的执行上下文切换的一种方式是允许内核在系统中每个进程的执行上下文中运行。在启动时，操作系统将其代码加载到内存中的固定位置，并将其映射到每个进程地址空间的顶部（见[图13-7](ch13.xhtml#ch13fig7)），并初始化一个CPU寄存器，指向操作系统处理程序函数的起始地址。发生中断时，CPU切换到内核模式，执行操作系统中断处理程序代码，该代码可在每个进程地址空间顶部的地址中访问。因为每个进程将操作系统映射到地址空间顶部的相同位置，所以操作系统中断处理程序代码能够在任何进程的执行上下文中快速执行，当中断发生时，CPU上运行的进程都可以迅速响应。此操作系统代码仅能在内核模式下访问，从而保护操作系统免受用户模式访问；在常规执行期间，进程在用户模式下运行，无法读取或写入映射到其地址空间顶部的操作系统地址。
- en: '![image](../images/13fig07.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig07.jpg)'
- en: '*Figure 13-7: Process address space: the OS kernel is mapped into the top of
    every process’s address space.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-7：进程地址空间：操作系统内核映射到每个进程地址空间的顶部。*'
- en: Although mapping the OS code into the address space of every process results
    in fast kernel code execution on an interrupt, many modern processors have features
    that expose vulnerabilities to kernel protections when the OS is mapped into every
    process like this. As of the January 2018 announcement of the Meltdown hardware
    exploit,^([1](ch13.xhtml#fn13_1)) operating systems are separating kernel memory
    and user-level program memory in ways that protect against this exploit but that
    also result in less efficient switching to kernel mode to handle interrupts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将操作系统代码映射到每个进程的地址空间中会导致在中断时内核代码执行迅速，但许多现代处理器具有暴露内核保护漏洞的功能，当操作系统像这样被映射到每个进程时。自2018年1月宣布Meltdown硬件漏洞以来，^([1](ch13.xhtml#fn13_1))
    操作系统正在以保护免受此漏洞的方式将内核内存和用户级程序内存分开，但这也导致了切换到内核模式处理中断的效率降低。
- en: 13.2 Processes
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2 进程
- en: One of the main abstractions implemented by the operating system is a *process*.
    A process represents an instance of a program running in the system, which includes
    the program’s binary executable code, data, and execution *context*. The context
    tracks the program’s execution by maintaining its register values, stack location,
    and the instruction it is currently executing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统实现的主要抽象之一是*进程*。进程表示系统中运行的程序实例，其中包括程序的二进制可执行代码、数据和执行*上下文*。上下文通过维护程序的寄存器值、栈位置和当前正在执行的指令来跟踪程序的执行。
- en: Processes are necessary abstractions in *multiprogramming* systems, which support
    multiple processes existing in the system at the same time. The process abstraction
    is used by the OS to keep track of individual instances of programs running in
    the system, and to manage their use of system resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是*多道程序*系统中的必要抽象，它支持系统中多个进程同时存在。操作系统使用进程抽象来跟踪系统中运行的程序实例，并管理它们对系统资源的使用。
- en: The OS provides each process with a “lone view” abstraction of the system. That
    is, the OS isolates processes from one another and gives each process the illusion
    that it’s controlling the entire machine. In reality, the OS supports many active
    processes and manages resource sharing among them. The OS hides the details of
    sharing and accessing system resources from the user, and the OS protects processes
    from the actions of other processes running in the system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为每个进程提供一个“独占视图”的系统抽象。也就是说，操作系统将进程互相隔离，并给予每个进程控制整台机器的错觉。实际上，操作系统支持多个活跃进程，并管理它们之间的资源共享。操作系统隐藏了共享和访问系统资源的细节，并且保护进程不受其他进程在系统中运行时的影响。
- en: 'For example, a user may simultaneously run two instances of a Unix shell program
    along with a web browser on a computer system. The OS creates three processes
    associated with these three running programs: one process for each separate execution
    of the Unix shell program, and one process for the web browser. The OS handles
    switching between these three processes running on the CPU, and it ensures that
    as a process runs on the CPU, only the execution state and system resources allocated
    to the process can be accessed.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可以同时在计算机系统上运行两个 Unix shell 程序实例，以及一个网页浏览器。操作系统为这三个正在运行的程序创建了三个进程：每个独立的
    Unix shell 程序实例对应一个进程，网页浏览器对应一个进程。操作系统负责在这三个进程之间切换，确保当某个进程在 CPU 上运行时，只有该进程的执行状态和分配给它的系统资源可以被访问。
- en: 13.2.1 Multiprogramming and Context Switching
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1 多道程序设计与上下文切换
- en: Multiprogramming enables the OS to make efficient use of hardware resources.
    For example, when a process running on the CPU needs to access data that are currently
    on disk, rather than have the CPU sit idle waiting for the data to be read into
    memory, the OS can give the CPU to another process and let it run while the read
    operation for the original process is being handled by the disk. By using multiprogramming,
    the OS can mitigate some of the effects of the memory hierarchy on its program
    workload by keeping the CPU busy executing some processes while other processes
    are waiting to access data in the lower levels of the memory hierarchy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多道程序设计使操作系统能够高效利用硬件资源。例如，当一个运行在 CPU 上的进程需要访问当前在磁盘上的数据时，操作系统可以让 CPU 执行另一个进程，而不是让
    CPU 空闲等待数据被读取到内存中。同时，原进程的读取操作由磁盘处理。通过使用多道程序设计，操作系统可以通过在执行其他进程时保持 CPU 繁忙，减轻内存层次结构对程序负载的一些影响，而其他进程则在等待访问内存层次结构中较低层的数据。
- en: General-purpose operating systems often implement *timesharing*, which is multiprogramming
    wherein the OS schedules each process to take turns executing on the CPU for short
    time durations (known as a *time slice* or *quantum*). When a process completes
    its time slice on the CPU, the OS removes the process from the CPU and lets another
    run. Most systems define time slices to be a few milliseconds (10^(-3) seconds),
    which is a long time in terms of CPU cycles but is not noticeable to a human.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通用操作系统通常实现*时间共享*，即多道程序设计，其中操作系统安排每个进程轮流在 CPU 上执行一段短时间（称为*时间片*或*量子*）。当一个进程完成它在
    CPU 上的时间片后，操作系统将该进程移出 CPU，并让另一个进程运行。大多数系统将时间片定义为几毫秒（10^(-3)秒），对于 CPU 周期来说，这个时间相对较长，但对人类来说却几乎是不可察觉的。
- en: Timesharing systems further support the “lone view” of the computer system to
    the user; because each process frequently executes on the CPU for short bursts
    of time, the fact that they are all sharing the CPU is usually imperceptible to
    the user. Only when the system is very heavily loaded might a user notice the
    effects of other processes in the system. The Unix command `ps -A` lists all the
    processes running in the system—you may be surprised by how many there are. The
    `top` command is also useful for seeing the state of the system as it runs by
    displaying the set of processes that currently use the most system resources (such
    as CPU time and memory space).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 时间共享系统进一步支持用户对计算机系统的“独占视图”；由于每个进程通常在 CPU 上执行短时间的突发任务，它们都共享 CPU 的事实通常对用户来说是无法察觉的。只有当系统负载非常重时，用户才可能注意到系统中其他进程的影响。Unix
    命令 `ps -A` 列出了系统中所有正在运行的进程——你可能会对进程数量感到惊讶。`top` 命令也非常有用，它通过显示当前使用最多系统资源（如 CPU
    时间和内存空间）的进程集合，帮助查看系统的运行状态。
- en: In multiprogrammed and timeshared systems, processes run *concurrently*, meaning
    that their executions overlap in time. For example, the OS may start running process
    A on the CPU, and then switch to running process B for a while, and later switch
    back to running process A some more. In this scenario, processes A and B run concurrently
    because their execution on the CPU overlaps due to the OS switching between the
    two.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在多道程序设计和时间共享系统中，进程是*并发*运行的，这意味着它们的执行在时间上重叠。例如，操作系统可能会首先在 CPU 上运行进程 A，然后切换到运行进程
    B 一段时间，之后再切换回运行进程 A。 在这种情况下，进程 A 和 B 是并发运行的，因为它们在 CPU 上的执行是重叠的，这是由于操作系统在两者之间切换造成的。
- en: 13.2.1.1 Context Switching
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 13.2.1.1 上下文切换
- en: The *mechanism* behind multiprogramming determines how the OS swaps one process
    running on the CPU with another. The *policy* aspect of multiprogramming governs
    scheduling the CPU, or picking which process from a set of candidate processes
    gets to use the CPU next and for how long. We focus primarily on the mechanism
    of implementing multiprogramming. Operating systems textbooks cover scheduling
    policies in more detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 多道程序设计背后的*机制*决定了操作系统如何将一个在 CPU 上运行的进程与另一个进程交换。多道程序设计的*策略*方面则决定了 CPU 调度，即从一组候选进程中选择哪个进程下一步使用
    CPU 以及使用多长时间。我们主要关注多道程序设计的实现机制。操作系统教材会更详细地讨论调度策略。
- en: 'The OS performs *context switching*, or swapping process state on the CPU,
    as the primary mechanism behind multiprogramming (and time-sharing). There are
    two main steps to performing a CPU context switch:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统执行*上下文切换*，即在 CPU 上交换进程状态，这是多道程序设计（和时间共享）背后的主要机制。进行 CPU 上下文切换的过程有两个主要步骤：
- en: 1\. The OS saves the context of the current process running on the CPU, including
    all of its register values (PC, stack pointers, general-purpose register, condition
    codes, etc.), its memory state, and some other state (for example, the state of
    system resources it uses, like open files).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 操作系统会保存当前在 CPU 上运行的进程的上下文，包括它的所有寄存器值（程序计数器、栈指针、通用寄存器、条件码等）、内存状态以及一些其他状态（例如，它使用的系统资源的状态，如打开的文件）。
- en: 2\. The OS restores the saved context from another process on the CPU and starts
    the CPU running this other process, continuing its execution from the instruction
    where it left off.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 操作系统从 CPU 上另一个进程恢复已保存的上下文，并开始让 CPU 运行该进程，继续从它上次中断的指令处执行。
- en: One part of context switching that may seem impossible to accomplish is that
    the OS’s code that implements context switching must run on the CPU while it saves
    (restores) a process’s execution contexts from (to) the CPU; the instructions
    of the context switching code need to use CPU hardware registers to execute, but
    the register values from the process being context switched off the CPU need to
    be saved by the context switching code. Computer hardware provides some help to
    make this possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换的一个部分可能看起来难以实现，那就是实现上下文切换的操作系统代码必须在 CPU 上运行，同时保存（恢复）一个进程的执行上下文（从 CPU 上保存到
    CPU 上恢复）；上下文切换代码的指令需要使用 CPU 硬件寄存器来执行，但是正在被上下文切换下线的进程的寄存器值需要被上下文切换代码保存。计算机硬件为实现这一点提供了一些帮助。
- en: At boot time, the OS initialized the hardware, including initializing the CPU
    state, so that when the CPU switches to kernel mode on an interrupt, the OS interrupt
    handler code starts executing and the interrupted process’s execution state is
    protected from this execution. Together, the computer hardware and OS perform
    some of the initial saving of the user-level execution context, enough that the
    OS code can run on the CPU without losing the execution state of the interrupted
    process. For example, register values of the interrupted process need to be saved
    so that when the process runs again on the CPU, the process can continue from
    the point at which it left off, using its register values. Depending on the hardware
    support, saving the user-level process’s register values may be done entirely
    by the hardware or may be done almost entirely in software as the first part of
    the kernel’s interrupt handling code. At a minimum, the process’s program counter
    (PC) value needs to be saved so that its value is not lost when the kernel interrupt
    handler address is loaded into the PC.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，操作系统初始化硬件，包括初始化CPU状态，这样当CPU因中断切换到内核模式时，操作系统的中断处理程序代码开始执行，而被中断进程的执行状态也得到保护，避免受此执行的影响。计算机硬件和操作系统共同执行一些初步的用户级执行上下文保存工作，足够使操作系统代码能够在CPU上运行而不会丢失被中断进程的执行状态。例如，需要保存被中断进程的寄存器值，以便当该进程再次在CPU上运行时，可以从中断时的状态继续执行，使用它的寄存器值。根据硬件支持，保存用户级进程的寄存器值可能完全由硬件完成，或者几乎完全由软件完成，作为内核中断处理代码的第一部分。至少需要保存进程的程序计数器（PC）值，以防当内核中断处理程序地址被加载到PC时，该值丢失。
- en: After the OS starts running, it executes its full process context switching
    code, saving the full execution state of the process running on the CPU and restoring
    the saved execution state of another process onto the CPU. Because the OS runs
    in kernel mode it is able to access any parts of computer memory and can execute
    privileged instructions and access any hardware registers. As a result, its context
    switching code is able to access and save the CPU execution state of any process
    to memory, and it is able to restore from memory the execution state of any process
    to the CPU. OS context switching code completes by setting up the CPU to execute
    the restored process’s execution state, and by switching the CPU to user mode.
    Once switched to user mode, the CPU executes instructions, and uses execution
    state from the process that the OS context switched onto the CPU.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统开始运行后，执行其完整的进程上下文切换代码，保存正在CPU上运行的进程的完整执行状态，并将另一个进程的已保存执行状态恢复到CPU上。由于操作系统在内核模式下运行，它能够访问计算机内存的任何部分，并且可以执行特权指令，访问任何硬件寄存器。因此，它的上下文切换代码能够访问并保存任何进程的CPU执行状态到内存，并能从内存中恢复任何进程的执行状态到CPU。操作系统的上下文切换代码通过设置CPU以执行恢复的进程执行状态，并将CPU切换到用户模式来完成。切换到用户模式后，CPU执行指令，并使用操作系统上下文切换到CPU上的进程的执行状态。
- en: 13.2.2 Process State
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2 进程状态
- en: 'In multiprogrammed systems, the OS must track and manage the multiple processes
    existing in the system at any given time. The OS maintains information about each
    process, including:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在多任务系统中，操作系统必须跟踪和管理系统中在任何给定时刻存在的多个进程。操作系统维护关于每个进程的信息，包括：
- en: A *process id* (PID), which is a unique identifier for a process. The `ps` command
    lists information about processes in the system, including their PID values.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*进程ID*（PID），它是进程的唯一标识符。`ps`命令列出系统中进程的信息，包括它们的PID值。
- en: The address space information for the process.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的地址空间信息。
- en: The execution state of the process (e.g., CPU register values, stack location).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的执行状态（例如，CPU寄存器值、堆栈位置）。
- en: The set of resources allocated to the process (e.g., open files).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给进程的资源集（例如，打开的文件）。
- en: The current *process state*, which is a value that determines its eligibility
    for execution on the CPU.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的*进程状态*，这是一个决定进程是否有资格在CPU上执行的值。
- en: Over the course of its lifetime, a process moves through several states, which
    correspond to different categories of process execution eligibility. One way that
    the OS uses process state is to identify the set of processes that are candidates
    for being scheduled on the CPU.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在其生命周期中，进程会经历多个状态，这些状态对应着不同类别的进程执行资格。操作系统使用进程状态的一个方式是识别哪些进程是可以调度到CPU上的候选进程。
- en: 'The set of process execution states are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 进程执行状态集：
- en: '*Ready*: The process could run on the CPU but is not currently scheduled (it
    is a candidate for being context switched on to the CPU). Once a new process is
    created and initialized by the OS, it enters the ready state (it is ready for
    the CPU to start executing its first instruction). In a timesharing system, if
    a process is context switched off the CPU because its time slice is up, it is
    also placed in the *ready* state (it is ready for the CPU to execute its next
    instruction, but it used up its time slice and has to wait its turn to get scheduled
    again on the CPU).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*就绪（Ready）*：进程可以在 CPU 上运行，但当前并未被调度（它是候选进程，准备上下文切换到 CPU）。当操作系统创建并初始化一个新进程时，它进入就绪状态（准备开始执行其第一条指令）。在分时系统中，如果进程因为时间片耗尽而被从
    CPU 上上下文切换，它也会进入*就绪*状态（准备执行下一条指令，但由于时间片已用完，需要等待再次调度到 CPU）。'
- en: '*Running*: The process is scheduled on the CPU and is actively executing instructions.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行（Running）*：进程已被调度到 CPU 上，正在积极执行指令。'
- en: '*Blocked*: The process is waiting for some event before it can continue being
    executed. For example, the process is waiting for some data to be read in from
    disk. Blocked processes are not candidates for being scheduled on the CPU. After
    the event on which the process is blocked occurs, the process moves to the *ready*
    state (it is ready to run again).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阻塞（Blocked）*：进程在等待某个事件发生，才能继续执行。例如，进程正在等待从磁盘读取某些数据。阻塞状态的进程不能被调度到 CPU 上执行。当进程等待的事件发生后，进程会转移到*就绪（Ready）*状态（它准备好再次执行）。'
- en: '*Exited*: The process has exited but still needs to be completely removed from
    the system. A process exits due to its completing the execution of its program
    instructions, or by exiting with an error (e.g., it tries to divide by zero),
    or by receiving a termination request from another process. An exited process
    will never run again, but it remains in the system until final clean-up associated
    with its execution state is complete.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*退出（Exited）*：进程已经退出，但仍需从系统中完全移除。进程退出的原因可以是完成了程序指令的执行，或因为遇到错误（例如，尝试进行除以零的运算），或者是接收到来自其他进程的终止请求。退出的进程将永远不会再次运行，但它会留在系统中，直到与其执行状态相关的最终清理工作完成。'
- en: '[Figure 13-8](ch13.xhtml#ch13fig8) shows the lifetime of a process in the system,
    illustrating how it moves between different states. Note the transitions (arrows)
    from one state to another. For example, a process can enter the Ready state in
    one of three ways: first, if it is newly created by the OS; second, if it was
    blocked waiting for some event and the event occurs; and third, if it was running
    on the CPU and its time slice is over and the OS context switches it off to give
    another Ready process its turn on the CPU.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-8](ch13.xhtml#ch13fig8)展示了进程在系统中的生命周期，说明了它如何在不同状态之间转换。注意状态之间的转换（箭头）。例如，进程可以通过三种方式进入就绪状态：第一，如果它是操作系统新创建的；第二，如果它因等待某个事件而处于阻塞状态且该事件发生；第三，如果它正在
    CPU 上运行，且时间片已用完，操作系统将其从 CPU 上上下文切换出去，以便给另一个就绪进程轮流使用 CPU。'
- en: '![image](../images/13fig08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig08.jpg)'
- en: '*Figure 13-8: The states of a process during its lifetime*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-8：进程生命周期中的状态*'
- en: PROCESS RUNTIME
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进程运行时间（PROCESS RUNTIME）
- en: Programmers often use a process’s completion time as a metric to evaluate its
    performance. For noninteractive programs, a faster runtime typically indicates
    a better, or more optimal, implementation. For example, in comparing two programs
    that compute the prime factors of a large number, the one that correctly completes
    the task faster is preferable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常使用进程的完成时间作为衡量其性能的指标。对于非交互式程序，较快的运行时间通常意味着更好或更优化的实现。例如，在比较两个计算大数素因数的程序时，能够更快完成任务的程序更为优选。
- en: There are two different measures of the runtime of a process. The first is total
    *wall time* (or wall-clock time). Wall time is the duration between the start
    and completion of a process; it is the elapsed time from the process’s start to
    finish as measured by a clock hanging on a wall. Wall time includes the time that
    the process is in the Running state executing on the CPU, as well as time that
    the process is in the Blocked state waiting for an event like I/O as well as the
    time that the process spends in the Ready state waiting for its turn to be scheduled
    to run on the CPU. In multiprogrammed and timeshared systems, the wall time of
    a process can slow down due to other processes running concurrently on the system
    and sharing system resources.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的度量方式来衡量一个进程的运行时间。第一种是总的*墙钟时间*（或墙时钟时间）。墙钟时间是进程开始和完成之间的持续时间；它是从进程开始到结束的经过时间，通常由挂在墙上的时钟测量。墙钟时间包括进程在运行状态下执行于CPU上的时间，也包括进程在阻塞状态下等待事件（如I/O）的时间，以及进程在就绪状态下等待调度执行的时间。在多道程序和时间共享系统中，进程的墙钟时间可能由于其他进程同时运行并共享系统资源而变慢。
- en: The second measure of process runtime is total *CPU time* (or process time).
    CPU time measures just the amount of time the process spends in the Running state
    executing its instructions on the CPU. CPU time does not include the time the
    process spends in the Blocked or Ready states. As a result, a process’s total
    CPU time is not affected by other processes concurrently running on the system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 进程运行时间的第二种度量方式是总的*CPU时间*（或进程时间）。CPU时间仅衡量进程在运行状态下执行指令的时间。CPU时间不包括进程在阻塞或就绪状态下的时间。因此，一个进程的总CPU时间不会受到系统中其他进程并发运行的影响。
- en: 13.2.3 Creating (and Destroying) Processes
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3 创建（和销毁）进程
- en: An OS creates a new process when an existing process makes a system call requesting
    it to do so. In Unix, the `fork` system call creates a new process. The process
    calling `fork` is the *parent* process and the new process it creates is its *child*
    process. For example, if you run `a.out` in a shell, the shell process calls the
    `fork` system call to request that the OS create a new child process that will
    be used to run the `a.out` program. Another example is a web browser process that
    calls `fork` to create child processes to handle different browsing events. A
    web browser may create a child process to handle communication with a web server
    when a user loads a web page. It may create another process to handle user mouse
    input, and other processes to handle separate browser windows or tabs. A multiple-process
    web browser like this is able to continue handling user requests through some
    of its child browser processes, while at the same time some of its other child
    browser processes may be blocked waiting for remote web server responses or for
    user mouse clicks.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当现有进程通过系统调用请求操作系统创建一个新进程时，操作系统会创建一个新进程。在Unix中，`fork`系统调用用于创建一个新进程。调用`fork`的进程是*父进程*，它创建的新进程是其*子进程*。例如，如果你在终端中运行`a.out`，shell进程会调用`fork`系统调用，请求操作系统创建一个新的子进程来运行`a.out`程序。另一个例子是，网页浏览器进程调用`fork`来创建子进程，处理不同的浏览事件。当用户加载网页时，浏览器可能会创建一个子进程来与web服务器进行通信；它可能创建另一个进程来处理用户的鼠标输入，还可能创建其他进程来处理不同的浏览器窗口或标签。像这样的多进程浏览器能够通过一些子进程继续处理用户请求，同时其他一些子进程可能会被阻塞，等待远程web服务器的响应或用户的鼠标点击。
- en: A *process hierarchy* of parent–child relationships exists between the set of
    processes active in the system. For example, if process *A* makes two calls to
    `fork`, two new child processes are created, *B* and *C*. If process C then calls
    `fork`, another new process, *D*, will be created. Process C is the child of A,
    and the parent of D. Processes B and C are siblings (they share a common parent
    process, process A). Process A is the ancestor of B, C, and D. This example is
    illustrated in [Figure 13-9](ch13.xhtml#ch13fig9).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中活动的进程之间存在一个*进程层级*的父子关系。例如，如果进程*A*调用两次`fork`，则会创建两个新的子进程，*B*和*C*。如果进程C再调用一次`fork`，则会创建另一个新进程，*D*。进程C是A的子进程，也是D的父进程。进程B和C是兄弟进程（它们共享一个父进程，进程A）。进程A是B、C和D的祖先。这个示例如[图13-9](ch13.xhtml#ch13fig9)所示。
- en: '![image](../images/13fig09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig09.jpg)'
- en: '*Figure 13-9: An example process hierarchy created by a parent process (A)
    calling `fork` twice to create two child processes (B and C). C’s call to `fork`
    creates its child process, D. To list the process hierarchy on Linux systems,
    run `pstree`, or `ps -Aef --forest`.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-9：一个由父进程（A）通过调用`fork`两次创建两个子进程（B和C）的示例进程层次结构。C调用`fork`创建其子进程D。在Linux系统上列出进程层次结构，运行`pstree`，或`ps
    -Aef --forest`。*'
- en: Since existing processes trigger process creation, a system needs at least one
    process to create any new processes. At boot time, the OS creates the first user-level
    process in the system. This special process, named `init`, sits at the very top
    of the process hierarchy as the ancestor of all other processes in the system.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现有的进程触发进程的创建，因此系统至少需要一个进程来创建任何新的进程。在启动时，操作系统创建系统中的第一个用户级进程。这个特殊的进程，称为`init`，位于进程层次结构的最顶部，是系统中所有其他进程的祖先。
- en: fork
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: fork
- en: The `fork` system call is used to create a process. At the time of the fork,
    the child inherits its execution state from its parent. The OS creates a *copy*
    of the calling (parent) process’s execution state at the point when the parent
    calls `fork`. This execution state includes the parent’s address space contents,
    CPU register values, and any system resources it has allocated (e.g., open files).
    The OS also creates a new *process control struct*, an OS data structure for managing
    the child process, and it assigns the child process a unique PID. After the OS
    creates and initializes the new process, the child and parent are concurrent—they
    both continue running and their executions overlap as the OS context switches
    them on and off the CPU.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork`系统调用用于创建进程。在`fork`时，子进程从父进程继承其执行状态。操作系统在父进程调用`fork`时创建调用（父）进程执行状态的*副本*。这个执行状态包括父进程的地址空间内容、CPU寄存器值，以及它已分配的任何系统资源（例如，打开的文件）。操作系统还创建一个新的*进程控制结构*，这是一个用于管理子进程的操作系统数据结构，并为子进程分配一个唯一的PID。操作系统创建并初始化新的进程后，子进程和父进程并发执行——它们都继续运行，并且随着操作系统在它们之间进行上下文切换，执行重叠。'
- en: 'When the child process is first scheduled by the OS to run on the CPU, it starts
    executing at the point at which its parent left off—at the return from the `fork`
    call. This is because `fork` gives the child a copy of its parent’s execution
    state (the child executes using its own copy of this state when it starts running).
    From the programmer’s point of view, *a call to* fork *returns twice*: once in
    the context of the running parent process, and once in the context of the running
    child process.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统第一次调度子进程在CPU上运行时，它从父进程返回`fork`调用的位置开始执行。这是因为`fork`将父进程的执行状态的副本传递给子进程（子进程在开始执行时使用自己副本的状态）。从程序员的角度看，*对`fork`的调用返回两次*：一次是在运行父进程的上下文中，另一次是在运行子进程的上下文中。
- en: In order to differentiate the child and parent processes in a program, a call
    to `fork` returns different values to the parent and child. The child process
    always receives a return value of 0, whereas the parent receives the child’s PID
    value (or –1 if `fork` fails).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分程序中的子进程和父进程，`fork`调用会返回不同的值给父进程和子进程。子进程总是接收到0的返回值，而父进程接收到子进程的PID值（如果`fork`失败则返回-1）。
- en: 'For example, the following code snippet shows a call to the `fork` system call
    that creates a new child process of the calling process:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段显示了对`fork`系统调用的调用，该调用创建了调用进程的新子进程：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After the call to `fork` creates a new child process, the parent and child processes
    both continue executing, in their separate execution contexts, at the return point
    of the `fork` call. Both processes assign the return value of `fork` to their
    `pid` variable and both call `printf`. The child process’s call prints out 0 and
    the parent process prints out the child’s PID value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fork`调用创建了一个新的子进程之后，父进程和子进程继续执行，各自处于独立的执行上下文中，在`fork`调用的返回点继续执行。两个进程将`fork`的返回值赋给各自的`pid`变量，并都调用`printf`。子进程的调用打印出0，而父进程则打印出子进程的PID值。
- en: '[Figure 13-10](ch13.xhtml#ch13fig10) shows an example of what the process hierarchy
    looks like after this code’s execution. The child process gets an exact copy of
    the parent process’s execution context at the point of the fork, but the value
    stored in its variable `pid` differs from its parent because `fork` returns the
    child’s PID value (14 in this example) to the parent process, and 0 to the child.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-10](ch13.xhtml#ch13fig10)显示了代码执行后进程层次结构的示例。子进程在分叉时获得父进程执行上下文的完整副本，但其变量`pid`的值与父进程不同，因为`fork`返回子进程的PID值（本例中为14）给父进程，并返回0给子进程。'
- en: '![image](../images/13fig10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig10.jpg)'
- en: '*Figure 13-10: A process (PID 12) calls `fork` to create a new child process.
    The new child process gets an exact copy of its parent’s address and execution
    state, but gets its own process identifier (PID 14). `fork` returns 0 to the child
    process and the child’s PID value (14) to the parent.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-10：一个进程（PID 12）调用`fork`来创建一个新的子进程。新的子进程获得父进程的地址和执行状态的精确副本，但获得它自己的进程标识符（PID
    14）。`fork`返回0给子进程，并返回子进程的PID值（14）给父进程。*'
- en: 'Often, the programmer wants the child and parent processes to perform different
    tasks after the `fork` call. A programmer can use the different return values
    from `fork` to trigger the parent and child processes to execute different code
    branches. For example, the following code snippet creates a new child process
    and uses the return value from `fork` to have the child and parent processes execute
    different code branches after the call:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员希望在`fork`调用后，子进程和父进程执行不同的任务。程序员可以利用`fork`的不同返回值触发父子进程执行不同的代码分支。例如，以下代码片段创建了一个新的子进程，并利用`fork`的返回值让子进程和父进程在调用后执行不同的代码分支：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is important to remember that as soon as they’re created, the child and parent
    processes run concurrently in their own execution contexts, modifying their separate
    copies of program variables and possibly executing different branches in the code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，一旦它们被创建，子进程和父进程将在各自的执行上下文中并发运行，修改它们各自的程序变量副本，并可能执行代码中的不同分支。
- en: 'Consider the following program^([2](ch13.xhtml#fn13_2)) that contains a call
    to `fork` with branching on the value of `pid` to trigger the parent and child
    processes to execute different code (this example also shows a call to `getpid`
    that returns the PID of the calling process):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下程序^([2](ch13.xhtml#fn13_2))，它包含对`fork`的调用，并根据`pid`的值进行分支，以触发父进程和子进程执行不同的代码（此示例还显示了对`getpid`的调用，该函数返回调用进程的PID）：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When run, this program’s output might look like the following (assume that
    the parent’s PID is 12 and the child’s is 14):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，其输出可能如下所示（假设父进程的PID是12，子进程的PID是14）：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In fact, the program’s output could look like any of the possible options shown
    in [Table 13-1](ch13.xhtml#ch13tab1) (and you will often see more than one possible
    ordering of output if you run the program multiple times). In [Table 13-1](ch13.xhtml#ch13tab1),
    the parent prints B:12 and the child B:14 in this example, but the exact PID values
    will vary from run to run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，程序的输出可能会呈现[表13-1](ch13.xhtml#ch13tab1)中所示的任何一种可能的选项（如果多次运行该程序，你通常会看到输出的顺序有多个可能性）。在[表13-1](ch13.xhtml#ch13tab1)中，父进程打印B:12，子进程打印B:14，但具体的PID值会因运行而异。
- en: '**Table 13-1:** All Six Possible Orderings of Example Program Output'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**表13-1：** 示例程序输出的所有六种可能顺序'
- en: '| **Option 1** | **Option 2** | **Option 3** | **Option 4** | **Option 5**
    | **Option 6** |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **选项1** | **选项2** | **选项3** | **选项4** | **选项5** | **选项6** |'
- en: '| A | A | A | A | A | A |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| A | A | A | A | A | A |'
- en: '| Parent... | Parent... | Parent... | Child... | Child... | Child... |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 父进程... | 父进程... | 父进程... | 子进程... | 子进程... | 子进程... |'
- en: '| Child... | Child... | B:12 | Parent... | Parent... | B:14 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 子进程... | 子进程... | B:12 | 父进程... | 父进程... | B:14 |'
- en: '| B:12 | B:14 | Child... | B:12 | B:14 | Parent... |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| B:12 | B:14 | 子进程... | B:12 | B:14 | 父进程... |'
- en: '| B:14 | B:12 | B:14 | B:14 | B:12 | B:12 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| B:14 | B:12 | B:14 | B:14 | B:12 | B:12 |'
- en: These six different output orderings are possible because after the `fork` system
    call returns, the parent and child processes are concurrent and can be scheduled
    to run on the CPU in many different orderings, resulting in any possible interleaving
    of their instruction sequences. Consider the execution time line of this program,
    shown in [Figure 13-11](ch13.xhtml#ch13fig11). The dotted line represents concurrent
    execution of the two processes. Depending on when each is scheduled to run on
    the CPU, one could execute both its `printf` statements before the other, or the
    execution of their two `printf` statements could be interleaved, resulting in
    any of the possible outcomes shown in [Table 13-1](ch13.xhtml#ch13tab1). Because
    only one process, the parent, exists before the call to `fork`, A is always printed
    by the parent before any of the output after the call to `fork`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这六种不同的输出顺序是可能的，因为在`fork`系统调用返回后，父进程和子进程是并发的，并且可以按多种不同的顺序在CPU上调度执行，导致它们的指令序列出现任何可能的交织。考虑该程序的执行时间线，如[图13-11](ch13.xhtml#ch13fig11)所示。虚线表示两个进程的并发执行。根据每个进程在CPU上的调度时间，它们的`printf`语句可能先后执行，或者它们的两个`printf`语句可能交替执行，导致[表13-1](ch13.xhtml#ch13tab1)中显示的任何可能结果。由于在调用`fork`之前只有父进程存在，因此A总是由父进程打印，之后的输出才会由调用`fork`后的进程打印。
- en: '![image](../images/13fig11.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig11.jpg)'
- en: '*Figure 13-11: The execution time line of the program. Only the parent process
    exists before the call to `fork`. After `fork` returns, both run concurrently
    (shown in the dotted lines).*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-11：程序的执行时间线。在调用`fork`之前只有父进程存在。`fork`返回后，两个进程并发执行（以虚线表示）。*'
- en: 13.2.4 exec
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.4 exec
- en: Usually a new process is created to execute a program that is different from
    that of its parent process. This means that `fork` is often called to create a
    process with the intention of running a new program from its starting point (i.e.,
    starting its execution from its first instruction). For example, if a user types
    `./a.out` in a shell, the shell process forks a new child process to run `a.out`.
    As two separate processes, the shell and the `a.out` process are protected from
    each other; they cannot interfere with each other’s execution state.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，会创建一个新进程来执行一个不同于其父进程的程序。这意味着`fork`通常用于创建一个进程，目的是从它的起点运行一个新程序（即从第一条指令开始执行）。例如，如果用户在shell中输入`./a.out`，shell进程会创建一个新的子进程来运行`a.out`。作为两个独立的进程，shell和`a.out`进程相互独立，无法干扰彼此的执行状态。
- en: While `fork` creates the new child process, it does not cause the child to run
    `a.out`. To initialize the child process to run a new program, the child process
    calls one of the *exec* system calls. Unix provides a family of exec system calls
    that trigger the OS to overlay the calling process’s image with a new image from
    a binary executable file. In other words, an exec system call tells the OS to
    overwrite the calling process’s address space contents with the specified `a.out`
    and to reinitialize its execution state to start executing the very first instruction
    in the `a.out` program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`fork`创建了新的子进程，但它并不会导致子进程运行`a.out`。为了初始化子进程以运行一个新程序，子进程会调用一个*exec*系统调用。Unix提供了一系列的exec系统调用，触发操作系统用二进制可执行文件中的新映像覆盖调用进程的映像。换句话说，exec系统调用告诉操作系统将调用进程的地址空间内容覆盖为指定的`a.out`，并重新初始化其执行状态，从`a.out`程序的第一条指令开始执行。
- en: 'One example of an exec system call is `execvp`, whose function prototype is
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个exec系统调用的例子是`execvp`，其函数原型如下：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `filename` parameter specifies the name of a binary executable program to
    initialize the process’s image, and `argv` contains the command line arguments
    to pass into the `main` function of the program when it starts executing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`filename`参数指定用于初始化进程映像的二进制可执行程序的名称，`argv`包含传递给程序的`main`函数的命令行参数，程序在启动执行时会使用这些参数。'
- en: 'Here’s an example code snippet that, when executed, creates a new child process
    to run `a.out`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例代码片段，当执行时，它会创建一个新的子进程来运行`a.out`：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `argv` variable is initialized to the value of the `argv` argument that
    is passed to the `main` function of `a.out`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv`变量被初始化为传递给`a.out`的`main`函数的`argv`参数的值：'
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`execvp` will figure out the value to pass to `argc` based on this `argv` value
    (in this case, 1).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`execvp`将根据此`argv`值（在此例中为1）确定传递给`argc`的值。'
- en: '[Figure 13-12](ch13.xhtml#ch13fig12) shows what the process hierarchy would
    look like after executing this code.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-12](ch13.xhtml#ch13fig12) 显示了执行此代码后进程层次结构的样子。'
- en: '![image](../images/13fig12.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig12.jpg)'
- en: '*Figure 13-12: When the child process calls `execvp` (left), the OS replaces
    its image with `a.out` (right) and initializes the child process to start running
    the `a.out` program from its beginning.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-12：当子进程调用 `execvp`（左侧）时，操作系统用 `a.out` 替换其映像（右侧），并初始化子进程以从头开始运行 `a.out`
    程序。*'
- en: 'Something to note in the previous example code is its seemingly odd error message
    after the call to `execvp`: why would returning from an exec system call be an
    error? If the exec system call is successful, then the error detection and handling
    code immediately following it will never be executed because the process will
    now be executing code in the `a.out` program instead of this code (the process’s
    address space contents have been changed by exec). That is, when a call to an
    exec function is successful, the process doesn’t continue its execution at the
    return of the exec call. Because of this behavior, the following code snippet
    is equivalent to the previous one (however, that code is typically easier to understand):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在之前示例代码中，`execvp` 调用后的错误信息似乎很奇怪：为什么从 exec 系统调用返回会是一个错误？如果 exec 系统调用成功，那么它后面的错误检测和处理代码将永远不会执行，因为此时进程将执行
    `a.out` 程序中的代码，而不是当前代码（进程的地址空间已被 exec 改变）。也就是说，当 exec 函数调用成功时，进程不会在 exec 调用返回后继续执行当前代码。由于这一行为，以下代码片段与之前的代码等价（但通常更容易理解）：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 13.2.5 exit and wait
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.5 退出和等待
- en: To terminate, a process calls the `exit` system call, which triggers the OS
    to clean up most of the process’s state. After running the exit code, a process
    notifies its parent process that it has exited. The parent is responsible for
    cleaning up the exited child’s remaining state from the system.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了终止，进程调用 `exit` 系统调用，这会触发操作系统清理大部分进程状态。执行完退出代码后，进程会通知其父进程自己已退出。父进程负责清理已退出子进程的剩余状态。
- en: Processes can be triggered to exit in several ways. First, a process may complete
    all of its application code. Returning from its `main` function leads to a process
    invoking the `exit` system call. Second, a process can perform an invalid action,
    such as dividing by zero or dereferencing a null pointer, that results in its
    exiting. Finally, a process can receive a *signal* from the OS or another process,
    telling it to exit (in fact, dividing by zero and null pointer dereferences result
    in the OS sending the process `SIGFPE` and `SIGSEGV` signals telling it to exit).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过几种方式触发退出。首先，进程可能完成所有应用代码，返回 `main` 函数时会调用 `exit` 系统调用从而退出。其次，进程可能执行无效操作，例如除以零或解引用空指针，这会导致它退出。最后，进程可以接收到来自操作系统或其他进程的
    *信号*，指示它退出（实际上，除以零和空指针解引用会导致操作系统发送 `SIGFPE` 和 `SIGSEGV` 信号，指示进程退出）。
- en: SIGNALS
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 信号
- en: A *signal* is a software interrupt that the OS delivers to a process. Signals
    are a method by which related processes can communicate with one another. The
    OS provides an interface for one process to send a signal to another, and for
    it to communicate with processes (to send a process a `SIGSEGV` signal when it
    dereferences a null pointer, for example).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号* 是操作系统发送给进程的软件中断。信号是一种相关进程之间进行通信的方式。操作系统提供了一个接口，让一个进程能够向另一个进程发送信号，从而进行通信（例如，当一个进程解引用空指针时，操作系统发送
    `SIGSEGV` 信号告诉该进程退出）。'
- en: When a process receives a signal, it is interrupted to run special signal handler
    code. A system defines a fixed number of signals to communicate various meanings,
    each differentiated by a unique signal number. The OS implements default signal
    handlers for each signal type, but programmers can register their own user-level
    signal handler code to override the default actions of most signals for their
    application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程接收到信号时，它会被中断并运行特定的信号处理程序代码。操作系统定义了一定数量的信号，用来传达不同的含义，每个信号由一个唯一的信号编号区分。操作系统为每种信号类型实现了默认的信号处理程序，但程序员可以注册自己的用户级信号处理程序代码，以覆盖大多数信号的默认行为，适应他们的应用需求。
- en: “Signals” on [page 657](ch13.xhtml#lev2_231) contains more information about
    signals and signal handling.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 《信号》部分位于 [第 657 页](ch13.xhtml#lev2_231)，其中包含关于信号和信号处理的更多信息。
- en: If a shell process wants to terminate its child process running `a.out`, it
    can send the child a `SIGKILL` signal. When the child process receives the signal,
    it runs signal handler code for `SIGKILL` that calls `exit`, terminating the child
    process. If a user types CTRL-C in a Unix shell that is currently running a program,
    the child process receives a `SIGINT` signal. The default signal handler for `SIGINT`
    also calls `exit`, resulting in the child process exiting.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 shell 进程想要终止它正在运行 `a.out` 的子进程，它可以向子进程发送一个 `SIGKILL` 信号。当子进程接收到信号时，它会运行处理
    `SIGKILL` 信号的代码，调用 `exit` 来终止子进程。如果用户在当前运行程序的 Unix shell 中按下 CTRL-C，子进程会接收到一个
    `SIGINT` 信号。`SIGINT` 的默认信号处理程序也会调用 `exit`，导致子进程退出。
- en: After executing the `exit` system call, the OS delivers a `SIGCHLD` signal to
    the process’s parent process to notify it that its child has exited. The child
    becomes a *zombie* process; it moves to the Exited state and can no longer run
    on the CPU. The execution state of a zombie process is partially cleaned up, but
    the OS still maintains a little information about it, including about how it terminated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `exit` 系统调用后，操作系统会向父进程发送一个 `SIGCHLD` 信号，通知它子进程已经退出。子进程变成一个 *僵尸* 进程；它进入已退出状态，无法再在
    CPU 上运行。僵尸进程的执行状态部分被清理，但操作系统仍然保留一些关于它的信息，包括它是如何终止的。
- en: A parent process *reaps* its zombie child (cleans up the rest of its state from
    the system) by calling the `wait` system call. If the parent process calls `wait`
    before its child process exits, then the parent process blocks until it receives
    a `SIGCHLD` signal from the child. The `waitpid` system call is a version of `wait`
    that takes a PID argument, allowing a parent to block while waiting for the termination
    of a specific child process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程通过调用 `wait` 系统调用来*回收*其僵尸子进程（清理系统中的剩余状态）。如果父进程在子进程退出之前调用了 `wait`，那么父进程会被阻塞，直到接收到来自子进程的
    `SIGCHLD` 信号。`waitpid` 系统调用是 `wait` 的一种变体，它接受一个 PID 参数，允许父进程在等待特定子进程终止时阻塞。
- en: '[Figure 13-13](ch13.xhtml#ch13fig13) shows the sequence of events that occur
    when a process exits.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-13](ch13.xhtml#ch13fig13) 显示了进程退出时发生的事件序列。'
- en: '![image](../images/13fig13.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig13.jpg)'
- en: '*Figure 13-13: Process exit. Left: The child process calls the `exit` system
    call to clean up most of its execution state. Middle: After running `exit`, the
    child process becomes a zombie (it is in the Exited state and cannot run again),
    and its parent process is sent a `SIGCHLD` signal, notifying it that its child
    is exited. Right: The parent calls `waitpid` to reap its zombie child (cleans
    up the rest of the child’s state from the system).*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-13：进程退出。左图：子进程调用 `exit` 系统调用清理其大部分执行状态。中图：运行 `exit` 后，子进程变成僵尸进程（它处于已退出状态，不能再次运行），并且父进程会收到一个
    `SIGCHLD` 信号，通知它子进程已退出。右图：父进程调用 `waitpid` 回收其僵尸子进程（从系统中清理子进程的剩余状态）。*'
- en: Because the parent and child processes execute concurrently, the parent may
    call `wait` before its child exits, or the child can exit before the parent calls
    `wait`. If the child is still executing when the parent process calls `wait`,
    then the parent blocks until the child exits (the parent enters the Blocked state
    waiting for the `SIGCHLD` signal event to happen). The blocking behavior of the
    parent can be seen if you run a program (`a.out`) in the foreground of a shell—the
    shell program doesn’t print out a shell prompt until `a.out` terminates, indicating
    that the shell parent process is blocked on a call to `wait`, waiting until it
    receives a `SIGCHLD` from its child process running `a.out`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于父子进程是并发执行的，父进程可能在子进程退出之前就调用 `wait`，或者子进程可能在父进程调用 `wait` 之前退出。如果子进程在父进程调用 `wait`
    时仍在执行，那么父进程会被阻塞，直到子进程退出（父进程进入阻塞状态，等待 `SIGCHLD` 信号事件发生）。父进程的阻塞行为可以通过在 shell 中前台运行一个程序（`a.out`）来观察——在
    `a.out` 终止之前，shell 程序不会打印出 shell 提示符，表示 shell 父进程在调用 `wait` 时被阻塞，直到接收到来自其运行 `a.out`
    的子进程的 `SIGCHLD` 信号。
- en: 'A programmer can also design the parent process code so that it will never
    block waiting for a child process to exit. If the parent implements a `SIGCHLD`
    signal handler that contains the call to `wait`, then the parent only calls `wait`
    when there is an exited child process to reap, and thus it doesn’t block on a
    `wait` call. This behavior can be seen by running a program in the background
    in a shell (`a.out &`). The shell program will continue executing, print out a
    prompt, and execute another command as its child runs `a.out`. Here’s an example
    of how you might see the difference between a parent blocking on `wait` vs. a
    nonblocking parent that only calls `wait` inside a `SIGCHLD` signal handler (make
    sure you execute a program that runs for long enough to notice the difference):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员还可以设计父进程代码，使其在等待子进程退出时永远不会阻塞。如果父进程实现了一个`SIGCHLD`信号处理程序，其中包含对`wait`的调用，那么父进程只有在有子进程退出时才会调用`wait`，从而避免在`wait`调用时发生阻塞。通过在shell中后台运行程序（`a.out
    &`）可以看到这种行为。Shell程序将继续执行，打印提示符，并在子进程运行`a.out`时执行另一个命令。以下是一个例子，展示了父进程在`wait`上阻塞与在`SIGCHLD`信号处理程序中只调用`wait`的非阻塞父进程之间的区别（确保你运行的程序足够长时间以注意到差异）：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Following is an example code snippet containing `fork`, `exec`, `exit`, and
    `wait` system calls (with error handling removed for readability). This example
    is designed to test your understanding of these system calls and their effects
    on the execution of the processes. In this example, the parent process creates
    a child process and waits for it to exit. The child then forks another child to
    run the `a.out` program (the first child is the parent of the second child). It
    then waits for its child to exit.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含`fork`、`exec`、`exit`和`wait`系统调用的示例代码片段（为便于阅读，已去除错误处理）。此示例旨在测试你对这些系统调用及其对进程执行影响的理解。在这个示例中，父进程创建一个子进程并等待其退出。然后，子进程再创建另一个子进程来运行`a.out`程序（第一个子进程是第二个子进程的父进程）。接着，它等待其子进程退出。
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 13-14](ch13.xhtml#ch13fig14) illustrates the execution time line of
    process create/running/blocked/exit events from executing the preceding example.
    The dotted lines represent times when a process’s execution overlaps with its
    child or descendants: the processes are concurrent and can be scheduled on the
    CPU in any order. Solid lines represent dependencies on the execution of the processes.
    For example, Child 1 cannot call `exit` until it has reaped its exited child process,
    Child 2\. When a process calls `wait`, it blocks until its child exits. When a
    process calls `exit`, it never runs again. The program’s output is annotated along
    each process’s execution time line at points in its execution when the corresponding
    `printf` statement can occur.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-14](ch13.xhtml#ch13fig14)展示了执行前述示例时，进程创建/运行/阻塞/退出事件的执行时间线。虚线表示进程的执行与其子进程或后代进程重叠的时间：这些进程是并发的，可以以任何顺序在CPU上调度。实线表示进程执行的依赖关系。例如，子进程1在回收子进程2退出之前无法调用`exit`。当进程调用`wait`时，它会阻塞直到子进程退出。当进程调用`exit`时，它将不再运行。程序的输出在每个进程的执行时间线上标注，表示在执行过程中对应的`printf`语句可能出现的位置。'
- en: '![image](../images/13fig14.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig14.jpg)'
- en: '*Figure 13-14: The execution time line for the example program, showing a possible
    sequence of `fork`, `exec`, `wait`, and `exit` calls from the three processes.
    Solid lines represent dependencies in the order of execution between processes,
    and dotted lines concurrent execution points. Parent is the parent process of
    Child 1, and Child 1 is the parent of Child 2.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-14：示例程序的执行时间线，显示了三进程间可能的`fork`、`exec`、`wait`和`exit`调用顺序。实线表示进程间执行顺序的依赖关系，虚线表示并发执行点。Parent是子进程1的父进程，子进程1是子进程2的父进程。*'
- en: After the calls to `fork` are made in this program, the parent process and first
    child process run concurrently, thus the call to `wait` in the parent could be
    interleaved with any instruction of its child. For example, the parent process
    could call `wait` and block before its child process calls `fork` to create its
    child process. [Table 13-2](ch13.xhtml#ch13tab2) lists all possible outputs from
    running the example program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本程序中，调用`fork`后，父进程和第一个子进程并发执行，因此父进程中的`wait`调用可能与子进程的任何指令交替执行。例如，父进程可能在子进程调用`fork`创建子进程之前就调用`wait`并阻塞。[表
    13-2](ch13.xhtml#ch13tab2)列出了运行示例程序时所有可能的输出结果。
- en: '**Table 13-2:** All Possible Output Orderings from the Program'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 13-2：** 程序的所有可能输出顺序'
- en: '| **Option 1** | **Option 2** | **Option 3** | **Option 4** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **选项 1** | **选项 2** | **选项 3** | **选项 4** |'
- en: '| A | A | A | A |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| A | A | A | A |'
- en: '| B | B | B | E |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| B | B | B | E |'
- en: '| C | C | E | B |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| C | C | E | B |'
- en: '| D | E | C | C |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| D | E | C | C |'
- en: '| E | D | D | D |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| E | D | D | D |'
- en: '| F | F | F | F |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| F | F | F | F |'
- en: The program outputs in [Table 13-2](ch13.xhtml#ch13tab2) are all possible because
    the parent runs concurrently with its descendant processes until it calls `wait`.
    Thus, the parent’s call to `printf("E\n")` can be interleaved at any point between
    the start and the exit of its descendant processes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在[表 13-2](ch13.xhtml#ch13tab2)中的输出都是可能的，因为父进程与其子孙进程并发执行，直到调用`wait`为止。因此，父进程调用`printf("E\n")`可以在任何时刻与子孙进程的开始和退出交替执行。
- en: 13.3 Virtual Memory
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3 虚拟内存
- en: The OS’s process abstraction provides each process with a virtual memory space.
    *Virtual memory* is an abstraction that gives each process its own private, logical
    address space in which its instructions and data are stored. Each process’s virtual
    address space can be thought of as an array of addressable bytes from address
    0 up to some maximum address. For example, on 32-bit systems the maximum address
    is 2^(32) – 1\. Processes cannot access the contents of one another’s address
    spaces. Some parts of a process’s virtual address space come from the binary executable
    file it’s running (e.g., the *text* portion contains program instructions from
    the `a.out` file). Other parts of a process’s virtual address space are created
    at runtime (e.g., the *stack*).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的进程抽象为每个进程提供了一个虚拟内存空间。*虚拟内存*是一种抽象，它为每个进程提供了一个独立的、逻辑上的地址空间，用于存储其指令和数据。每个进程的虚拟地址空间可以被看作是从地址0到某个最大地址的一个可寻址字节的数组。例如，在32位系统中，最大地址为2^(32)
    - 1。进程不能访问彼此的地址空间中的内容。进程的虚拟地址空间的某些部分来自于它正在运行的二进制可执行文件（例如，*text*部分包含来自`a.out`文件的程序指令）。进程虚拟地址空间的其他部分则是在运行时创建的（例如，*stack*部分）。
- en: 'Operating systems implement virtual memory as part of the *lone view* abstraction
    of processes. That is, each process only interacts with memory in terms of its
    own virtual address space rather than the reality of many processes simultaneously
    sharing the computer’s physical memory (RAM). The OS also uses its virtual memory
    implementation to protect processes from accessing one another’s memory spaces.
    As an example, consider the following simple C program:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统将虚拟内存实现为进程的*单一视图*抽象的一部分。也就是说，每个进程仅通过自己的虚拟地址空间与内存交互，而不是基于多个进程同时共享计算机物理内存（RAM）的现实。操作系统还使用其虚拟内存实现来保护进程，防止它们访问彼此的内存空间。举个例子，考虑以下简单的C程序：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If two processes simultaneously execute this program, they each get their own
    copy of stack memory as part of their separate virtual address spaces. As a result,
    if one process executes `x = 6` it will have no effect on the value of `x` in
    the other process—each process has its own copy of `x`, in its private virtual
    address space, as shown in [Figure 13-15](ch13.xhtml#ch13fig15).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个进程同时执行这个程序，它们每个都会获得自己的一份栈内存，作为各自独立虚拟地址空间的一部分。因此，如果一个进程执行`x = 6`，它不会影响另一个进程中`x`的值——每个进程都有自己的一份`x`，存储在它的私有虚拟地址空间中，正如在[图
    13-15](ch13.xhtml#ch13fig15)中所示。
- en: '![image](../images/13fig15.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig15.jpg)'
- en: '*Figure 13-15: Two executions of `a.out` results in two processes, each running
    isolated instances of the `a.out` program. Each process has its own private virtual
    address space, containing its copies of program instructions, global variables,
    and stack and heap memory space. For example, each may have a local variable `x`
    in the stack portion of their virtual address spaces.*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-15：`a.out`的两次执行结果是两个进程，每个进程都在隔离的实例中运行`a.out`程序。每个进程都有自己的私有虚拟地址空间，包含程序指令、全局变量，以及栈和堆内存空间的副本。例如，每个进程可能在虚拟地址空间的栈部分都有一个局部变量`x`。*'
- en: A process’s virtual address space is divided into several sections, each of
    which stores a different part of the process’s memory. The top part (at the lowest
    addresses) is reserved for the OS and can only be accessed in kernel mode. The
    text and data parts of a process’s virtual address space are initialized from
    the program executable file (`a.out`). The text section contains the program instructions,
    and the data section contains global variables (the data portion is actually divided
    into two parts, one for initialized global variables and the other for uninitialized
    globals).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的虚拟地址空间被划分为几个部分，每一部分存储进程内存的不同部分。最上面的一部分（最低的地址）保留给操作系统，并且只能在内核模式下访问。进程虚拟地址空间中的文本和数据部分是从程序可执行文件（`a.out`）中初始化的。文本段包含程序指令，数据段包含全局变量（数据部分实际上分为两部分，一部分是初始化的全局变量，另一部分是未初始化的全局变量）。
- en: The stack and heap sections of a process’s virtual address space vary in size
    as the process runs. Stack space grows in response to the process making function
    calls, and shrinks as it returns from functions. Heap space grows when the process
    dynamically allocates memory space (via calls to `malloc`), and shrinks when the
    process frees dynamically allocated memory space (via calls to `free`). The heap
    and stack portions of a process’s memory are typically located far apart in its
    address space to maximize the amount of space either can use. Typically, the stack
    is located at the bottom of a process’s address space (near the maximum address),
    and grows upward into lower addresses as stack frames are added to the top of
    the stack in response to a function call.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 进程虚拟地址空间中的堆和栈部分的大小随着进程的运行而变化。栈空间会随着进程进行函数调用而增长，在从函数返回时缩小。堆空间则会在进程动态分配内存空间（通过调用`malloc`）时增长，在进程释放动态分配的内存空间（通过调用`free`）时缩小。进程内存中的堆和栈部分通常位于虚拟地址空间的远离位置，以最大化两者可用的空间。通常情况下，栈位于进程地址空间的底部（靠近最大地址），并随着函数调用的发生而向下扩展，栈帧被添加到栈顶。
- en: ABOUT HEAP AND STACK MEMORY
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 堆和栈内存
- en: The actual total capacity of heap and stack memory space does not typically
    change on every call to `malloc` and `free`, nor on every function call and return.
    Instead, these actions often only make changes to how much of the currently allocated
    heap and stack parts of the virtual memory space are actively being used by the
    process. Sometimes, however, these actions do result in changes to the total capacity
    of the heap or stack space.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 堆和栈内存空间的实际总容量通常不会在每次调用`malloc`和`free`时发生变化，也不会在每次函数调用和返回时发生变化。相反，这些操作通常只是改变当前分配的虚拟内存空间中的堆和栈部分的实际使用量。然而，有时这些操作确实会导致堆或栈空间总容量的变化。
- en: The operating system is responsible for managing a process’s virtual address
    space, including changing the total capacity of heap and stack space. The system
    calls `brk`, `sbrk`, or `mmap` can be used to request that the OS change the total
    capacity of heap memory. C programmers do not usually invoke these system calls
    directly. Instead, C programmers call the standard C library function `malloc`
    (and `free`) to allocate (and free) heap memory space. Internally, the standard
    C library’s user-level heap manager may invoke one of these system calls to request
    that the OS change the size of heap memory space to satisfy a `malloc` request.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统负责管理进程的虚拟地址空间，包括改变堆和栈空间的总容量。系统调用`brk`、`sbrk`或`mmap`可以用来请求操作系统改变堆内存的总容量。C
    程序员通常不会直接调用这些系统调用，而是通过调用标准 C 库函数`malloc`（和`free`）来分配（和释放）堆内存空间。在内部，标准 C 库的用户级堆管理器可能会调用其中一个系统调用，请求操作系统改变堆内存空间的大小，以满足`malloc`请求。
- en: 13.3.1 Memory Addresses
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1 内存地址
- en: Because processes operate within their own virtual address spaces, operating
    systems must make an important distinction between two types of memory addresses.
    *Virtual addresses* refer to storage locations in a process’s virtual address
    space, and *physical addresses* refer to storage locations in physical memory
    (RAM).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进程在各自的虚拟地址空间中运行，操作系统必须区分两种类型的内存地址。*虚拟地址*指的是进程虚拟地址空间中的存储位置，*物理地址*指的是物理内存（RAM）中的存储位置。
- en: Physical Memory (RAM) and Physical Memory Addresses
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物理内存（RAM）和物理内存地址
- en: From [Chapter 11](ch11.xhtml#ch11), we know that physical memory (RAM) can be
    viewed as an array of addressable bytes in which addresses range from 0 to a maximum
    address value based on the total size of RAM. For example, in a system with 2
    gigabytes (GB) of RAM, physical memory addresses range from 0 to 2^(31) – 1 (1
    GB is 2^(30) bytes, so 2 GB is 2^(31) bytes).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [第 11 章](ch11.xhtml#ch11) 我们知道，物理内存（RAM）可以视为一个可寻址字节的数组，其中地址范围从 0 到基于 RAM 总大小的最大地址值。例如，在一个具有
    2 GB RAM 的系统中，物理内存地址的范围是从 0 到 2^(31) – 1（1 GB 为 2^(30) 字节，所以 2 GB 为 2^(31) 字节）。
- en: In order for the CPU to run a program, the program’s instructions and data must
    be loaded into RAM by the OS; the CPU cannot directly access other storage devices
    (e.g., disks). The OS manages RAM and determines which locations in RAM should
    store the virtual address space contents of a process. For example, if two processes,
    P1 and P2, run the earlier example program, then P1 and P2 have separate copies
    of the `x` variable, each stored at a different location in RAM. That is, P1’s
    `x` and P2’s `x` have different physical addresses. If the OS gave P1 and P2 the
    same physical address for their `x` variables, then P1 setting `x` to 6 would
    also modify P2’s value of `x`, violating the per-process private virtual address
    space.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 CPU 运行一个程序，操作系统必须将程序的指令和数据加载到 RAM 中；CPU 不能直接访问其他存储设备（例如磁盘）。操作系统管理 RAM 并决定应该将哪些位置存储到进程的虚拟地址空间内容。例如，如果两个进程
    P1 和 P2 运行之前的示例程序，那么 P1 和 P2 会有各自独立的 `x` 变量副本，每个副本都存储在 RAM 中不同的位置。也就是说，P1 的 `x`
    和 P2 的 `x` 有不同的物理地址。如果操作系统将相同的物理地址分配给 P1 和 P2 的 `x` 变量，那么 P1 将 `x` 设置为 6 时，也会修改
    P2 的 `x` 值，这将违反每个进程独立的虚拟地址空间。
- en: At any point in time, the OS stores in RAM the address space contents from many
    processes as well as OS code that it may map into every process’s virtual address
    space (OS code is typically loaded starting at address 0x0 of RAM). [Figure 13-16](ch13.xhtml#ch13fig16)
    shows an example of the OS and three processes (P1, P2, and P3) loaded into RAM.
    Each process gets its own separate physical storage locations for its address
    space contents (e.g., even if P1 and P2 run the same program, they get separate
    physical storage locations for their variable `x`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，操作系统都会将多个进程的地址空间内容以及可能映射到每个进程虚拟地址空间中的操作系统代码存储在 RAM 中（操作系统代码通常从 RAM 的地址
    0x0 开始加载）。[图 13-16](ch13.xhtml#ch13fig16) 显示了操作系统和三个进程（P1、P2 和 P3）加载到 RAM 中的示例。每个进程都会为其地址空间内容分配独立的物理存储位置（例如，即使
    P1 和 P2 运行相同的程序，它们也会为变量 `x` 分配独立的物理存储位置）。
- en: '![image](../images/13fig16.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig16.jpg)'
- en: '*Figure 13-16: Example RAM contents showing OS loaded at address 0x0, and processes
    loaded at different physical memory addresses in RAM. If P1 and P2 are running
    the same `a.out`, P1’s physical address for `x` is different from P2’s physical
    address for `x`.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-16：示例 RAM 内容，显示操作系统加载在地址 0x0，进程加载在 RAM 中不同物理内存地址。如果 P1 和 P2 运行相同的 `a.out`，则
    P1 的 `x` 的物理地址与 P2 的 `x` 的物理地址不同。*'
- en: Virtual Memory and Virtual Addresses
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 虚拟内存和虚拟地址
- en: Virtual memory is the per-process view of its memory space, and *virtual addresses*
    are addresses in the process’s view of its memory. If two process run the same
    binary executable, then they have exactly the same virtual addresses for function
    code and for global variables in their address spaces (the virtual addresses of
    dynamically allocated space in heap memory and of local variables on the stack
    may vary slightly between the two processes due to runtime differences in their
    two separate executions). In other words, both processes will have the same virtual
    addresses for the location of their `main` function, and the same virtual address
    for the location of a global variable `x` in their address spaces, as shown in
    [Figure 13-17](ch13.xhtml#ch13fig17).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存是每个进程对其内存空间的视图，*虚拟地址*是进程视图中内存的地址。如果两个进程运行相同的二进制可执行文件，那么它们在地址空间中对于函数代码和全局变量的虚拟地址是完全相同的（由于两次独立执行过程中的运行时差异，堆内存中动态分配空间和栈上局部变量的虚拟地址可能会有所不同）。换句话说，两个进程对于它们的
    `main` 函数的位置具有相同的虚拟地址，且在它们的地址空间中，对于全局变量 `x` 的位置也有相同的虚拟地址，如 [图 13-17](ch13.xhtml#ch13fig17)
    所示。
- en: '![image](../images/13fig17.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig17.jpg)'
- en: '*Figure 13-17: Example virtual memory contents for two processes running the
    same `a.out` file. P1 and P2 have the same virtual address for global variable
    `x`.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-17：示例虚拟内存内容，显示两个进程运行相同的 `a.out` 文件。P1 和 P2 对全局变量 `x` 有相同的虚拟地址。*'
- en: 13.3.2 Virtual Address to Physical Address Translation
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2 虚拟地址到物理地址的转换
- en: 'A program’s assembly and machine code instructions refer to virtual addresses.
    As a result, if two processes execute the same `a.out` program, the CPU executes
    instructions with identical virtual addresses to access corresponding parts of
    their two separate virtual address spaces. For example, supposing that `x` is
    at virtual address 0x24100, then assembly instructions to set `x` to 6 might look
    like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的汇编和机器代码指令引用虚拟地址。因此，如果两个进程执行相同的`a.out`程序，CPU将执行带有相同虚拟地址的指令，以访问它们各自的虚拟地址空间中的相应部分。例如，假设`x`位于虚拟地址0x24100，那么设置`x`为6的汇编指令可能如下所示：
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At runtime the OS loads each of the processes’ `x` variables at different physical
    memory addresses (at different locations in RAM). This means that whenever the
    CPU executes a load or store instruction to memory that specify virtual addresses,
    the virtual address from the CPU must be translated to its corresponding physical
    address in RAM before reading or writing the bytes from RAM.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，操作系统将每个进程的`x`变量加载到不同的物理内存地址（RAM中的不同位置）。这意味着每当CPU执行指向内存的加载或存储指令时，这些指令指定了虚拟地址，CPU中的虚拟地址必须先转换为RAM中对应的物理地址，然后才能从RAM中读取或写入字节。
- en: Because virtual memory is an important and core abstraction implemented by operating
    systems, processors generally provide some hardware support for virtual memory.
    An OS can make use of this hardware-level virtual memory support to perform virtual
    to physical address translations quickly, avoiding having to trap to the OS to
    handle every address translation. A particular OS chooses how much of the hardware
    support for paging it uses in its implementation of virtual memory. There is often
    a trade-off in speed versus flexibility when choosing a hardware-implemented feature
    versus a software-implemented feature.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟内存是操作系统实现的一个重要且核心的抽象，处理器通常提供某种硬件支持虚拟内存。操作系统可以利用这种硬件级的虚拟内存支持来快速执行虚拟地址到物理地址的转换，从而避免每次地址转换都需要切换到操作系统来处理。特定的操作系统可以选择在其虚拟内存实现中使用多少硬件支持分页。在选择硬件实现功能与软件实现功能时，通常会在速度和灵活性之间进行权衡。
- en: 'The *memory management unit* (MMU) is the part of the computer hardware that
    implements address translation. Together, the MMU hardware and the OS translate
    virtual to physical addresses when applications access memory. The particular
    hardware/software split depends on the specific combination of hardware and OS.
    At its most complete, MMU hardware performs the full translation: it takes a virtual
    address from the CPU and translates it to a physical address that is used to address
    RAM (as shown in [Figure 13-18](ch13.xhtml#ch13fig18)). Regardless of the extent
    of hardware support for virtual memory, there will be some virtual-to-physical
    translations that the OS has to handle. In our discussion of virtual memory, we
    assume a more complete'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存管理单元*（MMU）是计算机硬件的一部分，用于实现地址转换。MMU硬件和操作系统共同完成虚拟地址到物理地址的转换，当应用程序访问内存时。具体的硬件/软件分工取决于硬件和操作系统的具体组合。在最完整的情况下，MMU硬件执行完整的转换：它从CPU获取虚拟地址，并将其转换为物理地址，用于寻址RAM（如[图13-18](ch13.xhtml#ch13fig18)所示）。无论虚拟内存的硬件支持程度如何，总有一些虚拟到物理的转换需要操作系统来处理。在我们讨论虚拟内存时，假设使用的是更完整的方式。'
- en: MMU that minimizes the amount of OS involvement required for address translation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: MMU最小化了操作系统在地址转换中所需的干预。
- en: '![image](../images/13fig18.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig18.jpg)'
- en: '*Figure 13-18: The memory management unit (MMU) maps virtual to physical addresses.
    Virtual addresses are used in instructions executed by the CPU. When the CPU needs
    to fetch data from physical memory, the virtual address is first translated by
    the MMU to a physical addresses that is used to address RAM.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-18：内存管理单元（MMU）将虚拟地址映射到物理地址。虚拟地址用于CPU执行的指令中。当CPU需要从物理内存中获取数据时，虚拟地址首先由MMU转换为物理地址，用于寻址RAM。*'
- en: The OS maintains virtual memory mappings for each process to ensure that it
    can correctly translate virtual to physical addresses for any process that runs
    on the CPU. During a context switch, the OS updates the MMU hardware to refer
    to the swapped-on process’s virtual-to-physical memory mappings. The OS protects
    processes from accessing one another’s memory spaces by swapping the per-process
    address mapping state on a context switch—swapping the mappings on a context switch
    ensures that one process’s virtual addresses will not map to physical addresses
    storing another process’s virtual address space.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为每个进程维护虚拟内存映射，以确保能够正确地将虚拟地址转换为物理地址，供任何在CPU上运行的进程使用。在上下文切换期间，操作系统会更新MMU硬件，指向被交换进来的进程的虚拟到物理内存映射。操作系统通过在上下文切换时交换每个进程的地址映射状态来保护进程不互相访问彼此的内存空间——在上下文切换时交换映射，确保一个进程的虚拟地址不会映射到存储另一个进程虚拟地址空间的物理地址上。
- en: 13.3.3 Paging
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.3 分页
- en: Although many virtual memory systems have been proposed over the years, paging
    is now the most widely used implementation of virtual memory. In a *paged virtual
    memory* system, the OS divides the virtual address space of each process into
    fixed-sized chunks called *pages*. The OS defines the page size for the system.
    Page sizes of a few kilobytes are commonly used in general-purpose operating systems
    today—4 KB (4,096 bytes) is the default page size on many systems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来已经提出了许多虚拟内存系统，但分页现在是最广泛使用的虚拟内存实现。在*分页虚拟内存*系统中，操作系统将每个进程的虚拟地址空间划分为固定大小的块，称为*页*。操作系统定义了系统的页大小。如今，一些通用操作系统通常使用几千字节的页大小——4
    KB（4,096字节）是许多系统的默认页大小。
- en: Physical memory is similarly divided by the OS into page-sized chunks called
    *frames*. Because pages and frames are defined to be the same size, any page of
    a process’s virtual memory can be stored in any frame of physical RAM.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 物理内存也被操作系统划分为与页面大小相同的块，称为*帧*。由于页面和帧被定义为相同的大小，因此进程的任何虚拟内存页面都可以存储在物理RAM的任何帧中。
- en: In a paging system, pages and frames are the same size, so any page of virtual
    memory can be loaded into (stored) in any physical frame of RAM; a process’s pages
    do not need to be stored in contiguous RAM frames (at a sequence of addresses
    all next to one another in RAM); and not every page of virtual address space needs
    to be loaded into RAM for a process to run.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在分页系统中，页面和帧的大小相同，因此虚拟内存的任何页面都可以加载（存储）到物理RAM的任何帧中；进程的页面不需要存储在连续的RAM帧中（即在RAM中紧邻的一系列地址）；并且并非每个虚拟地址空间的页面都需要加载到RAM中，才能让进程运行。
- en: '[Figure 13-19](ch13.xhtml#ch13fig19) shows an example of how pages from a process’s
    virtual address space may map to frames of physical RAM.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-19](ch13.xhtml#ch13fig19)展示了一个示例，说明进程的虚拟地址空间中的页面如何映射到物理RAM的帧。'
- en: '![image](../images/13fig19.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig19.jpg)'
- en: '*Figure 13-19: Paged virtual memory. Individual pages of a process’s virtual
    address space are stored in RAM frames. Any page of virtual address space can
    be loaded into (stored at) any frame of physical memory. In this example, P1’s
    virtual page 1000 is stored in physical frame 100, and its [page 500](ch09.xhtml#page_500)
    resides in frame 513\. P2’s virtual page 1000 is stored in physical frame 880,
    and its [page 230](ch04.xhtml#page_230) resides in frame 102.*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-19：分页虚拟内存。进程虚拟地址空间的单个页面存储在RAM帧中。虚拟地址空间的任何页面都可以加载到（存储在）任何物理内存帧中。在此示例中，P1的虚拟页1000存储在物理帧100中，而其[页500](ch09.xhtml#page_500)存储在帧513中。P2的虚拟页1000存储在物理帧880中，而其[页230](ch04.xhtml#page_230)存储在帧102中。*'
- en: Virtual and Physical Addresses in Paged Systems
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分页系统中的虚拟地址和物理地址
- en: 'Paged virtual memory systems divide the bits of a virtual address into two
    parts: the high-order bits specify the *page number* on which the virtual address
    is stored, and the low-order bits correspond to the *byte offset* within the page
    (which byte from the top of the page corresponds to the address).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 分页虚拟内存系统将虚拟地址的位划分为两部分：高位指定虚拟地址存储的*页号*，低位对应于页面内的*字节偏移*（即页面顶部的哪个字节对应该地址）。
- en: 'Similarly, paging systems divide physical addresses into two parts: the high-order
    bits specify the *frame number* of physical memory, and the low-order bits specify
    the *byte offset* within the frame. Because frames and pages are the same size,
    the byte offset bits in a virtual address are identical to the byte offset bits
    in its translated physical address. Virtual addresses differ from their translated
    physical addresses in their high-order bits, which specify the virtual page number
    and physical frame number.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，分页系统将物理地址分为两部分：高位指定物理内存的*帧号*，低位指定帧内的*字节偏移量*。由于帧和页面的大小相同，虚拟地址中的字节偏移位与其转换后的物理地址中的字节偏移位相同。虚拟地址与其转换后的物理地址的不同之处在于其高位，这些高位指定虚拟页面号和物理帧号。
- en: '![image](../images/13fig20.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig20.jpg)'
- en: '*Figure 13-20: The address bits in virtual and physical addresses*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-20：虚拟地址和物理地址中的地址位*'
- en: For example, consider a (very tiny) system with 16-bit virtual addresses, 14-bit
    physical addresses, and 8-byte pages. Because the page size is eight bytes, the
    low-order three bits of physical and virtual addresses define the byte offset
    into a page or frame—three bits can encode eight distinct byte offset values,
    0–7 (2³ is 8). This leaves the high-order 13 bits of the virtual address for specifying
    the page number and the high-order 11 bits of the physical address for specifying
    frame number, as shown in the example in [Figure 13-21](ch13.xhtml#ch13fig21).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个（非常小的）系统，具有16位虚拟地址、14位物理地址和8字节的页面。由于页面大小为8字节，物理地址和虚拟地址的低三位定义了页面或帧内的字节偏移量——三位可以编码8个不同的字节偏移值，0–7（2³等于8）。这使得虚拟地址的高13位用于指定页面号，物理地址的高11位用于指定帧号，如[图
    13-21](ch13.xhtml#ch13fig21)中的示例所示。
- en: '![image](../images/13fig21.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig21.jpg)'
- en: '*Figure 13-21: Virtual and physical address bit divisions in an example system
    with 16-bit virtual addresses, 14-bit physical addresses, and a page size of 8
    bytes.*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-21：在一个具有16位虚拟地址、14位物理地址和8字节页面大小的示例系统中，虚拟地址和物理地址的位划分。*'
- en: In the example in [Figure 13-21](ch13.xhtml#ch13fig21), virtual address 43357
    (in decimal) has a byte offset of 5 (0b101 in binary), the low-order 3 bits of
    the address, and a page number of 5419 (0b1010100101011), the high-order 13 bits
    of the address. This means that the virtual address is at byte 5 from the top
    of page 5419.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 13-21](ch13.xhtml#ch13fig21)中的示例中，虚拟地址43357（十进制）具有字节偏移量5（0b101，二进制），这是地址的低三位，以及页面号5419（0b1010100101011），这是地址的高13位。这意味着虚拟地址位于页面5419的第5个字节。
- en: If this page of virtual memory is loaded into frame 43 (0b00000101011) of physical
    memory, then its physical address is 349 (0b00000101011101), where the low-order
    3 bits (0b101) specify the byte offset, and the high-order 11 bits (0b00000101011)
    specify the frame number. This means that the physical address is at byte 5 from
    the top of frame 43 of RAM.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个虚拟内存页面被加载到物理内存的帧43（0b00000101011）中，那么它的物理地址是349（0b00000101011101），其中低三位（0b101）指定字节偏移量，高11位（0b00000101011）指定帧号。这意味着物理地址位于RAM帧43的第5个字节。
- en: Page Tables for Virtual-to-Physical Page Mapping
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 虚拟到物理页面映射的页表
- en: Because every page of a process’s virtual memory space can map to a different
    frame of RAM, the OS must maintain mappings for every virtual page in the process’s
    address space. The OS keeps a per-process *page table* that it uses to store the
    process’s virtual page number to physical frame number mappings. The page table
    is a data structure implemented by the OS that is stored in RAM. [Figure 13-22](ch13.xhtml#ch13fig22)
    shows an example of how the OS may store two process’s page tables in RAM. The
    page table of each process stores the mappings of its virtual pages to their physical
    frames in RAM such that any pages of virtual memory can be stored in any physical
    frame of RAM.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个进程的虚拟内存空间的每个页面可以映射到不同的RAM帧，操作系统必须为进程地址空间中的每个虚拟页面保持映射。操作系统维护一个每个进程的*页表*，它用于存储进程的虚拟页面号到物理帧号的映射。页表是由操作系统实现的数据结构，存储在RAM中。[图
    13-22](ch13.xhtml#ch13fig22)展示了操作系统如何在RAM中存储两个进程的页表的示例。每个进程的页表存储其虚拟页面到物理帧的映射，从而使任何虚拟内存的页面都可以存储在RAM的任何物理帧中。
- en: '![image](../images/13fig22.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig22.jpg)'
- en: '*Figure 13-22: Every process has a page table containing its virtual page to
    physical frame mappings. Page tables, stored in RAM, are used by the system to
    translate process’s virtual addresses to physical addresses that are used to address
    locations in RAM. This example shows the separate page tables stored in RAM for
    processes P1 and P2, each page table with its own virtual page to physical frame
    mappings.*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-22：每个进程都有一个页面表，包含其虚拟页面到物理帧的映射。页面表存储在 RAM 中，系统使用它来将进程的虚拟地址翻译为用于寻址 RAM
    中位置的物理地址。此示例显示了存储在 RAM 中的 P1 和 P2 进程的单独页面表，每个页面表都有自己的虚拟页面到物理帧的映射。*'
- en: For each page of virtual memory, the page table stores one *page table entry*
    (PTE) that contains the frame number of physical memory (RAM) storing the virtual
    page. A PTE may also contain other information about the virtual page, including
    a *valid bit* that is used to indicate whether the PTE stores a valid mapping.
    If a page’s valid bit is zero, then the page of the process’s virtual address
    space is not currently loaded into physical memory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个虚拟内存页面，页面表存储一个 *页面表项*（PTE），其中包含存储虚拟页面的物理内存（RAM）的帧号。一个 PTE 还可能包含关于虚拟页面的其他信息，包括一个
    *有效位*，用于指示 PTE 是否存储了有效的映射。如果某个页面的有效位为零，则该进程虚拟地址空间中的页面当前没有加载到物理内存中。
- en: '![image](../images/13fig23.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig23.jpg)'
- en: '*Figure 13-23: A page table entry (PTE) stores the frame number (23) of the
    frame of RAM in which the virtual page is loaded. We list the frame number (23)
    in decimal, although it is really encoded in binary in the PTE entry (0…010111).
    A valid bit of 1 indicates that this entry stores a valid mapping.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-23：页面表项（PTE）存储虚拟页面加载到的 RAM 页框的帧号（23）。我们以十进制列出帧号（23），尽管它实际上在 PTE 项中是以二进制编码的（0…010111）。有效位为
    1 表示此项存储了有效的映射。*'
- en: Using a Page Table to Map Virtual Addresses to Physical Addresses
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用页面表将虚拟地址映射到物理地址
- en: There are four steps to translating a virtual address to a physical address
    (shown in [Figure 13-24](ch13.xhtml#ch13fig24)). The particular OS/hardware combination
    determines which of the OS or the hardware performs all or part of each step.
    We assume a full-featured MMU that performs as much of the address translation
    as possible in hardware in describing these steps, but on some systems the OS
    may perform parts of these steps.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址到物理地址的翻译有四个步骤（如[图 13-24](ch13.xhtml#ch13fig24)所示）。具体的操作系统/硬件组合决定了由操作系统还是硬件执行这些步骤的全部或部分。在描述这些步骤时，我们假设一个全功能的
    MMU，它尽可能在硬件中执行尽可能多的地址翻译，但在某些系统中，操作系统可能会执行这些步骤中的某些部分。
- en: '1\. First, the MMU divides the bits of the virtual address into two parts:
    for a page size of 2^(*k*) bytes, the low-order *k* bits (VA bits *k –* 1 to 0)
    encode the byte offset (*d*) into the page, and the high-order *n – k* bits (VA
    bits *n –* 1 to *k*) encode the virtual page number (*p*).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 首先，MMU 将虚拟地址的位分为两部分：对于 2^(*k*) 字节的页面大小，低位的 *k* 位（VA 位 *k –* 1 到 0）编码页面内的字节偏移量
    (*d*)，而高位的 *n – k* 位（VA 位 *n –* 1 到 *k*）编码虚拟页面号 (*p*)。
- en: 2\. Next, the page number value (*p*) is used by the MMU as an index into the
    page table to access the PTE for page *p*. Most architectures have a *page table
    base register* (PTBR) that stores the RAM address of the running process’s page
    table. The value in the PTBR is combined with the page number value (*p*) to compute
    the address of the PTE for page *p*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 接下来，页面号值 (*p*) 被 MMU 用作页面表的索引，以访问页面 *p* 的 PTE。大多数架构都有一个 *页面表基址寄存器*（PTBR），它存储运行中进程页面表的
    RAM 地址。PTBR 中的值与页面号值 (*p*) 结合起来，计算出页面 *p* 的 PTE 地址。
- en: 3\. If the valid bit in the PTE is set (is 1), then the frame number in the
    PTE represents a valid VA to PA mapping. If the valid bit is 0, then a page fault
    occurs, triggering the OS to handle this address translation (we discuss the OS
    page fault handling later).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 如果 PTE 中的有效位被设置为 1，则 PTE 中的帧号表示有效的 VA 到 PA 映射。如果有效位为 0，则会发生页面错误，触发操作系统处理此地址转换（稍后我们会讨论操作系统的页面错误处理）。
- en: 4\. The MMU constructs the physical address using the frame number (*f*) bits
    from the PTE entry as the high-order bits, and the page offset (*d*) bits from
    the VA as the low-order bits of the physical address.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. MMU 使用来自 PTE 项的帧号 (*f*) 位作为高位，并使用来自 VA 的页面偏移量 (*d*) 位作为物理地址的低位，来构造物理地址。
- en: '![image](../images/13fig24.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/13fig24.jpg)'
- en: '*Figure 13-24: A process’s page table is used to perform virtual to physical
    address translations. The PTBR stores the base address of the currently running
    process’s page table.*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'An Example: Mapping VA to PA with a Page Table'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider an example (tiny) paging system for which the page size is 4 bytes,
    the virtual addresses are 6 bits (the high-order 4 bits are the page number and
    the low-order 2 bits are the byte offset), and the physical addresses are 7 bits.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Assume that the page table for process P1 in this system looks like [Table 13-3](ch13.xhtml#ch13tab3)
    (values are listed in both decimal and binary).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-3:** Process P1’s Page Table'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '| **Entry** | **Valid** | **Frame #** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| 0 (0b0000) | 1 | 23 (0b10111) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| 1 (0b0001) | 0 | 17 (0b10001) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| 2 (0b0010) | 1 | 11 (0b01011) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| 3 (0b0011) | 1 | 16 (0b10000) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| 4 (0b0100) | 0 | 8 (0b01000) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| 5 (0b0101) | 1 | 14 (0b01110) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| ⋮ | ⋮ | ⋮ |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| 15 (0b1111) | 1 | 30 (0b11110) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: Using the information provided in this example suggests several important things
    about address sizes, parts of addresses, and address translation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: First, the size of (number of entries in) the page table is determined by the
    number of bits in the virtual address and the page size in the system. The high-order
    4 bits of each 6-bit virtual address specifies the page number, so there are 16
    (2⁴) total pages of virtual memory. Since the page table has one entry for each
    virtual page, there are a total of 16 page table entries in each process’s page
    table.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the size of each page table entry (PTE) depends on the number of bits
    in the physical address and the page size in the system. Each PTE stores a valid
    bit and a physical frame number. The valid bit requires a single bit. The frame
    number requires 5 bits because physical addresses are 7 bits and the page offset
    is the low-order 2 bits (to address the 4 bytes on each page), which leaves the
    5 high-order bits for the frame number. Thus, each PTE entry requires 6 bits:
    1 for the valid bit, and 5 for the frame number.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Third, the maximum sizes of virtual and physical memory are determined by the
    number of bits in the addresses. Because virtual addresses are 6 bits, 2⁶ bytes
    of memory can be addressed, so each process’s virtual address space is 2⁶ (or
    64) bytes. Similarly, the maximum size of physical memory is 2⁷ (or 128) bytes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the page size, the number of bits in virtual and physical addresses,
    and the page table determine the mapping of virtual to physical addresses. For
    example, if process P1 executes an instruction to load a value from its virtual
    address 0b001110, its page table is used to convert the virtual address to physical
    address 0b1000010, which is then used to access the value in RAM.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'The virtual address (VA) to physical address (PA) translation steps are:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Separate the VA bits into the page number (*p*) and byte offset (*d*) bits:
    the high-order four bits are the page number (0b0011 or [page 3](preface.xhtml#page_3))
    and the lower-order two bits are the byte offset into the page (0b10 or byte 2).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Use the page number (3) as an index into the page table to read the PTE
    for virtual [page 3](preface.xhtml#page_3) (PT[3]: valid:1 frame#:16).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Check the valid bit for a valid PTE mapping. In this case, the valid bit
    is 1, so the PTE contains a valid mapping, meaning that virtual memory [page 3](preface.xhtml#page_3)
    is stored in physical memory frame 16.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Construct the physical address using the five-bit frame number from the
    PTE as the high-order address bits (0b10000), and the low-order two-bit offset
    from the virtual address (0b10) as the lower-order two bits: the physical address
    is 0b1000010 (in RAM frame 16 at byte offset 2).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Paging Implementation
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most computer hardware provides some support for paged virtual memory, and together
    the OS and hardware implement paging on a given system. At a minimum, most architectures
    provide a page table base register (PTBR) that stores the base address of the
    currently running process’s page table. To perform virtual-to-physical address
    translations, the virtual page number part of a virtual address is combined with
    the value stored in the PTBR to find the PTE entry for the virtual page. In other
    words, the virtual page number is an index into the process’s page table, and
    its value combined with the PTBR value gives the RAM address of the PTE for page
    *p* (e.g., PTBR + *p* × (PTE size) is the RAM address of the PTE for page *p*).
    Some architectures may support the full page table lookup by manipulating PTE
    bits in hardware. If not, then the OS needs to be interrupted to handle some parts
    of page table lookup and accessing the PTE bits to translate virtual addresses
    to physical addresses.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: On a context switch, the OS *saves and restores* the PTBR values of processes
    to ensure that when a process runs on the CPU it accesses its own virtual-to-physical
    address mappings from its own page table in RAM. This is one mechanism through
    which the OS protects processes’ virtual address spaces from one another; changing
    the PTBR value on context switch ensures that a process cannot access the VA–PA
    mappings of another process, and thus it cannot read or write values at physical
    addresses that store the virtual address space contents of any other processes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'An Example: Virtual to Physical Address Mappings of Two Processes'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As an example, consider an example system ([Table 13-4](ch13.xhtml#ch13tab4))
    with eight-byte pages, seven-bit virtual addresses, and six-bit physical addresses.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-4:** Example Process Page Tables'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '| **P1’s Page Table** | **P2’s Page Table** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| **Entry** | **Valid** | **Frame #** | **Entry** | **Valid** | **Frame #**
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 3 | 0 | 1 | 1 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 2 | 1 | 1 | 4 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 6 | 2 | 1 | 5 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '|  | ⋮ |  |  | ⋮ |  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| 11 | 1 | 7 | 11 | 0 | 3 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '|  | ⋮ |  |  | ⋮ |  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: 'Given the current state of the (partially shown) page tables of two processes
    (P1 and P2) in [Table 13-4](ch13.xhtml#ch13tab4), let’s compute the physical addresses
    for the following sequence of virtual memory addresses generated from the CPU
    (each address is prefixed by the process that is running on the CPU):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, determine the division of bits in virtual and physical addresses. Since
    the page size is eight bytes, the three low-order bits of every address encodes
    the page offset (*d*). Virtual addresses are seven bits. Thus, with three bits
    for the page offset, this leaves the four high-order bits for specifying the page
    number (*p*). Since physical addresses are six bits long and the low-order three
    are for the page offset, the high-order three bits specify the frame number.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Next, for each virtual address, use its page number bits (*p*) to look up in
    the process’s page table the PTE for page *p*. If the valid bit (*v*) in the PTE
    is set, then use the frame number (*f*) for the high-order bits of the PA. The
    low-order bits of the PA come from the byte-offset bits (*d*) of the VA.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The results are shown in [Table 13-5](ch13.xhtml#ch13tab5) (note which page
    table is being used for the translation of each address).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-5:** Address Mappings for the Example Sequence of Memory Accesses
    from Processes P1 and P2'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '| **Process** | **Virtual address** | *p* | *d* | **PTE** | *f* | *d* | **Physical
    address** |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| P1 | 0000100 | 0000 | 100 | `PT[0]: 1(*v*), 3(*f*)` | 011 | 100 | 011100
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| P1 | 0000000 | 0000 | 000 | `PT[0]: 1(*v*), 3(*f*)` | 011 | 000 | 011000
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| P1 | 0010000 | 0010 | 000 | `PT[2]: 1(*v*), 6(*f*)` | 110 | 000 | 110000
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| **Context switch P1 to P2** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| P2 | 0010000 | 0010 | 000 | `PT[2]: 1(*v*), 5(*f*)` | 101 | 000 | 101000
    |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| P2 | 0001010 | 0001 | 010 | `PT[1]: 1(*v*), 4(*f*)` | 100 | 010 | 100010
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| P2 | 1011001 | 1011 | 001 | `PT[11]: 0(*v*), 3(*f*)` | Page fault (valid
    bit 0) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| **Context switch P2 to P1** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| P1 | 1011001 | 1011 | 001 | `PT[11]: 1(*v*), 7(*f*)` | 111 | 001 | 111001
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: As one example, consider the first address accesses by process P1\. When P1
    accesses its virtual address 8 (0b0000100), the address is divided into its page
    number 0 (0b0000) and its byte offset 4 (0b100). The page number, 0, is used to
    look up PTE entry 0, whose valid bit is 1, indicating a valid page mapping entry,
    and whose frame number is 3 (0b011). The physical address (0b011100) is constructed
    using the frame number (0b011) as the high-order bits and the page offset (0b100)
    as the low-order bits.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: When process P2 is context switched on the CPU, its page table mappings are
    used (note the different physical addresses when P1 and P2 access the same virtual
    address 0b0010000). When P2 accesses a PTE entry with a 0 valid bit, it triggers
    a page fault to the OS to handle.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4 Memory Efficiency
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the primary goals of the operating system is to efficiently manage hardware
    resources. System performance is particularly dependent on how the OS manages
    the memory hierarchy. For example, if a process accesses data that are stored
    in RAM, then the process will run much faster than if those data are on disk.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The OS strives to increase the degree of multiprogramming in the system in order
    to keep the CPU busy doing real work while some processes are blocked waiting
    for an event like disk I/O. However, because RAM is fixed-size storage, the OS
    must make decisions about which process to load in RAM at any point in time, possibly
    limiting the degree of multiprogramming in the system. Even systems with a large
    amount of RAM (10s or 100s of gigabytes) often cannot simultaneously store the
    full address space of every process in the system. As a result, an OS can make
    more efficient use of system resources by running processes with only parts of
    their virtual address spaces loaded in RAM.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Virtual Memory Using RAM, Disk, and Page Replacement
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From “Locality” on [page 552](ch11.xhtml#lev1_88), we know that memory references
    usually exhibit a very high degree of locality. In terms of paging, this means
    that processes tend to access pages of their memory space with a high degree of
    temporal or spatial locality. It also means that at any point in its execution,
    a process is not typically accessing large extents of its address space. In fact,
    processes typically never access large extents of their full address spaces. For
    example, processes typically do not use the full extent of their stack or heap
    memory space.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: One way in which the OS can make efficient use of both RAM and CPU is to treat
    RAM as a cache for disk. In doing so, the OS allows processes to run in the system
    only having some of their virtual memory pages loaded into physical frames of
    RAM. Their other virtual memory pages remain on secondary storage devices such
    as disk, and the OS only brings them into RAM when the process accesses addresses
    on these pages. This is another part of the OS’s *virtual memory* abstraction—the
    OS implements a view of a single large physical “memory” that is implemented using
    RAM storage in combination with disk or other secondary storage devices. Programmers
    do not need to explicitly manage their program’s memory, nor do they need to handle
    moving parts in and out of RAM as their program needs it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: By treating RAM as a cache for disk, the OS keeps in RAM only those pages from
    processes’ virtual address spaces that are being accessed or have been accessed
    recently. As a result, processes tend to have the set of pages that they are accessing
    stored in fast RAM and the set of pages that they do not access frequently (or
    at all) stored on slower disk. This leads to more efficient use of RAM because
    the OS uses RAM to store pages that are actually being used by running processes,
    and doesn’t waste RAM space to store pages that will not be accessed for a long
    time or ever. It also results in more efficient use of the CPU by allowing more
    processes to simultaneously share RAM space to store their active pages, which
    can result in an increase in the number of ready processes in the system, reducing
    times when the CPU is idle due to all the processes waiting for some event like
    disk I/O.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'In virtual memory systems, however, processes sometimes try to access a page
    that is currently not stored in RAM (causing a *page fault*). When a page fault
    occurs, the OS needs to read the page from disk into RAM before the process can
    continue executing. The MMU reads a PTE’s valid bit to determine whether it needs
    to trigger a page fault exception. When it encounters a PTE whose valid bit is
    zero, it traps to the OS, which takes the following steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The OS finds a free frame (e.g., frame *j*) of RAM into which it will load
    the faulted page.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 2\. It next issues a read to the disk to load the page from disk into frame
    *j* of RAM.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 3\. When the read from disk has completed, the OS updates the PTE entry, setting
    the frame number to *j* and the valid bit to 1 (this PTE for the faulted page
    now has a valid mapping to frame *j*).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Finally, the OS restarts the process at the instruction that caused the
    page fault. Now that the page table holds a valid mapping for the page that faulted,
    the process can access the virtual memory address that maps to an offset in physical
    frame *j*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: To handle a page fault, the OS needs to keep track of which RAM frames are free
    so that it can find a free frame of RAM into which the page read from disk can
    be stored. Operating systems often keep a list of free frames that are available
    for allocating on a page fault. If there are no available free RAM frames, then
    the OS picks a frame and replaces the page it stores with the faulted page. The
    PTE of the replaced page is updated, setting its valid bit to 0 (this page’s PTE
    mapping is no longer valid). The replaced page is written back to disk if its
    in-RAM contents differ from its on-disk version; if the owning process wrote to
    the page while it was loaded in RAM, then the RAM version of the page needs to
    be written to disk before being replaced so that the modifications to the page
    of virtual memory are not lost. PTEs often include a *dirty bit* that is used
    to indicate if the in-RAM copy of the page has been modified (written to). During
    page replacement, if the dirty bit of the replaced page is set, then the page
    needs to be written to disk before being replaced with the faulted page. If the
    dirty bit is 0, then the on-disk copy of the replaced page matches the in-memory
    copy, and the page does not need to be written to disk when replaced.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Our discussion of virtual memory has primarily focused on the *mechanism* part
    of implementing paged virtual memory. However, there is an important *policy*
    part of paging in the OS’s implementation. The OS needs to run a *page replacement
    policy* when free RAM is exhausted in the system. A page replacement policy picks
    a frame of RAM that is currently being used and replaces its contents with the
    faulted page; the current page is *evicted* from RAM to make room for storing
    the faulted page. The OS needs to implement a good page replacement policy for
    selecting which frame in RAM will be written back to disk to make room for the
    faulted page. For example, an OS might implement the *least recently used* (LRU)
    policy, which replaces the page stored in the frame of RAM that has been accessed
    least recently. LRU works well when there is a high degree of locality in memory
    accesses. There are many other policies that an OS may choose to implement. See
    an OS textbook for more information about page replacement policies.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Making Page Accesses Faster
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Although paging has many benefits, it also results in a significant slowdown
    to every memory access. In a paged virtual memory system, every load and store
    to a virtual memory address requires *two* RAM accesses: the first reads the page
    table entry to get the frame number for virtual-to-physical address translation,
    and the second reads or writes the byte(s) at the physical RAM address. Thus,
    in a paged virtual memory system, every memory access is twice as slow as in a
    system that supports direct physical RAM addressing.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: One way to reduce the additional overhead of paging is to cache page table mappings
    of virtual page numbers to physical frame numbers. When translating a virtual
    address, the MMU first checks for the page number in the cache. If found, then
    the page’s frame number mapping can be grabbed from the cache entry, avoiding
    one RAM access for reading the PTE.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: A *translation look-aside buffer* (TLB) is a hardware cache that stores (page
    number, frame number) mappings. It is a small, fully associative cache that is
    optimized for fast lookups in hardware. When the MMU finds a mapping in the TLB
    (a TLB hit), a page table lookup is not needed, and only one RAM access is required
    to execute a load or store to a virtual memory address. When a mapping is not
    found in the TLB (a TLB miss), then an additional RAM access to the page’s PTE
    is required to first construct the physical address of the load or store to RAM.
    The mapping associated with a TLB miss is added into the TLB. With good locality
    of memory references, the hit rate in the TLB is very high, resulting in fast
    memory accesses in paged virtual memory—most virtual memory accesses require only
    a single RAM access. [Figure 13-25](ch13.xhtml#ch13fig25) shows how the TLB is
    used in virtual-to-physical address mappings.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/13fig25.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-25: The translation look-aside buffer (TLB) is a small hardware
    cache of virtual page to physical frame mappings. The TLB is first searched for
    an entry for page *p*. If found, then no page table lookup is needed to translate
    the virtual address to its physical address.*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 13.4 Interprocess Communication
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processes are one of the primary abstractions implemented by the OS. Private
    virtual address spaces are an important abstraction in multiprogrammed systems
    and are one way in which the OS prevents processes from interfering with one another’s
    execution state. However, sometimes a user or programmer may want their application
    processes to communicate with one another (or to share some of their execution
    state) as they run.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems typically implement support for several types of interprocess
    communication, or ways in which processes can communicate or share their execution
    state. *Signals* are a very restricted form of interprocess communication by which
    one process can send a signal to another process to notify it of some event. Processes
    can also communicate using *message passing*, in which the OS implements an abstraction
    of a message communication channel that is used by a process to exchange messages
    with another process. Finally, the OS may support interprocess communication through
    *shared memory* that allows a process to share all or part of its virtual address
    space with other processes. Processes with shared memory can read or write to
    addresses in shared space to communicate with one another.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.1 Signals
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *signal* is a software interrupt that is sent by one process to another process
    via the OS. When a process receives a signal, its current execution point is interrupted
    by the OS to run signal handler code. If the signal handler returns, the process’s
    execution continues from where it was interrupted to handle the signal. Sometimes
    the signal handler causes the process to exit, and thus it does not continue its
    execution from where it left off.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Signals are similar to hardware interrupts and traps but are different from
    both. Whereas a trap is a synchronous software interrupt that occurs when a process
    explicitly invokes a system call, signals are asynchronous—a process may be interrupted
    by the receipt of a signal at any point in its execution. Signals also differ
    from asynchronous hardware interrupts in that they are triggered by software rather
    than hardware devices.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: A process can send another process a signal by executing the `kill` system call,
    which requests that the OS post a signal to another process. The OS handles posting
    the signal to the target process and setting its execution state to run the signal
    handler code associated with the particular posted signal.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The name of the `kill` system call is potentially misleading as well as unfortunately
    violent. Although it can be (and often is) used to deliver a termination signal,
    it is also used to send any other type of signal to a process.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The OS itself also uses signals to notify processes of certain events. For example,
    the OS posts a `SIGCHLD` signal to a process when one of its child processes exits.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Systems define a fixed number of signals (e.g., Linux defines 32 different signals).
    As a result, signals provide a limited way in which processes can communicate
    with one another, as opposed to other interprocess communication methods such
    as messaging or shared memory.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 13-6](ch13.xhtml#ch13tab6) lists some of the defined signals. See the
    man page (`man 7 signal`) for additional examples.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 13-6:** Example Signals Used for Interprocess Communication'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signal** | **Description** |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| `SIGSEGV` | Segmentation fault (e.g., dereferencing a null pointer) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| `SIGINT` | Interrupt process (e.g., CTRL-C in terminal window to kill process)
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| `SIGCHLD` | Child process has exited (e.g., a child is now a zombie after
    running `exit`) |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| `SIGALRM` | Notify a process when a timer goes off (e.g., `alarm(2)` every
    2 secs) |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| `SIGKILL` | Terminate a process (e.g., `pkill -9 a.out`) |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `SIGBUS` | Bus error occurred (e.g., a misaligned memory address to access
    an `int` value) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| `SIGSTOP` | Suspend a process, move to Blocked state (e.g., CTRL-Z) |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| `SIGCONT` | Continue a blocked process (move it to the Ready state; e.g.,
    `bg` or `fg`) |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: 'When a process receives a signal, one of several default actions can occur:
    the process can terminate, the signal can be ignored, the process can be blocked,
    or the process can be unblocked.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The OS defines a default action and supplies the default signal handler code
    for every signal number. Application programmers, however, can change the default
    action of most signals and can write their own signal handler code. If an application
    program doesn’t register its own signal handler function for a particular signal,
    then the OS’s default handler executes when the process receives a signal. For
    some signals, the OS-defined default action cannot be overridden by application
    signal handler code. For example, if a process receives a `SIGKILL` signal, the
    OS will always force the process to exit, and receiving a `SIGSTOP` signal will
    always block the process until it receives a signal to continue (`SIGCONT`) or
    to exit (`SIGKILL`).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux supports two different system calls that can be used to change the default
    behavior of a signal or to register a signal handler on a particular signal: `sigaction`
    and `signal`. Because `sigaction` is POSIX compliant and more featureful, it should
    be used in production software. However, we use `signal` in our example code because
    it is easier to understand.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example program^([3](ch13.xhtml#fn13_3)) that registers signal
    handlers for `SIGALRM`, `SIGINT`, and `SIGCONT` signals using the `signal` system
    call (error handling is removed for readability):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When run, the process receives a `SIGALRM` every 5 seconds (due to the call
    to `alarm` in `main` and `sigalarm_handler`). The `SIGINT` and `SIGCONT` signals
    can be triggered by running the `kill` or `pkill` commands in another shell. For
    example, if the process’s PID is 1234 and its executable is `a.out`, then the
    following shell command sends the process `SIGINT` and `SIGCONT` signals, triggering
    their signal handler functions to run:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Writing a SIGCHLD handler
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Recall that when a process terminates, the OS delivers a `SIGCHLD` signal to
    its parent process. In programs that create child processes, the parent process
    does not always want to block on a call to `wait` until its child processes exit.
    For example, when a shell program runs a command in the background, it continues
    to run concurrently with its child process, handling other shell commands in the
    foreground as the child process runs in the background. A parent process, however,
    needs to call `wait` to reap its zombie child processes after they exit. If not,
    the zombie processes will never die and will continue to hold on to some system
    resources. In these cases, the parent process can register a signal handler on
    `SIGCHLD` signals. When the parent receives a `SIGCHLD` from an exited child process,
    its handler code runs and makes calls to `wait` to reap its zombie children.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a code snippet showing the implementation of a signal handler
    function for `SIGCHLD` signals. This snippet also shows parts of a `main` function
    that register the signal handler function for the `SIGCHLD` signal (note that
    this should be done before any calls to `fork`):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example passes –1 as the PID to `waitpid`, which means “reap any zombie
    child process.” It also passes the `WNOHANG` flag, which means that the call to
    `waitpid` does not block if there are no zombie child processes to reap. Also
    note that `waitpid` is called inside a `while` loop that continues as long as
    it returns a valid PID value (as long as it reaps a zombie child process). It
    is important that the signal handler function calls `waitpid` in a loop because
    as it is running, the process could receive additional `SIGCHLD` signals from
    other exited child process. The OS doesn’t keep track of the number of `SIGCHLD`
    signals a process receives, it just notes that the process received a `SIGCHLD`
    and interrupts its execution to run the handler code. As a result, without the
    loop, the signal handler could miss reaping some zombie children.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The signal handler executes whenever the parent receives a `SIGCHLD` signal,
    regardless of whether the parent is blocked on a call to `wait` or `waitpid`.
    If the parent is blocked on a call to `wait` when it receives a `SIGCHLD`, it
    wakes up and runs the signal handler code to reap one or more of its zombie children.
    It then continues execution at the point in the program after the call to `wait`
    (it just reaped an exited child process). If, however, the parent is blocked on
    a call to `waitpid` for a specific child, then the parent may or may not continue
    to block after its signal handler code runs to reap an exited child. The parent
    process continues execution after its call to `waitpid` if the signal handler
    code reaped the child for which it was waiting. Otherwise, the parent continues
    to block on the call to `waitpid` to wait for the specified child to exit. A call
    to `waitpid` with a PID of a nonexistent child process (perhaps one that was previously
    reaped in the signal handler loop) does not block the caller.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.2 Message Passing
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One way in which processes with private virtual address spaces can communicate
    is through *message passing*—by sending and receiving messages to one another.
    Message passing allows programs to exchange arbitrary data rather than just a
    small set of predefined messages like those supported by signals. And operating
    systems typically implement a few different types of message passing abstractions
    that processes can use to communicate.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'The message passing interprocess communication model consists of three parts:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Processes allocate some type of message channel from the OS. Example message
    channel types include *pipes* for one-way communication, and *sockets* for two-way
    communication. There may be additional connection setup steps that processes need
    to take to configure the message channel.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Processes use the message channel to send and receive messages to one another.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Processes close their end of the message channel when they are done using
    it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: A *pipe* is a one-way communication channel for two processes running on the
    same machine. One-way means that one end of the pipe is for sending messages (or
    writing to) only, and the other end of the pipe is for receiving messages (or
    for reading from) only. Pipes are commonly used in shell commands to send the
    output from one process to the input of another process.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following command entered at a bash shell prompt
    that creates a pipe between two processes (the `cat` process outputs the contents
    of file `foo.c` and the pipe (`|`) redirects that output to the input of the `grep`
    command that searches for the string “factorial” in its input):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To execute this command, the bash shell process calls the `pipe` system call
    to request that the OS creates a pipe communication. The pipe will be used by
    the shell’s two child processes (`cat` and `grep`). The shell program sets up
    the `cat` process’s `stdout` to write to the write end of the pipe and the `grep`
    process’s `stdin` to read from the read end of the pipe, so that when the child
    processes are created and run, the `cat` process’s output will be sent as input
    to the `grep` process (see [Figure 13-26](ch13.xhtml#ch13fig26)).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/13fig26.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-26: Pipes are unidirectional communication channels for processes
    on the same system. In this example, the `cat` process sends the `grep` process
    information by writing to the write end of the pipe. The `grep` process receives
    this information by reading from the read end of the pipe.*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: While pipes transmit data from one process to another in only one direction,
    other message passing abstractions allow processes to communicate in both directions.
    A *socket* is a two-way communication channel, which means that each end of a
    socket can be used for both sending and receiving messages. Sockets can be used
    by communicating processes running on the same computer or running on different
    computers connected by a network (see [Figure 13-27](ch13.xhtml#ch13fig27)). The
    computers could be connected by a *local area network* (LAN), which connects computers
    in a small area, such as a network in a university computer science department.
    The communicating processes could also be on different LANs, connected to the
    internet. As long as there exists some path through network connections between
    the two machines, the processes can use sockets to communicate.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/13fig27.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-27: Sockets are bidirectional communication channels that can be
    used by communicating processes on different machines connected by a network.*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Because each individual computer is its own system (hardware and OS), and because
    the OS on one system does not know about or manage resources on the other system,
    message passing is the only way in which processes on different computers can
    communicate. To support this type of communication, operating systems need to
    implement a common message passing protocol for sending and receiving messages
    over a network. TCP/IP is one example of a messaging protocol that can be used
    to send messages over the internet. When a process wants to send a message to
    another, it makes a `send` system call, passing the OS a socket on which it wants
    to transmit, the message buffer and possibly additional information about the
    message or its intended recipient. The OS takes care of packing up the message
    in the message buffer and sending it out over the network to the other machine.
    When an OS receives a message from the network, it unpacks the message and delivers
    it to the process on its system that has requested to receive the message. This
    process may be in a Blocked state waiting for the message to arrive. In this case,
    receipt of the message makes the process Ready to run again.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: There are many system software abstractions built on top of message passing
    that hide the message passing details from the programmer. However, any communication
    between processes on different computers must use message passing at the lowest
    levels (communicating through shared memory or signals is not an option for processes
    running on different systems). In [Chapter 15](ch15.xhtml#ch15), we discuss message
    passing and the abstractions built atop it in more detail.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.3 Shared Memory
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Message passing using sockets is useful for bidirectional communication between
    processes running on the same machine and between processes running on different
    machines. However, when two processes are running on the same machine, they can
    take advantage of shared system resources to communicate more efficiently than
    by using message passing.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: For example, an operating system can support interprocess communication by allowing
    processes to share all or part of their virtual address spaces. One process can
    read and write values to the shared portion of its address space to communicate
    with other processes sharing the same memory region.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: One way that the OS can implement partial address space sharing is by setting
    entries in the page tables of two or more processes to map to the same physical
    frames. [Figure 13-28](ch13.xhtml#ch13fig28) illustrates an example mapping. To
    communicate, one process writes a value to an address on a shared page, and another
    process subsequently reads the value.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/13fig28.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-28: The OS can support sharing pages of virtual address space by
    setting entries in the page tables of sharing processes to the same physical frame
    number (e.g., frame 100). Note that processes do not need to use the same virtual
    address to refer to the shared page of physical memory.*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: If the OS supports partial shared memory, then it implements an interface to
    the programmer for creating and attaching to shared pages (or shared regions/segments)
    of memory. In Unix systems, the system call `shmget` creates or attaches to a
    shared memory segment. Each shared memory segment corresponds to a contiguous
    set of virtual addresses whose physical mappings are shared with other processes
    attaching to the same shared memory segment.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems also typically support sharing a single, full virtual address
    space. A *thread* is the OS abstraction of an execution control flow. A process
    has a single thread of execution control flow in a single virtual address space.
    A multithreaded process has multiple concurrent threads of execution control flow
    in a single, shared virtual address space—all threads share the full virtual address
    space of their containing process.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Threads can easily share execution state by reading and writing to shared locations
    in their common address space. For example, if one thread changes the value of
    a global variable, all other threads see the result of that change.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: On a multiprocessor systems (SMP or multicore), individual threads of a multithreaded
    process can be scheduled to run simultaneously, *in parallel*, on the multiple
    cores. In [Chapter 14](ch14.xhtml#ch14), we discuss threads and parallel multithreaded
    programming in more detail.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Summary and Other OS Functionality
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we examined what an operating system is, how it works, and
    the role it plays in running application programs on the computer. As the system
    software layer between the computer hardware and application programs, the OS
    efficiently manages the computer hardware and implements abstractions that make
    the computer easier to use. Operating systems implement two abstractions, processes
    and virtual memory, to support multiprogramming (allowing more than one program
    running on the computer system at a time). The OS keeps track of all the processes
    in the system and their state, and it implements context switching of processes
    running on the CPU cores. The OS also provides a way for processes to create new
    processes, to exit, and to communicate with one another. Through virtual memory,
    the OS implements the abstraction of a private virtual memory space for each process.
    The virtual memory abstraction protects processes from seeing the effects of other
    processes sharing the computer’s physical memory space. Paging is one implementation
    of virtual memory that maps individual pages of each process’s virtual address
    space to frames of physical RAM space. Virtual memory is also a way in which the
    OS makes more efficient use of RAM; by treating RAM as a cache for disk, it allows
    pages of virtual memory space to be stored in RAM or on disk.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Our focus in this chapter on the operating system’s role in running a program,
    including the abstractions and mechanisms it implements to efficiently run programs,
    is in no way complete. There are many other implementation options and details
    and policy issues related to processes and process management, and to virtual
    memory and memory management. Additionally, operating systems implement many other
    important abstractions, functionality, and policies for managing and using the
    computer. For example, the OS implements filesystem abstractions for accessing
    stored data, protection mechanisms and security policies to protect users and
    the system, and scheduling policies for different OS and hardware resources.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Modern operating systems also implement support for interprocess communication,
    networking, and parallel and distributed computing. In addition, most operating
    systems include *hypervisor* support, which virtualizes the system hardware and
    allows the host OS to run multiple virtual guest operating systems. Virtualization
    supports the host OS that manages the computer hardware in booting and running
    multiple other operating systems on top of itself, each with its own private virtualized
    view of the underlying hardware. The host operating system’s hypervisor support
    manages the virtualization, including protection and sharing of the underlying
    physical resources among the guest operating systems.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, most operating systems provide some degree of extensibility by which
    a user (often a system administrator) can tune the OS. For example, most Unix-like
    systems allow users (usually requiring root, or superuser, privileges) to change
    sizes of OS buffers, caches, swap partitions, and to select from a set of different
    scheduling policies in OS subsystems and hardware devices. Through these modifications,
    a user can tune the system for the type of application workloads they run. These
    types of operating systems often support *loadable kernel modules*, which are
    executable code that can be loaded into the kernel and run in kernel mode. Loadable
    kernel modules are often used to add additional abstractions or functionality
    into the kernel as well as for loading device driver code into the kernel that
    is used to handle managing a particular hardware device. For more breadth and
    depth of coverage of operating systems, we recommend reading an operating systems
    textbook, such as *Operating Systems: Three Easy Pieces*.^([4](ch13.xhtml#fn13_4))'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch13.xhtml#rfn13_1) Meltdown and Spectre. *[https://meltdownattack.com/](https://meltdownattack.com/)*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch13.xhtml#rfn13_2) Available at *[https://diveintosystems.org/book/C13-OS/_attachments/fork.c](https://diveintosystems.org/book/C13-OS/_attachments/fork.c)*.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch13.xhtml#rfn13_3) Available at *[https://diveintosystems.org/book/C13-OS/_attachments/signals.c](https://diveintosystems.org/book/C13-OS/_attachments/signals.c)*.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch13.xhtml#rfn13_4) Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau,
    *Operating Systems: Three Easy Pieces*, Arpaci-Dusseau Books, 2018.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
