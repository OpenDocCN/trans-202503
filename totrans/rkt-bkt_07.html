<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_57"/><strong><span class="big">5</span><br/>OPERATING SYSTEM BOOT PROCESS ESSENTIALS</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">This chapter introduces you to the most important bootkit-related aspects of the Microsoft Windows boot process. Because the goal of the bootkit is to hide on a target system at a very low level, it needs to tamper with the OS boot components. So, before we can dive into how bootkits are built and how they behave, you’ll need to understand how the boot process works.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The information in this chapter applies to Microsoft Windows Vista and later versions; the boot process for earlier versions of Windows differs, as explained in</em> “<a href="ch05.xhtml#ch05lev2sec4"><em>The</em> bootmgr <em>Module and Boot Configuration Data</em></a>” <em>on <a href="ch05.xhtml#page_64">page 64</a>.</em></p>
</div>
<p class="indent">The boot process is one of the most important yet least understood phases of operating system operation. Although the general concept is universally familiar, few programmers—including systems programmers—understand it in detail, and most lack the tools to do so. This makes the <span epub:type="pagebreak" id="page_58"/>boot process fertile ground for attackers to leverage the knowledge they’ve gleaned from reverse engineering and experimentation, while programmers must often rely on documentation that’s incomplete or outdated.</p>
<p class="indent">From a security point of view, the boot process is responsible for starting the system and bringing it to a trustworthy state. The logical facilities that defensive code uses to check the state of a system are also created during this process, so the earlier an attacker manages to compromise a system, the easier it is to hide from a defender’s checks.</p>
<p class="indent">In this chapter, we review the basics of the boot process in Windows systems running on machines with legacy firmware. The boot process for machines running UEFI firmware, introduced in Windows 7 x64 SP1, is significantly different from legacy-based machines, so we’ll discuss that process separately in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>
<p class="indent">Throughout this chapter, we approach the boot process from the attacker’s point of view. Although nothing prevents attackers from targeting a specific chipset or peripheral—and indeed some do—these kinds of attacks do not scale well and are hard to develop reliably. It’s in the attacker’s best interest, therefore, to target interfaces that are relatively generic, yet not so generic that defensive programmers could easily understand and analyze the attacks.</p>
<p class="indent">As always, offensive research pushes the envelope, digging deeper into the system as advances become public and transparent. The organization of this chapter underscores this point: we’ll begin with a general overview but progress to undocumented (at the time of this writing) data structures and a logic flow that can be gleaned only from disassembling the system—exactly the route that both bootkit researchers and malware creators follow.</p>
<h3 class="h3" id="ch05lev1sec1"><strong>High-Level Overview of the Windows Boot Process</strong></h3>
<p class="noindent"><a href="ch05.xhtml#ch05fig01">Figure 5-1</a> shows the general flow of the modern boot process. Almost any part of the process can be attacked by a bootkit, but the most common targets are the Basic Input/Output System (BIOS) initialization, the Master Boot Record (MBR), and the operating system bootloader.</p>
<div class="image"><a id="ch05fig01"/><img src="../images/05fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 5-1: The flow of the system boot process</em></p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_59"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Secure Boot technology, which we’ll discuss in <a href="ch17.xhtml#ch17">Chapter 17</a>, aims to protect the modern boot process, including its complex and versatile UEFI parts.</em></p>
</div>
<p class="indent">As the boot process progresses, the execution environment becomes more complex, offering the defender richer and more familiar programming models. However, it’s the lower-level code that creates and supports these abstracted models, so by targeting that code, attackers can manipulate the models to intercept the flow of the boot process and interfere with the higher-level system state. In this way, more abstract and powerful models can be crippled, which is exactly the point of a bootkit.</p>
<h3 class="h3" id="ch05lev1sec2"><strong>The Legacy Boot Process</strong></h3>
<p class="noindent">To understand a technology, it is helpful to review its previous iterations. Here’s a basic summary of the boot process as it was normally executed in the heyday of boot sector viruses (1980s–2000s), such as Brain (discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>):</p>
<ol>
<li class="noindent">Power on (a cold boot)</li>
<li class="noindent">Power supply self-test</li>
<li class="noindent">ROM BIOS execution</li>
<li class="noindent">ROM BIOS test of hardware</li>
<li class="noindent">Video test</li>
<li class="noindent">Memory test</li>
<li class="noindent">Power-On Self-Test (POST), a full hardware check (this step can be skipped when the boot process is a <em>warm</em> or <em>soft boot</em>—that is, a boot from a state that isn’t completely off)</li>
<li class="noindent">Test for the MBR at the first sector of the default boot drive, as specified in the BIOS setup</li>
<li class="noindent">MBR execution</li>
<li class="noindent">Operating system file initialization</li>
<li class="noindent">Base device driver initializations</li>
<li class="noindent">Device status check</li>
<li class="noindent">Configuration file reading</li>
<li class="noindent">Command shell loading</li>
<li class="noindent">Shell’s startup command file execution</li>
</ol>
<p class="indent">Notice that the early boot process begins by testing and initializing the hardware. This is often still the case, though many hardware and firmware technologies have moved on since Brain and its immediate successors. The boot processes described later in this book differ from earlier iterations in terminology and complexity, but the overall principles are similar.</p>
<h3 class="h3" id="ch05lev1sec3"><span epub:type="pagebreak" id="page_60"/><strong>The Windows Boot Process</strong></h3>
<p class="noindent"><a href="ch05.xhtml#ch05fig02">Figure 5-2</a> shows a high-level picture of the Windows boot process and the components involved, applicable to Windows versions Vista and higher. Each block in the figure represents modules that are executed and given control during the boot process, in order from top to bottom. As you can see, it’s quite similar to the iterations of the legacy boot process. However, as the components of modern Windows operating systems have increased in complexity, so too have the modules involved in the boot process.</p>
<div class="image"><a id="ch05fig02"/><img src="../images/05fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 5-2: A high-level view of the Windows boot process</em></p>
<p class="indent">Over the next few sections, we’ll refer to this figure as we walk through this boot process in more detail. As <a href="ch05.xhtml#ch05fig02">Figure 5-2</a> shows, when a computer is first powered on, the BIOS boot code receives control. This is the start of the boot process as the software sees it; other logic is involved at the hardware/firmware level (for example, during chipset initialization) but is not visible to software during the boot process.</p>
<h4 class="h4" id="ch05lev2sec1"><strong><em>BIOS and the Preboot Environment</em></strong></h4>
<p class="noindent">The BIOS performs basic system initialization and a POST to ensure that the critical system hardware is working properly. The BIOS also provides a specialized environment that includes the basic services needed to communicate with system devices. This simplified I/O interface first becomes available in the preboot environment, and is later replaced by different operating system abstractions for the majority of Windows uses. The most interesting of these services in terms of bootkit analysis is the <em>disk service</em>, which exposes a number of entry points used to perform disk I/O operations. The disk service is accessible through a special handler known as the <em>interrupt 13h handler</em>, or simply INT 13h. Bootkits will often target the disk service by tampering with its INT 13h; they do this in an effort to disable or circumvent OS protections by modifying operating system and boot components that are read from the hard drive during system startup.</p>
<p class="indent">Next, the BIOS looks for the bootable disk drive, which hosts the instance of the operating system to be loaded. This may be a hard drive, a USB drive, or a CD drive. Once the bootable device has been identified, the BIOS boot code loads the MBR, as <a href="ch05.xhtml#ch05fig02">Figure 5-2</a> shows.</p>
<h4 class="h4" id="ch05lev2sec2"><strong><em>The Master Boot Record</em></strong></h4>
<p class="noindent">The MBR is a data structure containing information on hard drive partitions and the boot code. Its main task is to determine the active partition <span epub:type="pagebreak" id="page_61"/>of the bootable hard drive, which contains the instance of the OS to load. Once it has identified the active partition, the MBR reads and executes its boot code. <a href="ch05.xhtml#ch05list01">Listing 5-1</a> shows the structure of the MBR.</p>
<p class="programs">typedef struct _MASTER_BOOT_RECORD{<br/>
<span class="ent">➊</span> BYTE bootCode[0x1BE];  // space to hold actual boot code<br/>
<span class="ent">➋</span> MBR_PARTITION_TABLE_ENTRY partitionTable[4];<br/>
  USHORT mbrSignature;  // set to 0xAA55 to indicate PC MBR format<br/>
} MASTER_BOOT_RECORD, *PMASTER_BOOT_RECORD;</p>
<p class="listing" id="ch05list01"><em>Listing 5-1: The structure of the MBR</em></p>
<p class="indent">As you can see, the MBR boot code <span class="ent">➊</span> is restricted to just 446 bytes (0x1BE in hexadecimal, a familiar value to reverse engineers of boot code), so it can implement only basic functionality. Next, the MBR parses the partition table, shown at <span class="ent">➋</span>, in order to locate the active partition; reads the Volume Boot Record (VBR) in its first sector; and transfers control to it.</p>
<h5 class="h5" id="ch05lev3sec1"><strong>Partition Table</strong></h5>
<p class="noindent">The partition table in the MBR is an array of four elements, each of which is described by the <span class="literal">MBR_PARTITION_TABLE_ENTRY</span> structure shown in <a href="ch05.xhtml#ch05list02">Listing 5-2</a>.</p>
<p class="programs">typedef struct _MBR_PARTITION_TABLE_ENTRY {<br/>
<span class="ent">➊</span> BYTE status;            // active?  0=no, 128=yes<br/>
   BYTE chsFirst[3];       // starting sector number<br/>
<span class="ent">➋</span> BYTE type;              // OS type indicator code<br/>
   BYTE chsLast[3];        // ending sector number<br/>
<span class="ent">➌</span> DWORD lbaStart;         // first sector relative to start of disk<br/>
   DWORD size;             // number of sectors in partition<br/>
} MBR_PARTITION_TABLE_ENTRY, *PMBR_PARTITION_TABLE_ENTRY;</p>
<p class="listing" id="ch05list02"><em>Listing 5-2: The structure of the partition table entry</em></p>
<p class="indent">The first byte <span class="ent">➊</span> of the <span class="literal">MBR_PARTITION_TABLE_ENTRY</span>, the <span class="literal">status</span> field, signifies whether the partition is active. Only one partition at any time may be marked as active, a status indicated with a value of 128 (0x80 in hexadecimal).</p>
<p class="indent">The <span class="literal">type</span> field <span class="ent">➋</span> lists the partition type. The most common types are:</p>
<ul>
<li class="noindent">EXTENDED MBR partition type</li>
<li class="noindent">FAT12 filesystem</li>
<li class="noindent">FAT16 filesystem</li>
<li class="noindent">FAT32 filesystem</li>
<li class="noindent">IFS (Installable File System used for the installation process)</li>
<li class="noindent">LDM (Logical Disk Manager for Microsoft Windows NT)</li>
<li class="noindent">NTFS (the primary Windows filesystem)</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_62"/>A type of <span class="literal">0</span> means <em>unused</em>. The fields <span class="literal">lbaStart</span> and <span class="literal">size</span> <span class="ent">➌</span> define the location of the partition on disk, expressed in sectors. The <span class="literal">lbaStart</span> field contains the offset of the partition from the beginning of the hard drive, and the <span class="literal">size</span> field contains the size of the partition.</p>
<h5 class="h5" id="ch05lev3sec2"><strong>Microsoft Windows Drive Layout</strong></h5>
<p class="noindent"><a href="ch05.xhtml#ch05fig03">Figure 5-3</a> shows the typical bootable hard drive layout of a Microsoft Windows system with two partitions.</p>
<p class="indent">The Bootmgr partition contains the <em>bootmgr</em> module and some other OS boot components, while the OS partition contains a volume that hosts the OS and user data. The <em>bootmgr</em> module’s main purpose is to determine which particular instance of the OS to load. If multiple operating systems are installed on the computer, <em>bootmgr</em> displays a dialog prompting the user to choose one. The <em>bootmgr</em> module also provides parameters that determine how the OS is loaded (whether it should be in safe mode, using the last-known good configuration, with driver signature enforcement disabled, and so on).</p>
<div class="image"><a id="ch05fig03"/><img src="../images/05fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 5-3: The typical bootable hard drive layout</em></p>
<h4 class="h4" id="ch05lev2sec3"><strong><em>The Volume Boot Record and Initial Program Loader</em></strong></h4>
<p class="noindent">The hard drive may contain several partitions hosting multiple instances of different operating systems, but only one partition should normally be marked as active. The MBR does not contain the code to parse the particular filesystem used on the active partition, so it reads and executes the first sector of the partition, the VBR, shown in the third layer of <a href="ch05.xhtml#ch05fig02">Figure 5-2</a>.</p>
<p class="indent">The VBR contains partition layout information, which specifies the type of filesystem in use and its parameters, and code that reads the Initial Program Loader (IPL) module from the active partition. The IPL module implements filesystem-parsing functionality in order to be able to read files from the partition’s filesystem.</p>
<p class="indent"><a href="ch05.xhtml#ch05list03">Listing 5-3</a> shows the layout of the VBR, which is composed of <span class="literal">BIOS_PARAMETER_BLOCK_NTFS</span> and <span class="literal">BOOTSTRAP_CODE</span> structures. The layout of the <span class="literal">BIOS_PARAMETER_BLOCK</span> (BPB) structure is specific to the volume’s filesystem. The <span class="literal">BIOS_PARAMETER_BLOCK_NTFS</span> and <span class="literal">VOLUME_BOOT_RECORD</span> structures correspond to the NTFS volume.</p>
<p class="programs">typedef struct _BIOS_PARAMETER_BLOCK_NTFS {<br/>
   WORD SectorSize;<br/>
   BYTE SectorsPerCluster;<br/>
<span epub:type="pagebreak" id="page_63"/>   WORD ReservedSectors;<br/>
   BYTE Reserved[5];<br/>
   BYTE MediaId;<br/>
   BYTE Reserved2[2];<br/>
   WORD SectorsPerTrack;<br/>
   WORD NumberOfHeads;<br/>
<span class="ent">➊</span> DWORD HiddenSectors;<br/>
   BYTE Reserved3[8];<br/>
   QWORD NumberOfSectors;<br/>
   QWORD MFTStartingCluster;<br/>
   QWORD MFTMirrorStartingCluster;<br/>
   BYTE ClusterPerFileRecord;<br/>
   BYTE Reserved4[3];<br/>
   BYTE ClusterPerIndexBuffer;<br/>
   BYTE Reserved5[3];<br/>
   QWORD NTFSSerial;<br/>
   BYTE Reserved6[4];<br/>
} BIOS_PARAMETER_BLOCK_NTFS, *PBIOS_PARAMETER_BLOCK_NTFS;<br/>
typedef struct _BOOTSTRAP_CODE{<br/>
    BYTE    bootCode[420];                // boot sector machine code<br/>
    WORD    bootSectorSignature;          // 0x55AA<br/>
} BOOTSTRAP_CODE, *PBOOTSTRAP_CODE;<br/>
typedef struct _VOLUME_BOOT_RECORD{<br/>
  <span class="ent">➋</span> WORD    jmp;<br/>
    BYTE    nop;<br/>
    DWORD   OEM_Name<br/>
    DWORD   OEM_ID; // NTFS<br/>
    BIOS_PARAMETER_BLOCK_NTFS BPB;<br/>
    BOOTSTRAP_CODE BootStrap;<br/>
} VOLUME_BOOT_RECORD, *PVOLUME_BOOT_RECORD;</p>
<p class="listing" id="ch05list03"><em>Listing 5-3: VBR layout</em></p>
<p class="indent">Notice that the VBR starts with a <span class="literal">jmp</span> instruction <span class="ent">➋</span>, which transfers control of the system to the VBR code. The VBR code in turn reads and executes the IPL from the partition, the location of which is specified by the <span class="literal">HiddenSectors</span> field <span class="ent">➊</span>. The IPL reports its offset (in sectors) from the beginning of the hard drive. The layout of the VBR is summarized in <a href="ch05.xhtml#ch05fig04">Figure 5-4</a>.</p>
<div class="image"><a id="ch05fig04"/><img src="../images/05fig04.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 5-4: The structure of the VBR</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_64"/>As you can see, the VBR essentially consists of the following components:</p>
<ul>
<li class="noindent">The VBR code responsible for loading the IPL</li>
<li class="noindent">The BIOS parameter block (a data structure that stores the volume parameters)</li>
<li class="noindent">Text strings displayed to a user if an error occurs</li>
<li class="noindent">0xAA55, a 2-byte signature of the VBR</li>
</ul>
<p class="indent">The IPL usually occupies 15 consecutive sectors of 512 bytes each and is located right after the VBR. It implements just enough code to parse the partition’s filesystem and continue loading the <em>bootmgr</em> module. The IPL and VBR are used together because the VBR can occupy only one sector and cannot implement sufficient functionality to parse the volume’s filesystem with so little space available to it.</p>
<h4 class="h4" id="ch05lev2sec4"><strong><em>The bootmgr Module and Boot Configuration Data</em></strong></h4>
<p class="noindent">The IPL reads and loads the OS boot manager’s <em>bootmgr</em> module from the filesystem, shown in the fourth layer of <a href="ch05.xhtml#ch05fig02">Figure 5-2</a>. Once the IPL runs, <em>bootmgr</em> takes over the boot process.</p>
<p class="indent">The <em>bootmgr</em> module reads from the Boot Configuration Data (BCD), which contains several important system parameters, including those that affect security policies such as the Kernel-Mode Code Signing Policy, covered in <a href="ch06.xhtml#ch06">Chapter 6</a>. Bootkits often attempt to bypass <em>bootmgr</em>’s implementation of code integrity verification.</p>
<div class="sidebar">
<p class="sidebart"><strong>ORIGINS OF THE BOOTMGR MODULE</strong></p>
<p class="spara">The <em>bootmgr</em> module was introduced in Windows Vista to replace the <span class="literal">ntldr</span> bootloader found in previous NT-derived versions of Windows. Microsoft’s idea was to create an additional layer of abstraction in the boot chain in order to isolate the preboot environment from the OS kernel layer. Isolation of the boot modules from the OS kernel brought improvements in boot management and security to Windows, making it easier to enforce security policies imposed on the kernel-mode modules (such as the Kernel-Mode Code Signing Policy). The legacy <span class="literal">ntldr</span> was split into two modules: <em>bootmgr</em> and <em>winload.exe</em> (or <em>winresume.exe</em> if the OS is loaded from the hibernation). Each module implements distinct functionality.</p>
</div>
<p class="indent">The <em>bootmgr</em> module manages the boot process until the user chooses a boot option (as shown in <a href="ch05.xhtml#ch05fig05">Figure 5-5</a> for Windows 10). The program <em>winload.exe</em> (or <em>winresume.exe</em>) loads the kernel, boot-start drivers, and some system registry data once the user makes a choice.</p>
<div class="image"><span epub:type="pagebreak" id="page_65"/><a id="ch05fig05"/><img src="../images/05fig05.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 5-5: The</em> bootmgr <em>boot menu in Windows 10</em></p>
<h5 class="h5" id="ch05lev3sec3"><strong>Real Mode vs. Protected Mode</strong></h5>
<p class="noindent">When a computer is first powered on, the CPU operates in <em>real mode</em>, a legacy execution mode that uses a 16-bit memory model in which each byte in RAM is addressed by a pointer consisting of two words (2 bytes): <em>segment_start</em>:<em>segment_offset</em>. This mode corresponds to the <em>segment memory model</em>, where the address space is divided into segments. The address of every target byte is described by the address of the segment and the offset of the target byte within the segment. Here, <em>segment_start</em> specifies the target segment, and <em>segment_offset</em> is the offset of the referenced byte in the target segment.</p>
<p class="indent">The real-mode addressing scheme allows the use of only a small amount of the available system RAM. Specifically, the real (physical) address in the memory is computed as the largest address, represented as ffff:ffff, which is only 1,114,095 bytes (65,535 × 16 + 65,535), meaning the address space in real mode is limited to around 1 MB—obviously not sufficient for modern operating systems and applications. To circumvent this limitation and get access to all available memory, <em>bootmgr</em> and <em>winload.exe</em> switch the processor into <em>protected mode</em> (called <em>long mode</em> on 64-bit systems) once <em>bootmgr</em> takes over.</p>
<p class="indent">The <em>bootmgr</em> module consists of 16-bit real-mode code and a compressed PE image, which, when uncompressed, is executed in protected mode. The 16-bit code extracts and uncompresses the PE from the <em>bootmgr</em> image, switches the processor into protected mode, and passes control to the uncompressed module.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_66"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Bootkits must properly handle the processor execution mode switch in order to maintain control of the boot code execution. After the switch, the whole memory layout is changed, and parts of the code previously located at one contiguous set of memory addresses may be moved to different memory segments. Bootkits must implement rather sophisticated functionality to get around this and keep control of the boot process.</em></p>
</div>
<h5 class="h5" id="ch05lev3sec4"><strong>BCD Boot Variables</strong></h5>
<p class="noindent">Once the <em>bootmgr</em> initializes protected mode, the uncompressed image receives control and loads boot configuration information from the BCD. When stored on the hard drive, the BCD has the same layout as a registry hive. (To browse its contents, use <span class="literal">regedit</span> and navigate to the key <em>HKEY_LOCAL_MACHINE\BCD000000</em>.)</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>To read from the hard drive,</em> bootmgr, <em>operating in protected mode, uses the INT 13h disk service, which is intended to be run in real mode. To do so,</em> bootmgr <em>saves the execution context of the processor in temporary variables, temporarily switches to real mode, executes the INT 13h handler, and then returns to protected mode, restoring the saved context.</em></p>
</div>
<p class="indent">The BCD store contains all the information <em>bootmgr</em> needs in order to load the OS, including the path to the partition containing the OS instance to load, available boot applications, code integrity options, and parameters instructing the OS to load in preinstallation mode, safe mode, and so on.</p>
<p class="indent"><a href="ch05.xhtml#ch05tab01">Table 5-1</a> shows the parameters in the BCD of greatest interest to bootkit authors.</p>
<p class="tabcap" id="ch05tab01"><strong>Table 5-1:</strong> BCD Boot Variables</p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:30%"/>
<col style="width:20%"/>
<col style="width:20%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Variable name</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Parameter type</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Parameter ID</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">BcdLibraryBoolean_DisableIntegrityCheck</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Disables kernel-mode code integrity checks</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Boolean</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0x16000048</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">BcdOSLoaderBoolean_WinPEMode</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Tells the kernel to load in preinstallation mode, disabling kernel-mode code integrity checks as a byproduct</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Boolean</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">0x26000022</span></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">BcdLibraryBoolean_AllowPrereleaseSignatures</span></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Enables test signing (TESTSIGNING)</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">Boolean</span></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">0x1600004</span></p></td>
</tr>
</tbody>
</table>
<p class="indent">The variable <span class="literal">BcdLibraryBoolean_DisableIntegrityCheck</span> is used to disable integrity checks and allow the loading of unsigned kernel-mode drivers. This option is ignored in Windows 7 and higher and cannot be set if Secure Boot (discussed in <a href="ch17.xhtml#ch17">Chapter 17</a>) is enabled.</p>
<p class="indent"><span epub:type="pagebreak" id="page_67"/>The variable <span class="literal">BcdOSLoaderBoolean_WinPEMode</span> indicates that the system should be started in Windows Preinstallation Environment Mode, which is essentially a minimal Win32 operating system with limited services that is primarily used to prepare a computer for Windows installation. This mode also disables kernel integrity checks, including the Kernel-Mode Code Signing Policy mandatory on 64-bit systems.</p>
<p class="indent">The variable <span class="literal">BcdLibraryBoolean_AllowPrereleaseSignatures</span> uses test code-signing certificates to load kernel-mode drivers for testing purposes. These certificates can be generated through tools included in the Windows Driver Kit. (The <em>Necurs</em> rootkit uses this process to install a malicious kernel-mode driver onto a system, signed with a custom certificate.)</p>
<p class="indent">After retrieving boot options, the <em>bootmgr</em> performs self-integrity verification. If the check fails, the <em>bootmgr</em> stops booting the system and displays an error message. However, the <em>bootmgr</em> doesn’t perform the self-integrity check if either <span class="literal">BcdLibraryBoolean_DisableIntegrityCheck</span> or <span class="literal">BcdOSLoaderBoolean_WinPEMode</span> is set to <span class="literal">TRUE</span> in the BCD. Thus, if either variable is <span class="literal">TRUE</span>, the <em>bootmgr</em> won’t notice if it has been tampered with by malicious code.</p>
<p class="indent">Once all the necessary BCD parameters have been loaded and self-integrity verification has been passed, the <em>bootmgr</em> chooses the boot application to load. When loading the OS afresh from the hard drive, the <em>bootmgr</em> chooses <em>winload.exe</em>; when resuming from hibernation, the <em>bootmgr</em> chooses <em>winresume.exe</em>. These respective PE modules are responsible for loading and initializing OS kernel modules. The <em>bootmgr</em> checks the integrity of the boot application in the same way, again skipping verification if either <span class="literal">BcdLibraryBoolean_DisableIntegrityCheck</span> or <span class="literal">BcdOSLoaderBoolean_WinPEMode</span> is <span class="literal">TRUE</span>.</p>
<p class="indent">In the final step of the boot process, once the user has chosen a particular instance of the OS to load, the <em>bootmgr</em> loads <em>winload.exe</em>. Once all modules are properly initialized, <em>winload.exe</em> (layer 5 in <a href="ch05.xhtml#ch05fig02">Figure 5-2</a>) passes control to the OS kernel, which continues the boot process (layer 6). Like <em>bootmgr</em>, <em>winload.exe</em> checks the integrity of all modules it is responsible for. Many bootkits attempt to circumvent these checks in order to inject a malicious module into the operating system kernel-mode address space.</p>
<p class="indent">When <em>winload.exe</em> receives control of the operating system boot, it enables paging in protected mode and then loads the OS kernel image and its dependencies, including these modules:</p>
<p class="hangt"><strong><em>bootvid.dll</em></strong> A library for video VGA support at boot time</p>
<p class="hang"><strong><em>ci.dll</em></strong> The code integrity library</p>
<p class="hang"><strong><em>clfs.dll</em></strong> The common logging filesystem driver</p>
<p class="hang"><strong><em>hal.dll</em></strong> The hardware abstraction layer library</p>
<p class="hang"><strong><em>kdcom.dll</em></strong> The kernel debugger protocol communications library</p>
<p class="hangb"><strong><em>pshed.dll</em></strong> The platform-specific hardware error driver</p>
<p class="indent">In addition to these modules, <em>winload.exe</em> loads boot-start drivers, including storage device drivers, Early Launch Anti-Malware (ELAM) modules (explained in <a href="ch06.xhtml#ch06">Chapter 6</a>), and the system registry hive.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_68"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In order to read all the components from the hard drive,</em> winload.exe <em>uses the interface provided by</em> bootmgr. <em>This interface relies on the BIOS INT 13h disk service. Therefore, if the INT 13h handler is hooked by a bootkit, the malware can spoof all data read by</em> winload.exe.</p>
</div>
<p class="indent">When loading the executables, <em>winload.exe</em> verifies their integrity according to the system’s code integrity policy. Once all modules are loaded, <em>winload.exe</em> transfers control to the OS kernel image to initialize them, as discussed in the following chapters.</p>
<h3 class="h3" id="ch05lev1sec4"><strong>Conclusion</strong></h3>
<p class="noindent">In this chapter, you learned about the MBR and VBR in the early boot stages, as well as important boot components such as <em>bootmgr</em> and <em>winload.exe</em>, from the point of view of bootkit threats.</p>
<p class="indent">As you’ve seen, transferring control between the phases of the boot process is not as simple as jumping directly to the next stage. Instead, several components that are related through various data structures—such as the MBR partition table, the VBR BIOS parameter block, and the BCD—determine execution flow in the preboot environment. This nontrivial relationship is one reason why bootkits are so complex and why they make so many modifications to boot components in order to transfer control from the original boot code to their own (and occasionally back and forth, to carry out essential tasks).</p>
<p class="indent">In the next chapter, we look at boot process security, focusing on the ELAM and the Microsoft Kernel-Mode Code Signing Policy, which defeated the methods of early rootkits.</p>
</body></html>