<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="app01"><span epub:type="pagebreak" id="page_433"/><strong>GENETIC PROGRAMMING WITH FIREFLY</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In <a href="ch15.xhtml#ch15">Chapter 15</a>, we explored the Firefly language with fun animations and music. In this appendix, we’ll use Firefly along with <em>genetic programming</em> to evolve displays we can then animate.</p>&#13;
<h3 class="h3" id="lev1sec108"><strong>Introduction to Genetic Programming</strong></h3>&#13;
<p class="noindent">Genetic programming became widely known in the early 1990s. Genetic programming uses algorithms to create programs by mimicking biological evolution. Instead of manually writing the code to perform a task, genetic programming generates and runs a population of random programs to see how well they perform. Each program in the population is given a <em>fitness value</em>, often called an objective function value, which is used to decide which programs breed to create the next generation of programs. Breeding is accomplished via <em>crossover</em> between pairs of programs, which mixes the code of “parent” programs to produce a new “offspring” program. As in biological evolution, there is a small probability a program will undergo a random mutation. Random mutation drives evolution by inserting new “genes” into <span epub:type="pagebreak" id="page_434"/>the population. Biological evolution is driven by other processes, like genetic drift, but we’ll keep things simple and rely on crossover between well-performing individuals and random mutation.</p>&#13;
<h3 class="h3" id="lev1sec109"><strong>How Genetic Programming Works</strong></h3>&#13;
<p class="noindent">The general approach to genetic programming is as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Create a population of randomly generated programs.</li>&#13;
<li class="noindent">Run each program in the population and assign it a fitness value depending on how well it does at solving the desired task.</li>&#13;
<li class="noindent">Create the next generation of programs by breeding (crossover) and mutation.</li>&#13;
<li class="noindent">Repeat from Step 2 until we either have a program that solves our task to our satisfaction or we give up.</li>&#13;
</ol>&#13;
<p class="indent">For us, the programs are Firefly code for generating LED displays. We’ll specify the display we’d like and let genetic programming evolve a program that creates that display (we hope!).</p>&#13;
<p class="indent">Typically, using genetic programming is somewhat tricky because generating random computer code that actually runs is difficult. Likewise, mixing two programs to produce a new one is challenging due to syntax issues. However, we are fortunate, as Firefly is extremely simple. <em>Any</em> string of characters extracted from the allowed set of Firefly commands is a valid Firefly program, and will thus run without error.</p>&#13;
<p class="indent">Also, as we are seeking code to generate a particular display, we only need to consider Firefly instructions that manipulate the LEDs. Thus, we can dispense with double buffering, music, and random trails, as they are not reproducible. We only need instructions to move the firefly and set the mode.</p>&#13;
<p class="indent">We are doing genetic programming, but we’ll implement the evolution portion via a <em>genetic algorithm</em>, or <em>GA</em>. A genetic algorithm is more general than genetic programming, but for our Firefly code, the GA works perfectly to implement genetic programming. We won’t dive into how the genetic algorithm code works. Rather, we’ll just use the algorithm and see its effects. However, GA isn’t all that complicated, so if you read through the code, you’ll see what it’s doing.</p>&#13;
<p class="indent">Therefore, to experiment with genetic programming and Firefly, we need the following pieces:</p>&#13;
<ol>&#13;
<li class="noindent">Some way to define the display we want to create.</li>&#13;
<li class="noindent">A stripped-down version of the Firefly interpreter that only processes move and mode commands.</li>&#13;
<li class="noindent">GA code to evolve a population of Firefly programs.</li>&#13;
<li class="noindent">Something to package the pieces together, run the search, and output the resulting code.</li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_435"/>Let’s build what we need, piece by piece. If you want to jump into the Python code now, read through <em>fly_swarm.py</em> in the <em>firefly/GP</em> directory. Note that the population evolved by genetic programming is sometimes referred to as a <em>swarm</em>, even though swarm is most often used in relation to <em>swarm intelligence</em> algorithms. We’ll use “population” and “swarm” interchangeably.</p>&#13;
<h3 class="h3" id="lev1sec110"><strong>Defining Displays</strong></h3>&#13;
<p class="noindent">The most straightforward part of this exercise is defining the display we want to generate. Firefly’s display is a 5×5 grid of LED intensities. Therefore, we’ll define target displays using a 5×5 array of numbers stored in a text file. For example, to specify a “ball” located in the upper-left corner of the display, create a text file containing</p>&#13;
<pre>5 5 0 0 0&#13;
5 5 0 0 0&#13;
0 0 0 0 0&#13;
0 0 0 0 0&#13;
0 0 0 0 0</pre>&#13;
<p class="noindent">This puts a medium intensity (square) “ball” in the upper-left corner with all other LEDs off. The text file stores the intensities of the 5×5 array for the genetic programming code to use as a target. The more similar the display generated by a candidate program is to the target, the better.</p>&#13;
<h3 class="h3" id="lev1sec111"><strong>A Tiny Firefly Interpreter</strong></h3>&#13;
<p class="noindent">We need a tiny interpreter supporting only the Firefly move and mode commands to run our programs. We’ll make this interpreter a Python class so we can instantiate it easily. The result is <a href="app01.xhtml#ch0Alist1">Listing A-1</a>.</p>&#13;
<pre>class Firefly:&#13;
    def Move(self, c):&#13;
        if self.M == "M":&#13;
            pass&#13;
        elif self.M == "I":&#13;
            self.C[self.I] += 1&#13;
            if self.C[self.I] &gt; 9:&#13;
                self.C[self.I] =0&#13;
        elif self.M == "D":&#13;
            if (self.C[self.I] == 0):&#13;
                self.C[self.I] = 9&#13;
            else:&#13;
                self.C[self.I] -= 1&#13;
        else:&#13;
            self.C[self.I] = int(self.M)<span epub:type="pagebreak" id="page_436"/>&#13;
        i = self.I // 5&#13;
        j = self.I % 5&#13;
&#13;
        if c == "N":&#13;
            i -= 1&#13;
            if i &lt; 0:&#13;
                i = 4&#13;
        elif c == "S":&#13;
            i += 1&#13;
            if i &gt; 4:&#13;
                i = 0&#13;
        elif c == "E":&#13;
            j += 1&#13;
            if j &gt; 4:&#13;
                j = 0&#13;
        elif c == "W":&#13;
            j -= 1&#13;
            if j &lt; 0:&#13;
                j = 4&#13;
        &#13;
        self.I = 5*i + j&#13;
&#13;
    def Run(self):&#13;
        for c in self.prg:&#13;
            if c == "I":&#13;
                self.M = "I"&#13;
            elif c == "D":&#13;
                self.M = "D"&#13;
            elif c == "M":&#13;
                self.M = "M"&#13;
            elif c in self.DIGITS:&#13;
                self.M = c&#13;
            elif c in self.MOVES:&#13;
                self.Move(c)&#13;
&#13;
    def GetDisplay(self):&#13;
        return self.C.reshape((5,5))&#13;
&#13;
    def __init__(self, prg=None):&#13;
        self.prg = prg&#13;
        self.C = np.zeros(25)&#13;
        self.I = 12&#13;
        self.M = "M"&#13;
        self.DIGITS= ["0","1","2","3","4","5","6","7","8","9"]&#13;
        self.MOVES = ["N","E","W","S"]</pre>&#13;
<p class="caption" id="ch0Alist1"><em>Listing A-1: A tiny Firefly interpreter</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_437"/>For each program in the population, we create a <code>Firefly</code> instance with the program passed in. Then the <code>Run</code> method executes the program and <code>GetDisplay</code> returns the resulting display. For example, this code loads the <code>Firefly</code> class and runs a program to move north three times:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from fly_swarm import Firefly</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">ff = Firefly("5NNN")</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">ff.Run()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">ff.GetDisplay()</span>&#13;
array([[0., 0., 5., 0., 0.],&#13;
       [0., 0., 5., 0., 0.],&#13;
       [0., 0., 5., 0., 0.],&#13;
       [0., 0., 0., 0., 0.],&#13;
       [0., 0., 0., 0., 0.]])</pre>&#13;
<p class="noindent">We’ll compare the display returned by <code>GetDisplay</code> with our desired target to calculate the program’s fitness.</p>&#13;
<p class="indent">The tiny Firefly interpreter accepts digits, the letters <code>M</code>, <code>I</code>, and <code>D</code>, and the cardinal directions as instructions. The interpreter runs the given program once, without looping, and ends, preserving the resulting display. As we’ll see, our GA runs thousands to millions of sample Firefly programs, searching for one that meets our needs. Each run uses an instance of the <code>Firefly</code> class.</p>&#13;
<h3 class="h3" id="lev1sec112"><strong>The Genetic Algorithm</strong></h3>&#13;
<p class="noindent">The <code>GA</code> class implements the GA. But we need to define a few things before we can use it. First, we need a mapping between the Firefly code we want and the vector of numbers the GA uses to represent an individual. Second, we need a class to bound the search. Third, we need a class to calculate the fitness value for an individual. A fitness value here is like a golf score: lower is better. If the score is 0, we can stop because we found a program that does exactly what we want.</p>&#13;
<p class="indent">There are 17 instructions supported by our tiny Firefly interpreter. Thus, we’ll restrict the vectors used by the GA to [0,16] to ensure they contain integers. This lets us map a vector to a Firefly program.</p>&#13;
<p class="indent"><a href="app01.xhtml#ch0Alist2">Listing A-2</a> defines <code>FlyBounds</code> as a subclass of <code>Bounds</code>.</p>&#13;
<pre>class FlyBounds(Bounds):&#13;
    def __init__(self, ndim):&#13;
        lower = [0]*ndim&#13;
        upper = [len(ALLOWED)-1]*ndim&#13;
        super().__init__(lower, upper, enforce="resample")&#13;
    def Validate(self, p):&#13;
        return np.floor(p+0.5)</pre>&#13;
<p class="caption" id="ch0Alist2"><em>Listing A-2: A class for bounding the search</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_438"/><code>Bounds</code> is a framework component used by the GA. What’s important for us is that the subclass defines the allowed range of values from 0 to 16 (<code>len(ALLOWED)-1</code>), with <code>ndim</code> being the number of instructions in the program (the dimensionality of the search space). The <code>Validate</code> method takes a member of the population, <code>p</code>, and makes it integer-valued by rounding to the nearest integer.</p>&#13;
<p class="indent">The last thing we need is a class to measure a program’s fitness (see <a href="app01.xhtml#ch0Alist3">Listing A-3</a>).</p>&#13;
<pre>class FlyObjective:&#13;
    def __init__(self, target):&#13;
        self.target = target&#13;
        self.fcount = 0&#13;
    def Evaluate(self, p):&#13;
        self.fcount += 1&#13;
        prg = PositionToFirefly(p)&#13;
        fly = Firefly(prg)&#13;
        fly.Run()&#13;
        return ((self.target - fly.GetDisplay())**2).mean()&#13;
&#13;
def PositionToFirefly(p):&#13;
    prg = ""&#13;
    for i in range(len(p)):&#13;
        prg += ALLOWED[int(p[i])]&#13;
    return prg</pre>&#13;
<p class="caption" id="ch0Alist3"><em>Listing A-3: A class to measure fitness</em></p>&#13;
<p class="indent">Here, <code>target</code> is a 5×5 NumPy array representing the display we’re trying to evolve code to generate. The <code>Evaluate</code> method accepts a member of the population, converts it to actual Firefly code with <code>PositionToFirefly</code>, creates a Firefly interpreter, and then runs the code.</p>&#13;
<p class="indent">The last line calculates the fitness of the program. The output is a 5×5 array, that is, the display. For fitness, we’ll use the <em>mean squared error</em>, or <em>MSE</em>. This is the average value of the squared per-element difference between the program’s display and the display we want to generate. The lower this value, the better the program is at creating the desired display. When the MSE is 0, the program has created the target display precisely, so we’ll stop searching when (if) that happens.</p>&#13;
<p class="indent">Using the square of the difference instead of the absolute value of the difference penalizes larger per-element differences more, which is what we want. We want to drive the population toward programs with smaller differences.</p>&#13;
<p class="indent"><code>PositionToFirefly</code> uses a one-to-one mapping between the integers in <code>p</code> and the characters in <code>ALLOWED</code> to return the program string.</p>&#13;
<p class="indent">The GA relies on crossover and random mutation. Firefly programs are represented as vectors of numbers. To implement the crossover of two programs, <em>A</em> and <em>B</em> of length <em>N</em>, the GA selects a random index, <em>i</em>, in [0, <em>N –</em> 1]. The new offspring vector is <em>C</em> = <em>A</em>[: <em>i</em>] + <em>B</em>[<em>i</em> :], meaning the first <em>i</em> values of <span epub:type="pagebreak" id="page_439"/><em>A</em> followed by the last <em>N – i</em> values of <em>B</em>. Mutation is even simpler. A random index, <em>j</em>, is selected, and the value at that index is set to a random number, [0,16].</p>&#13;
<p class="indent">We now have what we need to use the <code>GA</code> class and search for Firefly programs. Let’s see how to do it.</p>&#13;
<h3 class="h3" id="lev1sec113"><strong>Putting It All Together</strong></h3>&#13;
<p class="noindent"><a href="app01.xhtml#ch0Alist4">Listing A-4</a> shows the <code>main</code> function of <em>fly_swarm.py</em>.</p>&#13;
<pre><span class="ent">➊</span> target = np.loadtxt(sys.argv[1])&#13;
   npart = int(sys.argv[2])&#13;
   ndim = int(sys.argv[3])&#13;
   niter = int(sys.argv[4])&#13;
   &#13;
<span class="ent">➋</span> b = FlyBounds(ndim)&#13;
   i = RandomInitializer(npart, ndim, bounds=b)&#13;
   &#13;
<span class="ent">➌</span> obj = FlyObjective(target)&#13;
   &#13;
<span class="ent">➍</span> swarm = GA(obj=obj, npart=npart, ndim=ndim, init=i, tol=1e-12, max_iter=niter,&#13;
           bounds=b)&#13;
   &#13;
   st = time.time()&#13;
<span class="ent">➎</span> swarm.Optimize()&#13;
   en = time.time()&#13;
   &#13;
<span class="ent">➏</span> res = swarm.Results()&#13;
   prg = PositionToFirefly(res["gpos"][-1])&#13;
   ff = Firefly(prg)&#13;
   ff.Run()&#13;
   d = ff.GetDisplay()&#13;
   x = ff.I // 5&#13;
   y = ff.I % 5&#13;
   &#13;
   print()&#13;
   print("Minimum MSE: %0.8f" % res["gbest"][-1])&#13;
   print()&#13;
   print("Program: %s" % prg)&#13;
   print()&#13;
   print("Target display:")&#13;
   print(np.array2string(target.astype("uint8")))&#13;
   print()&#13;
   print("Program display:")&#13;
   print(np.array2string(d.astype("uint8")))&#13;
   print()&#13;
   print("Firefly position (%d,%d)" % (x,y))<span epub:type="pagebreak" id="page_440"/>&#13;
   print("(%d particles, %d/%d iterations, %d best updates, %d function evals,&#13;
          %0.3f sec)" % (npart, res["iterations"], niter, len(res["gbest"]),&#13;
          obj.fcount, en-st))&#13;
   print()</pre>&#13;
<p class="caption" id="ch0Alist4"><em>Listing A-4: The <span class="codeitalic1">main</span> function</em></p>&#13;
<p class="indent">The command line is parsed to load the target display, the size of the population (<code>npart</code>), the length of each program (<code>ndim</code>), and the number of generations to evolve (<code>niter</code>) <span class="ent">➊</span>.</p>&#13;
<p class="indent">Next, we create instances of <code>FlyBounds</code> and <code>RandomInitializer</code>, an object used by the GA to randomly generate the initial population of programs.</p>&#13;
<p class="indent">An instance of <code>FlyObjective</code> comes next <span class="ent">➌</span>, followed by the GA itself <span class="ent">➍</span>. Executing the search takes one line of code <span class="ent">➎</span>. When <code>Optimize</code> ends, it either has found a program that generates the target display or has run out of generations and abandons the search.</p>&#13;
<p class="indent">The results of the search are returned as a Python dictionary <span class="ent">➏</span>. The list of successively more fit programs is in <code>res["gpos"]</code>, meaning the last element of the list is the best program found. We convert the best position to Firefly code, run the program, and grab the display generated to print it at the console along with the program itself. We also print where the firefly is when the program ends. We’ll use this last bit of information in the next section when we piece displays together to make animations.</p>&#13;
<h3 class="h3" id="lev1sec114"><strong>Evolving Firefly Programs</strong></h3>&#13;
<p class="noindent">Let’s evolve some code. We’ll begin by animating two displays to create a flashing warning sign. Next, we’ll animate a radar sweep, complete with a “beep.” Lastly, we’ll animate a bouncing ball of sorts. For each example, we’ll evolve the necessary displays and then piece them together using double buffering to produce the animation.</p>&#13;
<h4 class="h4" id="lev2sec149"><strong><em>Warning Sign</em></strong></h4>&#13;
<p class="noindent">The flashing warning sign consists of two displays:</p>&#13;
<pre>5 5 0 3 3       3 3 0 5 5&#13;
5 5 0 3 3       3 3 0 5 5&#13;
0 0 7 0 0  and  0 0 7 0 0&#13;
3 3 0 5 5       5 5 0 3 3 &#13;
3 3 0 5 5       5 5 0 3 3</pre>&#13;
<p class="noindent">These displays are stored in <em>flash0.txt</em> and <em>flash1.txt</em>, respectively.</p>&#13;
<p class="indent">For the first display, we search with <em>fly_swarm.py</em> as follows:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 fly_swarm.py flash0.txt 30 60 1000000</span></pre>&#13;
<p class="noindent">This means the target display is in <em>flash0.txt</em>. We want a population of 30 programs, each with 60 instructions, and we’ll stop after 1,000,000 generations, or earlier if a program is found.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_441"/>My run took about an hour and fifteen minutes to produce</p>&#13;
<pre>Minimum MSE: 0.00000000&#13;
&#13;
Program: 547WMSNMNI9W5NI5EI174D95S415NMN3NW1D3S3WSWES5DI3WN3NND5ESW5W&#13;
&#13;
Target display:&#13;
[[5 5 0 3 3]&#13;
[5 5 0 3 3]&#13;
[0 0 7 0 0]&#13;
[3 3 0 5 5]&#13;
[3 3 0 5 5]]&#13;
&#13;
Program display:&#13;
[[5 5 0 3 3]&#13;
[5 5 0 3 3]&#13;
[0 0 7 0 0]&#13;
[3 3 0 5 5]&#13;
[3 3 0 5 5]]&#13;
&#13;
Firefly position (4,2)&#13;
(30 particles, 939087/1000000 iterations, GA, 49 best updates, &#13;
 28172640 function evals, 4445.839 sec)</pre>&#13;
<p class="indent">Let’s interpret the output. First, we’re told the MSE was 0. Excellent! We found a program that produces the exact display we need. Next comes the Firefly code. If you run this program with the console interpreter, perhaps adding <code>H</code> at the end to halt instead of loop, you’ll get the target display in <em>flash0.txt</em>. We’re told the firefly is at location (4,2) when the program ends. We’ll use this information to move the firefly back to position (2,2).</p>&#13;
<p class="indent">The final line of the output tells us about the search itself. Of the 1 million generations we set as the upper limit, 939,087 of them were used to find the program. During that time, 28,172,640 programs were tested, resulting in 49 updates to the best program found. No one ever said evolution was fast!</p>&#13;
<p class="indent">We now have the code for the first display. Searching for the second display produces</p>&#13;
<pre>Minimum MSE: 0.00000000&#13;
&#13;
Program: 7W20NE9I3ME5EEN33ESW556633W255NW5WI1MNW788M65NW5S9M55W3NW3SN&#13;
&#13;
Target display:&#13;
[[3 3 0 5 5]&#13;
 [3 3 0 5 5]&#13;
 [0 0 7 0 0]&#13;
 [5 5 0 3 3]&#13;
 [5 5 0 3 3]]<span epub:type="pagebreak" id="page_442"/>&#13;
&#13;
Program display:&#13;
[[3 3 0 5 5]&#13;
 [3 3 0 5 5]&#13;
 [0 0 7 0 0]&#13;
 [5 5 0 3 3]&#13;
 [5 5 0 3 3]]&#13;
&#13;
Firefly position (3,3)&#13;
(30 particles, 22431/1000000 iterations, GA, 41 best updates, 672960 function&#13;
 evals, 106.111 sec)</pre>&#13;
<p class="indent">Again, a program delivering the exact display was found, meaning MSE was 0. However, this run found the program after only 22,431 generations and ran for less than two minutes. Sometimes evolution can be fast after all.</p>&#13;
<p class="indent">Let’s pause briefly to consider what the results above represent. We told <code>GA</code> to search for a program with 60 instructions that results in the display we want. How many possible 60-instruction tiny Firefly programs are there? The interpreter understands 17 instructions. Therefore, there are</p>&#13;
<div class="imagec"><img src="Images/f0442.jpg" alt="Image" width="693" height="97"/></div>&#13;
<p class="noindent">possible 60-instruction tiny Firefly programs, which is a number so large it loses meaning. Did <code>GA</code> really find the <em>one</em> 60-instruction program that generates the target display? No. There are a vast number of 60-instruction Firefly programs resulting in the same display, and any one of them fits the bill. How many are there? That’s a good question—I have no intuition as to the answer or how to calculate it. I expect the number is many orders of magnitude greater than 1, especially if a suitable example was found quickly on the second run.</p>&#13;
<p class="indent">When developing this example, I noticed that the more complex the display, the longer the searches took—and the more often they failed—even though many were close and only off by one or two intensity values in a few places. This result is reasonable. If you try evolving your own displays, which I highly encourage, make them simpler instead of complicated to increase your chances of finding a suitable program in a reasonable amount of time.</p>&#13;
<p class="indent">Let’s move on now and use the code that cost so very many CPU cycles to find. The “Dance Dance” animation of <a href="ch15.xhtml#ch15">Chapter 15</a> presented the code pattern we need to animate displays. We have two here, so we’ll show grid B, draw the first display on grid A, flip to show grid A, and draw the second on grid B before looping. To use the display code via cut-and-paste, we’ll make use of the firefly location information reported above to move the firefly to (2,2) before starting to draw the next display.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_443"/>For example, <em>flash0.txt</em> ends with the firefly at position (4,2). Therefore, we move it back to (2,2) with <code>MNN</code>. Now we can run the code for <em>flash1.txt</em>. Likewise, that code ends with the firefly at (3,3), so we move back to (2,2) with <code>MNW</code>.</p>&#13;
<p class="indent"><a href="app01.xhtml#ch0Alist5">Listing A-5</a> contains the full Firefly code.</p>&#13;
<pre>YA      ! show B, draw A&#13;
7W20NE9I3ME5EEN33ESW556633W255NW5WI1MNW788M65NW5S9M55W3NW3SN&#13;
MNW&#13;
XB      ! show A, draw B&#13;
547WMSNMNI9W5NI5EI174D95S415NMN3NW1D3S3WSWES5DI3WN3NND5ESW5W&#13;
MNN</pre>&#13;
<p class="caption" id="ch0Alist5"><em>Listing A-5: Animating the flash displays</em></p>&#13;
<p class="indent">If you run the above code with the console interpreter, it will oscillate at a very high rate; however, you can slow it down by putting <code>PPP</code> after <code>MNW</code> and <code>MNN</code>. For the micro:bit, no pause instructions are needed; see the video on the GitHub site.</p>&#13;
<h4 class="h4" id="lev2sec150"><strong><em>Radar Sweep</em></strong></h4>&#13;
<p class="noindent">Our next example is quite a bit simpler in terms of displays. We want to make a radar display, one with a rotating “sweep” and a beep when a “target” is present.</p>&#13;
<p class="indent">We need eight displays for the sweep:</p>&#13;
<div class="imagec"><img src="Images/f0443-01.jpg" alt="Image" width="397" height="242"/></div>&#13;
<p class="noindent">If you look across the displays from left to right and top to bottom, you’ll see the sweep make a full revolution. The fourth display has a target at (0,1). We’ll add a “beep” for the target when the displays are animated.</p>&#13;
<p class="indent">The displays themselves are in the <em>GP/radar</em> directory as <em>radar0.txt</em> through <em>radar7.txt</em>. To evolve the displays, execute the <em>search_radar</em> shell script using</p>&#13;
<pre>&gt; <span class="codestrong1">sh search_radar</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_444"/>The script is a collection of individual runs of <em>fly_swarm</em> to evolve 40-instruction Firefly programs that produce the eight displays above. Each run uses a population of 30 programs and searches for up to 500,000 generations.</p>&#13;
<p class="indent">If a display fails, meaning the MSE reported in the results file is not 0, just try that one again manually. I needed to run the <em>radar3.txt</em> display twice. The first run did not find a program that included the target at (0,1). The second run did and only needed 18 seconds to find it.</p>&#13;
<p class="indent">With the display programs located, piecing together the full code is an exercise in following the animation pattern from <em>flash.fly</em>, where grid B is shown while the first display, <em>radar0.txt</em>, is drawn on grid A and then grid A is shown while <em>radar1.txt</em> is drawn on grid B, and so on through <em>radar7.txt</em>.</p>&#13;
<p class="indent">The complete code is in <a href="app01.xhtml#ch0Alist6">Listing A-6</a>.</p>&#13;
<pre>YVA 5383149W7EE27MEIMEWME4IEM6W74M975W932785 MWW  PPPP&#13;
XZB 37N387IM381IMIMW7495N19W645E8M9M4M188ISW MSEE PPPP&#13;
YVA 852MM7W4699793554MNE6791594415NSI6N42961 MSS  PPPP&#13;
XZB MI57S49173ME83I613MN7MN6E18125IMN95EME5S MSE  PPPP&#13;
YVA 1TJ7TF  ! beep&#13;
744299818E488E52I4M66I7M1462I5WW7E122IE1     MWW  PPPP&#13;
XZB 7E42943MSM76S6617EM55WI36M9454I57I33M50W MNN  PPPP&#13;
YVA 527S43M2S127778795N8E45MW57923311776S277 MNN  PPPP&#13;
XZB 697SMW6W99857M662M377242MSI83W35ME2125E1 MNNE PPPP</pre>&#13;
<p class="caption" id="ch0Alist6"><em>Listing A-6: The radar sweep animation</em></p>&#13;
<p class="indent">Note that your code will undoubtedly look different. Each time you evolve code for the displays, you’ll end up with a different program, as there are quite probably thousands to millions of 40-instruction Firefly programs that generate each configuration of the sweep. Don’t forget to add code to move the firefly back to (2,2) from its end position before starting the next display.</p>&#13;
<p class="indent">The beep occurs after <em>radar3.txt</em> is drawn and shown but before drawing <em>radar4.txt</em>. The beep plays with the firefly at (2,2) by setting the duration to 1 and playing note 7, a B above middle C (<code>1TJ7TF</code>).</p>&#13;
<h4 class="h4" id="lev2sec151"><strong><em>Bouncing Ball</em></strong></h4>&#13;
<p class="noindent">Our final example animates a ball moving in a figure-eight pattern. The screens are simple: a 2×2 square of intensity 5 LEDs in different positions to move a “ball” from the upper left to the lower right, then across the bottom of the display, up the lower-left-to-upper-right diagonal, and back across the top to the upper left before repeating—12 displays in all:</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_445"/><img src="Images/f0445-01.jpg" alt="Image" width="397" height="377"/></div>&#13;
<p class="noindent">The script <em>search_balls</em> in the <em>GP</em> directory performs the search for each display. The target displays are in the <em>ball</em> directory as <em>ball0.txt</em> through <em>ball11</em> <em>.txt</em>. In this case, we are searching for 30-instruction programs using a population of 30 individuals and up to 500,000 generations. The displays are simple enough that the searches are all successful, requiring an average of 966 generations (minimum 239, maximum 2,010) per display.</p>&#13;
<p class="indent"><a href="app01.xhtml#ch0Alist7">Listing A-7</a> shows the full code including the 30-instruction sequence for each ball position.</p>&#13;
<pre>YVA 9MNW145NM425WSWMSII12D678I97M8 MWW  ! (2,4)&#13;
XZB 2I6M5IN9I2499W5989D5E775S5WS45 MNE  ! (3,1)&#13;
YVA D83281S355NESW89794M6M92926D47 MN   ! (3,2)&#13;
XZB 57M9MEMS78I4M46MS6M95D5E5N25WS MNNW ! (4,3)&#13;
YVA MDIMS5E5S5SMW55NS749I4MD3250W9 MSSE ! (0,1)&#13;
XZB W3540SESWM735MII75N3298525ES5S MSS  ! (0,2)&#13;
YVA EWS56MW6DD4D55SIMI115WNS8279ME MENN ! (4,1)&#13;
XZB 89MDM4I972S5WEM57D5N5645WW2I4I MEE  ! (2,0)&#13;
YVA 2D764I319D9112615NEI7876SMM5NE MSWW ! (1,4)&#13;
XZB 1835MEN5ENW4S97D46NIS678DDSM68 MW   ! (2,3)&#13;
YVA 56647MN5E587795NWNMNNS5I331334 MN   ! (3,2)&#13;
XZB 78MNM4WN7E4MI85S94715W6N15S25S ME   ! (2,1)</pre>&#13;
<p class="caption" id="ch0Alist7"><em>Listing A-7: Animating a moving ball</em></p>&#13;
<p class="indent">The comment indicates where the sequence leaves the firefly. The move instructions on that line put the firefly back to (2,2) for the next display. No pause instructions are included to run as quickly as possible on the micro:bit.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_446"/>For the console interpreter, add <code>PPPP</code> after each move of the firefly back to (2,2) to see the ball move.</p>&#13;
<h3 class="h3" id="lev1sec115"><strong>Discussion</strong></h3>&#13;
<p class="noindent">The examples above demonstrate we can successfully evolve Firefly programs. In this section, we’ll take a closer look at just what is happening while the search is active by considering the initial and final populations. What do they look like? Next, we’ll take a look at a collection of successful searches. Are the programs found all similar? Lastly, while in general it isn’t usually possible to know what the shortest program for a task is for Firefly, we can in simple cases. Can genetic programming find the shortest program as well?</p>&#13;
<p class="indent">The files discussed in this section are found in the <em>GP/swarm_convergence</em> directory.</p>&#13;
<h4 class="h4" id="lev2sec152"><strong><em>Population Effects</em></strong></h4>&#13;
<p class="noindent">Genetic programming begins with a population of randomly generated programs. As the search progresses, new programs evolve while the size of the population remains fixed. What happens to the diversity of programs during the search? What does “diversity” even mean in this case?</p>&#13;
<p class="indent">Let’s examine two searches, one for a program of 10 instructions and the other for 60 instructions. In both cases, we are trying to generate the display found in <em>ball/ball0.txt</em>, the medium intensity square in the upper left of the display. We’ll use a population of 30 programs and only consider a successful search, that is, one with an MSE of 0.</p>&#13;
<p class="indent">The file <em>swarm_10.txt</em> contains the best 10-instruction programs found, followed by the initial population of programs and then the final population. There are 30 programs in the population, so there are 61 lines in <em>swarm_10.txt</em>.</p>&#13;
<pre>NW55NWS5E4  ! best program found&#13;
3596SW14M5  ! initial population&#13;
4N92DNW46D&#13;
1EIMIWD6M2&#13;
I7WM6I47M8&#13;
2467316I63&#13;
... 25 more lines ...&#13;
NW55NWS6E4  ! final population&#13;
NE55NWS6E4&#13;
NW55NWS6E4&#13;
NW55NWS6E4&#13;
NW55NWS6E4&#13;
... 25 more lines ...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_447"/>From this listing, it’s clear the initial population is quite different from the final population and that the latter is much like the best program found. How can we quantify this difference? One way is to measure the distance between the best program found and each of the initial and final population programs. The average distance should tell us something about the diversity of the programs in each population. What distance metric should we use? We could work with the programs as numeric vectors and calculate the distance for vectors in a 10D space. This is the <em>Euclidean distance</em>. However, using the Euclidean distance would require converting the program text to numbers.</p>&#13;
<p class="indent">Another option is to use the edit distance between the programs. The <em>edit distance</em> between two strings is how many letters must be changed to turn one string into the other. For example, the edit distance between “darwin” and “charles” is 5: we need five letters to turn “darwin” into “charles.” Similarly, the edit distance between “darwin” and “daniel” is 4, whereas the edit distance between “darwin” and “dorwin” is only 1—change the <em>a</em> to an <em>o</em>.</p>&#13;
<p class="indent">We need the <code>editdistance</code> library to calculate edit distances in Python. It’s easily installed with <code>pip3</code>:</p>&#13;
<pre>&gt; <span class="codestrong1">pip3 install editdistance</span></pre>&#13;
<p class="noindent">We can use it like so:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import editdistance</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">editdistance.eval("darwin", "charles")</span>&#13;
5&#13;
&gt;&gt;&gt; <span class="codestrong1">editdistance.eval("darwin", "daniel")</span>&#13;
4&#13;
&gt;&gt;&gt; <span class="codestrong1">editdistance.eval("darwin", "dorwin")</span>&#13;
1</pre>&#13;
<p class="indent">The closer the two strings are to each other, the shorter their edit distance. Let’s use this to calculate the average edit distance between the best program and the initial and final populations for <em>swarm_10.txt</em> and <em>swarm _60.txt</em>. The code we need is in <em>swarm_edit_distance.py</em>. See <a href="app01.xhtml#ch0Alist8">Listing A-8</a>.</p>&#13;
<pre>import numpy as np&#13;
import editdistance&#13;
&#13;
prg = [i[:-1] for i in open("swarm_10.txt")]&#13;
best = prg[0]&#13;
init = prg[1:31]&#13;
final= prg[31:]&#13;
&#13;
i = []&#13;
for p in init:&#13;
    i.append(editdistance.eval(best, p))<span epub:type="pagebreak" id="page_448"/>&#13;
i = np.array(i) / len(init[0])&#13;
f = []&#13;
for p in final:&#13;
    f.append(editdistance.eval(best, p))&#13;
f = np.array(f) / len(final[0])&#13;
print("Program length 10: %0.3f initial, %0.3f final" % (i.mean(), f.mean()))&#13;
&#13;
#  Program length 60&#13;
prg = [i[:-1] for i in open("swarm_60.txt")]&#13;
best = prg[0]&#13;
init = prg[1:31]&#13;
final= prg[31:]&#13;
&#13;
i = []&#13;
for p in init:&#13;
    i.append(editdistance.eval(best, p))&#13;
i = np.array(i) / len(init[0])&#13;
f = []&#13;
for p in final:&#13;
    f.append(editdistance.eval(best, p))&#13;
f = np.array(f) / len(final[0])&#13;
print("Program length 60: %0.3f initial, %0.3f final" % (i.mean(), f.mean()))</pre>&#13;
<p class="caption" id="ch0Alist8"><em>Listing A-8: The average edit distance between initial and final populations</em></p>&#13;
<p class="indent">The code loads <em>swarm_10.txt</em>, calculates the edit distance between the best program and each initial program, and then does the same with the final population of programs before reporting the average for both. It then repeats using <em>swarm_60.txt</em>.</p>&#13;
<p class="indent">If we run the code in <a href="app01.xhtml#ch0Alist8">Listing A-8</a> we get</p>&#13;
<pre>Program length 10: 0.920 initial, 0.103 final&#13;
Program length 60: 0.857 initial, 0.066 final</pre>&#13;
<p class="noindent">Note that we divide the edit distance by the program length, either 10 or 60, to meaningfully compare between the different length programs. The number shown above is then a fraction of the program length regardless of the actual program length.</p>&#13;
<p class="indent">The initial populations are significantly more diverse than the final populations. For the 10-instruction program, the initial population is on average 92 percent different, meaning the difference between the initial set of programs and the best found is almost every instruction. However, the final population is on average only 10 percent, or one instruction, different from the best program. The population has collapsed, diversity has disappeared, and most programs are virtually identical to the best found. The collapse effect is even more pronounced for the 60-instruction programs.</p>&#13;
<p class="indent">The results above examine what happens to the population during a single successful search. What if we run the search many times? Will we find the same best program each time? Let’s try it and see.</p>&#13;
<h4 class="h4" id="lev2sec153"><span epub:type="pagebreak" id="page_449"/><strong><em>Final Program Diversity</em></strong></h4>&#13;
<p class="noindent">Is the best program found by the search the same each time? To answer this question, let’s again search for programs generating the <em>ball0.txt</em> display. We’ll use 10-instruction and 60-instruction programs, as above.</p>&#13;
<p class="indent">To do this, we run <em>fly_swarm.py</em> 10 times, keeping the best program found in <em>runs_10.txt</em> or <em>runs_60.txt</em>. Each run looks like this:</p>&#13;
<pre>&gt; <span class="codestrong1">python3 fly_swarm.py ball/ball0.txt 30 10 10000</span></pre>&#13;
<p class="noindent">The best program found is put in <em>runs_10.txt</em>, one per line. Only successful searches, that is, those returning an MSE of 0, are kept. As the display is simple, most runs are successful.</p>&#13;
<p class="indent">Now that we have the 10 best programs for 10 searches, we’ll calculate the average edit distance between the programs. If the search produces the same program each time, the average edit distance will be 0. The higher the average edit distance, the more diverse the programs are, even though each program generates the desired display.</p>&#13;
<p class="indent"><a href="app01.xhtml#ch0Alist9">Listing A-9</a> shows what’s in <em>final_program_distance.py</em>.</p>&#13;
<pre>import numpy as np&#13;
import editdistance&#13;
&#13;
prg = [i[:-1] for i in open("runs_10.txt")]&#13;
dist = []&#13;
for i in range(len(prg)):&#13;
    for j in range(len(prg)):&#13;
        if (i == j):&#13;
            continue&#13;
        dist.append(editdistance.eval(prg[i],prg[j]))&#13;
dist = np.array(dist) / len(prg[0])&#13;
print()&#13;
print("10-instructions: %0.4f +/- %0.4f" % (dist.mean(), dist.std(ddof=1)/np.sqrt(len(dist))))&#13;
&#13;
prg = [i[:-1] for i in open("runs_60.txt")]&#13;
dist = []&#13;
for i in range(len(prg)):&#13;
    for j in range(len(prg)):&#13;
        if (i == j):&#13;
            continue&#13;
        dist.append(editdistance.eval(prg[i],prg[j]))&#13;
dist = np.array(dist) / len(prg[0])&#13;
print("60-instructions: %0.4f +/- %0.4f" % (dist.mean(), dist.std(ddof=1)/np.sqrt(len(dist))))</pre>&#13;
<p class="caption" id="ch0Alist9"><em>Listing A-9: The average distance between pairs of best programs found</em></p>&#13;
<p class="indent">This listing calculates the edit distance between each pair of best programs for both 10-instruction and 60-instruction programs. Naturally, the edit distance between a program and itself is 0, so we skip those cases. As <span epub:type="pagebreak" id="page_450"/>above, the edit distance is divided by the program length to make it a fraction to allow meaningful comparison between the two.</p>&#13;
<p class="indent"><a href="app01.xhtml#ch0Alist9">Listing A-9</a> produces</p>&#13;
<pre>10-instructions: 0.6467 +/- 0.0148&#13;
60-instructions: 0.8337 +/- 0.0037</pre>&#13;
<p class="noindent">You’ll get slightly different results if you re-create <em>runs_10.txt</em> and <em>runs_60.txt</em> yourself. The output shows the average edit distance and the <em>standard error of the mean</em>, or <em>SE</em>. The SE is a measure of uncertainty in a mean or average value. For us, a small SE relative to the average indicates that the average is well known.</p>&#13;
<p class="indent">Let’s interpret the values. For a 10-instruction program, we get an average difference of about 65 percent between the best programs found. Recall that each program is a successful program: each one generates the desired display. So even for short programs, there are multiple solutions, and different search runs find different possible solutions. Which solution is located depends on the population’s size, the random initial population, and random factors used in crossover and mutation.</p>&#13;
<p class="indent">As we might suspect, longer programs have many more possible solutions. I suspect this is mainly because of “junk” code; that is, code that doesn’t help or hurt because the rest of the code still generates the desired display. We see this, as the average distance between successful 60-instruction programs is about 83 percent. The programs all solve the problem, but they are very different from each other.</p>&#13;
<p class="indent">Let’s search for 1,000 10-instruction programs to generate <em>ball0.txt</em> and see how many of them are unique. The code we’ll run is in <em>ball_search.py</em>. The code dumps the programs to the file <em>ball_search_results.txt</em>.</p>&#13;
<p class="indent">A bit of processing on the output file tells us how many unique 10-instruction programs were generated:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">d = [i[:-1] for i in open("ball_search_results.txt")]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">len(set(d))</span>&#13;
985</pre>&#13;
<p class="noindent">Note that we turn the list of 10-instruction programs into a set, thereby removing duplicates, before asking for the number of items.</p>&#13;
<p class="indent">Of the 1,000 successful runs looking for a 10-instruction program to generate <em>ball0.txt</em>, 985, or 98.5 percent, of them are unique. In other words, there are virtually no duplicates. This is strong support for our belief that there are many possible solutions to any display we care to generate.</p>&#13;
<h4 class="h4" id="lev2sec154"><strong><em>Can Genetic Programming Find the Shortest Program?</em></strong></h4>&#13;
<p class="noindent">We usually don’t know what the shortest program is to accomplish a given goal. However, for Firefly displays, at least the simple ones, we can know. Let’s continue working with the <em>ball0.txt</em> display.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_451"/>If we look at the display, knowing the firefly starts in move mode at position (2,2), we can easily convince ourselves that the shortest possible program to generate the display has seven instructions. There are multiple seven-instruction programs, but no program with six or fewer instructions can create the display. Can genetic programming find these shortest programs? Let’s find out.</p>&#13;
<p class="indent">A command line like the following searches for a seven-instruction Firefly program generating the <em>ball0.txt</em> display.</p>&#13;
<pre>&gt; <span class="codestrong1">python3 fly_swarm.py ball/ball0.txt 30 7 16000</span></pre>&#13;
<p class="noindent">The search terminates after 16,000 generations if no program leading to the display is found. We’ll consider those cases to be failures.</p>&#13;
<p class="indent">Running 10 searches by hand leads to seven successes and three failures. The seven successful programs, sorted alphabetically, are</p>&#13;
<pre>NW5NWSS&#13;
NW5NWSW&#13;
NW5WNEE&#13;
NW5WNEE&#13;
NW5WNEE&#13;
WN5WNEN&#13;
WN5WNES</pre>&#13;
<p class="noindent">Notice that the same program, <code>NW5WNEE</code>, shows up three of the seven times.</p>&#13;
<p class="indent">To answer our first question: yes, genetic programming can find the shortest program to generate the display. We also have a hint that one of the programs might be more likely to show up than the others. However, 10 runs are too few to make any definitive statements about how often a solution appears.</p>&#13;
<p class="indent">Let’s repeat the search we did in the previous section and gather 1,000 successful seven-instruction programs to see how often each solution appears (see <em>ball_search_7.py</em>). The space of possible seven-instruction programs is smaller than the space of 10-instruction programs, so we do expect a distribution over a finite set of solutions that we might fully enumerate with even 1,000 trials.</p>&#13;
<p class="indent">The output of <em>ball_search_7.py</em> is in <em>ball_search_7_results.txt</em>, which contains the best program found for each of the 1,000 successful searches. If we load the results into Python and pass them to NumPy’s <code>np.unique</code> function, we’ll get back the list of unique best programs and how many times each one appeared.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">t = [i[:-1] for i in open("ball_search_7_results.txt")]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">prg, counts = np.unique(t, return_counts=True)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">prg</span>&#13;
array(['NW5NWSE', 'NW5NWSN', 'NW5NWSS', 'NW5NWSW', 'NW5WNEE', &#13;
       'NW5WNEN', 'NW5WNES', 'NW5WNEW', 'WN5NWSE', 'WN5NWSN',<span epub:type="pagebreak" id="page_452"/>&#13;
       'WN5NWSS', 'WN5NWSW', 'WN5WNEE', 'WN5WNEN', 'WN5WNES',&#13;
       'WN5WNEW'], dtype='&lt;U7')&#13;
&gt;&gt;&gt; <span class="codestrong1">counts</span>&#13;
array([68, 58, 67, 62, 71, 80, 61, 54, 62, 58, 59, 61, 52, 62,&#13;
       60, 65])</pre>&#13;
<p class="noindent">We see that there are 16 possible seven-instruction programs leading to the <em>ball0.txt</em> display. Each program begins with either <code>NW5</code> or <code>WN5</code>. This makes sense, as the program needs to set four positions to intensity 5, and the shortest way to get to the nearest ball position is to go north and then west or west and then north. The final four instructions enumerate the ways to move over the four upper-left display positions.</p>&#13;
<p class="indent">What about the counts? The results show the counts for each outcome over 1,000 searches. We have no strong reason to expect that any of the possible outcomes is to be favored over any of the others; therefore, we expect the counts to be the same in the long run. The counts are not the same, but they might still be consistent with a distribution where each output program is equally likely. How can we test if this is true?</p>&#13;
<p class="indent">In statistics, a way to test if a set of frequencies is consistent with each being equally likely is to use a <em>χ</em><sup>2</sup> (chi-square) test. We want to test the observed frequencies, that is, the counts, against another set of expected frequencies, which is the set where each outcome is equally likely. We could write a bit of code to do this, but fortunately for us, SciPy already has what we need.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from scipy.stats import chisquare</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">chisquare(counts)</span>&#13;
Power_divergenceResult(statistic=10.911999999999999,&#13;
    pvalue=0.7588072298114652)</pre>&#13;
<p class="noindent">The return value from <code>chisquare</code> that concerns us is the p-value of 0.76. This number can be interpreted as how consistent the counts are with each outcome being equally likely. If the p-value is low, usually if it’s much less than 0.05, we might think that the outcomes are not all equally likely. In this case, the p-value of 0.76 implies there is no reason to believe that any outcome, any best seven-instruction program, is any more likely to be found by genetic programming than the others.</p>&#13;
<p class="indent">The takeaway from this section is that genetic programming can find the smallest program and will find all possible such programs with enough runs of the search.</p>&#13;
<h3 class="h3" id="lev1sec116"><strong>Final Thoughts</strong></h3>&#13;
<p class="noindent">The examples of this appendix demonstrate the utility of genetic programming for evolving Firefly programs. Genetic programming is not widely discussed these days, but it has shown a slow and steady increase in scholarly publications over time, as <a href="app01.xhtml#ch0Afig1">Figure A-1</a> illustrates. The plot shows the number of Google Scholar hits by year, matching the string “genetic programming.”</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_453"/><img id="ch0Afig1" src="Images/Afig01.jpg" alt="Image" width="678" height="503"/></div>&#13;
<p class="figcap"><em>Figure A-1: Number of Google Scholar hits for “genetic programming” by year</em></p>&#13;
<p class="indent">We used a GA as the basis for our genetic programming searches; however, there are many other algorithms one might try instead. GA is an evolutionary algorithm, as it simulates evolution to some degree. Another powerful evolutionary algorithm is differential evolution. Beyond evolutionary algorithms are the myriad of swarm intelligence algorithms like particle swarm optimization.</p>&#13;
<p class="indent">When properly configured, the genetic programming searches above can use these algorithms in place of <code>GA</code> by importing them into <em>fly_swarm.py</em> and replacing</p>&#13;
<pre>swarm = GA(obj=obj, npart=npart, ndim=ndim, init=i, tol=1e-12,&#13;
           max_iter=niter, bounds=b)</pre>&#13;
<p class="noindent">with the desired algorithm. For example, to try differential evolution, import <em>DE.py</em> and use</p>&#13;
<pre>swarm = DE(obj=obj, npart=npart, ndim=ndim, init=i, tol=1e-12, &#13;
           max_iter=niter, bounds=b)</pre>&#13;
<p class="indent">Differential evolution and particle swarm optimization are in the <em>GP</em> directory. Give them a try, and let me know how it goes. Do the other algorithms work at all? If so, how do they compare to GA? <span epub:type="pagebreak" id="page_454"/></p>&#13;
</div></body></html>