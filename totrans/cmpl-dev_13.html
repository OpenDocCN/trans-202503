<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch11">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label=" Page 185. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">SETTING UP THE DOCKER ENVIRONMENT</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In this part of the book, you’ll build a full-stack application from scratch by using the knowledge you’ve acquired so far. While previous chapters explained parts of the technology stack, the remaining chapters focus on the code in more detail.</p>&#13;
<p class="TX">This chapter describes the application you’ll build and walks you through configuring the environment using Docker. While I recommend reading previous chapters before you start writing code, the only real requirement is that you have Docker installed and running before moving on. Consult <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> for instructions on doing so.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can download the complete source code for the Food Finder application at</i> <a href="http://www.usemodernfullstack.dev/downloads/food-finder"><span class="note_LinkURL_Italic">http://<wbr/>www<wbr/>.usemodernfullstack<wbr/>.dev<wbr/>/downloads<wbr/>/food<wbr/>-finder</span></a> <i>and a ZIP file with only the required assets from</i> <a href="http://www.usemodernfullstack.dev/downloads/assets"><span class="note_LinkURL_Italic">http://<wbr/>www<wbr/>.usemodernfullstack<wbr/>.dev<wbr/>/downloads<wbr/>/assets</span></a><i>.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-67"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label=" Page 186. "/><samp class="SANS_Futura_Std_Bold_B_11">The Food Finder Application</samp></h3>&#13;
<p class="TNI">The Food Finder application shows a list of restaurants and their locations. The user can click these to see additional details about each location. In addition, they can log in to the app with their GitHub accounts by using OAuth so that they can maintain a wish list of locations.</p>&#13;
<p class="TX">Behind the scenes, we’ll write this simple single-page application in TypeScript. After setting up the local environment, we’ll build the backend and middleware with Next.js, Mongoose, and MongoDB, which we’ll seed with initial data. Then we’ll add GraphQL to expose an API layer through which we can access a user’s wish list. To build the frontend, we’ll use our knowledge of React components, Next.js pages, and routing. We’ll also add an OAuth authorization flow with <i>next-auth</i> to let users log in with GitHub. Finally, we’ll write automated tests with Jest to verify the integrity and stability of the application.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-68"/><samp class="SANS_Futura_Std_Bold_B_11">Building the Local Environment with Docker</samp></h3>&#13;
<p class="TNI">Docker decouples the development environment from our local machine. We’ll use it to create self-contained services for each part of our application. In the <i>docker-compose</i> file, we’ll add one service for the backend, which provides the MongoDB database, and a second to run the Next.js application hosting the frontend and the middleware.</p>&#13;
<p class="TX">To start the development, create a new empty folder, <i>code</i>. This folder will serve as the application’s root and contain all the code for the Food Finder application. Later in this chapter, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp> helper command to add files to it.</p>&#13;
<p class="TX">Next, create an empty <i>docker-compose.yml</i> file and a <i>.docker</i> folder in this root folder. In the file, we will define the two services for our environment and store the seed data we need to create the container.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-147"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Backend Container</samp></h4>&#13;
<p class="TNI">The backend container provides nothing but the app’s MongoDB instance. For this reason, we can use the official MongoDB image, which Docker can download automatically, from the Docker registry without creating a custom Dockerfile.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h5 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Seeding the Database</samp></h5>&#13;
<p class="TNI">We want MongoDB to begin with a prefilled database that contains a valid set of initial datasets. This process is called seeding the database, and we can automate it by copying the seeding script <i>seed-mongodb.js</i> into the container’s <i>/docker-entrypoint-initdb.d/</i> directory on startup. The MongoDB image executes the scripts in this folder against the database defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_INITDB_DATABASE</samp> environment variable if there is no data in the container’s <i>/data/db</i> directory on startup.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label=" Page 187. "/>Create a new folder, <i>foodfinder-backend</i>, in the <i>.docker</i> folder, and then copy into the newly created folder the <i>seed-mongodb.js</i> file from the <i>assets.zip</i> file you downloaded earlier. The seed file’s content should look similar to <a href="chapter11.xhtml#Lis11-1">Listing 11-1</a>.</p>&#13;
<span id="Lis11-1"/>&#13;
<pre class="pre-203"><code>db.locations.insert([&#13;
    {&#13;
        address: "6220 Avenue U",&#13;
        zipcode: "NY 11234",&#13;
        borough: "Brooklyn",&#13;
        cuisine: "Cafe",&#13;
        grade: "A",&#13;
        name: "The Roasted Bean",&#13;
        on_wishlist: [],&#13;
        location_id: "56018",&#13;
    },&#13;
<var>--snip--</var>&#13;
    {&#13;
        address: "405 Lexington Avenue",&#13;
        zipcode: "NY 10174",&#13;
        borough: "Manhattan",&#13;
        cuisine: "American",&#13;
        grade: "A",&#13;
        name: "The Diner At The Corner",&#13;
        on_wishlist: [],&#13;
        location_id: "63426",&#13;
    }&#13;
]);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 11-1: The</span> <span class="Futura_Std_Book_11">seed-mongodb.js</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">You can see that the script interacts directly with a collection in the MongoDB instance that we’ll set up in the next section. We use MongoDB’s <samp class="SANS_TheSansMonoCd_W5Regular_11">insert</samp> method to fill the database’s <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> collection with the documents. Note that we are working with the <i>native</i> MongoDB driver to insert the documents instead of using Mongoose. We do so because Mongoose is not installed on the default MongoDB Docker image, and inserting the documents is a relatively simple task. Although we do not use Mongoose for seeding the database, the documents we insert need to match the schema we define with Mongoose later.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h5 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating the Backend Service</samp></h5>&#13;
<p class="TNI">We can now define the backend service in the Docker setup. Add the code from <a href="chapter11.xhtml#Lis11-2">Listing 11-2</a> into the empty <i>docker-compose.yml</i> file we created earlier.</p>&#13;
<span id="Lis11-2"/>&#13;
<pre class="pre-204"><code>version: "3.0"&#13;
services:&#13;
    backend:&#13;
        container_name: foodfinder-backend&#13;
        image: mongo:latest&#13;
        restart: always&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label=" Page 188. "/>        environment:&#13;
            DB_NAME: foodfinder&#13;
            MONGO_INITDB_DATABASE: foodfinder&#13;
        ports:&#13;
            - 27017:27017&#13;
        volumes:&#13;
            - "./.docker/foodfinder-backend/seed-mongodb.js:&#13;
/docker-entrypoint-initdb.d/seed-mongodb.js"&#13;
            - mongodb_data_container:/data/db&#13;
&#13;
volumes:&#13;
    mongodb_data_container:&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 11-2: The</span> <span class="Futura_Std_Book_11">docker-compose.yml</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the backend service</span></p>&#13;
<p class="TX">We first define the container’s name so that we can easily reference it later. As discussed earlier, we use the latest version of the official MongoDB image and specify that this container should always be restarted if it stops. Next, we use the environment variables to define the collections we’ll use with MongoDB. We define two of those: <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_NAME</samp> points to the collection we’ll use with Mongoose, and <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_INITDB_DATABASE</samp> points to the seed script. The scripts in <i>/docker-entrypoint-initdb.d/</i> use this latter collection by default.</p>&#13;
<p class="TX">We want the script to populate our application’s database, so we set both variables to the same name, <samp class="SANS_TheSansMonoCd_W5Regular_11">foodfinder</samp>, and thus we have a prefilled database for our Mongoose model.</p>&#13;
<p class="TX">Then we map and expose the container’s internal port 27017 to the host’s port 27017 so that the MongoDB instance is accessible to the application at <i>mongodb://backend:27017/foodfinder</i>. Notice that the connection string contains the service name, the port, and the database. Later, we store this connection string in the environment variables and use it to connect to the database from the middleware. Finally, we map and copy the seed script to the setup location and save the database data from <i>/data/db</i> into the Docker volume <i>mongodb_data_container</i>. Because we want to split the string across two lines, we need to wrap it in double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>) according to the YAML conventions.</p>&#13;
<p class="TX">Now complete the Docker setup with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp>:</p>&#13;
&#13;
<pre class="pre-205"><code>$ <b>docker compose up</b>&#13;
[+] Running 2/2&#13;
 ⠿ Network foodfinder_default                      Created                 0.1s&#13;
 ⠿ Container foodfinder-backend                    Created                 0.3s&#13;
Attaching to foodfinder-backend&#13;
&#13;
foodfinder-backend  | /usr/local/bin/docker-entrypoint.sh: running /docker&#13;
                    /entrypoint-initdb.d/seed-mongodb.js&#13;
</code></pre>&#13;
<p class="TX">The output shows us that the Docker daemon successfully created the <samp class="SANS_TheSansMonoCd_W5Regular_11">foodfinder-backend</samp> container and that the seeding script was executed during startup. Instead of going through the hassle of installing and maintaining MongoDB locally or finding a free or low-cost cloud instance, we’ve <span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label=" Page 189. "/>added MongoDB to our project with just a few lines of code in the <i>docker -compose</i> file.</p>&#13;
<p class="TX">Stop the container with <small>CRTL</small>-C and remove it with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose down</samp>:</p>&#13;
&#13;
<pre class="pre-206"><code>$ <b>docker compose down</b>&#13;
[+] Running 2/2&#13;
 ⠿ Container foodfinder-backend                     Removed                 0.0s&#13;
 ⠿ Network foodfinder_default                       Removed&#13;
</code></pre>&#13;
<p class="TX">Now we can add the frontend container.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-148"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Frontend Container</samp></h4>&#13;
<p class="TNI">Now we’ll create the containerized infrastructure for the frontend and middleware. Our approach will involve using <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp> to scaffold the Next.js application, as we did in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, relying on the official Node.js Docker image to decouple the application from any local Node.js installation.</p>&#13;
<p class="TX">As we’ll execute all Node.js-related commands inside this container, we technically don’t even need Node.js installed on our local machine; nor must we make sure the Node.js versions we use comply with Next.js’s requirements. Also, npm might install packages that are optimized for the operating system on which it is running, so by using npm inside the container, we ensure that npm installs the correct versions for Linux.</p>&#13;
<p class="TX">Nonetheless, we’ll want Docker to synchronize the Node.js <i>modules</i> folder to our local system. This will allow our IDE to automatically use the installed dependencies, such as the TypeScript compiler and ESLint. Let’s start by creating a minimal Dockerfile.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating the Application Service</samp></h5>&#13;
<p class="TNI">We add the combined frontend and middleware service to our Docker setup by placing the code from <a href="chapter11.xhtml#Lis11-3">Listing 11-3</a> into the <samp class="SANS_TheSansMonoCd_W5Regular_11">services</samp> property of the project’s <i>docker-compose.yml</i> file.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label=" Page 190. "/>&#13;
<span id="Lis11-3"/>&#13;
<pre class="pre-207"><code><var>--snip--</var>&#13;
services:&#13;
&#13;
    application:&#13;
        container_name: foodfinder-application&#13;
        image: node:lts-alpine&#13;
        ports:&#13;
            - "3000:3000"&#13;
        volumes:&#13;
            - ./code:/home/node/code&#13;
        working_dir: /home/node/code/&#13;
        depends_on:&#13;
            - backend&#13;
        environment:&#13;
            - HOST=0.0.0.0&#13;
            - CHOKIDAR_USEPOLLING=true&#13;
            - CHOKIDAR_INTERVAL=100&#13;
        tty: true&#13;
    backend:&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 11-3: The</span> <span class="Futura_Std_Book_11">docker-compose.yml</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the backend and application service</span></p>&#13;
<p class="TX">The service for the Food Finder application follows the same structure as the service for the backend. First we set the container’s name. Then we define the image to be used for this particular service. While the backend service used the official MongoDB image, we now use the official Node.js image with the current LTS version running on Alpine Linux, a lightweight Linux distribution that requires significantly less memory than a Debian-based image.</p>&#13;
<p class="TX">We then expose and map port 3000, making the application available on <i>http://localhost:3000</i>, and map the local application’s code directory into the container. Next, we set the working directory to the <i>code</i> directory. We specify that our container requires a running backend service, because the Next.js application will need a working connection to the MongoDB instance. In addition, we add environment variables. In particular, <samp class="SANS_TheSansMonoCd_W5Regular_11">chokidar</samp> supports hot-reloading for the Next.js code. Finally, setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">tty</samp> property to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> makes the container provide an interactive shell instead of shutting down. We’ll need the shell to execute commands inside the container.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Installing Next.js</samp></h5>&#13;
<p class="TNI">With both services in place, we can now install Next.js inside the container. To do so, we need to start the container with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp>:</p>&#13;
&#13;
<pre class="pre-208"><code>$ <b>docker compose up</b>&#13;
&#13;
[+] Running 3/3&#13;
 ⠿ Network foodfinder_default                      Created                 0.1s&#13;
 ⠿ Container foodfinder-backend                    Created                 0.3s&#13;
 ⠿ Container foodfinder-application                Created                 0.3s&#13;
Attaching to foodfinder-application, foodfinder-backend&#13;
<var>--snip--</var>&#13;
foodfinder-application  | Welcome to Node.js ...&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Compare this command line output with the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp> output. You should see that the application container started successfully and that it runs a Node.js interactive shell.</p>&#13;
<p class="TX">Now we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker exec</samp> to execute commands inside the running container. Doing so has two main advantages. First, we don’t need any particular version of Node.js (or any version at all) on our local machine. Second, we run the Node.js application and npm commands on the Node.js Linux Alpine image so that the dependencies will be optimized for Alpine instead of for our host system.</p>&#13;
<p class="TX">To run npm commands inside the container, use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker exec -it foodfinder-application</samp> followed by the command to run. The Docker <span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label=" Page 191. "/>daemon connects to the terminal inside the container and executes the provided command in the application container’s working directory, <i>/home/node/code</i>, which we set previously. Let’s install the Next.js application there using the <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> command discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>:</p>&#13;
&#13;
<pre class="pre-209"><code>/home/node/code# <b>docker exec -it foodfinder-application \</b>&#13;
<b>npx create-next-app@latest foodfinder-application \</b>&#13;
<b>--typescript --use-npm</b>&#13;
Need to install the following packages:&#13;
  create-next-app&#13;
Ok to proceed? (y)&#13;
✔ Would you like to use ESLint with this project? ... No / Yes&#13;
Creating a new Next.js app in /home/node/code/foodfinder-application.&#13;
&#13;
Success! Created foodfinder-application at /home/node/code/foodfinder-application&#13;
</code></pre>&#13;
<p class="TX">We set the project name to <i>foodfinder-application</i> and accept the defaults. The rest of the output should look familiar to you.</p>&#13;
<p class="TX">As soon as the scaffolding is done, we can start the Next.js application with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp>. If you visit <i>http://localhost:3000</i> in your browser, you should see the familiar Next.js splash screen. The <i>foodfinder-application</i> folder should be mapped into the local <i>code</i> folder, so we can edit the Next.js-related files locally.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adjusting the Application Service for Restarts</samp></h5>&#13;
<p class="TNI">Currently, connecting to the application container requires running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker exec</samp> after each restart through <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp> and then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> manually. Let’s make two minor adjustments in our application service to allow for a more convenient setup. Modify the file to match <a href="chapter11.xhtml#Lis11-4">Listing 11-4</a>.</p>&#13;
<span id="Lis11-4"/>&#13;
<pre class="pre-210"><code><var>--snip--</var>&#13;
services:&#13;
<var>--snip--</var>&#13;
    <b>application:</b>&#13;
<var>--snip--</var>&#13;
        volumes:&#13;
            - ./code:/home/node/code&#13;
        working_dir: /home/node/code/<b>foodfinder-application</b>&#13;
<var>--snip--</var>&#13;
<b>        command: "npm run dev"</b>&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 11-4: The</span> <span class="Futura_Std_Book_11">docker-compose.yml</span> <span class="Futura_Std_Book_Oblique_BI_11">file to start Next.js automatically</span></p>&#13;
<p class="TX">First, change the <samp class="SANS_TheSansMonoCd_W5Regular_11">working_dir</samp> property. Because we’re working with Next.js, we set it to the Next.js application’s root folder, <i>/home/node/code/foodfinder-application</i>, which contains the <i>package.json</i> file. Then we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> property with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp>. With these two modifications, each <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp> call should instantly start the Next.js application. Try <span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label=" Page 192. "/>starting the containers with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp>; the console output should show that Next.js runs and that it’s available at <i>http://localhost:3000</i>:</p>&#13;
&#13;
<pre class="pre-211"><code>$ <b>docker compose up</b>&#13;
[+] Running 3/3&#13;
 ⠿ Network foodfinder_default                      Created    0.1s&#13;
 ⠿ Container foodfinder-backend                    Created    0.3s&#13;
 ⠿ Container foodfinder-application                Created    0.3s&#13;
Attaching to foodfinder-application, foodfinder-backend&#13;
foodfinder-application  |&#13;
foodfinder-application  | &gt; foodfinder-application@0.1.0 dev&#13;
foodfinder-application  | &gt; next dev&#13;
foodfinder-application  |&#13;
foodfinder-application  | ready - started server on 0.0.0.0:3000,&#13;
foodfinder-application  | url: foodfinder-application  | http://localhost:3000&#13;
foodfinder-application  | info  - Loaded env from /home/node/code/foodfinder-&#13;
foodfinder-application  | application/.env.local&#13;
</code></pre>&#13;
<p class="TX">If you visit <i>http://localhost:3000</i> in your browser, you should see the Next.js splash screen without having to start the Next.js application manually.</p>&#13;
<p class="TX">Note that, if you’re using Linux or macOS without being the administrator or root user, you’ll need to adjust the application service and the startup command. Because the Docker daemon runs as a root user by default, all files it creates require root privileges. Your regular user doesn’t have those and cannot access those files. To avoid these possible issues, modify your setup so that the Docker daemon transfers the ownership to your user. Start by adding the code in <a href="chapter11.xhtml#Lis11-5">Listing 11-5</a> to the application service in the <i>docker-compose</i> file.</p>&#13;
<span id="Lis11-5"/>&#13;
<pre class="pre-212"><code>services:&#13;
<var>--snip--</var>&#13;
    <b>application:</b>&#13;
<var>--snip--</var>&#13;
<b>        user: ${MY_USER}</b>&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 11-5: The</span> <span class="Futura_Std_Book_11">docker-compose.yml</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user</samp> <span class="Futura_Std_Book_Oblique_BI_11">property</span></p>&#13;
<p class="TX">We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">application</samp> service and use the environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MY_USER</samp> as the property’s value. Then we modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose</samp> commands so that, on startup, we add the current user’s user ID and group ID to this environment variable. Instead of a plain <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp> call, we use the following code:</p>&#13;
&#13;
<pre class="pre-213"><code>MY_USER=$(id -u):$(id -g) docker compose up</code></pre>&#13;
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> helper program to save the user ID and group ID in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">userid:groupid</samp> to our environment variable, which the <i>docker-compose</i> file then picks up. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-u</samp> flag returns the user ID, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp> flag returns the group ID.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H1" id="sec10"><span id="h1-69"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label=" Page 193. "/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">We’ve set up our local development environment with Docker containers. With the <i>docker-compose.yml</i> file we created in this chapter, we decoupled the application development from our local host system. Now we can switch our host systems and, at the same time, ensure that the Food Finder application always runs with the same Node.js version. In addition, we added a container running our MongoDB server, to which we’ll connect in the next chapter when we implement our application’s middleware.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>