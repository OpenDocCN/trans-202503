- en: Chapter 3. How Ruby Executes Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：Ruby 如何执行你的代码
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*YARV is not just a stack machine—it’s a double-stack machine!*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*YARV不仅仅是一个栈机器——它是一个双栈机器！*'
- en: Now that Ruby has tokenized, parsed, and compiled your code, it’s finally ready
    to execute it. But just how does it do that? We’ve seen how the Ruby compiler
    creates YARV (Yet Another Ruby Virtual Machine) instructions, but how does YARV
    actually run them? How does it track variables and return values and arguments?
    How does it implement `if` statements and other control structures?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Ruby 已经对你的代码进行了标记化、解析和编译，终于准备好执行它了。但它究竟是如何执行的呢？我们已经看到 Ruby 编译器是如何创建 YARV（又一个
    Ruby 虚拟机）指令的，但 YARV 是如何实际执行这些指令的呢？它是如何跟踪变量、返回值和参数的？它是如何实现 `if` 语句和其他控制结构的？
- en: Koichi Sasada and the Ruby core team designed YARV to use a stack pointer and
    a program counter—that is, to function like your computer’s actual microprocessor.
    In this chapter, I’ll examine the basics of YARV instructions; namely, how they
    pop arguments off of and push return values onto an internal stack. We’ll also
    see how YARV keeps track of your Ruby call stack along with its own internal stack.
    I’ll explain how Ruby accesses local variables and how it can find variables farther
    down your call stack using dynamic access. We’ll finish with a look at how Ruby
    implements special variables. In [Chapter 4](ch04.html "Chapter 4. Control Structures
    and Method Dispatch") I’ll continue the discussion of YARV by examining how it
    implements control structures and method dispatch.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Koichi Sasada 和 Ruby 核心团队设计了 YARV，使其使用栈指针和程序计数器——也就是说，像计算机的实际微处理器一样工作。在本章中，我将探讨
    YARV 指令的基础知识；具体来说，它们是如何从内部栈中弹出参数并将返回值推送到栈上的。我们还将看到 YARV 如何跟踪你的 Ruby 调用栈以及它自己的内部栈。我将解释
    Ruby 如何访问局部变量，以及它如何通过动态访问找到调用栈更深层次的变量。最后，我们将了解 Ruby 如何实现特殊变量。在[第 4 章](ch04.html
    "第 4 章：控制结构和方法调用")中，我将继续讨论 YARV，分析它是如何实现控制结构和方法分发的。
- en: Roadmap
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[YARV’s Internal Stack and Your Ruby Stack](ch03.html#yarvapostrophes_internal_stack_and_your
    "YARV’s Internal Stack and Your Ruby Stack")'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[YARV 的内部栈与你的 Ruby 栈](ch03.html#yarvapostrophes_internal_stack_and_your "YARV
    的内部栈与你的 Ruby 栈")'
- en: '[Stepping Through How Ruby Executes a Simple Script](ch03.html#stepping_through_how_ruby_executes_a_sim
    "Stepping Through How Ruby Executes a Simple Script")'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[逐步了解 Ruby 如何执行一个简单脚本](ch03.html#stepping_through_how_ruby_executes_a_sim "逐步了解
    Ruby 如何执行一个简单脚本")'
- en: '[Executing a Call to a Block](ch03.html#executing_a_call_to_a_block "Executing
    a Call to a Block")'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[执行对块的调用](ch03.html#executing_a_call_to_a_block "执行对块的调用")'
- en: '[Taking a Close Look at a YARV Instruction](ch03.html#taking_a_close_look_at_a_yarv_instructio
    "Taking a Close Look at a YARV Instruction")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[仔细查看 YARV 指令](ch03.html#taking_a_close_look_at_a_yarv_instructio "仔细查看 YARV
    指令")'
- en: '**[Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8](ch03.html#experiment_3-1_benchmarking_ruby_2dot0_a
    "Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8")**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 3-1：基准测试 Ruby 2.0 和 Ruby 1.9 与 Ruby 1.8 的性能](ch03.html#experiment_3-1_benchmarking_ruby_2dot0_a
    "实验 3-1：基准测试 Ruby 2.0 和 Ruby 1.9 与 Ruby 1.8 的性能")**'
- en: '[Local and Dynamic Access of Ruby Variables](ch03.html#local_and_dynamic_access_of_ruby_variabl
    "Local and Dynamic Access of Ruby Variables")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 变量的局部和动态访问](ch03.html#local_and_dynamic_access_of_ruby_variabl "Ruby
    变量的局部和动态访问")'
- en: '[Local Variable Access](ch03.html#local_variable_access "Local Variable Access")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[局部变量访问](ch03.html#local_variable_access "局部变量访问")'
- en: '[Method Arguments Are Treated Like Local Variables](ch03.html#method_arguments_are_treated_like_local
    "Method Arguments Are Treated Like Local Variables")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方法参数像局部变量一样处理](ch03.html#method_arguments_are_treated_like_local "方法参数像局部变量一样处理")'
- en: '[Dynamic Variable Access](ch03.html#dynamic_variable_access "Dynamic Variable
    Access")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[动态变量访问](ch03.html#dynamic_variable_access "动态变量访问")'
- en: '[Climbing the Environment Pointer Ladder in C](ch03.html#climbing_the_environment_pointer_ladder
    "Climbing the Environment Pointer Ladder in C")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 C 中爬升环境指针阶梯](ch03.html#climbing_the_environment_pointer_ladder "在 C 中爬升环境指针阶梯")'
- en: '**[Experiment 3-2: Exploring Special Variables](ch03.html#experiment_3-2_exploring_special_variabl
    "Experiment 3-2: Exploring Special Variables")**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 3-2：探索特殊变量](ch03.html#experiment_3-2_exploring_special_variabl "实验 3-2：探索特殊变量")**'
- en: '[A Definitive List of Special Variables](ch03.html#definitive_list_of_special_variables
    "A Definitive List of Special Variables")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[特殊变量的权威列表](ch03.html#definitive_list_of_special_variables "特殊变量的权威列表")'
- en: '[Summary](ch03.html#summary-id00011 "Summary")'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch03.html#summary-id00011 "总结")'
- en: YARV’s Internal Stack and Your Ruby Stack
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YARV的内部栈和你的Ruby栈
- en: As we’ll see in a moment, YARV uses a stack internally to track intermediate
    values, arguments, and return values. YARV is a stack-oriented virtual machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后会看到的，YARV在内部使用栈来追踪中间值、参数和返回值。YARV是一个栈导向的虚拟机。
- en: In addition to its own internal stack, YARV keeps track of your Ruby program’s
    *call stack*, recording which methods call which other methods, functions, blocks,
    lambdas, and so on. In fact, YARV is not just a stack machine—it’s a double-stack
    machine! It has to track the arguments and return values not only for its own
    internal instructions but also for your Ruby program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它自身的内部栈，YARV还会追踪你的Ruby程序的*调用栈*，记录哪些方法调用了哪些其他方法、函数、块、lambda等等。事实上，YARV不仅仅是一个栈机——它是一个双栈机！它不仅需要追踪自己内部指令的参数和返回值，还要追踪你Ruby程序的参数和返回值。
- en: '[Figure 3-1](ch03.html#some_of_yarvapostrophes_internal_registe "Figure 3-1. Some
    of YARV’s internal registers, including the program counter and stack pointer")
    shows YARV’s basic registers and internal stack.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-1](ch03.html#some_of_yarvapostrophes_internal_registe "图3-1. YARV的一些内部寄存器，包括程序计数器和栈指针")展示了YARV的基本寄存器和内部栈。'
- en: '![Some of YARV’s internal registers, including the program counter and stack
    pointer](httpatomoreillycomsourcenostarchimages1853939.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![YARV的一些内部寄存器，包括程序计数器和栈指针](httpatomoreillycomsourcenostarchimages1853939.png.jpg)'
- en: Figure 3-1. Some of YARV’s internal registers, including the program counter
    and stack pointer
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1. YARV的一些内部寄存器，包括程序计数器和栈指针
- en: YARV’s internal stack is on the left. The `SP` label is the *stack pointer*,
    or the location of the top of the stack. On the right are the instructions that
    YARV is executing. `PC` is the *program counter*, or the location of the current
    instruction.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: YARV的内部栈位于左侧。`SP`标签表示*栈指针*，即栈顶的位置。右侧是YARV正在执行的指令。`PC`是*程序计数器*，即当前指令的位置。
- en: You can see the YARV instructions that Ruby compiled from the `puts 2+2` example
    on the right side of [Figure 3-1](ch03.html#some_of_yarvapostrophes_internal_registe
    "Figure 3-1. Some of YARV’s internal registers, including the program counter
    and stack pointer"). YARV stores both the `SP` and `PC` registers in a C structure
    called `rb_control_frame_t`, along with a `type` field, the current value of Ruby’s
    `self` variable, and some other values not shown here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图3-1](ch03.html#some_of_yarvapostrophes_internal_registe "图3-1. YARV的一些内部寄存器，包括程序计数器和栈指针")的右侧看到Ruby从`puts
    2+2`示例编译出的YARV指令。YARV将`SP`和`PC`寄存器存储在一个名为`rb_control_frame_t`的C结构体中，同时还包含一个`type`字段、Ruby的`self`变量的当前值以及一些未在此展示的其他值。
- en: At the same time, YARV maintains another stack of these `rb_control_frame_t`
    structures, as shown in [Figure 3-2](ch03.html#yarv_keeps_track_of_your_ruby_call_stack
    "Figure 3-2. YARV keeps track of your Ruby call stack using a series of rb_control_frame_t
    structures.").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，YARV还维护着另一组`rb_control_frame_t`结构体栈，如[图3-2](ch03.html#yarv_keeps_track_of_your_ruby_call_stack
    "图3-2. YARV通过一系列rb_control_frame_t结构体来追踪你的Ruby调用栈.")所示。
- en: '![YARV keeps track of your Ruby call stack using a series of rb_control_frame_t
    structures.](httpatomoreillycomsourcenostarchimages1853941.png.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![YARV通过一系列rb_control_frame_t结构体来追踪你的Ruby调用栈。](httpatomoreillycomsourcenostarchimages1853941.png.jpg)'
- en: Figure 3-2. YARV keeps track of your Ruby call stack using a series of `rb_control_frame_t
    structures`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2. YARV通过一系列`rb_control_frame_t结构体`来追踪你的Ruby调用栈。
- en: This second stack of `rb_control_frame_t` structures represents the path that
    YARV has taken through your Ruby program, and YARV’s current location. In other
    words, this is your Ruby call stack—what you would see if you ran `puts caller`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二个`rb_control_frame_t`结构体栈代表了YARV在执行你的Ruby程序时的路径以及当前的位置。换句话说，这就是你的Ruby调用栈——如果你运行`puts
    caller`，你会看到的内容。
- en: The `CFP` pointer indicates the *current frame pointer*. Each stack frame in
    your Ruby program stack contains, in turn, a different value for the `self`, `PC`,
    and `SP` registers, as shown in [Figure 3-1](ch03.html#some_of_yarvapostrophes_internal_registe
    "Figure 3-1. Some of YARV’s internal registers, including the program counter
    and stack pointer"). The `type` field in each `rb_control_frame_t` structure indicates
    the type of code running at this level in your Ruby call stack. As Ruby calls
    into the methods, blocks, or other structures in your program, the type might
    be set to `METHOD`, `BLOCK`, or one of a few other values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`CFP`指针表示*当前帧指针*。你Ruby程序栈中的每一个栈帧依次包含不同的`self`、`PC`和`SP`寄存器的值，如[图3-1](ch03.html#some_of_yarvapostrophes_internal_registe
    "图3-1. YARV的内部寄存器，包括程序计数器和栈指针")所示。每个`rb_control_frame_t`结构中的`type`字段表示在Ruby调用栈的这个级别上正在运行的代码类型。当Ruby调用方法、块或其他程序结构时，`type`可能被设置为`METHOD`、`BLOCK`或其他一些值。'
- en: Stepping Through How Ruby Executes a Simple Script
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分步解析Ruby如何执行一个简单的脚本
- en: In order to help you understand this a bit better, here are a couple of examples.
    I’ll begin with the simple `2+2` example from [Chapter 1](ch01.html "Chapter 1. Tokenization
    and Parsing") and [Chapter 2](ch02.html "Chapter 2. Compilation"), shown again
    in [Example 3-1](ch03.html#one-line_ruby_program_that_weapostroph "Example 3-1. A
    one-line Ruby program that we’ll execute as an example").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地理解，下面是一些示例。我将从[第1章](ch01.html "第1章. 词法分析与解析")和[第2章](ch02.html "第2章.
    编译")中的简单`2+2`示例开始，并在[示例3-1](ch03.html#one-line_ruby_program_that_weapostroph "示例3-1.
    我们将执行的一个单行Ruby程序")中再次展示。
- en: Example 3-1. A one-line Ruby program that we’ll execute as an example
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-1. 我们将执行的一个单行Ruby程序
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This one-line Ruby script doesn’t have a Ruby call stack, so I’ll focus on the
    internal YARV stack for now. [Figure 3-3](ch03.html#on_the_left_is_yarvapostrophes_internal
    "Figure 3-3. On the left is YARV’s internal stack, and on the right is the compiled
    version of my puts 2+2 program.") shows how YARV will execute this script, beginning
    with the first instruction, `trace`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行的Ruby脚本没有Ruby调用栈，所以我现在将重点介绍YARV的内部栈。[图3-3](ch03.html#on_the_left_is_yarvapostrophes_internal
    "图3-3. 左侧是YARV的内部栈，右侧是我编译后的puts 2+2程序")展示了YARV如何执行该脚本，从第一条指令`trace`开始。
- en: '![On the left is YARV’s internal stack, and on the right is the compiled version
    of my puts 2+2 program.](httpatomoreillycomsourcenostarchimages1853943.png.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![左侧是YARV的内部栈，右侧是我编译后的puts 2+2程序。](httpatomoreillycomsourcenostarchimages1853943.png.jpg)'
- en: Figure 3-3. On the left is YARV’s internal stack, and on the right is the compiled
    version of my `puts 2+2` program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3. 左侧是YARV的内部栈，右侧是我编译后的`puts 2+2`程序。
- en: As you can see in [Figure 3-3](ch03.html#on_the_left_is_yarvapostrophes_internal
    "Figure 3-3. On the left is YARV’s internal stack, and on the right is the compiled
    version of my puts 2+2 program."), YARV starts the program counter (`PC`) at the
    first instruction, and initially the stack is empty. Now YARV will execute the
    `trace` instruction, incrementing the `PC` register, as shown in [Figure 3-4](ch03.html#ruby_executes_the_first_instructioncomma
    "Figure 3-4. Ruby executes the first instruction, trace.").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3-3](ch03.html#on_the_left_is_yarvapostrophes_internal "图3-3. 左侧是YARV的内部栈，右侧是我编译后的puts
    2+2程序")所示，YARV将程序计数器（`PC`）设置为第一条指令，最初栈是空的。接下来，YARV将执行`trace`指令，递增`PC`寄存器，如[图3-4](ch03.html#ruby_executes_the_first_instructioncomma
    "图3-4. Ruby执行第一条指令trace.")所示。
- en: '![Ruby executes the first instruction, trace.](httpatomoreillycomsourcenostarchimages1853945.png.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby执行第一条指令trace。](httpatomoreillycomsourcenostarchimages1853945.png.jpg)'
- en: Figure 3-4. Ruby executes the first instruction, `trace`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4. Ruby执行第一条指令`trace`。
- en: Ruby uses the `trace` instruction to support the `set_trace_func` feature. If
    you call `set_trace_func` and provide a function, Ruby will call it each time
    it executes a line of Ruby code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby使用`trace`指令来支持`set_trace_func`功能。如果你调用`set_trace_func`并提供一个函数，Ruby将在每次执行一行Ruby代码时调用它。
- en: Next, YARV executes `putself` and pushes the current value of `self` onto the
    stack, as shown in [Figure 3-5](ch03.html#putself_pushes_the_top_self_value_onto_t
    "Figure 3-5. putself pushes the top self value onto the stack.").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，YARV执行`putself`，并将当前`self`的值推入栈中，如[图3-5](ch03.html#putself_pushes_the_top_self_value_onto_t
    "图3-5. putself将顶部的self值推入栈中。")所示。
- en: '![putself pushes the top self value onto the stack.](httpatomoreillycomsourcenostarchimages1853947.png.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![putself 将顶层 `self` 值推入栈中。](httpatomoreillycomsourcenostarchimages1853947.png.jpg)'
- en: Figure 3-5. `putself` pushes the `top self` value onto the stack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5. `putself` 将 `top self` 值推入栈中。
- en: 'Because this simple script contains no Ruby objects or classes, the `self`
    pointer is set to the default `top self` object. This is an instance of the `Object`
    class that Ruby automatically creates when YARV starts. It serves as the receiver
    for method calls and the container for instance variables in the top-level scope.
    The `top self` object contains a single, predefined `to_s` method, which returns
    the string `main`. You can call this method by running the following command in
    the console:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个简单脚本不包含 Ruby 对象或类，`self` 指针被设置为默认的 `top self` 对象。这是 Ruby 在 YARV 启动时自动创建的
    `Object` 类的一个实例。它作为方法调用的接收者，并且作为顶层作用域中的实例变量容器。`top self` 对象包含一个预定义的 `to_s` 方法，它返回字符串
    `main`。你可以通过在控制台中运行以下命令来调用这个方法：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'YARV will use this `self` value on the stack when it executes the `opt_send_simple`
    instruction: `self` is the receiver of the `puts` method because I didn’t specify
    a receiver for this method call.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当 YARV 执行 `opt_send_simple` 指令时，它将使用栈中的 `self` 值：`self` 是 `puts` 方法的接收者，因为我没有为此方法调用指定接收者。
- en: Next, YARV executes `putobject 2`. It pushes the numeric value `2` onto the
    stack and increments the `PC` again, as shown in [Figure 3-6](ch03.html#ruby_pushes_the_value_2_onto_the_stackco
    "Figure 3-6. Ruby pushes the value 2 onto the stack, the receiver of the + method.").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，YARV 执行 `putobject 2`。它将数值 `2` 推入栈中，并再次增加 `PC`，如图 [3-6](ch03.html#ruby_pushes_the_value_2_onto_the_stackco
    "图 3-6. Ruby 将值 2 推入栈中，作为 `+` 方法的接收者。") 所示。
- en: '![Ruby pushes the value 2 onto the stack, the receiver of the + method.](httpatomoreillycomsourcenostarchimages1853949.png.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将值 2 推入栈中，作为 `+` 方法的接收者。](httpatomoreillycomsourcenostarchimages1853949.png.jpg)'
- en: Figure 3-6. Ruby pushes the value `2` onto the stack, the receiver of the `+`
    method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6. Ruby 将值 `2` 推入栈中，作为 `+` 方法的接收者。
- en: This is the first step of the receiver (arguments) operation pattern described
    in [How Ruby Compiles a Simple Script](ch02.html#how_ruby_compiles_a_simple_script
    "How Ruby Compiles a Simple Script"). First, Ruby pushes the receiver onto the
    internal YARV stack. In this example, the `Fixnum` object `2` is the receiver
    of the message/method `+`, which takes a single argument, also a `2`. Next, Ruby
    pushes the argument `2`, as shown in [Figure 3-7](ch03.html#ruby_pushes_another_value_2_onto_the_sta
    "Figure 3-7. Ruby pushes another value 2 onto the stack, the argument of the +
    method.").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接收者（参数）操作模式的第一步，描述在 [如何 Ruby 编译一个简单脚本](ch02.html#how_ruby_compiles_a_simple_script
    "如何 Ruby 编译一个简单脚本") 中。首先，Ruby 将接收者推入内部 YARV 栈中。在这个例子中，`Fixnum` 对象 `2` 是 `+` 消息/方法的接收者，它接受一个参数，也是
    `2`。接下来，Ruby 推入参数 `2`，如图 [3-7](ch03.html#ruby_pushes_another_value_2_onto_the_sta
    "图 3-7. Ruby 将另一个值 2 推入栈中，作为 `+` 方法的参数。") 所示。
- en: '![Ruby pushes another value 2 onto the stack, the argument of the + method.](httpatomoreillycomsourcenostarchimages1853951.png.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将另一个值 2 推入栈中，作为 `+` 方法的参数。](httpatomoreillycomsourcenostarchimages1853951.png.jpg)'
- en: Figure 3-7. Ruby pushes another value `2` onto the stack, the argument of the
    `+` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7. Ruby 将另一个值 `2` 推入栈中，作为 `+` 方法的参数。
- en: 'Finally, Ruby executes the `+` operation. In this case, `opt_plus` is an optimized
    instruction that will add two values: the receiver and the argument, as shown
    in [Figure 3-8](ch03.html#optunderscoreplus_instruction_calcul "Figure 3-8. The
    opt_plus instruction calculates 2 + 2 = 4.").'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Ruby 执行 `+` 操作。在这种情况下，`opt_plus` 是一条优化指令，将会加法运算两个值：接收者和参数，如图 [3-8](ch03.html#optunderscoreplus_instruction_calcul
    "图 3-8. `opt_plus` 指令计算 2 + 2 = 4.") 所示。
- en: '![The opt_plus instruction calculates 2 + 2 = 4.](httpatomoreillycomsourcenostarchimages1853953.png.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![`opt_plus` 指令计算 2 + 2 = 4。](httpatomoreillycomsourcenostarchimages1853953.png.jpg)'
- en: Figure 3-8. The `opt_plus` instruction calculates 2 + 2 = 4.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-8. `opt_plus` 指令计算 2 + 2 = 4。
- en: 'As you can see in [Figure 3-8](ch03.html#optunderscoreplus_instruction_calcul
    "Figure 3-8. The opt_plus instruction calculates 2 + 2 = 4."), the `opt_plus`
    instruction leaves the result, `4`, at the top of the stack. Now Ruby is perfectly
    positioned to execute the `puts` function call: The receiver `self` is first on
    the stack, and the single argument, `4`, is at the top of the stack. (I’ll describe
    how method lookup works in [Chapter 6](ch06.html "Chapter 6. Method Lookup and
    Constant Lookup").)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 3-8](ch03.html#optunderscoreplus_instruction_calcul "图 3-8. `opt_plus`
    指令计算 2 + 2 = 4")中看到的，`opt_plus` 指令将结果`4`保留在栈顶。现在，Ruby 完美地准备好执行 `puts` 函数调用：接收者
    `self` 位于栈的最底层，单一参数 `4` 位于栈顶。（我将在[第 6 章](ch06.html "第 6 章. 方法查找与常量查找")中描述方法查找的工作原理。）
- en: Next, [Figure 3-9](ch03.html#ruby_calls_the_puts_method_on_the_top_se "Figure 3-9. Ruby
    calls the puts method on the top self object.") shows what happens when Ruby executes
    the `puts` method call. As you can see, the `opt_send_simple` instruction leaves
    the return value, `nil`, at the top of the stack. Finally, Ruby executes the last
    instruction, `leave`, which finishes the execution of our simple, one-line Ruby
    program. Of course, when Ruby executes the `puts` call, the C code implementing
    the `puts` function will actually display the value `4` in the console output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[图 3-9](ch03.html#ruby_calls_the_puts_method_on_the_top_se "图 3-9. Ruby
    在 top self 对象上调用 `puts` 方法")展示了 Ruby 执行 `puts` 方法调用时发生的情况。如你所见，`opt_send_simple`
    指令将返回值 `nil` 留在栈顶。最后，Ruby 执行最后一条指令 `leave`，这完成了我们简单的一行 Ruby 程序的执行。当然，当 Ruby 执行
    `puts` 调用时，实际执行 `puts` 函数的 C 代码会在控制台输出中显示值 `4`。
- en: '![Ruby calls the puts method on the top self object.](httpatomoreillycomsourcenostarchimages1853955.png.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在 top self 对象上调用 `puts` 方法。](httpatomoreillycomsourcenostarchimages1853955.png.jpg)'
- en: Figure 3-9. Ruby calls the `puts` method on the `top self` object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9. Ruby 在 `top self` 对象上调用 `puts` 方法。
- en: Executing a Call to a Block
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行对块的调用
- en: Now let’s see how the Ruby call stack works. In [Example 3-2](ch03.html#this_example_program_calls_a_block_10_ti
    "Example 3-2. This example program calls a block 10 times."), a slightly more
    complicated example, you see a simple Ruby script that calls a block 10 times,
    printing out a string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看 Ruby 调用栈是如何工作的。在[示例 3-2](ch03.html#this_example_program_calls_a_block_10_ti
    "示例 3-2. 本示例程序调用块 10 次")中，您将看到一个稍微复杂一点的示例，这是一个简单的 Ruby 脚本，调用块 10 次，并打印出一个字符串。
- en: Example 3-2. This example program calls a block 10 times.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-2. 本示例程序调用块 10 次。
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s skip over a few steps and start where YARV is about to call the `times`
    method, as shown in [Figure 3-10](ch03.html#every_ruby_program_starts_with_these_two
    "Figure 3-10. Every Ruby program starts with these two control frames.").
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过一些步骤，直接开始从 YARV 即将调用 `times` 方法的位置，如[图 3-10](ch03.html#every_ruby_program_starts_with_these_two
    "图 3-10. 每个 Ruby 程序都从这两个控制帧开始")所示。
- en: '![Every Ruby program starts with these two control frames.](httpatomoreillycomsourcenostarchimages1853957.png.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![每个 Ruby 程序都从这两个控制帧开始。](httpatomoreillycomsourcenostarchimages1853957.png.jpg)'
- en: Figure 3-10. Every Ruby program starts with these two control frames.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-10. 每个 Ruby 程序都从这两个控制帧开始。
- en: On the left side of the diagram are the YARV instructions that Ruby is executing.
    On the right, you see two control frame structures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图中左侧显示的是 Ruby 正在执行的 YARV 指令。右侧则展示了两个控制帧结构。
- en: At the bottom of the stack, you see a control frame with the type set to `TOP`.
    Ruby always creates this frame first when starting a new program. At the top of
    the stack, at least initially, a frame of type `EVAL` corresponds to the top level
    or main scope of the Ruby script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈底，您会看到一个类型设置为 `TOP` 的控制帧。Ruby 在启动新程序时总是首先创建此帧。在栈顶，至少最初，类型为 `EVAL` 的帧对应于 Ruby
    脚本的顶层或主作用域。
- en: Next, Ruby calls the `times` message on the `Fixnum` object `10`—the receiver
    of the `times` message. When it does so, it adds a new level to the control frame
    stack, as shown in [Figure 3-11](ch03.html#ruby_uses_the_cfunc_frame_when_you_call
    "Figure 3-11. Ruby uses the CFUNC frame when you call built-in functions implemented
    in C.").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 调用 `Fixnum` 对象 `10` 上的 `times` 消息——`times` 消息的接收者。当 Ruby 这么做时，它在控制帧栈中添加了一个新的层级，如[图
    3-11](ch03.html#ruby_uses_the_cfunc_frame_when_you_call "图 3-11. Ruby 在调用 C 实现的内建函数时使用
    CFUNC 帧")所示。
- en: '![Ruby uses the CFUNC frame when you call built-in functions implemented in
    C.](httpatomoreillycomsourcenostarchimages1853959.png.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在调用 C 实现的内建函数时使用 CFUNC 帧。](httpatomoreillycomsourcenostarchimages1853959.png.jpg)'
- en: Figure 3-11. Ruby uses the `CFUNC` frame when you call built-in functions implemented
    in C.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-11. Ruby 在调用 C 实现的内建函数时使用 `CFUNC` 框架。
- en: This new entry (at the right of [Figure 3-11](ch03.html#ruby_uses_the_cfunc_frame_when_you_call
    "Figure 3-11. Ruby uses the CFUNC frame when you call built-in functions implemented
    in C.")) represents a new level in the program’s Ruby call stack, and the `CFP`
    pointer has moved up to point at the new control frame structure. Also, notice
    that because the `Integer#times` method is built into Ruby, there are no YARV
    instructions for it. Instead, Ruby will call some internal C code to pop the argument
    `10` off the stack and call the provided block 10 times. Ruby gives this control
    frame a type of `CFUNC`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新条目（位于[图 3-11](ch03.html#ruby_uses_the_cfunc_frame_when_you_call "图 3-11.
    Ruby 在调用 C 实现的内建函数时使用 CFUNC 框架")的右侧）表示程序 Ruby 调用堆栈中的一个新级别，`CFP` 指针已上移，指向新的控制框架结构。此外，注意到由于
    `Integer#times` 方法是 Ruby 内建的，因此没有针对它的 YARV 指令。相反，Ruby 会调用一些内部 C 代码，从堆栈中弹出参数 `10`，并调用提供的块
    10 次。Ruby 给这个控制框架的类型是 `CFUNC`。
- en: Finally, [Figure 3-12](ch03.html#cfp_stack_when_we_pause_the_code_fro "Figure 3-12. The
    CFP stack when we pause the code from Example 3-2 inside the block") shows what
    the YARV and control frame stacks will look like if we interrupt the program inside
    the inner block.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[图 3-12](ch03.html#cfp_stack_when_we_pause_the_code_fro "图 3-12. 当我们在示例 3-2
    的块内部暂停代码时的 CFP 堆栈") 显示了如果我们在内部块暂停程序时，YARV 和控制框架堆栈的样子。
- en: '![The CFP stack when we pause the code from inside the block](httpatomoreillycomsourcenostarchimages1853961.png.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![当我们在块内部暂停代码时的CFP堆栈](httpatomoreillycomsourcenostarchimages1853961.png.jpg)'
- en: Figure 3-12. The `CFP` stack when we pause the code from [Example 3-2](ch03.html#this_example_program_calls_a_block_10_ti
    "Example 3-2. This example program calls a block 10 times.") inside the block
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-12. 当我们在 [示例 3-2](ch03.html#this_example_program_calls_a_block_10_ti "示例
    3-2. 这个示例程序调用块 10 次。") 的块内部暂停代码时的 `CFP` 堆栈
- en: 'There will now be four entries, as follows, in the control frame stack on the
    right:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，控制框架堆栈右侧将有四个条目，如下所示：
- en: The `TOP` and `EVAL` frames that Ruby always starts with
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 启动时总是存在的 `TOP` 和 `EVAL` 框架
- en: The `CFUNC` frame for the call to `10.times`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `10.times` 的 `CFUNC` 框架
- en: A `BLOCK` frame at the top of the stack that corresponds to the code running
    inside the block
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈顶部的 `BLOCK` 框架，表示块内部运行的代码
- en: Taking a Close Look at a YARV Instruction
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看一个 YARV 指令
- en: As it does with most other things, Ruby implements all YARV instructions, like
    `putobject` or `send`, using C code that is then compiled into machine language
    and executed directly by your hardware. Strangely, however, you won’t find the
    C source code for each YARV instruction in a C source file. Instead, the Ruby
    core team put the YARV-instruction C code in a single large file called `insns.def`.
    [Example 3-3](ch03.html#definition_of_the_putself_yarv_instr "Example 3-3. The
    definition of the putself YARV instruction") shows a small snippet from *insns.def*,
    where Ruby implements the `putself` YARV instruction internally.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 和处理其他大多数事物一样，Ruby 使用 C 代码实现所有 YARV 指令，如 `putobject` 或 `send`，然后将其编译为机器语言，直接由硬件执行。然而，奇怪的是，您不会在
    C 源文件中找到每个 YARV 指令的 C 源代码。相反，Ruby 核心团队将 YARV 指令的 C 代码放在一个名为 `insns.def` 的大文件中。[示例
    3-3](ch03.html#definition_of_the_putself_yarv_instr "示例 3-3. putself YARV 指令的定义")
    显示了 *insns.def* 中的一小段代码，Ruby 在其中实现了 `putself` YARV 指令。
- en: Example 3-3. The definition of the *`putself`* YARV instruction
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-3. *`putself`* YARV 指令的定义
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This doesn’t look like C at all and, in fact, most of it is not. Instead, what
    you see here is a bit of C code (`val = GET_SELF()`) at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    that appears below a call to `DEFINE_INSN`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来根本不像 C，实际上，大部分内容不是 C 代码。相反，您在这里看到的是一些 C 代码（`val = GET_SELF()`），出现在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    下方，紧跟在 `DEFINE_INSN` 调用之后。
- en: It’s not hard to figure out that `DEFINE_INSN` stands for *define instruction*.
    In fact, Ruby processes and converts the *insns.def* file into real C code during
    the Ruby build process, similar to the way that Bison converts the *parse.y* file
    into *parse.c*, as shown in [Figure 3-13](ch03.html#ruby_compiles_the_yarv-instruction_defin
    "Figure 3-13. Ruby compiles the YARV-instruction definition script insns.def into
    C code during the Ruby build process.").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFINE_INSN` 代表 *定义指令*，这并不难理解。事实上，在 Ruby 构建过程中，Ruby 会处理并将 *insns.def* 文件转换为真正的
    C 代码，这类似于 Bison 将 *parse.y* 文件转换为 *parse.c*，如 [图 3-13](ch03.html#ruby_compiles_the_yarv-instruction_defin
    "图 3-13. Ruby 在构建过程中将 YARV 指令定义脚本 insns.def 编译成 C 代码。") 所示。'
- en: '![Ruby compiles the YARV-instruction definition script insns.def into C code
    during the Ruby build process.](httpatomoreillycomsourcenostarchimages1853963.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在构建过程中将 YARV 指令定义脚本 insns.def 编译成 C 代码。](httpatomoreillycomsourcenostarchimages1853963.png.jpg)'
- en: Figure 3-13. Ruby compiles the YARV-instruction definition script *`insns.def`*
    into C code during the Ruby build process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-13：Ruby 在构建过程中将 YARV 指令定义脚本 *`insns.def`* 编译成 C 代码。
- en: 'Ruby processes the *insns.def* file using Ruby: The build process first compiles
    a smaller version of Ruby called *Miniruby* and then uses this to run some Ruby
    code that processes *insns.def* and converts it into a C source code file called
    *vm.inc*. Later the Ruby build process hands *vm.inc* to the C compiler, which
    includes the generated C code in the final, compiled version of Ruby.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用 Ruby 处理 *insns.def* 文件：构建过程首先编译一个称为 *Miniruby* 的较小版本，然后使用它运行一些 Ruby
    代码，这些代码处理 *insns.def* 并将其转换为一个名为 *vm.inc* 的 C 源代码文件。稍后，Ruby 构建过程将 *vm.inc* 交给
    C 编译器，C 编译器将生成的 C 代码包含在 Ruby 最终的编译版本中。
- en: '[Example 3-4](ch03.html#definition_of_putself_is_transformed "Example 3-4. The
    definition of putself is transformed into this C code during the Ruby build process.")
    shows what the snippet for `putself` looks like in *vm.inc* once Ruby has processed
    it.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-4](ch03.html#definition_of_putself_is_transformed "示例 3-4. `putself`
    的定义在 Ruby 构建过程中被转换成这段 C 代码。") 展示了 Ruby 处理后，*vm.inc* 中 `putself` 的代码片段样子。'
- en: Example 3-4. The definition of `putself` is transformed into this C code during
    the Ruby build process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-4：`putself` 的定义在 Ruby 构建过程中被转换成这段 C 代码。
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The single line `val = GET_SELF()` appears in the middle of the listing at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    Above and below this line, Ruby calls a few different C macros to do various things,
    like add `1` to the program counter (`PC`) register at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and push the `val` value onto the YARV internal stack at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
    If you look through *vm.inc*, you’ll see this same C code repeated over and over
    again for the definition of each YARV instruction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 单行代码 `val = GET_SELF()` 出现在列表的中间位置，如图所示 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。在这行代码的上下，Ruby
    调用了几个不同的 C 宏来执行各种操作，比如在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    处将 `1` 加到程序计数器（`PC`）寄存器中，以及在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    处将 `val` 值推送到 YARV 内部堆栈中。如果你查看 *vm.inc*，你会看到这段 C 代码会为每个 YARV 指令的定义重复多次。
- en: The *vm.inc* C source code file, in turn, is included by the *vm_exec.c* file,
    which contains the primary YARV instruction loop that steps through the YARV instructions
    in your program one after another and calls the C code corresponding to each one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*vm.inc* C 源代码文件，又被 *vm_exec.c* 文件包含，该文件包含了主要的 YARV 指令循环，逐条执行程序中的 YARV 指令，并调用每个指令对应的
    C 代码。'
- en: 'Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8'
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 3-1：基准测试 Ruby 2.0 与 Ruby 1.9 和 Ruby 1.8 的性能
- en: 'The Ruby core team introduced the YARV virtual machine with Ruby 1.9\. Earlier
    versions of Ruby executed programs by directly stepping through the nodes of the
    *abstract syntax tree (AST)*. There was no compile step: Ruby just tokenized,
    parsed, and then immediately executed your code.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 核心团队在 Ruby 1.9 中引入了 YARV 虚拟机。更早版本的 Ruby 通过直接遍历 *抽象语法树（AST）* 的节点来执行程序。当时没有编译步骤：Ruby
    只是将代码分词、解析，然后立即执行。
- en: Ruby 1.8 worked just fine. In fact, for years it was the most commonly used
    version. Then why did the Ruby core team do all of the extra work required to
    write a compiler and a new virtual machine? Speed. Executing a compiled Ruby program
    using YARV is much faster than walking through the AST directly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.8 运行得非常顺畅。事实上，多年来它一直是最常用的版本。那么，为什么 Ruby 核心团队要额外编写一个编译器和新的虚拟机呢？答案是：速度。使用
    YARV 执行已编译的 Ruby 程序比直接遍历抽象语法树（AST）要快得多。
- en: How much faster is YARV? Let’s take a look! In this experiment, we’ll measure
    how much faster Ruby 2.0 and 1.9 are compared to Ruby 1.8 by executing the very
    simple Ruby script shown in [Example 3-5](ch03.html#simple_test_script_for_benchmarking_ru
    "Example 3-5. A simple test script for benchmarking Ruby 2.0 and Ruby 1.9 vs.
    Ruby 1.8").
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: YARV 快多少？让我们来看看！在这个实验中，我们将通过执行[示例 3-5](ch03.html#simple_test_script_for_benchmarking_ru
    "示例 3-5。用于基准测试 Ruby 2.0 和 Ruby 1.9 相对于 Ruby 1.8 的简单测试脚本")中显示的非常简单的 Ruby 脚本，测量
    Ruby 2.0 和 1.9 相较于 Ruby 1.8 的执行速度。
- en: Example 3-5. A simple test script for benchmarking Ruby 2.0 and Ruby 1.9 vs.
    Ruby 1.8
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-5。用于基准测试 Ruby 2.0 和 Ruby 1.9 相对于 Ruby 1.8 的简单测试脚本
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This script receives a count value from the command line via the `ARGV` array
    and then just iterates in a `while` loop counting up to that value. This Ruby
    script is very, very simple: By measuring the time it takes to execute this script
    for different values of `ARGV[0]`, we should get a good sense of whether executing
    YARV instructions is actually faster than iterating over AST nodes. (There are
    no database calls or other external code involved.)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本从命令行通过`ARGV`数组接收一个计数值，然后在一个`while`循环中迭代，直到达到该值。这个 Ruby 脚本非常简单：通过测量在不同的`ARGV[0]`值下执行该脚本所需的时间，我们应该能很好地判断执行
    YARV 指令是否比迭代 AST 节点更快。（没有涉及数据库调用或其他外部代码。）
- en: 'We can use the Unix `time` command to measure how long it takes Ruby to iterate
    one time:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Unix 的`time`命令来测量 Ruby 执行一次迭代所需的时间：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'ten times:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 十次：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。
- en: '[Figure 3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby "Figure 3-14. Performance
    of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations
    on a logarithmic scale") shows a plot of the measured times on a logarithmic scale
    for Ruby 1.8.7, 1.9.3, and 2.0.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby "图 3-14。Ruby 1.8.7
    与 Ruby 1.9.3 和 Ruby 2.0 的性能对比；时间（秒）与迭代次数的对数坐标图") 显示了 Ruby 1.8.7、1.9.3 和 2.0 在对数坐标图上的测量时间。'
- en: '![Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds)
    vs. number of iterations on a logarithmic scale](httpatomoreillycomsourcenostarchimages1853965.png.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 1.8.7 与 Ruby 1.9.3 和 Ruby 2.0 的性能对比；时间（秒）与迭代次数的对数坐标图](httpatomoreillycomsourcenostarchimages1853965.png.jpg)'
- en: Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in
    seconds) vs. number of iterations on a logarithmic scale
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-14。Ruby 1.8.7 与 Ruby 1.9.3 和 Ruby 2.0 的性能对比；时间（秒）与迭代次数的对数坐标图
- en: Looking at the chart, you can see that for short-lived processes, such as loops
    with a small number of iterations (see the left side of [Figure 3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby
    "Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in
    seconds) vs. number of iterations on a logarithmic scale")), Ruby 1.8.7 is actually
    faster than Ruby 1.9.3 and 2.0 because there is no need to compile the Ruby code
    into YARV instructions. Instead, after tokenizing and parsing the code, Ruby 1.8.7
    immediately executes it. The time difference between Ruby 1.8.7 and Ruby 1.9.3
    and 2.0 at the left side of the chart, about 0.01 seconds, tells us how long it
    takes Ruby 1.9.3 or 2.0 to compile the script into YARV instructions. You can
    also see that Ruby 2.0 is actually a bit slower than Ruby 1.9.3 for short loops.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表来看，你可以看到对于短生命周期的进程，比如迭代次数较少的循环（参见[图 3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby
    "图 3-14。Ruby 1.8.7 与 Ruby 1.9.3 和 Ruby 2.0 的性能对比；时间（秒）与迭代次数的对数坐标图")的左侧部分），Ruby
    1.8.7 实际上比 Ruby 1.9.3 和 2.0 更快，因为不需要将 Ruby 代码编译成 YARV 指令。相反，在对代码进行词法分析和语法解析后，Ruby
    1.8.7 立即执行它。图表左侧 Ruby 1.8.7 和 Ruby 1.9.3、2.0 之间的时间差，大约是 0.01 秒，告诉我们 Ruby 1.9.3
    或 2.0 需要多长时间将脚本编译成 YARV 指令。你还可以看到，Ruby 2.0 实际上比 Ruby 1.9.3 在短循环中的执行速度稍慢。
- en: However, after about 11,000 iterations, Ruby 1.9.3 and 2.0 are faster. This
    crossover occurs when the additional speed provided by executing YARV instructions
    begins to pay off and make up for the additional time spent compiling. For long-lived
    processes, such as loops with a large number of iterations (see the right side
    of [Figure 3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby "Figure 3-14. Performance
    of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations
    on a logarithmic scale")), Ruby 1.9 and 2.0 are about 4.25 times faster! Also,
    we can see that Ruby 2.0 and 1.9.3 execute YARV instructions at exactly the same
    speed for many iterations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在约11,000次迭代后，Ruby 1.9.3 和 2.0 的速度更快。这个交叉点出现在通过执行 YARV 指令提供的额外速度开始发挥作用，并弥补了编译时所花费的额外时间。对于长时间运行的进程，例如包含大量迭代的循环（见
    [图3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby "图3-14. Ruby 1.8.7
    与 Ruby 1.9.3 和 Ruby 2.0 性能对比；时间（秒）与迭代次数的对数刻度")), Ruby 1.9 和 2.0 的速度约为原来的4.25倍！此外，我们可以看到，Ruby
    2.0 和 1.9.3 在许多迭代中执行 YARV 指令的速度完全相同。
- en: This speed up doesn’t look like much on the logarithmic chart in [Figure 3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby
    "Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in
    seconds) vs. number of iterations on a logarithmic scale"), but notice what happens
    if we redraw the right side of this chart using a linear scale instead, as shown
    in [Figure 3-15](ch03.html#performance_of_ruby_1dot8dot7_vs-id00010 "Figure 3-15. Performance
    of Ruby 1.8.7 vs. Ruby 1.9.3 vs. Ruby 2.0; time (in seconds) for 10 or 100 million
    iterations on a linear scale").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图3-14](ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby "图3-14. Ruby 1.8.7
    与 Ruby 1.9.3 和 Ruby 2.0 性能对比；时间（秒）与迭代次数的对数刻度") 中，这一速度提升在对数图表上看起来并不显著，但如果我们改用线性刻度重新绘制图表的右侧，就像在
    [图3-15](ch03.html#performance_of_ruby_1dot8dot7_vs-id00010 "图3-15. Ruby 1.8.7
    与 Ruby 1.9.3 与 Ruby 2.0 性能对比；时间（秒）为 10 亿或 1 亿次迭代的线性刻度") 中所示，效果就很明显了。
- en: '![Performance of Ruby 1.8.7 vs. Ruby 1.9.3 vs. Ruby 2.0; time (in seconds)
    for 10 or 100 million iterations on a linear scale](httpatomoreillycomsourcenostarchimages1853967.png.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 1.8.7 与 Ruby 1.9.3 与 Ruby 2.0 性能对比；10亿或1亿次迭代的时间（以秒为单位），使用线性刻度](httpatomoreillycomsourcenostarchimages1853967.png.jpg)'
- en: Figure 3-15. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 vs. Ruby 2.0; time (in
    seconds) for 10 or 100 million iterations on a linear scale
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-15. Ruby 1.8.7 与 Ruby 1.9.3 与 Ruby 2.0 性能对比；10亿或1亿次迭代的时间（以秒为单位），使用线性刻度
- en: The difference is dramatic! Executing this simple Ruby script using Ruby 1.9.3
    or Ruby 2.0 with YARV is about 4.25 times faster than it is using Ruby 1.8.7 without
    YARV.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 差异非常明显！使用 Ruby 1.9.3 或 Ruby 2.0 和 YARV 执行这个简单的 Ruby 脚本，比使用没有 YARV 的 Ruby 1.8.7
    快大约 4.25 倍。
- en: Local and Dynamic Access of Ruby Variables
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby 变量的局部与动态访问
- en: 'In the previous section, we saw how Ruby maintained an internal stack used
    by YARV as well as your Ruby program’s call stack. But something obvious was missing
    from both of the code examples: variables. Neither script used any Ruby variables.
    A more realistic example program would have used variables many times. How does
    Ruby handle variables internally? And where are they stored?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到 Ruby 维护了 YARV 使用的内部栈以及你的 Ruby 程序调用栈。但在这两个代码示例中，显然有一样东西被遗漏了：变量。两个脚本都没有使用任何
    Ruby 变量。一个更现实的示例程序会多次使用变量。那么 Ruby 如何在内部处理变量？它们存储在哪里？
- en: 'Ruby stores all of the values you save in variables on YARV’s stack, along
    with the parameters to and return values from the YARV instructions. However,
    accessing these variables is not so simple. Internally, Ruby uses two very different
    methods for saving and retrieving a value you save in a variable: *local access*
    and *dynamic access*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 将你保存在变量中的所有值存储在 YARV 的栈上，连同 YARV 指令的参数和返回值。然而，访问这些变量并不简单。Ruby 在内部使用两种非常不同的方法来保存和检索你保存在变量中的值：*局部访问*
    和 *动态访问*。
- en: Local Variable Access
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局部变量访问
- en: Whenever you make a method call, Ruby sets aside some space on the YARV stack
    for any local variables declared inside the method you are calling. Ruby knows
    how many variables you are using by consulting the *local table* created for each
    method during the compilation step discussed in [The Local Table](ch02.html#local_table
    "The Local Table").
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你进行方法调用时，Ruby 会在 YARV 栈上为你调用的该方法中的任何局部变量预留空间。Ruby 通过查阅在编译步骤中为每个方法创建的 *局部表*
    来知道你使用了多少变量，详见 [局部表](ch02.html#local_table "局部表")。
- en: For example, suppose we write the silly Ruby function you see in [Figure 3-16](ch03.html#example_ruby_script_that_uses_a_local
    "Figure 3-16. An example Ruby script that uses a local variable").
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们编写了你在[图 3-16](ch03.html#example_ruby_script_that_uses_a_local "图 3-16.
    使用局部变量的示例 Ruby 脚本")中看到的那个傻乎乎的 Ruby 函数。
- en: '![An example Ruby script that uses a local variable](httpatomoreillycomsourcenostarchimages1853969.png.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![使用局部变量的示例 Ruby 脚本](httpatomoreillycomsourcenostarchimages1853969.png.jpg)'
- en: Figure 3-16. An example Ruby script that uses a local variable
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-16. 使用局部变量的示例 Ruby 脚本
- en: The Ruby code is at the left of the figure; on the right is a diagram showing
    the YARV stack and stack pointer. You can see that Ruby stores the variables on
    the stack just under the stack pointer. (Notice that a space is reserved for the
    `str` value on the stack, three slots under `SP`, at `SP-3`.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 代码位于图形的左侧；右侧是一个展示 YARV 栈和栈指针的示意图。你可以看到，Ruby 将变量保存在栈上，位于栈指针下方。（请注意，栈上为 `str`
    值预留了一个空间，位于栈指针下方的三个槽，即 `SP-3`。）
- en: 'Ruby uses `svar/cref` to contain one of two things: either a pointer to a table
    of the special variables in the current method (values such as `$!` for *last
    exception message* or `$&` for *last regular expression match*) or to the current
    lexical scope. *Lexical scope* indicates which class or module you are currently
    adding methods to. (In [Experiment 3-2: Exploring Special Variables](ch03.html#experiment_3-2_exploring_special_variabl
    "Experiment 3-2: Exploring Special Variables") we’ll explore special variables
    in more detail, and I’ll discuss lexical scope further in [Chapter 6](ch06.html
    "Chapter 6. Method Lookup and Constant Lookup").) Ruby uses the first slot—the
    `special` variable—to track information related to blocks. (More in a moment when
    we discuss dynamic variable access.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用 `svar/cref` 来包含以下两者之一：要么是指向当前方法中特殊变量表的指针（例如，`$!` 表示 *最后的异常消息*，`$&` 表示
    *最后的正则表达式匹配*），要么是指向当前词法作用域的指针。*词法作用域* 表示你当前正在为哪个类或模块添加方法。（在[实验 3-2：探索特殊变量](ch03.html#experiment_3-2_exploring_special_variabl
    "实验 3-2：探索特殊变量")中，我们将更详细地探索特殊变量，而在[第 6 章](ch06.html "第 6 章. 方法查找与常量查找")中，我会进一步讨论词法作用域。）Ruby
    使用第一个槽——`special` 变量——来跟踪与块相关的信息。（稍后我们将讨论动态变量访问时进一步讲解。）
- en: When the example code saves a value into `str`, Ruby just needs to write the
    value into that space on the stack, as shown in [Figure 3-17](ch03.html#ruby_saves_local_variables_on_its_stack
    "Figure 3-17. Ruby saves local variables on its stack near the environment pointer
    (EP).").
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当示例代码将一个值保存到 `str` 时，Ruby 只需要将该值写入栈上的相应空间，如[图 3-17](ch03.html#ruby_saves_local_variables_on_its_stack
    "图 3-17. Ruby 将局部变量保存在栈上，接近环境指针（EP）。")所示。
- en: '![Ruby saves local variables on its stack near the environment pointer (EP).](httpatomoreillycomsourcenostarchimages1853971.png.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将局部变量保存在栈上，接近环境指针（EP）。](httpatomoreillycomsourcenostarchimages1853971.png.jpg)'
- en: Figure 3-17. Ruby saves local variables on its stack near the environment pointer
    (EP).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-17. Ruby 将局部变量保存在栈上，接近环境指针（EP）。
- en: To implement this internally, YARV uses another pointer similar to the stack
    pointer, called the `EP` or *environment pointer*. This points to where the local
    variables for the current method are located on the stack. Initially, `EP` is
    set to `SP-1`. Later on, the value of `SP` will change as YARV executes instructions,
    while the `EP` value will normally remain constant.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在内部实现这一点，YARV 使用了一个类似于栈指针的指针，称为 `EP` 或 *环境指针*。它指向当前方法的局部变量在栈上的位置。最初，`EP` 设置为
    `SP-1`。随着 YARV 执行指令，`SP` 的值会变化，而 `EP` 的值通常保持不变。
- en: '[Figure 3-18](ch03.html#displayunderscorestring_method_compi "Figure 3-18. The
    display_string method compiled into YARV instructions") shows the YARV instructions
    that Ruby compiled my `display_string` function into.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-18](ch03.html#displayunderscorestring_method_compi "图 3-18. `display_string`
    方法编译成 YARV 指令") 展示了 Ruby 将我的 `display_string` 函数编译成的 YARV 指令。'
- en: '![The display_string method compiled into YARV instructions](httpatomoreillycomsourcenostarchimages1853973.png.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![display_string 方法编译成 YARV 指令](httpatomoreillycomsourcenostarchimages1853973.png.jpg)'
- en: Figure 3-18. The `display_string` method compiled into YARV instructions
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-18. `display_string` 方法编译成 YARV 指令
- en: Ruby uses the `setlocal` YARV instruction to set the value of a local variable.
    However, instead of `setlocal` in [Figure 3-18](ch03.html#displayunderscorestring_method_compi
    "Figure 3-18. The display_string method compiled into YARV instructions"), I show
    an instruction called `setlocal_OP__WC__0`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用 `setlocal` YARV 指令来设置局部变量的值。然而，在[图 3-18](ch03.html#displayunderscorestring_method_compi
    "图 3-18. 显示字符串方法编译成 YARV 指令")中，我展示了一条名为 `setlocal_OP__WC__0` 的指令，而不是 `setlocal`。
- en: As it turns out, beginning with version 2.0, Ruby uses an optimized instruction
    with this confusing name instead of the simple `setlocal`. The difference is that
    Ruby 2.0 includes one of the parameters of the instruction, `0`, in the instruction
    name itself.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，从 2.0 版本开始，Ruby 使用一个优化过的指令，这个令人困惑的名字代替了简单的 `setlocal`。不同之处在于，Ruby 2.0 将指令的一个参数
    `0` 包含在了指令名称本身中。
- en: Internally, Ruby 2.0 calls this the *operand* optimization. (In the optimized
    instruction name, *OP* stands for *operand* and *WC* for *wildcard*.) In other
    words, `getlocal_OP__WC__0` is equivalent to `getlocal *, 0`, and `setlocal_OP__WC__0`
    is the same as `setlocal *, 0`. The instruction now requires only one parameter,
    as indicated by `*`. This trick allows Ruby 2.0 to save a bit of time because
    it doesn’t need to pass the `0` argument separately.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从内部来看，Ruby 2.0 将此称为 *操作数* 优化。（在优化后的指令名称中，*OP* 代表 *操作数*，*WC* 代表 *通配符*。）换句话说，`getlocal_OP__WC__0`
    等同于 `getlocal *, 0`，而 `setlocal_OP__WC__0` 与 `setlocal *, 0` 相同。现在，该指令只需要一个参数，如
    `*` 所示。这个技巧使得 Ruby 2.0 节省了一些时间，因为它不需要单独传递 `0` 作为参数。
- en: But to keep things simple, let’s ignore the operand optimization. [Figure 3-19](ch03.html#compiled_version_of_displayunderscor
    "Figure 3-19. The compiled version of display_string shown without operand optimization")
    repeats the YARV instructions for my example but shows `getlocal` and `setlocal`
    with the second operand listed normally.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了简化问题，我们暂时忽略操作数优化。[图 3-19](ch03.html#compiled_version_of_displayunderscor
    "图 3-19. 未进行操作数优化时显示字符串的编译版本") 重复了我的例子的 YARV 指令，但显示了 `getlocal` 和 `setlocal`，并且第二个操作数是正常列出的。
- en: '![The compiled version of display_string shown without operand optimization](httpatomoreillycomsourcenostarchimages1853975.png.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![未进行操作数优化时显示字符串的编译版本](httpatomoreillycomsourcenostarchimages1853975.png.jpg)'
- en: Figure 3-19. The compiled version of `display_string` shown without operand
    optimization
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-19. 未进行操作数优化时的 `display_string` 编译版本
- en: This a bit easier to understand. As you can see, first the `putstring` instruction
    saves the `Local access` string on top of the stack, incrementing the `SP` pointer.
    Then, YARV uses the `setlocal` instruction to get the value at the top of the
    stack and save it in the space allocated on the stack for the `str` local variable.
    The two dashed arrows on the left side of [Figure 3-19](ch03.html#compiled_version_of_displayunderscor
    "Figure 3-19. The compiled version of display_string shown without operand optimization")
    show the `setlocal` instruction copying the value. This type of operation is called
    *local variable access*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更容易理解。正如你所看到的，首先，`putstring` 指令将 `Local access` 字符串保存在栈顶，并增加 `SP` 指针。然后，YARV
    使用 `setlocal` 指令获取栈顶的值，并将其保存在栈上为 `str` 局部变量分配的空间中。[图 3-19](ch03.html#compiled_version_of_displayunderscor
    "图 3-19. 未进行操作数优化时显示字符串的编译版本") 左侧的两个虚线箭头显示了 `setlocal` 指令复制值的过程。这种操作叫做 *局部变量访问*。
- en: To determine which variable to set, `setlocal` uses the `EP` pointer and the
    numerical index provided as the first parameter. In this example, that would be
    `address of str = EP-2`. We’ll discuss what the second parameter, `0`, means in
    [Dynamic Variable Access](ch03.html#dynamic_variable_access "Dynamic Variable
    Access").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定设置哪个变量，`setlocal` 使用 `EP` 指针和作为第一个参数提供的数字索引。在本例中，这将是 `str 的地址 = EP-2`。我们将在[动态变量访问](ch03.html#dynamic_variable_access
    "动态变量访问")中讨论第二个参数 `0` 的含义。
- en: Next, for the call to `puts str`, Ruby uses the `getlocal` instruction, as shown
    in [Figure 3-20](ch03.html#getting_the_value_of_a_local_variable_us "Figure 3-20. Getting
    the value of a local variable using getlocal").
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于 `puts str` 的调用，Ruby 使用 `getlocal` 指令，如[图 3-20](ch03.html#getting_the_value_of_a_local_variable_us
    "图 3-20. 使用 getlocal 获取局部变量的值")所示。
- en: '![Getting the value of a local variable using getlocal](httpatomoreillycomsourcenostarchimages1853977.png.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用 getlocal 获取局部变量的值](httpatomoreillycomsourcenostarchimages1853977.png.jpg)'
- en: Figure 3-20. Getting the value of a local variable using `getlocal`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-20. 使用 `getlocal` 获取局部变量的值
- en: Here, Ruby has pushed the string value back onto the top of the stack, where
    it can be used as an argument for the call to the `puts` function. Again, the
    first parameter to `getlocal`, `2`, indicates which local variable to access.
    Ruby uses the local table for this snippet to find out `2` corresponds to the
    variable `str`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Ruby 将字符串值推送回栈顶，可以作为调用 `puts` 函数的参数使用。同样，`getlocal` 的第一个参数 `2` 表示访问哪个局部变量。Ruby
    使用局部变量表来查找 `2` 对应的是变量 `str`。
- en: Method Arguments Are Treated Like Local Variables
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法参数像局部变量一样处理
- en: Passing in a *method argument* works the same way as accessing a local variable,
    as shown in [Figure 3-21](ch03.html#ruby_stores_method_arguments_on_the_stac "Figure 3-21. Ruby
    stores method arguments on the stack just like local variables.").
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个*方法参数*的方式与访问局部变量相同，如[图 3-21](ch03.html#ruby_stores_method_arguments_on_the_stac
    "图 3-21. Ruby 像处理局部变量一样将方法参数保存在栈上。")所示。
- en: '![Ruby stores method arguments on the stack just like local variables.](httpatomoreillycomsourcenostarchimages1853979.png.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 像处理局部变量一样将方法参数保存在栈上。](httpatomoreillycomsourcenostarchimages1853979.png.jpg)'
- en: Figure 3-21. Ruby stores method arguments on the stack just like local variables.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-21. Ruby 像处理局部变量一样将方法参数保存在栈上。
- en: Method arguments are essentially the same as local variables. The only difference
    between the two is that the calling code pushes the arguments onto the stack before
    the method call even occurs. In this example there are no local variables, but
    the single argument appears on the stack just like a local variable, as shown
    in [Figure 3-22](ch03.html#calling_code_saves_the_argument_valu "Figure 3-22. The
    calling code saves the argument values before the method is called.").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数本质上与局部变量相同。两者之间的唯一区别是调用代码在方法调用之前就将参数推送到栈上。在这个示例中没有局部变量，但唯一的参数出现在栈上，像局部变量一样，如[图
    3-22](ch03.html#calling_code_saves_the_argument_valu "图 3-22. 调用代码在方法调用前保存参数值。")所示。
- en: '![The calling code saves the argument values before the method is called.](httpatomoreillycomsourcenostarchimages1853981.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![调用代码在方法调用前保存参数值。](httpatomoreillycomsourcenostarchimages1853981.png.jpg)'
- en: Figure 3-22. The calling code saves the argument values before the method is
    called.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-22. 调用代码在方法调用前保存参数值。
- en: Dynamic Variable Access
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态变量访问
- en: Now let’s see how dynamic variable access works and what that `special` value
    is. Ruby uses dynamic access when you use a variable that’s defined in a different
    scope—for example, when you write a block that references values in the surrounding
    code. [Example 3-6](ch03.html#code_inside_the_block_accesses_str_i "Example 3-6. The
    code inside the block accesses str in the surrounding method.") shows an example.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看动态变量访问是如何工作的，以及那个 `special` 值是什么。Ruby 使用动态访问时，当你使用在其他作用域中定义的变量时——例如，当你编写一个引用周围代码中值的块时。[示例
    3-6](ch03.html#code_inside_the_block_accesses_str_i "示例 3-6. 块中的代码访问周围方法中的 str。")展示了一个示例。
- en: Example 3-6. The code inside the block accesses `str` in the surrounding method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-6. 块中的代码访问周围方法中的 `str`。
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `str` is a local variable in `display_string`. As you can see in [Figure 3-23](ch03.html#ruby_saves_the_value_of_the_str_local_va
    "Figure 3-23. Ruby saves the value of the str local variable on the stack as usual."),
    Ruby will save `str` using the `setlocal` instruction in just the same way we
    saw in [Figure 3-18](ch03.html#displayunderscorestring_method_compi "Figure 3-18. The
    display_string method compiled into YARV instructions").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`str` 是 `display_string` 中的局部变量。如[图 3-23](ch03.html#ruby_saves_the_value_of_the_str_local_va
    "图 3-23. Ruby 像往常一样将 `str` 局部变量的值保存在栈上。")所示，Ruby 会使用 `setlocal` 指令保存 `str`，就像我们在[图
    3-18](ch03.html#displayunderscorestring_method_compi "图 3-18. `display_string`
    方法编译成 YARV 指令")中看到的一样。
- en: '![Ruby saves the value of the str local variable on the stack as usual.](httpatomoreillycomsourcenostarchimages1853983.png.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 像往常一样将 `str` 局部变量的值保存在栈上。](httpatomoreillycomsourcenostarchimages1853983.png.jpg)'
- en: Figure 3-23. Ruby saves the value of the `str` local variable on the stack as
    usual.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-23. Ruby 像往常一样将 `str` 局部变量的值保存在栈上。
- en: Next, Ruby will call the `10.times` method, passing a block in as an argument.
    Let’s step through the process of calling a method with a block. [Figure 3-24](ch03.html#when_ruby_calls_a_method_passing_in_a_bl
    "Figure 3-24. When Ruby calls a method passing in a block, it saves a pointer
    to a new rb_block_t structure as the special value in the new stack frame.") shows
    the same process we saw in [Figure 3-10](ch03.html#every_ruby_program_starts_with_these_two
    "Figure 3-10. Every Ruby program starts with these two control frames."), [Figure 3-11](ch03.html#ruby_uses_the_cfunc_frame_when_you_call
    "Figure 3-11. Ruby uses the CFUNC frame when you call built-in functions implemented
    in C."), and [Figure 3-12](ch03.html#cfp_stack_when_we_pause_the_code_fro "Figure 3-12. The
    CFP stack when we pause the code from Example 3-2 inside the block") but with
    more details about YARV’s internal stack.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 将调用 `10.times` 方法，并将一个块作为参数传入。让我们逐步了解调用带有块的方法的过程。[图 3-24](ch03.html#when_ruby_calls_a_method_passing_in_a_bl
    "图 3-24. 当 Ruby 调用一个方法并传入块时，它会将指向新的 rb_block_t 结构体的指针保存在新栈帧中的特殊值。") 展示了我们在 [图
    3-10](ch03.html#every_ruby_program_starts_with_these_two "图 3-10. 每个 Ruby 程序都从这两个控制帧开始。")、[图
    3-11](ch03.html#ruby_uses_the_cfunc_frame_when_you_call "图 3-11. 当你调用用 C 实现的内置函数时，Ruby
    会使用 CFUNC 框架。") 和 [图 3-12](ch03.html#cfp_stack_when_we_pause_the_code_fro "图 3-12.
    在块内暂停示例 3-2 代码时的 CFP 栈") 中看到的相同过程，不过它提供了更多关于 YARV 内部栈的细节。
- en: '![When Ruby calls a method passing in a block, it saves a pointer to a new
    rb_block_t structure as the special value in the new stack frame.](httpatomoreillycomsourcenostarchimages1853985.png.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![当 Ruby 调用一个方法并传入块时，它会将指向新的 rb_block_t 结构体的指针保存在新栈帧中的特殊值。](httpatomoreillycomsourcenostarchimages1853985.png.jpg)'
- en: Figure 3-24. When Ruby calls a method passing in a block, it saves a pointer
    to a new `rb_block_t` structure as the special value in the new stack frame.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-24. 当 Ruby 调用一个方法并传入块时，它会将指向新的 `rb_block_t` 结构体的指针保存在新栈帧中的特殊值。
- en: 'Notice the value `10` on the stack: This is the actual receiver of the `times`
    method. Notice too that Ruby has created a new stack frame with `svar/cref` and
    `special` above the value `10` for the C code that implements `Integer#times`
    to use. Because we passed a block into the method call, Ruby saves a pointer to
    this block in the `special` variable in the new stack frame. Each frame on the
    YARV stack corresponding to a method call tracks whether there was a block argument
    using this `special` variable. (I’ll discuss blocks and the `rb_block_t` structure
    in more detail in [Chapter 8](ch08.html "Chapter 8. How Ruby Borrowed a Decades-Old
    Idea from Lisp").)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意栈上的值 `10`：这是 `times` 方法的实际接收者。还要注意，Ruby 为实现 `Integer#times` 的 C 代码创建了一个新的栈帧，栈帧中的
    `svar/cref` 和 `special` 变量位于值 `10` 之上。因为我们传递了一个块作为方法调用的参数，Ruby 会在新栈帧中的 `special`
    变量中保存指向该块的指针。YARV 栈上的每个方法调用帧都通过这个 `special` 变量来跟踪是否存在块参数。（我将在 [第 8 章](ch08.html
    "第 8 章. Ruby 如何借用了 Lisp 中的一个几十年历史的概念") 中更详细地讨论块和 `rb_block_t` 结构。）
- en: Now the `Integer#times` method yields to or calls the block’s code 10 times.
    [Figure 3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i "Figure 3-25. How
    YARV’s stack would appear if we halted execution inside the block") shows how
    the YARV stack appears when Ruby is executing the code inside the block.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Integer#times` 方法会调用块中的代码 10 次。[图 3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i
    "图 3-25. 如果我们在块内部暂停执行，YARV 栈会是什么样子") 展示了 Ruby 执行块内代码时，YARV 栈的状态。
- en: '![How YARV’s stack would appear if we halted execution inside the block](httpatomoreillycomsourcenostarchimages1853987.png.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![如果我们在块内部暂停执行，YARV 栈会是什么样子](httpatomoreillycomsourcenostarchimages1853987.png.jpg)'
- en: Figure 3-25. How YARV’s stack would appear if we halted execution inside the
    block
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-25. 如果我们在块内部暂停执行，YARV 栈会是什么样子
- en: Just as we saw in [Figure 3-17](ch03.html#ruby_saves_local_variables_on_its_stack
    "Figure 3-17. Ruby saves local variables on its stack near the environment pointer
    (EP).") through [Figure 3-22](ch03.html#calling_code_saves_the_argument_valu "Figure 3-22. The
    calling code saves the argument values before the method is called."), Ruby sets
    `EP` to point to the location of the `special` value in each stack frame. [Figure 3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i
    "Figure 3-25. How YARV’s stack would appear if we halted execution inside the
    block") shows one value of `EP` for the new stack frame used by the block near
    the top of the stack and a second value of `EP` in the original method’s stack
    frame near the bottom. In [Figure 3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i
    "Figure 3-25. How YARV’s stack would appear if we halted execution inside the
    block") this second pointer is labeled *Previous EP*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[Figure 3-17](ch03.html#ruby_saves_local_variables_on_its_stack "Figure
    3-17. Ruby 在其栈上保存局部变量，靠近环境指针 (EP)")到[Figure 3-22](ch03.html#calling_code_saves_the_argument_valu
    "Figure 3-22. 调用代码在方法调用之前保存参数值")中看到的那样，Ruby 将`EP`设置为指向每个栈帧中`special`值的位置。[Figure
    3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i "Figure 3-25. 如果我们在块内部暂停执行，YARV
    的堆栈会怎样")展示了两个`EP`值，一个是用于块的新栈帧，位于栈顶，另一个是位于原始方法栈帧中的`EP`，位于栈底。在[Figure 3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i
    "Figure 3-25. 如果我们在块内部暂停执行，YARV 的堆栈会怎样")中，第二个指针被标记为*Previous EP*。
- en: Now, what happens when Ruby executes the `puts str` code inside the block? Ruby
    needs to obtain the value of the local variable `str` and pass it to the `puts`
    function as an argument. But notice in [Figure 3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i
    "Figure 3-25. How YARV’s stack would appear if we halted execution inside the
    block") that `str` is located farther down the stack. It’s not a local variable
    inside the block; rather, it’s a variable in the surrounding method, `display_string`.
    How does Ruby obtain the value from farther down the stack while executing code
    inside the block?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ruby 执行块内部的`puts str`代码时会发生什么呢？Ruby 需要获取局部变量`str`的值，并将其作为参数传递给`puts`函数。但请注意，在[Figure
    3-25](ch03.html#how_yarvapostrophes_stack_would_appear_i "Figure 3-25. 如果我们在块内部暂停执行，YARV
    的堆栈会怎样")中，`str` 位于栈的下方。它不是块内部的局部变量，而是周围方法`display_string`中的变量。Ruby 如何在执行块内代码时从栈下方获取该值呢？
- en: This is where dynamic variable access comes in and why Ruby needs those `special`
    values in each stack frame. [Figure 3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob
    "Figure 3-26. Ruby using dynamic variable access to obtain the value of str from
    farther down the stack") shows how dynamic variable access works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是动态变量访问的作用，也是为什么 Ruby 需要每个栈帧中的这些`special`值。[Figure 3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob
    "Figure 3-26. Ruby 使用动态变量访问从栈下方获取 str 的值")展示了动态变量访问是如何工作的。
- en: '![Ruby using dynamic variable access to obtain the value of str from farther
    down the stack](httpatomoreillycomsourcenostarchimages1853989.png.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用动态变量访问从栈下方获取 str 的值](httpatomoreillycomsourcenostarchimages1853989.png.jpg)'
- en: Figure 3-26. Ruby using dynamic variable access to obtain the value of `str`
    from farther down the stack
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-26. Ruby 使用动态变量访问从栈下方获取 `str` 的值
- en: 'The dashed arrows indicate dynamic variable access: The `getlocal` YARV instruction
    copies the value of `str` from the lower stack frame (from the parent or outer
    Ruby scope) to the top of the stack, where the block can access it. Notice how
    the `EP` pointers form a kind of ladder that Ruby can climb to access the local
    variables in the parent scope, the grandparent scope, and so on.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线箭头表示动态变量访问：`getlocal` YARV 指令将`str`的值从下方的栈帧（来自父级或外部 Ruby 作用域）复制到栈顶，块可以访问它。请注意，`EP`指针形成了一种阶梯，Ruby
    可以沿着这条阶梯向上爬，以访问父作用域、祖父作用域等中的局部变量。
- en: In the `getlocal 2, 1` call in [Figure 3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob
    "Figure 3-26. Ruby using dynamic variable access to obtain the value of str from
    farther down the stack"), the second parameter, `1`, tells Ruby where to find
    the variable. In this example, Ruby will follow the ladder of `EP` pointers one
    level down the stack to find `str`. That is, `1` means step once from the block’s
    scope to the surrounding method’s scope.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Figuere 3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob "Figure 3-26.
    Ruby 使用动态变量访问从栈下方获取 str 的值")中的`getlocal 2, 1`调用中，第二个参数`1`告诉 Ruby 从哪里找到变量。在这个例子中，Ruby
    将沿着`EP`指针的阶梯向下移动一层，找到`str`。也就是说，`1`表示从块的作用域步进到周围方法的作用域。
- en: '[Example 3-7](ch03.html#in_this_examplecomma_ruby_would_step_two "Example 3-7. In
    this example, Ruby would step two levels down the stack to find str using dynamic
    variable access.") shows another example of dynamic variable access.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例3-7](ch03.html#in_this_examplecomma_ruby_would_step_two "示例3-7. 在此示例中，Ruby会通过动态变量访问步进两级栈来查找str")展示了另一个动态变量访问的例子。'
- en: Example 3-7. In this example, Ruby would step two levels down the stack to find
    *str* using dynamic variable access.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-7. 在此示例中，Ruby会通过动态变量访问步进两级栈来查找*str*。
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If I had two nested blocks, as in [Example 3-7](ch03.html#in_this_examplecomma_ruby_would_step_two
    "Example 3-7. In this example, Ruby would step two levels down the stack to find
    str using dynamic variable access."), Ruby would have used `getlocal 2, 2` instead
    of `getlocal 2, 1`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我有两个嵌套的代码块，如[示例3-7](ch03.html#in_this_examplecomma_ruby_would_step_two "示例3-7.
    在此示例中，Ruby会通过动态变量访问步进两级栈来查找str")所示，Ruby会使用`getlocal 2, 2`而不是`getlocal 2, 1`。
- en: Climbing the Environment Pointer Ladder in C
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中爬升环境指针阶梯
- en: Let’s look at the actual C implementation of `getlocal`. As it does with most
    YARV instructions, Ruby implements `getlocal` in the *insns.def* code file, using
    the code shown in [Example 3-8](ch03.html#c_implementation_of_the_getlocal_yar
    "Example 3-8. The C implementation of the getlocal YARV instruction").
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`getlocal`的实际C语言实现。与大多数YARV指令一样，Ruby在*insns.def*代码文件中实现了`getlocal`，使用了[示例3-8](ch03.html#c_implementation_of_the_getlocal_yarv
    "示例3-8. getlocal YARV指令的C语言实现")中的代码。
- en: Example 3-8. The C implementation of the `getlocal` YARV instruction
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-8. `getlocal` YARV指令的C语言实现
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, the `GET_EP` macro ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    returns the `EP` from the current scope. (This macro is defined in the *vm_insnhelper.h*
    file along with a number of other macros related to YARV instructions.) Next,
    Ruby iterates over the `EP` pointers, moving from the current to the parent scope
    and then from the parent to the grandparent scope by repeatedly dereferencing
    the `EP` pointers. Ruby uses the `GET_PREV_EP` macro at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    (also defined in *vm_insnhelper.h*) to move from one `EP` to another. The `level`
    parameter tells Ruby how many times to iterate or how many rungs of the ladder
    to climb.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`GET_EP`宏![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)返回当前作用域的`EP`。（此宏在*vm_insnhelper.h*文件中定义，此外还有许多与YARV指令相关的其他宏。）接下来，Ruby遍历`EP`指针，从当前作用域移动到父作用域，然后再从父作用域移动到祖父作用域，反复取消引用`EP`指针。Ruby使用`GET_PREV_EP`宏在![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)处（同样在*vm_insnhelper.h*中定义）从一个`EP`移动到另一个。`level`参数告诉Ruby需要迭代多少次，或者爬升多少级阶梯。
- en: Finally, Ruby obtains the target variable using the `idx` parameter at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg),
    which is the index of the target variable. As a result, this line of code gets
    the value from the target variable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Ruby使用`idx`参数在![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)处获取目标变量，该参数是目标变量的索引。因此，这行代码从目标变量获取值。
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code means the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着以下内容：
- en: Start from the address of the `EP` for the target scope `ep`, obtained previously
    from the `GET_PREV_EP` iterations.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从之前通过`GET_PREV_EP`迭代获取的目标作用域`ep`的`EP`地址开始。
- en: Subtract `idx` from this address. The integer value `idx` gives `getlocal` the
    index of the local variable that you want to load from the local table. In other
    words, it tells `getlocal` how far down the stack the target variable is located.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这个地址减去`idx`。整数值`idx`给`getlocal`提供了你想要从局部表中加载的局部变量的索引。换句话说，它告诉`getlocal`目标变量在栈上有多深。
- en: Get the value from the YARV stack at the adjusted address.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从调整后的地址获取YARV栈中的值。
- en: Therefore, in the call to `getlocal` in [Figure 3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob
    "Figure 3-26. Ruby using dynamic variable access to obtain the value of str from
    farther down the stack"), YARV will take the `EP` from the scope one level down
    on the YARV stack and subtract the index value `str` (in this case, `2`) to obtain
    a pointer to the `str` variable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在[图3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob "图3-26. Ruby使用动态变量访问从堆栈下方获取str的值")中对`getlocal`的调用中，YARV会从YARV栈上一级的作用域获取`EP`，并减去索引值`str`（在此案例中是`2`），以获取指向`str`变量的指针。
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Experiment 3-2: Exploring Special Variables'
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验3-2：探索特殊变量
- en: In [Figure 3-16](ch03.html#example_ruby_script_that_uses_a_local "Figure 3-16. An
    example Ruby script that uses a local variable") through [Figure 3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob
    "Figure 3-26. Ruby using dynamic variable access to obtain the value of str from
    farther down the stack"), I showed you a value called `svar/cref` in the `EP-1`
    position on the stack. What are these two values, and how can Ruby save two values
    in one location on the stack? For that matter, why does it do this? Let’s find
    out.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 3-16](ch03.html#example_ruby_script_that_uses_a_local "图 3-16. 一个使用局部变量的
    Ruby 脚本示例") 到 [图 3-26](ch03.html#ruby_using_dynamic_variable_access_to_ob "图 3-26.
    Ruby 使用动态变量访问获取栈底的 str 值") 中，我向你展示了在栈的 `EP-1` 位置上一个名为 `svar/cref` 的值。这两个值是什么，Ruby
    如何在栈的一个位置保存两个值？更重要的是，为什么 Ruby 要这样做？让我们一探究竟。
- en: Usually, the `EP-1` slot in the stack will contain the `svar` value, which is
    a pointer to a table of any special variables defined in this stack frame. In
    Ruby the term *special variables* refers to values that Ruby automatically creates
    as a matter of convenience, based on the environment or on recent operations.
    For example, Ruby sets `$*` to the `ARGV` array and `$!` to the last exception
    raised.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，栈中的 `EP-1` 插槽将包含 `svar` 值，这是指向该栈帧中定义的任何特殊变量的表的指针。在 Ruby 中，*特殊变量* 是指 Ruby
    根据环境或最近的操作自动创建的值。例如，Ruby 将 `$*` 设置为 `ARGV` 数组，将 `$!` 设置为最后引发的异常。
- en: All special variables begin with the dollar sign (`$`) character, which usually
    indicates a global variable. Does that mean that special variables are global
    variables? If so, then why does Ruby save a pointer to them on the stack?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有特殊变量都以美元符号（`$`）开头，这通常表示全局变量。这是否意味着特殊变量是全局变量？如果是的话，为什么 Ruby 要在栈上保存指向它们的指针？
- en: To answer this question, let’s create a simple Ruby script to match a string
    using a regular expression.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们来创建一个简单的 Ruby 脚本，使用正则表达式匹配一个字符串。
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here I match the word `fox` in the string using a regex, and then I print the
    matching string using the `$&` special variable. Here’s the output I get running
    this at the console.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用正则表达式匹配字符串中的 `fox`，然后使用 `$&` 特殊变量打印匹配的字符串。以下是在控制台运行时得到的输出。
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 3-9](ch03.html#referring_to_dollarampersand_from_two_di "Example 3-9. Referring
    to $& from two different scopes") shows another example, this time searching for
    the same string twice: first in the top-level scope and then again from inside
    a method call.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-9](ch03.html#referring_to_dollarampersand_from_two_di "示例 3-9. 从两个不同作用域引用
    $&") 显示了另一个示例，这次是搜索相同的字符串两次：第一次在顶层作用域中，第二次在方法调用内部。'
- en: Example 3-9. Referring to `$&` from two different scopes
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-9. 从两个不同作用域引用 `$&`
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is simple Ruby code, but it still may be a bit confusing. Here’s how this
    works:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简单的 Ruby 代码，但仍然可能有些令人困惑。下面是它的工作原理：
- en: We search the string in the top scope for `fox` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    This matches and saves `fox` into the `$&` special variable.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在顶层作用域中搜索字符串 `fox`，如图所示 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。这与之匹配，并将
    `fox` 保存到 `$&` 特殊变量中。
- en: We call the `search` method and search for `dog` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)`.`
    I immediately print the match using the same `$&` variable inside the method at
    ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用 `search` 方法，并在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    搜索 `dog` 字符串。然后我立即在方法内部使用同一个 `$&` 变量打印匹配结果，如图所示 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)。
- en: Finally, we return to the top-level scope and print the value of `$&` again
    at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们返回到顶层作用域，并再次在 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    打印 `$&` 的值。
- en: Running this test gives the following output.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试将得到以下输出。
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is what we expect, but consider the following for a moment. The `$&` variable
    is obviously not global because it has different values at different places in
    my Ruby script. Ruby preserves the value of `$&` from the top-level scope when
    executing the `search` method, which allows me to print the matching word `fox`
    from the original search. Ruby provides for this behavior by saving a separate
    set of special variables at each level of the stack using the `svar` value, as
    shown in [Figure 3-27](ch03.html#each_stack_frame_has_its_own_set_of_spec "Figure 3-27. Each
    stack frame has its own set of special variables.").
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的情况，但请稍微考虑一下。显然，`$&` 变量不是全局的，因为它在 Ruby 脚本的不同地方具有不同的值。Ruby 在执行 `search`
    方法时会保留顶层作用域中 `$&` 的值，这让我能够从原始搜索中打印出匹配的单词 `fox`。Ruby 通过在栈的每一层使用 `svar` 值保存一组单独的特殊变量来支持这种行为，正如在[图
    3-27](ch03.html#each_stack_frame_has_its_own_set_of_spec "图 3-27. 每个栈帧都有自己的特殊变量集。")中所示。
- en: '![Each stack frame has its own set of special variables.](httpatomoreillycomsourcenostarchimages1853991.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![每个栈帧都有自己的特殊变量集。](httpatomoreillycomsourcenostarchimages1853991.png)'
- en: Figure 3-27. Each stack frame has its own set of special variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-27. 每个栈帧都有自己的特殊变量集。
- en: Notice that Ruby saved the `fox` string in a table referred to by the `svar`
    pointer for the top-level scope and saved the `dog` string in a different table
    for the inner-method scope. Ruby finds the proper special variable table using
    the `EP` pointer for each stack frame.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Ruby 将 `fox` 字符串保存在由 `svar` 指针引用的顶层作用域的表格中，将 `dog` 字符串保存在另一个表格中，该表格用于内方法作用域。Ruby
    使用每个栈帧的 `EP` 指针找到合适的特殊变量表。
- en: Ruby saves actual global variables (variables you define using a dollar sign
    prefix) in a single, global hash table. Regardless of where you save or retrieve
    the value of a normal global variable, Ruby accesses the same global hash table.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 将实际的全局变量（通过美元符号前缀定义的变量）保存在一个单独的全局哈希表中。无论你在哪里保存或检索一个普通全局变量的值，Ruby 都会访问相同的全局哈希表。
- en: 'Now for one more test: What if I perform the search inside a block and not
    a method? [Example 3-10](ch03.html#displaying_the_value_of_dollarampersand "Example 3-10. Displaying
    the value of $& from inside a block") shows this new search.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再做一次测试：如果我在一个块内执行搜索而不是在方法内呢？[示例 3-10](ch03.html#displaying_the_value_of_dollarampersand
    "示例 3-10. 在块内显示 $& 的值") 显示了这个新搜索。
- en: Example 3-10. Displaying the value of `$&` from inside a block
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-10. 在块内显示 `$&` 的值
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here’s the output I get at the console this time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这次在控制台上得到的输出。
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice that now Ruby has overwritten the value of `$&` in the top scope with
    the matching word `dog` from the search I performed inside the block! This is
    by design: Ruby considers the top-level and inner-block scope to be the same with
    regard to special variables. This is similar to how dynamic variable access works;
    we expect variables inside the block to have the same values as those in the parent
    scope.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在 Ruby 已经用我在块内执行搜索时匹配的单词 `dog` 覆盖了顶层作用域中 `$&` 的值！这是有意为之：Ruby 认为顶层和内块作用域对于特殊变量来说是相同的。这类似于动态变量访问的工作方式；我们期望块内的变量与父作用域中的变量具有相同的值。
- en: '[Figure 3-28](ch03.html#ruby_uses_the_ep-1_stack_position_for_cr "Figure 3-28. Ruby
    uses the EP-1 stack position for cref in blocks and for svar otherwise.") shows
    how Ruby implements this behavior.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-28](ch03.html#ruby_uses_the_ep-1_stack_position_for_cr "图 3-28. Ruby 在块中使用
    EP-1 栈位置来处理 cref，其他情况使用 svar.") 显示了 Ruby 如何实现这种行为。'
- en: '![Ruby uses the EP-1 stack position for cref in blocks and for svar otherwise.](httpatomoreillycomsourcenostarchimages1853993.png.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 在块中使用 EP-1 栈位置来处理 cref，其他情况使用 svar。](httpatomoreillycomsourcenostarchimages1853993.png.jpg)'
- en: Figure 3-28. Ruby uses the `EP-1` stack position for `cref` in blocks and for
    `svar` otherwise.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-28. Ruby 在块中使用 `EP-1` 栈位置来处理 `cref`，其他情况使用 `svar`。
- en: As you can see in [Figure 3-28](ch03.html#ruby_uses_the_ep-1_stack_position_for_cr
    "Figure 3-28. Ruby uses the EP-1 stack position for cref in blocks and for svar
    otherwise."), Ruby has just a single special variable table for the top-level
    scope. It finds the special variables using the previous `EP` pointer, which points
    to the top-level scope. Inside the block scope (because there is no need for a
    separate copy of the special variables), Ruby takes advantage of the `EP-1` open
    slot and saves the value `cref` there instead. Ruby uses the `cref` value to keep
    track of which lexical scope this block belongs to. *Lexical scope* refers to
    a section of code within the syntactical structure of your program and is used
    by Ruby to look up constant values. (See [Chapter 6](ch06.html "Chapter 6. Method
    Lookup and Constant Lookup") for more on lexical scope.) Specifically, Ruby uses
    the `cref` value here to implement metaprogramming API calls, such as `eval` and
    `instance_eval`. The `cref` value indicates whether the given block should be
    executed in a different lexical scope compared to the parent scope. (See [instance_eval
    Creates a Singleton Class for a New Lexical Scope](ch09.html#instanceunderscoreeval_creates_a_singlet
    "instance_eval Creates a Singleton Class for a New Lexical Scope").)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [图 3-28](ch03.html#ruby_uses_the_ep-1_stack_position_for_cr "图 3-28。Ruby
    在块中使用 EP-1 栈位置作为 cref，其他地方则使用 svar。") 中看到的，Ruby 只有一个用于顶级作用域的特殊变量表。它通过之前的 `EP`
    指针找到特殊变量，`EP` 指针指向顶级作用域。在块作用域内（因为不需要单独的特殊变量副本），Ruby 利用 `EP-1` 的空闲槽并将 `cref` 的值保存到其中。Ruby
    使用 `cref` 值来追踪当前块属于哪个词法作用域。*词法作用域*是指程序语法结构中的一段代码，并被 Ruby 用来查找常量值。（有关词法作用域的更多信息，请参见
    [第 6 章](ch06.html "第 6 章。方法查找与常量查找")）。具体而言，Ruby 在此处使用 `cref` 值来实现元编程 API 调用，如
    `eval` 和 `instance_eval`。`cref` 值指示给定块是否应该在与父作用域不同的词法作用域中执行。（参见 [instance_eval
    为新的词法作用域创建一个单例类](ch09.html#instanceunderscoreeval_creates_a_singlet "instance_eval
    为新的词法作用域创建一个单例类")）。
- en: A Definitive List of Special Variables
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊变量的权威列表
- en: 'One place to find an accurate list of all the special variables that Ruby supports
    is the C source itself. For example, [Example 3-11](ch03.html#consulting_parsedoty_is_a_good_way_to_fi
    "Example 3-11. Consulting parse.y is a good way to find a definitive list of Ruby’s
    many special variables.") is a piece of Ruby’s C source code that tokenizes your
    Ruby program, as snipped from the `parser_yylex` function located in *parse.y*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 Ruby 所支持的所有特殊变量的准确列表的一个地方就是 C 源代码本身。例如，[示例 3-11](ch03.html#consulting_parsedoty_is_a_good_way_to_fi
    "示例 3-11。查阅 parse.y 是找到 Ruby 多个特殊变量确切列表的好方法") 是 Ruby C 源代码的一部分，它将你的 Ruby 程序进行标记化，摘自
    *parse.y* 中的 `parser_yylex` 函数：
- en: Example 3-11. Consulting *parse.y* is a good way to find a definitive list of
    Ruby’s many special variables.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-11。查阅 *parse.y* 是找到 Ruby 多个特殊变量的确切列表的好方法。
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) that Ruby
    matches a dollar sign character (`$`). This is part of the large C `switch` statement
    that tokenizes your Ruby code—the process I discussed in [Tokens: The Words That
    Make Up the Ruby Language](ch01.html#tokens_the_words_that_make_up_the_ruby_l
    "Tokens: The Words That Make Up the Ruby Language"). This is followed by an inner
    `switch` statement at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    that matches on the following character. Each of these characters and each of
    the `case` statements that follow (at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    and after ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)) correspond
    to one of Ruby’s special variables.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) Ruby 匹配了美元符号字符（`$`）。这是一个大型
    C `switch` 语句的一部分，它将你的 Ruby 代码进行标记化——我在 [标记：构成 Ruby 语言的单词](ch01.html#tokens_the_words_that_make_up_the_ruby_l
    "标记：构成 Ruby 语言的单词") 中讨论过这个过程。接着是一个内部的 `switch` 语句，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    匹配接下来的字符。这些字符以及随后的每个 `case` 语句（在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    和之后的 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)）都对应于 Ruby 的一个特殊变量。
- en: Just a bit farther down in the function, more C code (see [Example 3-12](ch03.html#these_case_statements_correspond_to_ruby
    "Example 3-12. These case statements correspond to Ruby’s regex-related special
    variables.")) parses other special variable tokens that you write in your Ruby
    code, such as `$&` and related special variables.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的稍下方，更多的 C 代码（参见 [示例 3-12](ch03.html#these_case_statements_correspond_to_ruby
    "示例 3-12。这些 case 语句对应于 Ruby 的正则表达式相关特殊变量")）解析了你在 Ruby 代码中编写的其他特殊变量标记，比如 `$&` 及相关的特殊变量。
- en: Example 3-12. These `case` statements correspond to Ruby’s regex-related special
    variables.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-12. 这些 `case` 语句对应于 Ruby 中与正则表达式相关的特殊变量。
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) you can see four
    more `case` statements corresponding to the special variables `$&`, `` $` ``,
    `$/`, and `$+`, all related to regular expressions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 中，你可以看到四个额外的 `case`
    语句，分别对应于特殊变量 `$&`、`` $` ``、`$/` 和 `$+`，这些变量都与正则表达式相关。
- en: 'Finally, the code in [Example 3-13](ch03.html#this_c_code_tokenizes_rubyapostrophes_nt
    "Example 3-13. This C code tokenizes Ruby’s nth back reference special variables:
    $1, $2, and so forth.") tokenizes `$1`, `$2`, and so on, producing the special
    variables that return the nth back reference from the last regular expression
    operation.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [示例 3-13](ch03.html#this_c_code_tokenizes_rubyapostrophes_nt "示例 3-13.
    这段 C 代码将 Ruby 的 nth 反向引用特殊变量：$1、$2 等等") 中，代码将 `$1`、`$2` 等进行标记化，生成从上次正则表达式操作中返回的
    nth 反向引用特殊变量。
- en: 'Example 3-13. This C code tokenizes Ruby’s nth back reference special variables:
    `$1`, `$2`, and so forth.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-13. 这段 C 代码将 Ruby 的 nth 反向引用特殊变量：`$1`、`$2` 等等。
- en: '[PRE21]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `case` statements at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    match the numerical digits 1 through 9, while the C `do...while` loop at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    continues to process digits until an entire number is read in. This allows you
    to create special variables with multiple digits, such as `$12`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 中的 `case` 语句匹配数字
    1 到 9，而在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 中的 C `do...while`
    循环则会继续处理数字，直到读取完整的数字为止。这使得你能够创建具有多个数字的特殊变量，如 `$12`。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We’ve covered a lot of ground in this chapter. We began by looking at how Ruby
    keeps track of two stacks: an internal stack YARV uses and your Ruby call stack.
    Next, we saw how YARV executed two simple Ruby programs: one that calculated 2
    + 2 = 4 and another that called a block 10 times. In [Experiment 3-1: Benchmarking
    Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8](ch03.html#experiment_3-1_benchmarking_ruby_2dot0_a
    "Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8") we learned
    that executing YARV instructions in Ruby 2.0 and 1.9 is almost four times faster
    than in Ruby 1.8, which executes your program directly from the AST.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们覆盖了很多内容。我们首先探讨了 Ruby 如何追踪两个栈：YARV 使用的内部栈和你的 Ruby 调用栈。接着，我们看到了 YARV 如何执行两个简单的
    Ruby 程序：一个计算 2 + 2 = 4，另一个调用一个块 10 次。在 [实验 3-1：基准测试 Ruby 2.0 和 Ruby 1.9 与 Ruby
    1.8](ch03.html#experiment_3-1_benchmarking_ruby_2dot0_a "实验 3-1：基准测试 Ruby 2.0
    和 Ruby 1.9 与 Ruby 1.8") 中，我们了解到，在 Ruby 2.0 和 1.9 中执行 YARV 指令几乎比在 Ruby 1.8 中快四倍，而后者是直接从
    AST 执行程序。
- en: 'We moved on to look at how Ruby saves variables on the internal YARV stack
    using two methods: local and dynamic variable access. We also saw how method arguments
    are handled by Ruby in just the same way as local variables. In [Experiment 3-2:
    Exploring Special Variables](ch03.html#experiment_3-2_exploring_special_variabl
    "Experiment 3-2: Exploring Special Variables") we finished with a look at how
    Ruby handles special variables.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续研究了 Ruby 如何使用两种方法在内部 YARV 栈上保存变量：局部变量和动态变量访问。我们还看到 Ruby 如何处理方法参数，方式与局部变量相同。在
    [实验 3-2：探索特殊变量](ch03.html#experiment_3-2_exploring_special_variabl "实验 3-2：探索特殊变量")
    中，我们探讨了 Ruby 如何处理特殊变量。
- en: When you run any Ruby program, you are actually using a virtual machine designed
    specifically to execute Ruby programs. By examining how this machine works on
    a detailed level, we’ve acquired a deeper understanding of how the Ruby language
    works and, for example, what happens when you call a method or save a value in
    a local variable. In [Chapter 4](ch04.html "Chapter 4. Control Structures and
    Method Dispatch") we’ll continue to explore this virtual machine by looking at
    how control structures work and at YARV’s method dispatch process.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行任何 Ruby 程序时，实际上是在使用专门为执行 Ruby 程序设计的虚拟机。通过详细分析这个虚拟机的工作原理，我们对 Ruby 语言的运作有了更深入的理解，例如，当你调用方法或将值保存到局部变量时会发生什么。在
    [第 4 章](ch04.html "第 4 章：控制结构与方法调度") 中，我们将继续探索这个虚拟机，研究控制结构的工作原理以及 YARV 的方法调度过程。
