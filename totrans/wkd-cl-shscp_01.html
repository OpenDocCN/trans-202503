<html><head></head><body>
<h2 class="h2" id="ch00"><span epub:type="pagebreak" id="page_1"/><span class="big"><strong>0</strong></span><br/><strong>A SHELL SCRIPTS CRASH COURSE</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">Bash (and shell scripting in general) has been around for a long time, and every day new people are introduced to the power of shell scripting and system automation with bash. And with Microsoft’s release of an interactive bash shell and Unix subsystem within Windows 10, there’s never been a better time to learn how simple and effective shell scripts can be.</p>&#13;
<h3 class="h3" id="ch00lev1sec01"><strong>What Is a Shell Script, Anyway?</strong></h3>&#13;
<p class="noindenta">Ever since the early days of computers, shell scripts have been helping systems administrators and programmers perform tedious jobs that otherwise took time and elbow grease. So what is a shell script, and why should you care? Shell scripts are text files that run a set of commands, in the order <span epub:type="pagebreak" id="page_2"/>they are written in the script, for a particular shell (in our case, bash). The <em>shell</em> is your command line interface to the library of commands available on your operating system.</p>&#13;
<p class="indent">Shell scripts are essentially bite-sized programs built using the commands available in your shell environment to automate specific tasks— generally those tasks that no one enjoys doing by hand, like web scraping, tracking disk usage, downloading weather data, renaming files, and much more. You can even use shell scripts to make basic games! These scripts can include simple logic, like the <span class="literal">if</span> statements you may have seen in other languages, but they can also be even simpler, as you’ll soon see.</p>&#13;
<p class="indent">Many flavors of command line shells, such as tcsh, zsh, and the ever-popular bash, are available for OS X, BSD, and Linux operating systems. This book will focus on the mainstay of the Unix environment, bash. Each shell has its own features and capabilities, but the shell that most people first become familiar with on Unix is usually bash. On OS X, the Terminal app will open a window with a bash shell (see <a href="ch00.xhtml#ch0fig1">Figure 0-1</a>). On Linux, the command shell program can vary widely, but common command line consoles are <em>gnome-terminal</em> for GNOME or <em>konsole</em> for KDE. These applications can have their configurations changed so that they use different types of command line shells, but they all use bash by default. Essentially, if you are on any kind of Unix-like operating system, opening the terminal application should present you with a bash shell by default.</p>&#13;
<div class="image"><img src="../images/f0-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch0fig1"/><em>Figure 0-1: The Terminal app on OS X, showing a version of bash</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>In August 2016, Microsoft released bash for the Windows 10 Anniversary release, so if you’re working in Windows you can still run a bash shell. <a href="app01.xhtml#app01">Appendix A</a> gives instructions on how to install bash for Windows 10, but this book assumes you are running on a Unix-like operating system such as OS X or Linux. Feel free to test these scripts on Windows 10, but we make no guarantees and have not tested them on Windows ourselves! The beauty of bash, though, is portability, and many scripts in this book should “just work.”</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_3"/>Using the terminal to interact with your system may seem like a daunting task. Over time, though, it becomes more natural to just open a terminal to make a quick system change than to move your mouse around in menu after menu, trying to find the options you want to change.</p>&#13;
<h3 class="h3" id="ch00lev1sec02"><strong>Running Commands</strong></h3>&#13;
<p class="noindenta">Bash’s core ability is to run commands on your system. Let’s try a quick “Hello World” example. In a bash shell, the <span class="literal">echo</span> command displays text to the screen, like so:</p>&#13;
<pre class="programs">$ <span class="codestrong">echo "Hello World"</span></pre>&#13;
<p class="indent">Enter this on the bash command line and you’ll see the words <span class="literal">Hello World</span> displayed onscreen. This line of code runs the <span class="literal">echo</span> command that’s stored in your standard bash library. The directories that bash will search for these standard commands are stored in an environment variable called <span class="literal">PATH</span>. You can use <span class="literal">echo</span> with the <span class="literal">PATH</span> variable to see its contents, as <a href="ch00.xhtml#ch0ex1">Listing 0-1</a> shows.</p>&#13;
<div class="image"><img src="../images/f0003-01.jpg" alt="image"/></div>&#13;
<p class="listcap"><a id="ch0ex1"/><em>Listing 0-1: Printing the current</em> <span class="literal"><em>PATH</em></span> <em>environment variable</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>In listings that show both input commands and output, the input commands will be shown in bold and will start with a</em> <span class="literal"><em>$</em></span> <em>to differentiate them from output.</em></p>&#13;
</div>&#13;
<p class="indent">The directories in this output are separated from one another by a colon. These are all the directories that bash will check when you ask it to run a program or command. If your command is not stored in any of these directories, bash cannot run it. Also, note that bash will check these directories <em>in the order they appear in the</em> <span class="literal"><em>PATH</em></span>. This order is important because it may make a difference if you have two commands of the same name in two directories in your <span class="literal">PATH</span>. If you’re having trouble finding a particular command, you can use the <span class="literal">which</span> command with the name of that command to see its <span class="literal">PATH</span> in the shell, as in <a href="ch00.xhtml#ch0ex2">Listing 0-2</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">which ruby</span>&#13;
/Users/bperry/.rvm/rubies/ruby-2.1.5/bin/ruby&#13;
$ <span class="codestrong">which echo</span>&#13;
/bin/echo</pre>&#13;
<p class="listcap"><a id="ch0ex2"/><em>Listing 0-2: Using</em> <span class="literal"><em>which</em></span> <em>to find a command in</em> <span class="literal"><em>PATH</em></span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_4"/>Now armed with this information, you could move or copy the file in question to one of the directories listed by the <span class="literal">echo $PATH</span> command, as in <a href="ch00.xhtml#ch0ex1">Listing 0-1</a>, and then the command will run. We use <span class="literal">which</span> throughout the book to determine the full path to commands. It’s a useful tool for debugging a broken or weird <span class="literal">PATH</span>.</p>&#13;
<h3 class="h3" id="ch00lev1sec03"><strong>Configuring Your Login Script</strong></h3>&#13;
<p class="noindenta">Throughout the book, we will be writing scripts that we will then use in other scripts, so being able to easily call your new scripts is important. You can configure your <span class="literal">PATH</span> variable so that your custom scripts are automatically callable, just like any other command, when you start a new command shell. When you open a command shell, the first thing it does is read a login script in your home directory (<em>/Users/&lt;username&gt;</em> or <em>/home/&lt;username&gt;</em> in OS X or Linux, respectively) and execute any custom commands it finds there. The login script will be <em>.login</em>, <em>.profile</em>, <em>.bashrc</em>, or <em>.bash_profile</em>, depending on your system. To find out which of these files is the login script, add a line like the following to each file:</p>&#13;
<pre class="programs">echo this is <span class="codeitalic">.profile</span></pre>&#13;
<p class="indent">Tweak the last word to match the name of the file and then log in. The line should be printed at the top of the terminal window, reporting which script was run at login. If you open a terminal and see <span class="literal">this is .profile</span>, you know the <em>.profile</em> file is being loaded for your shell environment; if you see <span class="literal">this is .bashrc</span>, you know it’s the <em>.bashrc</em> file; and so on. And now you know! This behavior can change, though, depending on your shell.</p>&#13;
<p class="indent">You can alter the login script so it configures your <span class="literal">PATH</span> variable with other directories. You can also set up all kinds of bash settings, from changing how the bash prompt looks to setting a custom <span class="literal">PATH</span> to any number of other customizations. For instance, let’s use the <span class="literal">cat</span> command to take a look at a customized <em>.bashrc</em> login script. The <span class="literal">cat</span> command takes a filename as an argument and prints the contents of the file to the console screen, as shown in <a href="ch00.xhtml#ch0ex3">Listing 0-3</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">cat ~/.bashrc</span>&#13;
export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting.</pre>&#13;
<p class="listcap"><a id="ch0ex3"/><em>Listing 0-3: This customized</em> .bashrc <em>file updates</em> <span class="literal"><em>PATH</em></span> <em>to include RVM.</em></p>&#13;
<p class="indent">This code displays the contents of the <em>.bashrc</em> file, showing that a new value has been assigned to <span class="literal">PATH</span> that allows the local RVM (Ruby version manager) installation to manage any installed Ruby versions. Because the <em>.bashrc</em> file sets the customized <span class="literal">PATH</span> every time a new command shell is opened, the RVM installation will be available by default on this system.</p>&#13;
<p class="indent">You can implement a similar customization to make your shell scripts available by default. First, you’ll create a development folder in your home directory to save all your shell scripts in. Then you can add this directory to <span class="literal">PATH</span> in your login file to reference your new scripts more easily.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_5"/>To identify your home directory, use the command <span class="literal">echo $HOME</span> to print the directory path in your terminal. Navigate to that directory and create your development folder (we recommend naming it <em>scripts</em>). Then, to add your development directory to your login script, open the login script file in your text editor and add the following line to the top of the file, replacing <span class="literal"><em>/path/to/scripts/</em></span> with the directory of your development folder.</p>&#13;
<pre class="programs">export PATH="<span class="codeitalic">/path/to/scripts/</span>:$PATH"</pre>&#13;
<p class="indent">Once this is done, any of the scripts you save in the development folder can then be called as a command in the shell.</p>&#13;
<h3 class="h3" id="ch00lev1sec04"><strong>Running Shell Scripts</strong></h3>&#13;
<p class="noindenta">We’ve used a few commands now, such as <span class="literal">echo</span>, <span class="literal">which</span>, and <span class="literal">cat</span>. But we’ve only used them individually, not all together in a shell script. Let’s write a shell script that runs them all consecutively, as shown in <a href="ch00.xhtml#ch0ex4">Listing 0-4</a>. This script will print <em>Hello World</em> followed by the file path of the <span class="literal">neqn</span> shell script, a shell script that should be in your bash files by default. Then it will use this path to print the contents of <span class="literal">neqn</span> to the screen. (The contents of <span class="literal">neqn</span> aren’t important at the moment; this is just being used as an example script.) This is a good example of using a shell script to perform a series of commands in order, in this case to see the full system path of a file and quickly check the contents.</p>&#13;
<pre class="programs">echo "Hello World"&#13;
echo $(which neqn)&#13;
cat $(which neqn)</pre>&#13;
<p class="listcap"><a id="ch0ex4"/><em>Listing 0-4: The contents of our first shell script</em></p>&#13;
<p class="indent">Open your favorite text editor (Vim or gedit on Linux and TextEdit on OS X are popular editors) and enter <a href="ch00.xhtml#ch0ex4">Listing 0-4</a>. Then save the shell script to your development directory and name it <em>intro</em>. Shell scripts don’t need a special file extension, so leave the extension blank (or you can add the extension <em>.sh</em> if you prefer, but this isn’t required). The first line of the shell script uses the <span class="literal">echo</span> command to simply print the text <span class="literal">Hello World</span>. The second line is a bit more complicated; it uses <span class="literal">which</span> to find the location of the bash file <em>neqn</em> and then uses the <span class="literal">echo</span> command to print the location to the screen. To run two commands like this, where one command is provided as an argument to another, bash uses a <em>subshell</em> to run the second command and store the output for use by the first command. In our example, the sub-shell runs the <span class="literal">which</span> command, which will return the full path to the <span class="literal">neqn</span> script. This path is then used as the argument for <span class="literal">echo</span>, which means <span class="literal">echo</span> prints the path to <em>neqn</em> to the screen. Finally, the same subshell trick passes the file path of <em>neqn</em> to the <span class="literal">cat</span> command, which prints the contents of the <span class="literal">neqn</span> shell script to the screen.</p>&#13;
<p class="indent">Once the file is saved, we can run the shell script from the terminal. <a href="ch00.xhtml#ch0ex5">Listing 0-5</a> shows the result.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_6"/>   $ <span class="codestrong">sh intro</span>&#13;
<span class="ent">➊</span> Hello World&#13;
<span class="ent">➋</span> /usr/bin/neqn&#13;
<span class="ent">➌</span> #!/bin/sh&#13;
   # Provision of this shell script should not be taken to imply that use of&#13;
   # GNU eqn with groff -Tascii|-Tlatin1|-Tutf8|-Tcp1047 is supported.&#13;
&#13;
   GROFF_RUNTIME="${GROFF_BIN_PATH=/usr/bin}:"&#13;
   PATH="$GROFF_RUNTIME$PATH"&#13;
   export PATH&#13;
   exec eqn -Tascii ${1+"$@"}&#13;
&#13;
   # eof&#13;
   $</pre>&#13;
<p class="listcap"><a id="ch0ex5"/><em>Listing 0-5: Running our first shell script</em></p>&#13;
<p class="indent">Run the shell script by using the <span class="literal">sh</span> command with the <span class="literal">intro</span> script passed as an argument. The <span class="literal">sh</span> command will step through each line in the file and execute it as if it were a bash command passed in the terminal. You can see here that <span class="literal">Hello World</span> <span class="ent">➊</span> is printed to the screen and then the path to <em>neqn</em> is printed <span class="ent">➋</span>. Finally, the contents of the <em>neqn</em> file are printed <span class="ent">➌</span>; this is the source code for the short <span class="literal">neqn</span> shell script on your hard drive (on OS X at least—the Linux version may look slightly different).</p>&#13;
<h3 class="h3" id="ch00lev1sec05"><strong>Making Shell Scripts More Intuitive</strong></h3>&#13;
<p class="noindenta">You don’t need to use the <span class="literal">sh</span> command to run your scripts. If you add one more line to the <span class="literal">intro</span> shell script and then modify the script’s filesystem permissions, you will be able to call the shell script directly, without <span class="literal">sh</span>, as you do other bash commands. In your text editor, update your <span class="literal">intro</span> script to the following:</p>&#13;
<pre class="programs"><span class="ent">➊</span> #!/bin/bash&#13;
   echo "Hello World"&#13;
   echo $(which neqn)&#13;
   cat $(which neqn)</pre>&#13;
<p class="indent">We’ve added a single line at the very top of the file referencing the filesystem path <em>/bin/bash</em> <span class="ent">➊</span>. This line is called the <em>shebang</em>. The shebang allows you to define which program will be run to interpret the script. Here we set the file as a bash file. You may have seen other shebangs, like those for the Perl language (<span class="literal">#!/usr/bin/perl</span>) or for Ruby (<span class="literal">#!/usr/bin/env ruby</span>).</p>&#13;
<p class="indent">With this new line added at the top, you’ll still need to set a file permission so you can execute the shell script as if it were a program. Do this in the bash terminal, as shown in <a href="ch00.xhtml#ch0ex6">Listing 0-6</a>.</p>&#13;
<pre class="programs"><span class="ent">➊</span> $ <span class="codestrong">chmod +x intro</span>&#13;
<span class="ent">➋</span> $ <span class="codestrong">./intro</span>&#13;
   Hello World&#13;
   /usr/bin/neqn&#13;
   #!/bin/sh&#13;
   # Provision of this shell script should not be taken to imply that use of&#13;
   # GNU eqn with groff -Tascii|-Tlatin1|-Tutf8|-Tcp1047 is supported.&#13;
&#13;
   GROFF_RUNTIME="${GROFF_BIN_PATH=/usr/bin}:"&#13;
   PATH="$GROFF_RUNTIME$PATH"&#13;
   export PATH&#13;
   exec eqn -Tascii ${1+"$@"}&#13;
&#13;
   # eof&#13;
   $</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_7"/><a id="ch0ex6"/><em>Listing 0-6: Changing the file permissions of the</em> <span class="literal"><em>intro</em></span> <em>script to allow execution</em></p>&#13;
<p class="indent">We use <span class="literal">chmod</span> <span class="ent">➊</span>, the change mode command, and pass it the <span class="literal">+x</span> argument, which makes a file executable. We pass this the filename of the file to change. After setting the file permissions to allow the shell script to run as a program, we can run the shell script as shown at <span class="ent">➋</span>, without needing to invoke bash directly. This is good shell-scripting practice and will prove useful as you hone your skills. Most of the scripts we write in this book will need to have the same executable permissions we set for the <span class="literal">intro</span> script.</p>&#13;
<p class="indent">This was just a simple example to show you how to run shell scripts and how to use shell scripts to run other shell scripts. Many of the shell scripts in the book will use this method, and you’ll see shebangs a lot in your future shell-scripting endeavors.</p>&#13;
<h3 class="h3" id="ch00lev1sec06"><strong>Why Shell Scripts?</strong></h3>&#13;
<p class="noindenta">You may be wondering why you’d use bash shell scripts instead of a fancy new language like Ruby or Go. These languages try to provide portability across many types of systems, but they generally aren’t installed by default. The reason is simple: every Unix machine has a basic shell, and the vast majority of shells use bash. As mentioned at the beginning of this chapter, Microsoft recently shipped Windows 10 with the same bash shell that the major Linux distributions and OS X have. This means your shell scripts can be more portable than ever, with little work on your part. You can also more concisely and easily accomplish maintenance and system tasks with shell scripts than you can with other languages. Bash is still wanting in some ways, but you’ll learn how to smooth over some of these shortcomings in this book.</p>&#13;
<p class="indent"><a href="ch00.xhtml#ch0ex7">Listing 0-7</a> shows an example of a handy little shell script (really, just a bash one-liner!) that’s totally portable. The script finds how many pages are in a folder of OpenOffice documents—especially useful for writers.</p>&#13;
<pre class="programs">#!/bin/bash&#13;
echo "$(exiftool *.odt | grep Page-count | cut -d ":" -f2 | tr '\n' '+')""0" | bc</pre>&#13;
<p class="listcap"><a id="ch0ex7"/><em>Listing 0-7: A bash script for determining how many pages are in a folder of OpenOffice documents</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_8"/>We won’t go into the details of how this works—we’re just getting started, after all! But at a high level, it extracts the page count information for each document, strings the page counts together with addition operators, and pipes the arithmetic to a command line calculator that generates the sum. All that, in basically a single line. You’ll find more cool shell scripts like this one throughout the book, and, after you’ve gotten some practice, this script should make perfect sense and seem very simple!</p>&#13;
<h3 class="h3" id="ch00lev1sec07"><strong>Let’s Get Cracking</strong></h3>&#13;
<p class="noindenta">You should have a general idea of what shell scripting is now, if you didn’t have one already. Creating bite-sized scripts to accomplish specific tasks is at the heart of Unix philosophy. Understanding how to make your own scripts and expand your own Unix systems to better fit your needs will make you a power user. This chapter is just a taste of what is to come in the book: some really wicked cool shell scripts!</p>&#13;
</body></html>