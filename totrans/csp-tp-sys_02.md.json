["```\npublic readonly struct Color\n{\n    public Color(int r, int g, int b)\n        => (Red, Green, Blue) = (r, g, b);\n    public int Red {get;}\n    public int Green {get;}\n    public int Blue {get;}\n}\n```", "```\npublic class Color\n{\n`--snip--`\n```", "```\npublic record Color(int Red, int Green, int Blue);\n```", "```\nvar tomato = new Color(Red: 255, Green: 99, Blue: 71);\nAssert.That(tomato.Red, Is.EqualTo(255));\nAssert.That(tomato.Green, Is.EqualTo(99));\nAssert.That(tomato.Blue, Is.EqualTo(71));\n```", "```\npublic readonly record struct Color(int Red, int Green, int Blue);\n```", "```\npublic class Command\n{\n    public virtual IEnumerable<Result> RunQuery(string query)\n    {\n        using var transaction = connection.BeginTransaction();\n        return connection.Execute(transaction, query);\n    }\n    private readonly DatabaseConnection connection;\n}\npublic class DummyCommand : Command\n{\n    public override IEnumerable<Result> RunQuery(string query)\n    {\n        return new List<Result>();\n    }\n}\n```", "```\npublic readonly struct Color\n{\n    public Color(int r, int g, int b)\n        => (Red, Green, Blue) = (r, g, b);\n    public int Red {get;}\n    public int Green {get;}\n    public int Blue {get;}\n}\n```", "```\npublic class Brush\n{\n`--snip--`\n    public enum BrushStyle {Solid, Gradient, Texture}\n    private readonly int width;\n    private readonly Color color;\n    private readonly BrushStyle style;\n}\n```", "```\nvar colors = new Color[3];\n```", "```\nstruct Node\n{\n    Node p;\n}\n```", "```\nstruct Tree\n{\n    Node root;\n}\nstruct Node\n{\n    Tree leftChild, rightChild;\n}\n```", "```\npublic readonly struct Color\n{\n    public Color(int r, int g, int b)\n        => (Red, Green, Blue) = (r, g, b);\n    public int Red {get;}\n    public int Green {get;}\n    public int Blue {get;}\n}\nvar red = new Color(0xFF, 0, 0);\nvar green = new Color(0, 0xFF, 0);\n❶ object copy = green;\nAssert.That(object.Equals(❷ red, copy), Is.False);\nvar copyGreen = ❸ (Color)copy;\n```", "```\nvar thing = new Thing {Host = \"Palmer\"};\n❶ var copy = thing;\n❷ copy.Host = \"Bennings\";\nAssert.That(thing.Host, Is.EqualTo(\"Palmer\"));\n```", "```\npublic ??? Thing\n{\n    public string Host {get; set;}\n}\nvar thing = new Thing {Host = \"Palmer\"};\nvar clone = new Thing {Host = \"Palmer\"};\nAssert.That(clone.Equals(thing), Is.True);\n```", "```\nvar thing = new Thing();\n```", "```\npublic struct MusicTrack\n{\n    public string Artist {get; set;}\n    public string Name {get; set;}\n    public override string ToString()\n        => $\"{Artist.ToUpper()}: {Name.ToUpper()}\";\n}\n var defaultTrack = new MusicTrack();\nvar print = defaultTrack.ToString();\n```", "```\npublic readonly struct MusicTrack\n{\n    public MusicTrack(string artist, string name)\n    => (Artist, Name) = (artist ?? string.Empty, name ?? string.Empty);\n    public string Artist {get;}\n    public string Name {get;}\n    public override string ToString()\n        => $\"{Artist.ToUpper()}: {Name.ToUpper()}\";\n}\n```", "```\npublic override string ToString()\n    => $\"{Artist?.ToUpper()}: {Name?.ToUpper()}\";\n```", "```\nvar track = new MusicTrack();\n```", "```\n[CS7036] There is no argument given that corresponds to the required formal parameter 'artist'\nof 'MusicTrack.MusicTrack(string, string)'\n```", "```\npublic sealed record Color(int Red, int Green, int Blue);\n```", "```\npublic Color(int Red, int Green, int Blue)\n    => (this.Red, this.Green, this.Blue) = (Red, Green, Blue);\n```", "```\npublic readonly struct Color\n{\n    public Color(int red, int green, int blue)\n        => (Red, Green, Blue) = (red, green, blue);\n    public Color(uint rgb)\n        => (Red, Green, Blue) = Unpack(rgb);\n    public int Red {get;}\n    public int Green {get;}\n    public int Blue {get;}\n}\n```", "```\nvar orange = new Color(0xFFA500);\nvar yellow = new Color(0xFF, 0xFF, 0);\n```", "```\npublic sealed class Playlist\n{\n    public Playlist(IEnumerable<MusicTrack> items)\n      ❶ => queue = new(items);\n    public Playlist()\n      ❷ => queue = new();\n public void Append(MusicTrack item)\n        => queue.Add(item);\n`--snip--`\n    private Queue<MusicTrack> queue;\n}\n```", "```\npublic readonly struct MusicTrack\n{\n    public MusicTrack()\n        => (Artist, Name) = (string.Empty, string.Empty);\n    public MusicTrack(string artist, string name)\n        => (Artist, Name) = (artist, name);\n    public string Artist {get;}\n    public string Name {get;}\n    public override string ToString()\n        => $\"{Artist?.ToUpper()}: {Name?.ToUpper()}\";\n}\n```", "```\nvar favorites = new MusicTrack[3];\nvar print = favorites[0].ToString();\n```", "```\npublic struct Color\n{\n    public int red;\n    public int green;\n    public int blue;\n}\nColor background;   // initially unassigned variable\nbackground.red = 0xFF;\nbackground.green = 0xA5;\nbackground.blue = 0;\nAssert.That(background.red, Is.EqualTo(0xFF));\n```", "```\npublic sealed record Color\n{\n    private Color() {}\n    public static Color Black {get;} = new Color();\n`--snip--`\n}\n```", "```\nvar black = new Color();\n[CS0122] 'Color.Color()' is inaccessible due to its protection level\n```", "```\npublic sealed class Playlist\n{\n`--snip--`\n    public string Name {get; set;} = \"_playlist\";\n    private Queue<MusicTrack> queue = new();\n}\n```", "```\nvar fineBrush = new Brush {Width = 2};\n```", "```\npublic readonly struct Color\n{\n    public int Red {get; init;}\n    public int Green {get; init;}\n    public int Blue {get; init;}\n}\nvar orange = new Color {Red = 0xFF, Green = 0xA5};\nAssert.That(orange.Red, Is.EqualTo(0xFF));\nAssert.That(orange.Green, Is.EqualTo(0xA5));\nAssert.That(orange.Blue, Is.EqualTo(0));\n```", "```\npublic sealed record Color(int Red, int Green, int Blue);\nvar orange = new Color(0xFF, 0xA5, 0);\nvar yellow = orange with {Green = 0xFF};\nAssert.That(yellow.Red, Is.EqualTo(0xFF));\nAssert.That(yellow.Green, Is.EqualTo(0xFF));\nAssert.That(orange.Green, Is.EqualTo(0xA5)); // unchanged in orange\nAssert.That(orange.Blue, Is.EqualTo(0));\n```", "```\npublic readonly struct Speed\n{\n`--snip--`\n}\nvar c = new Speed();\nAssert.That(c == null, Is.False);\n```", "```\n[CS0019] Operator '==' cannot be applied to operands of type 'Speed' and '<null>'\n```", "```\nAssert.That(someObject is null, Is.True);\n```", "```\npublic static int Compare<T>(T left, T right)\n{\n    if(left is null) return right is null ? 0 : -1;\n`--snip--`\n}\n```", "```\npublic static T Consume<T>(IProducerConsumerCollection<T> collection)\n    => collection.TryTake(out var item) ? item : null;\n```", "```\n[CS0403] Cannot convert null to type parameter 'T' because it could be a non-nullable value\ntype. Consider using 'default(T)' instead.\n```", "```\npublic readonly struct Node<T>\n{\n    public Node(int index)\n    {\n        idx = index;\n        contained = default;\n    }\n private readonly int idx;\n    private readonly T contained;\n}\n```", "```\nint x = default;\nint y = 0;\nAssert.That(x.Equals(y), Is.True);\n```", "```\nint? x = null;\nint y = 0;\nAssert.That(x.Equals(y), Is.False);\n```", "```\nint? x = default;\nint? y = null;\nAssert.That(x.Equals(y), Is.True);\n```", "```\nobject speed = new Speed();\nvar actual = speed as Speed;\n```", "```\nvar actual = speed as Speed?;\n```", "```\nobject brush = null;\n```", "```\n[CS8600] Converting null literal or possible null value to non-nullable type\n```", "```\npublic static string ToTitleCase(string original)\n{\n    var txtInfo = Thread.CurrentThread.CurrentCulture.TextInfo;\n    return txtInfo.ToTitleCase(original.Trim());\n}\n```", "```\nvar names = new List<string?>();\n// Load names from somewhere, may contain null elements\n--`snip--`\nvar properNames = names.Select(name => ToTitleCase(name));\n```", "```\n[CS8604] Possible null reference argument for parameter 'original' in 'string\nToTitleCase(string original)'.\n```", "```\nforeach (var name in names)\n{\n    if(name is not null)\n        properNames.Add(ToTitleCase(name));\n}\n```", "```\nvar properNames = names\n    .Where(name => name is not null)\n    .Select(name => ToTitleCase(name));\n```", "```\nvar properNames = names\n    .Where(name => name is not null)\n    .Select(name => ToTitleCase(name!));\n```"]