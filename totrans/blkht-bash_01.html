<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch1">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_1" aria-label="1"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">1</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">BASH BASICS</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS"><i>Bash</i> is a command language interpreter that provides an environment in which users can execute commands and run applications. As penetration testers and security practitioners, we frequently write bash scripts to automate a wide variety of tasks, making bash an essential tool for hackers. In this chapter, you’ll set up your bash development environment, explore useful Linux commands to include in future scripts, and learn the fundamentals of the language’s syntax, including variables, arrays, streams, arguments, and operators.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-5"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_2" aria-label="2"/><span class="SANS_Futura_Std_Bold_B_11">Environmental Setup</span></h2>&#13;
<p class="TNI1">Before you begin learning bash, you need both a bash shell running in a terminal and a text editor. You can access these on any major operating system by following the instructions in this section.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Beginning in <a href="chapter4.xhtml">Chapter 4</a>, you’ll use Kali Linux to run bash commands and complete hacking labs. If you’d like to set up Kali now, consult the steps included in <a href="chapter3.xhtml">Chapter 3</a>.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h2-1"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing the Bash Shell</span></h3>&#13;
<p class="TNI1">If you’re running Linux or macOS, bash should already be available. On Linux, open the Terminal application by pressing <small>ALT</small>-<small>CTRL</small>-T. On macOS, you can find the terminal by navigating to the Launchpad icon on the system dock.</p>&#13;
<p class="TX">Kali and macOS use the Z Shell by default, so when you open a new terminal window, you’ll have to enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">exec bash</span> to switch to a bash shell before you run commands. If you want to change your default shell to bash so you don’t have to manually switch shells, you can use the <span class="SANS_TheSansMonoCd_W7Bold_B_11">chsh -s /bin/bash</span> command.</p>&#13;
<p class="TX">If you’re running Windows, you can use the Windows Subsystem for Linux (WSL), which lets you run Linux distributions and access a bash environment. The official Microsoft WSL documentation page describes how to install it: <i><a href="https://learn.microsoft.com/en-us/windows/wsl/install">https://learn.microsoft.com/en-us/windows/wsl/install</a></i>.</p>&#13;
<p class="TX">An alternative to WSL is <i>Cygwin</i>, which emulates a Linux environment by providing a collection of Linux utilities and system-call functionalities. To install Cygwin, visit <i><a href="https://www.cygwin.com/install.html">https://www.cygwin.com/install.html</a></i> to download the setup file, and then follow the installation wizard.</p>&#13;
<p class="TX">Cygwin installs itself by default to the <i>C:\cygwin64\</i> Windows path. To execute your bash scripts, save the scripts in the directory containing your username at <i>C:\cygwin64\home</i>. For example, if your username is <i>david</i>, you should save your scripts under <i>C:\cygwin64\home\david</i>. Then, from the Cygwin terminal, you’ll be able to change the directory to the home directory to run your scripts.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-2"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing a Text Editor</span></h3>&#13;
<p class="TNI1">To start writing bash scripts, you’ll need a text editor, preferably one with handy features such as syntax highlighting built in. You can choose between terminal-based text editors and graphical user interface–based text editors. Terminal-based text editors (such as vi or GNU nano) are useful because during a penetration test they may be the only available options when you need to develop a script on the spot.</p>&#13;
<p class="TX">If you prefer graphical text editors, Sublime Text (<i><a href="https://www.sublimetext.com">https://www.sublimetext.com</a></i>) is one option you could use. In Sublime Text, you can toggle on the syntax highlighting feature for bash scripts by clicking <b>Plain Text</b> in the bottom-right corner and choosing <b>Bash</b> from the drop-down list of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>languages. If you’re using a different text editor, reference its official documentation to learn how to turn on syntax highlighting.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h2 class="H1" id="sec4"><span id="h1-6"/><span class="SANS_Futura_Std_Bold_B_11">Exploring the Shell</span></h2>&#13;
<p class="TNI1">Now that you have a functional bash environment, it’s time to learn some basics. Although you’ll develop scripts in your text editor, you’ll also probably find yourself frequently running single commands in the terminal. This is because you often need to see how a command runs and the kind of output it produces before including it in a script. Let’s get started by running some bash commands.</p>&#13;
<p class="TX">First, enter the following command to verify that bash is available on your system:</p>&#13;
<pre><code>$ <b>bash --version</b></code></pre>&#13;
<p class="TX">The version in the output will depend on the operating system you are running.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-3"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Environment Variables</span></h3>&#13;
<p class="TNI1">When running in a terminal, bash loads a set of <i>environment variables</i> with every new session that gets invoked. Programs can use these environment variables for various purposes, such as discovering the identity of the user running the script, the location of their home directory, and their default shell.</p>&#13;
<p class="TX">To see the list of environment variables set by bash, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">env</span> command directly from the shell (<a href="chapter1.xhtml#Lis1-1">Listing 1-1</a>).</p>&#13;
<span id="Lis1-1"/><pre><code>$ <b>env</b>&#13;
&#13;
SHELL=/bin/bash&#13;
LANGUAGE=en_CA:en&#13;
DESKTOP_SESSION=ubuntu&#13;
PWD=/home/user&#13;
<var>--snip--</var></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-1: Listing bash’s environment variables</span></p>&#13;
<p class="TX">You can read individual environment variables by using the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command, which writes text to the terminal. For example, to print the default shell set for the user, use the <span class="SANS_TheSansMonoCd_W5Regular_11">SHELL</span> environment variable preceded by a dollar sign (<span class="SANS_TheSansMonoCd_W5Regular_11">$</span>) and surrounded by curly brackets (<span class="SANS_TheSansMonoCd_W5Regular_11">{}</span>). This will cause bash to expand the variable to its assigned value, as shown in <a href="chapter1.xhtml#Lis1-2">Listing 1-2</a>.</p>&#13;
<span id="Lis1-2"/><pre><code>$ <b>echo ${SHELL}</b>&#13;
&#13;
/bin/bash&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-2: Printing an environment variable to the terminal</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>Here are some of the default environment variables available:</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_B_11">BASH_VERSION</span> The bash version running</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">BASHPID</span> The process identifier (PID) of the current bash process</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">GROUPS</span> A list of groups the running user is a member of</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">HOSTNAME</span> The name of the host</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">OSTYPE</span> The type of operating system</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">PWD</span> The current working directory</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">RANDOM</span> A random number from 0 to 32,767</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">UID</span> The user ID (UID) of the current user</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_B_11">SHELL</span> The full pathname to the shell</p>&#13;
<p class="TX">The following examples show how to check the values of a few of these environment variables:</p>&#13;
<pre><code>$ <b>echo ${RANDOM}</b>&#13;
8744&#13;
&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_B_11">echo ${UID}</span>&#13;
1000&#13;
&#13;
$ <b>echo ${OSTYPE}</b>&#13;
linux-gnu&#13;
</code></pre>&#13;
<p class="TX">These commands generate a random number, output the current user’s ID, and display the operating system type, respectively. You can find the full list of environment variables at <i><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html">https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html</a></i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-4"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running Linux Commands</span></h3>&#13;
<p class="TNI1">The bash scripts you’ll write in this book will run common Linux tools, so if you’re not yet familiar with command line navigation and file modification utilities such as <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">touch</span>, try exploring them by using the <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> (manual) command. You can insert it before any Linux command to open a terminal-based guide that explains that command’s use and options, as shown in <a href="chapter1.xhtml#Lis1-3">Listing 1-3</a>.</p>&#13;
<span id="Lis1-3"/><pre><code>$ <b>man ls</b>&#13;
&#13;
NAME&#13;
      ls - list directory contents&#13;
&#13;
SYNOPSIS&#13;
      ls [OPTION]... [FILE]...&#13;
&#13;
DESCRIPTION&#13;
      List information about the FILEs (the current directory by default).&#13;
      Sort entries alphabetically if none of -cftuvSUX nor&#13;
      --sort is specified.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/>      Mandatory arguments to long options are mandatory for short options too.&#13;
      -a, --all&#13;
      do not ignore entries starting with .&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-3: Accessing a command’s manual page</span></p>&#13;
<p class="TX">Linux commands can accept many types of input on the command line. For example, you can enter <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> without any arguments to see files and directories, or pass it arguments to, for instance, display the list of files all on one line.</p>&#13;
<p class="TX">Arguments are passed on the command line by using either short-form or long-form argument syntax, depending on the command in use. <i>Short-form</i> syntax uses a single dash (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span>) followed by one or more characters. The following example uses <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> to list files and directories with a short-form argument syntax:</p>&#13;
<pre><code>$<b> ls -l</b></code></pre>&#13;
<p class="TX">Some commands let you supply multiple arguments by joining them together or listing them separately:</p>&#13;
<pre><code>$ <b>ls -la</b>&#13;
$ <b>ls -l -a</b>&#13;
</code></pre>&#13;
<p class="TX">Note that some commands may throw errors if you attempt to join two arguments with a single dash, so use the <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> command to learn the syntax that’s permitted.</p>&#13;
<p class="TX">Some command options may allow you to use <i>long-form</i> argument syntax, such as the <span class="SANS_TheSansMonoCd_W5Regular_11">--help</span> command to list the available options. Long-form argument syntax is prepended by the double dash (<span class="SANS_TheSansMonoCd_W5Regular_11">--</span>) symbol:</p>&#13;
<pre><code>$ <b>ls --help</b></code></pre>&#13;
<p class="TX">Sometimes the same command argument supports both short- and long-form argument syntax for convenience. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> supports the argument <span class="SANS_TheSansMonoCd_W5Regular_11">-a</span> (all) to display all files, including those that are hidden. (Files starting with a dot in their name are considered hidden in Linux.) However, you could also pass the argument <span class="SANS_TheSansMonoCd_W5Regular_11">--all</span>, and the outcome would be identical:</p>&#13;
<pre><code>$ <b>ls -a</b>&#13;
$ <b>ls --all</b>&#13;
</code></pre>&#13;
<p class="TX">Let’s execute some simple Linux commands so you can see the variation of options each offers. First, create a single directory with <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span>:</p>&#13;
<pre><code>$ <b>mkdir directory1</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/>Now let’s create two directories with <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span>:</p>&#13;
<pre><code>$ <b>mkdir directory2 directory3</b></code></pre>&#13;
<p class="TX">Next, list processes by using <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> with short-form argument syntax, supplying the arguments separately and then together:</p>&#13;
<pre><code>$ <b>ps -e -f</b>&#13;
$ <b>ps -ef</b>&#13;
</code></pre>&#13;
<p class="TX">Finally, let’s display the available disk space by using <span class="SANS_TheSansMonoCd_W5Regular_11">df</span> with long-form argument syntax:</p>&#13;
<pre><code>$ <b>df --human-readable</b></code></pre>&#13;
<p class="TX">Throughout this book, you’ll use Linux commands such as these in your scripts.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h2 class="H1" id="sec7"><span id="h1-7"/><span class="SANS_Futura_Std_Bold_B_11">Elements of a Bash Script</span></h2>&#13;
<p class="TNI1">In this section, you’ll learn the building blocks of a bash script. You’ll use comments to document what a script does, tell Linux to use a specific interpreter to execute the script, and style your scripts for better readability.</p>&#13;
<p class="TX">Bash doesn’t have an official style guide, but we recommend adhering to Google’s Shell Style Guide (<i><a href="https://google.github.io/styleguide/shellguide.html">https://google.github.io/styleguide/shellguide.html</a></i>), which outlines best practices to follow when developing bash code. If you work on a team of penetration testers and have an exploit code repository, using good code styling practices will help your team maintain it.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h2-5"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Shebang Line</span></h3>&#13;
<p class="TNI1">Every script should begin with the <i>shebang</i> line, a character sequence that starts with the hash and exclamation marks (<span class="SANS_TheSansMonoCd_W5Regular_11">#!</span>), followed by the full path to the script interpreter. <a href="chapter1.xhtml#Lis1-4">Listing 1-4</a> shows an example of a shebang line for a typical bash script.</p>&#13;
<span id="Lis1-4"/><pre><code>#!/bin/bash</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-4: A bash shebang line</span></p>&#13;
<p class="TX">The bash interpreter is typically located at <i>/bin/bash</i>. If you instead wrote scripts in Python or Ruby, your shebang line would include the full path to the Python or Ruby interpreter.</p>&#13;
<p class="TX">You’ll sometimes encounter bash scripts that use a shebang line like this one:</p>&#13;
<pre><code>#!/usr/bin/env bash</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/>You may want to use this shebang line because it is more portable than the one in <a href="chapter1.xhtml#Lis1-4">Listing 1-4</a>. Some Linux distributions place the bash interpreter in different system locations, and this shebang line will attempt to find that location. This approach could be particularly useful in penetration tests, where you might not know the location of the bash interpreter on the target machine. For simplicity, however, we’ll use the shebang version from <a href="chapter1.xhtml#Lis1-4">Listing 1-4</a> throughout this book.</p>&#13;
<p class="TX">The shebang line can also take optional arguments to change how the script executes. For example, you could pass the special argument <span class="SANS_TheSansMonoCd_W5Regular_11">-x</span> to your bash shebang, like so:</p>&#13;
<pre><code>#!/bin/bash -x</code></pre>&#13;
<p class="TX">This option prints all commands and their arguments as they are executed to the terminal. It is useful for debugging scripts as you’re developing them.</p>&#13;
<p class="TX">Another example of an optional argument is <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span>:</p>&#13;
<pre><code>#!/bin/bash -r</code></pre>&#13;
<p class="TX">This option creates a <i>restricted bash shell</i>, which restricts certain potentially dangerous commands that could, for example, navigate to certain directories, change sensitive environment variables, or attempt to turn off the restricted shell from within the script.</p>&#13;
<p class="TX">Specifying an argument within the shebang line requires modifying the script, but you can also pass arguments to the bash interpreter by using this syntax:</p>&#13;
<pre><code>$ <b>bash -r myscript.sh</b></code></pre>&#13;
<p class="TX">Whether you pass arguments to the bash interpreter on the command line or on the shebang line won’t make a difference. The command line option is just an easier way to trigger different modes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h2-6"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comments</span></h3>&#13;
<p class="TNI1"><i>Comments</i> are parts of a script that the bash interpreter won’t treat as code and that can improve the readability of a program. Imagine that you write a long script and, a few years later, need to modify some of its logic. If you didn’t write comments to explain what you did, you might find it quite challenging to remember the purpose of each section.</p>&#13;
<p class="TX">Comments in bash start with a hash mark (<span class="SANS_TheSansMonoCd_W5Regular_11">#</span>), as shown in <a href="chapter1.xhtml#Lis1-5">Listing 1-5</a>.</p>&#13;
<span id="Lis1-5"/><pre><code>#!/bin/bash&#13;
&#13;
# This is my first script.&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-5: A comment in a bash script</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>Except for the shebang line, every line that starts with a hash mark is considered a comment. If you wrote the shebang line twice, bash would consider the second one to be a comment.</p>&#13;
<p class="TX">To write a multiline comment, precede each individual line with the hash mark, as shown in <a href="chapter1.xhtml#Lis1-6">Listing 1-6</a>.</p>&#13;
<span id="Lis1-6"/><pre><code>#!/bin/bash&#13;
&#13;
# This is my first script!&#13;
# Bash scripting is fun...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-6: A multiline comment</span></p>&#13;
<p class="TX">In addition to documenting a script’s logic, comments can provide metadata to indicate the author, the script’s version, the person to contact for issues, and more. These comments usually appear at the top part of the script, below the shebang line.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-7"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Commands</span></h3>&#13;
<p class="TNI1">Scripts can be as short as two lines: the shebang line and a Linux command. Let’s write a simple script that prints <span class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</span> to the terminal. Open your text editor and enter the following:</p>&#13;
<pre><code><b>#!/bin/bash</b>&#13;
&#13;
<b>echo "Hello World!"</b>&#13;
</code></pre>&#13;
<p class="TX">In this example, we use the shebang statement to specify the interpreter of choice, bash. Then we use the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command to print the string <span class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</span> to the screen.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-8"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Execution</span></h3>&#13;
<p class="TNI1">To run the script, save the file as <i>helloworld.sh</i>, open the terminal, and navigate to the directory where the script resides. If you saved the file in your home directory, you should run the set of commands shown in <a href="chapter1.xhtml#Lis1-7">Listing 1-7</a>.</p>&#13;
<span id="Lis1-7"/><pre><code>$ <b>cd ~</b>&#13;
$ <b>chmod u+x helloworld.sh</b>&#13;
$ <b>./helloworld.sh</b>&#13;
&#13;
Hello World!&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-7: Running a script from the home directory</span></p>&#13;
<p class="TX">We use the <span class="SANS_TheSansMonoCd_W5Regular_11">cd</span> command to change directories. The tilde (<span class="SANS_TheSansMonoCd_W5Regular_11">~</span>) represents the home directory of the current running user. Next, we use <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span> to set the executable (<span class="SANS_TheSansMonoCd_W5Regular_11">u+x</span>) permissions for the user who owns the file (in this case, us). We run the script by using dot-slash notation (<span class="SANS_TheSansMonoCd_W5Regular_11">./</span>) followed by the script’s name. The dot (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) represents the current directory, so <span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>we’re essentially telling bash to run <i>helloworld.sh</i> from the current working directory.</p>&#13;
<p class="TX">You can also run a bash script with the following syntax:</p>&#13;
<pre><code>$ <b>bash helloworld.sh</b></code></pre>&#13;
<p class="TX">Because we specified the <span class="SANS_TheSansMonoCd_W5Regular_11">bash</span> command, the script will run using the bash interpreter and won’t require a shebang line. Also, if you use the <span class="SANS_TheSansMonoCd_W5Regular_11">bash</span> command, the script doesn’t have to be set with an executable permission (<span class="SANS_TheSansMonoCd_W5Regular_11">+x</span>). In later chapters, you’ll learn about the permission model in more depth and explore its importance in the context of finding misconfigurations in penetration tests.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h2-9"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Debugging</span></h3>&#13;
<p class="TNI1">Errors will inevitably occur when you’re developing bash scripts. Luckily, debugging scripts is quite intuitive. An easy way to check for errors early is by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-n</span> parameter when running a script:</p>&#13;
<pre><code>$ <b>bash -n script.sh</b></code></pre>&#13;
<p class="TX">This parameter will read the commands in the script but won’t execute them, so any syntax errors that exist will be shown onscreen. You can think of <span class="SANS_TheSansMonoCd_W5Regular_11">-n</span> as a dry-run method to test the validity of your syntax.</p>&#13;
<p class="TX">You can also use the <span class="SANS_TheSansMonoCd_W5Regular_11">-x</span> parameter to turn on verbose mode, which lets you see commands being executed and will help you debug issues as the script executes in real time:</p>&#13;
<pre><code>$ <b>bash -x script.sh</b></code></pre>&#13;
<p class="TX">If you want to start debugging at a given point in the script, include the <span class="SANS_TheSansMonoCd_W5Regular_11">set</span> command in the script itself (<a href="chapter1.xhtml#Lis1-8">Listing 1-8</a>).</p>&#13;
<span id="Lis1-8"/><pre><code>#!/bin/bash&#13;
set -x&#13;
&#13;
<var>--snip--</var>&#13;
&#13;
set +x&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-8: Using set to debug a script</span></p>&#13;
<p class="TX">You can think of <span class="SANS_TheSansMonoCd_W5Regular_11">set</span> as a valve that turns a certain option on and off. In this example, the first command sets the debugging mode (<span class="SANS_TheSansMonoCd_W5Regular_11">set -x</span>), while the last command (<span class="SANS_TheSansMonoCd_W5Regular_11">set</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+x</span>) disables it. By using <span class="SANS_TheSansMonoCd_W5Regular_11">set</span>, you can avoid generating a massive amount of noise in your terminal when your script is large and contains a specific problem area.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h1-8"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/><span class="SANS_Futura_Std_Bold_B_11">Basic Syntax</span></h2>&#13;
<p class="TNI1">At this point, you’ve written a two-line script that prints the message <span class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</span> to the screen. You’ve also learned how to run and debug a script. Now you’ll learn some bash syntax so you can write more useful scripts.</p>&#13;
<p class="TX">The most basic bash scripts are just lists of Linux commands collected in a single file. For example, you could write a script that creates resources on a system and then prints information about these resources to the screen (<a href="chapter1.xhtml#Lis1-9">Listing 1-9</a>).</p>&#13;
<span id="Lis1-9"/><pre><code>#!/bin/bash&#13;
&#13;
# All this script does is create a directory, create a file&#13;
# within the directory, and then list the contents of the directory.&#13;
&#13;
mkdir mydirectory&#13;
touch mydirectory/myfile&#13;
ls -l mydirectory&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-9: A bash script that lists directory contents</span></p>&#13;
<p class="TX">In this example, we use <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span> to create a directory named <i>mydirectory</i>. Next, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">touch</span> command to create a file named <i>myfile</i> within the directory. Finally, we run the <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span> command to list the contents of <i>mydirectory</i>.</p>&#13;
<p class="TX">The output of the script looks as follows:</p>&#13;
<pre><code><var>--snip--</var>&#13;
-rw-r--r-- 1 user user 0 Feb 16 13:37 myfile&#13;
</code></pre>&#13;
<p class="TX">However, this line-by-line strategy could be improved in several ways. First, when a command runs, bash waits until it finishes before advancing to the next line. If you include a long-running command (such as a file download or large file copy), the remaining commands won’t be executed until that command has completed. We also have yet to implement any checks to validate that all commands have executed correctly. You’ll need to write more-intelligent programs to reduce errors during runtime.</p>&#13;
<p class="TX">Writing sophisticated programs often requires using features like variables, conditions, loops, and tests. For example, what if we want to change this script so that it checks for enough space on the disk before attempting to create new files and directories? Or what if we could check whether the directory and file creation actions actually succeeded? This section and <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> introduce you to the syntactical elements you’ll need to accomplish these tasks.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H2" id="sec14"><span id="h2-10"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variables</span></h3>&#13;
<p class="TNI1">Every scripting language has variables. <i>Variables</i> are names that we assign to memory locations and that hold a value; they act like placeholders or labels. We can directly assign values to variables, or we can execute bash commands and store their output as variable values to use for various purposes.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/>If you’ve worked with programming languages, you may know that variables can be of different types, such as integers, strings, and arrays. In bash, variables are untyped; they’re all considered character strings. Even so, you’ll see that bash allows you to create arrays, access array elements, or perform arithmetic operations so long as the variable value consists of only numbers.</p>&#13;
<p class="TX">The following rules govern the naming of bash variables:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">They can include alphanumeric characters.</li>&#13;
<li class="ListBullet">They cannot start with a number.</li>&#13;
<li class="ListBullet">They can contain an underscore (<span class="SANS_TheSansMonoCd_W5Regular_11">_</span>).</li>&#13;
<li class="ListBullet">They cannot contain whitespace.</li>&#13;
</ul>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Assigning and Accessing Variables</span></h4>&#13;
<p class="TNI1">Let’s assign a variable. Open a terminal and enter the following directly within the command prompt:</p>&#13;
<pre><code>$ <b>book="black hat bash"</b></code></pre>&#13;
<p class="TX">We create a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">book</span> and, by using the equal sign (<span class="SANS_TheSansMonoCd_W5Regular_11">=</span>), assign the value <span class="SANS_TheSansMonoCd_W5Regular_11">black hat bash</span> to it. Now we can use this variable in a command. In the following example, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command to print the variable to the screen:</p>&#13;
<pre><code>$ <b>echo "This book's name is ${book}"</b>&#13;
This book's name is black hat bash&#13;
</code></pre>&#13;
<p class="TX">Here we were able to print the variable by using the <span class="SANS_TheSansMonoCd_W5Regular_11">${book}</span> syntax within an <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command. This will expand the <span class="SANS_TheSansMonoCd_W5Regular_11">book</span> variable to its value. You can also expand a variable by using just the dollar sign (<span class="SANS_TheSansMonoCd_W5Regular_11">$</span>) followed by the variable:</p>&#13;
<pre><code>$ <b>echo "This book's name is $book"</b></code></pre>&#13;
<p class="TX">Using the <span class="SANS_TheSansMonoCd_W5Regular_11">${}</span> syntax makes the code less prone to misinterpretation and helps readers understand when a variable starts and ends.</p>&#13;
<p class="TX">You can also assign the output of a command to a variable by using the command substitution syntax <span class="SANS_TheSansMonoCd_W5Regular_11">$()</span>, placing the desired command within the parentheses. You’ll use this syntax often in bash programming. Try running the commands in <a href="chapter1.xhtml#Lis1-10">Listing 1-10</a>.</p>&#13;
<span id="Lis1-10"/><pre><code>$ <b>root_directory=$(ls -ld /)</b>&#13;
$ <b>echo "${root_directory}"</b>&#13;
&#13;
drwxr-xr-x 1 user user 0 Feb 13 20:12 /&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-10: Assigning command output to a variable</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>We assign the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">ls -ld /</span> command to a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">root_directory</span> and then use <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> to print the output of the command. In this output, you can see that we were able to get metadata about the root directory (<span class="SANS_TheSansMonoCd_W5Regular_11">/</span>), such as its type and permission, size, user and group owners, and the timestamp of the last modification.</p>&#13;
<p class="TX">Note that you shouldn’t leave whitespace around the assignment symbol (<span class="SANS_TheSansMonoCd_W5Regular_11">=</span>) when creating a variable:</p>&#13;
<pre><code>book = "this is an invalid variable assignment"</code></pre>&#13;
<p class="TX">The previous variable assignment syntax is considered invalid.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H3" id="sec16"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Unassigning Variables</span></h4>&#13;
<p class="TNI1">You can unassign assigned variables by using the <span class="SANS_TheSansMonoCd_W5Regular_11">unset</span> command, as shown in <a href="chapter1.xhtml#Lis1-11">Listing 1-11</a>.</p>&#13;
<span id="Lis1-11"/><pre><code>$ <b>book="Black Hat Bash"</b>&#13;
$ <b>unset book</b>&#13;
$ <b>echo "${book}"</b>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-11: Unassigning variables</span></p>&#13;
<p class="TX">If you execute these commands in the terminal, no output will be shown after the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command executes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Scoping Variables</span></h4>&#13;
<p class="TNI1"><i>Global</i> variables are those available to the entire program. But variables in bash can also be <i>scoped</i> so that they are accessible only from within a certain block of code. These <i>local</i> variables are declared using the <span class="SANS_TheSansMonoCd_W5Regular_11">local</span> keyword. The script in <a href="chapter1.xhtml#Lis1-12">Listing 1-12</a> shows how local and global variables work.</p>&#13;
<span id="Lis1-12"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">local_scope _variable.sh</span></p><pre class="pre"><code>#!/bin/bash&#13;
&#13;
PUBLISHER="No Starch Press"&#13;
&#13;
print_name(){&#13;
   local name&#13;
   name="Black Hat Bash"&#13;
   echo "${name} by ${PUBLISHER}"&#13;
}&#13;
&#13;
print_name&#13;
&#13;
echo "Variable ${name} will not be printed because it is a local variable."&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-12: Accessing global and local variables</span></p>&#13;
<p class="TX">We assign the value <span class="SANS_TheSansMonoCd_W5Regular_11">No Starch Press</span> to the variable <span class="SANS_TheSansMonoCd_W5Regular_11">PUBLISHER</span> and then create a function called <span class="SANS_TheSansMonoCd_W5Regular_11">print_name()</span>. (You’ll learn more about functions <span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>in the next chapter.) Within the function, we declare a local variable called <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and assign it the value <span class="SANS_TheSansMonoCd_W5Regular_11">Black Hat Bash</span>. Then we call <span class="SANS_TheSansMonoCd_W5Regular_11">print_name()</span> and attempt to access the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> variable as part of a sentence to be printed using <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command at the end of the script file will result in an empty variable, as the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> variable is locally scoped to the <span class="SANS_TheSansMonoCd_W5Regular_11">print_name()</span> function, which means that nothing outside the function can access it. So, it will simply return without a value.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The scripts in this chapter are available at</i> <span class="note_LinkURL"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch01</a></span>.</p>&#13;
<p class="TX">Save this script, remembering to set the executable permission by using <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span>, and run it by using the following command:</p>&#13;
<pre><code>$ <b>./local_scope_variable.sh</b>&#13;
&#13;
Black Hat Bash by No Starch Press&#13;
&#13;
Variable  will not be printed here because it is a local variable&#13;
</code></pre>&#13;
<p class="TX">As you can see, the local variable never prints.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H2" id="sec18"><span id="h2-11"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arithmetic Operators</span></h3>&#13;
<p class="TNI1"><i>Arithmetic operators</i> allow you to perform mathematical operations on integers. <a href="chapter1.xhtml#tab1-1">Table 1-1</a> shows some of the arithmetic operators available. For the full list, see <i><a href="https://tldp.org/LDP/abs/html/ops.html">https://tldp.org/LDP/abs/html/ops.html</a></i>.</p>&#13;
<p class="TT" id="tab1-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</span></span> <span class="SANS_Futura_Std_Book_11">Arithmetic Operators</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">+</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Addition</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Subtraction</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">*</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Multiplication</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">/</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Division</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Modulo</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">+=</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Incrementing by a constant</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-=</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Decrementing by a constant</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You can perform these arithmetic operations in bash in a few ways: using the <span class="SANS_TheSansMonoCd_W5Regular_11">let</span> command, using the double parentheses syntax <span class="SANS_TheSansMonoCd_W5Regular_11">$((</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</span><span class="SANS_TheSansMonoCd_W5Regular_11">))</span>, or using the <span class="SANS_TheSansMonoCd_W5Regular_11">expr</span> command. Let’s consider an example of each method.</p>&#13;
<p class="TX">In <a href="chapter1.xhtml#Lis1-13">Listing 1-13</a>, we perform a multiplication operation by using the <span class="SANS_TheSansMonoCd_W5Regular_11">let</span> command.</p>&#13;
<span id="Lis1-13"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>$ <b>let result="4 * 5"</b>&#13;
$ <b>echo ${result}</b>&#13;
&#13;
20&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-13: Arithmetic with let</span></p>&#13;
<p class="TX">This command takes a variable name and performs an arithmetic calculation to resolve its value. In <a href="chapter1.xhtml#Lis1-14">Listing 1-14</a>, we perform another multiplication operation using the double parentheses syntax.</p>&#13;
<span id="Lis1-14"/><pre><code>$ <b>result=$((5 * 5))</b>&#13;
$ <b>echo ${result}</b>&#13;
&#13;
25&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-14: Arithmetic with double parentheses syntax</span></p>&#13;
<p class="TX">In this case, we perform the calculation within double parentheses. Finally, in <a href="chapter1.xhtml#Lis1-15">Listing 1-15</a>, we perform an addition operation using the <span class="SANS_TheSansMonoCd_W5Regular_11">expr</span> command.</p>&#13;
<span id="Lis1-15"/><pre><code>$ <b>result=$(expr 5 + 505)</b>&#13;
$ <b>echo ${result}</b>&#13;
&#13;
510&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-15: Evaluating expressions with expr</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">expr</span> command evaluates expressions, which don’t have to be arithmetic operations; for example, you might use it to calculate the length of a string. Use <span class="SANS_TheSansMonoCd_W5Regular_11">man expr</span> to learn more about the capabilities of <span class="SANS_TheSansMonoCd_W5Regular_11">expr</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H2" id="sec19"><span id="h2-12"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrays</span></h3>&#13;
<p class="TNI1">Bash allows you to create single-dimension arrays. An <i>array</i> is a collection of elements that are indexed. You can access these elements by using their index numbers, which begin at zero. In bash scripts, you might use arrays whenever you need to iterate over multiple strings and run the same commands on each one.</p>&#13;
<p class="TX"><a href="chapter1.xhtml#Lis1-16">Listing 1-16</a> shows how to create an array in bash. Save this code to a file named <i>array.sh</i> and execute it.</p>&#13;
<span id="Lis1-16"/><pre><code>#!/bin/bash&#13;
&#13;
# Sets an array&#13;
IP_ADDRESSES=(192.168.1.1 192.168.1.2 192.168.1.3)&#13;
&#13;
# Prints all elements in the array&#13;
echo "${IP_ADDRESSES[*]}"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/># Prints only the first element in the array&#13;
echo "${IP_ADDRESSES[0]}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-16: Creating and accessing arrays</span></p>&#13;
<p class="TX">This script uses an array named <span class="SANS_TheSansMonoCd_W5Regular_11">IP_ADDRESSES</span> that contains three internet protocol (IP) addresses. The first <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command prints all the elements in the array by passing <span class="SANS_TheSansMonoCd_W5Regular_11">[*]</span> to the variable name <span class="SANS_TheSansMonoCd_W5Regular_11">IP_ADDRESSES</span>, which holds the array values. The asterisk (<span class="SANS_TheSansMonoCd_W5Regular_11">*</span>) is a representation of every array element. Finally, another <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command prints just the first element in the array by specifying index 0.</p>&#13;
<p class="TX">Running this script should produce the following output:</p>&#13;
<pre><code>$ <b>chmod u+x array.sh</b>&#13;
$ <b>./array.sh</b>&#13;
&#13;
192.168.1.1 192.168.1.2 192.168.1.3&#13;
192.168.1.1&#13;
</code></pre>&#13;
<p class="TX">As you can see, we were able to get bash to print all elements in the array, as well as just the first element.</p>&#13;
<p class="TX">You can also delete elements from an array. <a href="chapter1.xhtml#Lis1-17">Listing 1-17</a> will delete 192.168.1.2 from the array.</p>&#13;
<span id="Lis1-17"/><pre><code>IP_ADDRESSES=(192.168.1.1 192.168.1.2 192.168.1.3)&#13;
&#13;
unset IP_ADDRESSES[1]&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-17: Deleting array elements</span></p>&#13;
<p class="TX">You can even swap one of the values with another value. This code will replace 192.168.1.1 with 192.168.1.10:</p>&#13;
<pre><code>IP_ADDRESSES[0]="192.168.1.10"</code></pre>&#13;
<p class="TX">You’ll find arrays particularly useful when you need to iterate over values and perform actions against them, such as a list of IP addresses to scan (or a list of email addresses to send a phishing email to).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h2-13"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Streams</span></h3>&#13;
<p class="TNI1"><i>Streams</i> are files that act as communication channels between a program and its environment. When you interact with a program (whether a built-in Linux utility such as <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span> or one that you wrote yourself), you’re interacting with one or more streams. Bash has three standard data streams, as shown in <a href="chapter1.xhtml#tab1-2">Table 1-2</a>.</p>&#13;
<p class="TT" id="tab1-2"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</span></span> <span class="SANS_Futura_Std_Book_11">Streams</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Stream name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">File descriptor number</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Standard input (stdin)</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Data coming into a program as input</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Standard output (stdout)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Data coming out of a program</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Standard error (stderr)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Errors coming out of a program</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">So far, we’ve run a few commands from the terminal and written and executed a simple script. The generated output was sent to the <i>standard output stream (stdout)</i>, or in other words, your terminal screen.</p>&#13;
<p class="TX">Scripts can also receive commands as input. When a script is designed to receive input, it reads it from the <i>standard input stream (stdin)</i>. Finally, scripts may display error messages to the screen due to a bug or syntax error in the commands sent to it. These messages are sent to the <i>standard error stream (stderr)</i>.</p>&#13;
<p class="TX">To illustrate streams, we’ll use the <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span> command to create a few directories and then use <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> to list the content of the current directory. Open your terminal and execute the following command:</p>&#13;
<pre><code>$ <b>mkdir directory1 directory2 directory1</b>&#13;
mkdir: cannot create directory 'directory1': File exists&#13;
&#13;
$ <b>ls -l</b>&#13;
total 1&#13;
drwxr-xr-x 1 user user   0 Feb 17 09:45 directory1&#13;
drwxr-xr-x 1 user user   0 Feb 17 09:45 directory2&#13;
</code></pre>&#13;
<p class="TX">Notice that <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span> generates an error. This is because we pass the directory name <i>directory1</i> twice on the command line. So, when <span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span> runs, it creates <i>directory1</i> and <i>directory2</i>, then fails on the third argument because, at that point, <i>directory1</i> has already been created. These types of errors are sent to the standard error stream.</p>&#13;
<p class="TX">Next, we execute <span class="SANS_TheSansMonoCd_W5Regular_11">ls -l</span>, which simply lists the directories. The result of the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command succeeds without any specific errors, so it is sent to the standard output stream.</p>&#13;
<p class="TX">You’ll practice working with the standard input stream when we introduce redirection in <span class="Xref">“Redirection Operators” on <a href="#pg_18">page 18</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h2-14"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Control Operators</span></h3>&#13;
<p class="TNI1"><i>Control operators</i> in bash are tokens that perform a control function. <a href="chapter1.xhtml#tab1-3">Table 1-3</a> gives an overview of control operators.</p>&#13;
<p class="TT" id="tab1-3"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 1-3:</span></span> <span class="SANS_Futura_Std_Book_11">Bash Control Operators</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Sends a command to the background.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Used as a logical AND. The second command in the expression will be evaluated only if the first command evaluates to true.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_Futura_Std_Book_11">and)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Used for command grouping.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Used as a list terminator. A command following the terminator will run after the preceding command has finished, regardless of whether it evaluates to true or not.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">;;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Ends a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> <span class="SANS_Futura_Std_Book_11">statement.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">|</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects the output of a command as input to another command.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">||</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Used as a logical OR. The second command will run if the first one</span> <span class="SANS_Futura_Std_Book_11">evaluates to false.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Let’s see some of these control operators in action. The <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span> operator sends a command to the background. If you have a list of commands to run, as in <a href="chapter1.xhtml#Lis1-18">Listing 1-18</a>, sending the first command to the background will allow bash to continue to the next line even if the previous command hasn’t finished its work.</p>&#13;
<span id="Lis1-18"/><pre><code>#!/bin/bash&#13;
&#13;
# This script will send the sleep command to the background.&#13;
echo "Sleeping for 10 seconds..."&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> sleep 10 &amp;&#13;
&#13;
# Creates a file&#13;
echo "Creating the file test123"&#13;
touch test123&#13;
&#13;
# Deletes a file&#13;
echo "Deleting the file test123"&#13;
rm test123&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-18: Sending a command to the background so execution can move to the next line</span></p>&#13;
<p class="TX">Commands that are long-running are often sent to the background to prevent scripts from hanging <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You’ll learn about sending commands to the background in more depth when we discuss job control in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span> operator allows us to perform an AND operation between two commands. In the following example, the file <i>test123</i> will be created only if the first command is successful:</p>&#13;
<pre><code>touch test &amp;&amp; touch test123</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label="18"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">()</span> operator allows us to group commands so they act a single unit when we need to redirect them together:</p>&#13;
<pre><code>(ls; ps)</code></pre>&#13;
<p class="TX">This is generally useful when you need to redirect results from multiple commands to a stream, as shown in <span class="Xref">“Redirection Operators,” next</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">;</span> operator allows us to run multiple commands regardless of their exit status:</p>&#13;
<pre><code>ls; ps; whoami</code></pre>&#13;
<p class="TX">As a result, each command is executed one after the other, as soon as the previous one finishes.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">||</span> operator allows us to chain commands together using an OR operation:</p>&#13;
<pre><code>lzl || echo "the lzl command failed"</code></pre>&#13;
<p class="TX">In this example, the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command will be executed only if the first command fails.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H2" id="sec22"><span id="h2-15"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Redirection Operators</span></h3>&#13;
<p class="TNI1">The three standard streams we highlighted earlier can be redirected from one program to another. <i>Redirection</i> is taking output from one command or script and using it as input to another script or file for writing purposes. <a href="chapter1.xhtml#tab1-4">Table 1-4</a> describes the available redirection operators.</p>&#13;
<p class="TT" id="tab1-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 1-4:</span></span> <span class="SANS_Futura_Std_Book_11">Redirection Operators</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects stdout to a file</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects stdout to a file by appending it to the existing content</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&gt;</span> <span class="SANS_Futura_Std_Book_11">or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&amp;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects stdout and stderr to a file</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&gt;&gt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects stdout and stderr to a file by appending them to the existing content</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects input to a command</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Called a</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">here document</span><span class="SANS_Futura_Std_Book_11">, or</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">heredoc</span><span class="SANS_Futura_Std_Book_11">, redirects multiple input lines to a command</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">|</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Redirects output of a command as input to another command</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Let’s practice using redirection operators to see how they work with standard streams. The <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> operator redirects the standard output stream to a file. Any command that precedes this character will send its output to the specified location. Run the following command directly in your terminal:</p>&#13;
<pre><code>$ <b>echo "Hello World!" &gt; output.txt</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label="19"/>We redirect the standard output stream to a file named <i>output.txt</i>. To see the content of <i>output.txt</i>, simply run the following:</p>&#13;
<pre><code>$ <b>cat output.txt</b>&#13;
&#13;
Hello World!&#13;
</code></pre>&#13;
<p class="TX">Next, we’ll use the <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</span> operator to append some content to the end of the same file (<a href="chapter1.xhtml#Lis1-19">Listing 1-19</a>).</p>&#13;
<span id="Lis1-19"/><pre><code>$ <b>echo "Goodbye!" &gt;&gt; output.txt</b>&#13;
$ <b>cat output.txt</b>&#13;
&#13;
Hello World!&#13;
Goodbye!&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-19: Appending content to a file</span></p>&#13;
<p class="TX">If we had used <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</span>, the content of <i>output.txt</i> would have been overwritten completely with the <span class="SANS_TheSansMonoCd_W5Regular_11">Goodbye!</span> text.</p>&#13;
<p class="TX">You can redirect both the standard output stream and the standard error stream to a file by using <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&gt;</span>. This is useful when you don’t want to send any output to the screen and instead save everything in a logfile (perhaps for later analysis):</p>&#13;
<pre><code>$ <b>ls -l / &amp;&gt; stdout_and_stderr.txt</b></code></pre>&#13;
<p class="TX">To append both the standard output and standard error streams to a file, use the ampersand followed by the double chevron (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&gt;&gt;</span>).</p>&#13;
<p class="TX">What if we want to send the standard output stream to one file and the standard error stream to another? This is also possible using the streams’ file descriptor numbers:</p>&#13;
<pre><code>$ <b>ls -l / 1&gt; stdout.txt 2&gt; stderr.txt</b></code></pre>&#13;
<p class="TX">You may sometimes find it useful to redirect the standard error stream to a file, as we’ve done here, so you can log any errors that occur during runtime. The next example runs a nonexistent command, <span class="SANS_TheSansMonoCd_W5Regular_11">lzl</span>. This should generate bash errors that will be written into the <i>error.txt</i> file:</p>&#13;
<pre><code>$ <b>lzl 2&gt; error.txt</b>&#13;
$ <b>cat error.txt</b>&#13;
&#13;
bash: lzl: command not found&#13;
</code></pre>&#13;
<p class="TX">Notice that you don’t see the error onscreen because bash sends the error to the file instead.</p>&#13;
<p class="TX">Next, let’s use the standard input stream. Run the command in <a href="chapter1.xhtml#Lis1-20">Listing 1-20</a> in the shell to supply the contents of <i>output.txt</i> as input to the <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> command.</p>&#13;
<span id="Lis1-20"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label="20"/>$ <b>cat &lt; output.txt</b>&#13;
&#13;
Hello World!&#13;
Goodbye!&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-20: Using a file as a command’s input</span></p>&#13;
<p class="TX">What if we want to redirect multiple lines to a command? Here document redirection (<span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</span>) can help with this (<a href="chapter1.xhtml#Lis1-21">Listing 1-21</a>).</p>&#13;
<span id="Lis1-21"/><pre><code>$ <b>cat &lt;&lt; EOF</b>&#13;
<b>  Black Hat Bash</b>&#13;
<b>  by No Starch Press</b>&#13;
<b>EOF</b>&#13;
&#13;
Black Hat Bash&#13;
by No Starch Press&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-21: Here document redirection</span></p>&#13;
<p class="TX">In this example, we pass multiple lines as input to a command. The <span class="SANS_TheSansMonoCd_W5Regular_11">EOF</span> in this example acts as a delimiter, marking the start and end points of the input. <i>Here document redirection</i> treats the input as if it were a separate file, preserving line breaks and whitespace.</p>&#13;
<p class="TX">The <i>pipe</i> operator (<span class="SANS_TheSansMonoCd_W5Regular_11">|</span>) redirects the output of one command and uses it as the input of another. For example, we could run the <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command on the root directory and then use another command to extract data from it, as shown in <a href="chapter1.xhtml#Lis1-22">Listing 1-22</a>.</p>&#13;
<span id="Lis1-22"/><pre><code>$ <b>ls -l / | grep "bin"</b>&#13;
&#13;
lrwxrwxrwx   1 root root          7 Mar 10 08:43 bin -&gt; usr/bin&#13;
lrwxrwxrwx   1 root root          8 Mar 10 08:43 sbin -&gt; usr/sbin&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-22: Piping command output into another command</span></p>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> to print the content of the root directory into the standard output stream, then use a pipe to send it as input to the <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> command, which filters out any lines containing the word <i>bin</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h3 class="H2" id="sec23"><span id="h2-16"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Positional Arguments</span></h3>&#13;
<p class="TNI1">Bash scripts can take <i>positional arguments</i> (also called <i>parameters</i>) passed on the command line. Arguments are especially useful, for example, when you want to develop a program that modifies its behavior based on input passed to it by another program or user. Arguments can also change features of the script such as the output format and how verbose it will be during runtime.</p>&#13;
<p class="TX">For example, imagine you develop an exploit and send it to a few colleagues, each of whom will use it against a different IP address. Instead of writing a script and asking the user to modify it with their network information, you can write it to take an IP address argument and then act against this input to avoid having to modify the source code in each case.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label="21"/>A bash script can access arguments passed to it on the command line by using the variables <span class="SANS_TheSansMonoCd_W5Regular_11">$1</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">$2</span>, and so on. The number represents the order in which the argument was entered. To illustrate this, the script in <a href="chapter1.xhtml#Lis1-23">Listing 1-23</a> takes in an argument (an IP address or domain name) and performs a ping test against it by using the <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> utility. Save this file as <i>ping_with_arguments.sh</i>.</p>&#13;
<span id="Lis1-23"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">ping_with _arguments.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
# This script will ping any address provided as an argument.&#13;
&#13;
SCRIPT_NAME="${0}"&#13;
TARGET="${1}"&#13;
&#13;
echo "Running the script ${SCRIPT_NAME}..."&#13;
echo "Pinging the target: ${TARGET}..."&#13;
ping "${TARGET}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-23: A script that accepts command line input</span></p>&#13;
<p class="TX">This script assigns the first positional argument to the variable <span class="SANS_TheSansMonoCd_W5Regular_11">TARGET</span>. Notice, also, that the argument <span class="SANS_TheSansMonoCd_W5Regular_11">${0}</span> is assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">SCRIPT_NAME</span> variable. This argument contains the script’s name (in this case, <i>ping_with_arguments.sh</i>).</p>&#13;
<p class="TX">To run this script, use the commands in <a href="chapter1.xhtml#Lis1-24">Listing 1-24</a>.</p>&#13;
<span id="Lis1-24"/><pre><code>$ <b>chmod u+x ping_with_arguments.sh</b>&#13;
$ <b>./ping_with_arguments.sh nostarch.com</b>&#13;
&#13;
Running the script ping_with_arguments.sh...&#13;
Pinging the target nostarch.com...&#13;
PING nostarch.com (104.20.120.46) 56(84) bytes of data.&#13;
&#13;
64 bytes from 104.20.120.46 (104.20.120.46): icmp_seq=1 ttl=57 time=6.89 ms&#13;
64 bytes from 104.20.120.46 (104.20.120.46): icmp_seq=2 ttl=57 time=4.16 ms&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-24: Passing arguments to a script</span></p>&#13;
<p class="TX">This script will perform a <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> command against the domain <i>nostarch.com</i> passed to it on the command line. The value is assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">$1</span> variable; if we passed another argument, it would get assigned to the second variable, <span class="SANS_TheSansMonoCd_W5Regular_11">$2</span>. Use <small>CTRL</small>-C to exit this script, as <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> may run indefinitely on some operating systems.</p>&#13;
<p class="TX">What if you want to access all arguments? You can do so using the variable <span class="SANS_TheSansMonoCd_W5Regular_11">$@</span>. Also, using <span class="SANS_TheSansMonoCd_W5Regular_11">$#</span>, you can get the total number of arguments passed. <a href="chapter1.xhtml#Lis1-25">Listing 1-25</a> demonstrates how this works.</p>&#13;
<span id="Lis1-25"/><pre><code>#!/bin/bash&#13;
&#13;
echo "The arguments are: $@"&#13;
echo "The total number of arguments is: $#"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-25: Retrieving all arguments and the total number of arguments</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label="22"/>Save this script to a file named <i>show_args.sh</i> and run it as follows:</p>&#13;
<pre><code>$ <b>chmod u+x show_args.sh</b>&#13;
$ <b>./show_args.sh "hello" "world"</b>&#13;
&#13;
The arguments are: hello world&#13;
The total number of arguments is: 2&#13;
</code></pre>&#13;
<p class="TX"><a href="chapter1.xhtml#tab1-5">Table 1-5</a> summarizes the variables related to positional arguments.</p>&#13;
<p class="TT" id="tab1-5"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 1-5:</span></span> <span class="SANS_Futura_Std_Book_11">Special Variables Related to Positional Arguments</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Variable</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The name of the script file</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$1</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$2</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$3</span><span class="SANS_Futura_Std_Book_11">, ...</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Positional arguments</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$#</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The number of passed positional arguments</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$*</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">All positional arguments</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$@</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">All positional arguments, where each argument is individually quoted</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">When a script uses <span class="SANS_TheSansMonoCd_W5Regular_11">"$*"</span> with the quotes included, bash will expand arguments into a single word. For instance, the following example groups the arguments into one word:</p>&#13;
<pre><code>$ <b>./script.sh "1" "2" "3"</b>&#13;
1 2 3&#13;
</code></pre>&#13;
<p class="TX">When a script uses <span class="SANS_TheSansMonoCd_W5Regular_11">"$@"</span> (again including the quotes), it will expand arguments into separate words:</p>&#13;
<pre><code>$ <b>./script.sh "1" "2" "3"</b>&#13;
1&#13;
2&#13;
3&#13;
</code></pre>&#13;
<p class="TX">In most cases, you will want to use <span class="SANS_TheSansMonoCd_W5Regular_11">"$@"</span> so that every argument is treated as an individual word.</p>&#13;
<p class="TX">The following script demonstrates how to use these special variables in a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop:</p>&#13;
<pre><code>#!/bin/bash&#13;
# Change "$@" to "$*" to observe behavior.&#13;
for args in "$@"; do&#13;
    echo "${args}"&#13;
done&#13;
</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H2" id="sec24"><span id="h2-17"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Input Prompting</span></h3>&#13;
<p class="TNI1">Some bash scripts don’t take any arguments during execution. However, they may need to ask the user for information in an interactive way and have <span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label="23"/>the response feed into their runtime. In these cases, we can use the <span class="SANS_TheSansMonoCd_W5Regular_11">read</span> command. You often see applications use <i>input prompting</i> when attempting to install software, asking the user to enter <i>yes</i> to proceed or <i>no</i> to cancel the operation.</p>&#13;
<p class="TX">In the bash script in <a href="chapter1.xhtml#Lis1-26">Listing 1-26</a>, we ask the user for their first and last names and then print these to the standard output stream.</p>&#13;
<span id="Lis1-26"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">input _prompting.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
# Takes input from the user and assigns it to variables&#13;
echo "What is your first name?"&#13;
read -r firstname&#13;
&#13;
echo "What is your last name?"&#13;
read -r lastname&#13;
&#13;
echo "Your first name is ${firstname} and your last name is ${lastname}"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-26: Prompting a user for input</span></p>&#13;
<p class="TX">Save and run this script as <i>input_prompting.sh</i>:</p>&#13;
<pre><code>$ <b>chmod u+x input_prompting.sh</b>&#13;
$ <b>./input_prompting.sh</b>&#13;
&#13;
What is your first name?&#13;
John&#13;
&#13;
What is your last name?&#13;
Doe&#13;
&#13;
Your first name is John and your last name is Doe&#13;
</code></pre>&#13;
<p class="TX">Notice that you are prompted to enter information that then gets printed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h3 class="H2" id="sec25"><span id="h2-18"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exit Codes</span></h3>&#13;
<p class="TNI1">Bash commands return <i>exit codes</i>, which indicate whether the execution of the command succeeded. Exit codes fall in the 0 to 255 range, where 0 means success, 1 means failure, 126 means that the command was found but is not executable, and 127 means the command was not found. The meaning of any other number depends on the specific command being used and its logic.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H3" id="sec26"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Checking Exit Codes</span></h4>&#13;
<p class="TNI1">To see exit codes in action, save the script in <a href="chapter1.xhtml#Lis1-27">Listing 1-27</a> to a file named <i>exit_codes.sh</i> and run it.</p>&#13;
<span id="Lis1-27"/><pre><code>#!/bin/bash&#13;
&#13;
# Experimenting with exit codes&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label="24"/>ls -l &gt; /dev/null&#13;
echo "The exit code of the ls command was: $?"&#13;
&#13;
lzl 2&gt; /dev/null&#13;
echo "The exit code of the non-existing lzl command was: $?"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-27: Using exit codes to determine a command’s success</span></p>&#13;
<p class="TX">We use the special variable <span class="SANS_TheSansMonoCd_W5Regular_11">$?</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command to return the exit codes of the executed commands <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">lzl</span>. We also redirect their standard output and standard error streams to the file <i>/dev/null</i>, a special device file that discards any data sent to it. When you want to silence commands, you can redirect their output to it.</p>&#13;
<p class="TX">You should see output like the following:</p>&#13;
<pre><code>$ <b>./exit_codes.sh</b>&#13;
&#13;
The exit code of the ls command was: 0&#13;
The exit code of the non-existing lzl command was: 127&#13;
</code></pre>&#13;
<p class="TX">We receive two distinct exit codes, one for each command. The first command returns 0 (success), and the second returns 127 (command not found).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">WARNING</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Use</i> <span class="note_Italic">/dev/null</span> <i>with caution. You may miss out on important errors if you choose to redirect output to it. When in doubt, redirect standard streams such as standard output and standard error to a dedicated logfile instead.</i></p>&#13;
<p class="TX">To understand why you might want to use exit codes, imagine you’re trying to download a 1GB file from the internet by using bash. It might be wise to first check whether the file already exists on the filesystem in case someone ran the script and retrieved it. Also, you might want to check that you have enough free space on the disk before attempting the download. By running commands and looking at their returned exit codes, you can decide whether to proceed with the file download.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h4 class="H3" id="sec27"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Setting a Script’s Exit Code</span></h4>&#13;
<p class="TNI1">You can set the exit code of a script by using the <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> command followed by the code number, as shown in <a href="chapter1.xhtml#Lis1-28">Listing 1-28</a>.</p>&#13;
<span id="Lis1-28"/><pre><code>#!/bin/bash&#13;
&#13;
# Sets the exit code of the script to be 223&#13;
&#13;
echo "Exiting with exit code: 223"&#13;
exit 223&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 1-28: Setting a script’s exit code</span></p>&#13;
<p class="TX">Save this script as <i>set_exit_code.sh</i> and run it on the command line. Then use the special variable <span class="SANS_TheSansMonoCd_W5Regular_11">$?</span> to see the exit code it returns:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label="25"/>$ <b>chmod u+x set_exit_code.sh</b>&#13;
$ <b>./set_exit_code.sh</b>&#13;
Exiting with exit code: 223&#13;
&#13;
<b>echo $?</b>&#13;
223&#13;
</code></pre>&#13;
<p class="TX">You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">$?</span> variable to check the returned exit code not only of a script but also of individual commands:</p>&#13;
<pre><code>$ <b>ps -ef</b>&#13;
$ <b>echo $?</b>&#13;
&#13;
0&#13;
</code></pre>&#13;
<p class="TX">Exit codes are important; they can be used in a series of scripts that call one another or within the same script, to control the logical flow of the code execution.</p>&#13;
<p class="HeadAExercise"><span id="exe-1"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 1: Recording Your Name and the Date</span></p>&#13;
<p class="TNI1">Write a script that does the following:</p>&#13;
<p class="NLF">  1.  Accepts two arguments on the command line and assigns them to variables. The first argument should be your first name, and the second should be your last name.</p>&#13;
<p class="NL">  2.  Creates a new file named <i>output.txt</i>.</p>&#13;
<p class="NL">  3.  Writes the current date to <i>output.txt</i> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">date</span> command. (Bonus points if you can make the <span class="SANS_TheSansMonoCd_W5Regular_11">date</span> command print the date in the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">DD-MM-YYYY</span> format; use <span class="SANS_TheSansMonoCd_W5Regular_11">man date</span> to learn how this works.)</p>&#13;
<p class="NL">  4.  Writes your full name to <i>output.txt</i>.</p>&#13;
<p class="NL">  5.  Makes a backup copy of <i>output.txt</i>, named <i>backup.txt</i>, using the <span class="SANS_TheSansMonoCd_W5Regular_11">cp</span> command. (Use <span class="SANS_TheSansMonoCd_W5Regular_11">man cp</span> if you aren’t sure of the command’s syntax.)</p>&#13;
<p class="NLL">  6.  Prints the content of the <i>output.txt</i> file to the standard output stream.</p>&#13;
<p class="TX">You can find an example solution, <i>exercise_solution.sh</i>, in the book’s GitHub repository.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h2 class="H1" id="sec28"><span id="h1-9"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, you ran simple Linux commands in the terminal and used <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> to learn about command options. You also learned how to pass arguments to scripts and execute a sequence of commands from within scripts. We covered the fundamentals of bash, such as how to write basic programs that use variables, arrays, redirects, exit codes, and arguments. You also learned how to prompt the user to enter arbitrary information and use it as part of a script’s flow.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>