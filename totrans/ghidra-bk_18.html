<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_315"/>
<h2 class="h2" id="ch15"><strong><span class="big">15</span><br/>ECLIPSE AND GHIDRADEV</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">The scripts that are distributed with Ghidra and the scripts we created in <a href="ch14.xhtml#ch14">Chapter 14</a> are relatively simple. The coding required was minimal, which greatly simplified the development and testing phases. The basic script editor provided by Ghidra’s Script Manager is fine for quick-and-dirty work, but it lacks the sophistication to manage complex projects. For more substantial tasks, Ghidra provides a plugin that facilitates development using the Eclipse development environment. In this chapter, we look at Eclipse and the role it can play in the development of more advanced Ghidra scripts. We also show how Eclipse can be used to create new Ghidra modules and revisit this topic in later chapters as we expand Ghidra’s inventory of loaders and discuss the inner workings of Ghidra processor modules.</p>
<span epub:type="pagebreak" id="page_316"/>
<h3 class="h3" id="ch15lev263"><strong>Eclipse</strong></h3>
<p class="noindent"><em>Eclipse</em> is an integrated development environment (IDE) that is used by many Java developers, which makes it a natural fit for Ghidra development. While it is possible to run both Eclipse and Ghidra on the same machine without any interaction between them, the integration of the two can greatly simplify Ghidra development. Without integration, Eclipse would just be another script editing option outside the Ghidra environment. By integrating Eclipse with Ghidra, you suddenly have a rich IDE that includes Ghidra-specific functionality, resources, and templates to facilitate your Ghidra development process. Integrating Eclipse and Ghidra does not require significant effort; you just need to provide each with some information about the other so that they can be used together.</p>
<h4 class="h4" id="ch15lev264"><strong><em>Eclipse Integration</em></strong></h4>
<p class="noindent">In order for Ghidra to work with Eclipse, Eclipse needs to have the GhidraDev plugin installed. You can integrate the two applications from within either Ghidra or Eclipse. Instructions for both integration approaches are included in the <em>GhidraDev_README.html</em> document found in the <em>Extensions/Eclipse/GhidraDev</em> directory of your Ghidra installation.</p>
<p class="indent">While the written documentation does walk you through the details of the process, the easiest starting point is to select a Ghidra action that requires Eclipse, such as Edit Script with Eclipse (refer to <a href="ch14.xhtml#fig14_2">Figure 14-2</a>). If you select this option and have not previously integrated Eclipse and Ghidra, you will be prompted for the directory information required to make the connection. Depending on your configuration, you may need to provide the path to your Eclipse installation directory, your Eclipse workspace directory, your Ghidra installation directory, your Eclipse drop-in directory, and possibly the port number used to communicate with Eclipse for script editing.</p>
<p class="indent">Ghidra’s documentation will help you overcome any obstacles that you encounter during the integration process. The truly adventurous can explore the integration plugins in the <em>Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/eclipse</em> directory in Ghidra’s source repository.</p>
<h4 class="h4" id="ch15lev265"><strong><em>Starting Eclipse</em></strong></h4>
<p class="noindent">Once Ghidra and Eclipse are successfully integrated, you can use them for writing Ghidra scripts and plugins. The first time you launch Eclipse after it has been integrated with Ghidra, you are likely to see the dialog shown in <a href="ch15.xhtml#fig15_1">Figure 15-1</a>, requesting to establish a communication path between your Ghidra instance and your Eclipse GhidraDev instance.</p>
<p class="indent">Venturing onward, you will see the Eclipse IDE welcome screen, as shown in <a href="ch15.xhtml#fig15_2">Figure 15-2</a>. This instance of Eclipse has a new addition on the menu bar: GhidraDev. This is the menu we will use to create more complex scripts and Ghidra tools.</p>
<p class="indent">The landing page for Ghidra Eclipse, the Welcome to the Eclipse IDE for Java Developers workbench, includes links to numerous tutorials, <span epub:type="pagebreak" id="page_317"/>documentation, and information about the Eclipse IDE and Java that should provide the necessary background support to users new to Eclipse as well as an optional refresher for experienced users. To move ahead with Ghidra, we will focus our discussion on how the GhidraDev menu can be used to augment Ghidra’s existing capabilities, build new capabilities, and customize Ghidra to improve our reverse engineering workflow.</p>
<div class="image"><img src="Images/fig15-1.jpg" alt="image" width="694" height="259"/></div>
<p class="figcap" id="fig15_1"><em>Figure 15-1: GhidraDevUser Consent dialog</em></p>
<div class="image"><img src="Images/fig15-2.jpg" alt="image" width="694" height="247"/></div>
<p class="figcap" id="fig15_2"><em>Figure 15-2: Eclipse IDE welcome screen</em></p>
<h4 class="h4" id="ch15lev266"><strong><em>Editing Scripts with Eclipse</em></strong></h4>
<p class="noindent">Once the GhidraDev plugin has been installed in Eclipse, you are ready to create new scripts, or edit existing ones using the Eclipse IDE. As we migrate from using Ghidra’s Script Manager to create and edit scripts, to using Eclipse, it’s worth remembering that while it is possible to launch Eclipse from Script Manager, it is possible to do so only to edit an existing script (see <a href="ch14.xhtml#fig14_2">Figure 14-2</a>). If you want to edit a new script using Eclipse, you’ll need to first launch Eclipse and then use the GhidraDev menu to create the new script. Whether you launch Eclipse yourself, or arrive in Eclipse via Ghidra’s Script Manager, for the remainder of this chapter, we use Eclipse rather than the Script Manager’s basic editor to create and modify scripts and modules for Ghidra.</p>
<p class="indent">To edit the first script we created in “<a href="ch14.xhtml#ch14lev236">Edit Script Example: Regex Search</a>” on <a href="ch14.xhtml#page_290">page 290</a>, select <strong>File</strong> ▸ <strong>Open File</strong> from the Eclipse menu and navigate to the script <em>FindStringByRegex.java</em>. This opens the script in the <span epub:type="pagebreak" id="page_318"/>Eclipse IDE, and you can begin using Eclipse’s rich set of editing options. <a href="ch15.xhtml#fig15_3">Figure 15-3</a> shows the first few lines of the script with the comments and imports collapsed. Collapsing lines is a default feature of the Eclipse IDE that could cause some confusion if you are switching between the basic editor provided by Ghidra and Eclipse.</p>
<div class="image"><img src="Images/fig15-3.jpg" alt="image" width="694" height="256"/></div>
<p class="figcap" id="fig15_3"><em>Figure 15-3: Eclipse editor presentation of</em> FindStringsByRegex</p>
<p class="indent">Only one line of comments is displayed by default. You can click an icon to expand (the + icon at the left of line 2) the content and display all of the comments as well as to collapse (the <code>–</code> icon at the left of line 34) the content if desired. The same is true on line 26 with the <code>import</code> statements. Hovering over the icon for any section that is collapsed displays the hidden content in a pop-up window.</p>
<p class="indent">Before we can start building examples that expand Ghidra’s capabilities, you need to understand more about the GhidraDev menu and the Eclipse IDE. Let’s shift our focus back to the GhidraDev menu and investigate the various options and how they can be used in context.</p>
<h3 class="h3" id="ch15lev267"><strong>GhidraDev Menu</strong></h3>
<p class="noindent">The expanded GhidraDev menu is shown in <a href="ch15.xhtml#fig15_4">Figure 15-4</a> and includes five options that you can use to control your development environment and work with files. In this chapter, we focus on developing in Java, although Python is an option in several of the windows.</p>
<div class="image"><img src="Images/fig15-4.jpg" alt="image" width="581" height="245"/></div>
<p class="figcap" id="fig15_4"><em>Figure 15-4: GhidraDev menu options</em></p>
<span epub:type="pagebreak" id="page_319"/>
<h4 class="h4" id="ch15lev268"><em>GhidraDev ▸ New</em></h4>
<p class="noindent">The GhidraDev ▸ New menu provides you with three submenu options, as shown in <a href="ch15.xhtml#fig15_5">Figure 15-5</a>. All three of the options launch wizards that guide you through an associated creation process. We start with the simplest option, which is to create a new Ghidra script. This is an alternative path to creating scripts from that discussed in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>
<div class="image"><img src="Images/fig15-5.jpg" alt="image" width="509" height="195"/></div>
<p class="figcap" id="fig15_5"><em>Figure 15-5: GhidraDev ▸ New submenu</em></p>
<h5 class="h5" id="ch15lev269"><strong>Creating a Script</strong></h5>
<p class="noindent">Creating a new script using GhidraDev ▸ New ▸ Ghidra Script results in a dialog that allows you to enter information about your new script. An example of the dialog populated with content is shown in <a href="ch15.xhtml#fig15_6">Figure 15-6</a>. In addition to the directory and file information, the dialog collects the same metadata that we manually entered into our script files in the Script Manager’s basic editor.</p>
<div class="image"><img src="Images/fig15-6.jpg" alt="image" width="694" height="494"/></div>
<p class="figcap" id="fig15_6"><em>Figure 15-6: Create Ghidra Script dialog</em></p>
<span epub:type="pagebreak" id="page_320"/>
<p class="indent">The Finish button at the bottom of the dialog produces the script template shown in <a href="ch15.xhtml#fig15_7">Figure 15-7</a>. The metadata entered in <a href="ch15.xhtml#fig15_6">Figure 15-6</a> is included in the comment section at the top of the script. This content is in the same format as the metadata we saw in <a href="ch14.xhtml#ch14">Chapter 14</a> (see the top of <a href="ch14.xhtml#fig14_4">Figure 14-4</a>). When you edit this script in Eclipse, the task tag (clipboard icon, seen on the left side of line 14 in <a href="ch15.xhtml#fig15_7">Figure 15-7</a>) associated with each <code>TODO</code> item in the script identifies locations where there is work to be done. You can delete and insert task tags at will.</p>
<div class="image"><img src="Images/fig15-7.jpg" alt="image" width="694" height="394"/></div>
<p class="figcap" id="fig15_7"><em>Figure 15-7: GhidraDev ▸ NewScript script shell</em></p>
<p class="indent">Eclipse does not preload your script with the list of <code>import</code> statements like the Ghidra basic editor does (refer to <a href="ch14.xhtml#fig14_4">Figure 14-4</a>). Not to worry. Eclipse helps you to manage your <code>import</code> statements by letting you know when you use something that requires an associated <code>import</code> statement. For example, if we replace the <code>TODO</code> comment in <a href="ch15.xhtml#fig15_7">Figure 15-7</a> with the declaration of a Java <code>ArrayList</code>, Eclipse adds an error tag to the line and underlines <code>ArrayList</code> in red. Hovering over the error tag or <code>ArrayList</code> displays a pop-up window suggesting quick fixes to solve the issue, as shown in <a href="ch15.xhtml#fig15_8">Figure 15-8</a>.</p>
<div class="image"><img src="Images/fig15-8.jpg" alt="image" width="542" height="262"/></div>
<p class="figcap" id="fig15_8"><em>Figure 15-8: Eclipse Quick Fix options</em></p>
<span epub:type="pagebreak" id="page_321"/>
<p class="indent">Choosing the first option in the suggestion list instructs Eclipse to add the selected <code>import</code> statement to the script, as shown in <a href="ch15.xhtml#fig15_9">Figure 15-9</a>. While it was helpful to have the list of potential <code>import</code> statements loaded when creating a new script in the CodeBrowser Script Manager, it is not as essential in Eclipse.</p>
<div class="image"><img src="Images/fig15-9.jpg" alt="image" width="568" height="217"/></div>
<p class="figcap" id="fig15_9"><em>Figure 15-9: Eclipse after Quick Fix import is applied</em></p>
<h5 class="h5" id="ch15lev270"><strong>Creating a Script Project</strong></h5>
<p class="noindent">The second option in the GhidraDev ▸ New menu creates a new script project, as shown in <a href="ch15.xhtml#fig15_10">Figure 15-10</a>. We name our first script project <em>CH15_ProjectExample_linked</em> and place it in the default directory that we have set up for Eclipse. The Create run configuration checkbox allows you to create a <em>run configuration</em>, which provides Eclipse with the necessary information (command line arguments, directory paths, and so on) to launch Ghidra and allows us to use Eclipse to run and debug the script in Ghidra. Leave this checkbox in its default state, selected. Click <strong>Finish</strong> to complete creation of the script using the default format, which links the script project to your home directory.</p>
<div class="image"><img src="Images/fig15-10.jpg" alt="image" width="694" height="419"/></div>
<p class="figcap" id="fig15_10"><em>Figure 15-10: Eclipse Ghidra Script Project dialog</em></p>
<span epub:type="pagebreak" id="page_322"/>
<p class="indent">We will create a second script project <em>CH15_ProjectExample</em> and this time will choose the Next button. Choosing Next yields the dialog with two Link options that are set by default (hence the <em>_linked</em> extension on our first project name). The first option creates a link to your home script directory. The second lets you link to the Ghidra installation script directories. <em>Link</em>, in this case, is a way of saying that folders representing your home script directory and/or Ghidra’s own script directories will be added to your new project, making any script in those directories easily accessible to you while working on your project.</p>
<p class="indent">The results of selecting or deselecting these options and then clicking the Finish button will become clear later in the chapter when we discuss the Eclipse Package Explorer. For this second script project, de-select the first link checkbox as shown in <a href="ch15.xhtml#fig15_11">Figure 15-11</a>.</p>
<div class="image"><img src="Images/fig15-11.jpg" alt="image" width="694" height="321"/></div>
<p class="figcap" id="fig15_11"><em>Figure 15-11: Eclipse configuration options for script projects</em></p>
<h5 class="h5" id="ch15lev271"><strong>Creating a Module Project</strong></h5>
<p class="noindent">The final option in the GhidraDev ▸ New menu creates a Ghidra module project.<sup><a id="ch15fn1a" href="footnotes.xhtml#ch15fn1">1</a></sup> Not to be confused with a Ghidra module (for example, analyzer, loader, and so on), a <em>Ghidra module project</em> aggregates code for a new Ghidra module with associated help files, documentation, and other resources, such as icons. Further, it allows you some control over how your new module interacts with the other modules within Ghidra. We demonstrate Ghidra modules in context in this and future chapters.</p>
<p class="indent">Choosing New ▸ Ghidra Module Project displays the dialog shown in <a href="ch15.xhtml#fig15_12">Figure 15-12</a>, which should be familiar because it is exactly the same as the Script Project dialog. We name our new project <em>CH15_ModuleExample</em> to make it easy to identify in the Package Explorer.</p>
<span epub:type="pagebreak" id="page_323"/>
<div class="image"><img src="Images/fig15-12.jpg" alt="image" width="694" height="349"/></div>
<p class="figcap" id="fig15_12"><em>Figure 15-12: Eclipse Module Project dialog</em></p>
<p class="indent">Clicking Next at this point allows you to base your module on existing Ghidra templates, as shown in <a href="ch15.xhtml#fig15_13">Figure 15-13</a>. By default, all of the options are selected. You can change this to include none, some, or all of the templates, depending on your development goals. Any of the options you choose will be grouped together in a project within the Package Explorer. In our case, we have deselected all of the options.</p>
<p class="indent">While most of the selections will produce an associated source code template with task tags, there are two exceptions. First, if you do not select any of the module templates, you will not have a template file. In addition, the processor module does not produce a template file but does generate other supporting content. (Processor modules are discussed in <a href="ch18.xhtml#ch18">Chapter 18</a>.)</p>
<div class="image"><img src="Images/fig15-13.jpg" alt="image" width="623" height="456"/></div>
<p class="figcap" id="fig15_13"><em>Figure 15-13: Template options for Ghidra module projects</em></p>
<span epub:type="pagebreak" id="page_324"/>
<p class="indent">Now that you know how to create Ghidra scripts, script projects, and module projects, let’s shift our focus to the Eclipse Package Explorer to better understand how we can work with our new creations.<sup><a id="ch15fn2a" href="footnotes.xhtml#ch15fn2">2</a></sup></p>
<h4 class="h4" id="ch15lev272"><strong><em>Navigating the Package Explorer</em></strong></h4>
<p class="noindent">Eclipse’s Package Explorer is the gateway to the Ghidra files you need to complete your Ghidra extension. Here, we present the hierarchical organization and then drill down into examples of Ghidra projects and modules created through the GhidraDev menu. <a href="ch15.xhtml#fig15_14">Figure 15-14</a> displays a sample Eclipse Package Explorer window containing the items we created earlier in this chapter as well as a few others we created to demonstrate the effect of various options on the resulting Package Explorer contents.</p>
<div class="image"><img src="Images/fig15-14.jpg" alt="image" width="527" height="280"/></div>
<p class="figcap" id="fig15_14"><em>Figure 15-14: Package Explorer populated with example modules and project</em></p>
<p class="indent">We start by looking at the two script projects. <em>CH15_ProjectExample_linked</em> is the script project we created with both link options checked (refer to <a href="ch15.xhtml#fig15_11">Figure 15-11</a>). Immediately below it, we see a similar project, <em>CH15_ProjectExample</em>, but in this case, neither link option was checked. A partially expanded Package Explorer entry for <em>CH15_ProjectExample</em> is shown in <a href="ch15.xhtml#fig15_15">Figure 15-15</a>.</p>
<p class="indentb">The following four components are included in this script project:</p>
<p class="uln-indent"><strong>JUnit4</strong> This is an open source unit-testing framework for Java. More information is available at <em><a href="https://junit.org/junit4/index.html">https://junit.org/junit4/index.html</a></em>.</p>
<p class="uln-indent"><strong>JRE System Library</strong> This is the Java Runtime Environment System Library.</p>
<p class="uln-indent"><strong>Referenced Libraries</strong> These are referenced libraries that are not part of the JRE System Library, but are part of our Ghidra installation.</p>
<p class="uln-indent"><strong>Ghidra</strong> This is the directory for your current Ghidra installation. We have expanded this directory so that you can see the familiar file structure introduced in <a href="ch03.xhtml#ch03">Chapter 3</a> (see <a href="ch03.xhtml#fig3_1">Figure 3-1</a>) and used throughout this book.</p>
<span epub:type="pagebreak" id="page_325"/>
<div class="image"><img src="Images/fig15-15.jpg" alt="image" width="358" height="421"/></div>
<p class="figcap" id="fig15_15"><em>Figure 15-15: Package Explorer script project entries</em> without <em>links</em></p>
<p class="indent">Compare the contents of <a href="ch15.xhtml#fig15_15">Figure 15-15</a> with the expanded contents from <em>CH15_ProjectExample_linked</em> shown in <a href="ch15.xhtml#fig15_16">Figure 15-16</a>. For this script project, we selected both link options. Linking the user home script directory results in the <em>Home scripts</em> entry in the project hierarchy and provides us easy access to the scripts we have previously written to use as examples or to modify.</p>
<div class="image"><img src="Images/fig15-16.jpg" alt="image" width="359" height="490"/></div>
<p class="figcap" id="fig15_16"><em>Figure 15-16: Package Explorer script project entries</em> with <em>links</em></p>
<span epub:type="pagebreak" id="page_326"/>
<p class="indent">Linking Ghidra installation script directories results in all of the folders in <a href="ch15.xhtml#fig15_16">Figure 15-16</a> that start with <em>Ghidra</em> and end with <em>scripts</em>. Each one of these corresponds to a script directory within in the <em>Ghidra/Features</em> directory in your Ghidra installation.<sup><a id="ch15fn3a" href="footnotes.xhtml#ch15fn3">3</a></sup> Expanding any of these folders provides access to the source code for each of the scripts included in your Ghidra installation. Like the home scripts, these can serve as examples to modify or use as a base for creating new scripts. While you are not permitted to overwrite these scripts from within the Ghidra Script Manager basic editor, you can edit them in Eclipse and other editors outside of the Ghidra Project environment. When you have finished creating or editing a new script, you can save it in the appropriate script directory within your script project, and it will be available to use the next time you open the Ghidra Script Manager.</p>
<p class="indent">Now that we have looked at scripts within the Eclipse Package Explorer, let’s see how the Ghidra module project we built is represented. The partially expanded content of our project in the Package Explorer is shown in <a href="ch15.xhtml#fig15_17">Figure 15-17</a>.</p>
<div class="image"><img src="Images/fig15-17.jpg" alt="image" width="367" height="465"/></div>
<p class="figcap" id="fig15_17"><em>Figure 15-17: Package Explorer hierarchy for</em> CH15_ModuleExampleModule</p>
<span epub:type="pagebreak" id="page_327"/>
<div class="box5">
<p class="boxtitle-c"><strong>ARE WE BUILDING THAT SCRIPT AGAIN?</strong></p>
<p class="noindent">In <a href="ch14.xhtml#ch14">Chapter 14</a>, we presented a toy example within the Ghidra Script Manager environment where we modified the existing script <em>CountAndSaveStrings</em> and used it to build a new script called <em>FindStringsByRegex</em>. The following steps do the same task within the Eclipse IDE:</p>
<ol>
<li class="noindent">Search for <em>CountAndSaveStrings.java</em> in Eclipse (<span class="smallcaps">CTRL-SHIFT-</span>R).</li>
<li class="noindent">Double-click to open the file in the Eclipse editor.</li>
<li class="noindent">Replace the existing class and comments with the new class and comments.</li>
<li class="noindent">Save the file (<em>EclipseFindStringByRegex.java</em>) in the recommended <em>ghidra_scripts</em> directory.</li>
<li class="noindent">Run the new script from the Script Manager window in Ghidra.</li>
</ol>
<p class="indent">You can launch Ghidra manually to get access to the Script Manager window. Alternatively, you can select the Run As option in the Eclipse IDE, which will show the dialog in <a href="ch15.xhtml#fig15_18">Figure 15-18</a>. The first option launches Ghidra for you. The second option launches a non-GUI version of Ghidra, which is the topic of <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>
<div class="image"><img src="Images/fig15-18.jpg" alt="image" width="481" height="286"/></div>
<p class="figcap" id="fig15_18"><em>Figure 15-18: Eclipse Run As options</em></p>
<p class="indent">Once Ghidra has been launched, you can run your script from the Script Manager and edit it using Eclipse.</p>
</div>
<p class="indentb">Module projects include the following new elements:</p>
<p class="uln-indent"><strong><em>src/main/java</em></strong> This is the location for the source code. If you created a module type that has a template available, the associated <em>.java</em> files are placed in this directory.</p>
<p class="uln-indent"><strong><em>src/main/help</em></strong> When you create or extend content, you have the opportunity to add useful information to Ghidra Help by using the files and information in this directory.</p>
<span epub:type="pagebreak" id="page_328"/>
<p class="uln-indent"><strong><em>src/main/resources</em></strong> As with many of the other entries in the <em>src/main</em> directory, expanding this content will lead you to a <em>README.txt</em> file that provides additional information about the purpose of the directory and how it should be used. For example, the <em>src/main/resources/images/ README.txt</em> file lets you know that it is the location in which any image or icon files associated with the module should be stored.</p>
<p class="uln-indent"><strong><em>ghidra_scripts</em></strong> This is where Ghidra scripts that are specific to this module are stored.</p>
<p class="uln-indent"><strong><em>data</em></strong> This folder holds any independent data files that are used with this module. (While not prohibited from use with other module types, this folder is primarily used with processor modules and is discussed in <a href="ch18.xhtml#ch18">Chapter 18</a>.)</p>
<p class="uln-indent"><strong><em>lib</em></strong> Any <em>.jar</em> files required by the module should be stored in this folder.</p>
<p class="uln-indent"><strong><em>os</em></strong> There are subdirectories within this folder for linux64, oxs64, and win64 to hold any native binaries that the module may depend upon.</p>
<p class="uln-indent"><strong><em>src</em></strong> This directory is used to hold unit test cases.</p>
<p class="uln-indent"><strong><em>build.gradle</em></strong> Gradle is an open source build system. This file is used to build your Ghidra extension.</p>
<p class="uln-indent"><strong><em>extension.properties</em></strong> This file stores metadata about the extension.</p>
<p class="uln-indent"><strong><em>Module.manifest</em></strong> You can enter information about the module such as configuration information in this file.</p>
<p class="indenta">You may have noticed in <a href="ch15.xhtml#fig15_14">Figure 15-14</a> that we created additional <em>Test</em> modules (<em>AnalyzerTest</em>, <em>AllTypeTest</em>, and <em>LoaderTest</em>). Each was created using a different combination of Module Template options (see <a href="ch15.xhtml#fig15_13">Figure 15-13</a>), which results in a different set of files being instantiated for each project. When using these templates as a starting point for your projects, it’s useful to know just how much work Eclipse and Ghidra have done for you—and how much work is left for you to complete.</p>
<p class="indent">Let’s begin by looking in the <em>AnalyzerTest</em> directory that we created to demonstrate an analyzer template. Expand the <em>src/main/java</em> directory to find a file called <em>AnalyzerTestAnalyzer.java</em>. The name is a concatenation of the module name (<em>AnalyzerTest</em>) with the template type (<em>Analyzer</em>). Double-click this file to open it in the editor and see the code shown in <a href="ch15.xhtml#fig15_19">Figure 15-19</a>. Like the script templates earlier in the chapter, the Eclipse IDE provides task tags with associated comments to guide us through building our analyzer as well as the options to expand and collapse content. The <em>LoaderTest</em> module contains the template for building a loader, which is discussed further in <a href="ch17.xhtml#ch17">Chapter 17</a>. The remaining module, <em>AllTypeTest</em>, is the default module that results when you bypass the module template options. This populates the <em>src/main/java</em> directory with all of the templates, as shown in <a href="ch15.xhtml#fig15_20">Figure 15-20</a>.</p>
<p class="indent">Now that we have seen how helpful Ghidra and Eclipse can be when we create new modules, let's use this information to build a new analyzer.</p>
<span epub:type="pagebreak" id="page_329"/>
<div class="image"><img src="Images/fig15-19.jpg" alt="image" width="844" height="373"/></div>
<p class="figcap" id="fig15_19"><em>Figure 15-19: Default analyzer template for a module (comments, imports, and functions collapsed)</em></p>
<div class="image"><img src="Images/fig15-20.jpg" alt="image" width="338" height="252"/></div>
<p class="figcap" id="fig15_20"><em>Figure 15-20: Sample default module source code content</em></p>
<h3 class="h3" id="ch15lev273"><strong>Example: Ghidra Analyzer Module Project</strong></h3>
<p class="noindent">With the Eclipse integration basics behind us, let’s walk through building a simple Ghidra analyzer to identify potential ROP gadgets in our listing. We will use a simplified software development process, as this is just a simple demonstration project. Our process includes the following steps:</p>
<ol>
<li class="noindent">Define the problem.</li>
<li class="noindent">Create the Eclipse module.</li>
<li class="noindent">Build the analyzer.</li>
<li class="noindent">Add the analyzer to our Ghidra installation.</li>
<li class="noindent">Test the analyzer from our Ghidra installation.</li>
</ol>
<span epub:type="pagebreak" id="page_330"/>
<div class="box5">
<p class="boxtitle-c"><strong>WHAT’S A ROP GADGET AND WHY DO WE CARE?</strong></p>
<p class="noindent">For those unfamiliar with exploit development, ROP stands for <em>return-oriented programming</em>. One software security mitigation that aims to defeat raw shellcode injection is to ensure that no memory region that is writable is, at the same time, also executable. Such mitigations are often referred to as <em>Non-eXecutable (NX)</em> or <em>Data Execution Prevention (DEP)</em>) because it becomes impossible to inject shellcode into memory (must be writable) and then transfer control to that shellcode (must be executable).</p>
<p class="indent">ROP techniques aim to hijack a program’s stack (often through a stack-based buffer overflow) to place a carefully crafted sequence of return addresses and data into the stack. At some point after the overflow, the program begins using the attacker-supplied return addresses rather than return addresses placed on the stack by normal program execution. The return addresses the attacker places on the stack point to program memory locations that already contain code as a result of normal program and library loading operations. Because the original author of the exploited program did not design the program to do the attacker’s work for them, the attacker often needs to pick and choose small portions of this existing code to sequence together.</p>
<p class="indent">A <em>ROP gadget</em> is a single one of these code fragments, and the sequencing mechanism often relies on the gadget terminating in a return (hence return-oriented) instruction, which retrieves an address from the now attacker-controlled stack to transfer control to the next gadget. A gadget often performs a very simple task such as loading a register from the stack. The following simple gadget could be used to initialize RAX on an x86-64 system:</p>
<pre>
POP RAX  ; pop the next item on the attacker-controlled stack into RAX<br/>
RET      ; transfer control to the address contained in the next stack item</pre>
<p class="indent">Because every exploitable program is different, attackers can’t depend on a specific set of gadgets being present in any given binary. Automated gadget finders are tools that search a binary for instruction sequences that may be used as gadgets and present these gadgets to the attacker, who must decide which ones are useful in crafting their attack. The most sophisticated gadget finders infer the semantics of a gadget and automatically sequence gadgets to perform a specified action, saving the attacker the trouble of doing it themselves.</p>
</div>
<h4 class="h4" id="ch15lev274"><strong><em>Step 1: Define the Problem</em></strong></h4>
<p class="noindent">Our task is to design and develop an instruction analyzer that will identify simple ROP gadgets within a binary. The analyzer needs to be added to Ghidra and be available as a selectable analyzer in the Ghidra Analyzer menu.</p>
<span epub:type="pagebreak" id="page_331"/>
<h4 class="h4" id="ch15lev275"><strong><em>Step 2: Create the Eclipse Module</em></strong></h4>
<p class="noindent">We use GhidraDev ▸ New ▸ Ghidra Module Project to create a module called <em>SimpleROP</em> using the analyzer module template. This creates a file called <em>SimpleROPAnalyzer.java</em> in the <em>src/main/java</em> folder within the <em>SimpleROP</em> module. The resulting Package Explorer view is shown in <a href="ch15.xhtml#fig15_21">Figure 15-21</a>.</p>
<div class="image"><img src="Images/fig15-21.jpg" alt="image" width="339" height="182"/></div>
<p class="figcap" id="fig15_21"><em>Figure 15-21: Package Explorer</em> src/main <em>entries for</em> SimpleROP</p>
<h4 class="h4" id="ch15lev276"><strong><em>Step 3: Build the Analyzer</em></strong></h4>
<p class="noindent">A portion of the generated <em>SimpleROPAnalyzer.java</em> code is shown in <a href="ch15.xhtml#fig15_22">Figure 15-22</a>. The functions have been collapsed so that we can see all of the analyzer methods that are provided. Eclipse will recommend imports if we need them as we develop our code so we can jump right into coding the tasks we need to perform and add the recommended <code>import</code> statements when Eclipse detects that we need them.</p>
<div class="image"><img src="Images/fig15-22.jpg" alt="image" width="694" height="478"/></div>
<p class="figcap" id="fig15_22"><em>Figure 15-22:</em> SimpleROPAnalyzer <em>template</em></p>
<span epub:type="pagebreak" id="page_332"/>
<p class="indent">The six task tags (to the left of the line numbers) in <a href="ch15.xhtml#fig15_22">Figure 15-22</a> indicate where we should start our development. We will expand the associated sections as we address each task and include the before and after content associated with each task. (Note that some content will be wrapped or reformatted for readability and comments minimized to conserve space.)</p>
<p class="indent">For functionality, we will rely on the following class-level declarations:</p>
<pre>   private int gadgetCount = 0;         // Counts the number of gadgets<br/>
   private BufferedWriter outFile;      // Output file<br/>
// List of "interesting" instructions<br/>
   private List&lt;String&gt; usefulInstructions = Arrays.asList(<br/>
       "NOP", "POP", "PUSH", "MOV", "ADD", "SUB", "MUL", "DIV", "XOR");<br/>
// List of "interesting" instructions that don’t have operands<br/>
   private List&lt;String&gt; require0Operands = Arrays.asList("NOP");<br/>
// List of "interesting" instructions that have one operand<br/>
   private List&lt;String&gt; require1RegOperand = Arrays.asList("POP", "PUSH");<br/>
// List of "interesting" instructions for which we want the first<br/>
// parameter to be a register<br/>
   private List&lt;String&gt; requireFirstRegOperand = Arrays.asList(<br/>
        "MOV", "ADD", "SUB", "MUL", "DIV", "XOR");<br/>
// List of "start" instructions that have ZERO operands<br/>
   private List&lt;String&gt; startInstr0Params = Arrays.asList("RET");<br/>
// List of "start" instructions that have ONE register operand<br/>
   private List&lt;String&gt; startInstr1RegParam = Arrays.asList("JMP", "CALL");</pre>
<p class="indent">Comments associated with each declaration describe the purpose of each variable. The various <code>List</code> variables contain the instructions from which our gadgets will be composed and classify those instructions based on the number and type of operands they require, and whether the instruction is a legal start instruction for one of our gadgets. Because our gadget construction algorithm works its way backward in memory, <em>start</em> here actually means a starting point for our algorithm. At runtime, these same start instructions would actually be the last instructions executed in a given gadget.</p>
<h5 class="h5" id="ch15lev277"><strong>Step 3-1: Document the Class</strong></h5>
<p class="noindent">When we expand the first task tag, we see the following task description:</p>
<pre>/**<br/>
 * TODO: Provide class-level documentation that describes what this<br/>
 * analyzer does.<br/>
 */</pre>
<p class="indent">Replace the existing <code>TODO</code> comments with comments that describe what the analyzer does:</p>
<pre>/**<br/>
 * This analyzer searches through a binary for ROP gadgets.<br/>
 * The address and contents of each gadget are written to a<br/>
 * file called <span class="codeitalic1">inputfilename</span>_gadgets.txt in the user’s home directory.<br/>
 */</pre>
<span epub:type="pagebreak" id="page_333"/>
<h5 class="h5" id="ch15lev278"><strong>Step 3-2: Name and Describe Our Analyzer</strong></h5>
<p class="noindent">Expanding the next task tag provides us with a <code>TODO</code> comment and the line of code that we need to edit. Within the Eclipse IDE, the code to be modified appears in purple font and has a name indicative of the associated task. The second task contains the following:</p>
<pre>// TODO: Name the analyzer and give it a description.<br/>
public SimpleROPAnalyzer() {<br/>
   super("My Analyzer",<br/>
         "Analyzer description goes here",<br/>
          AnalyzerType.BYTE_ANALYZER);<br/>
}</pre>
<p class="indent">The two strings need to be replaced with meaningful content. In addition, the analyzer type needs to be specified. To facilitate dependency resolution across analyzers, Ghidra groups analyzers into the following categories: byte, data, function, function modifiers, function signatures, and instruction. In this case, we are building an instruction analyzer. The resulting code is as follows:</p>
<pre>public SimpleROPAnalyzer() {<br/>
   super("SimpleROP",<br/>
         "Search a binary for ROP gadgets",<br/>
          AnalyzerType.INSTRUCTION_ANALYZER);<br/>
}</pre>
<h5 class="h5" id="ch15lev279"><strong>Step 3-3: Determine If Our Analyzer Should Be a Default Analyzer</strong></h5>
<p class="noindent">The third task asks us to return <code>true</code> if the analyzer should be enabled by default:</p>
<pre>public boolean getDefaultEnablement(Program program) {<br/>
   // TODO: Return true if analyzer should be enabled by default<br/>
   return false;<br/>
}</pre>
<p class="indent">We do not want this analyzer enabled by default; therefore, no code modifications are required.</p>
<h5 class="h5" id="ch15lev280"><strong>Step 3-4: Determine If the Input Is Appropriate for This Analyzer</strong></h5>
<p class="noindent">The fourth task requires us to determine whether our analyzer is compatible with the program content:</p>
<pre>public boolean canAnalyze(Program program) {<br/>
   // TODO: Examine 'program' to determine of this analyzer<br/>
   // should analyze it.<br/>
   // Return true if it can.<br/>
   return false;<br/>
}</pre>
<span epub:type="pagebreak" id="page_334"/>
<p class="indent">Since this analyzer is only for demonstration purposes, we assume that the input file is compatible with our analysis and simply return <code>true</code>. In reality, we would add code to verify compatibility of the analysis file prior to using our analyzer. For example, we might return <code>true</code> only after we have determined that file is an x86 binary. Worked examples of this verification can be found in most analyzers included in your Ghidra installation (<em>Ghidra/Features/Base/lib/Base-src/Ghidra/app/analyzers</em>), accessible through your module directory within Eclipse:</p>
<pre>public boolean canAnalyze(Program program) {<br/>
   return true;<br/>
}</pre>
<h5 class="h5" id="ch15lev281"><strong>Step 3-5: Register Analyzer Options</strong></h5>
<p class="noindent">The fifth task offers us the opportunity to specify any special options we wish to present to users of our analyzer:</p>
<pre>public void registerOptions(Options options, Program program) {<br/>
   // TODO: If this analyzer has custom options, register them here<br/>
   options.registerOption("Option name goes here", false, null,<br/>
                          "Option description goes here");<br/>
}</pre>
<p class="indent">Since this analyzer is only for demonstration purposes, we will not add any options. Options might include user-controlled choices (for example, choose output file, optionally annotate the listing, and so on). Options for each analyzer are displayed in the Analyzer window when an individual analyzer is selected:</p>
<pre>public void registerOptions(Options options, Program program) {<br/>
}</pre>
<h5 class="h5" id="ch15lev282"><strong>Step 3-6: Perform the Analysis</strong></h5>
<p class="noindent">The sixth task highlights the function that gets called when our analyzer gets invoked:</p>
<pre>public boolean added(Program program, AddressSetView set, TaskMonitor<br/>
                     monitor, MessageLog log) throws CancelledException {<br/>
   // TODO: Perform analysis when things get added to the 'program'.<br/>
   // Return true if the analysis succeeded.<br/>
   return false;<br/>
}</pre>
<span epub:type="pagebreak" id="page_335"/>
<p class="indent">This is the part of the module that does the work. Four methods are used by this module, each of which is detailed next:</p>
<pre>  //*************************************************************************<br/>
  //  This method is called when the analyzer is invoked.<br/>
  //*************************************************************************<br/>
<span class="ent">➊</span> public boolean added(Program program, AddressSetView set, TaskMonitor<br/>
                       monitor, MessageLog log) throws CancelledException {<br/>
      gadgetCount = 0;<br/>
      String outFileName = System.getProperty("user.home") + "/" +<br/>
                           program.getName() + "_gadgets.txt";<br/>
      monitor.setMessage("Searching for ROP Gadgets");<br/>
      try {<br/>
         outFile = new BufferedWriter(new FileWriter(outFileName));<br/>
      } catch (IOException e) {/* pass */}<br/>
      // iterate through each instruction in the binary<br/>
      Listing code = program.getListing();<br/>
      InstructionIterator instructions = code.getInstructions(set, true);<br/>
    <span class="ent">➋</span> while (instructions.hasNext() &amp;&amp; !monitor.isCancelled()) {<br/>
         Instruction inst = instructions.next();<br/>
      <span class="ent">➌</span> if (isStartInstruction(inst)) {<br/>
            // We found a "start" instruction.  This will be the last<br/>
            // instruction in the potential ROP gadget so we will try to<br/>
            // build the gadget from here<br/>
            ArrayList&lt;Instruction&gt; gadgetInstructions =<br/>
               new ArrayList&lt;Instruction&gt;();<br/>
            gadgetInstructions.add(inst);<br/>
            Instruction prevInstr = inst.getPrevious();<br/>
         <span class="ent">➍</span> buildGadget(program, monitor, prevInstr, gadgetInstructions);<br/>
         }<br/>
      }<br/>
      try {<br/>
         outFile.close();<br/>
      } catch (IOException e) {/* pass */}<br/>
      return true;<br/>
   }<br/>
   //*************************************************************************<br/>
   //  This method is called recursively until it finds an instruction that<br/>
   //  we don't want in the ROP gadget.<br/>
   //*************************************************************************<br/>
   private void buildGadget(Program program, TaskMonitor monitor,<br/>
                            Instruction inst,<br/>
                            ArrayList&lt;Instruction&gt; gadgetInstructions) {<br/>
      if (inst == null || !isUsefulInstruction(inst)<span class="ent">➎</span> ||<br/>
         monitor.isCancelled()) {<br/>
         return;<br/>
      }<br/>
      gadgetInstructions.add(inst);<br/>
   <span class="ent">➏</span> buildGadget(program, monitor, inst.getPrevious()<span class="ent">➐</span>, gadgetInstructions);<br/>
      gadgetCount += 1;<br/>
<span epub:type="pagebreak" id="page_336"/>
   <span class="ent">➑</span> for (int ii = gadgetInstructions.size() - 1; ii &gt;= 0; ii--) {<br/>
         try {<br/>
            Instruction insn = gadgetInstructions.get(ii);<br/>
            if (ii == gadgetInstructions.size() - 1) {<br/>
               outFile.write(insn.getMinAddress() + ";");<br/>
            }<br/>
            outFile.write(insn.toString() + ";");<br/>
         } catch (IOException e) {/* pass */}<br/>
      }<br/>
      try {<br/>
         outFile.write("\n");<br/>
      } catch (IOException e) {/* pass */}<br/>
      // Report count to monitor every 100th gadget<br/>
      if (gadgetCount % 100 == 0) {<br/>
         monitor.setMessage("Found " + gadgetCount + " ROP Gadgets");<br/>
      }<br/>
      gadgetInstructions.remove(gadgetInstructions.size() - 1);<br/>
   }<br/>
   //*************************************************************************<br/>
   //  This method determines if an instruction is useful in the context of<br/>
   //  a ROP gadget<br/>
   //*************************************************************************<br/>
   private boolean isUsefulInstruction(Instruction inst) {<br/>
      if (!usefulInstructions.contains(inst.getMnemonicString())) {<br/>
         return false;<br/>
      }<br/>
      if (require0Operands.contains(inst.getMnemonicString())) {<br/>
         return true;<br/>
      }<br/>
      if (require1RegOperand.contains(inst.getMnemonicString()) &amp;&amp;<br/>
         inst.getNumOperands() == 1) {<br/>
         Object[] opObjects0 = inst.getOpObjects(0);<br/>
         for (int ii = 0; ii &lt; opObjects0.length; ii++) {<br/>
            if (opObjects0[ii] instanceof Register) {<br/>
               return true;<br/>
            }<br/>
         }<br/>
      }<br/>
      if (requireFirstRegOperand.contains(inst.getMnemonicString()) &amp;&amp;<br/>
         inst.getNumOperands() &gt;= 1) {<br/>
         Object[] opObjects0 = inst.getOpObjects(0);<br/>
         for (int ii = 0; ii &lt; opObjects0.length; ii++) {<br/>
            if (opObjects0[ii] instanceof Register) {<br/>
               return true;<br/>
            }<br/>
         }<br/>
      }<br/>
      return false;<br/>
   }<br/>
   //*************************************************************************<br/>
   //  This method determines if an instruction is the "start" of a<br/>
   //  potential ROP gadget<br/>
   //*************************************************************************<br/>
<span epub:type="pagebreak" id="page_337"/>
   private boolean isStartInstruction(Instruction inst) {<br/>
      if (startInstr0Params.contains(inst.getMnemonicString())) {<br/>
         return true;<br/>
      }<br/>
      if (startInstr1RegParam.contains(inst.getMnemonicString()) &amp;&amp;<br/>
         inst.getNumOperands() &gt;= 1) {<br/>
         Object[] opObjects0 = inst.getOpObjects(0);<br/>
         for (int ii = 0; ii &lt; opObjects0.length; ii++) {<br/>
            if (opObjects0[ii] instanceof Register) {<br/>
               return true;<br/>
            }<br/>
         }<br/>
      }<br/>
      return false;<br/>
   }</pre>
<p class="indent">Ghidra invokes an analyzer’s <code>added</code> method <span class="ent">➊</span> to initiate analysis. Our algorithm tests every instruction <span class="ent">➋</span> in the binary to determine whether the instruction is a valid “start” point <span class="ent">➌</span> for our gadget builder. Each time a valid start instruction is found, our gadget creation function, <code>buildGadget</code>, is invoked <span class="ent">➍</span>. Gadget creation is a recursive <span class="ent">➏</span> walk backward <span class="ent">➐</span> through the instruction list that continues as long as an instruction is considered useful <span class="ent">➎</span> to us. Finally, each gadget is printed, by iterating over its instructions <span class="ent">➑</span>, as it is completed.</p>
<h4 class="h4" id="ch15lev283"><strong><em>Step 4: Test the Analyzer Within Eclipse</em></strong></h4>
<p class="noindent">During the development process, it is common to test and modify code frequently. As you are building your analyzer, you can test its functionality within Eclipse by using the Run As option and choosing Ghidra. This opens Ghidra with the current version of the module temporarily installed. If the results are not what you expect when you test the module, you can edit the file within Eclipse and retest. When you are satisfied with your result, you should move on to step 5. Using this method to test your code within Eclipse can be a great time-saver during the development process.</p>
<h4 class="h4" id="ch15lev284"><strong><em>Step 5: Add the Analyzer to Our Ghidra Installation</em></strong></h4>
<p class="noindent">To add this analyzer to our Ghidra installation, we need to export our module from Eclipse and then install the extension in Ghidra. Exporting is accomplished by selecting <strong>GhidraDev</strong> ▸ <strong>Export</strong> ▸ <strong>Ghidra Module Extension</strong>, choosing your module, and clicking <strong>Next</strong>. In the next window, select the <strong>Gradle Wrapper</strong> option shown in <a href="ch15.xhtml#fig15_23">Figure 15-23</a> if you do not have a local Gradle installation (note that an internet connection is required in order for the wrapper to reach out to <em>gradle.org</em>). Click <strong>Finish</strong> to complete the export process. If this is your first time exporting the module, a <em>dist</em> directory will be added to your module within Eclipse and a <em>.zip</em> file of the exported content will be saved to the folder.</p>
<span epub:type="pagebreak" id="page_338"/>
<div class="image"><img src="Images/fig15-23.jpg" alt="image" width="694" height="326"/></div>
<p class="figcap" id="fig15_23"><em>Figure 15-23: Configure Gradle dialog</em></p>
<p class="indent">In the Ghidra Project window, add the new analyzer by selecting <strong>File</strong> ▸ <strong>Install Extensions</strong>. A window similar to that shown in <a href="ch15.xhtml#fig15_24">Figure 15-24</a> will be displayed showing all of the existing extensions that have not been installed.</p>
<div class="image"><img src="Images/fig15-24.jpg" alt="image" width="658" height="256"/></div>
<p class="figcap" id="fig15_24"><em>Figure 15-24: Install Extensions window</em></p>
<p class="indent">Add the new analyzer <em>SimpleROP</em> by selecting the + icon at the top right and navigating to our newly created <em>.zip</em> file in the associated <em>dist</em> directory. Once our analyzer appears in the list, we can select it and click OK (not shown). Restart Ghidra to use the new functionality from the Analysis menu.</p>
<h4 class="h4" id="ch15lev285"><strong><em>Step 6: Test the Analyzer Within Ghidra</em></strong></h4>
<p class="noindent">As with our limited development plan, we used a limited scope test plan just to demonstrate functionality. <em>SimpleROP</em> passed acceptance testing as the analyzer met the following criteria:</p>
<ol>
<li class="noindent">(Pass) <em>SimpleROP</em> appears in the Analysis Options in the CodeBrowser ▸ Analysis menu.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_339"/>(Pass) The description of <em>SimpleROP</em> appears in the Analysis Options description window when selected.
<p class="noindent">Test cases 1 and 2 passed, as shown in <a href="ch15.xhtml#fig15_25">Figure 15-25</a>. (Had we chosen to register and program associated options in step 3-5, they would have been displayed in the Options panel on the right side of the window).</p>
<div class="image"><img src="Images/fig15-25.jpg" alt="image" width="657" height="373"/></div>
<p class="figcap" id="fig15_25"><em>Figure 15-25: Analysis Options window</em></p></li>
<li class="noindent">(Pass) <em>SimpleROP</em> executes when selected.
<p class="noindent">In this case, we ran <em>SimpleROP</em> on an analyzed file, and as part of auto analysis. Running <em>SimpleROP</em> on an unanalyzed file would not yield any results, as <code>INSTRUCTION_ANALYZER</code> extensions require instructions to have been previously identified (a default part of auto analysis). When <em>SimpleROP</em> is run as part of the auto analysis, it is prioritized appropriately because of the analyzer type we assigned in step 3-2. <a href="ch15.xhtml#fig15_26">Figure 15-26</a> shows the Ghidra Log confirmation that the <em>SimpleROP</em> analyzer ran.</p>
<div class="image"><img src="Images/fig15-26.jpg" alt="image" width="657" height="307"/></div>
<p class="figcap" id="fig15_26"><em>Figure 15-26: Ghidra User Log window showing analysis confirmation</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_340"/>(Pass) <em>SimpleROP</em> writes each gadget to a file called <em>fileZZZ_gadgets.txt</em> when analyzing <em>fileZZZ</em>.
<p class="indenta">The following excerpt from the file <em>call_tree_x64_static_gadgets.txt</em> shows that many of the gadgets are taken from the portion of the <em>call_tree_x64_static</em> listing shown in <a href="ch15.xhtml#fig15_27">Figure 15-27</a>:</p>
<pre>00400412;ADD RSP,0x8;RET;<br/>
004004ce;NOP;RET;<br/>
00400679;ADD RSP,0x8;POP RBX;POP RBP;POP R12;POP R13;POP R14;POP R15;RET;<br/>
0040067d;POP RBX;POP RBP;POP R12;POP R13;POP R14;POP R15;RET;<br/>
0040067e;POP RBP;POP R12;POP R13;POP R14;POP R15;RET;<br/>
0040067f;POP R12;POP R13;POP R14;POP R15;RET;<br/>
00400681;POP R13;POP R14;POP R15;RET;<br/>
00400683;POP R14;POP R15;RET;<br/>
00400685;POP R15;RET;<br/>
00400a8b;POP RBP;MOV EDI,0x6babd0;JMP RAX;<br/>
00400a8c;MOV EDI,0x6babd0;JMP RAX;<br/>
00400a98;POP RBP;RET;</pre>
<div class="image"><img src="Images/fig15-27.jpg" alt="image" width="332" height="254"/></div>
<p class="figcap" id="fig15_27"><em>Figure 15-27: CodeBrowser listing of</em> call_tree_x64_static</p></li>
</ol>
<h3 class="h3" id="ch15lev286"><strong>Summary</strong></h3>
<p class="noindent">In <a href="ch14.xhtml#ch14">Chapter 14</a>, we introduced scripting as a means of extending Ghidra’s capabilities. In this chapter, we introduced Ghidra extension modules along with Ghidra’s Eclipse integration capabilities. While Eclipse is not your only option for editing Ghidra extensions, the integration of Ghidra and the Eclipse IDE provides an incredibly powerful environment for developers extending Ghidra’s capabilities. The development wizards and templates lower the bar for authoring extensions as they present coders with a guided approach to modifying existing content and building new extensions. In <a href="ch16.xhtml#ch16">Chapter 16</a>, we take a look at headless Ghidra, an option that appeared in <a href="ch15.xhtml#fig15_18">Figure 15-18</a>. Subsequent chapters build on the integration of Ghidra and the Eclipse IDE to further extend Ghidra’s capabilities and provide a solid foundation for making Ghidra into the optimal tool for your reverse engineering workflow.</p>
</div>



  </body></html>