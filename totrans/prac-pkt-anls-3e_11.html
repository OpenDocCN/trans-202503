<html><head></head><body>
<h2 class="h2"><a id="ch11"/><span epub:type="pagebreak" id="page_231"/><strong><span class="big">11</span></strong><br/><strong>FIGHTING A SLOW NETWORK</strong></h2>&#13;
<div class="image"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><span class="big1">As a network administrator, much of your time will be spent fixing computers and services that are running slower than they should be. But just because someone says that the network is running slowly doesn’t mean that the network is to blame.</span></p>&#13;
<p class="indent">Before you begin to tackle a slow network, you first need to determine whether the network is in fact running slowly. You’ll learn how to do that in this chapter.</p>&#13;
<p class="indent">We’ll begin by discussing the error-recovery and flow-control features of TCP. Then we’ll explore how to detect the source of slowness on a network. Finally, we’ll look at ways of baselining networks and the devices and services that run on them. Once you have completed this chapter, you should be much better equipped to identify, diagnose, and troubleshoot slow networks.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_232"/><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Multiple techniques can be used to troubleshoot slow networks. I’ve chosen to focus primarily on TCP because most of the time, it is all you’ll have to work with. TCP allows you to perform passive retrospective analysis rather than generate additional traffic (unlike ICMP).</em></p>&#13;
</div>&#13;
<h3 class="h3"><a id="ch11lev1sec1"/><strong>TCP Error-Recovery Features</strong></h3>&#13;
<p class="noindent">TCP’s error-recovery features are our best tools for locating, diagnosing, and eventually repairing high latency on a network. In terms of computer networking, <em>latency</em> is a measure of delay between a packet’s transmission and its receipt.</p>&#13;
<p class="indent">Latency can be measured as one-way (from a single source to a destination) or as round-trip (from a source to a destination and back to the original source). When communication between devices is fast, and the amount of time it takes a packet to get from one point to another is low, the communication is said to have <em>low latency</em>. Conversely, when packets take a significant amount of time to travel between a source and destination, the communication is said to have <em>high latency</em>. High latency is the number one enemy of all network administrators who value their sanity (and their jobs).</p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch08">Chapter 8</a>, we discussed how TCP uses sequence and acknowledgment numbers to ensure the reliable delivery of packets. In this chapter, we’ll look at sequence and acknowledgment numbers again to see how TCP responds when high latency causes these numbers to be received out of sequence (or not received at all).</p>&#13;
<h4 class="h4"><a id="ch11lev2sec1"/><strong><em>TCP Retransmissions</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>tcp_retransmissions.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The ability of a host to retransmit packets is one of TCP’s most fundamental error-recovery features. It is designed to combat packet loss.</p>&#13;
<p class="indent">There are many possible causes of packet loss, including malfunctioning applications, routers under a heavy traffic load, or temporary service outages. Things move fast at the packet level, and often the packet loss is temporary, so it’s crucial for TCP to be able to detect and recover from packet loss.</p>&#13;
<p class="indent">The primary mechanism for determining whether the retransmission of a packet is necessary is the <em>retransmission timer</em>. This timer is responsible for maintaining a value called the <em>retransmission timeout (RTO)</em>. Whenever a packet is transmitted using TCP, the retransmission timer starts. This timer stops when an ACK for that packet is received. The time between the packet transmission and receipt of the ACK packet is called the <em>round-trip time (RTT)</em>. Several of these times are averaged, and that average is used to determine the final RTO value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_233"/>Until an RTO value is determined, the transmitting operating system relies on its default configured RTT setting, which is issued for the initial communication between hosts. This is then adjusted based on the RTT of received packets to determine the RTO value.</p>&#13;
<p class="indent">Once the RTO value has been determined, the retransmission timer is used on every transmitted packet to determine whether packet loss has occurred. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> illustrates the TCP retransmission process.</p>&#13;
<div class="image"><img alt="image" src="../images/f233-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig1"/><em>Figure 11-1: Conceptual view of the TCP retransmission process</em></p>&#13;
<p class="indent">When a packet is sent, but the recipient has not sent back a TCP ACK packet, the transmitting host assumes that the original packet was lost and retransmits the original packet. When the retransmission is sent, the RTO value is doubled; if no ACK packet is received before that value is reached, another retransmission will occur. If this retransmission also does not receive an ACK response, the RTO value is doubled again. This process will continue, with the RTO value being doubled for each retransmission, until an ACK packet is received or until the sender reaches the maximum number of retransmission attempts it is configured to send. More details about this process are described in RFC6298.</p>&#13;
<p class="indent">The maximum number of retransmission attempts depends on the value configured in the transmitting operating system. By default, Windows hosts make a maximum of five retransmission attempts. Most Linux hosts default to a maximum of 15 attempts. This option is configurable in either operating system.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_234"/>For an example of TCP retransmission, open the file <em>tcp_retransmissions.pcapng</em>, which contains six packets. The first packet is shown in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f234-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig2"/><em>Figure 11-2: A simple TCP packet containing data</em></p>&#13;
<p class="indent">This packet is a TCP PSH/ACK packet <span class="ent">➋</span> containing 648 bytes of data <span class="ent">➌</span> that are sent from 10.3.30.1 to 10.3.71.7 <span class="ent">➊</span>. This is a typical data packet.</p>&#13;
<p class="indent">Under normal circumstances, you would expect to see a TCP ACK packet in response fairly soon after the first packet is sent. In this case, however, the next packet is a retransmission. You can tell this by looking at the packet in the Packet List pane. The Info column will clearly say <span class="literal">[TCP Retransmission]</span>, and the packet will appear with red text on a black background. <a href="ch11.xhtml#ch11fig3">Figure 11-3</a> shows examples of retransmissions listed in the Packet List pane.</p>&#13;
<div class="image"><img alt="image" src="../images/f234-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig3"/><em>Figure 11-3: Retransmissions in the Packet List pane</em></p>&#13;
<p class="indent">You can also determine whether a packet is a retransmission by examining it in the Packet Details pane, as shown in <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>.</p>&#13;
<p class="indent">In the Packet Details pane, notice that the retransmission packet has some additional information included under the SEQ/ACK analysis heading <span class="ent">➊</span>. This useful information is provided by Wireshark and is not contained in the packet itself. The SEQ/ACK analysis tells us that this is indeed a retransmission <span class="ent">➋</span>, that the RTO value is 0.206 seconds <span class="ent">➌</span>, and that the RTO is based on the delta time from packet 1 <span class="ent">➍</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_235"/><img alt="image" src="../images/f235-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig4"/><em>Figure 11-4: An individual retransmission packet</em></p>&#13;
<p class="indent">Note that this packet is the same as the original packet (other than the IP identification and Checksum fields). To verify this, compare the Packet Bytes pane of this retransmitted packet with the original one.</p>&#13;
<p class="indent">Examination of the remaining packets should yield similar results, with the only differences between the packets found in the IP identification and Checksum fields and in the RTO value. To visualize the time lapse between each packet, look at the Time column in the Packet List pane, as shown in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>. Here, you see exponential growth in time as the RTO value is doubled after each retransmission.</p>&#13;
<p class="indent">The TCP retransmission feature is used by the transmitting device to detect and recover from packet loss. Next, we’ll examine <em>TCP duplicate acknowledgments</em>, a feature that the data recipient uses to detect and recover from packet loss.</p>&#13;
<div class="image"><img alt="image" src="../images/f235-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig5"/><em>Figure 11-5: The Time column shows the increase in RTO value.</em></p>&#13;
<h4 class="h4"><a id="ch11lev2sec2"/><strong><em>TCP Duplicate Acknowledgments and Fast Retransmissions</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>tcp_dupack.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">A duplicate ACK is a TCP packet sent from a recipient when that recipient receives packets that are out of order. TCP uses the sequence and acknowledgment number fields within its header to reliably ensure that data is received and reassembled in the same order in which it was sent.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>The proper term for a TCP packet is actually</em> TCP segment<em>, but most people refer to it as a packet.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_236"/>When a new TCP connection is established, one of the most important pieces of information exchanged during the handshake process is an initial sequence number (ISN). Once the ISN is set for each side of the connection, each subsequently transmitted packet increments the sequence number by the size of its data payload.</p>&#13;
<p class="indent">Consider a host that has an ISN of 5000 and sends a 500-byte packet to a recipient. Once this packet has been received, the recipient host will respond with a TCP ACK packet with an acknowledgment number of 5500, based on the following formula:</p>&#13;
<p class="center"><em>Sequence Number In</em> + <em>Bytes of Data Received</em> = <em>Acknowledgment Number Out</em></p>&#13;
<p class="indent">As a result of this calculation, the acknowledgment number returned to the transmitting host is the next sequence number that the recipient expects to receive. An example of this can be seen in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f236-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig6"/><em>Figure 11-6: TCP sequence and acknowledgment numbers</em></p>&#13;
<p class="indent">The detection of packet loss by the data recipient is made possible through the sequence numbers. As the recipient tracks the sequence numbers it is receiving, it can determine when it receives sequence numbers that are out of order.</p>&#13;
<p class="indent">When the recipient receives an unexpected sequence number, it assumes that a packet has been lost in transit. To reassemble data properly, the recipient must have the missing packet, so it resends the ACK packet that contains the lost packet’s expected sequence number in order to elicit a retransmission of that packet from the transmitting host.</p>&#13;
<p class="indent">When the transmitting host receives three duplicate ACKs from the recipient, it assumes that the packet was indeed lost in transit and immediately sends a <em>fast retransmission</em>. Once a fast retransmission is triggered, all other packets being transmitted are queued until the fast retransmission packet is sent. This process is depicted in <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_237"/><img alt="image" src="../images/f237-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig7"/><em>Figure 11-7: Duplicate ACKs from the recipient result in a fast retransmission.</em></p>&#13;
<p class="indent">You’ll find an example of duplicate ACKs and fast retransmissions in the file <em>tcp_dupack.pcapng</em>. The first packet in this capture is shown in <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f237-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig8"/><em>Figure 11-8: The ACK showing the next expected sequence number</em></p>&#13;
<p class="indent">This packet, a TCP ACK sent from the data recipient (172.31.136.85) to the transmitter (195.81.202.68) <span class="ent">➊</span>, has an acknowledgment of the data sent in the previous packet that is not included in this capture file.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_238"/><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>By default, Wireshark uses relative sequence numbers to make the analysis of these numbers easier, but the examples and screenshots in the next few sections do not use this feature. To turn off this feature, select</em> <strong><em>Edit ▶ Preferences</em></strong><em>. In the Preferences window, select</em> <strong><em>Protocols</em></strong> <em>and then the</em> <strong><em>TCP</em></strong> <em>section. Then uncheck the box next to</em> <strong><em>Relative sequence numbers</em></strong>.</p>&#13;
</div>&#13;
<p class="indent">The acknowledgment number in this packet is 1310973186 <span class="ent">➋</span>. This should match the sequence number in the next packet received, as shown in <a href="ch11.xhtml#ch11fig9">Figure 11-9</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f238-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig9"/><em>Figure 11-9: The sequence number of this packet is not what was expected.</em></p>&#13;
<p class="indent">Unfortunately for us and our recipient, the sequence number of the next packet is 1310984130 <span class="ent">➊</span>, which is not what we expect. This out-of-order packet indicates that the expected packet was somehow lost in transit. The recipient host notices that this packet is out of sequence and sends a duplicate ACK in the third packet of this capture, as shown in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>.</p>&#13;
<p class="indenta">You can determine that this is a duplicate ACK packet by examining either of the following:</p>&#13;
<p class="bullet">•     The Info column in the Packet Details pane. The packet should appear as red text on a black background.</p>&#13;
<p class="bulleta">•     The Packet Details pane under the SEQ/ACK analysis heading (<a href="ch11.xhtml#ch11fig10">Figure 11-10</a>). If you expand this heading, you’ll find that the packet is listed as a duplicate ACK of packet 1 <span class="ent">➊</span>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_239"/><img alt="image" src="../images/f239-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig10"/><em>Figure 11-10: The first duplicate ACK packet</em></p>&#13;
<p class="indent">The next several packets continue this process, as shown in <a href="ch11.xhtml#ch11fig11">Figure 11-11</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f239-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig11"/><em>Figure 11-11: Additional duplicate ACKs are generated due to out-of-order packets.</em></p>&#13;
<p class="indent">The fourth packet in the capture file is another chunk of data sent from the transmitting host with the wrong sequence number <span class="ent">➊</span>. As a result, the recipient host sends its second duplicate ACK <span class="ent">➋</span>. One more packet with the wrong sequence number is received by the recipient <span class="ent">➌</span>. That prompts the transmission of the third and final duplicate ACK <span class="ent">➍</span>.</p>&#13;
<p class="indent">As soon as the transmitting host receives the third duplicate ACK from the recipient, it is forced to halt all packet transmission and resend the lost packet. <a href="ch11.xhtml#ch11fig12">Figure 11-12</a> shows the fast retransmission of the lost packet.</p>&#13;
<p class="indent">The retransmission packet can once again be found through the Info column in the Packet List pane. As with previous examples, the packet is clearly labeled with red text on a black background. The SEQ/ACK analysis section of this packet (<a href="ch11.xhtml#ch11fig12">Figure 11-12</a>) tells us that this is suspected to be a fast retransmission <span class="ent">➊</span>. (Again, the information that labels this packet as a fast retransmission is not a value set in the packet itself but rather a feature of Wireshark.) The final packet in the capture is an ACK packet acknowledging receipt of the fast retransmission.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_240"/><img alt="image" src="../images/f240-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig12"/><em>Figure 11-12: Three duplicate ACKs cause this fast retransmission of the lost packet.</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>One feature to consider that may affect the flow of data in TCP communications in which packet loss is present is the Selective Acknowledgment feature. In the packet capture we just examined, Selective ACK was negotiated as an enabled feature during the initial three-way handshake process. As a result, whenever a packet is lost and a duplicate ACK received, only the lost packet has to be retransmitted, even though other packets were received successfully after the lost packet. Had Selective ACK not been enabled, every packet occurring after the lost packet would have had to be retransmitted as well. Selective ACK makes data loss recovery much more efficient. Because most modern TCP/IP stack implementations support Selective ACK, you will find that this feature is usually implemented.</em></p>&#13;
</div>&#13;
<h3 class="h3"><a id="ch11lev1sec2"/><strong>TCP Flow Control</strong></h3>&#13;
<p class="noindent">Retransmissions and duplicate ACKs are reactive TCP functions designed to recover from packet loss. TCP would be a poor protocol indeed if it didn’t include some form of proactive method for preventing packet loss.</p>&#13;
<p class="indent">TCP implements a <em>sliding-window mechanism</em> to detect when packet loss may occur and adjust the rate of data transmission to prevent it. The sliding-window mechanism leverages the data recipient’s <em>receive window</em> to control the flow of data.</p>&#13;
<p class="indent">The receive window is a value specified by the data recipient and stored in the TCP header (in bytes) that tells the transmitting device how much data the recipient is willing to store in its <em>TCP buffer space</em>. This buffer space is where data is stored temporarily until it can be passed up the stack to the <span epub:type="pagebreak" id="page_241"/>application-layer protocol waiting to process it. As a result, the transmitting host can send only the amount of data specified in the Window size value field at one time. For the transmitter to send more data, the recipient must send an acknowledgment that the previous data was received. It also must clear TCP buffer space by processing the data that is occupying that position. <a href="ch11.xhtml#ch11fig13">Figure 11-13</a> illustrates how the receive window works.</p>&#13;
<div class="image"><img alt="image" src="../images/f241-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig13"/><em>Figure 11-13: The receive window keeps the data recipient from getting overwhelmed.</em></p>&#13;
<p class="indent">In <a href="ch11.xhtml#ch11fig13">Figure 11-13</a>, the client is sending data to a server that has communicated a receive window size of 5,000 bytes. The client sends 2,500 bytes, reducing the server’s buffer space to 2,500 bytes, and then sends another 2,000 bytes, further reducing the buffer to 500 bytes. The server sends an acknowledgment of this data, and after it processes the data in its buffer, it again has an empty buffer available. This process repeats, with the client sending 3,000 bytes and another 1,000 bytes, reducing the server’s buffer to 1,000 bytes. The client once more acknowledges this data and processes the contents of its buffer.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec3"/><strong><em>Adjusting the Window Size</em></strong></h4>&#13;
<p class="noindent">This process of adjusting the window size is fairly clear-cut, but it isn’t always perfect. Whenever data is received by the TCP stack, an acknowledgment is generated and sent in reply, but the data placed in the recipient’s buffer is not always processed immediately.</p>&#13;
<p class="indent">When a busy server is processing packets from multiple clients, it could quite possibly be slow in clearing its buffer and thus be unable to make room for new data. Without a means of flow control, a full buffer could lead to lost packets and data corruption. Fortunately, when a server becomes too busy to process data at the rate its receive window is advertising, it can adjust the size <span epub:type="pagebreak" id="page_242"/>of the window. It does this by decreasing the window size value in the TCP header of the ACK packet it is sending back to the hosts that are sending it data. <a href="ch11.xhtml#ch11fig14">Figure 11-14</a> shows an example of this.</p>&#13;
<div class="image"><img alt="image" src="../images/f242-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig14"/><em>Figure 11-14: The window size can be adjusted when the server becomes busy.</em></p>&#13;
<p class="indent">In <a href="ch11.xhtml#ch11fig14">Figure 11-14</a>, the server starts with an advertised window size of 5,000 bytes. The client sends 2,000 bytes, followed by another 2,000 bytes, leaving only 1,000 bytes of buffer space available. The server realizes that its buffer is filling up quickly and knows that if data transfer keeps up at this rate, packets will soon be lost. To avoid such a mishap, the server sends an acknowledgment to the client with an updated window size of 1,000 bytes. The client responds by sending less data, and now the rate at which the server can process its buffer contents allows data to flow in a constant manner.</p>&#13;
<p class="indent">The resizing process works both ways. When the server can process data at a faster rate, it can send an ACK packet with a larger window size.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec4"/><strong><em>Halting Data Flow with a Zero Window Notification</em></strong></h4>&#13;
<p class="noindent">Due to a lack of memory, a lack of processing capability, or another problem, a server may no longer process data sent from a client. Such a stoppage could result in dropped packets and a halting of the communication process, but the receive window can minimize negative effects.</p>&#13;
<p class="indent">When this situation arises, a server can send a packet that contains a window size of zero. When the client receives this packet, it will halt any data transmission but will sometimes keep the connection to the server open with the transmission of <em>keep-alive packets</em>. Keep-alive packets can be sent by the client at regular intervals to check the status of the server’s <span epub:type="pagebreak" id="page_243"/>receive window. Once the server can begin processing data again, it will respond with a nonzero window size, and communication will resume. <a href="ch11.xhtml#ch11fig15">Figure 11-15</a> illustrates an example of zero window notification.</p>&#13;
<div class="image"><img alt="image" src="../images/f243-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig15"/><em>Figure 11-15: Data transfer stops when the window size is set to 0 bytes.</em></p>&#13;
<p class="indent">In <a href="ch11.xhtml#ch11fig15">Figure 11-15</a>, the server begins receiving data with a 5,000-byte window size. After receiving a total of 4,000 bytes of data from the client, the server begins experiencing a very heavy processor load, and it can no longer process any data from the client. The server then sends a packet with the Window size value field set to 0. The client halts transmission of data and sends a keep-alive packet. After receiving the keep-alive packet, the server responds with a packet notifying the client that it can now receive data and that its window size is 1,000 bytes. The client resumes sending data but at a slower rate than before.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec5"/><strong><em>The TCP Sliding Window in Practice</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>tcp_zerowindow recovery.pcapng tcp_zerowindow dead.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Having covered the theory behind the TCP sliding window, we will now examine it in the capture file <em>tcp_zerowindowrecovery.pcapng</em>.</p>&#13;
<p class="indent">In this file, we begin with several TCP ACK packets traveling from 192.168.0.20 to 192.168.0.30. The main value of interest to us is the Window size value field, which can be seen in both the Info column of the Packet List pane and in the TCP header in the Packet Details pane. You can see immediately that this field’s value decreases over the course of the first three packets, as shown in <a href="ch11.xhtml#ch11fig16">Figure 11-16</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f243-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig16"/><em>Figure 11-16: The window size of these packets is decreasing.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_244"/>The window size value goes from 8,760 bytes in the first packet to 5,840 bytes in the second packet and then 2,920 bytes in the third packet <span class="ent">➋</span>. This lowering of the window size value is a classic indicator of increased latency from the host. Notice in the Time column that this happens very quickly <span class="ent">➊</span>. When the window size is lowered this fast, it’s common for the window size to drop to zero, which is exactly what happens in the fourth packet, as shown in <a href="ch11.xhtml#ch11fig17">Figure 11-17</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f244-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig17"/><em>Figure 11-17: This zero window packet says that the host cannot accept any more data.</em></p>&#13;
<p class="indent">The fourth packet is also being sent from 192.168.0.20 to 192.168.0.30, but its purpose is to tell 192.168.0.30 that it can no longer receive any data. The 0 value is seen in the TCP header <span class="ent">➊</span>. Wireshark also tells us that this is a zero window packet in the Info column of the Packet List pane and under the SEQ/ACK analysis section of the TCP header <span class="ent">➋</span>.</p>&#13;
<p class="indent">Once this zero window packet is sent, the device at 192.168.0.30 will not send any more data until it receives a window update from 192.168.0.20 notifying it that the window size has increased. Luckily for us, the issue causing the zero window condition in this capture file was only temporary. So, a window update is sent in the next packet, shown in <a href="ch11.xhtml#ch11fig18">Figure 11-18</a>.</p>&#13;
<p class="indent">In this case, the window size is increased to a very healthy 64,240 bytes <span class="ent">➊</span>. Wireshark once again lets us know that this is a window update under the SEQ/ACK analysis heading.</p>&#13;
<p class="indent">Once the update packet is received, the host at 192.168.0.30 can begin sending data again, as it does in packets 6 and 7. This entire period of halted data transmission takes place very quickly. Had it lasted only slightly longer, it could have caused a potential hiccup on the network, resulting in a slower or failed data transfer.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_245"/><img alt="image" src="../images/f245-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig18"/><em>Figure 11-18: A TCP window update packet lets the other host know it can begin transmitting again.</em></p>&#13;
<p class="indent">For one last look at the sliding window, examine <em>tcp_zerowindowdead.pcapng</em>. The first packet in this capture is normal HTTP traffic being sent from 195.81.202.68 to 172.31.136.85. The packet is immediately followed with a zero window packet sent back from 172.31.136.85, as shown in <a href="ch11.xhtml#ch11fig19">Figure 11-19</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f245-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig19"/><em>Figure 11-19: A zero window packet halts data transfer.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>This looks very similar to the zero window packet shown in <a href="ch11.xhtml#ch11fig17">Figure 11-17</a>, but the result is much different. Rather than seeing a window update from the 172.31.136.85 host and the resumption of communication, we see a keep-alive packet, as shown in <a href="ch11.xhtml#ch11fig20">Figure 11-20</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f246-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig20"/><em>Figure 11-20: This keep-alive packet ensures the zero window host is still alive.</em></p>&#13;
<p class="indent">This packet is marked as a keep-alive by Wireshark under the SEQ/ACK analysis section of the TCP header in the Packet Details pane <span class="ent">➊</span>. The Time column tells us that this packet was sent 3.4 seconds after the last received packet. This process continues several more times, with one host sending a zero window packet and the other sending a keep-alive packet, as shown in <a href="ch11.xhtml#ch11fig21">Figure 11-21</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f246-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig21"/><em>Figure 11-21: The host and client continue to send zero window and keep-alive packets, respectively.</em></p>&#13;
<p class="indent">These keep-alive packets occur at intervals of 3.4, 6.8, and 13.5 seconds <span class="ent">➊</span>. This process can go on for quite a long time, depending on the operating systems of the communicating devices. As you can see by adding up the values in the Time column, the connection is halted for nearly <span epub:type="pagebreak" id="page_247"/>25 seconds. Imagine attempting to authenticate with a domain controller or download a file from the internet while experiencing a 25-second delay—unacceptable!</p>&#13;
<h3 class="h3"><a id="ch11lev1sec3"/><strong>Learning from TCP Error-Control and Flow-Control Packets</strong></h3>&#13;
<p class="noindent">Let’s put retransmission, duplicate ACKs, and the sliding-window mechanism into some context. Here are a few notes to keep in mind when troubleshooting latency issues.</p>&#13;
<p class="noindent"><strong>Retransmission Packets</strong></p>&#13;
<p class="noindentl">Retransmissions occur because the client has detected that the server is not receiving the data it’s sending. Therefore, depending on which side of the communication you are analyzing, you may never see retransmissions. If you are capturing data from the server, and it is truly not receiving the packets being sent and retransmitted from the client, you may be in the dark because you won’t see the retransmission packets. If you suspect that you are the victim of packet loss on the server side, consider attempting to capture traffic from the client (if possible) so that you can see whether retransmission packets are present.</p>&#13;
<p class="noindent"><strong>Duplicate ACK Packets</strong></p>&#13;
<p class="noindentl">I tend to think of a duplicate ACK as the pseudo-opposite of a retransmission, because it is sent when the server detects that a packet from the client it is communicating with was lost in transit. In most cases, you can see duplicate ACKs when capturing traffic on both sides of the communication. Remember that duplicate ACKs are triggered when packets are received out of sequence. For example, if the server received just the first and third of three packets sent, it would send a duplicate ACK to elicit a fast retransmission of the second packet from the client. Since you have received the first and third packets, it’s likely that whatever condition caused the second packet to be dropped was only temporary, so the duplicate ACK will likely be sent and received successfully. Of course, this scenario isn’t always the case, so when you suspect packet loss on the server side and don’t see any duplicate ACKs, consider capturing packets from the client side of the communication.</p>&#13;
<p class="noindent"><strong>Zero Window and Keep-Alive Packets</strong></p>&#13;
<p class="noindentl">The sliding window relates directly to the server’s inability to receive and process data. Any decrease in the window size or a zero window state is a direct result of some issue with the server, so if you see either occurring on the wire, you should focus your investigation there. You will typically see window update packets on both sides of network communications.</p>&#13;
<h3 class="h3"><a id="ch11lev1sec4"/><span epub:type="pagebreak" id="page_248"/><strong>Locating the Source of High Latency</strong></h3>&#13;
<p class="noindent">In some cases, packet loss may not be the cause of latency. You may find that even though communications between two hosts are slow, that slowness doesn’t show the common symptoms of TCP retransmissions or duplicate ACKs. Thus, you need another technique to locate the source of the high latency.</p>&#13;
<p class="indent">One of the most effective ways to find the source of high latency is to examine the initial connection handshake and the first couple of packets that follow it. For example, consider a simple connection between a client and a web server as the client attempts to browse a site hosted on the web server. We are concerned with the first six packets of this communication sequence, consisting of the TCP handshake, the initial HTTP <span class="literal">GET</span>   request, the acknowledgment of that <span class="literal">GET</span> request, and the first data packet sent from the server to the client.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>To follow along with this section, ensure that you have the proper time display format set in Wireshark by selecting</em> <strong><em>View</em></strong> ▶ <strong><em>Time Display Format</em></strong> ▶ <strong><em>Seconds Since Previous Displayed Packet</em></strong>.</p>&#13;
</div>&#13;
<h4 class="h4"><a id="ch11lev2sec6"/><strong><em>Normal Communications</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>latency1.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">We’ll discuss network baselines in detail a little later in the chapter. For now, just know that you need a baseline of normal communications to compare with the conditions of high latency. For these examples, we will use the file <em>latency1.pcapng</em>. We have already covered the details of the TCP handshake and HTTP communication, so we won’t review those topics again. In fact, we won’t look at the Packet Details pane at all. All we are really concerned about is the Time column, as shown in <a href="ch11.xhtml#ch11fig22">Figure 11-22</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f248-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig22"/><em>Figure 11-22: This traffic happens very quickly and can be considered normal.</em></p>&#13;
<p class="indent">This communication sequence is quite quick, with the entire process taking less than 0.1 seconds.</p>&#13;
<p class="indent">The next few capture files we’ll examine will consist of this same traffic pattern but with differences in the timing of the packets.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec7"/><strong><em>Slow Communications: Wire Latency</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>latency2.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Now let’s turn to the capture file <em>latency2.pcapng</em>. Notice that all of the packets are the same except for the time values in two of them, as shown in <a href="ch11.xhtml#ch11fig23">Figure 11-23</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_249"/><img alt="image" src="../images/f249-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig23"/><em>Figure 11-23: Packets 2 and 5 show high latency.</em></p>&#13;
<p class="indent">As we begin stepping through these six packets, we encounter our first sign of latency immediately. The initial SYN packet is sent by the client (172.16.16.128) to begin the TCP handshake, and a delay of 0.87 seconds is seen before the return SYN/ACK is received from the server (74.125.95.104). This is our first indicator that we are experiencing wire latency, which is caused by a device between the client and server.</p>&#13;
<p class="indent">We can make the determination that this is wire latency because of the nature of the types of packets being transmitted. When the server receives a SYN packet, a very minimal amount of processing is required to send a reply, because the workload doesn’t involve any processing above the transport layer. Even when a server is experiencing a very heavy traffic load, it will typically respond quickly to a SYN packet with a SYN/ACK. This eliminates the server as the potential cause of the high latency.</p>&#13;
<p class="indent">The client is also eliminated because, at this point, it is not doing any processing beyond simply receiving the SYN/ACK packet. Elimination of both the client and server points us to potential sources of slow communication within the first two packets of this capture.</p>&#13;
<p class="indent">Continuing, we see that the transmission of the ACK packet that completes the three-way handshake occurs quickly, as does the HTTP <span class="literal">GET</span> request sent by the client. All of the processing that generates these two packets occurs locally on the client following receipt of the SYN/ACK, so these two packets are expected to be transmitted quickly, as long as the client is not under a heavy processing load.</p>&#13;
<p class="indent">At packet 5, we see another packet with an incredibly high time value. It appears that after our initial HTTP <span class="literal">GET</span> request was sent, the ACK packet returned from the server took 1.15 seconds to be received. Upon receipt of the HTTP <span class="literal">GET</span> request, the server sent a TCP ACK before it began sending data, which once again requires very little processing by the server. This is another sign of wire latency.</p>&#13;
<p class="indent">Whenever you experience wire latency, you will almost always see it exhibited in both the SYN/ACK during the initial handshake and in other ACK packets throughout the communication. Although this information doesn’t tell you the exact source of the high latency on this network, it does tell you that neither client nor server is the source, so you know that the latency is due to some device in between. At this point, you could begin examining the various firewalls, routers, and proxies to locate the culprit.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec8"/><strong><em>Slow Communications: Client Latency</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>latency3.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The next latency scenario we’ll examine is contained in <em>latency3.pcapng</em>, as shown in <a href="ch11.xhtml#ch11fig24">Figure 11-24</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_250"/><img alt="image" src="../images/f250-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig24"/><em>Figure 11-24: The slow packet in this capture is the initial HTTP <span class="literal">GET</span>.</em></p>&#13;
<p class="indent">This capture begins normally, with the TCP handshake occurring very quickly and without any signs of latency. Everything appears to be fine until packet 4, which is an HTTP <span class="literal">GET</span> request after the handshake has completed. This packet shows a 1.34-second delay from the previously received packet.</p>&#13;
<p class="indent">To determine the source of this delay, we need to examine what is occurring between packets 3 and 4. Packet 3 is the final ACK in the TCP handshake sent from the client to the server, and packet 4 is the <span class="literal">GET</span> request sent from the client to the server. The common thread here is that these are both packets sent by the client and are independent of the server. The <span class="literal">GET</span> request should occur quickly after the ACK is sent, since all of these actions are centered on the client.</p>&#13;
<p class="indent">Unfortunately for the end user, the transition from ACK to <span class="literal">GET</span> doesn’t happen quickly. The creation and transmission of the <span class="literal">GET</span> packet requires processing up to the application layer, and the delay in this processing indicates that the client was unable to perform the action in a timely manner. Thus, the client is ultimately responsible for the high latency in the communication.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec9"/><strong><em>Slow Communications: Server Latency</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>latency4.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The last latency scenario we’ll examine uses the file <em>latency4.pcapng</em>, as shown in <a href="ch11.xhtml#ch11fig25">Figure 11-25</a>. This is an example of server latency.</p>&#13;
<div class="image"><img alt="image" src="../images/f250-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig25"/><em>Figure 11-25: High latency isn’t exhibited until the last packet of this capture.</em></p>&#13;
<p class="indent">In this capture, the TCP handshake process between these two hosts completes flawlessly and quickly, so things begin well. The next couple of packets bring more good news, as the initial <span class="literal">GET</span> request and response ACK packets are delivered quickly as well. It is not until the last packet in this file that we see signs of high latency.</p>&#13;
<p class="indent">This sixth packet is the first HTTP data packet sent from the server in response to the <span class="literal">GET</span> request sent by the client, and it has a slow arrival time of 0.98 seconds after the server sends its TCP ACK for the <span class="literal">GET</span> request. The transition between packets 5 and 6 is very similar to the transition we saw in the previous scenario between the handshake ACK and <span class="literal">GET</span> request. However, in this case, the server is the focus of our concern.</p>&#13;
<p class="indent">Packet 5 is the ACK that the server sends in response to the <span class="literal">GET</span> request from the client. As soon as that packet has been sent, the server should begin <span epub:type="pagebreak" id="page_251"/>sending data almost immediately. The accessing, packaging, and transmitting of the data in this packet is done by the HTTP protocol, and because this is an application-layer protocol, a bit of processing is required by the server. The delay in receipt of this packet indicates that the server was unable to process this data in a reasonable amount of time, ultimately pointing to it as the source of latency in this capture file.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec10"/><strong><em>Latency Locating Framework</em></strong></h4>&#13;
<p class="noindent">Using six packets, we’ve managed to locate the source of high network latency between the client and the server in several scenarios. The diagram in <a href="ch11.xhtml#ch11fig26">Figure 11-26</a> should help you troubleshoot your own latency issues. These principles can be applied to almost any TCP-based communication.</p>&#13;
<div class="image"><img alt="image" src="../images/f251-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch11fig26"/><em>Figure 11-26: This diagram can be used to troubleshoot your own latency issues.</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Notice that we have not talked a lot about UDP latency. Because UDP is designed to be quick but unreliable, it doesn’t have any built-in features to detect and recover from latency. Instead, it relies on the application-layer protocols (and ICMP) that it’s paired with to handle data delivery reliability.</em></p>&#13;
</div>&#13;
<h3 class="h3"><a id="ch11lev1sec5"/><strong>Network Baselining</strong></h3>&#13;
<p class="noindent">When all else fails, your <em>network baseline</em> can be one of the most crucial pieces of data you have when troubleshooting slowness on the network. <span epub:type="pagebreak" id="page_252"/>For our purposes, a network baseline consists of a sample of traffic from various points on the network that includes a large chunk of what we would consider “normal” network traffic. The goal of having a network baseline is for it to serve as a basis of comparison when the network or devices on it are misbehaving.</p>&#13;
<p class="indent">For example, consider a scenario in which several clients on the network complain of slowness when logging in to a local web application server. If you were to capture this traffic and compare it to a network baseline, you might find that the web server is responding normally but that the external DNS requests resulting from external content embedded in the web application are running twice as slowly as normal.</p>&#13;
<p class="indent">You might have noticed the slow external DNS server without the aid of a network baseline, but when you are dealing with subtle changes, that may not be the case. Ten DNS queries taking 0.1 seconds longer than normal to process are just as bad as one DNS query taking 1 full second longer than normal, but the former situation is much harder to detect without a network baseline.</p>&#13;
<p class="indent">Because no two networks are alike, the components of a network baseline can vary drastically. The following sections provide examples of the components of a network baseline. You may find that all of these items apply to your network infrastructure or that very few of them do. Regardless, you should be able to place each component of your baseline inside one of three basic baseline categories: site, host, and application.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec11"/><strong><em>Site Baseline</em></strong></h4>&#13;
<p class="noindent">The purpose of the site baseline is to gain an overall snapshot of the traffic at each physical site on your network. Ideally, this would be every segment of the WAN.</p>&#13;
<p class="indenta">Components of this baseline might include the following:</p>&#13;
<p class="noindent"><strong>Protocols in Use</strong></p>&#13;
<p class="noindentl">To see traffic from all devices, use the Protocol Hierarchy Statistics window (<strong>Statistics</strong>   ▶ <strong>Protocol Hierarchy</strong>) while capturing traffic from all the devices on the network segment at the network edge (router/firewall). Later, you can compare against the hierarchy output to find out whether normally present protocols are missing or new protocols have introduced themselves on the network. You can also use this output to find above ordinary amounts of certain types of traffic based on protocol.</p>&#13;
<p class="noindent"><strong>Broadcast Traffic</strong></p>&#13;
<p class="noindentl">This includes all broadcast traffic on the network segment. Sniffing at any point within the site should let you capture all of the broadcast traffic, allowing you to know who or what normally sends a lot of broadcast out on the network. Then you can quickly determine whether you have too much (or not enough) broadcasting going on.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_253"/><strong>Authentication Sequences</strong></p>&#13;
<p class="noindentl">These include traffic from authentication processes on random clients to all services, such as Active Directory, web applications, and organization-specific software. Authentication is one area in which services are commonly slow. The baseline allows you to determine whether authentication is to blame for slow communications.</p>&#13;
<p class="noindent"><strong>Data Transfer Rate</strong></p>&#13;
<p class="noindentl">This usually consists of a measure of a large data transfer from the site to various other sites in the network. You can use the capture summary and graphing features of Wireshark (demonstrated in <a href="ch05.xhtml#ch05">Chapter 5</a>) to determine the transfer rate and consistency of the connection. This is probably the most important site baseline you can have. Whenever any connection entering or leaving the network segment seems slow, you can perform the same data transfer as in your baseline and compare the results. This will tell you whether the connection is actually slow and will possibly even help you find the area in which the slowness begins.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec12"/><strong><em>Host Baseline</em></strong></h4>&#13;
<p class="noindent">You probably don’t need to baseline every single host within your network. The host baseline should be performed on only high-traffic or mission-critical servers. Basically, if a slow server will result in angry phone calls from management, you should have a baseline of that host.</p>&#13;
<p class="indenta">Components of the host baseline include the following:</p>&#13;
<p class="noindent"><strong>Protocols in Use</strong></p>&#13;
<p class="noindentl">This baseline provides a good opportunity to use the Protocol Hierarchy Statistics window while capturing traffic from the host. Later, you can compare against this baseline to find out whether normally present protocols are missing or new protocols have introduced themselves on the host. You can also use this to find unusually large amounts of certain types of traffic based on protocol.</p>&#13;
<p class="noindent"><strong>Idle/Busy Traffic</strong></p>&#13;
<p class="noindentl">This baseline simply consists of general captures of normal operating traffic during peak and off-peak times. Knowing the number of connections and amount of bandwidth used by those connections at different times of the day will allow you to determine whether slowness is a result of user load or another issue.</p>&#13;
<p class="noindent"><strong>Startup/Shutdown</strong></p>&#13;
<p class="noindentl">To obtain this baseline, you’ll need to create a capture of the traffic generated during the startup and shutdown sequences of the host. If the computer refuses to boot, refuses to shut down, or is abnormally slow during either sequence, you can use this baseline to determine whether the cause is network related.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_254"/><strong>Authentication Sequences</strong></p>&#13;
<p class="noindentl">Getting this baseline requires capturing traffic from authentication processes to all services on the host. Authentication is one area in which services are commonly slow. The baseline allows you to determine whether authentication is to blame for slow communications.</p>&#13;
<p class="noindent"><strong>Associations/Dependencies</strong></p>&#13;
<p class="noindentl">This baseline consists of a longer-duration capture to determine what other hosts this host is dependent upon (and are dependent upon this host). You can use the Conversations window (<strong>Statistics</strong>   ▶ <strong>Conversations</strong>) to see these associations and dependencies. An example is a SQL Server host on which a web server depends. We are not always aware of the underlying dependencies between hosts, so the host baseline can be used to determine these. From there, you can determine whether a host is not functioning properly due to a malfunctioning or high-latency dependency.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec13"/><strong><em>Application Baseline</em></strong></h4>&#13;
<p class="noindent">The final network baseline category is the application baseline. This baseline should be performed on all business-critical network-based applications.</p>&#13;
<p class="indenta">The following are the components of the application baseline:</p>&#13;
<p class="noindent"><strong>Protocols in Use</strong></p>&#13;
<p class="noindentl">Again, for this baseline, use the Protocol Hierarchy Statistics window in Wireshark, this time while capturing traffic from the host running the application. Later, you can compare against this list to find out whether protocols that the application depends on are functioning incorrectly or not at all.</p>&#13;
<p class="noindent"><strong>Startup/Shutdown</strong></p>&#13;
<p class="noindentl">This baseline includes a capture of the traffic generated during the startup and shutdown sequences of the application. If the application refuses to start or is abnormally slow during either sequence, you can use this baseline to determine the cause.</p>&#13;
<p class="noindent"><strong>Associations/Dependencies</strong></p>&#13;
<p class="noindentl">This baseline requires a longer-duration capture in which the Conversations window can be used to determine on which other hosts and applications this application depends. We are not always aware of the underlying dependencies between applications, so this baseline can be used to determine those. From there, you can determine whether an application is not functioning properly due to a malfunctioning or high-latency dependency.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_255"/><strong>Data Transfer Rate</strong></p>&#13;
<p class="noindentl">You can use the capture summary and graphing features of Wireshark to determine the transfer rate and consistency of the connections to the application server during its normal operation. Whenever the application is reported as being slow, you can use this baseline to determine whether the issues being experienced are a result of high utilization or high user load.</p>&#13;
<h4 class="h4"><a id="ch11lev2sec14"/><strong><em>Additional Notes on Baselines</em></strong></h4>&#13;
<p class="noindenta">Here are a few more points to keep in mind when creating your network baseline:</p>&#13;
<p class="bullet">•     When creating your baselines, capture each one at least three times: once during a low-traffic time (early morning), once during a high-traffic time (midafternoon), and once during a no-traffic time (late night).</p>&#13;
<p class="bullet">•     When possible, avoid capturing directly from the hosts you are baselining. During periods of high traffic, doing so may put an increased load on the device, hurt its performance, and cause your baseline to be invalid due to dropped packets.</p>&#13;
<p class="bullet">•     Your baseline will contain some very intimate information about your network, so be sure to secure it. Store it in a safe place where only the appropriate individuals have access. But at the same time, keep it readily accessible so you can use it when needed. Consider keeping it on a USB flash drive or on an encrypted partition.</p>&#13;
<p class="bullet">•     Keep all <em>.pcap</em>   and <em>.pcapng</em> files associated with your baseline and create a cheat sheet of the more commonly referenced values, such as associations or average data transfer rates.</p>&#13;
<h3 class="h3"><a id="ch11lev1sec6"/><strong>Final Thoughts</strong></h3>&#13;
<p class="noindent">This chapter has focused on troubleshooting slow networks. We’ve covered some of the more useful reliability detection and recovery features of TCP, demonstrated how to locate the source of high latency in network communications, and discussed the importance of a network baseline and some of its components. Using the techniques discussed here, along with some of Wireshark’s graphing and analysis features, you should be well equipped to troubleshoot when you get that call complaining that the network is slow.<span epub:type="pagebreak" id="page_256"/></p>&#13;
</body></html>