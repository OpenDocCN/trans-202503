["```\n#include <syslog.h>\n\nint `becomeDaemon`(int *flags*);\n```", "```\n`daemons/become_daemon.h`\n#ifndef BECOME_DAEMON_H             /* Prevent double inclusion */\n#define BECOME_DAEMON_H\n\n/* Bit-mask values for 'flags' argument of becomeDaemon() */\n\n#define BD_NO_CHDIR           01    /* Don't chdir(\"/\") */\n#define BD_NO_CLOSE_FILES     02    /* Don't close all open files */\n#define BD_NO_REOPEN_STD_FDS  04    /* Don't reopen stdin, stdout, and\n                                      stderr to /dev/null */\n#define BD_NO_UMASK0         010    /* Don't do a umask(0) */\n\n#define BD_MAX_CLOSE  8192          /* Maximum file descriptors to close if\n                                       sysconf(_SC_OPEN_MAX) is indeterminate */\n\nint becomeDaemon(int flags);\n\n#endif\n      `daemons/become_daemon.h`\n```", "```\n`daemons/become_daemon.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"become_daemon.h\"\n#include \"tlpi_hdr.h\"\n\nint                             /* Returns 0 on success, -1 on error */\nbecomeDaemon(int flags)\n{\n    int maxfd, fd;\n\n    switch (fork()) {                   /* Become background process */\n    case -1: return -1;\n    case 0:  break;                     /* Child falls through... */\n    default: _exit(EXIT_SUCCESS);       /* while parent terminates */\n    }\n\n    if (setsid() == -1)                 /* Become leader of new session */\n        return -1;\n\n    switch (fork()) {                   /* Ensure we are not session leader */\n    case -1: return -1;\n    case 0:  break;\n    default: _exit(EXIT_SUCCESS);\n    }\n\n    if (!(flags & BD_NO_UMASK0))\n        umask(0);                       /* Clear file mode creation mask */\n\n    if (!(flags & BD_NO_CHDIR))\n        chdir(\"/\");                     /* Change to root directory */\n\n    if (!(flags & BD_NO_CLOSE_FILES)) { /* Close all open files */\n        maxfd = sysconf(_SC_OPEN_MAX);\n        if (maxfd == -1)                /* Limit is indeterminate... */\n            maxfd = BD_MAX_CLOSE;       /* so take a guess */\n\n        for (fd = 0; fd < maxfd; fd++)\n            close(fd);\n    }\n\n    if (!(flags & BD_NO_REOPEN_STD_FDS)) {\n        close(STDIN_FILENO);            /* Reopen standard fd's to /dev/null */\n\n        fd = open(\"/dev/null\", O_RDWR);\n\n        if (fd != STDIN_FILENO)         /* 'fd' should be 0 */\n            return -1;\n        if (dup2(STDIN_FILENO, STDOUT_FILENO) != STDOUT_FILENO)\n            return -1;\n        if (dup2(STDIN_FILENO, STDERR_FILENO) != STDERR_FILENO)\n            return -1;\n    }\n\n    return 0;\n}\n      `daemons/become_daemon.c`\n```", "```\n$ `./test_become_daemon`\n$ `ps -C test_become_daemon -o \"pid ppid pgid sid tty command\"`\n  PID  PPID  PGID   SID TT       COMMAND\n24731     1 24730 24730 ?        ./test_become_daemon\n```", "```\n$ `echo START > /tmp/ds.conf`\n$ `./daemon_SIGHUP`\n$ `cat /tmp/ds.log`                                     *View log file*\n2011-01-17 11:18:34: Opened log file\n2011-01-17 11:18:34: Read config file: START\n```", "```\n$ `echo CHANGED > /tmp/ds.conf`\n$ `date +'%F %X'; mv /tmp/ds.log /tmp/old_ds.log`\n2011-01-17 11:19:03 AM\n$ `date +'%F %X'; killall -HUP daemon_SIGHUP`\n2011-01-17 11:19:23 AM\n$ `ls /tmp/*ds.log`                                     *Log file was reopened*\n/tmp/ds.log  /tmp/old_ds.log\n$ `cat /tmp/old_ds.log`                                 *View old log file*\n2011-01-17 11:18:34: Opened log file\n2011-01-17 11:18:34: Read config file: START\n2011-01-17 11:18:49: Main: 1\n2011-01-17 11:19:04: Main: 2\n2011-01-17 11:19:19: Main: 3\n2011-01-17 11:19:23: Closing log file\n```", "```\n$ `cat /tmp/ds.log`\n2011-01-17 11:19:23: Opened log file\n2011-01-17 11:19:23: Read config file: CHANGED\n2011-01-17 11:19:34: Main: 4\n$ `killall daemon_SIGHUP`                               *Kill our daemon*\n```", "```\n`daemons/daemon_SIGHUP.c`\n    #include <sys/stat.h>\n    #include <signal.h>\n    #include \"become_daemon.h\"\n    #include \"tlpi_hdr.h\"\n\n    static const char *LOG_FILE = \"/tmp/ds.log\";\n    static const char *CONFIG_FILE = \"/tmp/ds.conf\";\n\n    /* Definitions of logMessage(), logOpen(), logClose(), and\n       readConfigFile() are omitted from this listing */\n\n    static volatile sig_atomic_t hupReceived = 0;\n                                        /* Set nonzero on receipt of SIGHUP */\n     from\n    static void\n    sighupHandler(int sig)\n    {\n    hupReceived = 1;\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        const int SLEEP_TIME = 15;      /* Time to sleep between messages */\n        int count = 0;                  /* Number of completed SLEEP_TIME intervals */\n        int unslept;                    /* Time remaining in sleep interval */\n        struct sigaction sa;\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = SA_RESTART;\n        sa.sa_handler = sighupHandler;\n    if (sigaction(SIGHUP, &sa, NULL) == -1)\n                   errExit(\"sigaction\");\n    if (becomeDaemon(0) == -1)\n            errExit(\"becomeDaemon\");\n\n    logOpen(LOG_FILE);\n    readConfigFile(CONFIG_FILE);\n\n        unslept = SLEEP_TIME;\n\n        for (;;) {\n        unslept = sleep(unslept);       /* Returns > 0 if interrupted */\n        if (hupReceived) {              /* If we got SIGHUP... */\n                logClose();\n                    logOpen(LOG_FILE);\n                readConfigFile(CONFIG_FILE);\n                hupReceived = 0;            /* Get ready for next SIGHUP */\n            }\n\n            if (unslept == 0) {             /* On completed interval */\n                count++;\n            logMessage(\"Main: %d\", count);\n                unslept = SLEEP_TIME;       /* Reset interval */\n            }\n        }\n    }\n          `daemons/daemon_SIGHUP.c`\n```", "```\n#include <syslog.h>\n\nvoid `openlog`(const char **ident*, int *log_options*, int *facility*);\n```", "```\n#include <syslog.h>\n\nvoid `syslog`(int *priority*, const char **format*, ...);\n```", "```\nopenlog(argv[0], LOG_PID | LOG_CONS | LOG_NOWAIT, LOG_LOCALO);\nsyslog(LOG_ERR, \"Bad argument: %s\", argv[1]);\nsyslog(LOG_USER | LOG_INFO, \"Exiting\");\n```", "```\nsyslog(priority, user_supplied_string);\n```", "```\nsyslog(priority, \"%s\", user_supplied_string);\n```", "```\n#include <syslog.h>\n\nvoid `closelog`(void);\n```", "```\n#include <syslog.h>\n\nint `setlogmask`(int *mask_priority*);\n```", "```\nsetlogmask(LOG_MASK(LOG_EMERG) | LOG_MASK(LOG_ALERT) |\n           LOG_MASK(LOG_CRIT) | LOG_MASK(LOG_ERR));\n```", "```\nsetlogmask(LOG_UPTO(LOG_ERR));\n```", "```\n*facility.level       action*\n```", "```\n*.err                           /dev/tty10\nauth.notice                     root\n*.debug;mail.none;news.none     -/var/log/messages\n```", "```\n$ `killall -HUP syslogd`                  *Send* SIGHUP *to syslogd*\n```"]