- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 10 PERSISTENCE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By gaining *persistence* on compromised networks and machines, we can make our
    access immune to environmental changes such as system reboots, a loss of network
    connectivity, or even credential rotation.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to gain persistence. For example, you could plant code on
    a compromised server that reestablishes your access. Or you could discover virtual
    private network credentials in a configuration file on GitHub that someone accidentally
    pushed to a public repository to connect remotely to a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bash is a useful tool for gaining persistence, and in this chapter, we’ll use
    it in several persistence techniques: modifying the scripts used to start system
    services and interact with authentication modules, harvesting credentials by hooking
    executed commands, packaging and distributing malicious scripts, hijacking system
    utilities, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: The Enemies of Persistent Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many factors could interfere with an attacker’s ability to establish persistent
    access, some of which may not necessarily be under their direct control. Here
    are a few environment types and security practices that could become a hurdle
    and hamper persistence of access:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ephemeral environments**'
  prefs: []
  type: TYPE_NORMAL
- en: Short-lived environments, such as those running containers, may make persistence
    challenging. Container orchestration platforms and system administrators might
    spin containers up and down frequently. For example, a system experiencing a decreased
    system load on a slow weekend may automatically scale down the number of running
    containers. If we had access to one of those containers, we’d be at risk of losing
    access.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mature security practices**'
  prefs: []
  type: TYPE_NORMAL
- en: An organization that implements mature security practices can be a harder target
    both to compromise and maintain one’s access to. Some organizations review their
    systems every day for anomalies, harden their infrastructure, scan their environment
    for possible intrusion attempts, and perform threat hunting. In addition, many
    organizations have dedicated red teams to test the effectiveness of the controls.
    These security measures can make it harder to maintain long-term access.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network and endpoint security controls**'
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuned network and endpoint security controls implemented across an organization
    can make persisting access more difficult. A mature blue team will plan a defense-in-depth
    network strategy to compensate for any control failures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Asset life-cycle management and inventory hygiene**'
  prefs: []
  type: TYPE_NORMAL
- en: While it doesn’t happen often, asset decommissioning can trigger the loss of
    persistent access. Similarly, solid patch management could introduce fixes to
    the vulnerable software used as part of an exploitation kit. Ideally, you should
    find *grip points*, additional assets to persist your access to, so you don’t
    rely on a single vector for your remote access.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Service Configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to maintain access to a system is to create or modify the script used
    to start a system service. To achieve this, you could exploit System V and systemd,
    system mechanisms that manage services and control the start sequence of processes.
    System V is the older of the two mechanisms, but you may encounter either tool
    in a penetration test. Let’s learn about both mechanisms in the context of persistence.
  prefs: []
  type: TYPE_NORMAL
- en: System V
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System V’s */etc/init.d* directory contains shell scripts, called *init scripts*,
    responsible for starting services, whether they’re network services such as SSH,
    scheduling services such as Cron, or services responsible for setting up a server’s
    hardware clock. But we can also write custom malicious logic by using init scripts.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Introducing custom code into shell scripts under the* /etc *directory usually
    requires elevated privileges. This technique assumes you have write permissions
    to the target directory.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the ls command to list the files in */etc/init.d* on any of the machines
    in the lab. Here is the output on *p-jumpbox-01* (172.16.10.13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each file in the directory affects the configuration of a particular service.
    For example, take a look at the *ssh* script ([Listing 10-1](chapter10.xhtml#Lis10-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: The init script for the SSH service'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the core of this script uses a case statement to determine
    which set of commands to run, given some input. For example, to start, stop, and
    reload the SSH service, we could call the script in each of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The system is configured to start SSH on boot, and if we can place custom bash
    logic in the script, our code will run whenever the script is called. So, if we’re
    able to create a reverse shell from the init script, we can reconnect the server
    to our listener in the case of a full reboot, as long as the network is available.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s give this a try. Modify the */etc/init.d/ssh* file by inserting a reverse
    shell payload into it, as shown in [Listing 10-2](chapter10.xhtml#Lis10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: A reverse shell payload injected into /etc/init.d/ssh'
  prefs: []
  type: TYPE_NORMAL
- en: Next, start a listener to receive the reverse shell on Kali. You can use pwncat,
    Ncat, Netcat, or any other listener you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, switch back to the target system and run the service command to start
    the SSH server daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should see the reverse shell connecting to the listener.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you introduce obviously malicious commands such as reverse shell
    payloads, you should make these as invisible as possible. For example, try splitting
    the listener’s remote IP address into a bunch of variables so it blends with the
    rest of the script and doesn’t stand out to anyone who happens to be reading it.
  prefs: []
  type: TYPE_NORMAL
- en: systemd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: systemd manages *units*, which can represent services, devices, and other types
    of components. To achieve persistence, we could try to use systemd as a way to
    register a new service unit on the system. [Listing 10-3](chapter10.xhtml#Lis10-3)
    shows an example of a systemd service with a reverse shell payload.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: An example malicious systemd service definition file'
  prefs: []
  type: TYPE_NORMAL
- en: 'This service defines the following properties: a new unit ❶, a requirement
    for networking to be available ❷, an instruction to execute the reverse shell
    to the attacker’s machine on service start ❸, and a requirement to restart the
    process if it dies ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: The containers in the lab don’t run systemd, but if you’d like to experiment
    with this technique, you could use these commands on your Kali machine. To use
    the script, create a new service file at */etc/system/service/revshell.service*.
    (The name of the file is also the name of the service. In a real attack, you should
    probably use a sneakier name so it blends nicely with the environment.) Then enable
    the service by executing systemctl enable revshell.
  prefs: []
  type: TYPE_NORMAL
- en: Run the malicious service by using systemctl start revshell. Now, if the machine
    ever reboots, this service file should reestablish a connection on boot.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into Pluggable Authentication Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Pluggable authentication modules (PAMs)* provide high-level APIs for low-level
    authentication schemes, and applications can use them to authenticate users. For
    example, you could adopt an external multifactor authentication provider to prompt
    users to enter a code or insert a hardware security token during login, in addition
    to using a traditional password. PAM configuration files live in the */etc/pam.d*
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of establishing persistence, PAM has an interesting capability: it
    can call external scripts at certain points during an authentication flow by using
    the *pam_exec.so* library. By modifying specific configurations, we could make
    PAM call our own script whenever a user logs in to a system, then take any action
    we’d like.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, under */etc/pam.d*, you will find a file named *common-session*.
    This file includes session-related modules that are common to all services. Modify
    this file by appending the following line to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of this line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The type is session, the control is optional, the module path is *pam_exec.so*,
    and the module arguments are seteuid and /usr/local/bin/pam-helper.sh. The session
    type refers to the actions taken before or after a user is given access to a service,
    commonly used for actions such as logging. The optional control means that no
    matter whether this module succeeds or not, it won’t impact the authentication
    or login flow. The module path *pam_exec.so* is the library we will use to call
    external programs, followed by the module arguments seteuid (set effective UID)
    and the full path to the script.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve saved the PAM configuration file, *pam_exec.so* will call your script
    whenever someone logs in to or out of the system (for example, by running su -
    backup and providing the password). We’ll provide guidance on writing a suitable
    persistence script in Exercise 19.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 19: Coding a Malicious pam_exec Bash Script'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section explained how to modify a system’s PAM configuration to
    call an external script, *pam-helper.sh*. This script will run whenever a user
    logs in to or out of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Build the script’s logic to take malicious actions of your choice. For example,
    you could use Cron to schedule a persistent task or use At to schedule a one-time
    task that establishes a reverse shell to a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save your script into */usr/local/pam-helper.sh* with executable
    permissions. You can test this exercise on *p-jumpbox-01* (172.16.10.13) since
    you already have root access to it. Don’t forget to set up the reverse shell listener
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Rogue SSH Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Users with SSH access to a server can use their cryptographic keys instead of
    their passwords to log in. When we generate an SSH key pair, we must append the
    public key to a file named *authorized_keys* under the user’s home directory.
    Any public key in this file is authorized to authenticate to the system but only
    when using the account for which the key exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because more than one key could be authorized to authenticate, using a rogue
    SSH key to create a backdoor to an account is as easy as adding another public
    key to this file. For example, an *authorized_keys* file for a *nostarch* user
    might look like the following, assuming their home directory is */home/nostarch*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a new SSH key, run this command on your Kali machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We use -t (type) to define the type of key (in this case, RSA) and -C (comment)
    with an empty value. If you don’t supply the -C flag with an empty value, ssh-keygen
    will append the computer’s hostname to the end of the key as a comment, which
    is a way to identify the machine that the key belongs to. Follow the wizard, making
    sure not to set a passphrase for the purposes of this example. Two files should
    be created: *id_rsa* (the private key) and *id_rsa.pub* (the public key).'
  prefs: []
  type: TYPE_NORMAL
- en: You can add the public key to *authorized_keys* in multiple ways. Try performing
    these steps on the *p-jumpbox-01* machine (172.16.10.13) while logged in as the
    backup user.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can simply create or modify *~/.ssh/authorized_keys* by using a
    text editor and pasting the public key’s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To add the key remotely, you could use an SSH client to authenticate and run
    a command. Note that this will require you to provide the password of the account
    you’ve managed to compromise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The ssh-copy-id command makes it slightly easier to copy the public key to
    the server. It should automatically write it to the correct location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When prompted, enter the password for the backup user.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the key, try using the private RSA key to log in to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should notice that you’re not prompted to enter the user’s account password.
    If you had provided a passphrase during key creation, you’d be required to provide
    this passphrase when using the key for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Repurposing Default System Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, systems come with built-in accounts other than root, such as nobody,
    sys, sync, bin, games, and man. We call these accounts *service accounts*, as
    they’re used for running specific tasks. Separating these tasks into different
    accounts enforces a least-privilege model, as it enables the system to run applications
    under particular user contexts.
  prefs: []
  type: TYPE_NORMAL
- en: These accounts aren’t meant for users to log in to, and if you look closely
    at */etc/passwd* on any of the lab machines (or even on Kali), you’ll see they
    usually have no shell or password set. These common hardening practices ensure
    that they can’t perform system tasks such as job scheduling if compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you’ve compromised a machine and gained access to a root account (or
    a sudo user with the ability to create or modify users), you could take measures
    such as the following to craft a backdoor mechanism that blends into the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new account that looks similar to a service account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying an existing service account by adding a shell and password to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s convert a service account into a backdoor account that grants us ongoing
    access to the system. We’ll target the *p-jumpbox-01* machine (172.16.10.13),
    where we have root access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll backdoor the lp account, which is usually used for managing spooling
    services. You can see this account and its default shell in */etc/passwd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the account has the */usr/sbin/nologin* shell; this won’t allow
    us to log in. Let’s modify the default shell by using usermod and passing it the
    -s (shell) argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We recommend learning more about the usermod command by running man usermod.
    Next, set a password with the passwd command and enter a password when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, check that you can SSH into the server by using the lp account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to remotely connect to the machine by using this service
    account, which should now have a valid shell. You can use this as a backdoor account
    if you lose root access in the future, or if the root account is disabled for
    remote logins.
  prefs: []
  type: TYPE_NORMAL
- en: Poisoning Bash Environment Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](chapter2.xhtml), we discussed files such as *~/.bashrc*, which
    let us define variables, aliases, and scripts to customize the environment. In
    addition to these files, which live in a user’s home directory, there are system-wide
    *.bashrc* and *.profile* files, located at */etc/bash.bashrc* or */etc/bashrc*
    and */etc/profile*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: When bash is invoked as an interactive login shell, it will read from */etc/profile*
    (if it exists) before reading user-level environment files such as *~/.bash_profile*,
    *~/bash_login*, and *~/.profile*. Similarly, when bash is invoked as a nonlogin
    interactive shell, it reads the global *bashrc* file before the local one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, */etc/profile* will look for files under the */etc/profile.d* directory.
    If files exist, it will use the . command to source (or import) them. You can
    see this behavior by running cat /etc/profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an if condition ❶ checks whether */etc/profile.d* is a directory.
    Next, a for loop iterates on all files with a *.sh* extension under */etc/profile.d*
    ❷ and checks each file for read access by using -r ❸. Finally, the script imports
    the file by using the . command ❹.
  prefs: []
  type: TYPE_NORMAL
- en: If we can write malicious code to files such as */etc/profile* or into a directory
    such as */etc/profile.d*, we could invoke shells running custom code under our
    control. If you’ve compromised a specific user account, you might also try planting
    malicious code in that user’s shell environment file, which may lead to interesting
    results and doesn’t require root access. However, the impact will be user specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try tampering with a user’s profile by introducing custom code that will
    run immediately after a user executes a command. Log in to *p-jumpbox-01* (172.16.10.13)
    as the backup user and create a *.profile* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, write the script in [Listing 10-4](chapter10.xhtml#Lis10-4) into the file
    and save it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: Hooking an operating system command'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a function called hook ❶. This function does only one thing,
    which is print You executed ${BASH_COMMAND} to standard output, where ${BASH_COMMAND}
    is an environment variable that holds the name of the command about to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At ❷, we use the trap command followed by the function name (hook()) and the
    word DEBUG, which is a type of *signal spec (sigspec)* that the trap accepts.
    A sigspec can be any of these values: EXIT, DEBUG, RETURN, or ERR; DEBUG ensures
    that we trap every command executed. (In Exercise 20, we’ll put this sigspec to
    use to steal sensitive data.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here’s the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run a few commands and observe the output. In the following example, we
    run id and ps -ef:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our active hook prints the command we executed just before the
    output of that command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Intercepting Data via Profile Tampering'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you have a clear malicious goal: write a script that captures
    any command executed on the compromised system that might contain sensitive information,
    then transmit it to a remote server. If you’re unsure of which commands could
    be interesting to intercept, we have a few examples in our back pocket:'
  prefs: []
  type: TYPE_NORMAL
- en: Web requests that contain an API key parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords passed on the command line to common utilities, such as database administration
    tools like MySQL or Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PII such as emails or credit card numbers passed on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, here are a few high-level tips to get you going:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a web search for string patterns that match the sensitive data you’re interested
    in. For example, look for commands that can accept passwords or even credit card
    numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify specific commands you want to intercept; avoid intercepting every command,
    to make your data collection precise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design your script such that it fails safely. If something goes wrong while
    sending the data over the network, catch the error so the information doesn’t
    leak to the unsuspecting user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 10-5](chapter10.xhtml#Lis10-5) provides one solution, which targets
    curl or mysql commands used to transmit credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: profile_hook.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: Hooking commands and stealing credentials'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a function named hook() that uses a case statement ❶. The statement
    will try to match the BASH_COMMAND variable against two patterns: mysql* ❷ and
    curl* ❹. These patterns will match anything that starts with either of these strings.
    This should identify uses of the mysql command to connect to a database and the
    curl command to make HTTP requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, if the command involved calling the mysql client, we check whether the
    command included a password on the command line by using the -p or --password
    arguments ❸. In this case, the password would belong to the database. If we have
    a match, we send an HTTP POST request to *https://attacker.com* containing a JSON
    payload with the raw command in the request’s POST body.
  prefs: []
  type: TYPE_NORMAL
- en: At ❺, we do a similar thing with curl. We search for strings such as token,
    apikey, api_token, bearer, or authorization to catch any API keys being passed
    on the command line. These credentials might belong to an internal web panel or
    to an administration interface of some sort. The search is case insensitive (-i).
    If we find such a pattern, we send a request containing the command and the credentials
    to the attacker’s website over HTTP POST.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use trap to trap the hook() function with the DEBUG sigspec type
    ❻.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10).'
  prefs: []
  type: TYPE_NORMAL
- en: Credential Theft
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you can maintain access to a user’s credential data, or perhaps even to the
    keyboard actions taken by users, you could keep your access to the system as a
    whole. For example, if a user reset their password and we happened to intercept
    the commands used to do so, we could maintain access even if the credentials were
    rotated (at least until someone discovered and disarmed our mechanism or completely
    wiped the infected system).
  prefs: []
  type: TYPE_NORMAL
- en: We can capture credential information in a variety of ways. One way is by trojanizing
    commands, such as by replacing them with malicious binaries or otherwise tampering
    with their execution flow by injecting malicious logic into them. In this section,
    we’ll implement malicious logic in a few common system administrator utilities.
    We’ll also extract credentials from the bash history file and send these over
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking a Text Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Vim* is a common text editor application often found on servers. It’s also
    many developers’ and system administrators’ go-to text-editing application, so
    it warrants its own section.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’ve never used Vim before, we highly recommend you familiarize yourself
    with it. It’s a powerful editor with many additional capabilities, such as macros,
    scripts, and a plug-in system.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you have access to one or more users on the system and can modify configurations
    in their home directories, you can exploit Vim’s *autocmd* feature, an automation
    system able to run certain shell commands when special editor events occur. We
    define autocmd actions by using the *~/.vimrc* file, which Vim usually searches
    for in the user’s home directory. When the text editor is opened, it reads from
    this file and looks for any special configurations and instructions.
  prefs: []
  type: TYPE_NORMAL
- en: autocmd events could occur whenever a file is written or read, whenever a file
    is open or closed, and whenever the editor itself is opened or closed, among other
    cases. [Table 10-1](chapter10.xhtml#tab10-1) highlights a few key autocmd events
    of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-1: Interesting autocmd Events'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ShellCmdPost | After executing a shell command |'
  prefs: []
  type: TYPE_TB
- en: '| BufWritePost | After writing the entire buffer |'
  prefs: []
  type: TYPE_TB
- en: '| BufWipeout | Before deleting the buffer |'
  prefs: []
  type: TYPE_TB
- en: '| StdinReadPost | After reading from stdin into the buffer |'
  prefs: []
  type: TYPE_TB
- en: The BufWritePost event allows us to take an action after the editor writes whatever
    was present in the buffer. This means that if a user opened a file and performed
    a write action, autocmd would execute our commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s exploit this behavior. First, write the following content into the *~/.vimrc*
    file under a user’s home directory. You can use any of the lab’s compromised machines,
    such as *p-jumpbox-01* (172.16.10.13), using the backup or *root* user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let’s dissect what’s happening. First, we define an autocmd instruction by using
    the autocmd keyword. Next, we specify the event name BufWritePost, followed by
    two file extensions, **.conf* and **.config*. This will ensure that the command
    triggers whenever a file with the either of these extensions is written.
  prefs: []
  type: TYPE_NORMAL
- en: We use :silent to suppress any command messages or errors. Finally, we define
    a command with !, followed by the syntax of the shell command of interest. In
    this example, we’re making an HTTP POST request to 172.16.10.1:8080 by using curl,
    which will run a listener in our Kali machine. We pass -m (max time) with a value
    of 5 to ensure that the entire operation doesn’t take more than five seconds.
    We then pass the -s (silent) argument to stop text from being printed out, and
    redirect the standard output to */dev/null* by using -o /dev/null. We also pass
    --data-binary @<afile> to upload a file. The autocmd <afile> variable represents
    the actual file that Vim is editing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, when a user writes a file with a name such as *credentials.conf*,
    Vim will execute a curl command to secretly send the file to the remote listener.
    Save this file as *~/.vimrc*. Next, open a remote listener on the Kali machine
    by using any TCP listener of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, using either vi or vim.tiny commands (as vi is a symbolic link to
    vim.tiny in the lab), open a file and write content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use Vim to save the file to disk, you should notice that the content
    of the file was sent to the listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to leak all files, no matter their extension, this autocmd command
    should do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: However, if a file is particularly large, the upload could take a long time.
    This could reveal to the user that something nefarious is happening, as writing
    to the file would cause a noticeable delay. Let’s make our hook a little cleverer
    ([Listing 10-6](chapter10.xhtml#Lis10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Conditional command execution with autocmd'
  prefs: []
  type: TYPE_NORMAL
- en: Now the command will look only for files containing credentials such as passwords
    or API keys.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming Executed Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 8](chapter8.xhtml), we discussed history files, such as *~/.bash_history*.
    History files keep a record of commands executed by users and allow for an access,
    audit, and replay of previously executed commands.
  prefs: []
  type: TYPE_NORMAL
- en: History files update whenever new commands are executed, so it could be interesting
    to stream the history files over the network to a listener providing a live record
    of command-execution events to a server we control. These commands could reveal
    what users are executing on a server and capture any credentials they enter via
    the command line. (Note that *~/.bash_history* is just an example; you may find
    it useful to stream other files in your future engagements by using the method
    shown here.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set up a few bash commands to send the last written command over the network
    to a remote listener. This technique assumes you have access to a user’s home
    directory and can modify the *~/.profile* file or have the ability to write into
    the system-wide */etc/profile* file.
  prefs: []
  type: TYPE_NORMAL
- en: On *p-jumpbox-01* (172.16.10.13), using the *root* user, create a file under
    the */etc/profile.d* directory named *99-stream.sh* with the contents in [Listing
    10-7](chapter10.xhtml#Lis10-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: Streaming history files over the network'
  prefs: []
  type: TYPE_NORMAL
- en: 'At ❶, we export the PROMPT_COMMAND variable to make it available to subsequent
    commands during execution. We’ll set this variable to a bash command that will
    execute just before the shell displays the prompt in the terminal. You’ll notice
    that we pass the history command twice as its value: once with the -a (append)
    parameter and a second time with the -r (read) parameter. The PROMPT_COMMAND value
    will execute just before the prompt is shown, allowing us to append to and read
    from the history file whenever a command is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: We check whether the Netcat (nc) process is running by using pgrep ❷. We use
    -u (user) with whoami to narrow the process list to only those run by the current
    user, followed by the process name of nc. If pgrep returns an exit code of 1 (process
    not found), no reverse shell has connected from this user, so we can establish
    one. This helps us avoid opening multiple connections from the same user.
  prefs: []
  type: TYPE_NORMAL
- en: We use the tail command to read the end of the history file and pipe it to nc
    ❸. The -F (follow) argument tracks the end of the file so any new content gets
    sent across the wire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll use socat on Kali so we can receive multiple connections without
    closing the server’s end of the connection if multiple users connect and execute
    commands simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another terminal and log in to *p-jumpbox-01* (172.16.10.13) as the user
    *backup* (with the previously compromised password *backup*). Then enter a few
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the output from socat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You could adapt this technique to stream any file of value during a penetration
    test, such as application or system logfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Forging a Not-So-Innocent sudo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 9](chapter9.xhtml), we used misconfigurations of the sudo command
    to elevate our privileges. But we can compromise sudo in another way: by replacing
    it with our own malicious version, then harvesting the user’s password when they
    enter it to run the command.'
  prefs: []
  type: TYPE_NORMAL
- en: The main downside to this approach is that when a user provides a correct password
    to sudo, it caches the credentials for a period (such as 15 minutes), and subsequent
    commands won’t require reentering the password. The setting responsible for the
    caching duration is called timestamp_timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the caching, if we’re able to intercept the execution when the user
    enters their password the first time, we may be able to leak their password. Let’s
    walk through such an example. In this scenario, we assume we have access to alter
    a user’s environment and can modify files such as *~/.bashrc*.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a fake sudo script. Then we’ll modify a compromised user’s environment
    so that calling sudo will execute the fake version through the use of an alias,
    send their password over the network by using curl, and continue the normal sudo
    execution flow, to avoid raising suspicion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin! You can perform this scenario on *p-jumpbox-01* (172.16.10.13)
    by implanting the fake sudo script in the backup user account. Create this fake
    sudo file somewhere writable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an alias by adding a line to the compromised user’s *~/.bashrc*
    environment file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finally, populate the script with the code in [Listing 10-8](chapter10.xhtml#Lis10-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: A fake sudo script'
  prefs: []
  type: TYPE_NORMAL
- en: At ❷, we turn off input echoing by using stty -echo. We then read input from
    the user and present a sudo-like prompt ❸. As the input is the user’s password,
    it shouldn’t be presented in cleartext to the user while they’re typing it. This
    is because, by default, sudo hides the input while it’s being typed, and we need
    to emulate the look and feel of the original command. So, we disable input echoing
    before accepting input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we leak the provided password by using the leak_over_http() function.
    This function will use base64 to encode the password and use curl to make an HTTP
    GET request to a path on the web server, using the captured password as the path
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: At ❹, we turn on input echoing and pass the password, along with the command
    the user executed, to the real sudo binary (*/usr/bin/sudo*) so that the sudo
    execution resumes normally. [Figure 10-1](chapter10.xhtml#fig10-1) highlights
    this flow from end to end.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: A password interception flow using a fake sudo script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, on your Kali machine, use Python to run a simple HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then open another terminal to *p-jumpbox-01* (172.16.10.13) and run a sudo
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive the leaked password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The bolded base64-encoded string is *backup*, which is the password of the backup
    user.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this script at *[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch10/fake_sudo.sh)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21: Hijacking Password Utilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use an approach similar to the sudo attack we just performed to hijack
    other utilities. Any tool that interacts with credentials can help you gain persistence,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: passwd For changing local user passwords
  prefs: []
  type: TYPE_NORMAL
- en: chpasswd For updating passwords in bulk
  prefs: []
  type: TYPE_NORMAL
- en: htpasswd For setting up or changing Apache basic authentication
  prefs: []
  type: TYPE_NORMAL
- en: smbpasswd For changing Samba user passwords (such as Active Directory user passwords)
  prefs: []
  type: TYPE_NORMAL
- en: ldappasswd For changing Lightweight Directory Access Protocol user passwords
  prefs: []
  type: TYPE_NORMAL
- en: 'Try programming a fake command that accepts passwords as input. Here is guidance
    on how to go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Use man to learn about the target utility.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Attempt to use the tool, taking notes on how it prompts users for passwords,
    what type of output it produces, and how it handles errors.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Create a fake utility that can produce the same outputs and accept the same
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Retrofit the sudo script from the previous section to fit your new fake
    utility, or create a new script from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing Malicious Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux systems use package installers such as Debian (DEB) and RPM, depending
    on the distribution. These installers are interesting because they let you package
    your own files, and you may be able to backdoor a system if you can get someone
    to install a malicious package you’ve developed. In the next sections, we’ll explore
    the DEB packaging system. Then we’ll create packages that contain malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that software installation on Linux requires root privileges by default;
    a regular user cannot use commands such as dpkg -i package or rpm -i package unless
    they were specifically granted privileged access to these utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DEB Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll find DEB packages used by the Debian Linux distribution and its derivatives,
    such as Ubuntu. DEB packages are *ar* (archive) files and contain three files:
    *debian-binary*, the control archive, and the data archive.'
  prefs: []
  type: TYPE_NORMAL
- en: The *debian-binary* file is a text file containing the package’s version number,
    such as 2.0. The *control archive* is a compressed file containing scripts and
    metadata information. The *data archive* contains the files the package should
    install (for example, the software’s manual pages or additional binaries).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore an example package before building our own. Download the example
    DEB package, *example_amd64.deb*. Then run dpkg --info on the package to see information
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run strings on the package to see its contents. You should see the three
    files we discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, install the package to see what it does. You can do this on any machine
    in the lab or on Kali:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the package doesn’t do anything special other than printing
    a message to the screen. Consider this the “Hello, world!” of DEB packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the contents of a *.deb* file, use the ar command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The v flag is for verbose mode; the x flag, for extraction, accepts the filename.
    To further extract the *control.tar.xz* and *data.tar.xz* files, you can use the
    tar command with -x (extract), -v (verbose), and -f (file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: DEB packages can contain several types of scripts. The most interesting to us
    are *inst* (installation) and *rm* (remove) scripts. *Installation scripts* are
    responsible for the bootstrapping of the package. They include preinstallation
    scripts (*preinst*), called before the package is installed, and post-installation
    scripts (*postinst*), called afterward. These scripts can perform any task, but
    some common tasks are creating directories, setting permissions, and copying files.
  prefs: []
  type: TYPE_NORMAL
- en: The *rm scripts* perform some form of cleanup, such as removing files or stopping
    services. These include *prerm* scripts, which take actions such as the removal
    of symbolic links or files associated with the package before it’s finally removed,
    and *postrm* scripts, which clean up files after the package is removed. Can you
    think of ways to include malicious code in these scripts?
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Innocent Software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s practice creating packages by making our own innocent package. On your
    Kali machine, create a directory named *example*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a directory named *DEBIAN* inside the *example* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named *control* inside the *DEBIAN* directory, with the following
    package metadata, and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use dpkg -b (build) to build the package. The first argument to -b is
    the name of the directory where the files to package are located, followed by
    the name of the artifact to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can install this package by using sudo dpkg -i package and remove it by using
    sudo dpkg -r package.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Package Formats with alien
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other Linux distributions use different package formats. Luckily, we can convert
    packages from one format to another (for example, from RPM to DEB or from DEB
    to RPM) by using a tool called alien. Kali should come with alien installed, but
    if not, install it using sudo apt install alien.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example converts a DEB package to an RPM package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We use the arguments -v (verbose), -r package (where the *r* stands for *rpm
    conversion*), and --scripts to tell alien to use verbose output, convert the package
    to RPM, and include the post- and pre-scripts we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a package from RPM back to the DEB format is as easy as changing
    the -r flag to -d.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: Writing a Malicious Package Installer'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could create a malicious package installer to gain persistence on a system
    in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By compromising a central software repository, such as a local APT repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By compromising an account that has permissions to install packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By sending a malicious package as part of a phishing campaign against system
    administrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The APT repository mentioned in the first scenario is a web server that contains
    a database of DEB packages. Consumers on the network, such as servers or end users,
    can use the APT repository to download packages onto their operating system and
    install them. You’ll find such setups in networks that aren’t directly connected
    to the internet or that are designed to install software from trusted sources
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a DEB package containing malicious scripts for use in one of these
    scenarios. Specifically, we’ll use the *postinst* and *postrm* scripts to deploy
    and persist a reverse shell. Call your package *bksh*, for *backdoor shell*, and
    create a *control* file, as discussed in “Packaging Innocent Software” on [page
    253](#pg_253). Next, create *postinst* and *postrm* files in the *DEBIAN* directory
    and set their permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Your directory structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the *postinst* script with a bash script that calls the reverse shell.
    For example, the script in [Listing 10-9](chapter10.xhtml#Lis10-9) will reach
    out to the Kali machine by using the system-wide crontab file */etc/crontab*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: A reverse shell callback using /etc/crontab'
  prefs: []
  type: TYPE_NORMAL
- en: When a user first installs the package, an entry will be written into */etc/crontab*.
    That user could be the root user, or any other user that can install packages
    by using a tool such as dpkg. To ensure that we write this entry only once, we
    use grep to check whether the string 4444 exists in the file before proceeding
    with the actual modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, populate the *postrm* script with another reverse shell. This time, the
    cron job will belong to the user that executes the package removal and won’t be
    system-wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This second script provides a fallback mechanism in cases when this package
    is removed from the system.
  prefs: []
  type: TYPE_NORMAL
- en: You can develop additional fallback persistence mechanisms as an extension to
    the exercise. For example, try writing a small web shell to a file on the system
    if the system shows signs of running web server processes to common web directories,
    such as */var/www/html*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the package, build it, then start a Netcat reverse shell on your Kali
    machine. Copy the package to one of the lab machines, such as *p-jumpbox-01* (172.16.10.13),
    and install it by using the *root* user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then verify that you can see the reverse shell cron job in */etc/crontab*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: After about a minute, you should see the reverse shell connection to your Kali
    Netcat listener. To test *postrm*, remove the package from *p-jumpbox-01*, then
    check the *root* user’s crontab.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned many ways of using bash to persist your access
    in the post-compromise stage. We introduced malicious logic to PAM modules, system
    profiles, text editors, and fake utilities. We also enabled dormant accounts and
    added rogue SSH keys, then packaged malicious software using the DEB format.
  prefs: []
  type: TYPE_NORMAL
