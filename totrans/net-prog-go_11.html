<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_165" title="165"/>8</span><br/>&#13;
<span class="ChapterTitle">Writing HTTP Clients</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">The <em>HyperText Transfer Protocol</em><em>(HTTP)</em> is an application layer protocol used by the World Wide Web. In an HTTP communication, a web client sends a <em>uniform resource locator</em><em>(URL)</em> to a web server, and the web server responds with the corresponding media resources. In this context, a <em>resource</em> could be an image, a style sheet, an HTML document, a JavaScript file, and so on. For example, if your web browser sent the URL <em>www.google.com</em> to Google’s web servers, the servers would return Google’s main page. Most of us make such web transactions daily, whether they originate from our phones, computers, or Internet of Things (IoT) devices, such as doorbells, thermostats, or toasters (yes, really).</p>&#13;
<p><span epub:type="pagebreak" id="Page_166" title="166"/>This chapter will introduce you to Go’s HTTP client. First, you’ll learn the basics of HTTP, including request methods and response codes. Next, you’ll explore Go’s HTTP client to request resources from web servers, paying attention to potential pitfalls along the way. Then, you’ll move into the standard library code and learn the implementations that facilitate the request-response communication between an HTTP client and server. Finally, you’ll see common pitfalls to look for when interacting with web servers using Go’s HTTP client.</p>&#13;
<p>This chapter will give you the basics for interacting with services over HTTP. You’ll need this foundation to understand how to handle requests from the server’s point of view in the next chapter.</p>&#13;
<h2 id="h1-500884c08-0001">Understanding the Basics of HTTP</h2>&#13;
<p class="BodyFirst">HTTP is a sessionless client-server protocol in which the client initiates a request to the server and the server responds to the client. HTTP is an application layer protocol and serves as the foundation for communication over the web. It uses TCP as its underlying transport layer protocol.</p>&#13;
<p>This chapter assumes that you’re using HTTP version 1.1 (HTTP/1.1). We’ll also cover functionality introduced in HTTP version 2.0 (HTTP/2). Thankfully, Go abstracts many of the differences between these protocols, so we can easily use either protocol with the same bit of code.</p>&#13;
<h3 id="h2-500884c08-0001">Uniform Resource Locators</h3>&#13;
<p class="BodyFirst">A <em>URL</em> is an address of sorts used by the client to locate a web server and identify the requested resource. It’s composed of five parts: a required <em>scheme </em>indicating the protocol to use for the connection, an optional <em>authority</em> for the resource, the <em>path</em> to the resource, an optional <em>query</em>, and an optional <em>fragment</em>. A colon (:) followed by two forward slashes (//) separates the scheme from the authority. The authority includes an optional colon-delimited username and password suffixed with an at symbol (@), a hostname, and an optional port number preceded by a colon. The path is a series of segments preceded by a forward slash. A question mark (?) indicates the start of the query, which is conventionally composed of key-value pairs separated by an ampersand (&amp;). A hash mark (#) precedes the fragment, which is an identifier to a subsection of the resource. Taken together, a URL follows this pattern:</p>&#13;
<pre><code><var>scheme</var>://<var>user</var>:<var>password</var>@<var>host</var>:<var>port</var>/<var>path</var>?<var>key1</var>=<var>value1</var>&amp;<var>key2</var>=<var>value2</var>#<var>table_of_contents</var></code></pre>&#13;
<p>The typical URL you use over the internet includes a scheme and a hostname at minimum. For example, if you felt compelled to look up images of gophers, you could visit Google’s image search by entering the following URL in your web browser’s address bar, then searching for <em>gophers</em> in the image search tab: </p>&#13;
<pre><code><span class="CodeAnnotation">1</span>https://<span class="CodeAnnotation">2</span>images.google.com<span class="CodeAnnotation">3</span>/</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_167" title="167"/>The scheme <span class="CodeAnnotation">1</span> informs your browser that you want to use HTTPS to connect to the address <em>images.google.com</em><span class="CodeAnnotation">2</span> and that you want the default resource <span class="CodeAnnotation">3</span>. If you specify the web server address without any specific resource, the web server will respond with a default resource. Just as it’s helpful for large corporations to send your call to a receptionist when you omit an extension number, it’s helpful for web servers to serve up a default resource if you don’t specify the resource you want. Google receives your request and responds with the image search page. When you type <em>gophers</em> in the search box and submit the form, your browser sends a request using a URL like this, truncated for brevity:</p>&#13;
<pre><code>https://www.google.com/<span class="CodeAnnotation">1</span>search<span class="CodeAnnotation">2</span>?<span class="CodeAnnotation">3</span>q=gophers&amp;tbm=isch . . .</code></pre>&#13;
<p>This URL asks Google for a resource named <em>search</em><span class="CodeAnnotation">1</span> and includes a <em>query string</em>. The query string, indicated by the question mark <span class="CodeAnnotation">2</span>, contains ampersand-separated parameters defined by, and meaningful to, the web server. In this example, the value of the <code>q</code> parameter <span class="CodeAnnotation">3</span> is your search query, <code>gophers</code>. The <code>tbm</code> parameter’s value of <code>isch</code> tells Google you’re performing an image search. Google defines the parameters and their values. You pass them along to Google’s web servers as part of the request. The actual URL in your browser’s address bar is quite a bit longer and includes other details Google needs in order to satisfy your request.</p>&#13;
<p>If my wife were to send me shopping using HTTP, the URL she would give me might look like this:</p>&#13;
<pre><code>automobile://the.grocery.store/purchase?butter=irish&amp;eggs=12&amp;coffee=dark_roast</code></pre>&#13;
<p>This tells me I’m to drive my car to the grocery store and pick up Irish butter, a dozen eggs, and dark roast coffee. It’s important to mention that the scheme is relevant only to the context in which it’s used. My web browser wouldn’t know what to do with the <em>automobile</em> scheme, but for the sake of my marriage, I sure do. </p>&#13;
<h3 id="h2-500884c08-0002">Client Resource Requests</h3>&#13;
<p class="BodyFirst">An <em>HTTP request</em> is a message sent from a client to a web server that asks the server to respond with a specific resource. The request consists of a method, a target resource, headers, and a body. The <em>method</em> tells the server what you want it to do with the target resource. For example, the <code>GET</code> method followed by <em>robots.txt</em> tells the server you want it to send you the <em>robots.txt</em> file, whereas the <code>DELETE</code> method indicates to the server that you want it to delete that resource.</p>&#13;
<p><em>Request headers</em> contain metadata about the content of the request you are sending. The <code>Content-Length</code> header, for example, specifies the size of the request body in bytes. The <em>request body</em> is the payload of the request. If you upload a new profile picture to a web server, the request body will contain the image encoded in a format suitable for transport over the network, and the <code>Content-Length</code> header’s value will be set to the size in bytes of the image in the request body. Not all request methods require a request body.</p>&#13;
<p><span epub:type="pagebreak" id="Page_168" title="168"/><a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a> details a simple <code>GET</code> request for Google’s <em>robots.txt</em> file over Netcat to Google’s web server. <span class="xref" itemid="xref_target_“Testing the Service with Netcat” on page 159">“Testing the Service with Netcat” on page 159</span> walks you through installing Netcat.</p>&#13;
<pre><code>$ <b>nc www.google.com 80</b>&#13;
<span class="CodeAnnotationHang">1</span><em> </em><b>GET /robots.txt HTTP/1.1</b>&#13;
&#13;
<span class="CodeAnnotationHang">2</span> HTTP/1.1 200 OK&#13;
<span class="CodeAnnotationHang">3</span> Accept-Ranges: none&#13;
Vary: Accept-Encoding&#13;
Content-Type: text/plain&#13;
Date: Mon, 02 Jan 2006 15:04:05 MST&#13;
Expires: Mon, 02 Jan 2006 15:04:05 MST&#13;
Cache-Control: private, max-age=0&#13;
Last-Modified: Mon, 02 Jan 2006 15:04:05 MST&#13;
X-Content-Type-Options: nosniff&#13;
Server: sffe&#13;
X-XSS-Protection: 0&#13;
Transfer-Encoding: chunked&#13;
&#13;
<span class="CodeAnnotationHang">4</span><em> </em>User-agent: *&#13;
Disallow: /search&#13;
Allow: /search/about&#13;
Allow: /search/static&#13;
Allow: /search/howsearchworks&#13;
<var>--snip-- </var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: Sending a request for Google’s <em>robots.txt</em> file and receiving a response with its contents</p>&#13;
<p>The <code>GET</code> request <span class="CodeAnnotation">1</span> tells Google’s web server you want the <em>/robots.txt</em> file using HTTP/1.1. Following the request, you press the <span class="KeyCaps">enter</span> key twice to send the request followed by an empty line. The web server promptly responds with a status line <span class="CodeAnnotation">2</span>, a series of headers <span class="CodeAnnotation">3</span>, an empty line delimiting the headers from the response body, and the contents of the <em>robots.txt</em> file in the response body <span class="CodeAnnotation">4</span>. You’ll learn about server responses a bit later in this chapter.</p>&#13;
<p>Using Go’s <code>net/http</code> package, you can create a request with nothing but an HTTP method and a URL. The <code>net/http</code> package includes constants for the most common RFC 7231 and RFC 5789 request methods. The RFCs contain quite a bit of jargon with respect to request methods. The following descriptions describe how to use these methods in practice:</p>&#13;
<ol class="none">&#13;
<li><code class="bold">GET</code>  As in the earlier example, the <code>GET</code> method instructs the server to send you the target resource. The server will deliver the target resource in the response’s body. It’s important to note that the target resource does not need to be a file; the response could deliver you dynamically generated content, like the <em>gophers</em> image search result discussed earlier. The server should never change or remove the resource as the result of a <code>GET</code> request. </li>&#13;
<li><span epub:type="pagebreak" id="Page_169" title="169"/><code class="bold">HEAD</code>  The <code>HEAD</code> method is like <code>GET</code> except it tells the server to exclude the target resource in its response. The server will send only the response code and other various bits of metadata stored in the response headers. You can use this method to retrieve meaningful details about a resource, such as its size, to determine whether you want to retrieve the resource in the first place. (The resource may be larger than you expect.)</li>&#13;
<li><code class="bold">POST</code>  A <code>POST</code> request is a way for you to upload data included in the request body to a web server. The <code>POST</code> method tells the server that you are sending data to associate with the target resource. For example, you may post a new comment to a news story, in which case the news story would be the target resource. In simple terms, think of the <code>POST</code> method as the method for creating new resources on the server.</li>&#13;
<li><code class="bold">PUT</code>  Like <code>POST</code>, you can use a <code>PUT</code> request to upload data to a web server. In practice, the <code>PUT</code> method usually updates or completely replaces an existing resource. You could use <code>PUT</code> to edit the comment you <code>POST</code>ed to the news story.</li>&#13;
<li><code class="bold">PATCH</code>  The <code>PATCH</code> method specifies partial changes to an existing resource, leaving the rest of the resource unmodified. In this way, it’s like a <em>diff</em>. Let’s assume you are buying a Gopher Plush for that someone special in your life, and you’ve proceeded past the shipping address step of the checkout process when you realize you made a typo in your street address. You jump back to the shipping address form and correct the typo. Now, you could <code>POST</code> the form again and send all its contents to the server. But a <code>PATCH</code> request would be more efficient since you made only a single correction. You’ll likely encounter the <code>PATCH</code> method in APIs, rather than HTML forms.</li>&#13;
<li><code class="bold">DELETE</code>  The <code>DELETE</code> method instructs the server to remove the target resource. Let’s say your comment on the news story was too controversial, and now your neighbors avoid making eye contact with you. You can make a <code>DELETE</code> request to the server to remove your comment and restore your social status.</li>&#13;
<li><code class="bold">OPTIONS</code>  You can ask the server what methods a target resource supports by using the <code>OPTIONS</code> method. For example, you could send an <code>OPTIONS</code> request with your news story comment as the target resource and learn that the <code>DELETE</code> method is not one of the methods the server will support for your comment, meaning your best option now is to find another place to live and meet new neighbors.</li>&#13;
<li><code class="bold">CONNECT</code>  The client uses <code>CONNECT</code> to request that the web server perform <em>HTTP tunneling,</em> or establish a TCP session with a target destination and proxy data between the client and the destination.</li>&#13;
<li><code class="bold">TRACE</code>  The <code>TRACE</code> method instructs the web server to echo the request back to you instead of processing it. This method allows you to see whether any intermediate nodes modify your request before it reaches the web server.&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<span epub:type="pagebreak" id="Page_170" title="170"/><h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Before adding server-side support for the <code>TRACE</code> method, I strongly recommend you read up on its role in cross-site tracing (XST) attacks, whereby an attacker uses a cross-site scripting (XSS) attack to steal authenticated user credentials. The risk of adding a potential attack vector to your web server likely does not outweigh the diagnostic benefits of <code>TRACE</code> support.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
&#13;
</li>&#13;
</ol>&#13;
<p>It’s important to mention that web servers are under no obligation to implement these request methods. In addition, you may find that some web servers don’t correctly implement them. Trust, but verify.</p>&#13;
<h3 id="h2-500884c08-0003">Server Responses</h3>&#13;
<p class="BodyFirst">Whereas the client request always specifies a method and a target resource, the web server’s response always includes a status code to inform the client of the status of its request. A successful request results in a response containing a 200-class status code.</p>&#13;
<p>If the client makes a request that requires further action on the client’s part, the server will return a 300-class status code. For example, if the client requests a resource that has not changed since the client’s last request for the resource, the server may return a 304 status code to inform the client that it should instead render the resource from its cache.</p>&#13;
<p>If an error occurs because of the client’s request, the server will return a 400-class status code in its response. The most common example of this scenario occurs when a client requests a nonexistent target resource, in which case the server responds with a 404 status code to inform the client that it could not find the resource.</p>&#13;
<p>The 500-class status codes inform the client that an error has occurred on the server side that prevents the server from fulfilling the request. Let’s assume that your request requires the web server to retrieve assets from an upstream server to satisfy your request, but that the upstream server fails to respond. The web server will respond to you with a 504 status code indicating that a time-out occurred during the communication with its upstream server.</p>&#13;
<p>A handful of 100-class status codes exist in HTTP/1.1 to give direction to the client. For example, the client can ask for guidance from the server while sending a <code>POST</code> request. To do so, the client would send the <code>POST</code> method, target resource, and request headers to the server, one of which tells the server that the client wants permission to proceed sending the request body. The server can respond with a 100 status code indicating that the client can continue the request and send the body.</p>&#13;
<p>The IANA maintains the official list of HTTP status codes, which you can find at <a class="LinkURL" href="https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml">https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml</a>. If you encounter a relatively obscure status code, you can typically find a description of it in RFC 7231 at <a class="LinkURL" href="https://tools.ietf.org/html/rfc7231#section-6">https://tools.ietf.org/html/rfc7231#section-6</a>. </p>&#13;
<p><span epub:type="pagebreak" id="Page_171" title="171"/>Go defines many of these status codes as constants in its <code>net/http</code> package, and I suggest you use the constants in your code. It’s much easier to read <code>http.StatusOK</code> than it is to remember what 200 means. The most common HTTP status codes you’ll encounter include the following:</p>&#13;
<ol class="none">&#13;
<li><code class="bold">200 OK</code>  Indicates a successful request. If the request method was <code>GET</code>, the response body contains the target resource.</li>&#13;
<li><code class="bold">201 Created</code>  Returned when the server has successfully processed a request and added a new resource, as may be the case with a <code>POST</code> request.</li>&#13;
<li><code class="bold">202 Accepted</code>  Often returned if the request was successful but the server hasn’t yet created a new resource. The creation of the resource may still fail despite the successful request.</li>&#13;
<li><code class="bold">204 No Content</code>  Often returned if the request was successful but the response body is empty.</li>&#13;
<li><code class="bold">304 Not Modified</code>  Returned when a client requests an unchanged resource. The client should instead use its cached copy of the resource. One method of caching is using an entity tag (ETag) header. When a client requests a resource from the server, the response may include an optional server-derived ETag header, which has meaning to the server. If the client requests the same resource in the future, the client can pass along the cached ETag header and value in its request. The server will check the ETag value in the client’s request to determine whether the requested resource has changed. If it is unchanged, the server will likely respond with a 304 status code and an empty response body.</li>&#13;
<li><code class="bold">400 Bad Request</code>  Returned if the server outright rejects the client’s request for some reason. This may be due to a malformed request, like one that includes a request method but no target resource.</li>&#13;
<li><code class="bold">403 Forbidden</code>  Often returned if the server accepts your request but determines you do not have permission to access the resource, or if the server itself does not have permission to access the requested resource.</li>&#13;
<li><code class="bold">404 Not Found</code>  Returned if you request a nonexistent resource. You may also find this status code used as a <em>Glomar response</em> when a server does not want to confirm or deny your permission to access a resource. In other words, a web server may respond with a 404 status code for a resource you do not have permission to access instead of explicitly responding with a 403 status code confirming your lack of permissions to the resource. Attackers attempting to access sensitive resources on your web server would want to focus their efforts only on existing resources, even if they currently lack permissions to access those resources. Returning a 404 status code for both nonexistent and forbidden resources prevents attackers from differentiating between the two, providing a measure of security. The downside to this approach is you’ll have a harder time debugging your permissions on your server, because you won’t know whether the resource you’re requesting exists or you simply lack permissions. I suggest you articulate the difference in your server logs.</li>&#13;
<li><span epub:type="pagebreak" id="Page_172" title="172"/><code class="bold">405 Method Not Allowed</code>  Returned if you specify a request method for a target resource that the server does not support. Remember the controversial comment you attempted to delete in our discussion of the <code>OPTIONS</code> request method? You would receive a 405 status code in response to that <code>DELETE</code> request.</li>&#13;
<li><code class="bold">426 Upgrade Required</code>  Returned to instruct the client to first upgrade to TLS before requesting the target resource.</li>&#13;
<li><code class="bold">500 Internal Server Error</code>  A catchall code of sorts returned when an error occurs on the server that prevents it from satisfying the client’s request but that doesn’t match the criteria of any other status code. Servers have returned many a 500 error because of some sort of configuration error or syntax error in server-side code. If your server returns this code, check your logs.</li>&#13;
<li><code class="bold">502 Bad Gateway</code>  Returned when the server proxies data between the client and an upstream service, but the upstream service is unavailable and not accepting requests.</li>&#13;
<li><code class="bold">503 Service Unavailable</code>  Returned if a web server is unavailable to accept a request. For example, a web server may return a 503 status code for all incoming connections when it’s put into maintenance mode.</li>&#13;
<li><code class="bold">504 Gateway Timeout</code>  Returned by a proxy web server to indicate that the upstream service accepted the request but did not provide a timely reply.</li>&#13;
</ol>&#13;
<h3 id="h2-500884c08-0004">From Request to Rendered Page</h3>&#13;
<p class="BodyFirst">A web page is often composed of various resources, such as images, videos, layout instructions for your web browser, third-party ads, and so on. Accessing each resource requires a separate request to the server. In HTTP version 1.0 (HTTP/1.0), clients must initiate a separate TCP connection for each request. HTTP/1.1 eliminates this requirement, reducing the latency and request-connection overhead associated with multiple HTTP requests to the same web server. Instead, it allows multiple requests and responses over the same TCP connection. (All contemporary web server software and web browsers support HTTP/1.1 at a minimum, so you’re unlikely to use HTTP/1.0 at all.) </p>&#13;
<p><a href="#table8-1" id="tableanchor8-1">Table 8-1</a> demonstrates the retrieval of an HTML document and the subsequent <code>GET</code> calls of all resources specified in that document.</p>&#13;
<figure class="TableTitle">&#13;
<figcaption><p><a id="table8-1">Table 8-1</a>: Retrieving Additional Resources After Requesting the Index HTML Document</p></figcaption>&#13;
<table border="1" id="table-500884c08-0001">&#13;
<thead>&#13;
<tr>&#13;
<td>Status</td><td>Method</td><td>Domain</td><td>Resource</td><td>Type</td><td>Bytes transferred</td><td>Duration of transfer</td></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>200</td><td>GET</td><td><em>woodbeck.net</em></td><td><em>/</em></td><td>HTML</td><td>1.83KB</td><td>49 ms</td></tr>&#13;
<tr>&#13;
<td>200</td><td>GET</td><td><em>woodbeck.net   </em></td><td><em>main.min.css</em></td><td>CSS</td><td>1.30KB</td><td>20 ms</td></tr>&#13;
<tr>&#13;
<td>200</td><td>GET</td><td><em>woodbeck.net</em></td><td><em>code.css</em></td><td>CSS</td><td>0.99KB</td><td>20 ms</td></tr>&#13;
<tr>&#13;
<td>304</td><td>GET</td><td><em>woodbeck.net</em></td><td><em>avatar.jpeg</em></td><td>JPEG</td><td>0 bytes</td><td>0 ms</td></tr>&#13;
<tr>&#13;
<td>404</td><td>GET</td><td><em>woodbeck.net</em></td><td><em>favicon.ico</em></td><td>IMG</td><td>0 bytes</td><td>0 ms</td></tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_173" title="173"/>The initial <code>GET</code> request for <a class="LinkURL" href="https://woodbeck.net/">https://woodbeck.net/</a> successfully retrieved the HTML document specified by the default resource. This HTML document included links to additional resources necessary to properly render the page, so the web browser requested those too. Since this transfer used HTTP/1.1, the web browser used the same TCP connection to retrieve the remaining resources. The web server instructed the web browser to use its cached copy of <em>avatar.jpeg</em>, since that resource hadn’t changed since the last time the web browser received it. The web server was unable to find the <em>favicon.ico</em> file, so it returned a 404 status code to the web browser.</p>&#13;
<p>The latest version of HTTP, HTTP/2, aims to further reduce latency. In addition to reusing the same TCP connection for subsequent requests, the HTTP/2 server can proactively push resources to the client. If the conversation in <a href="#table8-1">Table 8-1</a> occurred over HTTP/2, it may have transpired like this. The client requested the default resource. The server responded with the default resource. But since the server knew that the default resource had dependent resources, it <em>pushed</em> those resources to the client without the client’s needing to make separate requests for each resource.</p>&#13;
<p>The Go HTTP client and server transparently support HTTP/1.0, HTTP/1.1, and HTTP/2, meaning that you can write your code to retrieve and serve resources while letting code in Go’s <code>net/http</code> package negotiate the optimal HTTP version. However, while the Go HTTP/2 server implementation can push resources to clients, the Go HTTP/2 client implementation cannot yet consume those server pushes.</p>&#13;
<h2 id="h1-500884c08-0002">Retrieving Web Resources in Go</h2>&#13;
<p class="BodyFirst">Just like your web browser, Go can communicate with web servers by using the <code>net/http</code> package’s HTTP client. Unlike your web browser, Go won’t directly render an HTML page to your screen. Instead, you could use Go to scrape data from websites (such as financial stock details), submit form data, or interact with APIs that use HTTP for their application protocol, to name a few examples.</p>&#13;
<p>Despite the simplicity of making HTTP requests in Go, you’ll have to handle some client-side pitfalls. You’ll learn about these pitfalls shortly. First, let’s look at a simple example request.</p>&#13;
<h3 id="h2-500884c08-0005">Using Go’s Default HTTP Client</h3>&#13;
<p class="BodyFirst">The <code>net/http</code> package includes a default client that allows you to make one-off HTTP requests. For example, you can use the <code>http.Get</code> function to send a <code>GET</code> request to a given URL.</p>&#13;
<p><a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a> demonstrates one way you can retrieve the current time from a trusted authority—<em>time.gov</em>’s web server—and compare it with the local time on your computer. This will give you a rough idea of how far ahead or behind the local time is on your computer. You certainly wouldn’t want to rely on this method for any sort of forensics, but the example serves to demonstrate the Go HTTP client workflow by using a <code>HEAD</code> request and response.</p>&#13;
<span epub:type="pagebreak" id="Page_174" title="174"/><pre><code>package main&#13;
&#13;
import (&#13;
    "net/http"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestHeadTime(t *testing.T) {&#13;
    resp, err := <span class="CodeAnnotation">1</span>http.Head("https://www.time.gov/")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    _ = <span class="CodeAnnotation">2</span>resp.Body.Close() // Always close this without exception.&#13;
&#13;
    now := time.Now().Round(time.Second)&#13;
    date := <span class="CodeAnnotation">3</span>resp.Header.Get("Date")&#13;
    if date == "" {&#13;
        t.Fatal("no Date header received from time.gov")&#13;
    }&#13;
&#13;
    dt, err := time.Parse(time.RFC1123, date)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    t.Logf("time.gov: %s (skew %s)", dt, now.Sub(dt))&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: Retrieving a timestamp from <em>time.gov</em> (<em>time_test.go</em>)</p>&#13;
<p>The <code>net/http</code> package includes a few helper functions to make <code>GET</code>, <code>HEAD</code>, or <code>POST</code> requests. Here, we use the <code>http.Get</code> function <span class="CodeAnnotation">1</span> to <a class="LinkURL" href="https://www.time.gov/">https://www.time.gov/</a> to retrieve the default resource. Go’s HTTP client automatically upgrades to HTTPS for you because that’s the protocol indicated by the URL’s scheme. Although you don’t read the contents of the response body, you must close it <span class="CodeAnnotation">2</span>. The next section covers why you need to close the response body in every case. </p>&#13;
<p>Now that you have a response, you retrieve the <code>Date</code> header <span class="CodeAnnotation">3</span>, which indicates the time at which the server created the response. You can then use this value to calculate the clock skew of your computer. Granted, you lose accuracy because of latency between the server’s generating the header and your code’s processing it, as well as the lack of nanosecond resolution of the <code>Date</code> header itself.</p>&#13;
<h3 id="h2-500884c08-0006">Closing the Response Body</h3>&#13;
<p class="BodyFirst">As mentioned earlier, HTTP/1.1 allows the client to maintain a TCP connection with a server for multiple HTTP requests (we call this <em>keepalive support</em>). Even so, the client cannot reuse a TCP session when unread bytes from the previous response remain on the wire. Go’s HTTP client <span epub:type="pagebreak" id="Page_175" title="175"/>automatically drains the response body when you close it. This allows your code to reuse the underlying TCP session if you are diligent about closing every response body.</p>&#13;
<p>Let’s revisit the response from <a href="#listing8-1">Listing 8-1</a> to see how Go parses the response (<a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a>).</p>&#13;
<pre><code><span class="CodeAnnotationHang">1</span><em> </em>HTTP/1.1 200 OK&#13;
Accept-Ranges: none&#13;
Vary: Accept-Encoding&#13;
Content-Type: text/plain&#13;
Date: Mon, 02 Jan 2006 15:04:05 MST&#13;
Expires: Mon, 02 Jan 2006 15:04:05 MST&#13;
Cache-Control: private, max-age=0&#13;
Last-Modified: Mon, 02 Jan 2006 15:04:05 MST&#13;
X-Content-Type-Options: nosniff&#13;
Server: sffe&#13;
X-XSS-Protection: 0&#13;
Transfer-Encoding: chunked&#13;
&#13;
<span class="CodeAnnotationHang">2</span><em> </em>User-agent: *&#13;
Disallow: /search&#13;
Allow: /search/about&#13;
Allow: /search/static&#13;
Allow: /search/howsearchworks&#13;
<var>--snip-- </var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: Parsing the HTTP response</p>&#13;
<p>Go’s HTTP client reads the response status and headers <span class="CodeAnnotation">1</span> from the network socket, and this data immediately becomes available to your code as part of the response object. The client doesn’t automatically read the response body, however <span class="CodeAnnotation">2</span>. The body remains unconsumed until your code explicitly reads it or until you close it and Go implicitly drains any unread bytes.</p>&#13;
<p>The Go HTTP client’s implicit draining of the response body on closing could potentially bite you. For example, let’s assume you send a <code>GET</code> request for a file and receive a response from the server. You read the response’s <code>Content-Length</code> header and realize the file is much larger than you anticipated. If you close the response body without reading any of its bytes, Go will download the entire file from the server as it drains the body regardless.</p>&#13;
<p>A better alternative would be to send a <code>HEAD</code> request to retrieve the <code>Content-Length</code> header. This way, no unread bytes exist in the response body, so closing the response body will not incur any additional overhead while draining it. You properly closed the response body in <a href="#listing8-2">Listing 8-2</a>, so the Go HTTP client could reuse the TCP session if you made additional calls in the future.</p>&#13;
<p>On the rare occasion that you make an HTTP request and want to explicitly drain the response body, the most efficient way is to use the <code>io.Copy</code> function:</p>&#13;
<pre><code>_, _ = io.Copy(ioutil.Discard, response.Body) &#13;
_ = response.Close()</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_176" title="176"/>The <code>io.Copy</code> function drains the <code>response.Body</code> by reading all bytes from it and writing those bytes to <code>ioutil.Discard</code>. As its name indicates, <code>ioutil.Discard</code> is a special <code>io.Writer</code> that discards all bytes written to it. </p>&#13;
<p>You do not have to ignore the return values of <code>io.Copy</code> and <code>response.Close</code>, but doing so lets other developers know you intentionally ignored these values. Some developers may regard this as unnecessary verbosity, and it’s true that <code>io.Copy</code> or <code>response.Close</code> will rarely return errors in this context, but it’s still a good practice. I’ve encountered code that implicitly ignores errors, presumably out of habit, when the developer should have otherwise handled the errors.</p>&#13;
<p>The bottom line is that you must close the response body no matter whether you read it or not, to avoid resource leaks.</p>&#13;
<h3 id="h2-500884c08-0007">Implementing Time-outs and Cancellations</h3>&#13;
<p class="BodyFirst">Go’s default HTTP client and the requests created with the <code>http.Get</code>, <code>http.Head</code>, and <code>http.Post</code> helper functions do not time out. The consequences of this may not be obvious until you get bit by the following fact (after which you’ll never forget it): the lack of a time-out or deadline means that a misbehaving or malicious service could cause your code to block indefinitely without producing an error to indicate that anything’s wrong. You might not find out that your service is malfunctioning until users start calling you to complain.</p>&#13;
<p>For example, <a href="#listing8-4" id="listinganchor8-4">Listing 8-4</a> demonstrates a simple test that causes the HTTP client to block indefinitely. </p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "context"&#13;
    "errors"&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func blockIndefinitely(w http.ResponseWriter, r *http.Request) {&#13;
    select {}&#13;
}&#13;
&#13;
func TestBlockIndefinitely(t *testing.T) {&#13;
    ts := <span class="CodeAnnotation">1</span>httptest.NewServer(<span class="CodeAnnotation">2</span>http.HandlerFunc(<span class="CodeAnnotation">3</span>blockIndefinitely))&#13;
    _, _ = http.Get(<span class="CodeAnnotation">4</span>ts.URL)&#13;
    t.Fatal("client did not indefinitely block")&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: The test server causes the default HTTP client to block indefinitely (<em>block_test.go</em>).</p>&#13;
<p>The <code>net/http/httptest</code> package includes a useful HTTP test server. The <code>httptest.NewServer</code><span class="CodeAnnotation">1</span> function accepts an <code>http.HandlerFunc</code><span class="CodeAnnotation">2</span>, which in turn wraps the <code>blockIndefinitely</code> function <span class="CodeAnnotation">3</span>. The test server passes any request <span epub:type="pagebreak" id="Page_177" title="177"/>it receives at its URL <span class="CodeAnnotation">4</span> to the <code>http.HandlerFunc</code>’s <code>ServeHTTP</code> method. This method sends the request and response objects to the <code>blockIndefinitely</code> function, where control blocks indefinitely.</p>&#13;
<p>Because the helper function <code>http.Get</code> uses the default HTTP client, this <code>GET</code> request won’t time out. Instead, the <code>go test</code> runner will eventually time out and halt the test, printing the stack trace. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	If you run this test, I recommend you pass the argument <code>-timeout 5s</code> to <code>go test</code> to keep from waiting too long.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>To solve this issue, production code should use the technique you learned for timing out network sockets in <span class="xref" itemid="xref_target_“Using a Context with a Deadline to Time Out a Connection” on page 57">“Using a Context with a Deadline to Time Out a Connection” on page 57</span>. Create a context and use it to initialize a new request. You can then manually cancel the request by either using the context’s <code>cancel</code> function or creating a context with a deadline or time-out.</p>&#13;
<p>Let’s fix the test in <a href="#listing8-4">Listing 8-4</a> by replacing it with the test in <a href="#listing8-5" id="listinganchor8-5">Listing 8-5</a>. The new test will time out the request after five seconds without an answer from the server.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestBlockIndefinitelyWithTimeout(t *testing.T) {&#13;
    ts := httptest.NewServer(http.HandlerFunc(blockIndefinitely))&#13;
&#13;
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#13;
    defer cancel()&#13;
&#13;
    req, err := <span class="CodeAnnotation">1</span>http.NewRequestWithContext(ctx, http.MethodGet, ts.URL, nil)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    resp, err := http.DefaultClient.Do(req)&#13;
    if err != nil {&#13;
        if !errors.Is(err, context.DeadlineExceeded) {&#13;
            t.Fatal(err)&#13;
        }&#13;
        return&#13;
    }&#13;
    _ = resp.Body.Close()&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-5">Listing 8-5</a>: Adding a time-out to the GET request (<em>block_test.go</em>)</p>&#13;
<p>First, you create a new request <span class="CodeAnnotation">1</span> by passing in the context, the request method, the URL, and a <code>nil</code> request body, since your request does not have a payload. Keep in mind that the context’s timer starts running as soon as you initialize the context. The context controls the entire life cycle of the request. In other words, the client has five seconds to connect to the web server, send the request, read the response headers, and pass the response to your code. You then have the remainder of the five seconds to read the <span epub:type="pagebreak" id="Page_178" title="178"/>response body. If you are in the middle of reading the response body when the context times out, your next read will immediately return an error. So, use generous time-out values for your specific application.</p>&#13;
<p>Alternatively, create a context without a time-out or deadline and control the cancellation of the context exclusively by using a timer and the context’s <code>cancel</code> function, like this:</p>&#13;
<pre><code>    ctx, cancel := context.WithCancel(context.Background())&#13;
    timer := time.AfterFunc(5*time.Second, <span class="CodeAnnotation">1</span>cancel)&#13;
    // Make the HTTP request, read the response headers, etc.&#13;
    // ...&#13;
    // Add 5 more seconds before reading the response body.&#13;
    timer.Reset(5*time.Second)</code></pre>&#13;
<p>This snippet demonstrates how to use a timer that will call the context’s <code>cancel</code> function <span class="CodeAnnotation">1</span> after it expires. You can reset the timer as needed to push the call to <code>cancel</code> further into the future.</p>&#13;
<h3 id="h2-500884c08-0008">Disabling Persistent TCP Connections</h3>&#13;
<p class="BodyFirst">By default, Go’s HTTP client maintains the underlying TCP connection to a web server after reading its response unless explicitly told to disconnect by the server. Although this is desirable behavior for most use cases because it allows you to use the same TCP connection for multiple requests, you may inadvertently deny your computer the ability to open new TCP connections with other web servers. </p>&#13;
<p>This is because the number of active TCP connections a computer can maintain is finite. If you write a program that makes one-off requests to numerous web servers, you could find that your program stops working after exhausting all your computer’s available TCP connections, leaving it unable to open new ones. In this scenario, TCP session reuse can work against you. Instead of disabling TCP session reuse in the client, a more flexible option is to inform the client what to do with the TCP socket on a per-request basis.</p>&#13;
<pre><code><var>--snip--</var>&#13;
    req, err := http.NewRequestWithContext(ctx, http.MethodGet, ts.URL, nil)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
  <span class="CodeAnnotation">1</span>req.Close = true &#13;
<var>--snip--</var></code></pre>&#13;
<p>Setting the request’s <code>Close</code> field <span class="CodeAnnotation">1</span> to <code>true</code> tells Go’s HTTP client that it should close the underlying TCP connection after reading the web server’s response. If you know you’re going to send four requests to a web server and no more, you could set the <code>Close</code> field to <code>true</code> on the fourth request. All four requests will use the same TCP session, and the client will terminate the TCP connection after receiving the fourth response.</p>&#13;
<h2 id="h1-500884c08-0003"><span epub:type="pagebreak" id="Page_179" title="179"/>Posting Data over HTTP</h2>&#13;
<p class="BodyFirst">Sending a <code>POST</code> request and its payload to a web server is like the calls you’ve made thus far. The difference, of course, is that the request body contains a payload. This payload can be any object that implements the <code>io.Reader</code> interface, including a file handle, standard input, an HTTP response body, or a Unix domain socket, to name a few. But as you’ll see, sending data to the web server involves a little more code than a <code>GET</code> request because you must prepare that request body.</p>&#13;
<h3 id="h2-500884c08-0009">Posting JSON to a Web Server</h3>&#13;
<p class="BodyFirst">Before you can send data to a test server, you need to create a handler that can accept it. <a href="#listing8-6" id="listinganchor8-6">Listing 8-6</a> creates a new type named <code>User</code> that you will encode to JavaScript Object Notation (JSON) and post to the handler.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "context"&#13;
    "encoding/json"&#13;
    "fmt"&#13;
    "io"&#13;
    "io/ioutil"&#13;
    "mime/multipart"&#13;
    "net/http"&#13;
    "net/http/httptest"&#13;
    "os"&#13;
    "path/filepath"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
type User struct {&#13;
    First string&#13;
    Last  string&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang">1</span> func handlePostUser(t *testing.T) func(http.ResponseWriter, *http.Request) {&#13;
    return func(w http.ResponseWriter, r *http.Request) {&#13;
        defer func(r io.ReadCloser) {&#13;
            _, _ = <span class="CodeAnnotation">2</span>io.Copy(ioutil.Discard, r)&#13;
            _ = r.Close()&#13;
        }(r.Body)&#13;
&#13;
        if r.Method != <span class="CodeAnnotation">3</span>http.MethodPost {&#13;
          <span class="CodeAnnotation">4</span>http.Error(w, "", http.StatusMethodNotAllowed)&#13;
            return&#13;
        }&#13;
&#13;
        var u User&#13;
        err := json.NewDecoder(r.Body).Decode(&amp;u)&#13;
<span epub:type="pagebreak" id="Page_180" title="180"/>        if err != nil {&#13;
            t.Error(err)&#13;
            http.Error(w, "Decode Failed", http.StatusBadRequest)&#13;
            return&#13;
        }&#13;
&#13;
      <span class="CodeAnnotationHang">5</span>w.WriteHeader(http.StatusAccepted) &#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-6">Listing 8-6</a>: A handler that can decode JSON into a User object (<em>post_test.go</em>)</p>&#13;
<p>The <code>handlePostUser</code> function <span class="CodeAnnotation">1</span> returns a function that will handle <code>POST</code> requests. If the request method is anything other than <code>POST</code><span class="CodeAnnotation">3</span>, it returns a status code indicating that the server disallows the method <span class="CodeAnnotation">4</span>. The function then attempts to decode the JSON in the request body to a <code>User</code> object. If successful, the response’s status is set to <em>Accepted</em><span class="CodeAnnotation">5</span>.</p>&#13;
<p>Unlike the Go HTTP client, the Go HTTP server must explicitly drain the request body <span class="CodeAnnotation">2</span> before closing it. We’ll discuss this in more detail in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.</p>&#13;
<p>The test in <a href="#listing8-7" id="listinganchor8-7">Listing 8-7</a> encodes a <code>User</code> object into JSON and sends it in a <code>POST</code> request to the test server.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestPostUser(t *testing.T) {&#13;
    ts := httptest.NewServer(http.HandlerFunc(handlePostUser(t)))&#13;
    defer ts.Close()&#13;
&#13;
    resp, err := http.Get(ts.URL)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    if <span class="CodeAnnotation">1</span>resp.StatusCode != http.StatusMethodNotAllowed {&#13;
        t.Fatalf("expected status %d; actual status %d",&#13;
            http.StatusMethodNotAllowed, resp.StatusCode)&#13;
    }&#13;
&#13;
    buf := new(bytes.Buffer)&#13;
    u := User{First: "Adam", Last: "Woodbeck"}&#13;
 <span class="CodeAnnotation">2</span> err = json.NewEncoder(buf).Encode(&amp;u)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    resp, err = <span class="CodeAnnotation">3</span>http.Post(ts.URL, "application/json", buf)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    if resp.StatusCode != <span class="CodeAnnotation">4</span>http.StatusAccepted {&#13;
        t.Fatalf("expected status %d; actual status %d",&#13;
            http.StatusAccepted, resp.StatusCode)&#13;
<span epub:type="pagebreak" id="Page_181" title="181"/>    }&#13;
    _ = resp.Body.Close()&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-7">Listing 8-7</a>: Encoding a User object to <var>JSON</var> and POST to the test server (<em>post_test.go</em>)</p>&#13;
<p>The test first makes sure that the test server’s handler properly responds with an error if the client sends the wrong type of request <span class="CodeAnnotation">1</span>. If the test server receives anything other than a <code>POST</code> request, it will respond with a Method Not Allowed error. Then, the test encodes a <code>User</code> object into JSON and writes the data to a bytes buffer <span class="CodeAnnotation">2</span>. It makes a <code>POST</code> request to the test server’s URL with the content type <em>application/json</em> because the bytes buffer, representing the request body, contains JSON <span class="CodeAnnotation">3</span>. The content type informs the server’s handler about the type of data to expect in the request body. If the server’s handler properly decoded the request body, the response status code is 202 Accepted <span class="CodeAnnotation">4</span>.</p>&#13;
<h3 id="h2-500884c08-0010">Posting a Multipart Form with Attached Files</h3>&#13;
<p class="BodyFirst">Posting JSON to a web server is easy. Simply set the appropriate content type and send along the JSON payload in the request body. But how do you handle sending various bits of data to a web server in a single <code>POST</code> request? Answer: use the <code>mime/multipart</code> package.</p>&#13;
<p>The <code>mime/multipart</code> package allows you to craft multipart <em>Multipurpose Internet Mail Extensions (MIME) messages</em>, which separate each bit of data you want to send from the other bits of data by a string known as a <em>boundary</em>. You’ll see an example of a boundary a bit later in this section, though it isn’t something you typically need to worry about.</p>&#13;
<p>Each MIME part includes optional headers that describe the content, as well as a body that contains the content itself. For example, if a web server parsed a MIME part with a <code>Content-Type</code> header set to <em>text/plain</em>, it would treat the part’s body as plaintext.</p>&#13;
<p><a href="#listing8-8" id="listinganchor8-8">Listing 8-8</a> introduces a new test that walks you through the process of building up a multipart request body using the <code>mime/multipart</code> package.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestMultipartPost(t *testing.T) {&#13;
    reqBody := <span class="CodeAnnotation">1</span>new(bytes.Buffer)&#13;
    w := <span class="CodeAnnotation">2</span>multipart.NewWriter(reqBody)&#13;
&#13;
    for k, v := range map[string]string{&#13;
        "date":        time.Now().Format(time.RFC3339),&#13;
        "description": "Form values with attached files",&#13;
    } {&#13;
        err := <span class="CodeAnnotation">3</span>w.WriteField(k, v)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-8">Listing 8-8</a>: Creating a new request body, multipart writer, and write form data (<em>post_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_182" title="182"/>First, you create a new buffer <span class="CodeAnnotation">1</span> to act as the request body. You then create a new multipart writer <span class="CodeAnnotation">2</span> that wraps the buffer. The multipart writer generates a random boundary upon initialization. Finally, you write form fields to the multipart writer <span class="CodeAnnotation">3</span>. The multipart writer separates each form field into its own part, writing the boundary, appropriate headers, and the form field value to each part’s body.</p>&#13;
<p>At this point, your request body has two parts, one for the <em>date</em> form field and one for the <em>description</em> form field. Let’s attach a couple of files in <a href="#listing8-9" id="listinganchor8-9">Listing 8-9</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    for i, file := range []string{&#13;
        "./files/hello.txt",&#13;
        "./files/goodbye.txt",&#13;
    } {&#13;
        filePart, err := <span class="CodeAnnotation">1</span>w.CreateFormFile(fmt.Sprintf("file%d", i+1),&#13;
            filepath.Base(file))&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        f, err := os.Open(file)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        _, err = <span class="CodeAnnotation">2</span>io.Copy(filePart, f)&#13;
        _ = f.Close()&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
    }&#13;
&#13;
    err := <span class="CodeAnnotation">3</span>w.Close()&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-9">Listing 8-9</a>: Writing two files to the request body, each in its own MIME part (<em>post_test.go</em>)</p>&#13;
<p>Attaching a field to a request body isn’t as straightforward as adding form field data. You have an extra step. First, you need to create a multipart section writer from <a href="#listing8-8">Listing 8-8</a>’s multipart writer <span class="CodeAnnotation">1</span>. The <code>CreateFormField</code> method accepts a field name and a filename. The server uses this filename when parsing the MIME part. It does not need to match the filename you attach. Now, you just open the file and copy its contents to the MIME part writer <span class="CodeAnnotation">2</span>.</p>&#13;
<p>When you’re done adding parts to the request body, you must close the multipart writer <span class="CodeAnnotation">3</span>, which finalizes the request body by appending the boundary.</p>&#13;
<p><span epub:type="pagebreak" id="Page_183" title="183"/><a href="#listing8-10" id="listinganchor8-10">Listing 8-10</a> posts the request to a well-regarded test server, <em>httpbin.org</em>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    ctx, cancel := context.WithTimeout(context.Background(),&#13;
        60*time.Second)&#13;
    defer cancel()&#13;
&#13;
    req, err := http.NewRequestWithContext(ctx, http.MethodPost,&#13;
      <span class="CodeAnnotation">1</span>"https://httpbin.org/post", <span class="CodeAnnotation">2</span>reqBody)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    req.Header.Set("Content-Type", <span class="CodeAnnotation">3</span>w.FormDataContentType())&#13;
&#13;
    resp, err := http.DefaultClient.Do(req)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer func() { _ = resp.Body.Close() }()&#13;
&#13;
    b, err := ioutil.ReadAll(resp.Body)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    if resp.StatusCode != http.StatusOK {&#13;
        t.Fatalf("expected status %d; actual status %d",&#13;
            http.StatusOK, resp.StatusCode)&#13;
    }&#13;
&#13;
    t.Logf("\n%s", b)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-10">Listing 8-10</a>: Sending a <var>POST</var> request to <em>httpbin.org</em> with Go’s default HTTP client (<em>post_test.go</em>)</p>&#13;
<p>First, you create a new request and pass it a context that will time out in 60 seconds. Since you’re making this call over the internet, you don’t have as much certainty that your request will reach its destination as you do when testing over localhost. The <code>POST</code> request is destined for <a class="LinkURL" href="https://www.httpbin.org/">https://www.httpbin.org/</a><span class="CodeAnnotation">1</span> and will send the multipart request body <span class="CodeAnnotation">2</span> in its payload.</p>&#13;
<p>Before you send the request, you need to set the <code>Content-Type</code> header to inform the web server you’re sending multiple parts in this request. The multipart writer’s <code>FormDataContentType</code> method <span class="CodeAnnotation">3</span> returns the appropriate <code>Content-Type</code> value that includes its boundary. The web server uses the boundary from this header to determine where one part stops and another starts as it reads the request body.</p>&#13;
<p>Once you run the test with the <code>-v</code> flag, you should see output like the JSON in <a href="#listing8-11" id="listinganchor8-11">Listing 8-11</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_184" title="184"/><pre><code>{&#13;
  "args": {},&#13;
  "data": "",&#13;
<span class="CodeAnnotation">1</span>"files": {&#13;
    "file1": "Hello, world!\n",&#13;
    "file2": "Goodbye, world!\n"&#13;
  },&#13;
<span class="CodeAnnotation">2</span>"form": {&#13;
    "date": "2006-01-02T15:04:05-07:00",&#13;
    "description": "Form fields with attached files"&#13;
  },&#13;
  "headers": {&#13;
    "Accept-Encoding": "gzip",&#13;
    "Content-Length": "739",&#13;
 <span class="CodeAnnotation">3</span> "Content-Type": "multipart/form-data; boundary=e9ad4b62e0dfc8d7dc57ccfa8ba62244342f1884608e6d88018f9de8abcb",&#13;
    "Host": "httpbin.org",&#13;
    "User-Agent": "Go-http-client/1.1"&#13;
  },&#13;
  "json": null,&#13;
  "origin": "192.168.0.1",&#13;
  "url": "https://httpbin.org/post"&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing8-11">Listing 8-11</a>: Response body from the multipart <var>POST</var> request</p>&#13;
<p>This is <em>httpbin.org</em>’s standard <code>POST</code> response and includes some fields irrelevant to the request you sent. But if you have a look, you’ll see the contents of each text file you attached <span class="CodeAnnotation">1</span> and the form fields you submitted <span class="CodeAnnotation">2</span>. You can also see the <code>Content-Type</code> header <span class="CodeAnnotation">3</span> added by the multipart writer. Notice the boundary is a random string. With your code as is, the boundary will randomly change with each request. But you can set a boundary by using the multipart writer’s <code>SetBoundary</code> method if you so choose.</p>&#13;
<h2 id="h1-500884c08-0004">What You’ve Learned</h2>&#13;
<p class="BodyFirst">HTTP allows clients to send requests to, and receive resources from, servers over the World Wide Web. This chapter showed you how to use Go to craft HTTP requests. Target resources can take the form of web pages, images, videos, documents, files, games, and so on. To retrieve a resource, the HTTP client sends a <code>GET</code> request with a URL to the web server. The web server uses the URL to locate the correct resource and send it along to the client in the server’s response. The client always initiates this HTTP request-response workflow.</p>&#13;
<p>The client can send diverse types of resource requests to the server. The most used request methods are <code>GET</code>, <code>HEAD</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>. A <code>GET</code> request asks the server to retrieve the specified resource. The client may send a <code>HEAD</code> request to retrieve the response headers without the requested payload. This can be useful for determining whether a resource exists and <span epub:type="pagebreak" id="Page_185" title="185"/>inspecting response headers before retrieving the resource. A <code>POST</code> request allows the client to send a resource to the server, whereas you typically use a <code>PUT</code> request to update an existing resource on the server. The client can request a resource’s deletion from the server by sending a <code>DELETE</code> request.</p>&#13;
<p>The <code>net/http</code> package provides all necessary types and functions to interact with servers over HTTP. It includes a default HTTP client that allows you to make a quick, one-off HTTP request and receive the response. However, you must diligently close the response body to prevent resource leaks, no matter whether you read the body’s contents or not. It’s also important to note that the default HTTP client and the requests sent using helper functions such as <code>http.Get</code>, <code>http.Head</code>, and <code>http.Post</code> do not time out. This means that a misbehaving or malicious service could cause your code to block indefinitely. Therefore, it’s important to manage request cancellation yourself by using a context.</p>&#13;
<p>The <code>mime/multipart</code> package allows you to easily add multiple MIME parts to a request body. You can efficiently craft requests that upload files and form content to a web server.</p>&#13;
</section>&#13;
</body></html>