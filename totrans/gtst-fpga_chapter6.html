<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>6 COMMON FPGA MODULES</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch6" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch6">
<span class="CN"><span aria-label=" Page 91. " epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">COMMON FPGA MODULES</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">Working with an FPGA can feel like building with LEGO: you have a limited variety of small bricks at your disposal, but by stacking them elegantly, you can create amazingly complex designs. At the lowest level, you’re working with LUTs and flip-flops. At a slightly higher level, there are several basic building blocks that appear over and over again in FPGA designs, including multiplexers and demultiplexers, shift registers, and first in, first out (FIFO) and other types of memory.</p>
<p class="TX">Each of these elements is very common. In fact, it’s likely that one or more of them will be used in every single FPGA project you’ll ever work on. In this chapter, I’ll show you how these basic building blocks work and how to implement them with Verilog and VHDL. For each of these common elements, you’ll create a self-contained module that you can reuse anytime you <span aria-label=" Page 92. " epub:type="pagebreak" id="pg_92" role="doc-pagebreak"/>need that element in an FPGA design. This will reinforce your FPGA programming knowledge and give you a solid foundation for your own projects.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-68"/><samp class="SANS_Futura_Std_Bold_B_11">Multiplexers and Demultiplexers</samp></h2>
<p class="TNI1"><i>Multiplexers</i> and <i>demultiplexers</i> are circuit components that allow you to select between two or more things. In the case of a multiplexer (sometimes spelled <i>multiplexor</i>, and often shortened to <i>mux</i>), you have multiple input signals, and you select which of them is sent to a single output. A demultiplexer (<i>demux</i> for short) is the opposite: you have a single input signal, and you select which of multiple outputs it should go to.</p>
<p class="TX">Multiplexers and demultiplexers have many applications. For example, a mux could be used to select which speed to run a fan at: the low-med-high switch might be acting as a mux to control which setting is sent to the fan controller. A demux could work with a switch to select which of four LEDs to illuminate: only one LED will be illuminated at a time, but you’ll be able to specify which one is illuminated.</p>
<p class="TX">Muxes and demuxes are classified based on how many inputs and outputs they have. For example, a 4-1 (pronounced <i>four-to-one</i>) mux has four inputs and one output. Conversely, a 1-4 (pronounced <i>one-to-four</i>) demux has one input and four outputs. You can design muxes to have any number of inputs, depending on the requirements of your circuit: you can have a 2-1 mux, a 3-1 mux, an 8-1 mux, a 13-1 mux, or whatever you want. Likewise, you can design a demux with however many outputs you need.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-69"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing a Multiplexer</samp></h3>
<p class="TNI1">Let’s consider how to create a multiplexer on an FPGA. Specifically, we’ll look at creating a 4-1 mux, but you can apply the same logic to a mux with any number of inputs. <a href="#fig6-1">Figure 6-1</a> shows a block diagram of a 4-1 mux.</p>
<figure class="IMG"><img alt="" class="img30" id="fig6-1" src="../images/Figure6-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: A 4-1 multiplexer (mux)</samp></p></figcaption>
</figure>
<p class="TX">Our multiplexer has four inputs on the left: <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data3</samp>. On the right is the single output, called <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data</samp>. At the bottom are two additional inputs, labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp>. <i>Sel</i> is short for <i>select</i>. These selector inputs choose which of the four data inputs is passed to the output. The truth table in <a href="#tab6-1">Table 6-1</a> shows how <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> work together to determine the mux’s output.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab6-1"><span aria-label=" Page 93. " epub:type="pagebreak" id="pg_93" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for a 4-1 Mux</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel0</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data3</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Looking at <a href="#tab6-1">Table 6-1</a>, we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data0</samp> is connected to the output when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> are both 0. The output gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data1</samp> when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 1, it gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data2</samp> when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> is 1 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 0, and it gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data3</samp> when both selectors are 1.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Because muxes serve to select which inputs go to which outputs, they’re often called</i> <span class="Roman">selectors</span><i>. In fact, select is a reserved word in VHDL that can be used to generate muxes.</i></p>
<p class="TX">Implementing this truth table in Verilog or VHDL is simply a matter of evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> and assigning the appropriate data input to the output. The following listing shows how it’s done (I’ve omitted the signal definitions to focus on the actual mux code, but more context can be found in the book’s GitHub repository, at <i><a href="https://github.com/nandland/getting-started-with-fpgas">https://<wbr/>github<wbr/>.com<wbr/>/nandland<wbr/>/getting<wbr/>-started<wbr/>-with<wbr/>-fpgas</a>)</i>:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>assign o_Data = !i_Sel1 &amp; !i_Sel0 ? i_Data0 :
                !i_Sel1 &amp;  i_Sel0 ? i_Data1 :
                 i_Sel1 &amp; !i_Sel0 ? i_Data2 : i_Data3;</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>o_Data &lt;= i_Data0 when i_Sel1 = '0' and i_Sel0 = '0' else
          i_Data1 when i_Sel1 = '0' and i_Sel0 = '1' else
          i_Data2 when i_Sel1 = '1' and i_Sel0 = '0' else
          i_Data3;</code></pre>
<p class="TX">The Verilog version uses the conditional (or ternary) operator, represented by a question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>). This is shorthand for writing conditional expressions without using <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statements. The operator works by first evaluating the condition before the question mark (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!i_Sel1 &amp; !i_Sel0</samp>). If the condition is true, the expression selects the condition before the colon. If the condition is false, it selects the condition after the colon. Here, we’ve chained several <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> operators together to handle each possible combination of the two selector inputs.</p>
<p class="TX">In the VHDL version, we accomplish the same thing by chaining several <samp class="SANS_TheSansMonoCd_W5Regular_11">when/else</samp> statements. Since the VHDL version uses more spelled-out keywords, it’s a bit more readable, but the Verilog is more concise. In both the Verilog and VHDL versions, the chain of logical checks gets evaluated until one evaluates as true. If none of them are true, then we use the last assignment in the chain.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-70"/><span aria-label=" Page 94. " epub:type="pagebreak" id="pg_94" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing a Demultiplexer</samp></h3>
<p class="TNI1">For a 1-4 demux, the block diagram looks like a mirrored version of a 4-1 mux, as you can see in <a href="#fig6-2">Figure 6-2</a>.</p>
<figure class="IMG"><img alt="" class="img30" id="fig6-2" src="../images/Figure6-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: A 1-4 demultiplexer (demux)</samp></p></figcaption>
</figure>
<p class="TX">This demux takes a single data input on the left (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>) and selects which output to connect it to. The demux is doing a 1-4 selection, so two input selectors are required to select between the four possible outputs. The truth table in <a href="#tab6-2">Table 6-2</a> shows all the possible combinations.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab6-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Truth Table for a 1-4 Demux</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Sel0</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data3</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data2</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">o_Data0</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Looking at the table, we can see that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp> is connected to one of the four outputs at a time, as determined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> selector inputs. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> are both 0, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data0</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>; otherwise it gets 0. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> is 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 1, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data1</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>; otherwise it gets 0. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> is 1 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 0, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data2</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>; otherwise it gets 0. Finally, when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel1</samp> is 1 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Sel0</samp> is 1, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data3</samp> gets <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp>; otherwise it gets 0. Let’s see how we can implement this truth table in Verilog and VHDL:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Demux_1_To_4
 (input  i_Data,
  input  i_Sel1,
  input  i_Sel0,
  output o_Data0,
  output o_Data1,
  output o_Data2,
  output o_Data3);
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> assign o_Data0 = !i_Sel1 &amp; !i_Sel0 ? i_Data : 1'b0;
assign o_Data1 = !i_Sel1 &amp;  i_Sel0 ? i_Data : 1'b0;
<span aria-label=" Page 95. " epub:type="pagebreak" id="pg_95" role="doc-pagebreak"/>assign o_Data2 = i_Sel1 &amp; !i_Sel0 ? i_Data : 1'b0;
assign o_Data3 = i_Sel1 &amp;  i_Sel0 ? i_Data : 1'b0;
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity Demux_1_To_4 is
  port (
    i_Data  : in  std_logic;
    i_Sel0  : in  std_logic;
    i_Sel1  : in  std_logic;
    o_Data0 : out std_logic;
    o_Data1 : out std_logic;
    o_Data2 : out std_logic;
    o_Data3 : out std_logic);
end entity Demux_1_To_4;
architecture RTL of Demux_1_To_4 is
begin
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> o_Data0 &lt;= i_Data when i_Sel1 = '0' and i_Sel0 = '0' else '0';
  o_Data1 &lt;= i_Data when i_Sel1 = '0' and i_Sel0 = '1' else '0';
  o_Data2 &lt;= i_Data when i_Sel1 = '1' and i_Sel0 = '0' else '0';
  o_Data3 &lt;= i_Data when i_Sel1 = '1' and i_Sel0 = '1' else '0';
end architecture RTL;</code></pre>
<p class="TX">Notice how each output in this code is set independently. The input <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data</samp> can only be assigned to a single output at a time. For example, we assign it to the first output, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Data0</samp>, when both selector inputs are 0 <span aria-label="annotation1" class="CodeAnnotation">❶</span>. When an output isn’t wired to the input data, then it’s just set to 0 to disable it.</p>
<p class="TX">In practice, since a mux or demux can be created with just a few lines of code, it’s unlikely that you’d ever create a module to instantiate a single multiplexer or demultiplexer. Generally, you’ll be better off just putting the code that builds the mux or demux directly into the module where it’s needed. However, multiplexers and demultiplexers are incredibly common circuit design elements, so it’s important to understand how to implement them. Next, we’ll look at another common component: the shift register.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h-71"/><samp class="SANS_Futura_Std_Bold_B_11">The Shift Register</samp></h2>
<p class="TNI1">A <i>shift register</i> is a series of flip-flops where the output of one flip-flop is connected to the input of the next. We looked at a shift register back in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> when we talked about a chain of flip-flops, but to keep things simple I didn’t introduce the term at the time. To review, <a href="#fig6-3">Figure 6-3</a> shows a chain of four flip-flops, which we can now call a <i>4-bit shift register</i>. As discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, each additional flip-flop in the chain adds a single clock cycle of delay to the output.</p>
<span aria-label=" Page 96. " epub:type="pagebreak" id="pg_96" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img100" id="fig6-3" src="../images/Figure6-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: A shift register</samp></p></figcaption>
</figure>
<p class="TX">Shift registers have many uses. For example, they can delay data for some fixed number of clock cycles, convert data from serial to parallel or from parallel to serial, or create a linear feedback shift register. We’ll look at examples of each of these applications in this section.</p>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-72"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Delaying Data</samp></h3>
<p class="TNI1">Creating delay in an FPGA is the most common application of a shift register. The delay is often used to align data in time. For example, when you send input data through a math operation, it might take a few clock cycles to produce a result. If you need to align the output result with the original input data, then the original input data needs to be delayed by the number of clock cycles that the math operation will take to perform.</p>
<p class="TX">As we’ve seen, a shift register is simply a chain of flip-flops, and the number of flip-flops in the chain dictates how many clock cycles it will take for the data on the input to propagate to the output. With that in mind, this code will create a shift register that generates a four-clock-cycle delay on some input data:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> reg [3:0] r_Shift;
always @ (posedge i_Clk)
  begin
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Shift[0]   &lt;= i_Data_To_Delay;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> r_Shift[3:1] &lt;= r_Shift[2:0];
  end</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> signal r_Shift : std_logic_vector(3 downto 0);
process (i_Clk)
begin
  if rising_edge(i_Clk) then
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_Shift(0)          &lt;= i_Data_To_Delay;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> r_Shift(3 downto 1) &lt;= r_Shift(2 downto 0);
  end if;
end process;</code></pre>
<p class="TX">Here we create a shift register called <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp>, which will be four flip-flops in length <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Remember, the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_</samp> in the name is a clue that the signal <span aria-label=" Page 97. " epub:type="pagebreak" id="pg_97" role="doc-pagebreak"/>will consist of flip-flops and be assigned within a clocked <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> block (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block (in VHDL). We load up the first flip-flop in the chain (position <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>) with <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data_To_Delay</samp>, the input signal <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Then we use a trick to create the remaining three flip-flop assignments in a single line of code, rather than three: we take the values on flip-flops <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> and assign them to flip-flops <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. This way, the data that was on the first flip-flop in the chain is shifted to the second flip-flop, the data on the second flip-flop is shifted to the third, and so on. If you wanted, you could break this step down into its individual operations, like so:</p>
<pre><code>r_Shift[3] &lt;= r_Shift[2];
r_Shift[2] &lt;= r_Shift[1];
r_Shift[1] &lt;= r_Shift[0];</code></pre>
<p class="TX">This example shows the Verilog version. For VHDL, replace the square brackets with parentheses.</p>
<p class="TX">Writing out each assignment individually demonstrates more explicitly how the data moves through the shift register one bit at a time, but both methods will work the same way. Now we can use bit position <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Shift</samp> for our purposes, as this is the flip-flop that represents a four-clock-cycle delay of the input data <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Data_To_Delay</samp>. If we needed a three-clock-cycle delay instead, we could use the data at bit position <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, or we could add more flip-flops to the chain to create a longer delay.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h-73"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between Serial and Parallel Data</samp></h3>
<p class="TNI1">Converting from serial data to parallel data and vice versa is another common use of a shift register. You might need to do this when communicating with off-chip interfaces that transmit and receive data serially. One specific example is interfacing with a <i>universal asynchronous receiver-transmitter (UART)</i>. This is a device that transmits bytes of data by breaking them into individual bits, which are then reconstituted into bytes on the receiving end. When the data is sent, it is converted from parallel to serial: the eight parallel bits of data in a byte are sent serially, one after the other. When the data is received, it’s converted back from serial (individual bits) to parallel (a complete byte).</p>
<p class="TX">UARTs are widely used to send and receive data between devices because they’re simple and effective, and they’re a perfect application for a shift register. An eight-bit shift register can send a byte of data by reading it out, one flip-flop at a time, or it can receive a byte of data by shifting the bits through the chain of flip-flops, one bit after the other. For example, say we want to send and receive ASCII-encoded characters, each of which can be represented within a single byte of data. First, let’s look at the receiving end of the UART. Each line in <a href="#tab6-3">Table 6-3</a> represents the receipt of a single bit of data. The column on the right shows how the complete byte is built up by shifting the bits through a shift register.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab6-3"><span aria-label=" Page 98. " epub:type="pagebreak" id="pg_98" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Receiving a Byte of Data Through a UART</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Bit index</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Received bit</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Byte contents</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1011</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01011</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">001011</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1001011</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">01001011</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL"/>
<td class="table TBL"/>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII=0x4B='K'</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">UARTs normally receive data starting with the least significant (rightmost) bit. The first bit received is shifted through the shift register from the most significant (leftmost) position to the least significant position as more bits come in. Let’s walk through how this works.</p>
<p class="TX">On the first line of the table, we’ve received the first bit, which has a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. We place it into the most significant bit position, the first flip-flop in the shift register. When we receive the second bit, which is also a <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, we shift the existing bit to the right, and put the new received bit in the most significant bit position. The third bit we receive is a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. Once again, we place it into the most significant position, and the rest of the bits are shifted right. Once we’ve received all eight bits, the shift register is full, with the last bit placed into the most significant bit position and the first bit placed in the least significant position. At this point, the byte is complete. In our example, we’ve received <samp class="SANS_TheSansMonoCd_W5Regular_11">01001011</samp>, which is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4B</samp> (meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">4B</samp> in hexadecimal), the ASCII encoding for the letter K. By receiving the data one bit at a time and shifting the received bits to the right with a shift register, we converted serial data to parallel data.</p>
<p class="TX">Now let’s look at the transmit side of a UART. <a href="#tab6-4">Table 6-4</a> shows how to transmit the byte <samp class="SANS_TheSansMonoCd_W5Regular_11">00110111</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x37</samp>, which is the digit 7 in ASCII.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab6-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Transmitting a Byte of Data Through a UART</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Bit index</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Byte contents</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Transmitted bit</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF"/>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII=0x37='7'</samp></p>
</td>
<td class="table TBF"/>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">00110111</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">	</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0011011</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">	</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">001101</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">	</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">00110</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">	</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0011</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">	</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">	</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">	</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX"><span aria-label=" Page 99. " epub:type="pagebreak" id="pg_99" role="doc-pagebreak"/>In this case, we start with the entire byte of data loaded in an 8-bit shift register. Again, a UART transmits from least significant bit to most significant bit, so here we send out the rightmost bit and shift the entire byte to the right with each step. By using a shift register to send out one bit at a time and shift the remaining bits to the right, we’re converting parallel data to serial data.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-74"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Linear Feedback Shift Register</samp></h3>
<p class="TNI1">The last common application of the shift register is to create a <i>linear feedback shift register (LFSR)</i>. This is a shift register where certain flip-flops in the chain are tapped into and used as input for either an XOR or an XNOR gate (we’ll be using XNOR). The output of this gate is then fed back into the beginning of the shift register, hence the word <i>feedback</i> in the name. <i>Linear</i> comes from the fact that this arrangement produces an input bit that’s a linear function of the LFSR’s previous state. <a href="#fig6-4">Figure 6-4</a> shows an example of a 3-bit LFSR, but keep in mind that LFSRs can have any number of bits.</p>
<figure class="IMG"><img alt="" class="img40" id="fig6-4" src="../images/Figure6-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: A 3-bit LFSR</samp></p></figcaption>
</figure>
<p class="TX">This LFSR features three chained flip-flops, representing bits 0 through 2 of a shift register. The outputs of the bit 1 flip-flop and the bit 2 flip-flop are passed through an XNOR gate, and the output of the gate is sent to the input of the first bit in the shift register. The value of the LFSR at any given clock cycle is the value of the three flip-flop outputs.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>The flip-flops in <a href="#fig6-4">Figure 6-4</a> are drawn backward compared to how we’ve usually seen them, with input D on the right and output Q on the left. I drew them this way so the least significant bit (bit 0) would appear on the right, to match how we write numbers, but there’s nothing special here; these are the same flip-flops that we all know and love, just mirrored.</i></p>
<p class="TX">When an LFSR is running, the pattern generated by the individual flip-flops is <i>pseudorandom</i>, meaning it’s close to but not completely random. It’s only pseudorandom because from any state of the LFSR pattern, you can predict the next state. <a href="#tab6-5">Table 6-5</a> shows what happens when the 3-bit LFSR is initialized to zero, then the clock starts toggling.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab6-5"><span aria-label=" Page 100. " epub:type="pagebreak" id="pg_100" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Pseudorandom Output of 3-Bit LFSR</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Clock cycle</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">LFSR data (binary)</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">LFSR data (decimal)</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">8</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">9</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">10</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">…</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">…</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">…</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">The LFSR goes from <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> on the first clock cycle. This makes sense, because the XNOR of bit 2 (0) and bit 1 (0) is 1, which gets written into bit 0. On the next clock cycle, the LFSR goes from <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>. Once again we’ve taken the XNOR of bit 2 (0) and bit 1 (0), giving us a new bit 0 value of 1. Meanwhile, the old bit 0 value (1) has shifted to bit 1. Following the rest of the values in the table, they seem relatively random—pseudorandom, even!</p>
<p class="TX">Notice that the table repeats itself on the seventh clock cycle, so there are seven unique values that the 3-bit LFSR can have: <samp class="SANS_TheSansMonoCd_W5Regular_11">000</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">001</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">010</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">011</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">101</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">110</samp>. It can never have a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp>. If you’re wondering why, consider what would happen if this value arose. At the next clock cycle, the new bit 0 would be the XNOR of 1 and 1, which is 1, while the other bits would shift over, giving us <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> again. The LFSR would be stuck on <samp class="SANS_TheSansMonoCd_W5Regular_11">111</samp> forever, so it would effectively stop running! As a rule, for an LFSR that’s <i>N</i> bit positions long, the maximum number of clock cycles that the LFSR takes to run through all combinations is 2<i><sup>N</sup></i> <span class="symbol">−</span> 1. For 3 bits, it’s 2<sup>3</sup> <span class="symbol">−</span> 1 = 7; for 4 bits, it’s 2<sup>4</sup> <span class="symbol">−</span> 1 = 15; and so on.</p>
<p class="TX">Because of their pseudorandomness, LFSRs have many applications. They can function as low-utilization counters, test pattern generators, data scramblers, or be used in cryptography. The LFSR is lightweight, so these kinds of mathematical operations are carried out with few resources, which is desirable so you can save your precious FPGA flip-flops and LUTs for other tasks.</p>
<p class="TX">Let’s look at how the LFSR in <a href="#fig6-4">Figure 6-4</a> could be implemented in Verilog and VHDL:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> reg [2:0] r_LFSR;
wire     w_XNOR;
always @(posedge i_Clk)
<span aria-label=" Page 101. " epub:type="pagebreak" id="pg_101" role="doc-pagebreak"/>begin
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_LFSR &lt;= {r_LFSR[1:0], w_XNOR};
end
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> assign w_XNOR = r_LFSR[2] ^~ r_LFSR[1];</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> signal r_LFSR : std_logic_vector(2 downto 0)
signal w_XNOR : std_logic;
begin
  process (i_Clk) is
  begin
    if rising_edge(i_Clk) then
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_LFSR &lt;= r_LFSR(1 downto 0) &amp; w_XNOR;
    end if;
  end process;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> w_XNOR &lt;= r_LFSR(2) xnor r_LFSR(1);</code></pre>
<p class="TX">First we declare a 3-bit-wide LFSR <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We perform the shift and incorporate the result of the XNOR operation through concatenation <span aria-label="annotation2" class="CodeAnnotation">❷</span>. In Verilog we concatenate values by placing them in curly brackets, <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>, separated by commas, while in VHDL we use a single ampersand (<samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>). Together, the shifting and concatenation build up a single 3-bit-wide value, with <samp class="SANS_TheSansMonoCd_W5Regular_11">w_XNOR</samp> in the least significant bit position. Finally, we assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_XNOR</samp> gate, based on the values of bits 2 and 1 in the register <span aria-label="annotation3" class="CodeAnnotation">❸</span>. This is a continuous assignment, occurring outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block, and it will be implemented by a LUT in the FPGA.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>This example has shown a very simple 3-bit-wide LFSR, but an LFSR would normally have initialization and reset logic, which would help avoid and recover from any disallowed state. More thorough code, including reset logic and the ability to size the LFSR to any number of bits, is available in the book’s GitHub repository.</i></p>
<p class="TX">LFSRs are a simple and efficient way to perform several useful tasks. They also highlight one of the strengths of an FPGA, namely being able to quickly perform math operations with few resources. Consider that you could have hundreds of LFSRs running in parallel on a single FPGA without issue, and you can start to see how FPGAs excel at fast math operations running in parallel.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h2 class="H1" id="sec8"><span id="h-75"/><span class="NoteHead"><samp class="SANS_Futura_Std_Heavy_B_21">Project #5: Selectively Blinking an LED</samp></span></h2>
<p class="TNI1">Now that we’ve introduced some building blocks, let’s start putting them together. The requirement for this project is to blink each of four LEDs on your development board on and off, but only one LED should be blinking at a time. You’ll select which LED to blink using two switches. <a href="#tab6-6">Table 6-6</a> shows how the LED selection is performed.</p>
<figure class="table">
<table class="table">
<caption>
<p class="TT" id="tab6-6"><span aria-label=" Page 102. " epub:type="pagebreak" id="pg_102" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">LED Selection</samp></p>
</caption>
<thead>
<tr class="table">
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Switch_2</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">i_Switch_1</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">LED to blink</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Signal name</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr class="table">
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">D1</samp></p>
</td>
<td class="table TBF">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">D2</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_2</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">0</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">D3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_3</samp></p>
</td>
</tr>
<tr class="table">
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">D4</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_4</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Looking at the table, we can see that when the two input switches are both 0 (not pressed), the D1 LED will blink. By pushing just switch 1 down (setting it to 1), we select the D2 LED to blink. When we push down just switch 2, D3 should blink, and finally, when we push down both buttons, D4 should blink. This sounds like a job for a demultiplexer! We’ll have a single signal that toggles on and off, and we’ll want to route it to one of four LEDs. But how can we generate the toggling signal?</p>
<p class="TX">The clock on a development board is quite fast. On the Go Board (discussed in <span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span>), for example, it’s 25 MHz. If we fed that directly to an LED, then the LED would blink at 25 MHz. To the human eye, it would look like the LED was just on, since that’s too fast for us to perceive. We need to generate a signal that toggles on its own, but at some much slower frequency than the clock: say, 2 to 4 Hz. That’s fast enough that you’ll be able to tell the LED is blinking quickly, but not too fast for the human eye to see. Remember, however, that FPGAs have no built-in concept of time, so we can’t blink an LED by writing code like this:</p>
<pre><code>r_LED &lt;= 1;
wait for 0.20 seconds
r_LED &lt;= 0;
wait for 0.20 seconds</code></pre>
<p class="TX">As discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, an FPGA can determine how much time has passed by counting clock cycles. To wait for 0.20 seconds to pass, we would need to count one-fifth of the number of clock cycles that occur in a second. In the case of the Go Board, since there are 25,000,000 clock cycles per second (a 25 MHz clock), we would need to count to 25,000,000 / 5 = 5,000,000. Once the count hits this limit, we could reset it to zero and toggle the state of the LED.</p>
<p class="TX">But there’s another way! Recall that one of the possible uses for an LFSR is to create a low-resource counter. Start an LFSR with a certain pattern, such as all zeros, and it will take 2<i><sup>N</sup></i> <span class="symbol">−</span> 1 clock cycles for that pattern to recur, where <i>N</i> is the number of flip-flops that make up the LFSR. Create an LFSR with a high enough number of flip-flops in the shift register, and the rate at which it cycles through all its values will be slow enough to toggle the LED at a satisfying frequency. For example, a 22-bit LFSR will repeat its <span aria-label=" Page 103. " epub:type="pagebreak" id="pg_103" role="doc-pagebreak"/>pattern every 2<sup>22</sup> <span class="symbol">−</span> 1 = 4,194,303 clock cycles. With the Go Board’s 25 MHz clock, that comes out to a little less than 0.20 seconds.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If your board has a different clock frequency, you’ll need to experiment with the number of bits in the LFSR. For the 100 MHz clock on the Alchitry Cu, for example (see <a href="appendix_A.xhtml">Appendix A</a>), try 24 bits: 2</i><i><sup>24</sup></i> <span class="symbol">−</span> <i>1</i> = <i>16,777,215 cycles, or about 0.17 seconds.</i></p>
<p class="TX">Each time the LFSR returns to all zeros, it will toggle a signal, and we’ll use that signal to blink whichever LED is currently selected. All of this can be done using fewer FPGA resources than a traditional counter. <a href="#fig6-5">Figure 6-5</a> shows a block diagram of how it will work.</p>
<figure class="IMG"><img alt="" class="img80" id="fig6-5" src="../images/Figure6-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: The Project #5 block diagram</samp></p></figcaption>
</figure>
<p class="TX">This project will instantiate two modules: the LFSR and the 1-4 demux. Between the two modules, we’ll have a flip-flop and a NOT gate (which will become a LUT). The input to the LFSR is the clock, and the output is a signal that goes high for one clock cycle when the LFSR has reached its limit and started at the beginning of its pattern again. We call this a <i>done pulse</i>. A <i>pulse</i> is a 1 (high) on a signal that lasts for one clock cycle, and this particular pulse signals when the LFSR is done with each cycle through its pattern loop.</p>
<p class="TX">We can’t use the LFSR output directly to blink the LEDs, but we can use it to create a toggling signal. We do this by feeding the LFSR output signal into the enable input of a flip-flop. The flip-flop’s output will be the inversion (using a NOT gate) of its input. This way, each time the LFSR cycles through its pattern, the done pulse will enable the flip-flop for one clock cycle and trigger a change on the flip-flop’s output, either from a 0 to a 1 or from a 1 to a 0. The net result is a signal with a 50 percent duty cycle and a frequency of about 3 Hz, perfect for toggling an LED at a rate the human eye can see. This toggling signal is the input to the demux module. The 1-4 demux selects which LED to pass the toggling signal to by reading the values on the two switches (SW1 and SW2). Only one LED will be blinking at a time, while the LEDs not selected by the switches will be off.</p>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-76"/><span aria-label=" Page 104. " epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp></h3>
<p class="TNI1">Let’s look at the Verilog and VHDL for this project, starting with the top-level code:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Demux_LFSR_Project_Top
  (input i_Clk,
  input i_Switch_1,
  input i_Switch_2,
  output o_LED_1,
  output o_LED_2,
  output o_LED_3,
  output o_LED_4);
  reg r_LFSR_Toggle = 1'b0;
  wire w_LFSR_Done;
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> LFSR_22 LFSR_Inst
  (.i_Clk(i_Clk),
 <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> .o_LFSR_Data(), // unconnected
 <span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> .o_LFSR_Done(w_LFSR_Done));
  always @(posedge i_Clk)
  begin
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if (w_LFSR_Done)
      r_LFSR_Toggle &lt;= !r_LFSR_Toggle;
  end
<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> Demux_1_To_4 Demux_Inst
  (.i_Data(r_LFSR_Toggle),
   .i_Sel0(i_Switch_1),
   .i_Sel1(i_Switch_2),
   .o_Data0(o_LED_1),
   .o_Data1(o_LED_2),
   .o_Data2(o_LED_3),
   .o_Data3(o_LED_4));
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
entity Demux_LFSR_Project_Top is
  port (
    i_Clk      : in  std_logic;
    i_Switch_1 : in  std_logic;
    i_Switch_2 : in  std_logic;
    o_LED_1    : out std_logic;
    o_LED_2    : out std_logic;
    o_LED_3    : out std_logic;
    o_LED_4    : out std_logic);
end entity Demux_LFSR_Project_Top;
architecture RTL of Demux_LFSR_Project_Top is
  signal r_LFSR_Toggle : std_logic := '0';
  signal w_LFSR_Done   : std_logic;
begin
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> LFSR_22 : entity work.LFSR_22
  port map (
    i_Clk       =&gt; i_Clk,
 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> o_LFSR_Data =&gt; open, -- unconnected
 <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> o_LFSR_Done =&gt; w_LFSR_Done);
  process (i_Clk) is
  begin
    if rising_edge(i_Clk) then
    <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if w_LFSR_Done  = '1' then
         r_LFSR_Toggle &lt;= not r_LFSR_Toggle;
       end if;
    end if;
  end process;
<span aria-label="annotation5" class="CodeAnnotationCode">❺</span> Demux_Inst : entity work.Demux_1_To_4
  port map (
    i_Data  =&gt; r_LFSR_Toggle,
    i_Sel0  =&gt; i_Switch_1,
    i_Sel1  =&gt; i_Switch_2,
    o_Data0 =&gt; o_LED_1,
    o_Data1 =&gt; o_LED_2,
    o_Data2 =&gt; o_LED_3,
    o_Data3 =&gt; o_LED_4);
end architecture RTL;</code></pre>
<p class="TX"><span aria-label=" Page 105. " epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/>Our project has three top-level inputs—the clock and two switches—as well as four outputs for the four LEDs. After declaring these, we instantiate the LFSR module <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We’ll look closely at the module next, but for now, notice its <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp> output <span aria-label="annotation3" class="CodeAnnotation">❸</span>, which we wire to <samp class="SANS_TheSansMonoCd_W5Regular_11">w_LFSR_Done</samp>. This output will pulse with each repetition of the LFSR loop.</p>
<p class="TX">We don’t actually need the LFSR to output the current value on its register for this project, but this may be important in other contexts, so the LFSR module has an <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> output for this purpose. One handy trick when instantiating a module with unused outputs is to keep those outputs unconnected, which we do here with <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. In Verilog, we simply leave the parentheses after the output name empty, while in VHDL we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp> keyword. When this design is synthesized, the synthesis tool will prune any outputs that are unused, removing logic that doesn’t go anywhere. This way, you can reuse modules without having to worry about devoting precious FPGA resources to unused features. The synthesis tools are smart enough to optimize your design and remove signals where they aren’t needed.</p>
<p class="TX">In our top-level logic, we check if <samp class="SANS_TheSansMonoCd_W5Regular_11">w_LFSR_Done</samp> is high, meaning the LFSR has output its done pulse <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If so, we invert the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_LFSR_Toggle</samp> signal. This is the signal that gets sent to the 1-4 demux, which we instantiate next <span aria-label="annotation5" class="CodeAnnotation">❺</span>. The <span aria-label=" Page 106. " epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/>selection is performed by the two input switches, and the outputs of the demux are directly connected to the four output LEDs.</p>
<p class="TX">We’ve already seen the code for the 1-4 demux module, in <span class="Xref">“Implementing a Demultiplexer” on page 94</span>. Let’s look at the LFSR module now:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module LFSR_22 (
  input         i_Clk,
  output [21:0] o_LFSR_Data,
  output        o_LFSR_Done);
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> reg [21:0] r_LFSR;
wire       w_XNOR;
always @(posedge i_Clk)
begin
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_LFSR &lt;= {r_LFSR[20:0], w_XNOR};
end
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> assign w_XNOR = r_LFSR[21] ^~ r_LFSR[20];
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> assign o_LFSR_Done = (r_LFSR == 22'd0);
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span> assign o_LFSR_Data = r_LFSR;
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library IEEE;
use IEEE.std_logic_1164.all;
entity LFSR_22 is
   port (
    i_Clk       : in std_logic;
    o_LFSR_Data : out std_logic_vector(21 downto 0);
    o_LFSR_Done : out std_logic);
end entity LFSR_22;
architecture RTL of LFSR_22 is
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> signal r_LFSR : std_logic_vector(21 downto 0);
signal w_XNOR : std_logic;
begin
  process (i_Clk) begin
    if rising_edge (i_Clk) then
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> r_LFSR &lt;= r_LFSR(20 downto 0) &amp; w_XNOR;
    end if;
  end process;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> w_XNOR      &lt;= r_LFSR(21) xnor r_LFSR(20);
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> o_LFSR_Done &lt;= '1' when (r_LFSR = "0000000000000000000000") else '0';
<span aria-label="annotation5" class="CodeAnnotationHang">❺</span> o_LFSR_Data &lt;= r_LFSR;
end RTL;</code></pre>
<p class="TX"><span aria-label=" Page 107. " epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>This module is similar to the 3-bit LFSR that we looked at earlier in the chapter, but the LFSR register has been scaled up to be 22 bits wide <span aria-label="annotation1" class="CodeAnnotation">❶</span>. (Modify the code if you need a different bit width based on your board’s clock speed.) The module also has extra logic to generate the done pulse, as well as to output the LFSR data, which may be useful in other contexts.</p>
<p class="TX">We shift the LFSR register and concatenate the result with a new value for the rightmost bit <span aria-label="annotation2" class="CodeAnnotation">❷</span>, just as we did in the 3-bit LFSR module. Then we XNOR the leftmost two bits in the register to get the new rightmost bit value <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We generate the done pulse on the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp> output when all of the flip-flops that make up the LFSR have zeros on their outputs <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Since this will be the case for exactly one clock cycle, this pulse will be one clock cycle wide. Otherwise, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp> will be low. Finally, we assign the contents of the LFSR register to the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> output <span aria-label="annotation5" class="CodeAnnotation">❺</span>. This way the module provides access to the LFSR data itself, but remember that in this case the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> output won’t be synthesized since we don’t need the data for this particular application.</p>
<p class="TX">At this point, you can build and program the FPGA. When the project starts running, you should see one of the LEDs blinking, but you can select a different LED to blink by pushing either or both of the two switches.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trying Another Way</samp></h3>
<p class="TNI1">This project has shown how simple building blocks like LFSRs and demuxes can be combined to build larger projects, and it has illustrated an interesting application for an LFSR. In the real world, however, you probably wouldn’t use an LFSR to act as a counter like this, since it doesn’t provide much flexibility. Let’s say we want to change the count limit. With the LFSR implementation, we only have a few possible options to choose from, based on the number of bits in the LFSR. For blinking an LED, that was totally acceptable, as we didn’t care exactly how fast the LED was blinking—anywhere between 2 and 4 Hz would be fine. But if we needed to count to a very specific value—say, 4,000,000 instead of 4,194,303—we’d be hard pressed to do this with the LFSR. The next lowest option would be to use a 21-bit LFSR instead of a 22-bit LFSR, which would only allow us to count to 2<sup>21</sup> <span class="symbol">−</span> 1 = 2,097,151. For any value between 2,097,151 and 4,194,303, we’re out of luck.</p>
<p class="TX">To provide more flexibility, I created another version of this project that uses a traditional counter. <a href="#fig6-6">Figure 6-6</a> shows the block diagram of this alternate code.</p>
<figure class="IMG"><img alt="" class="img60" id="fig6-6" src="../images/Figure6-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-6: The revised Project #5 block diagram</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 108. " epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>Here, we’ve replaced the LFSR module with a module that simply counts up to some value and then toggles its output. This approach also allows us to eliminate the flip-flop and NOT gate between the project’s two modules. Let’s look at the code for the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module Count_And_Toggle #(COUNT_LIMIT = 10)
 (input i_Clk,
  input i_Enable,
  output reg o_Toggle);
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> reg [$clog2(COUNT_LIMIT-1):0] r_Counter;
  always @(posedge i_Clk)
  begin
    if (i_Enable == 1'b1)
    begin
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (r_Counter == COUNT_LIMIT - 1)
       begin
       <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> o_Toggle   &lt;= !o_Toggle;
       <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Counter &lt;= 0;
       end
       else
       <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> r_Counter &lt;= r_Counter + 1;
    end
    else
       o_Toggle &lt;= 1'b0;
  end
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity Count_And_Toggle is
  generic (COUNT_LIMIT : natural);
  port (
    i_Clk      : in std_logic;
    i_Enable : in std_logic;
    o_Toggle : out std_logic);
end Count_And_Toggle;
architecture RTL of Count_And_Toggle is
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> signal r_Counter : natural range 0 to COUNT_LIMIT - 1;
begin
  process (i_Clk) is
  begin
    if rising_edge(i_Clk) then
       if i_Enable = '1' then
       <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if r_Counter = COUNT_LIMIT - 1 then
          <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> o_Toggle  &lt;= not o_Toggle;
          <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Counter &lt;= 0;
          else
          <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> r_Counter &lt;= r_Counter + 1;
          end if;
       else
          o_Toggle &lt;= '0';
       end if;
    end if;
  end process;
end RTL;</code></pre>
<p class="TX"><span aria-label=" Page 109. " epub:type="pagebreak" id="pg_109" role="doc-pagebreak"/>This code is much simpler to read and understand than the LFSR code. We declare a register that will act as a counter, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp> parameter/generic to define its size <span aria-label="annotation1" class="CodeAnnotation">❶</span>. If the module is enabled, we check if the counter has reached its limit <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If so, we invert the output signal <span aria-label="annotation3" class="CodeAnnotation">❸</span> and reset the counter <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If the counter isn’t at its limit, then it simply increments by 1 <span aria-label="annotation5" class="CodeAnnotation">❺</span>. With this code, we can set the counter to any arbitrary value and it will count to exactly that value.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>In the VHDL code, we have an output signal o_Toggle on the right side of an assignment</i> <span aria-label="annotation3" class="CodeAnnotation">❸</span><i>, meaning we’re accessing the output’s value. This is valid in VHDL-2008 and later but will throw an error on older versions of VHDL. I recommend using VHDL-2008 in your designs, because of improvements like this.</i></p>
<p class="TX">Now let’s look at the changes to the top-level code that are needed to use this new <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module instead of the LFSR:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
  output o_LED_3,
  output o_LED_4);
  // Equivalent to 2^22 - 1, which is what the LFSR counted up to
  localparam COUNT_LIMIT = 4194303;
  wire w_Counter_Toggle;
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> Count_And_Toggle #(.COUNT_LIMIT(COUNT_LIMIT)) Toggle_Counter
   (.i_Clk(i_Clk),
    .i_Enable(1'b1),
    .o_Toggle(w_Counter_Toggle));
  Demux_1_To_4 Demux_Inst
<span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> (.i_Data(w_Counter_Toggle),
   .i_Sel0(i_Switch_1),
   .i_Sel1(i_Switch_2),
   .o_Data0(o_LED_1),
   .o_Data1(o_LED_2),
   .o_Data2(o_LED_3),
   .o_Data3(o_LED_4));
endmodule</code></pre>
<span aria-label=" Page 110. " epub:type="pagebreak" id="pg_110" role="doc-pagebreak"/>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
architecture RTL of Demux_LFSR_Project_Top is
  -- Equivalent to 2^22 - 1, which is what the LFSR counted up to
  constant COUNT_LIMIT : integer := 4194303;
  signal w_Counter_Toggle : std_logic;
begin
<span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> Toggle_Counter : entity work.Count_And_Toggle
  generic map (
    COUNT_LIMIT =&gt; COUNT_LIMIT)
  port map (
    i_Clk      =&gt; i_Clk,
    i_Enable =&gt; '1',
    o_Toggle =&gt; w_Counter_Toggle);
  Demux_Inst : entity work.Demux_1_To_4
  port map (
  <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> i_Data   =&gt; w_Counter_Toggle,
    i_Sel0   =&gt; i_Switch_1,
    i_Sel1   =&gt; i_Switch_2,
    o_Data0 =&gt; o_LED_1,
    o_Data1 =&gt; o_LED_2,
    o_Data2 =&gt; o_LED_3,
    o_Data3 =&gt; o_LED_4);
end architecture RTL;</code></pre>
<p class="TX">I’ve snipped the parts that are the same. The LFSR has been removed and replaced with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Since that module generates a toggling signal, we no longer need the flip-flop between the two modules. Instead, we can feed <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Counter_Toggle</samp>, the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> module, directly into the demux <span aria-label="annotation2" class="CodeAnnotation">❷</span>.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-78"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing the Two Approaches</samp></h3>
<p class="TNI1">As you’ve seen, using a traditional counter is simpler and more flexible than using an LFSR. However, earlier I asserted that implementing an LFSR requires fewer resources than a traditional counter. Let’s compare the resource utilization reports for the two approaches to this project to see how significant the resource savings are. First, here’s the report for the LFSR version:</p>
<pre><code><span aria-label=" Page 111. " epub:type="pagebreak" id="pg_111" role="doc-pagebreak"/><var>--snip--</var>
Register bits not including I/Os:  23 (1%)
Mapping Summary:
Total  LUTs: 13 (1%)</code></pre>
<p class="BodyContinued">And here’s the report for the counter version:</p>
<pre><code><var>--snip--</var>
Register bits not including I/Os:  24 (1%)
Mapping Summary:
Total  LUTs: 36 (2%)</code></pre>
<p class="TX">The LFSR approach has used 1 fewer flip-flop and 23 fewer LUTs than the counter, so the LFSR does indeed require fewer resources. However, it helps to put that into perspective. Modern FPGAs have thousands of LUTs. You really shouldn’t have to count every single one. By going with the LFSR, we might save 1 percent (or less) of the total resources of our FPGA, but we lose readability and flexibility in the design. In general, I prefer to implement solutions that make sense and are simple, and in this case the LFSR isn’t the simplest solution.</p>
<p class="TX">In addition to showing you how to blink an LED and create a sophisticated project by combining various basic building blocks, this project has illustrated that there’s often a trade-off between simplicity and resources. You’ll find that there are typically several ways to solve problems within an FPGA, and you’ll have to determine which solution works best for you. It could be that the most resource-efficient solution isn’t the simplest, but on the other hand, the simplest solution may not require significantly more resources. In many cases, you might iterate on a design with different approaches, testing each one out. This is always a good exercise; you’ll become a stronger FPGA engineer when you explore multiple ways to write your code.</p>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h2 class="H1" id="sec12"><span id="h-79"/><samp class="SANS_Futura_Std_Bold_B_11">Random Access Memory</samp></h2>
<p class="TNI1"><i>Random-access memory (RAM)</i> allows you to store data within your FPGA and read it back later. This is an incredibly common requirement in an FPGA design. For example, you might want to store data received from a camera, a computer, or a microcontroller and retrieve it later for processing, or you may need to create a storage space for data before saving it to a microSD card. These are just a few examples of use cases for a RAM. The <i>random-access</i> part of the name means that you can access the data in any order. On one clock cycle, for example, you could read out the first location of memory, and then on the very next clock cycle you could read out the last location of memory.</p>
<p class="TX">A RAM is typically designed to be either <i>single-port</i> or <i>dual-port</i>. In a single-port RAM, there’s just one interface into the memory, so in a single <span aria-label=" Page 112. " epub:type="pagebreak" id="pg_112" role="doc-pagebreak"/>clock cycle you can either read from or write to the memory, but not both. A dual-port RAM allows you to read from and write to the memory in the same clock cycle. The latter is more versatile and used more often, so we’ll focus on how to implement that on an FPGA. <a href="#fig6-7">Figure 6-7</a> shows at a high level what we’ll be creating. Note that this is just one possible implementation; the exact signal names can vary.</p>
<figure class="IMG"><img alt="" class="img50" id="fig6-7" src="../images/Figure6-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-7: A dual-port RAM block diagram</samp></p></figcaption>
</figure>
<p class="TX">In the middle of the figure, the memory itself is represented by the large rectangle. The size of the memory is defined by its width and depth. The depth determines the number of memory locations available, while the width determines how many bits can be stored at each location. For example, if the memory is 8 bits wide, then each location can store a byte of data. Multiplying the width by the depth tells you the total number of bits of memory available. For example, if we have an 8-bit-wide memory that’s 16 locations deep, then there’s a total of 8 <span class="symbol">×</span> 16 = 128 bits of memory.</p>
<p class="TX">The memory has two ports, one for writing (on the left) and one for reading (on the right). Each port has its own clock signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Clk</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Clk</samp>. For our purposes, we’ll tie both of these to the same clock, but note that it’s possible for each port to operate according to its own independent clock. We’ll discuss working with more than one clock, or <i>crossing clock domains</i>, in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. For now, just know that this module is built with that feature in mind.</p>
<p class="TX">Each port has an address signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp>, which communicates the index into the memory where the writing or reading operation should take place. If you’ve programmed in C, this is like the index into an array. The indices typically range from 0 to (<i>depth</i> – 1), giving us a total of <i>depth</i> locations in the physical memory.</p>
<p class="TX">For writing the data, we need to set the write address correctly, put the data that we want to write on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp>, and pulse the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_DV</samp> for a single clock cycle. <samp class="SANS_TheSansMonoCd_W5Regular_11">DV</samp> here stands for <i>data valid</i>, which I commonly use to indicate that the data signal should be “looked at” by the module. If we want to keep writing to the memory, we can change the address and the data, and keep pulsing the data valid signal.</p>
<p class="TX">For reading the data, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp> high, while setting the read address to the address we want to read from. The module that is performing the read can simply monitor the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_DV</samp> to see when it goes high; this indicates that there is valid data on <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp>, which is the data that is read from the memory.</p>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-80"/><span aria-label=" Page 113. " epub:type="pagebreak" id="pg_113" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A RAM Implementation</samp></h3>
<p class="TNI1">Now that you understand at a high level how a RAM works, let’s examine the code implementing the memory:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>module RAM_2Port <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> #(parameter WIDTH = 16, DEPTH = 256)
   (
   // Write signals
   input                     i_Wr_Clk,
   input [$clog2(DEPTH)-1:0] i_Wr_Addr,
   input                     i_Wr_DV,
   input [WIDTH-1:0]         i_Wr_Data,
   // Read signals
   input                     i_Rd_Clk,
   input [$clog2(DEPTH)-1:0] i_Rd_Addr,
   input                     i_Rd_En,
   output reg                o_Rd_DV,
   output reg [WIDTH-1:0]    o_Rd_Data
   );
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> reg [WIDTH-1:0] r_Mem[DEPTH-1:0];
   always @ (posedge i_Wr_Clk)
   begin
   <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if (i_Wr_DV)
      begin
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Mem[i_Wr_Addr] &lt;= i_Wr_Data;
      end
   end
   always @ (posedge i_Rd_Clk)
   begin
   <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> o_Rd_Data &lt;= r_Mem[i_Rd_Addr];
   <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> o_Rd_DV   &lt;= i_Rd_En;
   end
endmodule</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity RAM_2Port is
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> generic (
     WIDTH : integer := 16;
     DEPTH : integer := 256
     );
   port (
     -- Write signals
     i_Wr_Clk  : in std_logic;
     i_Wr_Addr : in std_logic_vector; -- sized at higher level
     i_Wr_DV   : in std_logic;
     i_Wr_Data : in std_logic_vector(WIDTH-1 downto 0);
     -- Read signals
     i_Rd_Clk  : in std_logic;
     i_Rd_Addr : in std_logic_vector; -- sized at higher level
     i_Rd_En   : in std_logic;
     o_Rd_DV   : out std_logic;
     o_Rd_Data : out std_logic_vector(WIDTH-1 downto 0)
     );
end RAM_2Port;
architecture RTL of RAM_2Port is
   type t_Mem is array (0 to DEPTH-1) of std_logic_vector(WIDTH-1 downto 0);
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> signal r_Mem : t_Mem;
begin
   process (i_Wr_Clk)
   begin
     if rising_edge(i_Wr_Clk) then
     <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if i_Wr_DV = '1' then
        <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> r_Mem(to_integer(unsigned(i_Wr_Addr))) &lt;= i_Wr_Data;
        end if;
     end if;
   end process;
   process (i_Rd_Clk)
   begin
     if rising_edge(i_Rd_Clk) then
     <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> o_Rd_Data &lt;= r_Mem(to_integer(unsigned(i_Rd_Addr)));
     <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> o_Rd_DV   &lt;= i_Rd_En;
     end if;
   end process;
end RTL;</code></pre>
<p class="TX"><span aria-label=" Page 114. " epub:type="pagebreak" id="pg_114" role="doc-pagebreak"/>We’ve implemented the memory as a module called <samp class="SANS_TheSansMonoCd_W5Regular_11">RAM_2Port</samp>. Notice that the module has two parameters (in Verilog) or generics (in VHDL): <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This gives us the flexibility to create a RAM of any size we want, without having to modify the module code. If we need a memory that’s 4 bits wide and 16 locations deep, this code can do that; if we need it to be 16 bits wide by 1,024 deep, this code can do that too. We only need to choose different <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> values when we instantiate the module.</p>
<p class="TX">Looking at the signal declarations to the module, we can see all the signals shown in <a href="#fig6-7">Figure 6-7</a> that make up the write and read interfaces. The signals <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp> will provide the indices of the write and read locations, respectively. These address signals are given a bit width large enough to represent any index to a memory containing <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> elements. For example, if you need to address into 128 memory locations (<samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">128</samp>), then you’re going to need 7 bits to accomplish that (2<sup>7</sup> = 128), so the address signals will be 7 bits wide. In Verilog, this sizing of the address works with the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp> trick described in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. In VHDL we can leave the length of the vector undefined and set it in the higher-level module when this memory is <span aria-label=" Page 115. " epub:type="pagebreak" id="pg_115" role="doc-pagebreak"/>instantiated. The instantiation itself must be of a fixed width, which will then specify the address signal width in this module. The last place we are using the parameters/generics to size our signals is for <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp>. These carry the actual data being written or read, respectively, and are sized based on <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> to accommodate the full width of each location in memory.</p>
<p class="TX">We instantiate the memory itself as <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Mem</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. It will be <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> wide and <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> long, for a total storage of <samp class="SANS_TheSansMonoCd_W5Regular_11">WIDTH</samp> <span class="symbol">×</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp> bits of memory. This instantiates a two-dimensional (2D) array in the code. In Verilog, we create it by setting a register of specific width, as we’ve done in the past, but with extra brackets on the end that specify the number of memory locations based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>. In VHDL, we need to create a custom data type called <samp class="SANS_TheSansMonoCd_W5Regular_11">t_Mem</samp> that defines the 2D array; then we can create the memory signal <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Mem</samp>, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">t_Mem</samp>.</p>
<p class="TX">Next, we give the write and read operations their own <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks, triggered by the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Clk</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Clk</samp> clock signals, respectively. (Again, unless you need to cross clock domains, you can simply tie these signals to the same clock in the higher-level code that instantiates this module.) For write operations, we first check to see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_DV</samp> signal is high <span aria-label="annotation3" class="CodeAnnotation">❸</span>. If it is, we take the data that’s on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp> and store it into memory at the location specified by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. This looks a lot like updating a value in an array, because that’s basically what we’re doing.</p>
<p class="TX">For read operations, the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp> output is updated with the value of the memory at the address given by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp> <span aria-label="annotation5" class="CodeAnnotation">❺</span>. At the same time, the value on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp> is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_DV</samp> <span aria-label="annotation6" class="CodeAnnotation">❻</span>. The higher-level module will set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp> to high when it’s actually trying to read data, and passing this signal to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_DV</samp> generates a data valid pulse telling the higher-level module that the data is safe to read. Notice, however, that <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp> doesn’t really control when data will be read within this module. In fact, the code to update <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp> <span aria-label="annotation5" class="CodeAnnotation">❺</span> will run on every single clock cycle, updating it with whatever is stored at the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp> memory location, whether we’re explicitly trying to read data out of the memory or not. That’s fine! It does no harm to read the memory on every clock cycle like this, even if we end up ignoring the data that’s being read out.</p>
<p class="TX">To see the dual-port memory operating in a simulation, download the code from the repository and run the testbench for this module.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2" id="sec14"><span id="h-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">RAM on an FPGA</samp></h3>
<p class="TNI1">We’ve written the code for a dual-port RAM, but what FPGA component makes up the memory itself? The answer is, <i>it depends</i>. If the memory is small enough—for example, 4 locations wide by 8 deep—the storage elements will be individual flip-flops. However, if the memory gets large enough, the synthesis tools will instead decide to use a block RAM (BRAM). We’ll discuss the block RAM in detail in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>. For now, just know that it’s a large memory storage component that exists on the FPGA for this very purpose.</p>
<p class="TX">You wouldn’t want to use flip-flops for large memories because you’re limited with how many flip-flops are available for memory storage. You want to save those precious flip-flops to do the main work in your FPGA, not just store a single bit of data in a large memory. The synthesis tools are smart; <span aria-label=" Page 116. " epub:type="pagebreak" id="pg_116" role="doc-pagebreak"/>they know it’s best to push a large memory instantiation to one or more block RAMs.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h2 class="H1" id="sec15"><span id="h-82"/><samp class="SANS_Futura_Std_Bold_B_11">FIFO: First In, First Out</samp></h2>
<p class="TNI1">The <i>first in, first out (FIFO)</i> is another common FPGA building block for storing and retrieving data. The concept of a FIFO is quite simple: data comes in one entry at a time and gets read out in order from oldest to newest. <a href="#fig6-8">Figure 6-8</a> shows a high-level representation of a FIFO.</p>
<figure class="IMG"><img alt="" class="img40" id="fig6-8" src="../images/Figure6-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-8: A high-level block diagram of a FIFO</samp></p></figcaption>
</figure>
<p class="TX">As you can see, a FIFO has a write interface pushing data in on the left side and a read interface pulling data out on the right side. Compared to the dual-port RAM diagram in <a href="#fig6-7">Figure 6-7</a>, notice that I’ve flipped the width and depth here. This helps to visualize the key FIFO behavior: the first data that gets put in is the first data that gets pulled out. In this sense, data moves through a FIFO like cars through a tunnel. The first car into the tunnel is also the first car out. Other programming languages often have some sort of queue structure, which behaves the same way. With a FIFO in an FPGA, however, you’re building a real queue out of real components!</p>
<p class="TX">FIFOs are used extensively in FPGA designs. Any time you need to buffer some data between a producer and a consumer, a FIFO acts as that buffer. For example, to write data to an off-chip memory storage element like a low-power double data rate (LPDDR) memory, you’d use many FIFOs to queue up the data, and then quickly burst it out of the FPGA into the LPDDR. Similarly, if you interface with a camera, you might store rows of pixel data into FIFOs for image manipulation like blurring or brightness enhancement. Finally, whenever you need to send data across clock domains, FIFOs are up to the task: one clock coordinates loading data into the FIFO, while the other clock coordinates reading it out.</p>
<p class="TX">A FIFO is full when there are no more memory locations available for new write data. A FIFO is empty when it has nothing in it. This leads to two critical rules that you must follow to ensure your FIFO behaves as expected:</p>
<p class="NLF2">1.  Never write to a full FIFO.</p>
<p class="NLL2">2.  Never read from an empty FIFO.</p>
<p class="TX">Writing to a full FIFO is bad because it can cause data loss: you’ll end up overwriting data that was stored earlier. Reading from an empty FIFO is <span aria-label=" Page 117. " epub:type="pagebreak" id="pg_117" role="doc-pagebreak"/>also bad, as you don’t know what data you’re going to get out of it. Breaking one of these two rules is one of the most common FPGA bugs that I’ve encountered in my career. It’s also one of the harder bugs to find, because writing to a full FIFO or reading from an empty FIFO can cause strange behavior, like unexpected data and data loss. Often this corrupted data looks like a problem with the data, rather than a problem with the FIFO, so what’s causing the bug is difficult to diagnose. Keep these rules in mind as we discuss the details of how a FIFO works.</p>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H2" id="sec16"><span id="h-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Input and Output Signals</samp></h3>
<p class="TNI1">A FIFO is basically a version of a dual-port RAM with some extra signals added to create the FIFO behavior. Before we look at the code for the FIFO, let’s consider what all those signals are. <a href="#fig6-9">Figure 6-9</a> shows a more detailed block diagram of a FIFO.</p>
<figure class="IMG"><img alt="" class="img60" id="fig6-9" src="../images/Figure6-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-9: A detailed FIFO block diagram</samp></p></figcaption>
</figure>
<p class="TX">Like the dual-port RAM, the FIFO has ports for writing and reading. Each port has its own dedicated clock. FIFOs are commonly used to cross clock domains, so <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Clk</samp> is different from <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Clk</samp>. However, the FIFO that we’ll explore has a single clock for both the write and read ports, for simplicity and portability across FPGAs.</p>
<p class="TX">Next, on the write side, the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_DV</samp> (data valid) input signals when there’s data to be written on <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Data</samp> and pushes that data into the FIFO. On the read side, the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_En</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_DV</samp> signals similarly communicate when we wish to read data, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Rd_Data</samp> output retrieves the data itself. All of this is just like what we saw on the RAM. Unlike on the RAM, however, we no longer need to worry about keeping track of which address to write to or read from. The FIFO knows to simply cycle through the memory addresses in sequence, one after the other, when reading or writing. As such, there’s no need for <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Wr_Addr</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rd_Addr</samp> input signals we had on the RAM. Instead, the remaining input and output signals help to track how much of the FIFO is used, while ensuring that we don’t write to a full FIFO or read from an empty FIFO.</p>
<p class="TX">On the write side, the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> output goes high when all the locations within the FIFO have been written to. When the user sees <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> go high, they must stop writing to the FIFO until some space frees up and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> <span aria-label=" Page 118. " epub:type="pagebreak" id="pg_118" role="doc-pagebreak"/>goes low again. As you know by now, writing to a full FIFO is very bad and should be avoided.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> signals, also on the write side, aren’t always included in FIFO modules, but they can be very helpful. <samp class="SANS_TheSansMonoCd_W5Regular_11">AF</samp> is short for <i>almost full</i>, and these signals allow the user to set a watermark in the FIFO before it fills up completely. If the number of elements (sometimes called <i>words</i>) in the FIFO is greater than or equal to the value set by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> will be high. Otherwise, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> will be low. This feature is particularly useful in situations where data is written to the FIFO in batches. For example, say the write interface <i>must</i> write a minimum of four elements at a time in a burst, meaning once the interface starts writing it can’t stop, even if the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> flag goes high mid-burst. To prevent data loss, we would want to set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> to <i>depth</i> <span class="symbol">−</span> 4 and then check that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> is low before writing each burst of four elements. This ensures that there will be space in the FIFO for all four elements, before the write operation begins.</p>
<p class="TX">The read side has a similar set of FIFO-specific signals. <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp> will be high when the FIFO has no data in it. To ensure that we never read from an empty FIFO, we should check the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp> flag before attempting to read data out to know if there’s data available for reading.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> signals behave similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp>, guaranteeing that a burst of reads is possible without the FIFO becoming empty mid-burst (<samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp> is short for <i>almost empty</i>). For example, say your FIFO is 1,024 bits deep and 1 byte wide, and you have an LPDDR interface that requires data to be written in 256-byte bursts. Again, since a burst can’t be interrupted, you can’t simply stop reading if the FIFO becomes empty partway through the read. To guarantee that at least 256 bytes will be available to be pulled from the FIFO before sending a burst of data to the LPDDR, set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp> to 256, and check that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> is low before reading data.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If you don’t need almost full or almost empty behaviors for your application, you can just ignore the i_AF_Level, o_AF_Flag, i_AE_Level, and o_AE_Flag signals in your design.</i></p>
<p class="TX"><a href="#fig6-10">Figure 6-10</a> shows some examples summarizing what we’ve learned about FIFO signals.</p>
<figure class="IMG"><img alt="" class="img50" id="fig6-10" src="../images/Figure6-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-10: FIFO flag examples</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 119. " epub:type="pagebreak" id="pg_119" role="doc-pagebreak"/>The figure illustrates a FIFO with a depth of 12 words (the width isn’t important). For this example, let’s assume we’ve set <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp> to 4 and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> to 8. In the first row, we can see that if the FIFO has nothing in it, the count is zero and the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> signals are both set to 1. Remember that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> is set when the count is less than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp>. Next, we see that there are four words written, the FIFO is no longer empty, but <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> is still set. It’s not until the fifth word is written that <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp> goes low. All flags are low from words five through seven, but when there are eight words in the FIFO, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> goes high (since <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> was set to 8). When the FIFO is full, we see that both <samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> are high.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H2" id="sec17"><span id="h-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A FIFO Implementation</samp></h3>
<p class="TNI1">We’ll now consider the Verilog and VHDL for implementing the FIFO illustrated in <a href="#fig6-9">Figure 6-9</a>. This code adds features around the <samp class="SANS_TheSansMonoCd_W5Regular_11">RAM_2Port</samp> module discussed in <span class="Xref">“A RAM Implementation” on page 113</span> that convert the RAM into a FIFO. The complete code is available in the book’s GitHub repository, along with the testbenches that exercise it. I’m not showing the module signals or the instantiation of the memory (the dual-port RAM from the previous section) here, so we can focus on the functional code that makes the FIFO a FIFO:</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code><var>--snip--</var>
  always @(posedge i_Clk or negedge i_Rst_L)
  begin
  <span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> if (~i_Rst_L)
    begin
      r_Wr_Addr &lt;= 0;
      r_Rd_Addr &lt;= 0;
      r_Count   &lt;= 0;
    end
    else
    begin
    <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> if (i_Wr_DV)
      begin
        if (r_Wr_Addr == DEPTH-1)
          r_Wr_Addr &lt;= 0;
        else
          r_Wr_Addr &lt;= r_Wr_Addr + 1;
      end
   <span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> if (i_Rd_En)
     begin
       if (r_Rd_Addr == DEPTH-1)
         r_Rd_Addr &lt;= 0;
       else
         r_Rd_Addr &lt;= r_Rd_Addr + 1;
     end
   <span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> if (i_Rd_En &amp; ~i_Wr_DV)
     begin
       if (r_Count != 0)
       begin
         r_Count &lt;= r_Count - 1;
       end
     end
   <span aria-label="annotation5" class="CodeAnnotationCode-1">❺</span> else if (i_Wr_DV &amp; ~i_Rd_En)
     begin
       if (r_Count != DEPTH)
       begin
         r_Count &lt;= r_Count + 1;
       end
     end
      if (i_Rd_En)
      begin
        o_Rd_Data &lt;= w_Rd_Data;
      end
    end // else: !if(~i_Rst_L)
  end // always @ (posedge i_Clk or negedge i_Rst_L)
<span aria-label="annotation6" class="CodeAnnotationCode-1">❻</span> assign o_Full  = (r_Count == DEPTH) ||
                   (r_Count == DEPTH-1 &amp;&amp; i_Wr_DV &amp;&amp; !i_Rd_En);
  assign o_Empty = (r_Count == 0);
  assign o_AF_Flag = (r_Count &gt; DEPTH - i_AF_Level);
  assign o_AE_Flag = (r_Count &lt; i_AE_Level);
<var>--snip--</var></code></pre>
<p class="Label"><span aria-label=" Page 120. " epub:type="pagebreak" id="pg_120" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code><var>--snip--</var>
  process (i_Clk, i_Rst_L) is
  begin
  <span aria-label="annotation1" class="CodeAnnotationCode-1">❶</span> if not i_Rst_L then
      r_Wr_Addr &lt;= 0;
      r_Rd_Addr &lt;= 0;
      r_Count   &lt;= 0;
    elsif rising_edge(i_Clk) then
 
    <span aria-label="annotation2" class="CodeAnnotationCode-1">❷</span> if i_Wr_DV then
        if r_Wr_Addr = DEPTH-1 then
          r_Wr_Addr &lt;= 0;
        else
          r_Wr_Addr &lt;= r_Wr_Addr + 1;
        end if;
      end if;
    <span aria-label="annotation3" class="CodeAnnotationCode-1">❸</span> if i_Rd_En then
        if r_Rd_Addr = DEPTH-1 then
          r_Rd_Addr &lt;= 0;
        else<span aria-label=" Page 121. " epub:type="pagebreak" id="pg_121" role="doc-pagebreak"/>
          r_Rd_Addr &lt;= r_Rd_Addr + 1;
        end if;
      end if;
    <span aria-label="annotation4" class="CodeAnnotationCode-1">❹</span> if i_Rd_En = '1' and i_Wr_DV = '0' then
        if (r_Count /= 0) then
          r_Count &lt;= r_Count - 1;
        end if;
    <span aria-label="annotation5" class="CodeAnnotationCode-1">❺</span> elsif i_Wr_DV = '1' and i_Rd_En = '0' then
        if r_Count /= DEPTH then
          r_Count &lt;= r_Count + 1;
        end if;
      end if;
      if i_Rd_En = '1' then
        o_Rd_Data &lt;= w_Rd_Data;
      end if;
 
    end if;
  end process;
 
<span aria-label="annotation6" class="CodeAnnotationCode-1">❻</span> o_Full &lt;= '1' when ((r_Count = DEPTH) or
                      (r_Count = DEPTH-1 and i_Wr_DV = '1' and i_Rd_En = '0'))
                     else '0';
  o_Empty &lt;= '1' when (r_Count = 0) else '0';
 
  o_AF_Flag &lt;= '1' when (r_Count &gt; DEPTH - i_AF_Level) else '0';
  o_AE_Flag &lt;= '1' when (r_Count &lt; i_AE_Level) else '0';
<var>--snip--</var></code></pre>
<p class="TX">The bulk of this code is the main <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> block (in Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block (in VHDL), which handles memory addressing, counting the number of elements in the FIFO, and read and write operations. Notice that this block has a reset signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Rst_L</samp>, in the sensitivity list, in addition to a clock signal. If the reset signal goes low, then we’re in a reset state and we reset the signals that control the read address, the write address, and the FIFO count <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">_L</samp> at the end of the reset signal name is a clue that it’s active-low.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>As I mentioned earlier, FIFOs are useful for crossing clock domains, but this particular implementation of a FIFO cannot do this. It only has one clock, the i_Clk signal. Crossing clock domains is an advanced feature that we aren’t prepared to implement at this stage in the book.</i></p>
<p class="TX">Next, we create the logic for the write address <span aria-label="annotation2" class="CodeAnnotation">❷</span> and read address <span aria-label="annotation3" class="CodeAnnotation">❸</span>. For these, we simply increment the address each time we do a write or a read. When we reach the last address in the FIFO, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp>, we start over again at 0. Thanks to this system, elements are written to memory sequentially and they’re read from memory in the same order they were written, ensuring adherence to the first-in, first-out scheme.</p>
<p class="TX"><span aria-label=" Page 122. " epub:type="pagebreak" id="pg_122" role="doc-pagebreak"/>To keep track of the number of elements in the FIFO, first we check for the condition where we’re doing a read but not a write <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. In this case, the total number of elements in the FIFO goes down by 1. Next we check if we’re doing a write but not a read <span aria-label="annotation5" class="CodeAnnotation">❺</span>, in which case the total number of elements in the FIFO increases by 1. It’s also possible that we could be writing <i>and</i> reading at the same time, but notice that the code doesn’t explicitly handle this case. That’s intentional; in this situation, the count will remain the same. We could make this explicit by writing <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count;</samp>, but this isn’t necessary. By default, the count variable retains its value.</p>
<p class="TX">We also perform several signal assignments outside of the <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block <span aria-label="annotation6" class="CodeAnnotation">❻</span>. Recall that this will generate combinational (as opposed to sequential) logic. First we assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Full</samp> flag, which will be high when <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH</samp>, or when <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">DEPTH-1</samp> <i>and</i> there’s a write <i>and</i> there’s not a read. This second case lets the full flag “anticipate” the write and tell the higher-level module to stop writing, since the FIFO is about to be full.</p>
<p class="TX">Next we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Empty</samp> assignment, which is a bit simpler. When the count is zero, the FIFO is empty; otherwise, it’s not empty. After that we assign the almost full (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_AF_Flag</samp>) and almost empty (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_AE_Flag</samp>) flags. For these, we need to compare the count of the FIFO to the thresholds determined by <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AF_Level</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_AE_Level</samp>, respectively. This is the first time we’ve seen the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp> comparison operators being used in Verilog and VHDL. These are perfectly valid to include in combinational signal assignments.</p>
<p class="TX">By monitoring these status flags from a higher-level module, you’ll be able to precisely control when data can move into and out of the FIFO.</p>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h2 class="H1" id="sec18"><span id="h-85"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">In this chapter, you learned about several common building blocks in FPGA designs, including multiplexers and demultiplexers, shift registers, RAM, and FIFOs. You saw how these components work and learned how to implement them with Verilog and VHDL. With these foundational pieces of code, you can start to see how very large FPGA designs can be composed of many smaller modules structured together.</p>
</section>
</section>
</body>
</html>