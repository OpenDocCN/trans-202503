- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WHAT YOU NEED TO KNOW TO WRITE GREAT CODE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/comm1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *Write Great Code (WGC)* series will teach you how to write code you can
    be proud of; code that will impress other programmers, satisfy customers, and
    prove popular with users; and code that people (customers, your boss, and so on)
    won’t mind paying top dollar to obtain. In general, the books in the *[WGC](gloss01.xhtml#gloss01_262)*
    series will discuss how to write software that achieves legendary status, eliciting
    the awe and admiration of other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.1 The Write Great Code Series**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Write Great Code, Volume 1: Understanding the Machine* (*[WGC1](gloss01.xhtml#gloss01_263)*
    hereafter) is the first of six books in the *[WGC](gloss01.xhtml#gloss01_262)*
    series. Writing great code requires a combination of knowledge, experience, and
    skill that programmers usually obtain only after years of mistakes and discoveries.
    The purpose of this series is to share with both new and experienced programmers
    a few decades’ worth of observations and experience. I hope that these books will
    help reduce the time and frustration it takes to learn things “the hard way.”'
  prefs: []
  type: TYPE_NORMAL
- en: This book, *[WGC1](gloss01.xhtml#gloss01_263)*, fills in the low-level details
    that are often skimmed over in a typical computer science or engineering curriculum.
    These details are the foundation for the solutions to many problems, and you can’t
    write efficient code without this information. Though I’m attempting to keep each
    book independent, *[WGC1](gloss01.xhtml#gloss01_263)* might be considered a prerequisite
    for the subsequent volumes in the series.
  prefs: []
  type: TYPE_NORMAL
- en: '*Write Great Code, Volume 2: Thinking Low-Level, Writing High-Level* (*[WGC2](gloss01.xhtml#gloss01_264)*)
    immediately applies the knowledge from this book. *[WGC2](gloss01.xhtml#gloss01_264)*
    will teach you how to analyze code written in a high-level language to determine
    the quality of the machine code that a compiler would generate for it. Optimizing
    compilers don’t always generate the best machine code possible—the statements
    and data structures you choose in your source files can have a big impact on the
    efficiency of the compiler’s output. *[WGC2](gloss01.xhtml#gloss01_264)* will
    teach you how to write efficient code without resorting to assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many attributes of great code besides efficiency, and the third book
    in this series, *Write Great Code, Volume 3: Engineering Software* (*[WGC3](gloss01.xhtml#gloss01_265)*),
    will cover some of those. *[WGC3](gloss01.xhtml#gloss01_265)* will discuss software
    development metaphors, development methologies, types of developers, system documentation,
    and the Unified Modeling Language (UML). *[WGC3](gloss01.xhtml#gloss01_265)* provides
    the basis for personal software engineering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great code begins with a great design. *Write Great Code, Volume 4: Designing
    Great Code* (*[WGC4](gloss01.xhtml#gloss01_266)*), will describe the process of
    analysis and design (both structured and object-oriented). *[WGC4](gloss01.xhtml#gloss01_266)*
    will teach you how to translate an initial concept into a working design for your
    software systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write Great Code, Volume 5: Great Coding* (*[WGC5](gloss01.xhtml#gloss01_267)*)
    will teach you how to create source code that others can easily read and maintain,
    as well as how to improve your productivity without the burden of the “busy work”
    that many software engineering books discuss.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great code *works*. Therefore, I’d be remiss not to include a book on testing,
    debugging, and quality assurance. Few programmers properly test their code. This
    generally isn’t because they find testing boring or beneath them, but because
    they don’t know *how* to test their programs, eradicate defects, and ensure the
    quality of their code. To help overcome this problem, *Write Great Code, Volume
    6: Testing, Debugging, and Quality Assurance* (*[WGC6](gloss01.xhtml#gloss01_268)*)
    will describe how to efficiently test your applications without all the drudgery
    engineers normally associate with this task.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.2 What This Book Covers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to write great code, you need to know how to write efficient code,
    and to write efficient code, you must understand how computer systems execute
    programs and how abstractions in programming languages map to the low-level hardware
    capabilities of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, learning great coding techniques has required learning assembly
    language. While this isn’t a bad approach, it’s overkill. Learning assembly language
    involves learning two related subjects: machine organization, and programming
    in assembly language. The real benefits of learning assembly language come from
    the machine organization component. Thus, this book focuses solely on machine
    organization so you can learn to write great code without the overhead of also
    learning assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: Machine organization is a subset of computer architecture that covers low-level
    data types, internal CPU organization, memory organization and access, low-level
    machine operations, mass storage organization, peripherals, and how computers
    communicate with the rest of the world. This book concentrates on those parts
    of computer architecture and machine organization that are visible to the programmer
    or are helpful for understanding why system architects chose a particular system
    design. The goal of learning machine organization, and of this book, is not to
    enable you to design your own CPU or computer system, but to equip you to make
    the most efficient use of existing computer designs. Let’s do a quick run-through
    of the specific topics we’ll cover.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapters 2](ch02.xhtml#ch02), [4](ch04.xhtml#ch04), and [5](ch05.xhtml#ch05)
    deal with basic computer data representation—how computers represent signed and
    unsigned integer values, characters, strings, character sets, real values, fractional
    values, and other numeric and non-numeric quantities. Without a solid grasp of
    how computers represent these various data types internally, it’ll be difficult
    for you to understand why some operations that use these data types are so inefficient.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.xhtml#ch03) discusses binary arithmetic and bit operations
    used by most modern computer systems. It also offers several insights into how
    you can write better code by using arithmetic and logical operations in ways not
    normally taught in beginning programming courses. Learning these kinds of standard
    “tricks” is part of how you become a great programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.xhtml#ch06) introduces memory, discussing how the computer
    accesses its memory and describing characteristics of memory performance. This
    chapter also covers various machine code *[addressing modes](gloss01.xhtml#gloss01_8)*,
    which CPUs use to access different types of data structures in memory. In modern
    applications, poor performance often occurs because the programmer, unaware of
    the ramifications of memory access in their programs, creates bottlenecks. [Chapter
    6](ch06.xhtml#ch06) addresses many of these ramifications.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.xhtml#ch07) returns to data types and representation by covering
    composite data types and memory objects: pointers, arrays, records, structures,
    and unions. All too often, programmers use large composite data structures without
    even considering the memory and performance impact of doing so. The low-level
    description of these high-level composite data types will make clear their inherent
    costs, so you can use them sparingly and wisely.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.xhtml#ch08) discusses Boolean logic and digital design. This
    chapter provides the mathematical and logical background you’ll need to understand
    the design of CPUs and other computer system components. In particular, this chapter
    discusses how to optimize Boolean expressions, such as those found in common high-level
    programming language statements like `if` and `while`.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the hardware discussion from [Chapter 8](ch08.xhtml#ch08), [Chapter
    9](ch09.xhtml#ch09) discusses CPU architecture. A basic understanding of CPU design
    and operation is essential if you want to write great code. By writing your code
    in a manner consistent with how a CPU will execute it, you’ll get much better
    performance using fewer system resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.xhtml#ch10) discusses CPU instruction set architecture. Machine
    instructions are the primitive units of execution on any CPU, and the duration
    of program execution is directly determined by the number and type of machine
    instructions the CPU must process. Learning how computer architects design machine
    instructions can provide valuable insight into why certain operations take longer
    to execute than others. Once you understand the limitations of machine instructions
    and how the CPU interprets them, you can use this information to turn mediocre
    code sequences into great ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.xhtml#ch11) returns to the subject of memory, covering memory
    architecture and organization. This chapter is especially important for anyone
    wanting to write fast code. It describes the memory hierarchy and how to maximize
    the use of the cache and other fast memory components. You’ll learn about thrashing
    and how to avoid low-performance memory access in your applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapters 12](ch12.xhtml#ch12) through [15](ch15.xhtml#ch15) describe how computer
    systems communicate with the outside world. Many peripheral (input/output) devices
    operate at much lower speeds than the CPU and memory. You could write the fastest-executing
    sequence of instructions possible, and your application would still run slowly
    because you didn’t understand the limitations of the I/O devices in your system.
    These four chapters discuss generic I/O ports, system buses, buffering, handshaking,
    polling, and interrupts. They also explain how to efficiently use many popular
    PC peripheral devices, including keyboards, parallel (printer) ports, serial ports,
    disk drives, tape drives, flash storage, SCSI, IDE/ATA, USB, and sound cards.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.3 Assumptions This Book Makes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This book was written with certain assumptions about your prior knowledge.
    You’ll reap the greatest benefit from this material if your skill set matches
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You should be reasonably competent in at least one modern programming language.
    This includes C/C++, C#, Java, Swift, Python, Pascal/Delphi (Object Pascal), BASIC,
    and assembly, as well as languages like Ada, Modula-2, and FORTRAN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a small problem description, you should be capable of working through
    the design and implementation of a software solution for that problem. A typical
    semester or quarter course at a college or university (or several months’ experience
    on your own) should be sufficient background for this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, this book is not language specific; its concepts transcend
    whatever programming language(s) you’re using. Furthermore, this book does not
    assume that you use or know any particular language. To help make the examples
    more accessible, the programming examples rotate among several languages. This
    book explains exactly how the example code operates so that even if you’re unfamiliar
    with the specific programming language, you’ll be able to understand its operation
    by reading the accompanying description.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book uses the following languages and compilers in various examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'C/C++: GCC, Microsoft’s Visual C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pascal: Embarcadero’s Delphi, Free Pascal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assembly language: Microsoft’s MASM, HLA (High-Level Assembly), Gas (the Gnu
    Assembler; on the PowerPC and ARM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift 5 (Apple)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java (v6 or later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BASIC: Microsoft’s Visual Basic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, the examples appear in multiple languages, so it’s usually safe to ignore
    a specific example if you don’t understand the syntax of the language it uses.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.4 Characteristics of Great Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Different programmers will have different definitions for great code, so it’s
    impossible to provide an all-encompassing definition that will satisfy everyone.
    However, nearly everyone will agree that great code:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the CPU efficiently (that is, it’s fast)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses memory efficiently (that is, it’s small)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses system resources efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is easy to read and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follows a consistent set of style guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses an explicit design that follows established software engineering conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is easy to enhance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is well tested and robust (that is, it works)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is well documented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could easily add dozens of items to this list. Some programmers, for example,
    may feel that great code must be portable, must follow a given set of programming
    style guidelines, or must be written in a certain language (or *not* be written
    in a certain language). Some may feel that great code must be written as simply
    as possible, while others believe that it must be written quickly. Still others
    may feel that great code is created on time and under budget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition this book uses:'
  prefs: []
  type: TYPE_NORMAL
- en: Great code is software that is written using a consistent and prioritized set
    of good software characteristics. In particular, great code follows a set of rules
    that guide the decisions a programmer makes when implementing an algorithm as
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Two different programs do not have to follow the same set of rules (that is,
    they need not possess the same set of characteristics) in order for both to be
    great. In one environment, the priority might be producing code that’s portable
    across different CPUs and operating systems. In a different environment, efficiency
    (speed) might be the primary goal, and portability might not be an issue. Neither
    program would qualify as great according to the rules of the other, but as long
    as the software consistently follows the guidelines established for that particular
    program, you can argue that it is an example of great code.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.5 The Environment for This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although this book presents generic information, parts of the discussion will
    necessarily be specific to a particular system. Because the Intel Architecture
    PCs are, by far, the most common in use today, this book will use that platform
    when discussing specific system-dependent concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the specific examples in this book run on a late-model Intel Architecture
    (including AMD) CPU under macOS, Windows, or Linux, with a reasonable amount of
    RAM and other system peripherals normally found on a late-model PC. This book
    attempts to stick with standard library interfaces to the operating system (OS)
    wherever possible, and it makes OS-specific calls only when the alternative is
    to write “less than great” code. The concepts, if not the software itself, will
    apply to Android, Chrome, iOS, Macs, Unix boxes, embedded systems, and even mainframes,
    though you may need to research how to apply a concept to your platform.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.6 Additional Tips**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No single book can completely cover everything you need to know in order to
    write great code. This book, therefore, concentrates on the areas that are most
    pertinent for machine organization, providing the 90 percent solution for those
    who are interested in writing the best possible code. To get that last 10 percent
    you’ll need additional help. Here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learn assembly language.** Fluency in at least one assembly language will
    fill in many missing details that you just won’t get by learning machine organization
    alone. Unless you plan to use assembly language in your software systems, you
    don’t have to learn it on the platform(s) to which you’re targeting your software.
    Probably your best bet is to learn 80x86 assembly language on a PC, because there
    are lots of great software tools for learning Intel Architecture assembly language
    (for example, HLA) that simply don’t exist on other platforms. The point of learning
    assembly language here is not to write assembly code, but to learn the assembly
    paradigm. If you know 80x86 assembly language, you’ll have a good idea of how
    other CPUs (such as the ARM or the IA-64 family) operate.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Study advanced computer architecture.** Machine organization is a subset
    of computer architecture, but space limitations prevent full coverage of both
    in this book. While you may not need to know how to design your own CPUs, studying
    computer architecture might teach you something omitted here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.7 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hennessy, John L., and David A. Patterson. *Computer Architecture: A Quantitative
    Approach*. 5th ed. Waltham, MA: Morgan Kaufmann, 2012.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  prefs: []
  type: TYPE_NORMAL
