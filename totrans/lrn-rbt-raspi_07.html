<html><head></head><body>
<h2 class="h2a" id="ch07">7<br/><span epub:type="pagebreak" id="page_145"/>LINE FOLLOWING</h2>&#13;
<p class="startpara">IN THIS CHAPTER YOU’LL GIVE YOUR ROBOT THE ABILITY TO DETECT AND FOLLOW A LINE AUTONOMOUSLY. IT WILL BE ABLE TO IDENTIFY ITS OWN COURSE AND THEN DECIDE EXACTLY HOW TO STICK TO IT.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_146"/>This is a test of both digital recognition and clever programming. It is also a classic robotics task that is important for everyone to master, from beginners to professionals. By the end of this project you’ll have a fully autonomous robot that will be able to stick to a line like glue!</p>&#13;
<h3 class="h3" id="ch07lev1sec1">CREATING A TRACK</h3>&#13;
<p class="noindent">As usual, prior to launching into any project, it is important and useful to step back and analyze the task at hand. The aim here is to make your robot follow a line. More specifically, you want to make your robot follow a black line on a white background, like the one shown in <a href="ch07.xhtml#ch07fig1">Figure 7-1</a>.</p>&#13;
<div class="image" id="ch07fig1"><img alt="image" src="../images/f146-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-1</strong> My robot following a black line</p>&#13;
<p class="indent">The combination of white and black provides maximum contrast for your robot, enabling us to use simple line-following sensors.</p>&#13;
<p class="indent">The first thing to do is create a line for your robot to follow. You can make the shape of this track as adventurous as you like. The simplest option is a basic loop, but feel free to get creative, as long as the background is white and the line is black. I also recommend making the width of the line around 1/4 inch.</p>&#13;
<p class="indent">There are many different ways of constructing a track. You could simply grab a large piece of paper (at least ledger size, roughly 11 × 17 inches) and draw a thick line with a black marker. You could <span epub:type="pagebreak" id="page_147"/>use some black electrical tape on white poster board. You can even purchase premade line-following tracks online. If you have access to a printer, I recommend printing a track out on letter-size paper and assembling it with tape.</p>&#13;
<p class="indent">I’ve also included the template for a set of tiles you can make into a track of any shape in the resources for this book, which you can access on your Windows, Mac, or Linux PC:</p>&#13;
<ol>&#13;
<li class="noindent">If you haven’t done so already, download the software bundle from <a href="https://nostarch.com/raspirobots/"><em>https://nostarch.com/raspirobots/</em></a> onto your personal computer.</li>&#13;
<li class="noindent">Navigate to the folder where the software is stored, and then open the PDF named <em>track_generator.pdf</em>. This is a 34-page document that has a variety of 20 × 20 cm tiles with different lines on them (see <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>).&#13;
<div class="image" id="ch07fig2"><img alt="image" src="../images/f147-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-2</strong> The <em>track_generator.pdf</em> document</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_148"/>Print out whichever lines you want to put together into a track, cut them out, and then stick them together to form your own custom track. The first few pages of the PDF document show simple paths, such as straight lines and corners, but the farther down you scroll, the crazier the paths get!</p>&#13;
<p class="indent">For your first track, I recommend keeping it relatively simple. Remember that you can always print out more tiles and make a more difficult course for your robot in the future.</p></li>&#13;
<li class="noindent">To create a simple loop, like the one in <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>, print out four copies of Tile Type #2 (the straight line) and four copies of Tile Type #3 (the basic corner). You should be able to print these pages specifically using the printer dialog box of your PDF reader software. Ensure that each tile takes up one letter-size piece of paper.</li>&#13;
<li class="noindent">Use scissors to cut around the dotted line of each tile. Then arrange them in a loop, as shown in <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>, and use tape along the length of the <em>underside</em> to join the edges of the tiles together. Your track is now complete!</li>&#13;
</ol>&#13;
<div class="note">&#13;
<p class="note-warning">WARNING</p>&#13;
<p class="note-warning1"><em>Make sure you don’t tape over the black line when you connect the tiles, as this may affect the sensors’ performance. Also try to eliminate any gaps or wrinkles between tiles—these can hinder your robot’s movement!</em></p>&#13;
</div>&#13;
<div class="image" id="ch07fig3"><img alt="image" src="../images/f148-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-3</strong> My assembled basic line-following track</p>&#13;
<h3 class="h3" id="ch07lev1sec2"><span epub:type="pagebreak" id="page_149"/>THE THEORY BEHIND LINE FOLLOWING</h3>&#13;
<p class="noindent">We’re going to use <em>infrared</em> (IR) sensors to make your Raspberry Pi robot follow the black line. We used similar technology for obstacle avoidance in <a href="ch05.xhtml#ch05">Chapter 5</a>, when we used ultrasound for the purpose of detecting objects. But instead of sound, in this chapter we’ll use invisible light. Fortunately, much of the same theory you learned previously can be applied here too.</p>&#13;
<p class="indent">Every IR sensor, like the one in <a href="ch07.xhtml#ch07fig4">Figure 7-4</a>, has two small bulb-like devices—an infrared transmitter and a receiver, normally arranged and positioned closely together. The transmitter is an IR LED that, when triggered, fires off a pulse of infrared light. The receiver, an IR photodiode, then waits for this transmitted light to return. A <em>photo­diode</em> is simply a device that uses light to vary an electric current.</p>&#13;
<div class="image" id="ch07fig4"><img alt="image" src="../images/f149-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-4</strong> An IR sensor</p>&#13;
<p class="indent">Light interacts differently with different types of surfaces. Most notably, light is <em>reflected</em> more by a white surface, and almost totally <em>absorbed</em> by a black surface, enabling the IR sensor to detect black lines on white backgrounds.</p>&#13;
<p class="indent">As depicted in <a href="ch07.xhtml#ch07fig5">Figure 7-5</a>, if an IR sensor module is over a white surface, the receiver will detect the reflection of the infrared beam emitted by the transmitter. If the sensor is over a black surface, like the line of your track, the receiver will not detect the reflection. This difference in reflectance allows the sensor module to detect whether or not there is a line in front of it.</p>&#13;
<div class="image" id="ch07fig5"><img alt="image" src="../images/f150-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-5</strong> The different behavior of IR light as it meets a white versus a black surface</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_150"/>Mounting a single IR sensor onto the bottom of your robot would enable it to detect the presence of a black line, but if your robot moved so the sensor was no longer directly over the line, it could easily go off-track. With only one sensor, there is no easy way for your robot to detect whether it has gone too far to the left or right of the line. <span epub:type="pagebreak" id="page_151"/>Instead, we’ll use two IR sensors, both mounted on the bottom of your robot at the front, about an inch apart. Two sensors will provide a feedback mechanism with a sense of direction. There are four possibilities for the outputs of these sensors, each of which will guide the robot:</p>&#13;
<ul>&#13;
<li class="noindent">If both sensors receive a reflected signal and detect white, the robot can assume that the line must be in between the sensors. Therefore, the robot should move forward in a straight line (see <a href="ch07.xhtml#ch07fig6">Figure 7-6</a>).&#13;
<div class="image" id="ch07fig6"><img alt="image" src="../images/f151-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-6</strong> The robot moves forward when both sensors detect white.</p></li>&#13;
<li class="noindent">If the left sensor doesn’t receive a reflected signal but the right sensor does, this must mean that the left sensor detects the line. This indicates that the robot must be veering right, so it should turn left to correct itself, as in <a href="ch07.xhtml#ch07fig7">Figure 7-7</a>.</li>&#13;
<li class="noindent">If the right sensor detects the line but the left sensor doesn’t, the robot should correct itself by turning right, as shown at the bottom of <a href="ch07.xhtml#ch07fig7">Figure 7-7</a>.&#13;
<div class="image" id="ch07fig7"><img alt="image" src="../images/f152-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-7</strong> The robot turns left or right if one of the sensors detects the black line.</p></li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_152"/><span epub:type="pagebreak" id="page_153"/>Finally, if neither sensor receives a reflected signal, then they must <em>both</em> be reading black, as shown in <a href="ch07.xhtml#ch07fig8">Figure 7-8</a> (this won’t happen if you’re using just a basic loop track). What to do next is up to you, but one option is simply to make the robot stop. If you experiment with other track layouts—for example, a figure 8 shape—you might run into other situations where both sensors detect black. In these circumstances you may want your robot to move forward, turn, or even reverse—play around to find out what works best!</li>&#13;
</ul>&#13;
<div class="image" id="ch07fig8"><img alt="image" src="../images/f153-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-8</strong> The robot stops if both sensors read black.</p>&#13;
<h3 class="h3" id="ch07lev1sec3">USING AN IR SENSOR TO DETECT A LINE</h3>&#13;
<p class="noindent">Before you start mounting two IR sensors to your Raspberry Pi and configuring the code behind a complete line-following robot, let’s wire up just one IR sensor and test its line detection response.</p>&#13;
<h4 class="h4" id="ch07lev2sec1">The Parts List</h4>&#13;
<p class="noindent">For this part of the project you’ll use only one sensor, but make sure to buy two, as you’ll need both for the next project!</p>&#13;
<ul>&#13;
<li class="noindent">2 TCRT5000-based infrared line-following sensor modules</li>&#13;
<li class="noindent">Jumper wires</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>TCRT5000-based line-following sensor modules, like the one shown in <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>, are very common and available online for less than a couple of dollars each. I sourced mine from eBay by searching “TCRT5000 Line Follow Module.” The <em>TCRT5000</em> part of the sensor name refers to the infrared optical sensor, the small black component on the underside of the board.</p>&#13;
<div class="image" id="ch07fig9"><img alt="image" src="../images/f154-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-9</strong> My TCRT5000 infrared line-following sensor module</p>&#13;
<p class="indent">Make sure to get a line-following <em>module</em> like the one in <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>, as this means the functionality of the optical sensor has been neatly packaged into an easy-to-use component. These boards have a simple set of pins and require just three connections (see <a href="ch07.xhtml#ch07fig10">Figure 7-10</a>).</p>&#13;
<div class="image" id="ch07fig10"><img alt="image" src="../images/f154-02.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-10</strong> Pinout of a TCRT5000 IR sensor module</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_155"/>The infrared diode is housed inside the small black component and emits an infrared ray continuously when the module is connected to power. If the light is not reflected back into the sensor, it means a black line must be present and the output pin (OUT) of the module goes low (that is, it drops the voltage). This simple digital logic is ideal and, better still, the module can be powered natively from the Pi’s 3.3 V. This saves us from having to use a voltage divider circuit as we did for the ultrasonic distance sensor in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;
<div class="note">&#13;
<p class="note1"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>Remember that you don’t need to disconnect any of your previous circuits, but I won’t show those connections here.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch07lev2sec2">Wiring Up Your TCRT5000 Line-Following Sensor Module</h4>&#13;
<p class="noindent">Disconnect your Pi from power and wire up your sensor by following these instructions:</p>&#13;
<ol>&#13;
<li class="noindent">Use an F-F jumper wire to connect the VCC pin of your TCRT5000 module to physical pin 1 of your Raspberry Pi. This is the +3.3 V connection and provides power to the sensor.</li>&#13;
<li class="noindent">Use another jumper wire to connect the GND pin of your module to the common ground rail on your breadboard. So far, your wiring should look like <a href="ch07.xhtml#ch07fig11">Figure 7-11</a>.&#13;
<div class="image" id="ch07fig11"><img alt="image" src="../images/f155-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-11</strong> Line-following sensor connected to +3.3 V and GND</p></li>&#13;
<li class="noindent">Use another jumper wire to connect the data output pin of your sensor (OUT) to physical pin 21 on your Raspberry Pi. This is BCM 9. Your complete circuit should look like <a href="ch07.xhtml#ch07fig12">Figure 7-12</a>.</li>&#13;
</ol>&#13;
<div class="image" id="ch07fig12"><img alt="image" src="../images/f156-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-12</strong> Completed breadboard diagram with your TCRT5000 line-following sensor module wired up and in place</p>&#13;
<h4 class="h4" id="ch07lev2sec3"><span epub:type="pagebreak" id="page_156"/>Programming Your Raspberry Pi to Detect a Line</h4>&#13;
<p class="noindent">Now that you have a line sensor connected to your Raspberry Pi, let’s write some code to test its line detection response. Connect your Pi to power via a wall outlet, boot it up and move into your code folder, and then enter the following to create and open a test program called <em>line_test.py</em>:</p>&#13;
<p class="codesingle"><span class="p1-green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">nano line_test.py</span></p>&#13;
<p class="indent">Add the code in <a href="ch07.xhtml#ch07list1">Listing 7-1</a>, which will test your TCRT5000 module. The purpose of this program is to simply output to the terminal to inform the user whether the module has detected a line.</p>&#13;
<p class="programs">   <span class="p-blue">import</span> gpiozero<br/>   <span class="p-blue">import</span> time<br/><br/><span class="ent">➊</span> line_sensor = gpiozero.DigitalInputDevice(9)<br/><br/>   <span class="p-blue">while</span> <span class="p-purple">True</span>:<br/>      <span class="ent">➋</span> <span class="p-blue">if</span> line_sensor.is_active == <span class="p-purple">False</span>:<br/>                  <span class="p-blue">print</span>(<span class="p1-green">"Line detected"</span>)<br/>      <span class="ent">➌</span> <span class="p-blue">else</span>:<br/>                  <span class="p-blue">print</span>(<span class="p1-green">"No line detected"</span>)<br/>      <br/>          time.sleep(0.2)      </p>&#13;
<p class="listing" id="ch07list1"><strong>LISTING 7-1</strong> Detecting a line</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_157"/>After importing the usual libraries, we set up the line sensor as a digital input on BCM 9 <span class="ent">➊</span>.</p>&#13;
<div class="note">&#13;
<p class="note1"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>The TCRT5000 has a detection distance between 1 mm and 8 mm. If the line is farther away from the sensor than this, it is likely to give false positives or negatives.</em></p>&#13;
</div>&#13;
<p class="indent">We then start an infinite <span class="literal">while True</span> loop containing the logic of the program. At <span class="ent">➋</span> we use an <span class="literal">if</span> statement to detect whether the line sensor is active. If it <em>isn’t</em> active, it must mean the infrared reflection has not returned and therefore the emitted rays have been absorbed by the black line. Thus, the line has been detected, and we indicate this to the user with the <span class="literal">print()</span> statement inside the <span class="literal">if</span> statement.</p>&#13;
<p class="indent">Any other scenario would mean that the line sensor is active and therefore is <em>not</em> detecting a line. The <span class="literal">else</span> statement <span class="ent">➌</span> catches this alternative scenario and outputs to the user that a line has not been detected. The program then waits for a fifth of a second and loops back around.</p>&#13;
<h4 class="h4" id="ch07lev2sec4">Running Your Program: Detect a Line!</h4>&#13;
<p class="noindent">After saving your program, grab a piece of your track to test out your sensor. To run the program, enter:</p>&#13;
<p class="codesingle"><span class="p1-green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 line_test.py</span></p>&#13;
<p class="indent">While there is nothing within range of the sensor, it may produce erratic results that will be displayed in the terminal. Bring your piece of track up to the module and move the line over the sensor. You should notice that as you move the piece, the terminal output will change to <span class="literal">Line detected</span>:</p>&#13;
<p class="programs"><span class="p1-green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 line_test.py</span><br/><span class="p-dark-blue">No line detected</span><br/><span class="p-dark-blue">No line detected</span><br/><span class="p-dark-blue">Line detected</span><br/><span class="p-dark-blue">Line detected</span></p>&#13;
<p class="indent">My particular sensor also has an LED on the top that changes state when the line comes into view.</p>&#13;
<p class="indent">If you’re having issues with your module and it’s not detecting the line very well, you can try a few things. First, try to limit inter­ference from other light sources by turning the lights off. Alternatively, some TCRT5000 modules have an on-board potentiometer to adjust their sensitivity. This usually looks like a piece of blue/white plastic with a place to insert a screwdriver. Use an appropriate screwdriver or other implement to twist this potentio­meter to see if it improves your readings.</p>&#13;
<h3 class="h3" id="ch07lev1sec4"><span epub:type="pagebreak" id="page_158"/>MAKE YOUR ROBOT FOLLOW A LINE AUTONOMOUSLY</h3>&#13;
<p class="noindent">When your sensor is successfully detecting the line, it’s time to give your robot the ability to follow the track.</p>&#13;
<p class="indent">By the end of this project, you’ll have connected up a second sensor and programmed the logic behind a fully autonomous program, giving you a line-following robot.</p>&#13;
<h4 class="h4" id="ch07lev2sec5">Wiring Up the Second TCRT5000 Line-Following Sensor Module</h4>&#13;
<p class="noindent">You’ve already wired up the first TCRT5000 module, so now you only need to wire up the second one. If you don’t have the first one connected, flip back a few pages and follow the wiring guide in the previous project.</p>&#13;
<p class="indent">The process for connecting your second sensor is as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Take a F-F jumper wire and connect the VCC pin of your second TCRT5000 module to physical pin 17 on your Raspberry Pi. This is another +3.3 V pin and will power the sensor.</li>&#13;
<li class="noindent">Now, use a jumper wire to connect the GND pin of the new module to the common ground rail on your breadboard.</li>&#13;
<li class="noindent">Use a wire to connect the data output pin of your second sensor (OUT) to physical pin 23 on your Pi. This is BCM 11. The wiring for the second sensor, with the first sensor omitted, should look like <a href="ch07.xhtml#ch07fig13">Figure 7-13</a>.</li>&#13;
</ol>&#13;
<div class="image" id="ch07fig13"><img alt="image" src="../images/f158-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-13</strong> Second line-following sensor connected to power, ground, and data</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_159"/>With both line-following sensors connected, your breadboard should look something like <a href="ch07.xhtml#ch07fig14">Figure 7-14</a>.</p>&#13;
<div class="image" id="ch07fig14"><img alt="image" src="../images/f159-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-14</strong> Both line-following sensors connected to the Raspberry Pi</p>&#13;
<h4 class="h4" id="ch07lev2sec6">Mounting Your Sensors</h4>&#13;
<p class="noindent">Now you need to mount your TCRT5000 modules onto the underside of the front of your robot.</p>&#13;
<p class="indent">To avoid having to change the code demos later, make sure that the TCRT5000 module you wired up <em>first</em> (the one connected to BCM 9) is on the <em>left side</em> of your robot, and the <em>second</em> TCRT5000 module (connected to BCM 11) is on the <em>right side</em> of your robot.</p>&#13;
<p class="indent">You can mount these sensors to your chassis in whatever way you like. If you’re using a LEGO-based robot like mine, I recommend attaching two small stalks made of 2×2 LEGO blocks to the bottom of your chassis; mine are roughly four blocks deep. You can then also use sticky tack to affix your modules onto the bottom of the stalks as I have done (see <a href="ch07.xhtml#ch07fig15">Figure 7-15</a>). I have routed the wires for the sensors through the gap in the middle of my LEGO chassis.</p>&#13;
<div class="image" id="ch07fig15"><img alt="image" src="../images/f160-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-15</strong> My IR sensors, mounted on LEGO stalks on the underside of my robot</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_160"/>When mounting the modules, bear in mind that the optimal range from the optical sensor to the ground is between 1 mm and 8 mm. Also remember that the wider the gap between them, the more your robot will stray left or right before it corrects itself. For reference, mine are only an inch or two apart from each other and placed on either side of the front stabilizer.</p>&#13;
<h4 class="h4" id="ch07lev2sec7">Programming Your Robot to Follow a Line</h4>&#13;
<p class="noindent">With both your sensors wired up and mounted in place, it’s time to write the code that will allow your robot to follow a line.</p>&#13;
<p class="indent">Open up a new program using Nano and call it <em>line_follower.py</em> as follows:</p>&#13;
<p class="codesingle"><span class="p1-green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">nano line_follower.py</span></p>&#13;
<p class="indent">The code in <a href="ch07.xhtml#ch07list2">Listing 7-2</a> takes the theory and process behind line following we discussed previously and puts it all into practice. Take a moment to look over the code before you move on to the explanation.</p>&#13;
<p class="programs">   <span class="p-blue">import</span> gpiozero<br/><br/><span class="ent">➊</span> SPEED = 0.25<br/><br/>   robot = gpiozero.Robot(left=(17,18), right=(27,22))<br/><br/><span class="ent">➋</span> left = gpiozero.DigitalInputDevice(9)<br/>   right = gpiozero.DigitalInputDevice(11)<br/><br/>   <span class="p-blue">while</span> <span class="p-purple">True</span>:<br/>    <span class="ent">➌</span> <span class="p-blue">if</span> (left.is_active == <span class="p-purple">True</span>) <span class="p-blue">and</span> (right.is_active == <span class="p-purple">True</span>):<br/>             robot.forward(SPEED)<br/>    <span class="ent">➍</span> <span class="p-blue">elif</span> (left.is_active == <span class="p-purple">False</span>) <span class="p-blue">and</span> (right.is_active == <span class="p-purple">True</span>):<br/>             robot.right(SPEED)<br/>    <span class="ent">➎</span> <span class="p-blue">elif</span> (left.is_active == <span class="p-purple">True</span>) <span class="p-blue">and</span> (right.is_active == <span class="p-purple">False</span>):<br/>             robot.left(SPEED)<br/>    <span class="ent">➏</span> <span class="p-blue">else</span>:<br/>             robot.stop()</p>&#13;
<p class="listing" id="ch07list2"><strong>LISTING 7-2</strong> Following a line</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>The code here follows the same logical layout as previous projects in this book. We import <span class="literal">gpiozero</span>, then initiate a constant called <span class="literal">SPEED</span> and set it to 0.25 <span class="ent">➊</span>. This value, which represents the speed of your robot throughout the program, can be set to anything between 0 and 1.</p>&#13;
<p class="indent">When you run this code for the first time, you’ll discover that the speed at which your robot is traveling has a huge influence on its line-following ability. By defining a constant at the start of the program, you can easily tweak this setting without rifling through all of the rest of your code later.</p>&#13;
<p class="indent">At <span class="ent">➋</span> we set up the first TCRT5000 sensor as a digital input and assign it to the variable <span class="literal">left</span>. Then we repeat the process for the second line-following sensor, assigning it to the variable <span class="literal">right</span>.</p>&#13;
<p class="indent">We then begin an infinite <span class="literal">while True</span> loop that contains the main logic of the program: a series of <span class="literal">if</span> statements. This is where the line-following theory is implemented.</p>&#13;
<p class="indent">The code at <span class="ent">➌</span> deals with the scenario in which both sensors are active and therefore both reading white. With no line detected, the program assumes that the line is directly underneath and between the sensors, and the robot proceeds forward at its given speed.</p>&#13;
<p class="indent">Next, an <span class="literal">elif</span> statement <span class="ent">➍</span> catches the case when the left sensor is off and thus detecting black, but the right sensor is active and thus detecting white. In this scenario, we need to execute a corrective maneuver to turn the robot right.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>Then, an almost identical <span class="literal">elif</span> statement <span class="ent">➎</span> accounts for when the right sensor detects the black line. The corrective maneuver turns the robot left this time.</p>&#13;
<p class="indent">Finally, at <span class="ent">➏</span> we use an <span class="literal">else</span> statement to deal with the only option left: neither sensor is active and therefore both are reading black. The exact behavior of your robot after this is up to you to define. In my code I have decided to stop its movement.</p>&#13;
<h4 class="h4" id="ch07lev2sec8">Running Your Program: Make Your Robot Follow a Line!</h4>&#13;
<p class="noindent">With your line-following program now complete, connect your robot to battery power and place it on the test track you created earlier. For the best results, ensure that the black line is directly underneath your robot and between the two TCRT5000 sensors (see <a href="ch07.xhtml#ch07fig16">Figure 7-16</a>).</p>&#13;
<div class="image" id="ch07fig16"><img alt="image" src="../images/f162-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-16</strong> My robot in place, ready to follow the line</p>&#13;
<p class="indent">Run your program with this command:</p>&#13;
<p class="codesingle"><span class="p1-green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 line_follower.py</span></p>&#13;
<p class="indent">Your robot should now be moving around your track completely autonomously and sticking to the black line with no trouble at all. Admire your work as the robot scuttles around in an endless loop!</p>&#13;
<div class="note">&#13;
<p class="note1"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>You may find that you need to stick your track down to the floor so that the wheels of your robot don’t move it around. If this is the case, just use some tape to securely and nonpermanently fix it in place.</em></p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="headbox">EXPERIMENTING WITH LINE FOLLOWING</p>&#13;
<p class="noindent">Line following is a classic lesson in robotics, but as you can probably tell, it can take a serious amount of tweaking and hacking to improve the effectiveness and results. You’ll probably have already noticed that you can alter many different factors to change the performance of your line follower. Here are some of my suggestions.</p>&#13;
<p class="boxhead1">Change the Track</p>&#13;
<p class="noindent">While a simple loop is a great first-time test bed, it quickly becomes boring. To challenge your robot, try creating a more adventurous track. Use tighter corners, longer straights, and more advanced geometries! You can even get inspiration for new layouts from real race tracks—for example, the Monaco Grand Prix circuit in <a href="ch07.xhtml#ch07fig17">Figure 7-17</a>.</p>&#13;
<div class="image" id="ch07fig17"><img alt="Image" src="../images/f163-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 7-17</strong> The Monaco Grand Prix circuit represented as a black line that your robot could follow</p>&#13;
<p class="boxhead1">Change the Speed</p>&#13;
<p class="noindent">The faster your robot is moving around the track, the less time it has to react to the information that the TCRT5000 sensors provide. At faster speeds, you may find that your robot drifts away from the line. You can change its speed by going back into the program and editing the <span class="literal">SPEED</span> constant defined at the top of the code.</p>&#13;
<p class="indent">You may also find that you want to change the speed of your line follower for different movements. For example, your robot may perform better if it goes around corners slower. You could add this functionality into the program by creating another constant called <span class="literal">CORNER_SPEED</span> and using it in the functions for turning left and right.</p>&#13;
<p class="indent">As you fine-tune the speed of your line-following robot, time it as it goes around the track. See how fast you can get it to accurately follow the line. You could even race against some friends and have a line-following racing tournament to see whose code is best.</p>&#13;
<p class="boxhead1">Change the Position of Your Sensors</p>&#13;
<p class="noindent">The farther apart the IR sensors are, the more your robot will stray from the line before executing a corrective maneuver. This could potentially lead to your robot fish-tailing along the line in a zigzag pattern. Experiment with moving the modules closer together to see how this affects how well your line follower operates.</p>&#13;
<p class="indent">You should find that the closer together the modules are, the more the robot will turn left and right to get back on track. This will mean that your robot follows the line more accurately, but at what cost? Does it affect the speed at which it can complete the course? Play around and find out!</p>&#13;
<p class="boxhead1">Add More Sensors</p>&#13;
<p class="noindent">If you want to take this even further, add more line-following sensors. Just like with obstacle avoidance, the more information your robot has about its position, the more intelligent the program behind it can be. If you can add a third, fourth, or even fifth TCRT5000 module, then you can judge the degree by which your robot has strayed from the line. You could then use this information to change the magnitude of course corrections. For example, if the robot is far away from the line, it could execute a faster corrective maneuver.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07lev1sec5">SUMMARY</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_163"/><span epub:type="pagebreak" id="page_164"/>In this chapter you’ve given your robot the ability to autonomously follow a line. We have covered everything from the theory of line following to the sensors you need and the code behind them.</p>&#13;
<p class="indent">In the next chapter I’ll show you how to use the official Raspberry Pi Camera Module to recognize and follow a colored ball!</p>&#13;
</body></html>