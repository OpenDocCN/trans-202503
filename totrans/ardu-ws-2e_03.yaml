- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building Blocks
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模块
- en: In this chapter you will
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将
- en: Learn how to read schematic diagrams, the language of electronic circuits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何阅读原理图，这是电子电路的“语言”
- en: Be introduced to the capacitor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解电容器
- en: Work with input pins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入引脚
- en: Use arithmetic and test values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用算术和测试值
- en: Make decisions with `if` statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`语句做决策
- en: Learn the difference between analog and digital
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习模拟与数字的区别
- en: Measure analog voltage sources at different levels of precision
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的精度水平下测量模拟电压源
- en: Be introduced to variable resistors, piezoelectric buzzers, and temperature
    sensors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可变电阻器、压电蜂鸣器和温度传感器
- en: Consolidate your knowledge by creating traffic lights, a battery tester, and
    a thermometer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过制作交通灯、电池测试仪和温度计来巩固你的知识
- en: The information in this chapter will help you understand an Arduino’s potential.
    We’ll continue to learn about electronics, including how to read schematic diagrams
    (the “road maps” of electronic circuits). We’ll also explore some new components
    and the types of signals that we can measure. Then we’ll discuss additional Arduino
    functions, such as storing values, performing mathematical operations, and making
    decisions. Finally, we’ll examine a few more components and put them to use in
    some useful projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容将帮助你理解Arduino的潜力。我们将继续学习电子学，包括如何阅读原理图（电子电路的“路线图”）。我们还将探索一些新的元件和我们可以测量的信号类型。然后我们将讨论更多Arduino功能，如存储值、执行数学运算和做决策。最后，我们将审视一些其他元件，并在一些有用的项目中加以使用。
- en: Using Schematic Diagrams
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原理图
- en: Chapter 3 described how to build a circuit using physical layout diagrams to
    represent the breadboard and components mounted on it. Although such physical
    layout diagrams may seem like the easiest way to diagram a circuit, you’ll find
    that as more components are added, diagrams that are direct representations can
    become a real mess. Because our circuits are about to get more complicated, we’ll
    start using *schematic diagrams* (also known as *circuit diagrams*) to illustrate
    them, such as the one shown in [Figure 4-1](#figure4-1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章描述了如何使用物理布局图来构建电路，这些布局图代表了面包板及其上安装的元件。虽然这种物理布局图看起来是绘制电路的最简单方式，但你会发现，随着更多元件的加入，直接表示的图纸会变得非常混乱。因为我们的电路将变得更加复杂，所以我们将开始使用*原理图*（也称为*电路图*）来说明它们，如[图
    4-1](#figure4-1)所示。
- en: '![f04001](image_fi/500587c04/f04001.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f04001](image_fi/500587c04/f04001.png)'
- en: 'Figure 4-1: Example of a schematic diagram'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：原理图示例
- en: Schematics are simply circuit road maps that show the path of the electrical
    current flowing through various components. Instead of showing components and
    wires, a schematic uses symbols and lines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图只是电路的路线图，显示了电流在各个元件中流动的路径。与显示元件和电线不同，原理图使用符号和线条来表示。
- en: Identifying Components
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别元件
- en: Once you know what the symbols mean, reading a schematic is easy. To begin,
    let’s examine the symbols for the components we’ve already used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道这些符号的含义，读取原理图就变得容易了。首先，让我们来看看我们已经使用过的元件符号。
- en: The Arduino
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Arduino
- en: '[Figure 4-2](#figure4-2) shows a symbol for the Arduino itself. As you can
    see, all of the Arduino’s connections are displayed and neatly labeled.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#figure4-2)展示了Arduino本身的符号。如你所见，所有Arduino的连接都被显示并清晰标记。'
- en: '![f04002](image_fi/500587c04/f04002.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f04002](image_fi/500587c04/f04002.png)'
- en: 'Figure 4-2: Arduino Uno symbol'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：Arduino Uno符号
- en: The Resistor
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电阻器
- en: The resistor symbol is shown in [Figure 4-3](#figure4-3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻器符号如[图 4-3](#figure4-3)所示。
- en: '![f04003](image_fi/500587c04/f04003.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![f04003](image_fi/500587c04/f04003.png)'
- en: 'Figure 4-3: Resistor symbol'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：电阻器符号
- en: It’s good practice to display the resistor value and part designator along with
    the resistor symbol (220 Ω and R1 in this case). This makes life a lot easier
    for everyone trying to make sense of the schematic (including you). Often you
    may see ohms written as *R* instead—for example, 220 R.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在电阻符号旁边显示电阻值和元件标识符（例如此处的220 Ω和R1）是一个很好的做法。这使得每个人在理解原理图时都更加轻松（包括你自己）。你常常会看到电阻值以*R*表示——例如220
    R。
- en: The Rectifier Diode
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 整流二极管
- en: The rectifier diode symbol is shown in [Figure 4-4](#figure4-4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 整流二极管符号如[图 4-4](#figure4-4)所示。
- en: '![f04004](image_fi/500587c04/f04004.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f04004](image_fi/500587c04/f04004.png)'
- en: 'Figure 4-4: Rectifier diode symbol'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：整流二极管符号
- en: Recall from Chapter 3 that rectifier diodes are polarized and current flows
    from the anode to the cathode. In the symbol shown in [Figure 4-4](#figure4-4),
    the anode is on the left and the cathode is on the right. An easy way to remember
    this is to think of current flowing toward the point of the triangle only. Current
    cannot flow the other way because the vertical bar “stops” it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第三章，整流二极管是有极性的，电流从阳极流向阴极。在[图 4-4](#figure4-4)所示的符号中，阳极位于左侧，阴极位于右侧。记住这一点的一个简单方法是想象电流只会流向三角形的尖端。电流不能反向流动，因为垂直条形“阻止”它。
- en: The LED
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LED
- en: The LED symbol is shown in [Figure 4-5](#figure4-5).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: LED符号如[图 4-5](#figure4-5)所示。
- en: '![f04005](image_fi/500587c04/f04005.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f04005](image_fi/500587c04/f04005.png)'
- en: 'Figure 4-5: LED symbol'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：LED符号
- en: 'All members of the diode family share a common symbol: the triangle and vertical
    line. However, LED symbols show two parallel arrows pointing away from the triangle
    to indicate that light is being emitted.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 二极管家族的所有成员都有一个共同的符号：三角形和垂直线。然而，LED符号显示两个平行箭头指向三角形的外侧，表示光正在发出。
- en: The Transistor
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 晶体管
- en: The transistor symbol is shown in [Figure 4-6](#figure4-6). We’ll use this to
    represent our BC548.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管符号如[图 4-6](#figure4-6)所示。我们将用这个符号表示我们的BC548。
- en: '![f04006](image_fi/500587c04/f04006.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![f04006](image_fi/500587c04/f04006.png)'
- en: 'Figure 4-6: Transistor symbol'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6：晶体管符号
- en: The vertical line at the top of the symbol (labeled *C*) represents the collector,
    the horizontal line at the left represents the base (labeled *B*), and the bottom
    line represents the emitter (labeled *E*). The arrow inside the symbol, pointing
    down and to the right, tells us that this is an *NPN*-type transistor, because
    NPN transistors allow current to flow from the collector to the emitter. (*PNP*-type
    transistors allow current to flow from the emitter to the collector.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 符号顶部的垂直线（标记为*C*）表示集电极，左侧的水平线表示基极（标记为*B*），底部的线表示发射极（标记为*E*）。符号内的箭头指向下方和右侧，告诉我们这是一个*NPN*型晶体管，因为NPN晶体管允许电流从集电极流向发射极。（*PNP*型晶体管允许电流从发射极流向集电极。）
- en: When numbering transistors we use the letter *Q*, just as we use *R* to number
    resistors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在编号晶体管时，我们使用字母*Q*，就像我们用*R*来编号电阻器一样。
- en: The Relay
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继电器
- en: The relay symbol is shown in [Figure 4-7](#figure4-7).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器符号如[图 4-7](#figure4-7)所示。
- en: '![f04007](image_fi/500587c04/f04007.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![f04007](image_fi/500587c04/f04007.png)'
- en: 'Figure 4-7: Relay symbol'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7：继电器符号
- en: Relay symbols can vary in many ways and may have more than one set of contacts,
    but all relay symbols share certain elements in common. The first is the *coil*,
    which is the curvy vertical line at the left. The second element is the relay
    *contacts*. The *COM* (for common) contact is often used as an input, and the
    contacts marked *NO* (normally open) and *NC* (normally closed) are often used
    as outputs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器符号可以有多种变体，且可能有多组触点，但所有继电器符号都有一些共同的元素。第一个是*线圈*，即左侧的弯曲垂直线。第二个元素是继电器*触点*。*COM*（公共端）触点通常用作输入，而标记为*NO*（常开）和*NC*（常闭）的触点通常用作输出。
- en: The relay symbol is always shown with the relay in the off state and the coil
    not *energized*—that is, with the COM and NC pins connected. When the relay coil
    is energized, the COM and NO pins will be connected in the symbol.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器符号总是显示在继电器处于断开状态，且线圈未*通电*的情况下——也就是说，COM和NC引脚连接在一起。当继电器线圈通电时，符号中COM和NO引脚将连接。
- en: Wires in Schematics
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原理图中的电线
- en: When wires cross or connect in schematics, they are drawn in particular ways,
    as shown in the following examples.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当电线在原理图中交叉或连接时，它们会按照特定的方式绘制，如下例所示。
- en: Crossing but Not Connected Wires
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交叉但未连接的电线
- en: When two wires cross but are not connected, the crossing can be represented
    in one of two ways, as shown in [Figure 4-8](#figure4-8). There is no one right
    way; it’s a matter of preference.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当两根电线交叉但未连接时，交叉可以通过两种方式表示，如[图 4-8](#figure4-8)所示。没有一种正确的方法，这取决于个人偏好。
- en: '![f04008](image_fi/500587c04/f04008.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![f04008](image_fi/500587c04/f04008.png)'
- en: 'Figure 4-8: Non-connecting crossed wires'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8：未连接的交叉电线
- en: Connected Wires
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接的电线
- en: When wires are meant to be physically connected, a *junction dot* is drawn at
    the point of connection, as shown in [Figure 4-9](#figure4-9).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当电线要物理连接时，会在连接点绘制*连接点*，如[图 4-9](#figure4-9)所示。
- en: '![f04009](image_fi/500587c04/f04009.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![f04009](image_fi/500587c04/f04009.png)'
- en: 'Figure 4-9: Two wires that are connected'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-9：连接的两根电线
- en: Wire Connected to Ground
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接到地的电线
- en: When a wire is connected back to ground (GND), the standard method is to use
    the symbol shown in [Figure 4-10](#figure4-10).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当一根线连接回地线（GND）时，标准方法是使用[图 4-10](#figure4-10)所示的符号。
- en: '![f04010](image_fi/500587c04/f04010.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![f04010](image_fi/500587c04/f04010.png)'
- en: 'Figure 4-10: The GND symbol'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-10：GND 符号
- en: The GND symbol at the end of a line in a schematic in this book tells you that
    the wire is physically connected to the Arduino GND pin.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中原理图中线路末端的 GND 符号告诉你，这根线与 Arduino 的 GND 引脚物理连接。
- en: Dissecting a Schematic
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解读原理图
- en: Now that you know the symbols for various components and their connections,
    let’s dissect the schematic we would draw for Project 1, on page 33 in Chapter
    3. Recall that you made five LEDs blink backward and forward.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了各种元件及其连接的符号，接下来让我们分析我们将在第 3 章第 33 页为项目 1 绘制的原理图。回想一下，你让五个 LED 前后闪烁。
- en: Compare the schematic shown in [Figure 4-11](#figure4-11) with Figure 3-13 on
    page 34, and you’ll see that using a schematic is a much easier way to describe
    a circuit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 比较[图 4-11](#figure4-11)所示的原理图与第 3 章第 34 页的图 3-13，你会发现使用原理图是一种更简便的方式来描述电路。
- en: '![f04011](image_fi/500587c04/f04011.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f04011](image_fi/500587c04/f04011.png)'
- en: 'Figure 4-11: Schematic for Project 1'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-11：项目 1 的原理图
- en: From now on, we’ll use schematics to describe circuits, and I’ll show you the
    symbols for new components as they’re introduced.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用原理图来描述电路，并且在引入新元件时，我会向你展示它们的符号。
- en: The Capacitor
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电容器
- en: A *capacitor* is a device that holds an electric charge. It consists of two
    conductive plates sandwiching an insulating layer that allows an electric charge
    to build up between the plates. When the current is stopped, the charge remains
    and can flow out of the capacitor (called *discharging* the capacitor) as soon
    as the charge voltage stored in the capacitor is presented with a new path for
    the current to take.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*电容器*是一种存储电荷的设备。它由两块导电板夹着一个绝缘层组成，允许电荷在两板之间积聚。当电流被切断时，电荷保持在电容器内，并可以在电容器中储存的电压遇到电流的新路径时（称为*放电*）流出。'
- en: Measuring the Capacity of a Capacitor
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量电容器的容量
- en: The amount of charge that a capacitor can store is measured in *farads*, and
    one farad is actually a very large amount. Therefore, you will generally find
    capacitors with values measured in picofarads or microfarads. One *picofarad*
    (pF) is 0.000000000001 of a farad, and one *microfarad* (μF) is 0.000001 of a
    farad. Capacitors are also manufactured to accept certain voltage maximums. In
    this book we’ll be working with low voltages only, so we won’t be using capacitors
    rated at greater than 10 V or so; it’s generally fine, however, to use higher-voltage
    capacitors in lower-voltage circuits. Common voltage ratings are 10, 16, 25, and
    50 V.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 电容器能存储的电荷量以*法拉*（farad）为单位，一法拉实际上是一个非常大的数值。因此，通常电容器的容量以皮法（pF）或微法（μF）为单位进行标注。一*皮法*（pF）是法拉的
    0.000000000001 倍，而一*微法*（μF）是法拉的 0.000001 倍。电容器也有额定的最大电压值。在本书中，我们只会使用低电压，因此我们不会使用额定电压超过
    10 V 的电容器；然而，通常可以在低电压电路中使用高电压电容器。常见的电压额定值为 10、16、25 和 50 V。
- en: Reading Capacitor Values
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读电容器数值
- en: Reading the value of a ceramic capacitor takes some practice, because the value
    is printed in a sort of code. The first two digits represent the value in picofarads,
    and the third digit is the multiplier in tens. For example, the capacitor shown
    in [Figure 4-12](#figure4-12) is labeled *104*. This equates to 10 followed by
    four zeros, or 100,000 pF (which is 100 nanofarads [nF] or 0.1 μF).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读陶瓷电容器的数值需要一些练习，因为其数值是以某种代码方式打印的。前两位数字代表皮法拉（pF）的数值，第三位数字是以十为倍数的乘数。例如，[图 4-12](#figure4-12)所示的电容器标注为*104*。这相当于
    10 后面跟着四个零，即 100,000 pF（即 100 纳法（nF）或 0.1 微法（μF））。
- en: Types of Capacitors
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电容器类型
- en: 'Our projects will use two types of capacitors: ceramic and electrolytic.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将使用两种类型的电容器：陶瓷电容器和电解电容器。
- en: Ceramic Capacitors
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陶瓷电容器
- en: '*Ceramic capacitors*, such as the one shown in [Figure 4-12](#figure4-12),
    are very small and therefore hold a small amount of charge. They are not polarized
    and can be used for current flowing in either direction. The schematic symbol
    for a non-polarized capacitor is shown in [Figure 4-13](#figure4-13).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*陶瓷电容器*，例如[图 4-12](#figure4-12)所示的电容器，非常小，因此储存的电荷量也很小。它们是非极性的，可以用于电流双向流动。非极性电容器的原理图符号如[图
    4-13](#figure4-13)所示。'
- en: '![f04012](image_fi/500587c04/f04012.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![f04012](image_fi/500587c04/f04012.png)'
- en: 'Figure 4-12: A 0.1 µF ceramic capacitor'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-12：一个 0.1 µF 陶瓷电容器
- en: '![f04013](image_fi/500587c04/f04013.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![f04013](image_fi/500587c04/f04013.png)'
- en: 'Figure 4-13: Non-polarized capacitor schematic symbol, with the capacitor’s
    value shown at the upper right'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-13：非极性电容器电路符号，电容器的数值显示在右上角
- en: Ceramic capacitors work beautifully in high-frequency circuits because they
    can charge and discharge very quickly due to their small capacitance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 陶瓷电容器在高频电路中表现优异，因为它们可以由于较小的电容而非常快速地充放电。
- en: Electrolytic Capacitors
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电解电容器
- en: '*Electrolytic capacitors*, like the one shown in [Figure 4-14](#figure4-14),
    are physically larger than ceramic types, offer increased capacitance, and are
    polarized. A marking on the cover shows either the positive (+) side or the negative
    (–) side. In [Figure 4-14](#figure4-14), you can see the stripe and the small
    negative (–) symbol that identifies the negative side. Like resistors, capacitors
    also have a level of tolerance with their values. The capacitor in [Figure 4-14](#figure4-14)
    has a tolerance of 20 percent and a capacitance of 100 μF.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*电解电容器*，如[图 4-14](#figure4-14)所示，物理尺寸大于陶瓷类型，提供更大的电容，并且是极性的。外壳上的标记显示了正（+）极或负（–）极。在[图
    4-14](#figure4-14)中，你可以看到条纹和标识负极的小负号（–）符号。像电阻一样，电容器的数值也有一定的公差。[图 4-14](#figure4-14)中的电容器公差为20%，电容值为100
    μF。'
- en: '![f04014](image_fi/500587c04/f04014.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![f04014](image_fi/500587c04/f04014.png)'
- en: 'Figure 4-14: An electrolytic capacitor'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-14：电解电容器
- en: The schematic symbol for electrolytic capacitors, shown in [Figure 4-15](#figure4-15),
    includes the + symbol to indicate the capacitor’s polarity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 电解电容器的电路符号，如[图 4-15](#figure4-15)所示，包含+符号以表示电容器的极性。
- en: '![f04015](image_fi/500587c04/f04015.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![f04015](image_fi/500587c04/f04015.png)'
- en: 'Figure 4-15: Polarized capacitor schematic symbol'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-15：极性电容器电路符号
- en: Electrolytic capacitors are often used to store larger electric charges and
    to smooth power supply voltages. Like a small temporary battery, they can smooth
    out the power supply and provide stability near circuits or parts that draw high
    currents quickly from the supply. This prevents unwanted dropouts and noise in
    your circuits. Luckily, the values of the electrolytic capacitor are printed clearly
    on the outside and don’t require decoding or interpretation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 电解电容器常用于存储较大的电荷并平滑电源电压。像一个小型的临时电池，它们可以平滑电源并提供在快速从电源抽取大电流的电路或部件附近的稳定性。这可以防止电路中出现不必要的掉电和噪声。幸运的是，电解电容器的数值清晰地印刷在外面，不需要解码或解释。
- en: You already have some experience generating basic forms of output using LEDs
    with your Arduino. Now it’s time to learn how to send input from the outside world
    into your Arduino using digital inputs, and to make decisions based on that input.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了一些使用LED生成基本输出的经验。现在是时候学习如何通过数字输入将外部世界的信息传入Arduino，并根据这些输入做出决策。
- en: Digital Inputs
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字输入
- en: In Chapter 3, we used digital I/O pins as outputs to turn LEDs on and off. We
    can use these same pins to accept input from users—as long as we limit our information
    to two states, high and low.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们使用数字I/O引脚作为输出，控制LED的开关。我们可以使用这些相同的引脚接受用户的输入——只要我们将信息限制为两种状态，高电平和低电平。
- en: The simplest form of digital input is a *push button*; several push buttons
    are shown in [Figure 4-16](#figure4-16). You can insert one of these directly
    into your solderless breadboard and wire it to an Arduino pin. When the button
    is pressed, current flows through the switch and into the digital input pin, which
    detects the presence of the voltage.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入的最简单形式是*按钮*；[图 4-16](#figure4-16)中展示了几个按钮。你可以将其中一个按钮直接插入无焊面包板并将其连接到 Arduino
    引脚。当按钮被按下时，电流通过开关流入数字输入引脚，后者检测到电压的存在。
- en: '![f04016](image_fi/500587c04/f04016.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![f04016](image_fi/500587c04/f04016.png)'
- en: 'Figure 4-16: Basic push buttons on a breadboard'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-16：面包板上的基本按钮
- en: Notice that the button at the bottom of the figure is inserted into the breadboard,
    bridging rows 23 and 25\. When the button is pressed, it connects the two rows.
    The schematic symbol for this push button is shown in [Figure 4-17](#figure4-17).
    The symbol represents the two sides of the button, which are numbered with the
    prefix *S*. When the button is pressed, the line bridges the two halves and allows
    voltage or current through.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，图底部的按钮已插入面包板，桥接了第23行和第25行。当按钮被按下时，它将连接这两行。该按钮的电路符号如[图 4-17](#figure4-17)所示。符号代表按钮的两侧，两侧的编号以*S*为前缀。当按钮被按下时，线路桥接两部分，允许电压或电流通过。
- en: '![f04017](image_fi/500587c04/f04017.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![f04017](image_fi/500587c04/f04017.png)'
- en: 'Figure 4-17: Push button schematic symbol'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-17：按钮电路符号
- en: 'Project #4: Demonstrating a Digital Input'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '项目 #4：演示数字输入'
- en: Our goal in this project is to create a button that turns on an LED for half
    a second when pressed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个项目中的目标是创建一个按钮，当按下时，点亮 LED 半秒钟。
- en: The Algorithm
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'Here is our algorithm:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的算法：
- en: Test whether the button has been pressed.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试按钮是否被按下。
- en: If the button has been pressed, turn on the LED for half a second and then turn
    it off.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按钮已被按下，点亮 LED 半秒钟，然后将其关闭。
- en: If the button has not been pressed, do nothing.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按钮未被按下，则不执行任何操作。
- en: Repeat indefinitely.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无限重复。
- en: The Hardware
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件部分
- en: 'Here’s what you’ll need to create this project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要的物品来创建这个项目：
- en: One push button
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮开关
- en: One LED
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 LED
- en: One 560 Ω resistor
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 560 Ω 电阻
- en: One 10 kΩ resistor
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 10 kΩ 电阻
- en: One 100 nF capacitor
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 100 nF 电容器
- en: Various connecting wires
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种连接线
- en: One breadboard
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Arduino and USB cable
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino 和 USB 电缆
- en: The Schematic
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电路图
- en: First, we create the circuit on the breadboard with the schematic shown in [Figure
    4-19](#figure4-19). Notice that the 10 kΩ resistor is connected between GND and
    digital pin 7\. We call this a *pull-down resistor,* because it pulls the voltage
    at the digital pin almost to zero. Furthermore, by adding a 100 nF capacitor across
    the 10 kΩ resistor, we create a simple *debounce* circuit to help filter out the
    switch bounce. When the button is pressed, the digital pin goes immediately to
    high. But when the button is released, digital pin 7 is pulled down to GND via
    the 10 kΩ resistor, and the 100 nF capacitor creates a small delay. This effectively
    covers up the bouncing pulses by slowing the drop of the voltage to GND, thereby
    eliminating most of the false readings due to floating voltage and erratic button
    behavior.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们根据 [图 4-19](#figure4-19) 中的电路图在面包板上搭建电路。注意，10 kΩ 电阻连接在 GND 和数字引脚 7 之间。我们称之为
    *下拉电阻*，因为它将数字引脚的电压几乎拉到零。此外，通过在 10 kΩ 电阻两端添加 100 nF 电容器，我们创建了一个简单的 *去抖动* 电路，帮助滤除开关抖动。当按钮按下时，数字引脚立即变为高电平。但是当按钮松开时，数字引脚
    7 通过 10 kΩ 电阻被拉到 GND，并且 100 nF 电容器产生了一个小的延迟。这有效地覆盖了抖动脉冲，减缓了电压下降到 GND 的速度，从而消除了大部分由于浮动电压和按钮不稳定行为引起的错误读取。
- en: '![f04019](image_fi/500587c04/f04019.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f04019](image_fi/500587c04/f04019.png)'
- en: 'Figure 4-19: Schematic for Project 4'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-19：项目 4 的电路图
- en: 'Because this is the first time you’re building a circuit with a schematic,
    follow these step-by-step instructions as you walk through the schematic; this
    should help you understand how the components connect:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是你第一次根据电路图搭建电路，所以请按照这些逐步说明来完成电路图的操作；这将帮助你理解各个组件如何连接：
- en: Insert the push button into the breadboard, as shown in [Figure 4-20](#figure4-20).![f04020](image_fi/500587c04/f04020.png)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮插入面包板，如 [图 4-20](#figure4-20) 所示。![f04020](image_fi/500587c04/f04020.png)
- en: 'Figure 4-20: The push button inserted into the breadboard'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-20：按钮插入面包板
- en: Now insert the 10 kΩ resistor, a short link wire, and the capacitor, as shown
    in [Figure 4-21](#figure4-21).![f04021](image_fi/500587c04/f04021.png)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在插入 10 kΩ 电阻、一根短接电线和电容器，如 [图 4-21](#figure4-21) 所示。![f04021](image_fi/500587c04/f04021.png)
- en: 'Figure 4-21: Adding the 10 kΩ resistor and the capacitor'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-21：添加 10 kΩ 电阻和电容器
- en: Connect one wire from the Arduino 5 V pin to the upper-right row for the button
    on the breadboard. Connect another wire from the Arduino GND pin to the same vertical
    row that connects to the left-hand sides of the wire link and the resistor. This
    is shown in [Figure 4-22](#figure4-22).![f04022](image_fi/500587c04/f04022.png)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Arduino 5 V 引脚连接一根电线到面包板上按钮的右上行。再连接另一根电线从 Arduino GND 引脚到与电线连接和电阻的左侧相连的同一垂直行。这如
    [图 4-22](#figure4-22) 所示。![f04022](image_fi/500587c04/f04022.png)
- en: 'Figure 4-22: Connecting the 5 V (red) and GND (black) wires'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-22：连接 5 V（红色）和 GND（黑色）电线
- en: Run a wire from Arduino digital pin 7 to the lower-right row for the button
    on the breadboard, as shown in [Figure 4-23](#figure4-23).![f04023](image_fi/500587c04/f04023.png)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Arduino 数字引脚 7 连接一根电线到面包板上按钮的右下行，如 [图 4-23](#figure4-23) 所示。![f04023](image_fi/500587c04/f04023.png)
- en: 'Figure 4-23: Connecting the button to the digital input'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-23：将按钮连接到数字输入
- en: Insert the LED into the breadboard with the short leg (the cathode) connected
    to the GND column and the long leg (the anode) in a row to the right. Next, connect
    the 560 Ω resistor to the right of the LED, as shown in [Figure 4-24](#figure4-24).![f04024](image_fi/500587c04/f04024.png)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED插入面包板，将短腿（阴极）连接到GND列，长腿（阳极）插入右侧的某一行。接着，将560 Ω电阻连接到LED的右侧，如[图 4-24](#figure4-24)所示。![f04024](image_fi/500587c04/f04024.png)
- en: 'Figure 4-24: Inserting the LED and 560 Ω resistor'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4-24：插入LED和560 Ω电阻
- en: Connect a wire from the right side of the 560 Ω resistor to Arduino digital
    pin 3, as shown in [Figure 4-25](#figure4-25).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一根导线从560 Ω电阻的右侧连接到Arduino数字引脚3，如[图 4-25](#figure4-25)所示。
- en: '![f04025](image_fi/500587c04/f04025.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f04025](image_fi/500587c04/f04025.png)'
- en: 'Figure 4-25: Connecting the LED branch to the Arduino'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-25：将LED分支连接到Arduino
- en: Before continuing, review the schematic for this circuit and check that your
    components are wired correctly. Compare the schematic against the actual wiring
    of the circuit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，查看该电路的原理图，检查你的元件是否正确连接。将原理图与实际电路连接进行对比。
- en: The Sketch
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 草图
- en: For the sketch, enter and upload [Listing 4-1](#listing4-1).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于草图，输入并上传[列表 4-1](#listing4-1)。
- en: '[PRE0]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: Digital input'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：数字输入
- en: After you’ve uploaded your sketch, tap the push button briefly. Your LED should
    stay on for half a second.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上传草图后，短按按钮。LED应该保持亮起约半秒钟。
- en: Understanding the Sketch
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解草图
- en: Let’s examine the new items in the sketch for Project 4—specifically, `#define`,
    digital input pins, and the `if` statement.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查项目 4 草图中的新内容——特别是`#define`、数字输入引脚和`if`语句。
- en: 'Creating Constants with #define'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`#define`创建常量
- en: 'Before `void setup()`, we use `#define` statements at 1 to create fixed values:
    when the sketch is compiled, the IDE replaces any instance of the defined word
    with the number that follows it. For example, when the IDE sees `LED` in the line
    at 2, it replaces it with the number `3`. Notice that we do not use a semicolon
    after a `#define` value.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`void setup()`之前，我们使用`#define`语句在第 1 行创建固定值：当草图被编译时，IDE会将定义的单词的每个实例替换为它后面的数字。例如，当IDE在第
    2 行看到`LED`时，它会将其替换为数字`3`。请注意，我们在`#define`值后面不使用分号。
- en: We’re basically using the `#define` statements to label the digital pins for
    the LED and button in the sketch. It’s a good idea to label pin numbers and other
    fixed values (such as a time delay) in this way, because if the value is used
    repeatedly in the sketch, then you won’t have to edit the same item more than
    once. In this example, `LED` is used three times in the sketch, but to change
    this value we’d have to edit its definition only once in its `#define` statement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上是使用`#define`语句在草图中给LED和按钮的数字引脚加标签。这样标注引脚编号和其他固定值（例如时间延迟）是一个好主意，因为如果该值在草图中被重复使用，你就不需要多次编辑相同的项。在这个例子中，`LED`在草图中使用了三次，但如果我们要更改这个值，只需在`#define`语句中的定义进行一次编辑。
- en: Reading Digital Input Pins
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取数字输入引脚
- en: 'To read the status of a button, we first define a digital I/O pin as an input
    in `void setup()` using the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取按钮的状态，我们首先在`void setup()`中定义一个数字I/O引脚作为输入，使用如下代码：
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, to discover whether the button is connecting a voltage through to the
    digital input (that is, it’s being pressed), we use `digitalRead(``pin``)`, where
    `pin` is the digital pin number to read. The function returns either `HIGH` (voltage
    is close to 5 V at the pin) or `LOW` (voltage is close to 0 V at the pin).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了发现按钮是否将电压连接到数字输入（即按钮被按下），我们使用`digitalRead(``pin``)`，其中`pin`是要读取的数字引脚编号。该函数返回`HIGH`（引脚上的电压接近5V）或`LOW`（引脚上的电压接近0V）。
- en: Making Decisions with if
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`if`做决策
- en: Using `if`, we can make decisions in our sketch and tell the Arduino to run
    different code depending on the decision. For example, in the sketch for Project
    4, we used [Listing 4-2](#listing4-2).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`，我们可以在我们的草图中做出决策，并告诉Arduino根据决策运行不同的代码。例如，在项目 4 的草图中，我们使用了[列表 4-2](#listing4-2)。
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-2: A simple `if-then` example'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-2：一个简单的`if-then`例子
- en: The first line in this code snippet begins with `if` because it tests for a
    condition. If the condition is true (that is, if the voltage is `HIGH`), then
    it means that the button is pressed. The Arduino will then run the code that is
    inside the curly brackets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一行以`if`开始，因为它测试某个条件。如果条件为真（即电压为`HIGH`），则表示按钮被按下。Arduino接着会执行花括号内的代码。
- en: To determine whether the button is pressed (`digitalRead(BUTTON)` is set to
    `HIGH`), we use a *comparison operator*, a double equal sign (`==`). If we were
    to replace `==` with `!=` (not equal to) in the sketch, then the LED would turn
    off when the button is pressed instead. Try it and see.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定按钮是否被按下（`digitalRead(BUTTON)` 设置为 `HIGH`），我们使用了一个*比较运算符*，即双等号（`==`）。如果我们将
    `==` 替换为 `!=`（不等于），那么当按钮被按下时，LED 会熄灭。试试看吧。
- en: Once you’ve had some success, try changing the length of time that the light
    stays on, or go back to Project 3 on page 38 in Chapter 3 and add a push button
    control. (Don’t disassemble this circuit, though; we’ll use it again in the next
    example.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你取得了一些成功，试着改变灯亮的时间，或者回到第3章第38页的项目3，添加一个按钮控制。（不过不要拆解这个电路，我们将在下一个例子中再次使用它。）
- en: 'Modifying Your Sketch: Making More Decisions with if-else'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改你的草图：使用 if-else 进行更多决策
- en: You can add another action to an `if` statement by using `else`. For example,
    if we rewrite [Listing 4-1](#listing4-1) by adding an `else` clause, as shown
    in [Listing 4-3](#listing4-3), then the LED will turn on *if* the button is pressed,
    or *else* it will be off. Using `else` forces the Arduino to run another section
    of code if the test in the `if` statement is not true.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `else` 为 `if` 语句添加另一个动作。例如，如果我们通过添加 `else` 子句来重写 [示例 4-1](#listing4-1)，如
    [示例 4-3](#listing4-3) 所示，那么当按钮被按下时，LED 将点亮，*否则* 它会熄灭。使用 `else` 会强制 Arduino 在 `if`
    语句中的测试不为真时运行另一段代码。
- en: '[PRE3]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-3: Adding `else`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3：添加 `else`
- en: Boolean Variables
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔变量
- en: 'Sometimes you need to record whether something is in either of only two states,
    such as on or off, or hot or cold. A *Boolean variable* is the legendary computer
    “bit” whose value can be only a zero (0, false) or one (1, true). As with any
    other variable, we need to declare it in order to use it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要记录某物是否处于两种状态中的任意一种，例如开或关，或热或冷。*布尔变量* 就是计算机中的“位”，它的值只能是零（0，假）或一（1，真）。与其他变量一样，我们需要声明它才能使用：
- en: '[PRE4]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the sketch, you can change the state of a Boolean with a simple reassignment,
    such as this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图中，你可以通过简单的重新赋值来改变布尔值的状态，例如这样：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because Boolean variables can only take on the values of true or false, they
    are well suited to making decisions using `if`. True/false Boolean comparisons
    work well with the comparison operators `!=` and `==`. Here’s an example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于布尔变量只能取真或假的值，它们非常适合用于 `if` 语句进行决策。真假布尔比较与比较运算符 `!=` 和 `==` 配合得很好。以下是一个示例：
- en: '[PRE6]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Comparison Operators
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: We can use various operators to make decisions about two or more Boolean variables
    or other states. These include the operators *not* (`!`), *and* (`&&`), and *or*
    (`||`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种运算符来判断两个或多个布尔变量或其他状态。这些运算符包括 *非*（`!`）、*与*（`&&`）和 *或*（`||`）。
- en: The not Operator
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非运算符
- en: 'The *not* operator is denoted by an exclamation mark (`!`). This operator is
    used as an abbreviation for checking whether something is *not true*. Here’s an
    example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*非* 运算符用感叹号（`!`）表示。这个运算符用于简化检查某事是否*不为真*。以下是一个示例：'
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The and Operator
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与运算符
- en: 'The logical *and* operator is denoted by `&&`. Using *and* helps reduce the
    number of separate `if` tests. Here’s an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑*与*运算符用 `&&` 表示。使用 *与* 运算符有助于减少单独的 `if` 测试次数。以下是一个示例：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The or Operator
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 或运算符
- en: 'The logical *or* operator is denoted by `||`. Using *or* is pretty intuitive.
    Here’s an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑*或*运算符用 `||` 表示。使用 *或* 运算符相当直观。以下是一个示例：
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Making Two or More Comparisons
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行两个或更多比较
- en: 'You can also make two or more comparisons using the same `if` statement. Here’s
    an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用相同的 `if` 语句进行两个或多个比较。这里有一个示例：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And you can use parentheses to set the order of operation. In the next example,
    the comparison in the parentheses is checked first and given a true or false state,
    and then that condition is subjected to the remaining test in the `if` statement:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用括号来设置操作的顺序。在下一个示例中，括号中的比较首先会被检查，并得到一个真假状态，然后该条件会接受 `if` 语句中的剩余测试：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, just like the examples of the not (`!`) operator before a value, simple
    true/false tests can be performed without requiring `== true` or `== false` in
    each test. The following code has the same effect as the preceding example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像之前使用 `!` 运算符对值进行的示例一样，简单的真假测试可以在不需要在每次测试中写 `== true` 或 `== false` 的情况下执行。以下代码与之前的示例效果相同：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, it’s possible to have the Arduino make a multitude of decisions
    using Boolean variables and comparison operators. Once you move on to more complex
    projects, this will become very useful.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用布尔变量和比较运算符，Arduino 可以做出多种决策。随着你进行更复杂的项目，这将变得非常有用。
- en: 'Project #5: Controlling Traffic'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '项目 #5：控制交通'
- en: Now let’s put our newfound knowledge to use by solving a hypothetical problem.
    As the town planners for a rural county, we have a problem with a single-lane
    bridge that crosses the river. Every week, one or two accidents occur at night,
    when tired drivers rush across the bridge without first stopping to see if the
    road is clear. We have suggested that traffic lights be installed, but the mayor
    wants to see them demonstrated before signing off on the purchase. We could rent
    temporary lights, but they’re expensive. Instead, we’ve decided to build a model
    of the bridge with working traffic lights using LEDs and an Arduino.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过解决一个假设问题来运用我们新学到的知识。作为一个乡村县城的城镇规划师，我们面临一个单车道桥梁的问题。每周，在夜间，疲劳驾驶的司机匆忙穿越桥梁，而没有先停下来检查道路是否畅通，这时经常发生一到两起事故。我们建议安装交通信号灯，但市长希望在签署购买合同前看到信号灯的演示。我们可以租用临时信号灯，但它们非常昂贵。于是，我们决定使用
    LED 和 Arduino 构建一个带有工作交通信号灯的桥梁模型。
- en: The Goal
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: Our goal is to install three-color traffic lights at each end of the single-lane
    bridge. The lights allow traffic to flow in only one direction at a time. When
    sensors located at either end of the bridge detect a car waiting at a red light,
    the lights will change and allow the traffic to flow in the opposite direction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在单车道桥梁的每一端安装三色交通灯。该灯只允许交通一次按一个方向流动。当桥梁两端的传感器检测到红灯前等待的车辆时，交通灯会改变，并允许交通向相反方向流动。
- en: The Algorithm
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: We’ll use two buttons to simulate the vehicle sensors at each end of the bridge.
    Each set of lights will have red, yellow, and green LEDs. Initially, the system
    will allow traffic to flow from west to east, so the west-facing lights will be
    set to green and the east-facing lights will be set to red.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个按钮来模拟桥梁两端的车辆传感器。每组灯都会有红、黄、绿三种 LED。初始时，系统将允许西向的交通流向东，因此西向的交通灯设为绿灯，东向的交通灯设为红灯。
- en: When a vehicle approaches the bridge (modeled by pressing the button) and the
    light is red, the system will turn the light on the opposite side from green to
    yellow to red, and then wait a set period of time to allow any vehicles already
    on the bridge to finish crossing. Next, the yellow light on the waiting vehicle’s
    side will blink as a “get ready” notice for the driver, and finally the light
    will change to green. The light will remain green until a vehicle approaches the
    other side, at which point the process repeats.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当车辆接近桥梁（通过按下按钮来模拟）且红灯亮起时，系统会将对面方向的交通信号灯从绿灯变为黄灯，再变为红灯，并等待一定时间，以允许已经在桥上的车辆完成通行。接下来，等待车辆一侧的黄灯会闪烁，作为对驾驶员的“准备好”提示，最后灯会变为绿灯。绿灯会一直保持，直到另一侧的车辆接近，此时整个过程会重复。
- en: The Hardware
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件
- en: 'Here’s what you’ll need to create this project:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你创建此项目所需的物品：
- en: Two red LEDs (LED1 and LED2)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个红色 LED（LED1 和 LED2）
- en: Two yellow LEDs (LED3 and LED4)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个黄色 LED（LED3 和 LED4）
- en: Two green LEDs (LED5 and LED6)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个绿色 LED（LED5 和 LED6）
- en: Six 560 Ω resistors (R1 to R6)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个 560 Ω 电阻（R1 至 R6）
- en: Two 10 kΩ resistors (R7 and R8)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 10 kΩ 电阻（R7 和 R8）
- en: Two 100 nF capacitors (C1 and C2)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 100 nF 电容（C1 和 C2）
- en: Two push buttons (S1 and S2)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个按键（S1 和 S2）
- en: One medium-sized breadboard
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个中型面包板
- en: Arduino and USB cable
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino 和 USB 数据线
- en: Various connecting wires
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种连接线
- en: The Schematic
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原理图
- en: Because we’re controlling only six LEDs and receiving input from two buttons,
    the design will not be too difficult. [Figure 4-26](#figure4-26) shows the schematic
    for our project.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只控制六个 LED 并接收来自两个按钮的输入，设计不会太复杂。[图 4-26](#figure4-26) 显示了我们项目的原理图。
- en: '![f04026](image_fi/500587c04/f04026.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![f04026](image_fi/500587c04/f04026.png)'
- en: 'Figure 4-26: Schematic for Project 5'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-26：项目 5 的原理图
- en: This circuit is basically a more elaborate version of the button and LED circuit
    in Project 4, with resistors, more LEDs, and another button.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电路基本上是项目 4 中按钮和 LED 电路的一个更复杂版本，增加了电阻器、更多的 LED 和另一个按钮。
- en: 'Be sure that the LEDs are inserted in the correct direction: the resistors
    connect to LED anodes, and the LED cathodes connect to the Arduino GND pin, as
    shown in [Figure 4-27](#figure4-27).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 LED 插入的方向正确：电阻连接到 LED 阳极，LED 阴极连接到 Arduino 的 GND 引脚，如[图 4-27](#figure4-27)所示。
- en: '![f04027](image_fi/500587c04/f04027.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![f04027](image_fi/500587c04/f04027.png)'
- en: 'Figure 4-27: The completed circuit'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-27：完成的电路
- en: The Sketch
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 草图
- en: And now for the sketch. Can you see how it matches our algorithm?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看一下草图。你能看到它是如何与我们的算法匹配的吗？
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our sketch starts by using `#define` at 1 to associate digital pin numbers with
    labels for all the LEDs used, as well as the two buttons. We have red, yellow,
    and green LEDs and a button each for the west and east sides of the bridge. The
    Boolean variable `trafficWest` at 2 is used to keep track of which way the traffic
    is flowing—`true` is west to east, and `false` is east to west.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的草图首先通过在第1行使用`#define`来将数字引脚号与所有使用的LED标签以及两个按钮的标签关联。我们有红色、黄色和绿色LED，以及每个桥面东西两侧的一个按钮。布尔变量`trafficWest`在第2行用于跟踪交通流向——`true`表示西到东，`false`表示东到西。
- en: The integer variable `flowTime` at 3 is the minimum period of time that vehicles
    have to cross the bridge. When a vehicle pulls up at a red light, the system extends
    this period to give the opposing traffic time to cross the bridge. The integer
    variable `changeDelay` at 4 is the elapsed time between changes of color from
    green to yellow to red.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 整型变量`flowTime`在第3行是车辆必须通过桥梁的最短时间。当车辆停在红灯前时，系统会延长此时间，以便对面来车有时间通过桥梁。整型变量`changeDelay`在第4行表示从绿色到黄色再到红色的颜色变化之间的经过时间。
- en: Before the sketch enters the `void loop()` section, it is set for traffic to
    flow from west to east in `void setup()`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图进入`void loop()`部分之前，它已经在`void setup()`中设置为从西向东的交通流向。
- en: Running the Sketch
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行草图
- en: 'Once it’s running, the sketch does nothing until one of the buttons is pressed.
    When the east button is pressed, the line:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始运行，草图将不做任何操作，直到按下其中一个按钮。当按下东侧按钮时，代码行：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ensures that the lights change only if the traffic is heading in the opposite
    direction. The rest of the `void loop()` section is composed of a simple sequence
    of waiting and then of turning on and off various LEDs to simulate the traffic
    lights’ operation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 确保只有当交通流向相反方向时，交通灯才会改变。`void loop()`部分的其余代码是由简单的等待序列组成，然后是开启和关闭各种LED以模拟交通灯的工作。
- en: Analog vs. Digital Signals
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟信号与数字信号
- en: In this section you’ll learn the difference between digital and analog signals,
    and you’ll learn how to measure analog signals with the analog input pins.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习数字信号和模拟信号的区别，并学习如何使用模拟输入引脚来测量模拟信号。
- en: Until now, our sketches have been using digital electrical signals, with just
    two discrete levels. Specifically, we used `digitalWrite(``pin``, HIGH)` and `digitalWrite(``pin``,
    LOW)` to blink an LED and `digitalRead()` to measure whether a digital pin had
    a voltage applied to it (`HIGH`) or not (`LOW`). [Figure 4-28](#figure4-28) is
    a visual representation of a digital signal that alternates between high and low.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的草图一直在使用数字电信号，只有两个离散的电平。具体来说，我们使用了`digitalWrite(``pin``, HIGH)`和`digitalWrite(``pin``,
    LOW)`来闪烁LED，并使用`digitalRead()`来测量数字引脚是否有电压（`HIGH`）或没有（`LOW`）。[图 4-28](#figure4-28)是数字信号的视觉表示，信号在高低电平之间交替。
- en: '![f04028](image_fi/500587c04/f04028.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![f04028](image_fi/500587c04/f04028.png)'
- en: 'Figure 4-28: A digital signal, with highs appearing as horizontal lines at
    the top and lows appearing at the bottom'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-28：数字信号，顶部的水平线表示高电平，底部表示低电平
- en: Unlike digital signals, analog signals can vary with an indefinite number of
    steps between high and low. For example, [Figure 4-29](#figure4-29) shows the
    analog signal of a sine wave. Notice that as time progresses, the voltage floats
    fluidly between high and low levels.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字信号不同，模拟信号可以在高低之间变化，且变化步数是无限的。例如，[图 4-29](#figure4-29)显示了正弦波的模拟信号。注意，随着时间的推移，电压在高低电平之间流动得非常平滑。
- en: '![f04029](image_fi/500587c04/f04029.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![f04029](image_fi/500587c04/f04029.png)'
- en: 'Figure 4-29: An analog signal of a sine wave'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-29：正弦波的模拟信号
- en: '![f04030](image_fi/500587c04/f04030.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![f04030](image_fi/500587c04/f04030.png)'
- en: 'Figure 4-30: Analog inputs on the Arduino Uno'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-30：Arduino Uno上的模拟输入
- en: With our Arduino, high is closer to 5 V and low is closer to 0 V, or GND. We
    can measure the voltage values of an analog signal with our Arduino using the
    six analog inputs shown in [Figure 4-30](#figure4-30). These analog inputs can
    safely measure voltages from 0 (GND) to no more than 5 V.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Arduino中，高电平接近5 V，低电平接近0 V或GND。我们可以使用[图 4-30](#figure4-30)中显示的六个模拟输入来测量模拟信号的电压值。这些模拟输入可以安全地测量从0（GND）到最多5
    V的电压。
- en: 'If you use the function `analogRead()`, then the Arduino will return a number
    between 0 and 1,023 in proportion to the voltage applied to the analog pin. For
    example, you might use `analogRead()` to store the value of analog pin 0 in the
    integer variable `a`, as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`analogRead()`函数，则Arduino将根据应用于模拟引脚的电压返回一个介于0和1,023之间的数字。例如，您可以使用`analogRead()`将模拟引脚0的值存储在整数变量`a`中，如下所示：
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Project #6: Creating a Single-Cell Battery Tester'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目#6：创建单节电池测试仪
- en: Although the popularity and use of cell batteries has declined, most people
    still have a few devices around the house, such as remote controls, clocks, or
    children’s toys, that use AA, AAA, C, or D cell batteries. These batteries carry
    much less than 5 V, so we can measure a cell’s voltage with our Arduino to determine
    the state of the cell. In this project, we’ll create a battery tester.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管电池的流行度和使用率有所下降，但大多数家庭仍然拥有一些设备，如遥控器、时钟或儿童玩具，这些设备使用AA、AAA、C或D型电池。这些电池的电压远低于5
    V，因此我们可以使用Arduino测量电池的电压，从而判断电池的状态。在这个项目中，我们将创建一个电池测试仪。
- en: The Goal
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: Single-cell batteries such as AAs usually have a voltage of about 1.6 V when
    new, which decreases with use and age. We will measure the voltage and express
    the battery condition visually with LEDs. We’ll use the reading from `analogRead()`,
    which we will convert to volts. The maximum voltage that can be read is 5 V, so
    we divide 5 by 1,024 (the number of possible values), which equals 0.0048\. We
    multiply the value returned by `analogRead()` by this number to get the reading
    in volts. For example, if `analogRead()` returns 512, then we multiply that reading
    by 0.0048, which equals 2.4576 V.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 单节电池（如AA电池）通常在新电池时电压约为1.6 V，使用和老化后电压会降低。我们将测量电压，并通过LEDs以视觉方式显示电池状态。我们将使用`analogRead()`的读取值，并将其转换为电压值。最大可读取的电压是5
    V，因此我们将5除以1,024（可能的值的数量），得到0.0048。我们将`analogRead()`返回的值乘以这个数字，以获取电压值。例如，如果`analogRead()`返回512，则将该读取值乘以0.0048，得到2.4576
    V。
- en: The Algorithm
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法
- en: 'Here’s the algorithm for our battery tester:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们电池测试仪的算法：
- en: Read from analog pin 0.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模拟引脚0读取数据。
- en: Multiply the reading by 0.0048 to create a voltage value.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将读取值乘以0.0048以创建电压值。
- en: If the voltage is greater than or equal to 1.6 V, briefly turn on a green LED.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果电压大于或等于1.6 V，则短暂点亮绿色LED。
- en: If the voltage is greater than 1.4 V *and* less than 1.6 V, briefly turn on
    a yellow LED.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果电压大于1.4 V *且*小于1.6 V，则短暂点亮黄色LED。
- en: If the voltage is less than 1.4 V, briefly turn on a red LED.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果电压小于1.4 V，则短暂点亮红色LED。
- en: Repeat indefinitely.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无限重复。
- en: The Hardware
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件
- en: 'Here’s what you’ll need to create this project:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您需要的材料来创建这个项目：
- en: Three 560 Ω resistors (R1 to R3)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个560 Ω的电阻（R1到R3）
- en: One green LED (LED1)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绿色LED（LED1）
- en: One yellow LED (LED2)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个黄色LED（LED2）
- en: One red LED (LED3)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个红色LED（LED3）
- en: One breadboard
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Various connecting wires
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种连接线
- en: Arduino and USB cable
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino和USB电缆
- en: The Schematic
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电路图
- en: The schematic for the single-cell battery tester circuit is shown in [Figure
    4-31](#figure4-31). On the left side, notice the two terminals, labeled *+* and
    *–.* Connect the *matching* sides of the single-cell battery to be tested at those
    points. Positive should connect to positive, and negative should connect to negative.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 单节电池测试仪电路的原理图见[图4-31](#figure4-31)。左侧有两个端子，标记为*+*和*-*。将待测试的单节电池的*匹配*端连接到这些端子上。正极应连接到正极，负极应连接到负极。
- en: '![f04031](image_fi/500587c04/f04031.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![f04031](image_fi/500587c04/f04031.png)'
- en: 'Figure 4-31: Schematic for Project 6'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-31：项目6的电路图
- en: The Sketch
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 草图
- en: 'Now for the sketch. Since analog values can drift between integers, we’re going
    to use a new type of variable called a *float*, which can contain fractional or
    decimal values:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是草图部分。由于模拟值可能会在整数之间波动，我们将使用一种新的变量类型——*float*，它可以包含小数或分数值：
- en: '[PRE16]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this sketch, the Arduino takes the value measured by analog pin 0 at 2 and
    converts this to a voltage at 3. You’ll learn more about the new type of variable,
    the `float` at 1, in the next section, which discusses doing arithmetic with an
    Arduino and using comparison operators to compare numbers.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个草图中，Arduino获取模拟引脚0在2处测量的值，并在3处将其转换为电压值。您将在下一节中了解更多关于新类型变量`float`的内容，下一节将讨论如何使用Arduino进行算术运算，并使用比较运算符来比较数字。
- en: Doing Arithmetic with an Arduino
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Arduino进行算术运算
- en: 'Like a pocket calculator, the Arduino can perform calculations such as multiplication,
    division, addition, and subtraction. Here are some examples:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 像口袋计算器一样，Arduino 可以执行乘法、除法、加法和减法等计算。以下是一些示例：
- en: '[PRE17]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Float Variables
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮动变量
- en: 'When you need to deal with numbers with a decimal point, you can use the variable
    type `float`. The values that can be stored in a `float` fall between 3.4028235
    × 10^(38) and −3.4028235 × 10^(38) and are generally limited to six or seven decimal
    places of precision. You can mix integers and `float` numbers in your calculations.
    For example, you could add the `float` number `f` to the integer `a` and store
    the sum as the `float` variable `g`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要处理带小数点的数字时，可以使用 `float` 变量类型。`float` 变量可以存储的值范围在 3.4028235 × 10^(38) 和 −3.4028235
    × 10^(38) 之间，通常精度限制在六到七位小数。你可以在计算中混合使用整数和 `float` 数字。例如，你可以将 `float` 数字 `f` 加到整数
    `a` 上，并将结果存储为 `float` 变量 `g`：
- en: '[PRE18]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Comparison Operators for Calculations
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算的比较运算符
- en: 'We used comparison operators such as `==` and `!=` with `if` statements and
    digital input signals in Project 5\. In addition to these operators, we can use
    the following to compare numbers or numerical variables:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目 5 中使用了 `==` 和 `!=` 等比较运算符与 `if` 语句以及数字输入信号。除了这些运算符外，我们还可以使用以下运算符来比较数字或数值变量：
- en: '`<` Less than'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<` 小于'
- en: '`>` Greater than'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`>` 大于'
- en: '`<=` Less than or equal to'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<=` 小于或等于'
- en: '`>=` Greater than or equal to'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`>=` 大于或等于'
- en: We used these operators to compare numbers in lines 4, 5, and 6 in the sketch
    for Project 6.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目 6 的草图中，使用了这些运算符来比较第 4、5 和 6 行的数字。
- en: Improving Analog Measurement Precision with a Reference Voltage
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用参考电压提高模拟测量精度
- en: As demonstrated in Project 6, the `analogRead()` function returns a value proportional
    to a voltage between 0 and 5 V. The upper value (5 V) is the *reference voltage*,
    the maximum voltage that the Arduino analog inputs will accept and return the
    highest value for (1,023).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如项目 6 中所示，`analogRead()` 函数返回一个与 0 到 5 V 电压成比例的值。上限值（5 V）是*参考电压*，即 Arduino 模拟输入将接受并返回最高值（1,023）的最大电压。
- en: To increase precision while reading even lower voltages, we can use a lower
    reference voltage. For example, when the reference voltage is 5 V, `analogRead()`
    represents this with a value from 0 to 1,023\. However, if we needed to measure
    only a voltage with a maximum of 2 V, then we could alter the Arduino output to
    represent 2 V using the 0 to 1,023 range to allow for more precise measurement.
    You can do this with either an external or internal reference voltage, as discussed
    next.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在读取更低电压时提高精度，我们可以使用较低的参考电压。例如，当参考电压为 5 V 时，`analogRead()` 的值范围是 0 到 1,023。然而，如果我们只需要测量最大为
    2 V 的电压，那么我们可以调整 Arduino 输出，使其在 0 到 1,023 的范围内表示 2 V，从而实现更精确的测量。你可以使用外部或内部参考电压来做到这一点，具体内容将在下文中讨论。
- en: Using an External Reference Voltage
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用外部参考电压
- en: The first method of using a reference voltage is with the *AREF* (*a*nalog *ref*erence)
    pin, as shown in [Figure 4-32](#figure4-32).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参考电压的第一种方法是通过 *AREF*（*a*nalog *ref*erence）引脚，如[图 4-32](#figure4-32)所示。
- en: '![f04032](image_fi/500587c04/f04032.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![f04032](image_fi/500587c04/f04032.png)'
- en: 'Figure 4-32: The Arduino Uno AREF pin'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-32：Arduino Uno 的 AREF 引脚
- en: We can introduce a new reference voltage by connecting the voltage to the AREF
    pin and the matching GND to the Arduino’s GND. Note that this can lower the reference
    voltage but will not raise it, because the reference voltage connected to an Arduino
    Uno must not exceed 5 V. A simple way to set a lower reference voltage is by creating
    a *voltage divider* with two resistors, as shown in [Figure 4-33](#figure4-33).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将电压连接到 AREF 引脚并将匹配的 GND 连接到 Arduino 的 GND 来引入新的参考电压。请注意，这样做可以降低参考电压，但不能提高它，因为连接到
    Arduino Uno 的参考电压不得超过 5 V。设置较低参考电压的一种简单方法是使用两个电阻器构成*电压分压器*，如[图 4-33](#figure4-33)所示。
- en: '![f04033](image_fi/500587c04/f04033.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![f04033](image_fi/500587c04/f04033.png)'
- en: 'Figure 4-33: A voltage divider circuit'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-33：电压分压电路
- en: The values of *R1* and *R2* will determine the reference voltage according to
    the formula in [Figure 4-34](#figure4-34).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[图 4-34](#figure4-34)中的公式，*R1* 和 *R2* 的值将决定参考电压。
- en: '![f04034](image_fi/500587c04/f04034.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![f04034](image_fi/500587c04/f04034.png)'
- en: 'Figure 4-34: Reference voltage formula'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-34：参考电压公式
- en: In the formula, *V*[out] is the reference voltage, and *V*[in] is the input
    voltage—in this case, 5 V. *R1* and *R2* are the resistor values in ohms.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在该公式中，*V*[out] 是参考电压，*V*[in] 是输入电压—在本例中为 5 V。*R1* 和 *R2* 是电阻值，单位为欧姆。
- en: The simplest way to divide the voltage is to split *V*[in] in half by setting
    *R1* and *R2* to the same value—for example, 10 kΩ each. When you’re doing this,
    it’s best to use the lowest-tolerance resistors you can find, such as 1 percent;
    confirm their true resistance values with a multimeter and use those confirmed
    values in the calculation. Furthermore, it’s a very good idea to place a 100 nF
    capacitor between AREF and GND to avoid a noisy AREF and prevent unstable analog
    readings.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 分压的最简单方法是将*V*[in]一分为二，将*R1*和*R2*设为相同值——例如，每个 10 kΩ。在进行此操作时，最好使用精度最低的电阻器，例如 1%
    的误差；用万用表确认它们的实际电阻值，并在计算中使用这些确认的值。此外，最好在 AREF 和 GND 之间放置一个 100 nF 的电容器，以避免 AREF
    噪声并防止模拟读取不稳定。
- en: 'When using an external reference voltage, insert the following line in the
    `void setup()` section of your sketch:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部参考电压时，请在您的草图的`void setup()`部分插入以下代码行：
- en: '[PRE19]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using the Internal Reference Voltage
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内部参考电压
- en: 'The Arduino Uno also has an internal 1.1 V reference voltage. If this meets
    your needs, no hardware changes are required. Just add this line to `void setup()`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino Uno 还具有内部 1.1 V 参考电压。如果这满足您的需求，则无需更改硬件。只需在`void setup()`中添加以下代码行：
- en: '[PRE20]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Variable Resistor
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变电阻器
- en: Variable resistors, also known as *potentiometers*, can generally be adjusted
    from 0 Ω up to their rated value. Their schematic symbol is shown in [Figure 4-35](#figure4-35).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 可变电阻器，也称为*电位器*，通常可以调节从 0 Ω 到其额定值。其电路符号如[图 4-35](#figure4-35)所示。
- en: '![f04035](image_fi/500587c04/f04035.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![f04035](image_fi/500587c04/f04035.png)'
- en: 'Figure 4-35: Variable resistor (potentiometer) symbol'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-35：可变电阻器（电位器）符号
- en: 'Variable resistors have three pin connections: one in the center pin and one
    on each side. As the shaft of a variable resistor turns, it increases the resistance
    between one side and the center and decreases the resistance between the opposite
    side and the center.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 可变电阻器有三个引脚连接：一个在中央引脚，另两个分别在两侧。当可变电阻器的轴旋转时，它会增加中心与一侧之间的电阻，并减少中心与另一侧之间的电阻。
- en: 'Variable resistors can be either *linear* or *logarithmic*. The resistance
    of linear models changes at a constant rate as they turn, while the resistance
    of logarithmic models changes slowly at first and then increases rapidly. Logarithmic
    potentiometers are used more often in audio amplifier circuits, because they model
    the human hearing response. You can generally identify whether a potentiometer
    is logarithmic or linear via the marking on the rear. Most will have either an
    *A* or a *B* next to the resistance value: *A* for logarithmic, *B* for linear.
    Most Arduino projects use linear variable resistors, such as the one shown in
    [Figure 4-36](#figure4-36).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可变电阻器可以是*线性*型或*对数*型。线性模型的电阻随着旋转以恒定的速度变化，而对数模型的电阻最初变化缓慢，然后迅速增加。对数电位器更常用于音频放大电路，因为它们模拟了人类的听觉反应。您通常可以通过后面的标记来识别电位器是对数型还是线性型。大多数电位器会在电阻值旁标有*A*或*B*：*A*表示对数型，*B*表示线性型。大多数
    Arduino 项目使用线性可变电阻器，如[图 4-36](#figure4-36)所示。
- en: '![f04036](image_fi/500587c04/f04036.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![f04036](image_fi/500587c04/f04036.png)'
- en: 'Figure 4-36: A typical linear variable resistor'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-36：典型的线性可变电阻
- en: You can also get miniature versions of variable resistors, known as *trimpots*
    or *trimmers* (see [Figure 4-37](#figure4-37)). Because of their size, trimpots
    are useful for making adjustments in circuits, but they’re also very useful for
    breadboard work because they can be slotted in.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以获得小型的可变电阻器，称为*微调电位器*或*调节器*（参见[图 4-37](#figure4-37)）。由于其体积小，微调电位器非常适合用于电路调整，但它们在面包板工作中也非常有用，因为它们可以插入使用。
- en: '![f04037](image_fi/500587c04/f04037.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![f04037](image_fi/500587c04/f04037.png)'
- en: 'Figure 4-37: Various trimpots'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-37：各种微调电位器
- en: Piezoelectric Buzzers
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压电蜂鸣器
- en: A *piezoelectric element* (*piezo* for short), or buzzer, is a small, round
    device that can be used to generate loud and annoying noises that are perfect
    for alarms—or for having fun. [Figure 4-38](#figure4-38) shows a common example,
    the TDK PS1240, next to an American quarter, to give you an idea of its size.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*压电元件*（简称*压电*），或蜂鸣器，是一种小型圆形设备，可用于产生响亮且令人烦恼的声音，适合用于报警——或用于娱乐。[图 4-38](#figure4-38)展示了一个常见的例子，TDK
    PS1240，旁边放着一枚美国一角硬币，以便让您了解其大小。'
- en: '![f04038](image_fi/500587c04/f04038.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![f04038](image_fi/500587c04/f04038.png)'
- en: 'Figure 4-38: The TDK PS1240 piezo'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-38：TDK PS1240 压电器
- en: Piezos contain a very thin plate inside the housing that moves when an electrical
    current is applied. When a pulsed current is applied (such as on . . . off . .
    . on . . . off), the plate vibrates and generates sound waves.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 压电元件内部包含一个非常薄的板，当电流通过时，这个板会发生移动。当施加脉冲电流（例如开……关……开……关）时，板会振动并产生声波。
- en: It’s simple to use piezos with the Arduino because they can be turned on and
    off just like an LED. The piezo elements are not polarized and can be connected
    in either direction.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Arduino 控制压电元件非常简单，因为它们可以像 LED 一样开关。压电元件没有极性，可以任意方向连接。
- en: Piezo Schematic
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压电元件原理图
- en: The schematic symbol for the piezo looks like a loudspeaker ([Figure 4-39](#figure4-39)),
    which makes it easy to recognize.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 压电元件的原理图符号类似于扬声器（见[图 4-39](#figure4-39)），这使得它容易识别。
- en: '![f04039](image_fi/500587c04/f04039.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![f04039](image_fi/500587c04/f04039.png)'
- en: 'Figure 4-39: Piezo schematic symbol'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-39：压电元件原理图符号
- en: 'Project #7: Trying Out a Piezo Buzzer'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '项目 #7：尝试使用压电蜂鸣器'
- en: 'If you have a piezo handy and want to try it out, first connect it between
    Arduino GND and digital pins D3 to D0 inclusive. Then upload the following demonstration
    sketch to your Arduino:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手头有一个压电元件并且想尝试，首先将其连接到 Arduino 的 GND 和数字引脚 D3 到 D0（包括）之间。然后将以下演示草图上传到你的 Arduino：
- en: '[PRE21]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This sketch uses pulse-width modulation on digital pin 3\. If you change the
    duty cycle in the `analogWrite()` function (currently it’s 128, which is 50 percent
    on) at 1, you can alter the sound of the buzzer.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此草图使用数字引脚 3 上的脉宽调制（PWM）。如果你在 `analogWrite()` 函数中更改占空比（当前是 128，即 50% 开），你可以改变蜂鸣器的声音。
- en: To increase the volume of your piezo, increase the voltage applied to it. The
    voltage is currently limited to 5 V, but the buzzer would be much louder at 9
    or 12 V. Because higher voltages can’t be sourced from the Arduino, you would
    need to use an external power source for the buzzer, such as a 9 V battery, and
    then switch the power into the buzzer using a BC548 transistor as an electronic
    switch. You can use the same sketch with the schematic shown in [Figure 4-40](#figure4-40).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要增加蜂鸣器的音量，可以增加施加到蜂鸣器上的电压。目前电压限制为 5 V，但在 9 V 或 12 V 时蜂鸣器会更响。由于 Arduino 无法提供更高的电压，你需要使用外部电源为蜂鸣器供电，如
    9 V 电池，然后使用 BC548 晶体管作为电子开关来控制蜂鸣器的电源。你可以使用与[图 4-40](#figure4-40)所示原理图相同的草图。
- en: The part of the schematic labeled 12 V will be the positive side of the higher-power
    supply, whose negative side will connect to the Arduino GND pin.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图中标记为 12 V 的部分将是高功率电源的正极，负极将连接到 Arduino 的 GND 引脚。
- en: '![f04040](image_fi/500587c04/f04040.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![f04040](image_fi/500587c04/f04040.png)'
- en: 'Figure 4-40: Schematic for Project 7'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-40：项目 7 原理图
- en: 'Project #8: Creating a Quick-Read Thermometer'
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '项目 #8：创建一个快速读取温度计'
- en: Temperature can be represented by an analog signal. We can measure temperature
    using the TMP36 voltage output temperature sensor made by Analog Devices ([http://www.analog.com/tmp36/](http://www.analog.com/tmp36/)),
    shown in [Figure 4-41](#figure4-41).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 温度可以通过模拟信号表示。我们可以使用模拟设备公司（Analog Devices）生产的TMP36电压输出温度传感器来测量温度（[http://www.analog.com/tmp36/](http://www.analog.com/tmp36/)），该传感器如[图
    4-41](#figure4-41)所示。
- en: '![f04041](image_fi/500587c04/f04041.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![f04041](image_fi/500587c04/f04041.png)'
- en: 'Figure 4-41: TMP36 temperature sensor'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-41：TMP36 温度传感器
- en: Notice that the TMP36 looks just like the BC548 transistor we worked with in
    the relay control circuit in Chapter 3. The TMP36 outputs a voltage that is proportional
    to the temperature, so you can determine the current temperature using a simple
    conversion. For example, at 25 degrees Celsius, the output voltage is 750 mV,
    and each change in temperature of 1 degree results in a change of 10 mV. The TMP36
    can measure temperatures between −40 and 125 degrees Celsius.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，TMP36 看起来就像我们在第 3 章继电器控制电路中使用的 BC548 晶体管。TMP36 输出与温度成比例的电压，因此你可以通过简单的转换来确定当前温度。例如，在
    25 摄氏度时，输出电压为 750 mV，每增加 1 摄氏度，电压会变化 10 mV。TMP36 可以测量从 −40 到 125 摄氏度的温度。
- en: The function `analogRead()` will return a value between 0 and 1,023, which corresponds
    to a voltage between 0 and just under 5,000 mV (5 V). If we multiply the output
    of `analogRead()` by (5,000/1,024), we will get the actual voltage returned by
    the sensor. Next, we subtract 500 (an offset used by the TMP36 to allow for temperatures
    below 0) and then divide by 10, which leaves us with the temperature in degrees
    Celsius. If you work in Fahrenheit, then multiply the Celsius value by 1.8 and
    add 32 to the result.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`analogRead()`将返回一个介于0和1,023之间的值，这对应于一个介于0到接近5,000毫伏（5 V）之间的电压。如果我们将`analogRead()`的输出值乘以(5,000/1,024)，我们就能得到传感器返回的实际电压。接下来，我们减去500（TMP36使用的偏移量，用于处理低于0度的温度），然后除以10，最后得到摄氏度的温度。如果你使用华氏度，则将摄氏值乘以1.8，并加上32。
- en: The Goal
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: In this project, we’ll use the TMP36 to create a quick-read thermometer. When
    the temperature falls below 20 degrees Celsius, a blue LED turns on; when the
    temperature is between 20 and 26 degrees, a green LED turns on; and when the temperature
    is above 26 degrees, a red LED turns on.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用TMP36创建一个快速读取温度的温度计。当温度低于20摄氏度时，蓝色LED灯亮起；当温度在20到26摄氏度之间时，绿色LED灯亮起；当温度高于26摄氏度时，红色LED灯亮起。
- en: The Hardware
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件
- en: 'Here’s what you’ll need to create this project:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要创建这个项目所需的组件：
- en: Three 560 Ω resistors (R1 to R3)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个560 Ω电阻（R1至R3）
- en: One red LED (LED1)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个红色LED灯（LED1）
- en: One green LED (LED2)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绿色LED灯（LED2）
- en: One blue LED (LED3)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个蓝色LED灯（LED3）
- en: One TMP36 temperature sensor
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个TMP36温度传感器
- en: One breadboard
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Various connecting wires
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种连接线
- en: Arduino and USB cable
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino和USB线
- en: The Schematic
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原理图
- en: The circuit is simple. When you’re looking at the labeled side of the TMP36,
    the pin on the left connects to the 5 V input, the center pin is the voltage output,
    and the pin on the right connects to GND, as shown in [Figure 4-42](#figure4-42).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 电路很简单。当你看到TMP36的标记面时，左侧的引脚连接到5 V输入，中间的引脚是电压输出，右侧的引脚连接到地（GND），如[图4-42](#figure4-42)所示。
- en: '![f04042](image_fi/500587c04/f04042.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![f04042](image_fi/500587c04/f04042.png)'
- en: 'Figure 4-42: Schematic for Project 8'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-42：项目8的原理图
- en: The Sketch
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 草图
- en: 'And now for the sketch:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是草图部分：
- en: '[PRE22]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The sketch first reads the voltage from the TMP36 and converts it to a temperature
    in degrees Celsius at 1. Next, using the `if-else` statements at 2 and 3, the
    code compares the current temperature against the values for hot and cold and
    turns on the appropriate LED. The `delay(1000)` statements are used to prevent
    the lights from flashing on and off too quickly if the temperature fluctuates
    rapidly between two ranges.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先从TMP36读取电压，并将其转换为摄氏度温度，如步骤1所示。接着，在步骤2和3中，使用`if-else`语句，代码将当前温度与冷热的值进行比较，并打开相应的LED灯。`delay(1000)`语句用于防止灯光在温度迅速在两个范围之间波动时闪烁得太快。
- en: You can experiment with the thermometer by blowing cool air over it to lower
    the temperature or by rubbing two fingers over the TMP36’s body to generate heat.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向传感器吹冷空气来让温度降低，或者通过用两根手指摩擦TMP36的表面来产生热量，进行实验。
- en: Looking Ahead
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来
- en: And Chapter 4 comes to a close. You now have a lot more tools to work with,
    including digital inputs and outputs, new types of variables, and various mathematical
    functions. In the next chapter, you will have a lot more fun with LEDs, learn
    to create your own functions, build a computer game and electronic dice, and much
    more.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章到此结束。现在你有了更多的工具可以使用，包括数字输入和输出、新类型的变量以及各种数学函数。在下一章，你将更深入地玩转LED，学习如何创建自己的函数，制作计算机游戏和电子骰子，等等。
