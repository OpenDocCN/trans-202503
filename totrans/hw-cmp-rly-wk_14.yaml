- en: '## **A'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: ANSWERS TO EXERCISES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Here you’ll find questions and answers for the exercises included in this book.
    Some questions don’t have a single right answer; for those, I’ve included an example
    answer. You’ll get the most out of these exercises if you come up with an answer
    yourself before you read the solution found here!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**1-2: Binary to Decimal**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in binary, to their decimal
    equivalents.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 10 (binary) = 2 (decimal)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 111 (binary) = 7 (decimal)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 1010 (binary) = 10 (decimal)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '### **1-3: Decimal to Binary**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in decimal, to their binary
    equivalents.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 3 (decimal) = 11 (binary)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 8 (decimal) = 1000 (binary)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 14 (decimal) = 1110 (binary)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**1-4: Binary to Hexadecimal**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in binary, to their hexadecimal
    equivalents. Don’t convert to decimal if you can help it! You can use [Table 1-5](ch01.xhtml#ch1tab5)
    to help you. The goal is to move directly from binary to hexadecimal.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 10 (binary) = 2 (hexadecimal)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 11110000 (binary) = F0 (hexadecimal)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**1-5: Hexadecimal to Binary**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in hexadecimal, to their binary
    equivalents. Don’t convert to decimal if you can help it! You can use [Table 1-5](ch01.xhtml#ch1tab5)
    to help you. The goal is to move directly from hexadecimal to binary.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 1A (hexadecimal) = 0001 1010 (binary)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: C3A0 (hexadecimal) = 1100 0011 1010 0000 (binary)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**2-1: Create Your Own System for Representing Text**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Define a way to represent the uppercase letters A through D as
    8-bit numbers, and then encode the word *DAD* into 24 bits using your system.
    Bonus: Show your encoded 24-bit number in hexadecimal too. [Table A-1](appa.xhtml#chAtab1)
    presents an example answer; there’s no single right answer.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-1:** A Custom System for Representing A–D with Bytes'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Binary** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| A | 00000001 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| B | 00000010 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| C | 00000011 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| D | 00000100 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: 'DAD using this system would be 00000100 00000001 00000100 (spaces added for
    clarity). Written as hexadecimal: 0x040104.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**2-2: Encode and Decode ASCII**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Using [Table 2-1](ch02.xhtml#ch2tab1), encode the following words
    to ASCII binary and hexadecimal, using a byte for each character. Remember that
    there are different codes for uppercase and lowercase letters.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Hello'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   01001000 01100101 01101100 01101100 01101111'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   0x48656C6C6F'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   5 cats'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   00110101 00100000 01100011 01100001 01110100 01110011'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   0x352063617473'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Note how encoding “5 cats” gave us 0b00110101 as the binary representation of
    the character 5\. This is different from the number 5, which is 0b101\. The character
    represents the symbol (5) we use for the number five, while the number represents
    a quantity. From the same encoding of “5 cats,” note that even the space character,
    which you might think of as empty, still requires a byte to represent.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Using [Table 2-1](ch02.xhtml#ch2tab1), decode the following words.
    Each character is represented as an 8-bit ASCII value with spaces added for clarity.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   01000011 01101111 01100110 01100110 01100101 01100101'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Coffee'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   01010011 01101000 01101111 01110000'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Shop'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Using [Table 2-1](ch02.xhtml#ch2tab1), decode the following word.
    Each character is represented as an 8-bit hexadecimal value with spaces added
    for clarity.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   43 6C 61 72 69 6E 65 74'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Clarinet'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**2-3: Create Your Own System for Representing Grayscale**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Define a way to represent black, white, dark gray, and light
    gray.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** If we go with a 2-bit system, the four unique values for a 2-bit
    number are 00, 01, 10, and 11\. Each of those four binary numbers can then be
    mapped to a color: black, white, dark gray, and light gray—the specific mapping
    is up to you, since you are designing your own system. [Table A-2](appa.xhtml#chAtab2)
    presents an example answer; there’s no single right answer.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-2:** A Custom System for Representing Grayscale'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '| **Color** | **Binary** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| black | 00 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| dark gray | 01 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| light gray | 10 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| white | 11 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '**2-4: Create Your Own Approach for Representing Simple Images**'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise: Part 1**   Building upon your previous system for representing
    grayscale colors, design an approach for representing an image composed of those
    colors. If you want to simplify things, you can assume that the image will always
    be 4 pixels by 4 pixels, like the one in [Figure 2-1](ch02.xhtml#ch2fig1).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Assume the image will always be 4 pixels by 4 pixels, and therefore
    we need to represent 16 pixels, one color per pixel. Using the previously defined
    system for representing grayscale colors in [Table A-2](appa.xhtml#chAtab2), we
    need 2 bits to represent the color of each pixel. So to represent our full image
    of 16 pixels, with 2 bits per pixel, we need 16 × 2 = 32 total bits.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: When we encode the data as binary, in what order should we represent the 16
    pixels? This decision is somewhat arbitrary, but for this example, let’s order
    our data from left to right, top to bottom, as shown in [Figure A-1](appa.xhtml#chAfig1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-1.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-1: Order of pixels in example image format*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Using the approach shown in [Figure A-1](appa.xhtml#chAfig1), when we encode
    our data in binary, the first 2 bits are the color of pixel 1, and the next 2
    bits are the color of pixel 2, and so on. We then use the color codes defined
    in the previous exercise to define the color of each pixel. For example, if pixel
    1 is white, pixel 2 is black, and pixel 3 is dark gray, the first 6 bits in our
    image data are 110001.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise: Part 2**   Using your approach from part 1, write out a binary
    representation of the flower image from [Chapter 2](ch02.xhtml), [Figure 2-1](ch02.xhtml#ch2fig1).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Here, I provide an example of how this can work by applying the
    example approach from part 1 to this problem. To help visualize this, [Figure
    A-2](appa.xhtml#chAfig2) overlays the numbered image grid on the flower image.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-2.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-2: A 4X4 image grid overlaid on a flower image*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have assigned each pixel in the grid a number, we can refer to
    [Table A-2](appa.xhtml#chAtab2) to apply a 2-bit value to each square, progressing
    from square 1 to 16\. The end result is the following binary sequence that represents
    the grayscale flower image:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '11111101111011011111110101100101'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '*I wrote a simple web page that simulates this particular system of 16 pixels
    and 2-bit grayscale. Try it here:* [https://www.howcomputersreallywork.com/grayscale](https://www.howcomputersreallywork.com/grayscale)/.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '**2-5: Write a Truth Table for a Logical Expression**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** [Table 2-7](ch02.xhtml#ch2tab7) shows three inputs for a logical
    expression. Complete the truth table output for the expression (A OR B) AND C.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-3:** (A OR B) AND C Truth Table Solution'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **C** | **Output** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '**3-1: Using Ohm’s Law**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Excercise:**   Take a look at the circuit in [Figure A-3](appa.xhtml#chAfig3).
    What is the current, *I*?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-3.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-3: Find the current using Ohm’s law.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**   Ohm’s law tells us that current is voltage divided by resistance.
    So *I* is 0.2 milliamps, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0324-01.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: '**3-2: Find the Voltage Drops**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Given the circuit in [Figure 3-11](ch03.xhtml#ch3fig11), what
    is the current, *I*? What is the voltage drop across each resistor? Find the labeled
    voltages: V[A], V[B], V[C], and V[D], each measured as relative to the negative
    terminal of the power supply.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** The total resistance is 24kΩ + 6kΩ + 10kΩ = 40kΩ. This influences
    the current through the circuit, which we can calculate using Ohm’s law: 10V /
    40kΩ = 0.25 mA, as shown in [Figure A-4](appa.xhtml#chAfig4).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-4.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-4: Voltage drops around a circuit*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Now calculate the voltage drop across the 24kΩ resistor using Ohm’s law: V
    = 0.25mA × 24kΩ = 6V. That means that V[B] will be 6V less than V[A]. So V[B]
    = 10V – 6V = 4V. The 6kΩ resistor drops 0.25mA × 6kΩ = 1.5V. Therefore, V[C] =
    V[B] – 1.5V = 2.5V. That leaves 2.5V to drop across the 10kΩ resistor, which we
    can deduce from Kirchhoff’s voltage law or calculate using Ohm’s law.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**4-1: Design a Logical OR with Transistors**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Draw a circuit diagram for a logical OR circuit that uses transistors
    for inputs A and B. Adapt the circuit in [Figure 4-4](ch04.xhtml#ch4fig4) that
    uses mechanical switches, but use NPN transistors instead.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** [Figure A-5](appa.xhtml#chAfig5) shows a solution for implementing
    a logical OR with NPN transistors.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-5.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-5: Logical OR implemented with NPN transistors*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**4-2: Design a Circuit with Logic Gates**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** In [Chapter 2](ch02.xhtml), [Exercise 2-5](ch02.xhtml#ch2ex5),
    you created the truth table for (A OR B) AND C. Now build on that work and translate
    that truth table and logical expression into a circuit diagram. Draw a logic gate
    diagram (similar to the one in [Figure 4-11](ch04.xhtml#ch4fig11)) for the circuit
    using logic gates.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** [Figure A-6](appa.xhtml#chAfig6) shows a solution for implementing
    (A OR B) AND C.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-6.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-6: Logic gate diagram for (A OR B) AND C*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**5-1: Practice Binary Addition**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Try the following addition problems.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** The leading 0s in the answers are optional.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 0001 + 0010 = 0011
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 0011 + 0001 = 0100
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 0101 + 0011 = 1000
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 0111 + 0011 = 1010
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**5-2: Find the Two’s Complement**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Find the 4-bit two’s complement of 6.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** See [Figure A-7](appa.xhtml#chAfig7).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-7.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-7: Finding the two’s complement of 6*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '**5-3: Add Two Binary Numbers and Interpret as Signed and Unsigned**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Add 1000 and 0110\. Interpret your work as signed numbers. Then
    interpret it as unsigned. Do the results make sense?'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** See [Figure A-8](appa.xhtml#chAfig8).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-8.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-8: Add 1000 and 0110*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**7-1: Calculate the Required Number of Bits**'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Using the techniques described in [Chapter 7](ch07.xhtml), determine
    the number of bits required for addressing 4GB of memory. Remember that each byte
    is assigned a unique address, which is just a number.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Looking back at [Chapter 1](ch01.xhtml) as a reference on SI-prefixes,
    1GB of memory is 2^(30) or 1,073,741,824 bytes. So 4GB is 4 times that number,
    or 4,294,967,296 bytes. If we take log[2](4,294,967,296) we get 32\. So with 32
    bits, we can represent a unique address for every byte in 4GB of memory.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: If your calculator or application does not provide a log[2] function, note that
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0327-01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: With that bit of information, you can find log[2](4,294,967,296) by taking log(4,294,967,296)
    and dividing it by log(2). This should give you a result of 32.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: We can also arrive at this solution using a different approach. Since memory
    addresses are assigned starting with 0 rather than 1, the range of memory addresses
    for 4GB of memory is from 0 to 4,294,967,295 (1 less than the number of bytes).
    In hex, 4,294,967,295 is 0xFFFFFFFF. That is 8 hex digits, and since each hexadecimal
    symbol represents 4 bits, we easily see that 4 × 8 = 32 bits are required.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**8-1: Use Your Brain as a CPU**'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Try running the following ARM assembly program in your mind,
    or use pencil and paper:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assume an input value of *n* = 4 is initially stored in `r0`. When the program
    gets to the instruction at `00010090` you’ve reached the end of the code, and
    `r0` should be the expected output value of 24\. I recommend that for each instruction,
    you keep track of the values of `r0` and `r3` before and after the instruction
    completes. Work through the instructions until you reach the instruction at `00010090`
    and see if you got the expected result. If things worked correctly, you should
    have looped through the same instructions several times; that’s intentional.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**   Once you’ve worked through this exercise, look at [Table A-4](appa.xhtml#chAtab4)
    to see each step of running the assembly code. Each row in the table represents
    an execution of a single instruction. For each instruction, we track the values
    of `r0` and `r3`. An arrow (→) means the register value changed from the value
    on the left to the value on the right. In the Notes column, I use an equals sign
    to mean “is set to” rather than as a mathematical check of equality. For example,
    `r0` = `r3` × `r0` means “`r0` is set to the product of `r3` and `r0`.”'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-4:** Factorial Assembly Code, Step by Step'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Instruction** | r0 | r3 | **Notes** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '|  |  | 4 | ? | You want to calculate the factorial of 4, so set `r0` = 4 before
    the code runs. `r3` is initially unknown. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `0001007c` | `subs r3, r0, #1` | 4 | ? → 3 | `r3` = `r0` – 1 = 4 – 1 = 3
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `00010080` | `ble 0x10090` | 4 | 3 | `r3` > 0, so don’t branch; instead,
    continue to 10084. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `00010084` | `mul r0, r3, r0` | 4 → 12 | 3 | `r0` = `r3` × `r0` = 3 × 4 =
    12 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `00010088` | `subs r3, r3, #1` | 12 | 3 → 2 | Decrement `r3`. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `0001008c` | `bne 0x10084` | 12 | 2 | `r3` is not 0, so branch to 10084.
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `00010084` | `mul r0, r3, r0` | 12 → 24 | 2 | `r0` = `r3` × `r0` = 2 × 12
    = 24 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `00010088` | `subs r3, r3, #1` | 24 | 2 → 1 | Decrement `r3`. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `0001008c` | `bne 0x10084` | 24 | 1 | `r3` is not 0, so branch to 10084.
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `00010084` | `mul r0, r3, r0` | 24 → 24 | 1 | `r0` = `r3` × `r0` = 1 × 24
    = 24 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `00010088` | `subs r3, r3, #1` | 24 | 1 → 0 | Decrement `r3`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `0001008c` | `bne 0x10084` | 24 | 0 | `r3` is 0, so don’t branch; instead,
    continue to 10090. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `00010090` |  | 24 | 0 | We are finished with the algorithm, and the result
    can be found in `r0`, which is now equal to 24, as expected. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: 'Hopefully this table matches the outcomes you saw when you tried this on your
    own. Now that we’ve walked through the code for *n* = 4, consider the following
    questions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If we calculate the factorial of 1 by initially setting `r0` = 1, what happens?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mathematical definition of *factorial* says that the factorial of 0 is 1\.
    Does our algorithm work for that scenario? What specific result do we get if we
    initially set `r0` = 0?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have noticed that the expected result of 24 was stored in `r0` on the
    next-to-last iteration through the code. That is, the program loops an additional
    time, but this has no bearing on the value of `r0`. Why do you think the code
    was written this way?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that we are using 32-bit registers, is there a practical upper limit for
    *n*? That is, can a value of *n* be provided where the result will be too large
    to fit in a 32-bit register?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the answers to these questions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The first `subs` instruction sets `r3` = 0, and the following `ble` instruction
    jumps to `0x10090`, since `r3` is 0\. At this point our result in `r0` is still
    1, which is the expected output.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, our algorithm won’t work. The first `subs` instruction sets `r3` to –1,
    and the following `ble` instruction jumps to `0x10090`, since `r3` is negative.
    At this point our result in `r0` is still 0, which is not the expected output.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The factorial of *n* is the product of the positive integers less than or equal
    to *n*. Staying true to this definition means multiplying `r0` by 1, even though
    doing so doesn’t change the final result. That means one extra loop through the
    code while `r3` is equal to 1\. We could improve the efficiency of the code by
    skipping this multiplication by 1, but I left it in place to stay true to the
    mathematical definition of a factorial.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The maximum value that a 32-bit integer can represent is 2^(32) – 1 = 4,294,967,295\.
    Or if we need to represent negative numbers too, the largest value is 2,147,483,647\.
    So if we try to calculate a factorial where the result is larger than about 4
    billion (or 2 billion), we get an inaccurate result. It turns out that *n* = 12
    is the largest value of *n* that we can use. The factorial of 13 is over 6 billion,
    which is too large to fit in a 32-bit integer.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**9-1: Bitwise Operators**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Consider the following Python statements. What will be the values
    of `a`, `b`, and `c` after this code executes?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Solution:** [Figure A-9](appa.xhtml#chAfig9) shows how the bitwise operations
    of AND, OR, and XOR work when applied to the values of 11 and 5.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-9.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-9: Bitwise operations on two values*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: So, the value of `a` is 1\. The value of `b` is 15 (1111 binary). The value
    of `c` is 14 (1110 binary).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**9-2: Run a C Program in Your Mind**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Try running the following function in your head or use pencil
    and paper. Assume an input value of `n` = 4\. When the function returns, the returned
    result should be the expected value of 24\. I recommend that, for each line, you
    keep track of the values of `n` and `result` before and after the statement completes.
    Work through the code until you reach the end of the `while` loop and see if you
    get the expected result.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note that the condition of the `while` loop (`--n > 0`) places the decrement
    operator (`--`) before the variable `n`. This means that `n` is decremented *before*
    its value is compared to 0\. This happens each time the `while` loop condition
    is evaluated.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Solution:** Before you read on, I strongly recommend you attempt to complete
    this exercise! You’ll learn more if you do this yourself. Once you’ve worked through
    this exercise, look at [Table A-5](appa.xhtml#chAtab5) to see each step of running
    our example C code. An arrow (→) means the variable value changed from the value
    on the left to the value on the right.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-5:** Factorial C Code, Step by Step'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '| **Statement** | **Result** | **n** | **Notes** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `int factorial(int n)` | ? | 4 | We want to calculate the factorial of 4,
    so set `n` = 4 as an input to our function. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `int result = n;` | ? → 4 | 4 | Initially, set `result` to the value of `n`.
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 4 | 4 → 3 | Decrement `n`.`n` > 0, so run the body of
    the `while` loop. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| `result = result * n;` | 4 → 12 | 3 | `result` = 4 × 3 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 12 | 3 → 2 | Decrement `n`.`n` > 0, so run the `while`
    loop body again. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `result = result * n`; | 12 → 24 | 2 | `result` = 12 × 2 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 24 | 2 → 1 | Decrement `n`.`n` > 0, so run the `while`
    loop body again. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `result = result * n`; | 24 → 24 | 1 | `result` = 24 × 1 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 24 | 1 → 0 | Decrement `n`.`n` = 0, so exit the `while`
    loop. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `return result`; | 24 | 0 | We are finished with the function, and the calculated
    value can be found in `result`, which is now equal to 24, as expected. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: Hopefully this table matches the outcomes you saw when you tried this on your
    own.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**11-1: Which IPs Are on the Same Subnet?**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Is IP address `192.168.0.200` on the same subnet as your computer?
    Assume your computer has an IP address of `192.168.0.133` and a subnet mask of
    `255.255.255.224`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** As we found in [Chapter 11](ch11.xhtml), the network ID of your
    computer’s subnet is `192.168.0.128`. Assuming two devices are on the same subnet,
    they’ll share a subnet mask and network ID. A logical AND of the other computer’s
    IP address and our subnet mask gives us a network ID.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The network ID of the other computer (`192.168.0.192`) does not match the network
    ID of your computer (`192.168.0.128`), so they are on different subnets. This
    means that communication between these hosts needs to go through a router.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**11-2: Research Common Ports**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Find the port numbers for common application layer protocols.
    What are the port numbers for Domain Name System (DNS), Secure Shell (SSH), and
    Simple Mail Transfer Protocol (SMTP)? You can find this information online with
    a search, or by looking at the IANA registry, here: *[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)*.
    The IANA listings sometimes use an unexpected term for the service name. For example,
    DNS is simply listed as “domain.”'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：** 查找常见应用层协议的端口号。域名系统（DNS）、安全外壳协议（SSH）和简单邮件传输协议（SMTP）的端口号分别是多少？你可以通过搜索在线资料或查阅IANA注册表来找到这些信息，地址是：*[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)*。IANA注册表有时会用一些意外的术语来表示服务名称。例如，DNS通常仅列为“domain”。'
- en: '**Solution:**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: 'DNS: 53'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DNS: 53'
- en: 'SSH: 22'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SSH: 22'
- en: 'SMTP: 25'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SMTP: 25'
- en: '### **12-1: Identify the Parts of a URL**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '### **12-1: 识别URL的各个部分**'
- en: '**Exercise:** For the following URLs, identify the scheme, username, host,
    port, path, and query. Not all URLs include all these parts.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：** 对于以下URL，识别出协议、用户名、主机、端口、路径和查询。并非所有URL都包含所有这些部分。'
- en: '**Solution:**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案：**'
- en: '*[https://example.com/photos?subject=cat&color=black](https://example.com/photos?subject=cat&color=black)*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*[https://example.com/photos?subject=cat&color=black](https://example.com/photos?subject=cat&color=black)*'
- en: '**scheme**   *https*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**   *https*'
- en: '**host**   *example.com*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机**   *example.com*'
- en: '**path**   *photos*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径**   *photos*'
- en: '**query**   *subject=cat&color=black*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**查询**   *subject=cat&color=black*'
- en: '*[http://192.168.1.20:8080/docs/set5/two-trees.pdf](http://192.168.1.20:8080/docs/set5/two-trees.pdf)*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*[http://192.168.1.20:8080/docs/set5/two-trees.pdf](http://192.168.1.20:8080/docs/set5/two-trees.pdf)*'
- en: '**scheme**   *http*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**   *http*'
- en: '**host**   *192.168.1.20*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机**   *192.168.1.20*'
- en: '**port**   *8080*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口**   *8080*'
- en: '**path**   *docs/set5/two-trees.pdf*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径**   *docs/set5/two-trees.pdf*'
- en: '*[mailto:someone@example.com](mailto:someone@example.com)*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*[mailto:someone@example.com](mailto:someone@example.com)*'
- en: '**scheme**   *mailto*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议**   *mailto*'
- en: '**username**   *someone*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户名**   *someone*'
- en: '**host**   *example.com*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机**   *example.com*'
