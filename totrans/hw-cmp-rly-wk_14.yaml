- en: '## **A'
  prefs: []
  type: TYPE_NORMAL
- en: ANSWERS TO EXERCISES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here you’ll find questions and answers for the exercises included in this book.
    Some questions don’t have a single right answer; for those, I’ve included an example
    answer. You’ll get the most out of these exercises if you come up with an answer
    yourself before you read the solution found here!
  prefs: []
  type: TYPE_NORMAL
- en: '**1-2: Binary to Decimal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in binary, to their decimal
    equivalents.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 10 (binary) = 2 (decimal)
  prefs: []
  type: TYPE_NORMAL
- en: 111 (binary) = 7 (decimal)
  prefs: []
  type: TYPE_NORMAL
- en: 1010 (binary) = 10 (decimal)
  prefs: []
  type: TYPE_NORMAL
- en: '### **1-3: Decimal to Binary**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in decimal, to their binary
    equivalents.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 3 (decimal) = 11 (binary)
  prefs: []
  type: TYPE_NORMAL
- en: 8 (decimal) = 1000 (binary)
  prefs: []
  type: TYPE_NORMAL
- en: 14 (decimal) = 1110 (binary)
  prefs: []
  type: TYPE_NORMAL
- en: '**1-4: Binary to Hexadecimal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in binary, to their hexadecimal
    equivalents. Don’t convert to decimal if you can help it! You can use [Table 1-5](ch01.xhtml#ch1tab5)
    to help you. The goal is to move directly from binary to hexadecimal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 10 (binary) = 2 (hexadecimal)
  prefs: []
  type: TYPE_NORMAL
- en: 11110000 (binary) = F0 (hexadecimal)
  prefs: []
  type: TYPE_NORMAL
- en: '**1-5: Hexadecimal to Binary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Convert these numbers, represented in hexadecimal, to their binary
    equivalents. Don’t convert to decimal if you can help it! You can use [Table 1-5](ch01.xhtml#ch1tab5)
    to help you. The goal is to move directly from hexadecimal to binary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 1A (hexadecimal) = 0001 1010 (binary)
  prefs: []
  type: TYPE_NORMAL
- en: C3A0 (hexadecimal) = 1100 0011 1010 0000 (binary)
  prefs: []
  type: TYPE_NORMAL
- en: '**2-1: Create Your Own System for Representing Text**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Define a way to represent the uppercase letters A through D as
    8-bit numbers, and then encode the word *DAD* into 24 bits using your system.
    Bonus: Show your encoded 24-bit number in hexadecimal too. [Table A-1](appa.xhtml#chAtab1)
    presents an example answer; there’s no single right answer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-1:** A Custom System for Representing A–D with Bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Binary** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | 00000001 |'
  prefs: []
  type: TYPE_TB
- en: '| B | 00000010 |'
  prefs: []
  type: TYPE_TB
- en: '| C | 00000011 |'
  prefs: []
  type: TYPE_TB
- en: '| D | 00000100 |'
  prefs: []
  type: TYPE_TB
- en: 'DAD using this system would be 00000100 00000001 00000100 (spaces added for
    clarity). Written as hexadecimal: 0x040104.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2-2: Encode and Decode ASCII**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Using [Table 2-1](ch02.xhtml#ch2tab1), encode the following words
    to ASCII binary and hexadecimal, using a byte for each character. Remember that
    there are different codes for uppercase and lowercase letters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Hello'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   01001000 01100101 01101100 01101100 01101111'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   0x48656C6C6F'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   5 cats'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   00110101 00100000 01100011 01100001 01110100 01110011'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   0x352063617473'
  prefs: []
  type: TYPE_NORMAL
- en: Note how encoding “5 cats” gave us 0b00110101 as the binary representation of
    the character 5\. This is different from the number 5, which is 0b101\. The character
    represents the symbol (5) we use for the number five, while the number represents
    a quantity. From the same encoding of “5 cats,” note that even the space character,
    which you might think of as empty, still requires a byte to represent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Using [Table 2-1](ch02.xhtml#ch2tab1), decode the following words.
    Each character is represented as an 8-bit ASCII value with spaces added for clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   01000011 01101111 01100110 01100110 01100101 01100101'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Coffee'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary**   01010011 01101000 01101111 01110000'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Shop'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Using [Table 2-1](ch02.xhtml#ch2tab1), decode the following word.
    Each character is represented as an 8-bit hexadecimal value with spaces added
    for clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hexadecimal**   43 6C 61 72 69 6E 65 74'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**   Clarinet'
  prefs: []
  type: TYPE_NORMAL
- en: '**2-3: Create Your Own System for Representing Grayscale**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Define a way to represent black, white, dark gray, and light
    gray.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** If we go with a 2-bit system, the four unique values for a 2-bit
    number are 00, 01, 10, and 11\. Each of those four binary numbers can then be
    mapped to a color: black, white, dark gray, and light gray—the specific mapping
    is up to you, since you are designing your own system. [Table A-2](appa.xhtml#chAtab2)
    presents an example answer; there’s no single right answer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-2:** A Custom System for Representing Grayscale'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Color** | **Binary** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| black | 00 |'
  prefs: []
  type: TYPE_TB
- en: '| dark gray | 01 |'
  prefs: []
  type: TYPE_TB
- en: '| light gray | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| white | 11 |'
  prefs: []
  type: TYPE_TB
- en: '**2-4: Create Your Own Approach for Representing Simple Images**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise: Part 1**   Building upon your previous system for representing
    grayscale colors, design an approach for representing an image composed of those
    colors. If you want to simplify things, you can assume that the image will always
    be 4 pixels by 4 pixels, like the one in [Figure 2-1](ch02.xhtml#ch2fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Assume the image will always be 4 pixels by 4 pixels, and therefore
    we need to represent 16 pixels, one color per pixel. Using the previously defined
    system for representing grayscale colors in [Table A-2](appa.xhtml#chAtab2), we
    need 2 bits to represent the color of each pixel. So to represent our full image
    of 16 pixels, with 2 bits per pixel, we need 16 × 2 = 32 total bits.'
  prefs: []
  type: TYPE_NORMAL
- en: When we encode the data as binary, in what order should we represent the 16
    pixels? This decision is somewhat arbitrary, but for this example, let’s order
    our data from left to right, top to bottom, as shown in [Figure A-1](appa.xhtml#chAfig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-1: Order of pixels in example image format*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the approach shown in [Figure A-1](appa.xhtml#chAfig1), when we encode
    our data in binary, the first 2 bits are the color of pixel 1, and the next 2
    bits are the color of pixel 2, and so on. We then use the color codes defined
    in the previous exercise to define the color of each pixel. For example, if pixel
    1 is white, pixel 2 is black, and pixel 3 is dark gray, the first 6 bits in our
    image data are 110001.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise: Part 2**   Using your approach from part 1, write out a binary
    representation of the flower image from [Chapter 2](ch02.xhtml), [Figure 2-1](ch02.xhtml#ch2fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Here, I provide an example of how this can work by applying the
    example approach from part 1 to this problem. To help visualize this, [Figure
    A-2](appa.xhtml#chAfig2) overlays the numbered image grid on the flower image.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-2: A 4X4 image grid overlaid on a flower image*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have assigned each pixel in the grid a number, we can refer to
    [Table A-2](appa.xhtml#chAtab2) to apply a 2-bit value to each square, progressing
    from square 1 to 16\. The end result is the following binary sequence that represents
    the grayscale flower image:'
  prefs: []
  type: TYPE_NORMAL
- en: '11111101111011011111110101100101'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I wrote a simple web page that simulates this particular system of 16 pixels
    and 2-bit grayscale. Try it here:* [https://www.howcomputersreallywork.com/grayscale](https://www.howcomputersreallywork.com/grayscale)/.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2-5: Write a Truth Table for a Logical Expression**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** [Table 2-7](ch02.xhtml#ch2tab7) shows three inputs for a logical
    expression. Complete the truth table output for the expression (A OR B) AND C.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-3:** (A OR B) AND C Truth Table Solution'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **C** | **Output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '**3-1: Using Ohm’s Law**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Excercise:**   Take a look at the circuit in [Figure A-3](appa.xhtml#chAfig3).
    What is the current, *I*?'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-3: Find the current using Ohm’s law.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**   Ohm’s law tells us that current is voltage divided by resistance.
    So *I* is 0.2 milliamps, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0324-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**3-2: Find the Voltage Drops**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Given the circuit in [Figure 3-11](ch03.xhtml#ch3fig11), what
    is the current, *I*? What is the voltage drop across each resistor? Find the labeled
    voltages: V[A], V[B], V[C], and V[D], each measured as relative to the negative
    terminal of the power supply.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** The total resistance is 24kΩ + 6kΩ + 10kΩ = 40kΩ. This influences
    the current through the circuit, which we can calculate using Ohm’s law: 10V /
    40kΩ = 0.25 mA, as shown in [Figure A-4](appa.xhtml#chAfig4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-4: Voltage drops around a circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now calculate the voltage drop across the 24kΩ resistor using Ohm’s law: V
    = 0.25mA × 24kΩ = 6V. That means that V[B] will be 6V less than V[A]. So V[B]
    = 10V – 6V = 4V. The 6kΩ resistor drops 0.25mA × 6kΩ = 1.5V. Therefore, V[C] =
    V[B] – 1.5V = 2.5V. That leaves 2.5V to drop across the 10kΩ resistor, which we
    can deduce from Kirchhoff’s voltage law or calculate using Ohm’s law.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4-1: Design a Logical OR with Transistors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Draw a circuit diagram for a logical OR circuit that uses transistors
    for inputs A and B. Adapt the circuit in [Figure 4-4](ch04.xhtml#ch4fig4) that
    uses mechanical switches, but use NPN transistors instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** [Figure A-5](appa.xhtml#chAfig5) shows a solution for implementing
    a logical OR with NPN transistors.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-5: Logical OR implemented with NPN transistors*'
  prefs: []
  type: TYPE_NORMAL
- en: '**4-2: Design a Circuit with Logic Gates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** In [Chapter 2](ch02.xhtml), [Exercise 2-5](ch02.xhtml#ch2ex5),
    you created the truth table for (A OR B) AND C. Now build on that work and translate
    that truth table and logical expression into a circuit diagram. Draw a logic gate
    diagram (similar to the one in [Figure 4-11](ch04.xhtml#ch4fig11)) for the circuit
    using logic gates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** [Figure A-6](appa.xhtml#chAfig6) shows a solution for implementing
    (A OR B) AND C.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-6: Logic gate diagram for (A OR B) AND C*'
  prefs: []
  type: TYPE_NORMAL
- en: '**5-1: Practice Binary Addition**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Try the following addition problems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** The leading 0s in the answers are optional.'
  prefs: []
  type: TYPE_NORMAL
- en: 0001 + 0010 = 0011
  prefs: []
  type: TYPE_NORMAL
- en: 0011 + 0001 = 0100
  prefs: []
  type: TYPE_NORMAL
- en: 0101 + 0011 = 1000
  prefs: []
  type: TYPE_NORMAL
- en: 0111 + 0011 = 1010
  prefs: []
  type: TYPE_NORMAL
- en: '**5-2: Find the Two’s Complement**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Find the 4-bit two’s complement of 6.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** See [Figure A-7](appa.xhtml#chAfig7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-7: Finding the two’s complement of 6*'
  prefs: []
  type: TYPE_NORMAL
- en: '**5-3: Add Two Binary Numbers and Interpret as Signed and Unsigned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Add 1000 and 0110\. Interpret your work as signed numbers. Then
    interpret it as unsigned. Do the results make sense?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** See [Figure A-8](appa.xhtml#chAfig8).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-8: Add 1000 and 0110*'
  prefs: []
  type: TYPE_NORMAL
- en: '**7-1: Calculate the Required Number of Bits**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Using the techniques described in [Chapter 7](ch07.xhtml), determine
    the number of bits required for addressing 4GB of memory. Remember that each byte
    is assigned a unique address, which is just a number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** Looking back at [Chapter 1](ch01.xhtml) as a reference on SI-prefixes,
    1GB of memory is 2^(30) or 1,073,741,824 bytes. So 4GB is 4 times that number,
    or 4,294,967,296 bytes. If we take log[2](4,294,967,296) we get 32\. So with 32
    bits, we can represent a unique address for every byte in 4GB of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: If your calculator or application does not provide a log[2] function, note that
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0327-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With that bit of information, you can find log[2](4,294,967,296) by taking log(4,294,967,296)
    and dividing it by log(2). This should give you a result of 32.
  prefs: []
  type: TYPE_NORMAL
- en: We can also arrive at this solution using a different approach. Since memory
    addresses are assigned starting with 0 rather than 1, the range of memory addresses
    for 4GB of memory is from 0 to 4,294,967,295 (1 less than the number of bytes).
    In hex, 4,294,967,295 is 0xFFFFFFFF. That is 8 hex digits, and since each hexadecimal
    symbol represents 4 bits, we easily see that 4 × 8 = 32 bits are required.
  prefs: []
  type: TYPE_NORMAL
- en: '**8-1: Use Your Brain as a CPU**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Try running the following ARM assembly program in your mind,
    or use pencil and paper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assume an input value of *n* = 4 is initially stored in `r0`. When the program
    gets to the instruction at `00010090` you’ve reached the end of the code, and
    `r0` should be the expected output value of 24\. I recommend that for each instruction,
    you keep track of the values of `r0` and `r3` before and after the instruction
    completes. Work through the instructions until you reach the instruction at `00010090`
    and see if you got the expected result. If things worked correctly, you should
    have looped through the same instructions several times; that’s intentional.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**   Once you’ve worked through this exercise, look at [Table A-4](appa.xhtml#chAtab4)
    to see each step of running the assembly code. Each row in the table represents
    an execution of a single instruction. For each instruction, we track the values
    of `r0` and `r3`. An arrow (→) means the register value changed from the value
    on the left to the value on the right. In the Notes column, I use an equals sign
    to mean “is set to” rather than as a mathematical check of equality. For example,
    `r0` = `r3` × `r0` means “`r0` is set to the product of `r3` and `r0`.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-4:** Factorial Assembly Code, Step by Step'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Instruction** | r0 | r3 | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 4 | ? | You want to calculate the factorial of 4, so set `r0` = 4 before
    the code runs. `r3` is initially unknown. |'
  prefs: []
  type: TYPE_TB
- en: '| `0001007c` | `subs r3, r0, #1` | 4 | ? → 3 | `r3` = `r0` – 1 = 4 – 1 = 3
    |'
  prefs: []
  type: TYPE_TB
- en: '| `00010080` | `ble 0x10090` | 4 | 3 | `r3` > 0, so don’t branch; instead,
    continue to 10084. |'
  prefs: []
  type: TYPE_TB
- en: '| `00010084` | `mul r0, r3, r0` | 4 → 12 | 3 | `r0` = `r3` × `r0` = 3 × 4 =
    12 |'
  prefs: []
  type: TYPE_TB
- en: '| `00010088` | `subs r3, r3, #1` | 12 | 3 → 2 | Decrement `r3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `0001008c` | `bne 0x10084` | 12 | 2 | `r3` is not 0, so branch to 10084.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `00010084` | `mul r0, r3, r0` | 12 → 24 | 2 | `r0` = `r3` × `r0` = 2 × 12
    = 24 |'
  prefs: []
  type: TYPE_TB
- en: '| `00010088` | `subs r3, r3, #1` | 24 | 2 → 1 | Decrement `r3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `0001008c` | `bne 0x10084` | 24 | 1 | `r3` is not 0, so branch to 10084.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `00010084` | `mul r0, r3, r0` | 24 → 24 | 1 | `r0` = `r3` × `r0` = 1 × 24
    = 24 |'
  prefs: []
  type: TYPE_TB
- en: '| `00010088` | `subs r3, r3, #1` | 24 | 1 → 0 | Decrement `r3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `0001008c` | `bne 0x10084` | 24 | 0 | `r3` is 0, so don’t branch; instead,
    continue to 10090. |'
  prefs: []
  type: TYPE_TB
- en: '| `00010090` |  | 24 | 0 | We are finished with the algorithm, and the result
    can be found in `r0`, which is now equal to 24, as expected. |'
  prefs: []
  type: TYPE_TB
- en: 'Hopefully this table matches the outcomes you saw when you tried this on your
    own. Now that we’ve walked through the code for *n* = 4, consider the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: If we calculate the factorial of 1 by initially setting `r0` = 1, what happens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mathematical definition of *factorial* says that the factorial of 0 is 1\.
    Does our algorithm work for that scenario? What specific result do we get if we
    initially set `r0` = 0?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have noticed that the expected result of 24 was stored in `r0` on the
    next-to-last iteration through the code. That is, the program loops an additional
    time, but this has no bearing on the value of `r0`. Why do you think the code
    was written this way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that we are using 32-bit registers, is there a practical upper limit for
    *n*? That is, can a value of *n* be provided where the result will be too large
    to fit in a 32-bit register?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the answers to these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `subs` instruction sets `r3` = 0, and the following `ble` instruction
    jumps to `0x10090`, since `r3` is 0\. At this point our result in `r0` is still
    1, which is the expected output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, our algorithm won’t work. The first `subs` instruction sets `r3` to –1,
    and the following `ble` instruction jumps to `0x10090`, since `r3` is negative.
    At this point our result in `r0` is still 0, which is not the expected output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The factorial of *n* is the product of the positive integers less than or equal
    to *n*. Staying true to this definition means multiplying `r0` by 1, even though
    doing so doesn’t change the final result. That means one extra loop through the
    code while `r3` is equal to 1\. We could improve the efficiency of the code by
    skipping this multiplication by 1, but I left it in place to stay true to the
    mathematical definition of a factorial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The maximum value that a 32-bit integer can represent is 2^(32) – 1 = 4,294,967,295\.
    Or if we need to represent negative numbers too, the largest value is 2,147,483,647\.
    So if we try to calculate a factorial where the result is larger than about 4
    billion (or 2 billion), we get an inaccurate result. It turns out that *n* = 12
    is the largest value of *n* that we can use. The factorial of 13 is over 6 billion,
    which is too large to fit in a 32-bit integer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**9-1: Bitwise Operators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Consider the following Python statements. What will be the values
    of `a`, `b`, and `c` after this code executes?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Solution:** [Figure A-9](appa.xhtml#chAfig9) shows how the bitwise operations
    of AND, OR, and XOR work when applied to the values of 11 and 5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/figA-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-9: Bitwise operations on two values*'
  prefs: []
  type: TYPE_NORMAL
- en: So, the value of `a` is 1\. The value of `b` is 15 (1111 binary). The value
    of `c` is 14 (1110 binary).
  prefs: []
  type: TYPE_NORMAL
- en: '**9-2: Run a C Program in Your Mind**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Try running the following function in your head or use pencil
    and paper. Assume an input value of `n` = 4\. When the function returns, the returned
    result should be the expected value of 24\. I recommend that, for each line, you
    keep track of the values of `n` and `result` before and after the statement completes.
    Work through the code until you reach the end of the `while` loop and see if you
    get the expected result.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the condition of the `while` loop (`--n > 0`) places the decrement
    operator (`--`) before the variable `n`. This means that `n` is decremented *before*
    its value is compared to 0\. This happens each time the `while` loop condition
    is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Solution:** Before you read on, I strongly recommend you attempt to complete
    this exercise! You’ll learn more if you do this yourself. Once you’ve worked through
    this exercise, look at [Table A-5](appa.xhtml#chAtab5) to see each step of running
    our example C code. An arrow (→) means the variable value changed from the value
    on the left to the value on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-5:** Factorial C Code, Step by Step'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Statement** | **Result** | **n** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int factorial(int n)` | ? | 4 | We want to calculate the factorial of 4,
    so set `n` = 4 as an input to our function. |'
  prefs: []
  type: TYPE_TB
- en: '| `int result = n;` | ? → 4 | 4 | Initially, set `result` to the value of `n`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 4 | 4 → 3 | Decrement `n`.`n` > 0, so run the body of
    the `while` loop. |'
  prefs: []
  type: TYPE_TB
- en: '| `result = result * n;` | 4 → 12 | 3 | `result` = 4 × 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 12 | 3 → 2 | Decrement `n`.`n` > 0, so run the `while`
    loop body again. |'
  prefs: []
  type: TYPE_TB
- en: '| `result = result * n`; | 12 → 24 | 2 | `result` = 12 × 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 24 | 2 → 1 | Decrement `n`.`n` > 0, so run the `while`
    loop body again. |'
  prefs: []
  type: TYPE_TB
- en: '| `result = result * n`; | 24 → 24 | 1 | `result` = 24 × 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `while(--n > 0)` | 24 | 1 → 0 | Decrement `n`.`n` = 0, so exit the `while`
    loop. |'
  prefs: []
  type: TYPE_TB
- en: '| `return result`; | 24 | 0 | We are finished with the function, and the calculated
    value can be found in `result`, which is now equal to 24, as expected. |'
  prefs: []
  type: TYPE_TB
- en: Hopefully this table matches the outcomes you saw when you tried this on your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: '**11-1: Which IPs Are on the Same Subnet?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Is IP address `192.168.0.200` on the same subnet as your computer?
    Assume your computer has an IP address of `192.168.0.133` and a subnet mask of
    `255.255.255.224`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:** As we found in [Chapter 11](ch11.xhtml), the network ID of your
    computer’s subnet is `192.168.0.128`. Assuming two devices are on the same subnet,
    they’ll share a subnet mask and network ID. A logical AND of the other computer’s
    IP address and our subnet mask gives us a network ID.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The network ID of the other computer (`192.168.0.192`) does not match the network
    ID of your computer (`192.168.0.128`), so they are on different subnets. This
    means that communication between these hosts needs to go through a router.
  prefs: []
  type: TYPE_NORMAL
- en: '**11-2: Research Common Ports**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise:** Find the port numbers for common application layer protocols.
    What are the port numbers for Domain Name System (DNS), Secure Shell (SSH), and
    Simple Mail Transfer Protocol (SMTP)? You can find this information online with
    a search, or by looking at the IANA registry, here: *[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)*.
    The IANA listings sometimes use an unexpected term for the service name. For example,
    DNS is simply listed as “domain.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS: 53'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSH: 22'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SMTP: 25'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### **12-1: Identify the Parts of a URL**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** For the following URLs, identify the scheme, username, host,
    port, path, and query. Not all URLs include all these parts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://example.com/photos?subject=cat&color=black](https://example.com/photos?subject=cat&color=black)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**scheme**   *https*'
  prefs: []
  type: TYPE_NORMAL
- en: '**host**   *example.com*'
  prefs: []
  type: TYPE_NORMAL
- en: '**path**   *photos*'
  prefs: []
  type: TYPE_NORMAL
- en: '**query**   *subject=cat&color=black*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[http://192.168.1.20:8080/docs/set5/two-trees.pdf](http://192.168.1.20:8080/docs/set5/two-trees.pdf)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**scheme**   *http*'
  prefs: []
  type: TYPE_NORMAL
- en: '**host**   *192.168.1.20*'
  prefs: []
  type: TYPE_NORMAL
- en: '**port**   *8080*'
  prefs: []
  type: TYPE_NORMAL
- en: '**path**   *docs/set5/two-trees.pdf*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[mailto:someone@example.com](mailto:someone@example.com)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**scheme**   *mailto*'
  prefs: []
  type: TYPE_NORMAL
- en: '**username**   *someone*'
  prefs: []
  type: TYPE_NORMAL
- en: '**host**   *example.com*'
  prefs: []
  type: TYPE_NORMAL
