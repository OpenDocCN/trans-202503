- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Maintaining Your Database
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 维护你的数据库
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: To wrap up our exploration of SQL, we’ll look at key database maintenance tasks
    and options for customizing PostgreSQL. In this chapter, you’ll learn how to track
    and conserve space in your databases, how to change system settings, and how to
    back up and restore databases. How often you’ll need to perform these tasks depends
    on your current role and interests. If you want to be a *database administrator*
    or a *backend developer*, the topics covered here are vital.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对SQL的探索结束时，我们将了解关键的数据库维护任务以及定制PostgreSQL的选项。本章中，你将学习如何跟踪和节省数据库空间，如何更改系统设置，以及如何备份和恢复数据库。你需要执行这些任务的频率取决于你当前的角色和兴趣。如果你想成为*数据库管理员*或*后端开发者*，这里所涵盖的主题至关重要。
- en: It’s worth noting that database maintenance and performance tuning are large
    enough topics that they often occupy entire books, and this chapter mainly serves
    as an introduction to a handful of essentials. If you want to learn more, a good
    place to begin is with the resources in the appendix.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，数据库维护和性能调优是足够庞大的话题，常常占据整本书的篇幅，而本章主要作为一些基本概念的介绍。如果你想深入了解，可以从附录中的资源开始。
- en: Let’s start with the PostgreSQL `VACUUM` feature, which lets you shrink the
    size of tables by removing unused rows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从PostgreSQL的`VACUUM`功能开始，它通过移除未使用的行来缩小表的大小。
- en: Recovering Unused Space with VACUUM
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用VACUUM回收未使用的空间
- en: The PostgreSQL `VACUUM` command helps manage the size of a database, which—as
    discussed in “Improving Performance When Updating Large Tables” in Chapter 10—can
    grow as a result of routine operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL的`VACUUM`命令帮助管理数据库的大小，正如第10章《更新大表时提升性能》一文中所讨论的，数据库的大小可能因日常操作而增长。
- en: For example, when you update a row value, the database creates a new version
    of that row with the updated value and retains (but hides) the old version of
    the row. The PostgreSQL documentation refers to these rows that you can’t see
    as *dead tuples*, with *tuples*—an ordered list of elements—being the name for
    the internal implementation of rows in a PostgreSQL database. The same thing happens
    when you delete a row. Though the row is no longer visible to you, it lives on
    as a dead row in the table.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你更新行值时，数据库会创建该行的新版本，并保留（但隐藏）旧版本。PostgreSQL文档将这些你看不见的行称为*死元组*，其中*元组*是PostgreSQL数据库中行的内部实现方式的名称。删除行时也会发生相同的情况。尽管该行对你不可见，但它仍作为死行存在于表中。
- en: This is by design so the database can provide certain features in environments
    where multiple transactions are occurring, and an old version of a row might be
    needed by transactions other than the current one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是经过设计的，目的是让数据库能够在多个事务发生的环境中提供某些功能，旧版本的行可能会被当前事务之外的其他事务所需要。
- en: The `VACUUM` command cleans up these dead rows. Running `VACUUM` on its own
    designates the space occupied by dead rows as available for the database to use
    again (assuming that any transactions using the rows have been completed). In
    most cases, `VACUUM` doesn’t return the space to your system’s disk; it just flags
    that space as available for new data. To actually shrink the size of the data
    file, you can run `VACUUM FULL`, which rewrites the table to a new version that
    doesn’t include the dead row space. It drops the old version.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`VACUUM`命令清理这些死行。单独运行`VACUUM`将死行所占的空间标记为可供数据库再次使用（假设任何使用该行的事务已经完成）。在大多数情况下，`VACUUM`并不会将空间返还给系统的磁盘，它只是将该空间标记为可以用于新数据。要真正缩小数据文件的大小，你可以运行`VACUUM
    FULL`，它会将表重新写成一个不包含死行空间的新版本，并删除旧版本。'
- en: Although `VACUUM FULL` frees space on your system’s disk, there are a couple
    of caveats to keep in mind. First, `VACUUM FULL` takes more time to complete than
    `VACUUM`. Second, it must have exclusive access to the table while rewriting it,
    which means that no one can update data during the operation. The regular `VACUUM`
    command can run while updates and other operations are happening. Finally, not
    all dead space in a table is bad. In many cases, having available space to put
    new tuples instead of needing to ask the operating system for more disk space
    can improve performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`VACUUM FULL`可以释放系统磁盘上的空间，但仍有几个注意事项需要记住。首先，`VACUUM FULL`的完成时间比`VACUUM`更长。其次，它在重写表时必须独占访问表，这意味着在操作期间没有人可以更新数据。常规的`VACUUM`命令可以在更新和其他操作进行时运行。最后，表中的并非所有死空间都是坏的。在许多情况下，拥有可用空间来存放新元组，而不是需要向操作系统请求更多磁盘空间，可以提高性能。
- en: You can run either `VACUUM` or `VACUUM FULL` on demand, but PostgreSQL by default
    runs an *autovacuum* background process that monitors the database and runs `VACUUM`
    as needed. Later in this chapter, I’ll show you how to monitor autovacuum as well
    as run the `VACUUM` command manually. But first, let’s look at how a table grows
    as a result of updates and how you can track this growth.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要运行`VACUUM`或`VACUUM FULL`，但PostgreSQL默认会运行一个*自动清理*后台进程，它会监控数据库并在需要时运行`VACUUM`。在本章的后面，我将展示如何监控自动清理并手动运行`VACUUM`命令。但首先，让我们来看一下表在更新后的增长情况，以及如何跟踪这种增长。
- en: Tracking Table Size
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪表大小
- en: We’ll create a small test table and monitor its growth as we fill it with data
    and perform an update. The code for this exercise, as with all resources for the
    book, is available at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小的测试表，并在向表中填充数据并执行更新时监控其增长。与本书中的所有资源一样，本练习的代码可以在[https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)找到。
- en: Creating a Table and Checking Its Size
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个表并检查其大小
- en: '[Listing 19-1](#listing19-1) creates a `vacuum_test` table with a single column
    to hold an integer. Run the code, and then we’ll measure the table’s size.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 19-1](#listing19-1)创建了一个`vacuum_test`表，该表只有一个列用来存储整数。运行代码后，我们将测量该表的大小。'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 19-1: Creating a table to test vacuuming'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 19-1：创建一个表以测试清理
- en: 'Before we fill the table with test data, let’s check how much space it occupies
    on disk to establish a reference point. We can do so in two ways: check the table
    properties via the pgAdmin interface or run queries using PostgreSQL administrative
    functions. In pgAdmin, click once on a table to highlight it, and then click the
    **Statistics** tab. Table size is one of about two dozen indicators in the list.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向表中填充测试数据之前，让我们检查一下它在磁盘上占用了多少空间，以便建立一个参考点。我们可以通过两种方式来做到这一点：通过pgAdmin界面检查表的属性，或者使用PostgreSQL管理函数运行查询。在pgAdmin中，单击一次表格以突出显示它，然后点击**统计**选项卡。表的大小是列表中的二十多个指标之一。
- en: I’ll focus on the running queries technique here because knowing these queries
    is helpful if for some reason pgAdmin isn’t available or you’re using another
    graphical user interface (GUI). [Listing 19-2](#listing19-2) shows how to check
    the `vacuum_test` table size using PostgreSQL functions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里重点介绍运行查询的技术，因为了解这些查询在pgAdmin不可用或使用其他图形用户界面（GUI）时非常有用。[清单 19-2](#listing19-2)展示了如何使用PostgreSQL函数检查`vacuum_test`表的大小。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 19-2: Determining the size of `vacuum_test`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 19-2：确定`vacuum_test`的大小
- en: 'The outermost function, `pg_size_pretty()` 1, converts bytes to a more easily
    understandable format in kilobytes, megabytes, or gigabytes. Wrapped inside is
    the `pg_total_relation_size()` function 2, which reports how many bytes a table,
    its indexes, and any offline compressed data takes up on disk. Because the table
    is empty at this point, running the code in pgAdmin should return a value of `0
    bytes`, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的函数`pg_size_pretty()` 1将字节转换为更易于理解的格式，如千字节、兆字节或千兆字节。内部嵌套的`pg_total_relation_size()`函数
    2报告了一个表、它的索引以及任何离线压缩数据在磁盘上占用了多少字节。由于此时表为空，运行pgAdmin中的代码应该返回`0字节`，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can get the same information using the command line. Launch `psql` as you
    learned in Chapter 18. Then, at the prompt, enter the meta-command `\dt+ vacuum_test`,
    which should display the following information including table size (I’ve omitted
    one column for space):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用命令行获取相同的信息。启动`psql`，如第18章所学。然后，在提示符下输入元命令`\dt+ vacuum_test`，它应该显示包括表大小在内的以下信息（为了节省空间，我省略了一列）：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, the current size of the `vacuum_test` table should display `0 bytes`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查，当前的 `vacuum_test` 表的大小应显示为 `0 字节`。
- en: Checking Table Size After Adding New Data
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加新数据后检查表的大小
- en: Let’s add some data to the table and then check its size again. We’ll use the
    `generate_series()` function introduced in Chapter 12 to fill the table’s `integer_column`
    with 500,000 rows. Run the code in [Listing 19-3](#listing19-3) to do this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向表中添加一些数据，然后再次检查其大小。我们将使用第 12 章中介绍的 `generate_series()` 函数，将 500,000 行数据填充到表的
    `integer_column` 列中。运行 [列表 19-3](#listing19-3) 中的代码来完成此操作。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 19-3: Inserting 500,000 rows into `vacuum_test`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-3：向 `vacuum_test` 表插入 500,000 行数据
- en: 'This standard `INSERT INTO` statement adds the results of `generate_series()`,
    which is a series of values from 1 to 500,000, as rows to the table. After the
    query completes, rerun the query in [Listing 19-2](#listing19-2) to check the
    table size. You should see the following output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标准的 `INSERT INTO` 语句将 `generate_series()` 的结果（即从 1 到 500,000 的一系列值）作为行插入表中。查询完成后，再次运行
    [列表 19-2](#listing19-2) 中的查询来检查表的大小。你应该看到以下输出：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The query reports that the `vacuum_test` table, now with a single column of
    500,000 integers, uses 17MB of disk space.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 查询报告显示，`vacuum_test` 表现在有一列 500,000 个整数，使用了 17MB 的磁盘空间。
- en: Checking Table Size After Updates
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新后检查表的大小
- en: Now, let’s update the data to see how that affects the table size. We’ll use
    the code in [Listing 19-4](#listing19-4) to update every row in the `vacuum_test`
    table by adding `1` to the `integer_column` values, replacing the existing value
    with a number that’s one greater.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新数据，看看这如何影响表的大小。我们将使用 [列表 19-4](#listing19-4) 中的代码，通过将 `integer_column`
    的每个值加上 `1` 来更新 `vacuum_test` 表中的每一行，将现有值替换为更大的数字。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 19-4: Updating all rows in `vacuum_test`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-4：更新 `vacuum_test` 表中的所有行
- en: Run the code, and then test the table size again.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，然后再次测试表的大小。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The table size doubled from 17MB to 35MB! The increase seems excessive, because
    the `UPDATE` simply replaced existing numbers with values of a similar size. As
    you might have guessed, the reason for this increase in table size is that for
    every updated value, PostgreSQL creates a new row, and the dead row remains in
    the table. Even though you see only 500,000 rows, the table has double that number.
    This behavior can lead to surprises for database owners who don’t monitor disk
    space.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表的大小从 17MB 翻倍到 35MB！增加的幅度看起来过大，因为 `UPDATE` 只是用相似大小的值替换了现有的数字。正如你可能猜到的那样，表大小增加的原因是，PostgreSQL
    为每个更新的值创建了一个新行，而旧行依然保留在表中。即使你只看到了 500,000 行，表中实际有双倍数量的行。这种行为可能会给不监控磁盘空间的数据库所有者带来意外。
- en: Before looking at how using `VACUUM` and `VACUUM FULL` affects the table’s size
    on disk, let’s review the process that runs `VACUUM` automatically as well as
    how to check on statistics related to table vacuums.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 `VACUUM` 和 `VACUUM FULL` 如何影响表的磁盘大小之前，让我们回顾一下自动运行 `VACUUM` 的过程，以及如何检查与表清理相关的统计信息。
- en: Monitoring the Autovacuum Process
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控自动清理进程
- en: PostgreSQL’s autovacuum process monitors the database and launches `VACUUM`
    automatically when it detects a large number of dead rows in a table. Although
    autovacuum is enabled by default, you can turn it on or off and configure it using
    the settings I’ll cover later in “Changing Server Settings.” Because autovacuum
    runs in the background, you won’t see any immediately visible indication that
    it’s working, but you can check its activity by querying data that PostgreSQL
    collects about system performance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的自动清理（autovacuum）进程监控数据库，并在检测到表中有大量死行时自动启动 `VACUUM`。尽管默认启用自动清理，你可以通过稍后在“更改服务器设置”一节中讲解的设置来开启或关闭它，并进行配置。由于自动清理在后台运行，你不会看到它正在工作的任何明显迹象，但你可以通过查询
    PostgreSQL 收集的关于系统性能的数据来检查它的活动。
- en: 'PostgreSQL has its own *statistics collector* that tracks database activity
    and usage. You can look at the statistics by querying one of several views the
    system provides. (See a complete list of views for monitoring the state of the
    system in the PostgreSQL documentation under “The Statistics Collector”: [https://www.postgresql.org/docs/current/monitoring-stats.html](https://www.postgresql.org/docs/current/monitoring-stats.html).)
    To check the activity of autovacuum, we query the `pg_stat_all_tables` view, as
    shown in [Listing 19-5](#listing19-5).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 有自己的 *统计收集器*，用于跟踪数据库活动和使用情况。你可以通过查询系统提供的多个视图之一来查看统计信息。（查看 PostgreSQL
    文档中“统计收集器”下的完整视图列表： [https://www.postgresql.org/docs/current/monitoring-stats.html](https://www.postgresql.org/docs/current/monitoring-stats.html)。）要检查自动清理的活动，我们查询
    `pg_stat_all_tables` 视图，如 [Listing 19-5](#listing19-5) 中所示。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 19-5: Viewing autovacuum statistics for `vacuum_test`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 19-5: 查看 `vacuum_test` 的自动清理统计信息'
- en: As you learned in Chapter 17, a view provides the results of a stored query.
    The query stored by the view `pg_stat_all_tables` returns a column called `relname`1,
    which is the name of the table, plus columns with statistics related to index
    scans, rows inserted and deleted, and other data. For this query, we’re interested
    in `last_vacuum` 2 and `last_autovacuum` 3, which contain the last time the table
    was vacuumed manually and automatically, respectively. We also ask for `vacuum_count`
    4 and `autovacuum_count` 5, which show the number of times the vacuum was run
    manually and automatically.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第17章中学到的，视图提供了一个存储查询的结果。视图 `pg_stat_all_tables` 存储的查询返回一个名为 `relname` 的列，该列是表的名称，并且还有与索引扫描、插入和删除的行数以及其他数据相关的统计列。对于此查询，我们关心的是
    `last_vacuum` 和 `last_autovacuum`，它们分别包含表格手动和自动清理的最后时间。我们还请求了 `vacuum_count` 和
    `autovacuum_count`，它们显示手动和自动运行清理的次数。
- en: 'By default, autovacuum checks tables every minute. So, if a minute has passed
    since you last updated `vacuum_test`, you should see details of vacuum activity
    when you run the query in [Listing 19-5](#listing19-5). Here’s what my system
    shows (note that I’ve removed the seconds from the time to save space here):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动清理每分钟检查一次表格。因此，如果自上次更新 `vacuum_test` 已经过去了一分钟，你应该会在运行 [Listing 19-5](#listing19-5)
    中的查询时看到清理活动的详细信息。以下是我的系统显示的内容（请注意，我已将时间中的秒数去除，以节省空间）：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The table shows the date and time of the last autovacuum, and the `autovacuum_count`
    column shows one occurrence. This result indicates that autovacuum executed a
    `VACUUM` command on the table once. However, because we’ve not vacuumed manually,
    the `last_vacuum` column is empty, and the `vacuum_count` is `0`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该表显示了最后一次自动清理的日期和时间，`autovacuum_count` 列显示了一次出现的记录。这个结果表明，自动清理在该表上执行了 `VACUUM`
    命令一次。然而，由于我们没有手动执行清理，`last_vacuum` 列为空，`vacuum_count` 为 `0`。
- en: Recall that `VACUUM` designates dead rows as available for the database to reuse
    but typically doesn’t reduce the size of the table on disk. You can confirm this
    by rerunning the code in [Listing 17-2](c17.xhtml#listing17-2), which shows the
    table remains at 35MB even after the automatic vacuum.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`VACUUM` 会将死掉的行标记为可供数据库重新使用，但通常不会减少表格在磁盘上的大小。你可以通过重新运行 [Listing 17-2](c17.xhtml#listing17-2)
    中的代码来确认这一点，它显示即使在自动清理之后，表格仍然保持在 35MB。
- en: Running VACUUM Manually
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动运行 VACUUM
- en: To run `VACUUM` manually, you can use the single line of code in [Listing 19-6](#listing19-6).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动运行 `VACUUM`，可以使用 [Listing 19-6](#listing19-6) 中的单行代码。
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 19-6: Running `VACUUM` manually'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 19-6: 手动运行 `VACUUM`'
- en: This command should return the message `VACUUM` from the server. Now when you
    fetch statistics again using the query in [Listing 17-5](c17.xhtml#listing17-5),
    you should see that the `last_vacuum` column reflects the date and time of the
    manual vacuum you just ran, and the number in the `vacuum_count` column should
    increase by one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该从服务器返回 `VACUUM` 的消息。现在，当你再次使用 [Listing 17-5](c17.xhtml#listing17-5) 中的查询提取统计信息时，你应该看到
    `last_vacuum` 列反映了你刚刚运行的手动清理的日期和时间，并且 `vacuum_count` 列中的数字应该增加一个。
- en: In this example, we executed `VACUUM` on our test table, but you can also run
    `VACUUM` on the entire database by omitting the table name. In addition, you can
    add the `VERBOSE` keyword to return information such as the number of rows found
    in a table and the number of rows removed, among other information.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们对测试表执行了 `VACUUM`，但是你也可以通过省略表名来对整个数据库执行 `VACUUM`。此外，你可以添加 `VERBOSE`
    关键字，以返回例如表格中找到的行数和删除的行数等信息。
- en: Reducing Table Size with VACUUM FULL
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `VACUUM FULL` 减小表大小
- en: Next, we’ll run `VACUUM` with the `FULL` option, which actually returns the
    space taken up by dead tuples back to disk. It does this by creating a new version
    of a table with the dead rows discarded.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`FULL`选项运行`VACUUM`，该选项实际上会将被删除的元组所占的空间归还给磁盘。它通过创建一个新的表版本并丢弃死行来实现这一点。
- en: To see how `VACUUM FULL` works, run the command in [Listing 19-7](#listing19-7).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`VACUUM FULL`的工作原理，请运行[清单19-7](#listing19-7)中的命令。
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 19-7: Using `VACUUM FULL` to reclaim disk space'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 清单19-7：使用`VACUUM FULL`来回收磁盘空间
- en: After the command executes, test the table size again. It should be back down
    to 17MB, the size it was when we first inserted data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行后，再次测试表的大小。它应该已经恢复到17MB，这是我们第一次插入数据时的大小。
- en: It’s never prudent or safe to run out of disk space, so minding the size of
    your database files as well as your overall system space is a worthwhile routine
    to establish. Using `VACUUM` to prevent database files from growing bigger than
    they have to is a good start.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要让磁盘空间耗尽，因此，关注数据库文件的大小以及整体系统空间是一个值得建立的常规习惯。使用`VACUUM`来防止数据库文件比必要时更大，是一个不错的开始。
- en: Changing Server Settings
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改服务器设置
- en: You can alter the settings for your PostgreSQL server by editing values in *postgresql.conf*,
    one of several configuration text files that control server settings. Other files
    include *pg_hba.conf*, which controls connections to the server, and *pg_ident.conf*,
    which database administrators can use to map usernames on a network to usernames
    in PostgreSQL. See the PostgreSQL documentation on these files for details; here
    we’ll just cover *postgresql.conf* because it contains settings you may likely
    want to change. Most of the values in the file are set to defaults you may never
    need to adjust, but it’s worth exploring in case you’re fine-tuning your system.
    Let’s start with the basics.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编辑*postgresql.conf*中的值来更改PostgreSQL服务器的设置，这是控制服务器设置的几个配置文本文件之一。其他文件包括*pg_hba.conf*，它控制与服务器的连接，以及*pg_ident.conf*，数据库管理员可以使用它将网络上的用户名映射到PostgreSQL中的用户名。有关这些文件的详细信息，请参阅PostgreSQL文档；在这里，我们将只介绍*postgresql.conf*，因为它包含了你可能希望更改的设置。文件中的大多数值都设置为默认值，你可能永远不需要调整它们，但还是值得探索，以防你在微调系统时需要修改。让我们从基础开始。
- en: Locating and Editing postgresql.conf
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位和编辑postgresql.conf
- en: The location of *postgresql.conf* varies depending on your operating system
    and install method. You can run the command in [Listing 19-8](#listing19-8) to
    locate the file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*postgresql.conf*的位置取决于你的操作系统和安装方式。你可以运行[清单19-8](#listing19-8)中的命令来定位该文件。'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 19-8: Showing the location of *postgresql.conf*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单19-8：显示*postgresql.conf*的位置
- en: 'When I run the command on macOS, it shows the path to the file, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在macOS上运行该命令时，它显示文件的路径，如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To edit *postgresql.conf*, navigate in your file system to the directory displayed
    by `SHOW config_file;` and open the file using a text editor. Don’t use a rich-text
    editor like Microsoft Word, as it may add additional formatting to the file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑*postgresql.conf*，请在文件系统中导航到`SHOW config_file;`显示的目录，并使用文本编辑器打开该文件。不要使用像Microsoft
    Word这样的富文本编辑器，因为它可能会向文件中添加额外的格式。
- en: 'When you open the file, the first several lines should read as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开文件时，前几行应该是这样的：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The *postgresql.conf* file is organized into sections that specify settings
    for file locations, security, logging of information, and other processes. Many
    lines begin with a hash mark (`#`), which indicates the line is commented out
    and the setting shown is the active default.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*postgresql.conf*文件被组织成多个部分，指定文件位置、安全性、信息日志记录和其他进程的设置。许多行以井号符号（`#`）开始，这表示该行被注释掉，显示的设置是有效的默认值。'
- en: 'For example, in the *postgresql.conf* file section “Autovacuum Parameters,”
    the default is for autovacuum to be turned on (which is a good, standard practice).
    The hash mark (`#`) in front of the line means that the line is commented out
    and the default value is in effect:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*postgresql.conf*文件的“自动清理参数”部分，默认情况下启用了自动清理（这是一个很好的标准做法）。行前的井号符号（`#`）表示该行被注释掉，默认值仍然生效：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To change this or other default settings, you would remove the hash mark, adjust
    the setting value, and save *postgresql.conf*. Some changes, such as to memory
    allocations, require a restart of the server; they’re noted in *postgresql.conf*.
    Other changes require only a reload of settings files. You can reload settings
    files by running the function `pg_reload_conf()` under an account with superuser
    permissions or by executing the `pg_ctl` command, which we’ll cover in the next
    section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改此项或其他默认设置，你需要去掉井号，调整设置值，并保存 *postgresql.conf*。某些更改（如内存分配的更改）需要重启服务器；这些更改会在
    *postgresql.conf* 中注明。其他更改只需要重新加载设置文件。你可以通过在具有超级用户权限的账户下运行 `pg_reload_conf()`
    函数，或者执行 `pg_ctl` 命令来重新加载设置文件，具体内容我们将在下一节介绍。
- en: '[Listing 19-9](#listing19-9) shows settings you may want to change, excerpted
    from the *postgresql.conf* section “Client Connection Defaults.” Use your text
    editor to search the file for the following.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 19-9](#listing19-9) 显示了你可能想要更改的设置，摘自 *postgresql.conf* 中的“客户端连接默认值”部分。使用文本编辑器搜索文件以查找以下内容。'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 19-9: Sample *postgresql.conf* settings'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 19-9：示例 *postgresql.conf* 设置
- en: 'You can use the `datestyle` setting 1 to specify how PostgreSQL displays dates
    in query results. This setting takes two parameters separated by a comma: the
    output format and the ordering of month, day, and year. The default for the output
    format is the ISO format `YYYY-MM-DD` we’ve used throughout this book, which I
    recommend for its cross-national portability. However, you can also use the traditional
    SQL format `MM/DD/YYYY`, the expanded Postgres format `Sun Nov 12 22:30:00 2023
    EST`, or the German format `DD.MM.YYYY` with dots between the date, month, and
    year (`12.11.2023`). To specify the format using the second parameter, arrange
    `m`, `d`, and `y` in the order you prefer.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `datestyle` 设置 1 来指定 PostgreSQL 在查询结果中显示日期的方式。此设置包含两个用逗号分隔的参数：输出格式和月份、日期和年份的排序。输出格式的默认值是
    ISO 格式 `YYYY-MM-DD`，这是本书中始终使用的格式，我推荐使用它，因为它具有跨国便携性。不过，你也可以使用传统的 SQL 格式 `MM/DD/YYYY`，扩展的
    Postgres 格式 `Sun Nov 12 22:30:00 2023 EST`，或德式格式 `DD.MM.YYYY`，在日期、月份和年份之间用点号分隔（如
    `12.11.2023`）。要使用第二个参数指定格式，可以按你喜欢的顺序排列 `m`、`d` 和 `y`。
- en: The `timezone` 2 parameter sets the server time zone. [Listing 19-9](#listing19-9)
    shows the value `America/New_York`, which reflects the time zone on my machine
    when I installed PostgreSQL. Yours should vary based on your location. When setting
    up PostgreSQL for use as the backend to a database application or on a network,
    administrators often set this value to `UTC` and use that as a standard on machines
    across multiple locations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`timezone` 2 参数设置服务器的时区。[清单 19-9](#listing19-9) 显示了值 `America/New_York`，它反映了我在安装
    PostgreSQL 时机器上的时区。你的值应根据你所在的位置而有所不同。当将 PostgreSQL 设置为数据库应用程序的后端或在网络上使用时，管理员通常将此值设置为
    `UTC`，并将其作为多个位置机器的标准。'
- en: The `default_text_search_config` 3 value sets the language used by the full-text
    search operations. Here, mine is set to `english`. Depending on your needs, you
    can set this to `spanish`, `german`, `russian`, or another language of your choice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_text_search_config` 3 值设置全文搜索操作使用的语言。这里，我的值设置为 `english`。根据需要，你可以将其设置为
    `spanish`、`german`、`russian` 或你选择的其他语言。'
- en: These three examples represent only a handful of settings available for adjustment.
    Unless you end up deep in system tuning, you probably won’t have to tweak much
    else. Also, use caution when changing settings on a network server used by multiple
    people or applications; changes can have unintended consequences, so it’s worth
    communicating with colleagues first.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个示例只是可调节设置的一小部分。除非你深入进行系统调优，否则通常不需要做太多其他调整。此外，在更改多个用户或应用程序使用的网络服务器上的设置时要谨慎；这些更改可能会带来意想不到的后果，因此最好先与同事沟通。
- en: Next, let’s look at how to use `pg_ctl` to make changes take effect.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下如何使用 `pg_ctl` 使更改生效。
- en: Reloading Settings with pg_ctl
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 pg_ctl 重新加载设置
- en: The command line utility `pg_ctl` allows you to perform actions on a PostgreSQL
    server, such as starting and stopping it and checking its status. Here, we’ll
    use the utility to reload the settings files so the changes we make will take
    effect. Running the command reloads all settings files at once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具 `pg_ctl` 允许你对 PostgreSQL 服务器执行操作，如启动、停止以及检查其状态。在这里，我们将使用该工具重新加载设置文件，以便我们所做的更改能够生效。运行此命令将一次性重新加载所有设置文件。
- en: 'You’ll need to open and configure a command line prompt the same way you did
    in Chapter 18 when you learned how to set up and use `psql`. After you launch
    a command prompt, use one of the following commands to reload, replacing the path
    with the path to the PostgreSQL data directory:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要像第18章学习如何设置和使用`psql`时那样打开并配置命令行提示符。启动命令提示符后，使用以下命令之一重新加载，替换路径为PostgreSQL数据目录的路径：
- en: On Windows, use `pg_ctl reload -D "``C:\path\to\data\directory\``"`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，使用`pg_ctl reload -D "``C:\path\to\data\directory\``"`。
- en: On macOS or Linux, use `pg_ctl reload -D '``/path/to/data/directory/``'`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在macOS或Linux上，使用`pg_ctl reload -D '``/path/to/data/directory/``'`。
- en: To find the location of your PostgreSQL data directory, run the query in [Listing
    19-10](#listing19-10).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到PostgreSQL数据目录的位置，请运行[示例 19-10](#listing19-10)中的查询。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 19-10: Showing the location of the data directory'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-10：显示数据目录的位置
- en: Place the path after the `-D` argument, between double quotes on Windows and
    single quotes on macOS or Linux. You run this command on your system’s command
    prompt, not inside the `psql` application. Enter the command and press enter;
    it should respond with the message `server signaled`. The settings files will
    be reloaded, and changes should take effect.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将路径放在`-D`参数后面，在Windows上使用双引号，在macOS或Linux上使用单引号。你需要在系统的命令提示符下运行此命令，而不是在`psql`应用程序内。输入命令并按回车键，它应该会返回`server
    signaled`的消息。设置文件将重新加载，并且更改应该生效。
- en: If you’ve changed settings that require a server restart, replace `reload` in
    [Listing 19-10](#listing19-10) with `restart`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改了需要重启服务器的设置，请将[示例 19-10](#listing19-10)中的`reload`替换为`restart`。
- en: Backing Up and Restoring Your Database
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库的备份与恢复
- en: You might want to back up your entire database either for safekeeping or for
    transferring data to a new or upgraded server. PostgreSQL offers command line
    tools that make backup and restore operations easy. The next few sections show
    examples of how to export data from a database or a single table to a file, as
    well as how to restore data from an export files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望备份整个数据库，无论是为了保存数据还是为了将数据迁移到新服务器或升级后的服务器。PostgreSQL提供了命令行工具，使备份和恢复操作变得简单。接下来的几个部分展示了如何将数据库或单个表的数据导出到文件，以及如何从导出文件恢复数据。
- en: Using pg_dump to Export a Database or Table
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`pg_dump`导出数据库或表
- en: The PostgreSQL command line tool `pg_dump` creates an output file that contains
    all the data from your database; SQL commands for re-creating tables, views, functions,
    and other database objects; and commands for loading the data into tables. You
    can also use `pg_dump` to save only selected tables in your database. By default,
    `pg_dump` outputs a text file; I’ll discuss an alternate custom compressed format
    first and then discuss other options.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL命令行工具`pg_dump`创建一个包含你数据库所有数据的输出文件；包括重新创建表、视图、函数和其他数据库对象的SQL命令，以及将数据加载到表中的命令。你还可以使用`pg_dump`仅保存数据库中的特定表。默认情况下，`pg_dump`输出为文本文件；我将首先讨论一种自定义压缩格式，然后再讨论其他选项。
- en: To export the `analysis` database we’ve used for our exercises to a file, run
    the command in [Listing 19-11](#listing19-11) at your system’s command prompt
    (not in `psql`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们在练习中使用的`analysis`数据库导出到文件，请在系统的命令提示符下（不是在`psql`中）运行[示例 19-11](#listing19-11)中的命令。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 19-11: Exporting the `analysis` database with `pg_dump`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-11：使用`pg_dump`导出`analysis`数据库
- en: Here, we start the command with `pg_dump` and use similar connection arguments
    as with `psql`. We specify the database to export with the `-d` argument, followed
    by the `-U` argument and your username. Next, we use the `-Fc` argument to specify
    that we want to generate this export in a custom PostgreSQL compressed format
    and the `-v` argument to generate verbose output. Then we use the `-f` argument
    to direct the output of `pg_dump` to a text file named *analysis_backup.dump*.
    To place the file in a directory other than the one your terminal prompt is currently
    open to, you can specify the complete directory path before the filename.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以`pg_dump`开始命令，并使用与`psql`相似的连接参数。我们通过`-d`参数指定要导出的数据库，接着是`-U`参数和你的用户名。然后，我们使用`-Fc`参数指定我们希望以自定义PostgreSQL压缩格式生成此导出文件，并使用`-v`参数生成详细输出。接着，使用`-f`参数将`pg_dump`的输出导向名为*analysis_backup.dump*的文本文件。如果你希望将文件放在当前终端提示符所在目录之外的目录中，可以在文件名之前指定完整的目录路径。
- en: When you execute the command, depending on your installation, you might see
    a password prompt. Fill in that password, if prompted. Then, depending on the
    size of your database, the command could take a few minutes to complete. You’ll
    see a series of messages about the objects the command is reading and outputting.
    When it’s done, it should return you to a new command prompt, and you should see
    a file named *analysis_backup.dump* in your current directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令时，取决于你的安装方式，你可能会看到一个密码提示。如果有提示，请填写密码。然后，根据数据库的大小，该命令可能需要几分钟才能完成。你将看到一系列关于命令正在读取和输出的对象的消息。当它完成时，它应该会返回一个新的命令提示符，并且你应该能在当前目录中看到一个名为*analysis_backup.dump*的文件。
- en: 'To limit the export to one or more tables that match a particular name, use
    the `-t` argument followed by the name of the table in single quotes. For example,
    to back up just the `train_rides` table, use the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将导出限制为匹配特定名称的一个或多个表，请使用`-t`参数，后跟单引号中的表名。例如，要仅备份`train_rides`表，可以使用以下命令：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now let’s look at how to restore the data from the export file, and then we’ll
    explore additional `pg_dump` options.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何从导出文件中恢复数据，然后我们将探讨更多的`pg_dump`选项。
- en: Restoring a Database Export with pg_restore
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`pg_restore`恢复数据库导出
- en: The `pg_restore` utility restores data from your exported database file. You
    might need to restore your database when migrating data to a new server or when
    upgrading to a new major version of PostgreSQL. To restore the `analysis` database
    (assuming you’re on a server where `analysis` doesn’t exist), at the command prompt,
    run the command in [Listing 19-12](#listing19-12).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`pg_restore`工具从导出的数据库文件中恢复数据。你可能需要在将数据迁移到新服务器或升级到新的PostgreSQL主版本时恢复数据库。要恢复`analysis`数据库（假设你所在的服务器上没有`analysis`数据库），在命令提示符下，运行[Listing
    19-12](#listing19-12)中的命令。'
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 19-12: Restoring the `analysis` database with `pg_restore`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 19-12: 使用`pg_restore`恢复`analysis`数据库'
- en: After `pg_restore`, you add the `-C` argument, which tells the utility to create
    the `analysis` database on the server. (It gets the database name from the export
    file.) Then, as you saw previously, the `-v` argument provides verbose output,
    and `-d` specifies the name of the database to connect to, followed by the `-U`
    argument and your username. Press enter, and the restore will begin. When it’s
    done, you should be able to view your restored database via `psql` or in pgAdmin.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pg_restore`后，你添加`-C`参数，这告诉工具在服务器上创建`analysis`数据库。（它从导出文件中获取数据库名称。）然后，如前所述，`-v`参数提供详细输出，`-d`指定要连接的数据库名称，后跟`-U`参数和你的用户名。按回车键，恢复过程将开始。当它完成时，你应该能够通过`psql`或pgAdmin查看恢复的数据库。
- en: Exploring Additional Backup and Restore Options
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索更多的备份和恢复选项
- en: You can configure `pg_dump` with multiple options to include or exclude certain
    database objects, such as tables matching a name pattern, or to specify the output
    format. For example, when we backed up the `analysis` database, we specified the
    `-Fc` argument with `pg_dump` to generate the backup in a custom PostgreSQL compressed
    format. By excluding the `-Fc` argument, the utility will output in plain text,
    and you can view the contents of the backup with a text editor. For details, check
    the full `pg_dump` documentation at [https://www.postgresql.org/docs/current/app-pgdump.html](https://www.postgresql.org/docs/current/app-pgdump.html).
    For corresponding restore options, check the `pg_restore` documentation at [https://www.postgresql.org/docs/current/app-pgrestore.html](https://www.postgresql.org/docs/current/app-pgrestore.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多个选项配置`pg_dump`，以包括或排除某些数据库对象，例如匹配名称模式的表，或指定输出格式。例如，当我们备份`analysis`数据库时，我们使用`-Fc`参数与`pg_dump`一起生成自定义的PostgreSQL压缩格式的备份。通过省略`-Fc`参数，工具将以纯文本格式输出，你可以使用文本编辑器查看备份内容。有关详细信息，请查看完整的`pg_dump`文档：[https://www.postgresql.org/docs/current/app-pgdump.html](https://www.postgresql.org/docs/current/app-pgdump.html)。有关相应的恢复选项，请查看`pg_restore`文档：[https://www.postgresql.org/docs/current/app-pgrestore.html](https://www.postgresql.org/docs/current/app-pgrestore.html)。
- en: You also may want to explore the `pg_basebackup` command, which can back up
    multiple databases running on a PostgreSQL server. See [https://www.postgresql.org/docs/current/app-pgbasebackup.html](https://www.postgresql.org/docs/current/app-pgbasebackup.html)
    for details. An even more robust backup solution is pgBackRest ([https://pgbackrest.org/](https://pgbackrest.org/)),
    a free, open source application with options such as cloud integration for storage
    and the ability to create full, incremental, or differential backups.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以探索`pg_basebackup`命令，它可以备份在PostgreSQL服务器上运行的多个数据库。详情请见[https://www.postgresql.org/docs/current/app-pgbasebackup.html](https://www.postgresql.org/docs/current/app-pgbasebackup.html)。一个更为强大的备份解决方案是pgBackRest（[https://pgbackrest.org/](https://pgbackrest.org/)），这是一款免费的开源应用，提供如云存储集成等选项，并且支持创建完整备份、增量备份或差异备份。
- en: Wrapping Up
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to track and conserve space in your databases
    using the `VACUUM` feature in PostgreSQL. You also learned how to change system
    settings as well as back up and restore databases using other command line tools.
    You may not need to perform these tasks every day, but the maintenance tricks
    you learned here can help enhance the performance of your databases. Note that
    this is not a comprehensive overview of the topic; see the appendix for more resources
    on database maintenance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用PostgreSQL中的`VACUUM`功能来跟踪和节省数据库空间。你还学会了如何更改系统设置，以及如何使用其他命令行工具备份和恢复数据库。你可能不需要每天都执行这些任务，但你在这里学到的维护技巧可以帮助提升数据库的性能。请注意，这不是该主题的全面概述；更多关于数据库维护的资源请参阅附录。
- en: In the next and final chapter of this book, I’ll share guidelines for identifying
    hidden trends and telling an effective story using your data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章也是最后一章，我将分享如何识别隐藏的趋势并利用数据讲述有效故事的指南。
