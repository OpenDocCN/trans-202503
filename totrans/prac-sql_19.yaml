- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining Your Database
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: To wrap up our exploration of SQL, we’ll look at key database maintenance tasks
    and options for customizing PostgreSQL. In this chapter, you’ll learn how to track
    and conserve space in your databases, how to change system settings, and how to
    back up and restore databases. How often you’ll need to perform these tasks depends
    on your current role and interests. If you want to be a *database administrator*
    or a *backend developer*, the topics covered here are vital.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that database maintenance and performance tuning are large
    enough topics that they often occupy entire books, and this chapter mainly serves
    as an introduction to a handful of essentials. If you want to learn more, a good
    place to begin is with the resources in the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the PostgreSQL `VACUUM` feature, which lets you shrink the
    size of tables by removing unused rows.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering Unused Space with VACUUM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PostgreSQL `VACUUM` command helps manage the size of a database, which—as
    discussed in “Improving Performance When Updating Large Tables” in Chapter 10—can
    grow as a result of routine operations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you update a row value, the database creates a new version
    of that row with the updated value and retains (but hides) the old version of
    the row. The PostgreSQL documentation refers to these rows that you can’t see
    as *dead tuples*, with *tuples*—an ordered list of elements—being the name for
    the internal implementation of rows in a PostgreSQL database. The same thing happens
    when you delete a row. Though the row is no longer visible to you, it lives on
    as a dead row in the table.
  prefs: []
  type: TYPE_NORMAL
- en: This is by design so the database can provide certain features in environments
    where multiple transactions are occurring, and an old version of a row might be
    needed by transactions other than the current one.
  prefs: []
  type: TYPE_NORMAL
- en: The `VACUUM` command cleans up these dead rows. Running `VACUUM` on its own
    designates the space occupied by dead rows as available for the database to use
    again (assuming that any transactions using the rows have been completed). In
    most cases, `VACUUM` doesn’t return the space to your system’s disk; it just flags
    that space as available for new data. To actually shrink the size of the data
    file, you can run `VACUUM FULL`, which rewrites the table to a new version that
    doesn’t include the dead row space. It drops the old version.
  prefs: []
  type: TYPE_NORMAL
- en: Although `VACUUM FULL` frees space on your system’s disk, there are a couple
    of caveats to keep in mind. First, `VACUUM FULL` takes more time to complete than
    `VACUUM`. Second, it must have exclusive access to the table while rewriting it,
    which means that no one can update data during the operation. The regular `VACUUM`
    command can run while updates and other operations are happening. Finally, not
    all dead space in a table is bad. In many cases, having available space to put
    new tuples instead of needing to ask the operating system for more disk space
    can improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: You can run either `VACUUM` or `VACUUM FULL` on demand, but PostgreSQL by default
    runs an *autovacuum* background process that monitors the database and runs `VACUUM`
    as needed. Later in this chapter, I’ll show you how to monitor autovacuum as well
    as run the `VACUUM` command manually. But first, let’s look at how a table grows
    as a result of updates and how you can track this growth.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Table Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll create a small test table and monitor its growth as we fill it with data
    and perform an update. The code for this exercise, as with all resources for the
    book, is available at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Table and Checking Its Size
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 19-1](#listing19-1) creates a `vacuum_test` table with a single column
    to hold an integer. Run the code, and then we’ll measure the table’s size.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-1: Creating a table to test vacuuming'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we fill the table with test data, let’s check how much space it occupies
    on disk to establish a reference point. We can do so in two ways: check the table
    properties via the pgAdmin interface or run queries using PostgreSQL administrative
    functions. In pgAdmin, click once on a table to highlight it, and then click the
    **Statistics** tab. Table size is one of about two dozen indicators in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll focus on the running queries technique here because knowing these queries
    is helpful if for some reason pgAdmin isn’t available or you’re using another
    graphical user interface (GUI). [Listing 19-2](#listing19-2) shows how to check
    the `vacuum_test` table size using PostgreSQL functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-2: Determining the size of `vacuum_test`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The outermost function, `pg_size_pretty()` 1, converts bytes to a more easily
    understandable format in kilobytes, megabytes, or gigabytes. Wrapped inside is
    the `pg_total_relation_size()` function 2, which reports how many bytes a table,
    its indexes, and any offline compressed data takes up on disk. Because the table
    is empty at this point, running the code in pgAdmin should return a value of `0
    bytes`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the same information using the command line. Launch `psql` as you
    learned in Chapter 18. Then, at the prompt, enter the meta-command `\dt+ vacuum_test`,
    which should display the following information including table size (I’ve omitted
    one column for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, the current size of the `vacuum_test` table should display `0 bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Table Size After Adding New Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s add some data to the table and then check its size again. We’ll use the
    `generate_series()` function introduced in Chapter 12 to fill the table’s `integer_column`
    with 500,000 rows. Run the code in [Listing 19-3](#listing19-3) to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-3: Inserting 500,000 rows into `vacuum_test`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This standard `INSERT INTO` statement adds the results of `generate_series()`,
    which is a series of values from 1 to 500,000, as rows to the table. After the
    query completes, rerun the query in [Listing 19-2](#listing19-2) to check the
    table size. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The query reports that the `vacuum_test` table, now with a single column of
    500,000 integers, uses 17MB of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Table Size After Updates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, let’s update the data to see how that affects the table size. We’ll use
    the code in [Listing 19-4](#listing19-4) to update every row in the `vacuum_test`
    table by adding `1` to the `integer_column` values, replacing the existing value
    with a number that’s one greater.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-4: Updating all rows in `vacuum_test`'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code, and then test the table size again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The table size doubled from 17MB to 35MB! The increase seems excessive, because
    the `UPDATE` simply replaced existing numbers with values of a similar size. As
    you might have guessed, the reason for this increase in table size is that for
    every updated value, PostgreSQL creates a new row, and the dead row remains in
    the table. Even though you see only 500,000 rows, the table has double that number.
    This behavior can lead to surprises for database owners who don’t monitor disk
    space.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at how using `VACUUM` and `VACUUM FULL` affects the table’s size
    on disk, let’s review the process that runs `VACUUM` automatically as well as
    how to check on statistics related to table vacuums.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the Autovacuum Process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PostgreSQL’s autovacuum process monitors the database and launches `VACUUM`
    automatically when it detects a large number of dead rows in a table. Although
    autovacuum is enabled by default, you can turn it on or off and configure it using
    the settings I’ll cover later in “Changing Server Settings.” Because autovacuum
    runs in the background, you won’t see any immediately visible indication that
    it’s working, but you can check its activity by querying data that PostgreSQL
    collects about system performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL has its own *statistics collector* that tracks database activity
    and usage. You can look at the statistics by querying one of several views the
    system provides. (See a complete list of views for monitoring the state of the
    system in the PostgreSQL documentation under “The Statistics Collector”: [https://www.postgresql.org/docs/current/monitoring-stats.html](https://www.postgresql.org/docs/current/monitoring-stats.html).)
    To check the activity of autovacuum, we query the `pg_stat_all_tables` view, as
    shown in [Listing 19-5](#listing19-5).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-5: Viewing autovacuum statistics for `vacuum_test`'
  prefs: []
  type: TYPE_NORMAL
- en: As you learned in Chapter 17, a view provides the results of a stored query.
    The query stored by the view `pg_stat_all_tables` returns a column called `relname`1,
    which is the name of the table, plus columns with statistics related to index
    scans, rows inserted and deleted, and other data. For this query, we’re interested
    in `last_vacuum` 2 and `last_autovacuum` 3, which contain the last time the table
    was vacuumed manually and automatically, respectively. We also ask for `vacuum_count`
    4 and `autovacuum_count` 5, which show the number of times the vacuum was run
    manually and automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, autovacuum checks tables every minute. So, if a minute has passed
    since you last updated `vacuum_test`, you should see details of vacuum activity
    when you run the query in [Listing 19-5](#listing19-5). Here’s what my system
    shows (note that I’ve removed the seconds from the time to save space here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The table shows the date and time of the last autovacuum, and the `autovacuum_count`
    column shows one occurrence. This result indicates that autovacuum executed a
    `VACUUM` command on the table once. However, because we’ve not vacuumed manually,
    the `last_vacuum` column is empty, and the `vacuum_count` is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that `VACUUM` designates dead rows as available for the database to reuse
    but typically doesn’t reduce the size of the table on disk. You can confirm this
    by rerunning the code in [Listing 17-2](c17.xhtml#listing17-2), which shows the
    table remains at 35MB even after the automatic vacuum.
  prefs: []
  type: TYPE_NORMAL
- en: Running VACUUM Manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run `VACUUM` manually, you can use the single line of code in [Listing 19-6](#listing19-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-6: Running `VACUUM` manually'
  prefs: []
  type: TYPE_NORMAL
- en: This command should return the message `VACUUM` from the server. Now when you
    fetch statistics again using the query in [Listing 17-5](c17.xhtml#listing17-5),
    you should see that the `last_vacuum` column reflects the date and time of the
    manual vacuum you just ran, and the number in the `vacuum_count` column should
    increase by one.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we executed `VACUUM` on our test table, but you can also run
    `VACUUM` on the entire database by omitting the table name. In addition, you can
    add the `VERBOSE` keyword to return information such as the number of rows found
    in a table and the number of rows removed, among other information.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing Table Size with VACUUM FULL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll run `VACUUM` with the `FULL` option, which actually returns the
    space taken up by dead tuples back to disk. It does this by creating a new version
    of a table with the dead rows discarded.
  prefs: []
  type: TYPE_NORMAL
- en: To see how `VACUUM FULL` works, run the command in [Listing 19-7](#listing19-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-7: Using `VACUUM FULL` to reclaim disk space'
  prefs: []
  type: TYPE_NORMAL
- en: After the command executes, test the table size again. It should be back down
    to 17MB, the size it was when we first inserted data.
  prefs: []
  type: TYPE_NORMAL
- en: It’s never prudent or safe to run out of disk space, so minding the size of
    your database files as well as your overall system space is a worthwhile routine
    to establish. Using `VACUUM` to prevent database files from growing bigger than
    they have to is a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Server Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can alter the settings for your PostgreSQL server by editing values in *postgresql.conf*,
    one of several configuration text files that control server settings. Other files
    include *pg_hba.conf*, which controls connections to the server, and *pg_ident.conf*,
    which database administrators can use to map usernames on a network to usernames
    in PostgreSQL. See the PostgreSQL documentation on these files for details; here
    we’ll just cover *postgresql.conf* because it contains settings you may likely
    want to change. Most of the values in the file are set to defaults you may never
    need to adjust, but it’s worth exploring in case you’re fine-tuning your system.
    Let’s start with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Locating and Editing postgresql.conf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The location of *postgresql.conf* varies depending on your operating system
    and install method. You can run the command in [Listing 19-8](#listing19-8) to
    locate the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-8: Showing the location of *postgresql.conf*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run the command on macOS, it shows the path to the file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To edit *postgresql.conf*, navigate in your file system to the directory displayed
    by `SHOW config_file;` and open the file using a text editor. Don’t use a rich-text
    editor like Microsoft Word, as it may add additional formatting to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the file, the first several lines should read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The *postgresql.conf* file is organized into sections that specify settings
    for file locations, security, logging of information, and other processes. Many
    lines begin with a hash mark (`#`), which indicates the line is commented out
    and the setting shown is the active default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the *postgresql.conf* file section “Autovacuum Parameters,”
    the default is for autovacuum to be turned on (which is a good, standard practice).
    The hash mark (`#`) in front of the line means that the line is commented out
    and the default value is in effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To change this or other default settings, you would remove the hash mark, adjust
    the setting value, and save *postgresql.conf*. Some changes, such as to memory
    allocations, require a restart of the server; they’re noted in *postgresql.conf*.
    Other changes require only a reload of settings files. You can reload settings
    files by running the function `pg_reload_conf()` under an account with superuser
    permissions or by executing the `pg_ctl` command, which we’ll cover in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 19-9](#listing19-9) shows settings you may want to change, excerpted
    from the *postgresql.conf* section “Client Connection Defaults.” Use your text
    editor to search the file for the following.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-9: Sample *postgresql.conf* settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `datestyle` setting 1 to specify how PostgreSQL displays dates
    in query results. This setting takes two parameters separated by a comma: the
    output format and the ordering of month, day, and year. The default for the output
    format is the ISO format `YYYY-MM-DD` we’ve used throughout this book, which I
    recommend for its cross-national portability. However, you can also use the traditional
    SQL format `MM/DD/YYYY`, the expanded Postgres format `Sun Nov 12 22:30:00 2023
    EST`, or the German format `DD.MM.YYYY` with dots between the date, month, and
    year (`12.11.2023`). To specify the format using the second parameter, arrange
    `m`, `d`, and `y` in the order you prefer.'
  prefs: []
  type: TYPE_NORMAL
- en: The `timezone` 2 parameter sets the server time zone. [Listing 19-9](#listing19-9)
    shows the value `America/New_York`, which reflects the time zone on my machine
    when I installed PostgreSQL. Yours should vary based on your location. When setting
    up PostgreSQL for use as the backend to a database application or on a network,
    administrators often set this value to `UTC` and use that as a standard on machines
    across multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: The `default_text_search_config` 3 value sets the language used by the full-text
    search operations. Here, mine is set to `english`. Depending on your needs, you
    can set this to `spanish`, `german`, `russian`, or another language of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: These three examples represent only a handful of settings available for adjustment.
    Unless you end up deep in system tuning, you probably won’t have to tweak much
    else. Also, use caution when changing settings on a network server used by multiple
    people or applications; changes can have unintended consequences, so it’s worth
    communicating with colleagues first.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how to use `pg_ctl` to make changes take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading Settings with pg_ctl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The command line utility `pg_ctl` allows you to perform actions on a PostgreSQL
    server, such as starting and stopping it and checking its status. Here, we’ll
    use the utility to reload the settings files so the changes we make will take
    effect. Running the command reloads all settings files at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to open and configure a command line prompt the same way you did
    in Chapter 18 when you learned how to set up and use `psql`. After you launch
    a command prompt, use one of the following commands to reload, replacing the path
    with the path to the PostgreSQL data directory:'
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, use `pg_ctl reload -D "``C:\path\to\data\directory\``"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On macOS or Linux, use `pg_ctl reload -D '``/path/to/data/directory/``'`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To find the location of your PostgreSQL data directory, run the query in [Listing
    19-10](#listing19-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-10: Showing the location of the data directory'
  prefs: []
  type: TYPE_NORMAL
- en: Place the path after the `-D` argument, between double quotes on Windows and
    single quotes on macOS or Linux. You run this command on your system’s command
    prompt, not inside the `psql` application. Enter the command and press enter;
    it should respond with the message `server signaled`. The settings files will
    be reloaded, and changes should take effect.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve changed settings that require a server restart, replace `reload` in
    [Listing 19-10](#listing19-10) with `restart`.
  prefs: []
  type: TYPE_NORMAL
- en: Backing Up and Restoring Your Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might want to back up your entire database either for safekeeping or for
    transferring data to a new or upgraded server. PostgreSQL offers command line
    tools that make backup and restore operations easy. The next few sections show
    examples of how to export data from a database or a single table to a file, as
    well as how to restore data from an export files.
  prefs: []
  type: TYPE_NORMAL
- en: Using pg_dump to Export a Database or Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL command line tool `pg_dump` creates an output file that contains
    all the data from your database; SQL commands for re-creating tables, views, functions,
    and other database objects; and commands for loading the data into tables. You
    can also use `pg_dump` to save only selected tables in your database. By default,
    `pg_dump` outputs a text file; I’ll discuss an alternate custom compressed format
    first and then discuss other options.
  prefs: []
  type: TYPE_NORMAL
- en: To export the `analysis` database we’ve used for our exercises to a file, run
    the command in [Listing 19-11](#listing19-11) at your system’s command prompt
    (not in `psql`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-11: Exporting the `analysis` database with `pg_dump`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we start the command with `pg_dump` and use similar connection arguments
    as with `psql`. We specify the database to export with the `-d` argument, followed
    by the `-U` argument and your username. Next, we use the `-Fc` argument to specify
    that we want to generate this export in a custom PostgreSQL compressed format
    and the `-v` argument to generate verbose output. Then we use the `-f` argument
    to direct the output of `pg_dump` to a text file named *analysis_backup.dump*.
    To place the file in a directory other than the one your terminal prompt is currently
    open to, you can specify the complete directory path before the filename.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the command, depending on your installation, you might see
    a password prompt. Fill in that password, if prompted. Then, depending on the
    size of your database, the command could take a few minutes to complete. You’ll
    see a series of messages about the objects the command is reading and outputting.
    When it’s done, it should return you to a new command prompt, and you should see
    a file named *analysis_backup.dump* in your current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To limit the export to one or more tables that match a particular name, use
    the `-t` argument followed by the name of the table in single quotes. For example,
    to back up just the `train_rides` table, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s look at how to restore the data from the export file, and then we’ll
    explore additional `pg_dump` options.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring a Database Export with pg_restore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pg_restore` utility restores data from your exported database file. You
    might need to restore your database when migrating data to a new server or when
    upgrading to a new major version of PostgreSQL. To restore the `analysis` database
    (assuming you’re on a server where `analysis` doesn’t exist), at the command prompt,
    run the command in [Listing 19-12](#listing19-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 19-12: Restoring the `analysis` database with `pg_restore`'
  prefs: []
  type: TYPE_NORMAL
- en: After `pg_restore`, you add the `-C` argument, which tells the utility to create
    the `analysis` database on the server. (It gets the database name from the export
    file.) Then, as you saw previously, the `-v` argument provides verbose output,
    and `-d` specifies the name of the database to connect to, followed by the `-U`
    argument and your username. Press enter, and the restore will begin. When it’s
    done, you should be able to view your restored database via `psql` or in pgAdmin.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Additional Backup and Restore Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can configure `pg_dump` with multiple options to include or exclude certain
    database objects, such as tables matching a name pattern, or to specify the output
    format. For example, when we backed up the `analysis` database, we specified the
    `-Fc` argument with `pg_dump` to generate the backup in a custom PostgreSQL compressed
    format. By excluding the `-Fc` argument, the utility will output in plain text,
    and you can view the contents of the backup with a text editor. For details, check
    the full `pg_dump` documentation at [https://www.postgresql.org/docs/current/app-pgdump.html](https://www.postgresql.org/docs/current/app-pgdump.html).
    For corresponding restore options, check the `pg_restore` documentation at [https://www.postgresql.org/docs/current/app-pgrestore.html](https://www.postgresql.org/docs/current/app-pgrestore.html).
  prefs: []
  type: TYPE_NORMAL
- en: You also may want to explore the `pg_basebackup` command, which can back up
    multiple databases running on a PostgreSQL server. See [https://www.postgresql.org/docs/current/app-pgbasebackup.html](https://www.postgresql.org/docs/current/app-pgbasebackup.html)
    for details. An even more robust backup solution is pgBackRest ([https://pgbackrest.org/](https://pgbackrest.org/)),
    a free, open source application with options such as cloud integration for storage
    and the ability to create full, incremental, or differential backups.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to track and conserve space in your databases
    using the `VACUUM` feature in PostgreSQL. You also learned how to change system
    settings as well as back up and restore databases using other command line tools.
    You may not need to perform these tasks every day, but the maintenance tricks
    you learned here can help enhance the performance of your databases. Note that
    this is not a comprehensive overview of the topic; see the appendix for more resources
    on database maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of this book, I’ll share guidelines for identifying
    hidden trends and telling an effective story using your data.
  prefs: []
  type: TYPE_NORMAL
