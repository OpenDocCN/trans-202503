- en: '**13**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CONTROL STRUCTURES AND PROGRAMMATIC DECISIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Control structures are the bread and butter of high-level language (HLL) programming.
    The ability to make decisions based on the evaluation of stated conditions is
    fundamental to practically every kind of automation that computers provide. The
    translation of HLL control structures into machine code has, perhaps, the largest
    impact on program performance and size. As you’ll see in this chapter, knowing
    which control structures to use in a given situation is the key to writing great
    code. In particular, this chapter describes the machine implementation of control
    structures related to decision making and unconditional flow, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`switch` or `case` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goto` and related statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following two chapters will expand this discussion to loop control structures
    and procedure/function calls and returns.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.1 How Control Structures Affect a Program’s Efficiency**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fair percentage of the machine instructions in a program control the execution
    path through that program. Because control transfer instructions often flush the
    instruction pipeline (see *WGC1*), they tend to be slower than instructions that
    perform simple calculations. To produce efficient programs, you should reduce
    the number of control transfer instructions or, if that’s not possible, choose
    the fastest ones.
  prefs: []
  type: TYPE_NORMAL
- en: The exact set of instructions that CPUs use to control program flow varies across
    processors. Nevertheless, many CPUs (including the five families covered in this
    book) control program flow using the “compare-and-jump” paradigm. That is, after
    a compare or another instruction that modifies the CPU flags, a conditional jump
    instruction transfers control to another location based on the CPU flag settings.
    Some CPUs can do all this with a single instruction, while others require two,
    three, or more. Some CPUs allow you to compare two values for a large range of
    different conditions, whereas others allow only a few tests. Regardless of the
    mechanism, HLL statements that map to a given sequence on one CPU will map to
    a comparable sequence on a second CPU. Therefore, if you understand the basic
    conversion for one CPU, you’ll have a good idea how the compiler works across
    all CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.2 Introduction to Low-Level Control Structures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most CPUs use a two-step process to make a programmatic decision. First, the
    program compares two values and saves the result of the comparison in a machine
    register or flag. Then the program tests that result and, based on what it learns,
    transfers control to one of two locations. With little more than this *compare
    and conditional branch* sequence, it is possible to synthesize most of the major
    HLL control structures.
  prefs: []
  type: TYPE_NORMAL
- en: Even within the compare and conditional branch paradigm, CPUs commonly implement
    conditional code sequences using two different approaches. One technique, especially
    common on stack-based architectures (such as the UCSD p-machine, Java Virtual
    Machine, and Microsoft CLR), is to have different forms of the compare instruction
    that test for specific conditions. For example, you might have *compare if equal*,
    *compare if not equal*, *compare if less than*, *compare if greater than*, and
    so on. The result of each is a Boolean value. Then a pair of conditional branch
    instructions, *branch if true* and *branch if false*, can test the result of the
    comparison and transfer control to the appropriate location. Some of these VMs
    might actually merge the compare and branch instructions into “compare and branch”
    instructions (one for each condition to test). Despite using fewer instructions,
    the end result is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: The second, and historically more popular, approach is for the CPU’s instruction
    set to contain a single comparison instruction that sets (or clears) several bits
    in the CPU’s *program status* or *flags* register. Then the program uses one of
    several more specific conditional branch instructions to transfer control to some
    other location. These conditional branch instructions might have names such as
    *jump if equal*, *jump if not equal*, *jump if less than*, or *jump if greater
    than*. Because this “compare and jump” technique is the one the 80x86, ARM, and
    PowerPC use, that’s also the approach this chapter’s examples use; however, it’s
    easy to convert them to the multiple comparisons/jump true/jump false paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 32-bit variants of the ARM processor introduce a third technique: conditional
    execution. Most instructions (not just the branches) on the 32-bit ARM provide
    this option. For example, the `addeq` instruction adds two values if and only
    if the result of the previous comparison (or other operation) has set the zero
    flag. See “Conditional Suffixes for Instructions” in Appendix C online for more
    details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional branches are typically two-way branches. That is, they transfer
    control to one location in the program if the condition they’re testing is `true`
    and to a different location if the condition is `false`. To reduce the size of
    the instruction, the conditional branches on most CPUs encode the address of only
    one of the two possible branch locations, and they use an implied address for
    the opposite condition. Specifically, most conditional branches transfer control
    to some target location if the condition is `true` and fall through to the next
    instruction if the condition is `false`. For example, consider the following 80x86
    `je` (jump if equal) instruction sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This instruction sequence begins by comparing the value in the EAX register
    against the value in EBX (the `cmp` instruction); this sets the *condition-code
    bits* in the 80x86 EFLAGS register. In particular, this instruction sets the 80x86
    zero flag to `1` if the value in EAX is equal to the value in EBX. The `je` instruction
    tests the zero flag to see if it is set, and if so, transfers control to the machine
    instruction immediately following the `EAXequalsEBX` label. If the value in EAX
    is not equal to EBX, then the `cmp` instruction clears the zero flag and the `je`
    instruction falls through to the `mov` instruction rather than transferring control
    to the destination label.
  prefs: []
  type: TYPE_NORMAL
- en: Certain machine instructions that access data can be smaller (and faster) if
    the memory location the machine instruction accesses is near the base address
    of the activation record containing that variable. This rule also applies to conditional
    jump instructions. The 80x86 provides two forms of the conditional jump instructions.
    One form is only 2 bytes long (1 byte for an opcode and 1 byte for a signed displacement
    in the range –128 through +127). The other form is 6 bytes long (2 bytes for the
    opcode and 4 bytes for a signed displacement in the range –2 billion through +2
    billion). The displacement value specifies how far (in bytes) the program must
    jump to reach the target location. To transfer control to a nearby location, the
    program can use the short form of the branch. Because 80x86 instructions are between
    1 and 15 bytes long (typically around 3 or 4 bytes long), the short forms of the
    conditional jump instructions can usually skip over about 32 to 40 machine instructions.
    Once the target location is out of the ±127-byte range, the 6-byte version of
    these conditional jump instructions extends the range to ±2 billion bytes around
    the current instruction. If you’re interested in writing the most efficient code,
    then, you’ll want to use the 2-byte form as often as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Branching is an expensive operation in a modern (pipelined) CPU because a branch
    may require the CPU to flush the pipeline and reload it (see *WGC1* for more details).
    Conditional branches incur this cost only if the branch is taken; if the conditional
    branch instruction falls through to the next instruction, the CPU will continue
    to use the instructions found in the pipeline without flushing them. Therefore,
    on many systems the *branch that falls through to the next instruction is faster
    than the branch that is taken*. Note, however, that some CPUs (like the 80x86,
    PowerPC, and ARM) support a *branch prediction* feature that tells the CPU to
    begin fetching instructions for the pipeline from the branch’s target location
    rather than from the instructions that immediately follow the conditional jump.
    Unfortunately, branch prediction algorithms vary from processor to processor (even
    within the 80x86 CPU family), so it’s difficult to predict, in general, how branch
    prediction will affect your HLL code. It’s probably safest to assume, unless you’re
    writing code for a specific processor, that falling through to the next instruction
    is more efficient than taking the jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the compare and conditional branch paradigm is the most common control
    structure found in machine code programs, there are other ways to transfer control
    to another location in memory based on some computed result. Without question,
    the indirect jump (especially via a table of addresses) is the most common alternative
    form. Consider the following 32-bit 80x86 `jmp` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This `jmp` instruction fetches the double-word value at the index specified
    by the value in EBX in the `jmpTable` array. That is, the instruction transfers
    control to one of four different locations based upon the value (`0..3`) in EBX.
    For example, if EBX contains `0`, then the `jmp` instruction fetches the double
    word at index `0` in `jmpTable` (the address of the instruction prefixed by `label1`).
    Likewise, if EBX contains `2`, then this `jmp` instruction fetches the third double
    word from this table (the address of `label3` in the program). This is roughly
    equivalent to, but usually shorter than, the following sequence of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A few other conditional control transfer mechanisms are available on various
    CPUs, but these two mechanisms (compare and conditional branch and indirect jump)
    are the ones most HLL compilers use to implement standard control structures in
    the HLL.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3 The goto Statement**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `goto` statement is, perhaps, the most fundamental low-level control structure.
    Since the wave of “structured programming” in the late 1960s and 1970s, its use
    in HLL code has diminished. Indeed, some modern high-level programming languages
    (for example, Java and Swift) don’t even provide an unstructured `goto` statement.
    Even in those languages where one is available, programming style guidelines usually
    restrict its use to special circumstances. Combined with the fact that student
    programmers have been religiously taught to avoid them in their programs since
    the mid 1970s, it’s now rare to find many `goto` statements in a modern program.
    From a readability point of view, this is a good thing (check out some 1960sera
    FORTRAN programs to get an idea of how hard to read code can be when it’s peppered
    with `goto` statements). Nevertheless, some programmers believe that they can
    achieve higher efficiency by using `goto` statements in their code. While this
    is sometimes true, the gains are rarely worth the loss of readability that ultimately
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the big efficiency arguments for `goto` is that it helps avoid duplicate
    code. Consider the following simple C/C++ example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmers looking for ways to make their programs more efficient will immediately
    notice all the duplicated code and might be tempted to rewrite the example as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are, of course, several software engineering problems with this code,
    including the fact that it is a bit harder to read, modify, and maintain than
    the original example. (You *could* argue that it’s actually a little easier to
    maintain, because you no longer have duplicated code and you only have to fix
    defects in the common code at one spot.) However, there’s no denying that there’s
    less code in this example. Or is there?
  prefs: []
  type: TYPE_NORMAL
- en: The optimizers in many modern compilers actually look for code sequences like
    the first example and generate code that’s identical to what you’d expect for
    the second example. Therefore, a *good* compiler avoids generating duplicate machine
    code even when the source file contains duplication, as in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C/C++ example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the compilation of the `if` sequence to PowerPC code by GCC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of course, not every compiler has an optimizer that will recognize the duplicated
    code. So, if you want to write a program that compiles to efficient machine code
    regardless of the compiler, you might be tempted to use the version of the code
    that employs the `goto` statement. Indeed, you could make a strong software engineering
    argument that having duplicate code in a source file makes the program harder
    to read and harder to maintain. (If you fix a defect in one copy of the code,
    chances are that you’ll forget to correct the defect in the other copies of the
    code.) While this is definitely true, if you make changes to the code at the target
    label, it’s not immediately obvious that the change is appropriate for each and
    every section of code that jumps to the target label. And it’s not immediately
    obvious how many different `goto` statements transfer control to the same target
    label when you’re reading through the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional software engineering approach is to put the common code into
    a procedure or function and simply call that function. However, the overhead of
    a function call and return can be rather large (especially if there isn’t much
    duplicated code), so from a performance point of view, that approach may not be
    satisfactory. For short sequences of common code, creating a macro or an inline
    function is probably the best solution. To complicate the issue, you might need
    a change that affects only one instance of the duplicated code (that is, it would
    no longer be a duplicate). The bottom line is that using a `goto` statement to
    gain efficiency in this manner should be your last resort.
  prefs: []
  type: TYPE_NORMAL
- en: Another common use for `goto` statements is for exceptional conditions. When
    you find yourself nested deeply in several statements and you encounter a situation
    where you need to exit all those statements, the common consensus is that a `goto`
    is acceptable if restructuring the code wouldn’t make it more readable. However,
    jumps out of nested blocks may thwart the optimizer’s ability to generate decent
    code for the entire procedure or function. The use of the `goto` statement may
    save a few bytes or processor cycles in the code it immediately affects, but it
    could have detrimental effects on the rest of the function, resulting in less
    efficient code overall. So, take care when inserting `goto` statements into your
    code—they can make your source code harder to read, and might wind up making it
    less efficient as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For what it’s worth, there’s a programming trick you can use to solve the original
    problem. Consider the following modification to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is tricky code, and tricky code isn’t usually great code. However,
    it does have the benefit of avoiding duplication of source code in your program.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3.1 Restricted Forms of the goto Statement**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an effort to support structured `goto`-less programming, many programming
    languages have added restricted forms of the `goto` statement that allow a programmer
    to immediately exit a control structure such as a loop or a procedure/function.
    Typical statements include `break` and `exit`, which jump out of an enclosing
    loop; `continue`, `cycle`, and `next`, which restart an enclosing loop; and `return`
    and `exit`, which immediately return from an enclosing procedure or function.
    These statements are more structured than a standard `goto` because the programmer
    doesn’t choose the destination; instead, control transfers to a fixed location
    based upon whatever control statement (or function or procedure) encloses the
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every one of these statements compiles into a single `jmp` instruction.
    Those that jump out of a loop (such as `break`) compile into a single `jmp` instruction
    that transfers control to the first statement beyond the bottom of the loop. Those
    that restart a loop (for example, `continue`, `next`, or `cycle`) compile into
    a single `jmp` instruction that transfers control to the loop termination test
    (in the case of while or `repeat..until`/`do..while`) or to the top of the loop
    (in the case of most other loops).
  prefs: []
  type: TYPE_NORMAL
- en: However, just because these statements typically compile to a single `jmp` instruction
    doesn’t mean they’re efficient to use. Even ignoring the fact that a `jmp` can
    be somewhat expensive (because it forces the CPU to flush the instruction pipeline),
    statements that branch out of a loop can have a serious impact on the compiler’s
    optimizer, dramatically reducing the opportunity to generate high-quality code.
    Therefore, you should attempt to use these statements as sparingly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4 The if Statement**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the most basic high-level control structure is the `if` statement. Indeed,
    with nothing more than an `if` and a `goto` statement, you can (semantically)
    implement all other control structures.^([1](footnotes.xhtml#ch13fn1)) We’ll revisit
    this point when discussing other control structures, but for now we’ll look at
    how a typical compiler converts an `if` statement into machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a simple `if` statement that compares two values and executes
    the body if the condition is `true`, you can use a single compare and conditional
    branch instruction. Consider the following Pascal `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the conversion to 80x86/HLA code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Pascal source code, the body of the `if` statement executes if the value
    of EAX is equal to EBX. In the resulting assembly code, the program compares EAX
    with EBX and then, if EAX does not equal EBX, branches over the statements that
    correspond to the `if` statement’s body. This is the “boilerplate” conversion
    of an HLL `if` statement into machine code: test some condition and, if it’s `false`,
    branch over the `if` statement’s body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of an `if..then..else` statement is only slightly more complicated
    than the basic `if` statement. An `if..then..else` statement typically employs
    syntax and semantics such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing this code sequence in machine code requires only a single machine
    instruction beyond what a simple `if` statement requires. Consider this example
    C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the conversion to 80x86 assembly language code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are two things to note about this code. First, if the condition evaluates
    to `false`, the code transfers to the first statement of the `else` block rather
    than the first statement following the (entire) `if` statement. The second thing
    to note is the `jmp` instruction at the end of the `true` clause skips the `else`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages, including HLA, support an `elseif` clause in their `if` statement
    to evaluate a second condition if the first one fails. This is a straightforward
    extension of the code generation of the `if` statement I’ve shown. Consider the
    following HLA `if..elseif..else..endif` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the conversion to pure 80x86/HLA assembly language code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The translation of the `elseif` clause is very straightforward; the machine
    code for it is identical to an `if` statement. What’s noteworthy here is how the
    compiler emits a `jmp` instruction at the end of the `if..then` clause to skip
    around the Boolean test emitted for the `elseif` clause.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4.1 Improving the Efficiency of Certain if/else Statements**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'From an efficiency point of view, it’s important to note that there’s no path
    through the `if..else` statement that doesn’t involve a transfer of control (unlike
    the simple `if` statement, which simply falls through if the conditional expression
    is `true`). As this chapter has pointed out, branches are bad because they often
    flush the CPU’s instruction pipeline, which takes several CPU cycles to refill.
    If both outcomes of the Boolean expression (`true` and `false`) are equally likely,
    there’s little you can do to improve the code’s performance by rearranging the
    `if..else` statement. For most `if` statements, however, one outcome is often
    more likely—perhaps much more likely—than the other. Assembly coders who understand
    the likelihood of one comparison over another will often encode their `if..else`
    statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the most common case (where the expression evaluates to `true`),
    the code falls through to the `then` section, which then falls straight through
    to the code that follows the entire `if` statement. Therefore, if the Boolean
    expression (`eax == ebx`) is `true` most of the time, this code executes straight
    through without any branches. In the rare case, when EAX does not equal EBX, the
    program actually has to execute two branches: one to transfer control to the section
    of code that handles the `else` clause, and one to return control to the first
    statement following the `if`. As long as this occurs less than half of the time,
    the software sees an overall performance boost. You can achieve this same result
    in an HLL such as C using `goto` statements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the drawback to this scheme is that it produces *spaghetti code*
    that becomes unreadable once you add more than a few of these kludges. Assembly
    language programmers get away with this because most assembly language code is,
    by definition, spaghetti code.^([2](footnotes.xhtml#ch13fn2)) For HLL code, however,
    this programming style is generally unacceptable, and you should use it only when
    necessary. (See “The `goto` Statement” on [page 455](ch13.xhtml#page_455).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following generic `if` statement is common in programs written in HLLs
    such as C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the conversion of this C code into 80x86/HLA assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve seen in previous examples, the `if..then..else` statement conversion
    to assembly language requires two control transfer instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `jne` instruction that tests the comparison between EAX and EBX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unconditional `jmp` instruction that skips over the `else` section of the
    `if` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regardless of which path the program takes (through the `then` or the `else`
    section), the CPU executes a slow branch instruction that winds up flushing the
    instruction pipeline. Consider the following code, which does not have this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its conversion to pure 80x86/HLA assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if the expression evaluates to `true`, the CPU executes no control
    transfer statements at all. Yes, the CPU executes an extra `mov` instruction whose
    result is immediately overwritten (so the execution of the first `mov` instruction
    is wasted); however, the execution of this extra `mov` instruction happens much
    more rapidly than the execution of the `jmp` instruction. This trick is a prime
    example of why it’s a good idea to know some assembly language code (and know
    how compilers generate machine code from high-level code). It’s not at all obvious
    that the second sequence is better than the first. Beginning programmers, in fact,
    would probably believe it to be inferior because the program “wastes” an assignment
    to `i` when the expression evaluates to `true` (and no such assignment is made
    in the first version). This is one reason why this chapter exists—to make sure
    you understand the costs associated with using high-level control structures.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4.2 Forcing Complete Boolean Evaluation in an if Statement**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because complete Boolean evaluation and short-circuit Boolean evaluation can
    produce different results (see “Short-Circuit Evaluation” on [page 441](ch12.xhtml#page_441)),
    there are times when you’ll need to force your code to use one form or the other
    when computing the result of a Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general way to force complete Boolean evaluation is to evaluate each subcomponent
    of the expression and store the subresult into temporary variables. Then you can
    combine the temporary results after their computation to produce the complete
    result. For example, consider the following Pascal code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Because Pascal doesn’t guarantee complete Boolean evaluation, function `f()`
    might not be called in this expression—if `i` is less than `g(y)`—and thus any
    side effects produced by the call to `f()` might not occur. (See “Side Effects
    in Arithmetic Expressions” on [page 430](ch12.xhtml#page_430).) If the logic of
    the application depends on any side effects produced by the calls to `f()` and
    `g()`, then you must ensure that the application calls both functions. Note that
    simply swapping the two subexpressions around the AND operator is insufficient
    to solve this problem; with that change, the application might not call `g()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to solve this problem is to compute the Boolean results of the two
    subexpressions using separate assignment statements and then compute the logical
    AND of the two results within the `if` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t be too concerned about the efficiency loss that could result from using
    these temporary variables. Any compiler that provides optimization facilities
    will put these values into registers and not bother using actual memory locations.
    Consider the following variant of the previous Pascal program written in C and
    compiled with the Visual C++ compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the conversion to 32-bit MASM code by the Visual C++ compiler (a few
    instructions have been rearranged to make their intent clearer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you scan the assembly code, you’ll see that this code fragment always executes
    the calls to both `f()` and `g()`. Contrast this with the following C code and
    assembly output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the MASM assembly output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In C, you can use another trick to force complete Boolean evaluation in any
    Boolean expression. The C bitwise operators do not support short-circuit Boolean
    evaluation. If your subexpressions in a Boolean expression always produce `0`
    or `1`, the bitwise Boolean conjunction and disjunction operators (that is, `&`
    and `|`) produce identical results to the logical Boolean operators (`&&` and
    `||`). Consider the following C code and the MASM code that the Visual C++ compiler
    produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the MASM code emitted by Visual C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note how the use of the bitwise operators produces comparable code to the earlier
    sequence that used temporary variables. This creates less clutter in your original
    C source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do keep in mind, however, that C’s bitwise operators produce the same results
    as the logical operators *only* if the operands are `0` and `1`. Fortunately,
    you can use a little C trick here: just write `!!(expr`), and if the expression’s
    value is zero or nonzero, C will convert the result to `0` or `1`. To see this
    in action, consider the following C/C++ code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the 80x86 assembly code that Microsoft’s Visual C++ compiler produces
    for this short program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the 80x86 assembly output, only three machine instructions
    (involving no expensive branches) are needed to convert zero/nonzero to `0`/`1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4.3 Forcing Short-Circuit Evaluation in an if Statement**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although it’s useful to be able to force complete Boolean evaluation on occasion,
    needing to force short-circuit evaluation is probably more common. Consider the
    following Pascal statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The Pascal language definition leaves it up to the compiler writer to decide
    whether to use complete Boolean evaluation or short-circuit evaluation. In fact,
    the writer is free to use both schemes as desired. Thus, it’s quite possible that
    the same compiler could use complete Boolean evaluation for the previous statement
    in one section of the code and short-circuit evaluation in another.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this Boolean expression will fail if `ptrVar` contains the
    NIL pointer value and if the compiler uses complete Boolean evaluation. The only
    way to get this statement to work properly is by using short-circuit Boolean evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simulating short-circuit Boolean evaluation with the AND operator is actually
    quite simple. All you have to do is create a pair of nested `if` statements and
    place each subexpression in each one. For example, you could guarantee short-circuit
    Boolean evaluation in the current Pascal example by rewriting it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This statement is semantically identical to the previous one. It should be clear
    that the second subexpression will not execute if the first expression evaluates
    to `false`. Even though this approach clutters up the source file a bit, it does
    guarantee short-circuit evaluation regardless of whether the compiler supports
    that scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling the logical-OR operation is a little more difficult. Guaranteeing
    that the right operand of a logical-OR does not execute if the left operand evaluates
    to `true` requires an extra test. Consider the following C code (remember that
    C supports short-circuit evaluation by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the machine code that the Microsoft Visual C++ compiler produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a version of the C program that implements short-circuit evaluation
    without relying on the C compiler to do so (not that this is necessary for C,
    as its language definition guarantees short-circuit evaluation, but you could
    use this approach in any language):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the corresponding MASM code emitted by the Microsoft Visual C++ compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code the compiler emits for the second version of the routine,
    which manually forces short-circuit evaluation, isn’t quite as good as that emitted
    by the C compiler for the first example. However, if you need the semantics for
    short-circuit evaluation so the program will execute correctly, you’ll have to
    live with possibly less efficient code than you’d get if the compiler supported
    this scheme directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If speed, minimal size, and short-circuit evaluation are all necessary, and
    you’re willing to sacrifice a little readability and maintainability in your code
    to achieve them, then you can destructure the code and create something comparable
    to what the C compiler produces using short-circuit evaluation. Consider the following
    C code and the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the MASM output from Visual C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you compare this code to the MASM output for the original C example (which
    relies on short-circuit evaluation), you’ll see that this code is just as efficient.
    This is a classic example of why there was considerable resistance to structured
    programming in the 1970s among some programmers—sometimes it leads to less efficient
    code. Of course, readability and maintainability are usually more important than
    a few bytes or machine cycles. But never forget that if performance is paramount
    for a small section of code, destructuring that code can improve efficiency in
    some special cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5 The switch/case Statement**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `switch` (or `case`) high-level control statement is another conditional
    statement found in HLLs. As you’ve seen, an `if` statement tests a Boolean expression
    and executes one of two different paths in the code based on the result of the
    expression. A `switch/case` statement, on the other hand, can branch to one of
    several different points in the code based on the result of an ordinal (integer)
    expression. The following examples demonstrate the `switch` and `case` statements
    in C/C++, Pascal, and HLA. First, the C/C++ `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Java and Swift provide a similar syntax to C/C++ for the `switch` statement,
    although Swift’s version has many additional features. We’ll explore some of those
    additional features in the section “The Swift `switch` Statement” on [page 500](ch13.xhtml#page_500).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a Pascal `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, here’s the HLA `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell by these examples, these statements all share a similar syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5.1 Semantics of a switch/case Statement**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most beginning programming classes and textbooks teach the semantics of the
    `switch`/`case` statement by comparing it with a chain of `if..else..if` statements;
    this introduces the `switch`/`case` statement using a concept the student already
    understands. Unfortunately, this approach can be misleading. To see why, consider
    the following code, which an introductory Pascal programming book might claim
    is equivalent to our Pascal `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Although this particular sequence will achieve the same result as the `case`
    statement, there are several fundamental differences between the `if..then..elseif`
    sequence and the Pascal `case` implementation. First, the case labels in a `case`
    statement must all be constants, but in an `if..then..elseif` chain you can actually
    compare variables and other nonconstant values against the control variable. Another
    limitation of the `switch`/`case` statement is that you can compare only the value
    of a single expression against a set of constants; you cannot compare one expression
    against a constant for one case and a separate expression against a second constant,
    as you can with an `if..then..elseif` chain. The reason for these limitations
    will become clear in a moment, but the takeaway here is that an `if..then..elseif`
    chain is semantically different from—and more powerful than—a `switch`/`case`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5.2 Jump Tables vs. Chained Comparisons**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although it is arguably more readable and convenient than an `if..then..elseif`
    chain, the `switch`/`case` statement was originally added to HLLs for efficiency,
    not readability or convenience. Consider an `if..then..elseif` chain with 10 separate
    expressions to test. If all the cases are mutually exclusive and equally likely,
    then on average the program will execute five comparisons before encountering
    an expression that evaluates to `true`. In assembly language, it’s possible to
    transfer control to one of several different locations in a fixed amount of time,
    independent of the number of cases, by using a table lookup and an indirect jump.
    Effectively, such code uses the value of the `switch`/`case` expression as an
    index into a table of addresses and then jumps (indirectly) to the statement specified
    by the table entry. When you have more than three or four cases, this scheme is
    typically faster and consumes less memory than the corresponding `if..then..elseif`
    chain. Consider the following simple implementation of a `switch`/`case` statement
    in assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To see how this code operates, we’ll step through it one instruction at a time.
    The `jmpTable` declaration defines an array of four double-word pointers, one
    pointer for each case in our `switch` statement emulation. Entry 0 in the array
    holds the address of the statement to jump to when the `switch` expression evaluates
    to `0`, entry 1 contains the address of the statement to execute when the `switch`
    expression evaluates to `1`, and so on. Note that the array must have one element
    whose index matches each of the possible cases in the `switch` statement (`0`
    through `3` in this particular example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first machine instruction in this example loads the value of the `switch`
    expression (variable `i`’s value) into the EAX register. Because this code uses
    the `switch` expression’s value as an index into the `jmpTable` array, this value
    must be an ordinal (integer) value in an 80x86 32-bit register. The next instruction
    (`jmp`) does the real work of the `switch` statement emulation: it jumps to the
    address specified by the entry in the `jmpTable` array, indexed by EAX. If EAX
    contains `0` upon execution of this `jmp` statement, the program fetches the double
    word from `jmpTable[0]` and transfers control to that address; this is the address
    of the first instruction following the `label0` label in the program code. If
    EAX contains `1`, then the `jmp` instruction fetches the double word at address
    `jmpTable + 4` in memory (note that the `*4` scaled-index addressing mode is used
    in this code; see “Indexed Addressing Mode” on [page 34](ch03.xhtml#page_34) for
    more details). Likewise, if EAX contains `2` or `3`, then the `jmp` instruction
    transfers control to the double-word address held at `jmpTable + 8` or `jmpTable
    + 12` (respectively). Because the `jmpTable` array is initialized with the addresses
    of `label0`, `label1`, `label2`, and `label3`, at respective offsets 0, 4, 8,
    and 12, this particular indirect `jmp` instruction will transfer control to the
    statement at the label corresponding to `i`’s value (`label0`, `label1`, `label2`,
    or `label3`, respectively).'
  prefs: []
  type: TYPE_NORMAL
- en: The first point of interest about this `switch` statement emulation is that
    it requires only two machine instructions (and a jump table) to transfer control
    to any of the four possible cases. Contrast this with an `if..then..elseif` implementation,
    which requires at least two machine instructions for each case. Indeed, as you
    add more cases to the `if..then..elseif` implementation, the number of compare
    and conditional branch instructions increases, yet the number of machine instructions
    for the jump table implementation remains fixed at two (even though the size of
    the jump table increases by one entry for each case). Accordingly, the `if..then..elseif`
    implementation gets progressively slower as you add more cases, while the jump
    table implementation takes a constant amount of time to execute (regardless of
    the number of cases). Assuming your HLL compiler uses a jump table implementation
    for `switch` statements, a `switch` statement will typically be much faster than
    an `if..then..elseif` sequence if there are a large number of cases.
  prefs: []
  type: TYPE_NORMAL
- en: The jump table implementation of `switch` statements does have a couple of drawbacks,
    though. First, because the jump table is an array in memory, and accessing (noncached)
    memory can be slow, accessing the jump table array could possibly impair system
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another downside is that you must have one entry in the table for every possible
    case between the largest and the smallest case values, including those values
    for which you haven’t actually supplied an explicit case. In the example up to
    this point, this hasn’t been an issue because the case values started with `0`
    and were contiguous through `3`. However, consider the following Pascal `case`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can’t implement this `case` statement with a jump table containing four entries.
    If the value of `i` were `0` or `1`, then it would fetch the correct address.
    However, for case 5, the index into the jump table would be `20` (5 × 4), not
    the third (2 x 4 = 8) entry in the jump table. If the jump table contained only
    four entries (16 bytes), indexing into the jump table using the value `20` would
    grab an address beyond the end of the table and likely crash the application.
    This is exactly why in the original definition of Pascal, the results were undefined
    if the program supplied a case value that wasn’t present in the set of labels
    for a particular `case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem in assembly language, you must make sure there are entries
    for each of the possible case labels as well as all values in between them. In
    the current example, the jump table would need nine entries to handle all the
    possible case values, `0` through `8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that if `i` is equal to `2`, `3`, `4`, `6`, or `7`, then this code transfers
    control to the first statement beyond the `switch` statement (the standard semantics
    for C’s `switch` statement and the `case` statement in most modern variants of
    Pascal). Of course, C will also transfer control to this point in the code if
    the `switch`/`case` expression value is greater than the largest case value. Most
    compilers implement this feature with a comparison and conditional branch immediately
    before the indirect jump. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed another assumption that this code is making—that the case
    values start at `0`. Modifying the code to handle an arbitrary range of case values
    is simple. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There are two differences between this example and the previous one. First,
    this example compares the value in EAX against the range `10..16` and, if the
    value falls outside this range, branches to the `switchDone` label (in other words,
    there is no case label for the value in EAX). Second, the `jmpTable` index has
    been modified to be `[eax*4 – 10*4]`. Arrays at the machine level always begin
    at index `0`; the “`- 10*4`” component of this expression adjusts for the fact
    that EAX actually contains a value starting at `10` rather than `0`. Effectively,
    this expression makes `jmpTable` start 40 bytes earlier in memory than its declaration
    states. Because EAX is always 10 or greater (40 bytes or greater because of the
    `eax*4` component), this code begins accessing the table at its declared beginning
    location. Note that HLA subtracts this offset from the address of `jmpTable`;
    the CPU doesn’t actually perform this subtraction at runtime. Hence, there is
    no additional efficiency loss to create this zero-based index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that a fully generalized `switch`/`case` statement actually requires
    six instructions to implement: the original two instructions plus four instructions
    to test the range.^([3](footnotes.xhtml#ch13fn3)) This, plus the fact that an
    indirect jump is slightly more expensive to execute than a conditional branch,
    is why the break-even point for a `switch`/`case` statement (versus an `if..then..elseif`
    chain) is around three to four cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, one serious drawback to the jump table implementation
    of the `switch`/`case` statement is the fact that you must have one table entry
    for every possible value between the smallest case and the largest case. Consider
    the following C/C++ `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If the C/C++ compiler implements this `switch` statement using a jump table,
    that table will require 10,001 entries (that is, 40,004 bytes of memory on a 32-bit
    processor). That’s quite a chunk of memory for such a simple statement! Although
    the wide separation of the cases has a major effect on memory usage, it has only
    a minor effect on the execution speed of the `switch` statement. The program executes
    the same four instructions it would execute if the values were all contiguous
    (only four instructions are necessary because the case values start at `0`, so
    there’s no need to check the `switch` expression against a lower bound). Indeed,
    the only reason there’s a performance difference at all is because of the effects
    of the table size on the cache (it’s less likely you will find a particular table
    entry in the cache when the table is large). Speed issues aside, the memory usage
    by the jump table is difficult to justify for most applications. Therefore, if
    your particular compiler emits a jump table for all `switch`/`case` statements
    (which you can determine by looking at the code it produces), you should be careful
    about creating `switch`/`case` statements whose cases are widely separated.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5.3 Other Implementations of switch/case**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because of the issue with jump table sizes, some HLL compilers do not implement
    `switch`/`case` statements using jump tables. Some compilers will simply convert
    a `switch`/`case` statement into the corresponding `if..then..elseif` chain (Swift
    falls into this category). Obviously, such compilers tend to produce low-quality
    code (from a speed point of view) whenever a jump table would be appropriate.
    Many modern compilers are relatively smart about their code generation. They’ll
    determine the number of cases in a `switch`/`case` statement as well as the spread
    of the case values. Then the compiler will choose a jump table or `if..then..elseif`
    implementation based on some threshold criteria (code size versus speed). Some
    compilers might even use a combination of the techniques. For example, consider
    the following Pascal `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A good compiler will recognize that the majority of the cases work well in
    a jump table, with the exception of only one (or a few) cases. It will translate
    this code to a sequence of instructions that combine the `if..then` and jump table
    implementation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the `switch`/`case` statement was originally created to allow the
    use of an efficient jump table transfer mechanism in an HLL, there are few language
    definitions that require a specific implementation for a control structure. Therefore,
    unless you stick with a specific compiler and you know how that compiler generates
    code under all circumstances, there’s absolutely no guarantee that your `switch`/`case`
    statements will compile to a jump table, an `if..then..elseif` chain, some combination
    of the two, or something else entirely. For example, consider the following short
    C program and the resulting assembly output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the 80x86 output from the (older) Borland C++ v5.0 compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see at the beginning of the main program, this code compares the
    value in `argc` against the four values (`1`, `2`, `10`, and `11`) sequentially.
    For a `switch` statement as small as this one, this isn’t a bad implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When there are a fair number of cases and a jump table would be too large,
    many modern optimizing compilers generate a binary search tree to test the cases.
    For example, consider the following C program and the corresponding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the 64-bit MASM output from the Visual C++ compiler. Note how Microsoft’s
    compiler generates a partial binary search through each of the 10 cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly enough, when compiling to 32-bit code, Visual C++ produces a
    true binary search. Here’s the MASM32 output from the 32-bit version of Visual
    C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Some compilers, especially those for some microcontroller devices, generate
    a table of *2-tuples* (paired records/structures), with one element of the tuple
    being the value of the case and the second element being the address to jump to
    if the value matches. Then the compiler emits a loop that scans through this little
    table searching for the current `switch`/`case` expression value. If this is a
    linear search, this implementation is even slower than the `if..then..elseif`
    chain. If the compiler emits a binary search, the code may be faster than an `if..then.elseif`
    chain but probably not as fast as a jump table implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a Java example of a `switch` statement, along with the Java bytecode
    the compiler produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `lookupswitch` bytecode instruction contains a table of 2-tuples. As described
    earlier, the first value of the tuple is the case value, and the second is the
    target address where the code transfers on a match. Presumably, the bytecode interpreter
    does a binary search on these values rather than a linear search (one would hope!).
    Notice that the Java compiler generates a separate call to method `f()` for each
    of the cases; it doesn’t optimize them to a single call as GCC and Visual C++
    do.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Java also has a tableswitch VM instruction that executes a table-driven switch
    operation. The Java compiler chooses between the tableswitch and lookupswitch
    instructions based on the density of the case values.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, compilers resort to some code tricks to generate marginally better
    code under certain circumstances. Consider again the short `switch` statement
    that led the Borland compiler to produce a linear search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code that the Microsoft Visual C++ 32-bit compiler generates for
    this `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The trick in this 80x86 code is that Visual C++ first does a table lookup to
    make an `argc` value in the range `1..11` to a value in the range `0..3` (which
    corresponds to the three different code bodies appearing in the cases, plus a
    default case). This code is shorter than a jump table, with the corresponding
    double-word entries mapping to the default case, although it’s a little slower
    than a jump table because it needs to access two different tables in memory. (As
    for how the speed of this code compares with a binary search or linear search,
    that research is left to you; the answer will probably vary by processor.) Note,
    however, that when producing 64-bit code, Visual C++ reverts to the linear search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Few compilers give you the option of explicitly specifying how the compiler
    will translate a specific `switch`/`case` statement. For example, if you really
    want the `switch` statement with cases 0, 1, 10, 100, 1,000, and 10,000 given
    earlier to generate a jump table, you’ll have to write the code in assembly language
    or use a specific compiler whose code generation traits you understand. Any HLL
    code you’ve written that depends on the compiler generating a jump table won’t
    be portable to other compilers, however, because few languages specify the actual
    machine code implementation of high-level control structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you don’t have to totally rely on the compiler to generate decent
    code for a `switch`/`case` statement. Assuming your compiler uses the jump table
    implementation for all `switch`/`case` statements, you can help it produce better
    code when modifications to your HLL source code would generate a huge jump table.
    For example, consider the `switch` statement given earlier with the cases 0, 1,
    2, 3, 4, and 1,000\. If your compiler generates a jump table with 1,001 entries
    (consuming a little more than 4KB of memory), you can improve its output by writing
    the following Pascal code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: By handling case value `1000` outside the `switch` statement, the compiler can
    produce a short jump table for the main cases, which are contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility (which is arguably easier to read) is the following C/C++
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: What makes this example slightly easier to read is that the code for the case
    when `i` is equal to `1000` has been moved into the `switch` statement (thanks
    to the default clause), so it doesn’t appear to be separate from all the tests
    taking place in the `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers simply won’t generate a jump table for a `switch`/`case` statement.
    If you’re using such a compiler and you want to generate a jump table, there’s
    little you can do—short of dropping into assembly language or using nonstandard
    C extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although jump table implementations of `switch`/`case` statements are generally
    efficient when you have a fair number of cases and they’re all equally likely,
    remember that an `if..then..elseif` chain can be faster if one or two cases are
    far more likely than the others. For example, if a variable has the value `15`
    more than half the time, the value `20` about a quarter of the time, and one of
    several different values the remaining 25 percent of the time, it’s probably more
    efficient to implement the multiway test using an `if..then..elseif` chain (or
    a combination of `if..then..elseif` and a `switch`/`case` statement). By testing
    the most common case(s) first, you can often reduce the average time the multiway
    statement needs to execute. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If `i` is equal to `15` more often than not, then most of the time this code
    sequence will execute the body of the first `if` statement after executing only
    two instructions. Even in the best `switch` statement implementation, you’re going
    to need more instructions than this.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5.4 The Swift switch Statement**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Swift’s `switch` statement is semantically different from most other languages.
    There are four major differences between Swift’s `switch` and the typical C/C++
    `switch` or Pascal `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Swift’s `switch` provides a special `where` clause that lets you apply a conditional
    to a `switch`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift’s `switch` allows you to use the same value in more than one `case` statement
    (differentiated by the `where` clause).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift’s `switch` allows the use of nonintegral/ordinal data types, such as tuples,
    strings, and sets, as the selection value (with appropriately typed case values).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift’s `switch` statement supports pattern matching for case values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the Swift language reference manual for more details. The purpose
    of this section is not to provide the syntax and semantics of the Swift `switch`,
    but rather to discuss how Swift’s design affects its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Because it allows arbitrary types as the `switch` selector value, there’s no
    way that Swift could use a jump table to implement the `switch` statement. A jump
    table implementation requires an ordinal value (something you can represent as
    an integer) that the compiler can use as an index into the jump table. A string
    selector, for example, couldn’t be used as an index into an array. Furthermore,
    Swift allows you to specify the same case value twice,^([4](footnotes.xhtml#ch13fn4))
    creating a consistency problem with the same jump table entry mapping to two separate
    sections of code (which is impossible for a jump table).
  prefs: []
  type: TYPE_NORMAL
- en: Given the design of the Swift `switch` statement, then, the only solution is
    a linear search (effectively, the `switch` statement is equivalent to a chain
    of `if..else if..else if..etc`. statements). The bottom line is that there is
    no performance benefit to using the `switch` statement over a set of `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5.5 Compiler Output for switch Statements**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you run off to help your compiler produce better code for `switch` statements,
    you might want to examine the actual code it produces. This chapter has described
    several of the techniques that various compilers use for implementing `switch`/`case`
    statements at the machine code level, but there are several additional implementations
    that this book could not cover. Although you can’t assume that a compiler will
    always generate the same code for a `switch`/`case` statement, observing its output
    can help you see the different implementations that compiler authors use.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.6 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Aho, Alfred V., Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. *Compilers:
    Principles, Techniques, and Tools*. 2nd ed. Essex, UK: Pearson Education Limited,
    1986.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Barrett, William, and John Couch. *Compiler Construction: Theory and Practice*.
    Chicago: SRA, 1986.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dershem, Herbert, and Michael Jipping. *Programming Languages, Structures and
    Models*. Belmont, CA: Wadsworth, 1990.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraser, Christopher, and David Hansen. *A Retargetable C Compiler: Design and
    Implementation*. Boston: Addison-Wesley Professional, 1995.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ghezzi, Carlo, and Jehdi Jazayeri. *Programming Language Concepts*. 3rd ed.
    New York: Wiley, 2008.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hoxey, Steve, Faraydon Karim, Bill Hay, and Hank Warren, eds. *The PowerPC
    Compiler Writer’s Guide*. Palo Alto, CA: Warthman Associates for IBM, 1996.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  prefs: []
  type: TYPE_NORMAL
- en: Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated
    November 11, 2019\. *[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ledgard, Henry, and Michael Marcotty. *The Programming Language Landscape*.
    Chicago: SRA, 1986.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Louden, Kenneth C. *Compiler Construction: Principles and Practice*. Boston:
    Cengage, 1997.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Louden, Kenneth C., and Kenneth A. Lambert. *Programming Languages: Principles
    and Practice*. 3rd ed. Boston: Course Technology, 2012.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsons, Thomas W. *Introduction to Compiler Construction*. New York: W. H.
    Freeman, 1992.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pratt, Terrence W., and Marvin V. Zelkowitz. *Programming Languages, Design
    and Implementation*. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2001.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sebesta, Robert. *Concepts of Programming Languages*. 11th ed. Boston: Pearson,
    2016.'
  prefs: []
  type: TYPE_NORMAL
