<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch24" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch24">
<span class="cn"><span aria-label=" Page 277. " epub:type="pagebreak" id="pg_277" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">24</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">TEXT STRING SEARCHES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">In previous chapters, you’ve seen a number of searches, such as for files, directories, and even lost disk space. In this chapter, I’ll discuss the many ways of searching for text strings and possible applications for text searches. You’ll see searches for a single word, searches for one out of multiple possible words, and searches for a literal string containing multiple words. Another search flavor will look for a list of words and considers the search a success only if each and every word is found. I’ll show how to perform these searches against a file, multiple files, and other strings.</p>
<p class="tx">For performing these searches, I’ll compare and contrast two very different techniques. One is far more flexible, and the other executes much <span aria-label=" Page 278. " epub:type="pagebreak" id="pg_278" role="doc-pagebreak"/>faster, so they’re both extremely useful. I’ll also discuss regular expressions and how you can use them to build some very impressive Batch searches.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-162"/><span class="sans_futura_std_bold_b_">Searching within a File</span></h3>
<p class="tni">To demonstrate how to search each record in a file for a string, the first requirement is a file to search. In the real world, you might have a logfile containing tens of thousands of records with many clients interspersed; searching for a client name can extract all relevant entries for a more targeted report. Daily report files might each have totals at the end; a search on the <span class="sans_thesansmonocd_w5regular_">Totals</span> text can extract each of those trailer records from all of the report files in a certain directory. Better yet, you can search all files satisfying a file mask, maybe targeting files from the prior month or year.</p>
<p class="tx">For this demonstration, I’ll use a much smaller (and I hope more interesting) input file, a file called <i class="calibre6">12Movies.txt</i> containing a not-so-random list of a dozen movies spanning three decades, organized by release date. Look closely for any commonalities with the titles. Here are its complete contents:</p>
<pre class="pre"><code class="calibre11">Here Come the Littles
Little Shop of Horrors
Big Trouble in Little China
Big
The Little Mermaid
The Big Lebowski
Stuart Little
Big Momma's House
My Big Fat Greek Wedding
Little Miss Sunshine
Big Hero 6
The Big Short
</code></pre>
<p class="tx">Some are great movies, some not so great, and some I’ve never seen, but we’ll be using this file in many examples throughout this chapter.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="h1" id="sec2"><span id="h2-71"/><span class="sans_futura_std_heavy_oblique_bi_">A Simple String</span></h4>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">findstr</span> command is the primary Batch tool for finding a text string inside one or more files. Despite the abbreviation, coders refer to it as the <i class="calibre6">find string</i> command. You’ll soon see how versatile this command is, but I’ll start with a simple optionless command that searches for the word <span class="sans_thesansmonocd_w5regular_">Little</span> in the input file. The first argument is the search string, and the second argument is the file to be searched:</p>
<pre class="pre"><code class="calibre11">findstr Little C:\Batch\12Movies.txt</code></pre>
<p class="tx">This command writes every record from the file containing the six consecutive letters in the search string to stdout:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 279. " epub:type="pagebreak" id="pg_279" role="doc-pagebreak"/>Here Come the Littles
Little Shop of Horrors
Big Trouble in Little China
The Little Mermaid
Stuart Little
Little Miss Sunshine
</code></pre>
<p class="tni">Notice that the interpreter returns the first title even though it contains the search word appended with an <span class="sans_thesansmonocd_w5regular_">s</span>; the command isn’t searching for whole words. Also, this particular command sets the pseudo-environment variable <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">0</span>, indicating that it found at least one instance of the search string. If it finds no matches, <span class="sans_thesansmonocd_w5regular_">errorlevel</span> takes on the value of <span class="sans_thesansmonocd_w5regular_">1</span>.</p>
<p class="tx">Typically, coders handle the output from this command in one of three ways. If you simply want to know whether one or more records exist, you need only interrogate <span class="sans_thesansmonocd_w5regular_">errorlevel</span> and move on. In other instances, you can redirect the list of returned records written to stdout to the console or an output file for later use or viewing. The last use is to programmatically process every returned record, which you can do by using a <span class="sans_thesansmonocd_w5regular_">findstr</span> command as input to a <span class="sans_thesansmonocd_w5regular_">for /F</span> command. For most of the upcoming examples, I’ll describe what’s written to stdout, but understand that the output has many different uses.</p>
<p class="tx">Now let’s make a subtle change to the prior command and make the search string entirely lowercase:</p>
<pre class="pre"><code class="calibre11">findstr little C:\Batch\12Movies.txt</code></pre>
<p class="tni">This returns nothing because the <span class="sans_thesansmonocd_w5regular_">findstr</span> command performs case-sensitive searches, by default anyway, and every instance of the word in the file starts with an uppercase <span class="sans_thesansmonocd_w5regular_">L</span>. The other interesting result is that because the command returned nothing, <span class="sans_thesansmonocd_w5regular_">1</span> is the value of <span class="sans_thesansmonocd_w5regular_">errorlevel</span>. Often, a case-sensitive search is exactly what you want; many other times, that’s exactly what you don’t want.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1" id="sec3"><span id="h2-72"/><span class="sans_futura_std_heavy_oblique_bi_">Customizations</span></h4>
<p class="tni">Fortunately, this command has a large number of options to customize each search. I’ll discuss many of them in this chapter, starting with a few options that change the behavior of the <span class="sans_thesansmonocd_w5regular_">findstr</span> command in simple yet powerful ways.</p>
<p class="tx">Just as the <span class="sans_thesansmonocd_w5regular_">/i</span> option invokes case-insensitivity of the <span class="sans_thesansmonocd_w5regular_">if</span> command, the same option works for the <span class="sans_thesansmonocd_w5regular_">findstr</span> command. (As mentioned in <span class="xref"><a href="chapter4.xhtml" class="calibre3">Chapter 4</a></span>, I use lowercase for this one option, but <span class="sans_thesansmonocd_w5regular_">/I</span> also works.) Notice the option and the odd capitalization of <span class="sans_thesansmonocd_w5regular_">tHE</span>:</p>
<pre class="pre"><code class="calibre11">findstr /i tHE C:\Batch\12Movies.txt</code></pre>
<p class="tni">I’m not recommending a capitalization scheme such as this, but I do it here to unambiguously demonstrate the fact that the interpreter returns all four <span aria-label=" Page 280. " epub:type="pagebreak" id="pg_280" role="doc-pagebreak"/>titles containing these three letters in this order, regardless of the case, as you can see in the output:</p>
<pre class="pre"><code class="calibre11">Here Come the Littles
The Little Mermaid
The Big Lebowski
The Big Short
</code></pre>
<p class="tx">Another useful option is <span class="sans_thesansmonocd_w5regular_">/E</span>. With it, the command returns only the records it finds where the search string is at the <i class="calibre6">end</i> of the record. Consider this command:</p>
<pre class="pre"><code class="calibre11">findstr /i /E little C:\Batch\12Movies.txt</code></pre>
<p class="tni">The only title returned is <i class="calibre6">Stuart Little</i>. Also notice this command uses multiple options for further customization; with the <span class="sans_thesansmonocd_w5regular_">/i</span> and <span class="sans_thesansmonocd_w5regular_">/E</span> options, it performs a case-insensitive search for records ending with the search string.</p>
<p class="tx">Similarly, the <span class="sans_thesansmonocd_w5regular_">/B</span> option returns only the records it finds where the search string is at the <i class="calibre6">beginning</i> of the record. You can team up this option with <span class="sans_thesansmonocd_w5regular_">/i</span> as well as the <span class="sans_thesansmonocd_w5regular_">/N</span> option, which prepends the <i class="calibre6">line number</i> to the returned record, delimited by a colon:</p>
<pre class="pre"><code class="calibre11">findstr /i /B /N big C:\Batch\12Movies.txt</code></pre>
<p class="tni">This <span class="sans_thesansmonocd_w5regular_">findstr</span> command returns the following four titles, all starting with <span class="sans_thesansmonocd_w5regular_">big</span>, case-insensitive, prepended with their corresponding line numbers:</p>
<pre class="pre"><code class="calibre11">3:Big Trouble in Little China
4:Big
8:Big Momma's House
11:Big Hero 6
</code></pre>
<p class="tx">Another useful option is <span class="sans_thesansmonocd_w5regular_">/V</span>, which negates the search logic. The following command is identical to the previous one, except it includes the <span class="sans_thesansmonocd_w5regular_">/V</span> option:</p>
<pre class="pre"><code class="calibre11">findstr /i /B /N /V big C:\Batch\12Movies.txt</code></pre>
<p class="tni">The four records that were returned previously are now missing from the output, replaced with the other eight records not satisfying the search criteria. The line numbers are still at the front of each record because of the <span class="sans_thesansmonocd_w5regular_">/N</span> option, but the <span class="sans_thesansmonocd_w5regular_">/V</span> option alters the logic so that the output consists of all records <i class="calibre6">not</i> starting with <span class="sans_thesansmonocd_w5regular_">big</span>, case-insensitive:</p>
<pre class="pre"><code class="calibre11">1:Here Come the Littles
2:Little Shop of Horrors
5:The Little Mermaid
6:The Big Lebowski
7:Stuart Little
<span aria-label=" Page 281. " epub:type="pagebreak" id="pg_281" role="doc-pagebreak"/>9:My Big Fat Greek Wedding
10:Little Miss Sunshine
12:The Big Short
</code></pre>
<p class="tx">Rounding out these options is <span class="sans_thesansmonocd_w5regular_">/X</span>, which finds only records that match the search string in their entirety:</p>
<pre class="pre"><code class="calibre11">findstr /i /X big C:\Batch\12Movies.txt</code></pre>
<p class="tni">This command returns a single title, the Tom Hanks film <i class="calibre6">Big</i>.</p>
<p class="tx">The one-character codes in the <span class="sans_thesansmonocd_w5regular_">/i</span>, <span class="sans_thesansmonocd_w5regular_">/B</span>, <span class="sans_thesansmonocd_w5regular_">/E</span>, and <span class="sans_thesansmonocd_w5regular_">/N</span> options are representative of their function, but <span class="sans_thesansmonocd_w5regular_">/V</span>, <span class="sans_thesansmonocd_w5regular_">/X</span>, and some others aren’t as obvious. Plan to make ample use of the help when working with the <span class="sans_thesansmonocd_w5regular_">findstr</span> command.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1" id="sec4"><span id="h2-73"/><span class="sans_futura_std_heavy_oblique_bi_">Multiple Words</span></h4>
<p class="tni">There are multiple variants of a two-word search (when the search string has an embedded space). We can search for all records that have either word, both words, or a literal string of the two words separated by that space (or spaces). The <span class="sans_thesansmonocd_w5regular_">findstr</span> command handles all of them, although the variant searching for both words requires a little extra work. We can extrapolate these solutions to searches of more than two words.</p>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="h2" id="sec5"><span class="sans_futura_std_bold_b_">Any Words in a List</span></h5>
<p class="tni">Instead of a one-word search string, the following <span class="sans_thesansmonocd_w5regular_">findstr</span> command has two words encased in double quotes. If you haven’t seen something like this before, you’re probably expecting it to return all titles with the word <span class="sans_thesansmonocd_w5regular_">the</span> followed by the word <span class="sans_thesansmonocd_w5regular_">big</span>, but that’s not the case:</p>
<pre class="pre"><code class="calibre11">findstr /i "the big" C:\Batch\12Movies.txt</code></pre>
<p class="tx">In actuality, the double quotes encase the set of space-delimited search strings. The interpreter searches each record in the file for each word in the set of search strings, returning all records with at least one match. This command returns nine titles; all but three movies in the list contain either the word <span class="sans_thesansmonocd_w5regular_">the</span> or the word <span class="sans_thesansmonocd_w5regular_">big</span>, or both.</p>
<p class="tx">Adding three specific words to the set of search strings returns all 12 titles:</p>
<pre class="pre"><code class="calibre11">findstr /i "the big art hop sun" C:\Batch\12Movies.txt</code></pre>
<p class="tx">The three additional words in the set of search strings are part of the words <i class="calibre6">Stuart</i>, <i class="calibre6">Shop</i>, and <i class="calibre6">Sunshine</i>, respectively, and each of those words is in one of the previously missing titles. Although, if you haven’t noticed yet, the two-word set of search strings, <span class="sans_thesansmonocd_w5regular_">"big little"</span>, returns every record in the file more efficiently.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="h2" id="sec6"><span aria-label=" Page 282. " epub:type="pagebreak" id="pg_282" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">A Literal String</span></h5>
<p class="tni">With a simple modification, you can alter the command searching for either of two words to search for a single string: <span class="sans_thesansmonocd_w5regular_">the</span>, followed by a space and <span class="sans_thesansmonocd_w5regular_">big</span>. The <span class="sans_thesansmonocd_w5regular_">/C</span> option defines a literal search string, and you must use it when the search string includes at least one space.</p>
<p class="tx">You’ve already seen a case-insensitive search of <i class="calibre6">12Movies.txt</i>. In this example, I’ve inserted the <span class="sans_thesansmonocd_w5regular_">/C:</span> option in front of what’s now a literal search string encased in double quotes:</p>
<pre class="pre"><code class="calibre11">findstr /i /C:"the big" C:\Batch\12Movies.txt</code></pre>
<p class="tx">This <span class="sans_thesansmonocd_w5regular_">findstr</span> command returns just these two titles:</p>
<pre class="pre"><code class="calibre11">The Big Lebowski
The Big Short
</code></pre>
<p class="tni">Both of these titles happen to start with the text, but a record with this literal string later in the title would’ve also been part of the output.</p>
<p class="tx">The literal search string doesn’t have to contain entire words. The following command</p>
<pre class="pre"><code class="calibre11">findstr /i /C:"y big fat greek wed" C:\Batch\12Movies.txt</code></pre>
<p class="tni">returns the title <i class="calibre6">My Big Fat Greek Wedding</i>.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="h2" id="sec7"><span class="sans_futura_std_bold_b_">All Words in a List</span></h5>
<p class="tni">There’s just one movie title in the <i class="calibre6">12Movies.txt</i> file that contains two particular words of interest, <span class="sans_thesansmonocd_w5regular_">Big</span> and <span class="sans_thesansmonocd_w5regular_">Little</span>. Unfortunately, the <span class="sans_thesansmonocd_w5regular_">findstr</span> command cannot perform a single search to find all records containing both words, but with some ingenuity, you can meld two <span class="sans_thesansmonocd_w5regular_">findstr</span> commands together to get the job done:</p>
<pre class="pre"><code class="calibre11">findstr /i big C:\Batch\12Movies.txt | findstr /i little</code></pre>
<p class="tx">This pipes the output of one <span class="sans_thesansmonocd_w5regular_">findstr</span> command—via the pipe character—to another <span class="sans_thesansmonocd_w5regular_">findstr</span> command (another application of the piping technique introduced in <span class="xref"><a href="chapter12.xhtml" class="calibre3">Chapter 12</a></span>). The first <span class="sans_thesansmonocd_w5regular_">findstr</span> command performs a case-insensitive search for the word <span class="sans_thesansmonocd_w5regular_">big</span> using the <i class="calibre6">12Movies.txt</i> file as its input. As you have seen by now, this command by itself writes seven titles to stdout.</p>
<p class="tx">But this isn’t a simple command. The interpreter writes the output, those seven records, to an unnamed temporary file and pipes, or feeds, it into the second <span class="sans_thesansmonocd_w5regular_">findstr</span> command, which is doing a case-insensitive search for the word <span class="sans_thesansmonocd_w5regular_">little</span>. Notice that I’m not defining an input file in the second command. It doesn’t need one, because its input is the output from the first <span class="sans_thesansmonocd_w5regular_">findstr</span> command. As the following output shows, of the seven titles that contain the word <span class="sans_thesansmonocd_w5regular_">big</span>, only one also contains the word <span class="sans_thesansmonocd_w5regular_">little</span>:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 283. " epub:type="pagebreak" id="pg_283" role="doc-pagebreak"/>Big Trouble in Little China</code></pre>
<p class="tni">The upshot is a search that returns only records containing both strings.</p>
<p class="tx">The intermediate file is lost, but if you desire an audit trail of what transpired, you can redirect the output into a file. Then you can pipe a <span class="sans_thesansmonocd_w5regular_">type</span> command of that file into the second <span class="sans_thesansmonocd_w5regular_">findstr</span> command:</p>
<pre class="pre"><code class="calibre11">findstr /i big C:\Batch\12Movies.txt &gt; C:\Batch\BigMovies.txt
type C:\Batch\BigMovies.txt | findstr /i little
</code></pre>
<p class="tx">The two commands find the same title, but now <i class="calibre6">BigMovies.txt</i> contains the seven records found with the first search string.</p>
<p class="tx">You can use this technique with any number of search strings. The following command again finds the one title, because it contains all four of the search strings, even if the third word is only a portion of a word in the title:</p>
<pre class="pre"><code class="calibre11">findstr /i big C:\Batch\12Movies.txt | findstr /i little ^
                                     | findstr /i chi ^
                                     | findstr /i trouble
</code></pre>
<p class="tni">The trickiest part of this technique is making it readable. In this example, I’ve lined up all of the search strings, other than the first, by continuing the command on multiple lines with the trailing carets.</p>
</section>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="h" id="sec8"><span id="h1-163"/><span class="sans_futura_std_bold_b_">Searching Multiple Files</span></h3>
<p class="tni">Up to this point, I’ve performed the <span class="sans_thesansmonocd_w5regular_">findstr</span> command using a single input file, but you can search any number of files with a single invocation. The command accepts multiple files to search as additional arguments, and it also accepts file masks. The following command is looking for the <span class="sans_thesansmonocd_w5regular_">miss</span> text, regardless of the case, in the file we’ve been using and in any file that satisfies either of the two file masks:</p>
<pre class="pre"><code class="calibre11">findstr /i miss C:\Batch\12Movies.txt C:\Flicks\*Movies.txt C:\Movies\*</code></pre>
<p class="tx">This example raises an issue of concern about the output because prior invocations have simply written each record found to stdout. That worked great when searching a single file, but when searching multiple files, this output would leave you no way of knowing the file of origin for each output record. The interpreter smartly detects the difference and outputs the path and filename with the record found:</p>
<pre class="pre"><code class="calibre11">C:\Batch\12Movies.txt:Little Miss Sunshine
C:\Movies\Some Other File.dat:  Will findstr miss this record?
C:\Movies\Some Other File.dat:  Sorry, that was misserable. Sorry again.
</code></pre>
<p class="tx"><span aria-label=" Page 284. " epub:type="pagebreak" id="pg_284" role="doc-pagebreak"/>The command found <i class="calibre6">Little Miss Sunshine</i> in the <i class="calibre6">12Movies.txt</i> file as expected, and it also found the text in two records belonging to a file satisfying the trailing file mask, resulting in the last two lines of the output. The formatting leaves much to be desired. It’s hard to see where the filename ends and the record starts despite the colon delimiter. When writing the output to the console, the <span class="sans_thesansmonocd_w5regular_">/A</span> option highlights the path and filename to a color scheme of your choosing, but that obviously does nothing when you redirect the output to a file or pipe it to another command.</p>
<p class="tx">The colon itself is an unfortunate choice for the delimiter because it’s often part of the path after the drive letter, as it is in this instance. If you want to parse this data, you could use a <span class="sans_thesansmonocd_w5regular_">findstr</span> command as input to a <span class="sans_thesansmonocd_w5regular_">for /F</span> command and delimit the output on the colon. But given this output, the path and filename would span the first two tokens with the actual record in the third. A delimiter that can’t be in a path or filename, such as a pipe, would’ve been a better idea, but you can still parse this with a little extra work.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/S</span> option expands the search to include subdirectories. I often use it with wildcards to search all files in a directory tree or all files of a certain extension in a directory tree, but in the following example, I’m using an explicit filename:</p>
<pre class="pre"><code class="calibre11">findstr /i /S /N miss C:\Batch\12Movies.txt</code></pre>
<p class="tni">The interpreter searches <i class="calibre6">C:\Batch\</i> and all of its subfolders for files named <i class="calibre6">12Movies.txt</i>. Then it searches each file found for records containing the search string.</p>
<p class="tx">Also, notice that I reintroduced the <span class="sans_thesansmonocd_w5regular_">/N</span> option mentioned previously. The output now contains the path and filename, the line number (delimited on either side with a colon), and the full record containing the search string:</p>
<pre class="pre"><code class="calibre11">C:\Batch\12Movies.txt:10:Little Miss Sunshine
C:\Batch\Subfolder\12Movies.txt:2:The misspelling of miserable was painful.
C:\Batch\Subfolder\12Movies.txt:3:It should be a missdemeanor.
</code></pre>
<p class="tni">Two files in two directories have the same name, but the result of this command shows that their contents are quite different.</p>
<p class="warning"><span class="sans_dogma_ot_bold_b_1">WARNING</span></p>
<p class="warning-txt"><i class="calibre6">When the findstr command doesn’t find any files that fit a file mask, it writes an error message to stderr saying it Cannot open the specific mask. If you have redirected both stdout and stderr to a trace file, the command intermingles the message with the desired output. If a mask might not be valid, suppressing stderr with the 2&gt; nul syntax anticipates the possibility of the batveat and cleans up the output:</i></p>
<pre class="pre"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">findstr /i miss C:\Batch\12Movies.txt C:\NotADir\* 2&gt; nul</span>
</code></pre>
<blockquote class="calibre8">
<p class="notecontinued"><i class="calibre6">The interpreter returns any records it finds in the valid file, but it sends the error message concerning the nonexistent directory to the nul file. This technique even works inside a routine or bat file with its stderr already redirected.</i></p>
</blockquote>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="h" id="sec9"><span id="h1-164"/><span aria-label=" Page 285. " epub:type="pagebreak" id="pg_285" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Auxiliary Search Files</span></h3>
<p class="tni">When your searches start to get more complex, you can more easily manage them with two auxiliary files, one that contains a list of search strings and another that contains a list of files to search.</p>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1" id="sec10"><span id="h2-74"/><span class="sans_futura_std_heavy_oblique_bi_">File of Search Strings</span></h4>
<p class="tni">I mentioned earlier how you can search for any of the strings in a list by encasing multiple space-delimited search strings in double quotes. That works great for a handful of strings, but when the list gets long enough to make a mess of the command, you can use the <span class="sans_thesansmonocd_w5regular_">findstr</span> command with a file containing the list of search strings. You define this file by entering it after the <span class="sans_thesansmonocd_w5regular_">/G</span> option, delimited by a colon. The following example performs case-sensitive searches for <span class="sans_thesansmonocd_w5regular_">Little</span> and four of its synonyms, and you can easily add many more:</p>
<pre class="pre"><code class="calibre11">&gt;  SearchStr.temp echo Little
&gt;&gt; SearchStr.temp echo Small
&gt;&gt; SearchStr.temp echo Short
&gt;&gt; SearchStr.temp echo Minuscule
&gt;&gt; SearchStr.temp echo Tiny
findstr /G:SearchStr.temp C:\Batch\12Movies.txt
del SearchStr.temp
</code></pre>
<p class="tx">I’m building the temporary file with hardcoded strings, but they could easily be variables or even come from user input, and because it’s a temporary file, I’m deleting it when I’m done with it. The output consists of all records containing at least one of these five strings, which in this case includes the six titles containing <span class="sans_thesansmonocd_w5regular_">Little</span>, plus <i class="calibre6">The Big Short</i>, with nothing found for the other three search strings.</p>
<p class="tx">This technique is also helpful when the search criteria changes from execution to execution. You can generate a file dynamically in the code, or even update it manually, and you can run the same code with differing results.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1" id="sec11"><span id="h2-75"/><span class="sans_futura_std_heavy_oblique_bi_">File of Files to Search</span></h4>
<p class="tni">Taking this a step further, I’ll use the file just created containing the list of the search strings in tandem with another file containing the list of files to be searched. This <i class="calibre6">file of files (FOF)</i> is defined by the <span class="sans_thesansmonocd_w5regular_">findstr</span> command with the <span class="sans_thesansmonocd_w5regular_">/F</span> option. Similar to the <span class="sans_thesansmonocd_w5regular_">/G</span> option, the file comes after the option, delimited by a colon:</p>
<pre class="pre"><code class="calibre11">findstr /i /G:C:\Batch\SearchStrings.txt /F:C:\Batch\SearchFiles.txt</code></pre>
<p class="tx">Oddly, you can use the <span class="sans_thesansmonocd_w5regular_">/F</span> option only when using the <span class="sans_thesansmonocd_w5regular_">/G</span> option.</p>
<p class="tx">If the list of files to search will be known only at the time of execution, you can build this FOF dynamically at runtime. This technique is also useful when you can’t easily define a set of files with a file mask. For instance, <span aria-label=" Page 286. " epub:type="pagebreak" id="pg_286" role="doc-pagebreak"/>these options are ideal if you plan to search one of multiple sets of files, perhaps production or test sets of files partially named with a datestamp. You can also create the file of search strings with data entered by the user, perhaps a list of client names. If, however, the list of files to search is more consistent, you can use a static file instead.</p>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="h" id="sec12"><span id="h1-165"/><span class="sans_futura_std_bold_b_">Searching a String</span></h3>
<p class="tni">Most compiled languages include a method that returns a boolean indicating whether a string is contained in part or in whole inside another string, because the need arises often in very disparate situations. In Batch, you can search a variable holding a path for a specific node or server name, or you might examine the <span class="sans_thesansmonocd_w5regular_">path</span> variable to see whether it holds a particular directory. You can even use this technique to validate user input, verifying that the response contains at least one word on a list.</p>
<p class="tx">There are two very different methods of finding out if a string contains another string. The makers of Batch designed the <span class="sans_thesansmonocd_w5regular_">findstr</span> command to search files, but the first method manipulates it to search a string. The second method is based on the text replacement syntax from <span class="xref"><a href="chapter5.xhtml" class="calibre3">Chapter 5</a></span>, and they each have significant advantages over the other.</p>
<p class="listhead"><b class="calibre10">The <span class="sans_thesansmonocd_w5regular_"><b class="calibre10">findstr</b></span> Method</b></p>
<p class="listplainfirst">Finding love can be difficult, but with the <span class="sans_thesansmonocd_w5regular_">findstr</span> command, finding the <span class="sans_thesansmonocd_w5regular_">love</span> string requires only a few lines of code. For this exercise, I’ll set the <span class="sans_thesansmonocd_w5regular_">aString</span> variable to one of two similar text strings giving advice to anyone planning a winter trip to one of two neighboring countries on the Adriatic Sea:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">set aString=Bring mittens and a sweater to Croatia.</span>
set aString=Bring gloves and a pullover to Slovenia.
</code></pre>
<p class="listcontinued1">I’ll step through a couple of upcoming code listings twice, with the variable set to each of these strings to demonstrate very different behaviors.</p>
<p class="listbody">Can you find <span class="sans_thesansmonocd_w5regular_">love</span> in either string? The <span class="sans_thesansmonocd_w5regular_">findstr</span> command can:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">echo "%aString%" | findstr love</span>
if %errorlevel% equ 0 (
   set bLove=true==true
) else (
   set bLove=false==x
)
</code></pre>
<p class="listbody">To search <span class="sans_thesansmonocd_w5regular_">aString</span> for the <span class="sans_thesansmonocd_w5regular_">love</span> text, I employ the same piping technique used earlier, with the only difference being that instead of piping a multirecord file to the <span class="sans_thesansmonocd_w5regular_">findstr</span> command via a <span class="sans_thesansmonocd_w5regular_">type</span> command, I’m piping a variable via an <span class="sans_thesansmonocd_w5regular_">echo</span> command. In essence, I’m treating the contents of the variable as a single-record input file to the <span class="sans_thesansmonocd_w5regular_">findstr</span> <span aria-label=" Page 287. " epub:type="pagebreak" id="pg_287" role="doc-pagebreak"/>command. The end result is that the command searches the string for the text.</p>
<p class="listbody">Remember that the <span class="sans_thesansmonocd_w5regular_">findstr</span> command sets <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">0</span> when it finds the search string; otherwise, <span class="sans_thesansmonocd_w5regular_">1</span> is the value. If it’s <span class="sans_thesansmonocd_w5regular_">0</span>, the code sets the <span class="sans_thesansmonocd_w5regular_">bLove</span> boolean to true; if not, the result is false.</p>
<p class="listbody">First envision this logic with <span class="sans_thesansmonocd_w5regular_">aString</span> set to the Croatian string. The <span class="sans_thesansmonocd_w5regular_">love</span> text isn’t in the string, so the command returns <span class="sans_thesansmonocd_w5regular_">1</span>, and we set the boolean to false. Now do the same with the string set to the Slovenian text. The <span class="sans_thesansmonocd_w5regular_">love</span> text is embedded in three different words in the short string—Bring g<b class="calibre10">love</b>s and a pul<b class="calibre10">love</b>r to S<b class="calibre10">love</b>nia. One or more matches sets <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">0</span>, so we set the boolean to true.</p>
<p class="listbody">Also notice how easily we can convert this to a case-insensitive search:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">echo "%aString%" | findstr /i love</span>
</code></pre>
<p class="listbody">Much of the flexibility present when searching a file is still available when searching a string. The options for targeting the beginning or ending of the string, negating the logic, and others work perfectly well in this context.</p>
<p class="listhead"><b class="calibre10">The Text Replacement Method</b></p>
<p class="listplainfirst">The idea behind the text replacement method is as straightforward as its execution. The technique compares a resolved variable to itself with the search string removed. If they differ, we’ve found the search string; if they’re equal, we haven’t found the text. The following code uses this method to determine whether a string contains another string, in this case <span class="sans_thesansmonocd_w5regular_">love</span>, setting the same boolean from the prior example to true or false:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">if "%aString%" neq "%aString:love=%" (</span>
   set bLove=true==true
) else (
   set bLove=false==x
)
</code></pre>
<p class="listbody">The left side of the inequality is pedestrian by now, a resolved variable in double quotes. The <span class="sans_thesansmonocd_w5regular_">if</span> command compares it to <span class="sans_thesansmonocd_w5regular_">"%aString:love=%"</span>, the same resolved variable, but with all instances of the <span class="sans_thesansmonocd_w5regular_">love</span> text replaced with null; notice that nothing comes between the equal sign and the terminating percent sign. The upshot is that if <span class="sans_thesansmonocd_w5regular_">aString</span> contains at least one instance of the <span class="sans_thesansmonocd_w5regular_">love</span> string, these two values differ, and we set the <span class="sans_thesansmonocd_w5regular_">bLove</span> boolean to true; if the search string isn’t inside the string we’re searching, the two values are identical, and we set <span class="sans_thesansmonocd_w5regular_">bLove</span> to false.</p>
<p class="listbody">Let’s execute this code with both possible values of <span class="sans_thesansmonocd_w5regular_">aString</span>. Assuming that it contains the Croatian text, the two values are identical because <span aria-label=" Page 288. " epub:type="pagebreak" id="pg_288" role="doc-pagebreak"/>the <span class="sans_thesansmonocd_w5regular_">love</span> string isn’t to be found, and we set <span class="sans_thesansmonocd_w5regular_">bLove</span> to false. However, the text replacement syntax alters the Slovenian text by removing each of the three instances of the <span class="sans_thesansmonocd_w5regular_">love</span> string, resulting in this mess on the right side of the inequality: <span class="sans_thesansmonocd_w5regular_">"Bring gs and a pulr to Snia."</span> This clearly doesn’t equal the original text, so we set <span class="sans_thesansmonocd_w5regular_">bLove</span> to the value of true.</p>
<p class="listbody">Delayed expansion makes this technique more generic, allowing you to use variables for both the search string and the string to search:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">if "%stringToSearch%" neq "!stringToSearch:%searchString%=!" (</span>
    set bLove=true==true
) else (
   set bLove=false==x
)
</code></pre>
<p class="listcontinued">Now the search string and the string to search are variables, allowing you to determine both in the Batch code prior to performing this search.</p>
<p class="tx">When searching a string, both methods have a definitive place in the Batch universe. The biggest advantage of the <span class="sans_thesansmonocd_w5regular_">findstr</span> method is its flexibility, primarily its ability to perform case-sensitive searches, and you can use those options discussed earlier to easily customize any search. In contrast, the text replacement method is intrinsically case-insensitive because you can’t easily change the fact that the interpreter ignores the case of the text being changed.</p>
<p class="tx">The text replacement method has advantages of its own. First, I consider it a bit simpler to use. Neither method is complex, but an <span class="sans_thesansmonocd_w5regular_">if</span> command, even with delayed expansion, is even more straightforward than an <span class="sans_thesansmonocd_w5regular_">echo</span> piped to a <span class="sans_thesansmonocd_w5regular_">findstr</span>. But by far its primary advantage is performance.</p>
<p class="tx">When you call the <span class="sans_thesansmonocd_w5regular_">findstr</span> command, you’re actually calling a program, <i class="calibre6">findstr.exe</i>, and any program invocation involves more overhead than a simple comparison of two variables. They both happen in a fraction of a second, but the text replacement method happens in a much smaller fraction. You wouldn’t notice the distinction performing a handful of searches, but I tested both methods extensively and found the text replacement method to be more than 200 times faster than the <span class="sans_thesansmonocd_w5regular_">findstr</span> method. There are many variables to consider when testing performance and my testing is far from definitive, but it’s safe to say that a major advantage of the text replacement method is that it’s much faster.</p>
<p class="tx">In the final analysis, if your code is to perform a search repeatedly, say in a loop with possibly hundreds or even thousands of invocations, the replacement text method is the better choice. However, if efficiency isn’t a big concern or if you need a more complex search, even just a case-sensitive search, the <span class="sans_thesansmonocd_w5regular_">findstr</span> method is the better choice.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="h" id="sec13"><span id="h1-166"/><span aria-label=" Page 289. " epub:type="pagebreak" id="pg_289" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Regular Expressions</span></h3>
<p class="tni">Throughout this book I’ve more than hinted that Batch syntax can be esoteric and counterintuitive, even for someone who has coded in the language for many years. But somewhere out there someone of a contrarian bent is saying, “It isn’t that bad” or “Who among us hasn’t memorized all the options of the <span class="sans_thesansmonocd_w5regular_">findstr</span> command?” To this person I have two words: <i class="calibre6">regular expressions</i>, or <i class="calibre6">regex</i>.</p>
<p class="tx">Regular expressions are not unique to Batch. Many languages and editors use them as an incredibly powerful tool for searches. With regex, you can search for numeric values, non-numeric values, and very intricate patterns and ranges of characters. The <span class="sans_thesansmonocd_w5regular_">/B</span> and <span class="sans_thesansmonocd_w5regular_">/E</span> options of the <span class="sans_thesansmonocd_w5regular_">findstr</span> command allow you to search for text at the beginning or ending of a record, but regex allows you to do both in one command—that is, search for one string at the beginning and another string at the end of a record. Let’s see regex in action with a couple of examples.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="h1" id="sec14"><span id="h2-76"/><span class="sans_futura_std_heavy_oblique_bi_">Searching for Any Number</span></h4>
<p class="tni">The following <span class="sans_thesansmonocd_w5regular_">findstr</span> command using the regex option, denoted appropriately enough by <span class="sans_thesansmonocd_w5regular_">/R</span>, searches the <i class="calibre6">12Movies.txt</i> file to find all movies with at least one number in the title:</p>
<pre class="pre"><code class="calibre11">findstr /R "[0-9]" C:\Batch\12Movies.txt</code></pre>
<p class="tx">The regular expression <span class="sans_thesansmonocd_w5regular_">[0-9]</span> denotes all characters from 0 to 9, inclusive. Given the input file that we’ve been using throughout this chapter, the command returns just one title:</p>
<pre class="pre"><code class="calibre11">Big Hero 6</code></pre>
<p class="tx">If we were working with a more complete list of movies, the titles returned might include <i class="calibre6">2001: A Space Odyssey</i>, <i class="calibre6">12 Angry Men</i>, <i class="calibre6">The 12th Man</i>, and <i class="calibre6">Ocean’s 11</i>, but not the remake <i class="calibre6">Ocean’s Eleven</i>.</p>
<p class="tx">Regular expressions also are effective when searching a string as opposed to a file. Consider the following example that uses negated logic (<span class="sans_thesansmonocd_w5regular_">/V</span>) for a regex (<span class="sans_thesansmonocd_w5regular_">/R</span>) search:</p>
<pre class="pre"><code class="calibre11">:TryAgain
 &gt; con set /P reply=Enter a movie title that does NOT include a number:
 echo %reply% | findstr /R /V "[0-9]"
 if errorlevel 1 (
    &gt; con echo Invalid response. Please try again. 
    goto :TryAgain
)
</code></pre>
<p class="tx">The code prompts the user for a movie title without a number anywhere in the title. If they enter a typical movie sequel or a title such as <span aria-label=" Page 290. " epub:type="pagebreak" id="pg_290" role="doc-pagebreak"/><i class="calibre6">28 Days Later</i>, this logic prompts them to enter a different title until they finally abide by the instructions.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="h1" id="sec15"><span id="h2-77"/><span class="sans_futura_std_heavy_oblique_bi_">Searching with Complex Criteria</span></h4>
<p class="tni">For a search that would be far more difficult without regex, consider the following:</p>
<pre class="pre"><code class="calibre11">findstr /R "^The...........*Man$" C:\Batch\12Movies.txt</code></pre>
<p class="tni">The leading caret isn’t an escape character in this context, but part of a string encased in double quotes. The caret is a regex indicator noting that the text after it is anchored to the beginning of the string, and the trailing dollar sign indicates the text before it is anchored to the end of the string. The 11 dots are wildcards, and the asterisk indicates that the wildcard just before it can be of any length, zero and up.</p>
<p class="tx">Putting this all together in a language that a non-regex-coder can understand, the search is looking for all records that start with <span class="sans_thesansmonocd_w5regular_">The</span> and end in <span class="sans_thesansmonocd_w5regular_">Man</span>, case-sensitive, with at least 10 characters, spaces included, between them.</p>
<p class="tx">If you execute this command using a file containing a more complete list of movies, it might return the title <i class="calibre6">The Invisible Man</i> and even <i class="calibre6">The Amazing Spider-Man</i>. However, <i class="calibre6">The Amazing Spider-Man 2</i>, <i class="calibre6">The Music Man</i>, and the aforementioned <i class="calibre6">The 12th Man</i> are out of the mix. (The first has a number appended to the title, and the other two are too short.)</p>
<p class="tx">To perform this same search without regex, you could pipe one <span class="sans_thesansmonocd_w5regular_">findstr</span> command using the <span class="sans_thesansmonocd_w5regular_">/B</span> option into another <span class="sans_thesansmonocd_w5regular_">findstr</span> command using the <span class="sans_thesansmonocd_w5regular_">/E</span> option, but you’d still need to filter out all of the titles with fewer than 10 characters between the two words; it’s possible, but oh so messy. Many other difficult to nearly impossible searches are more than possible with regular expressions.</p>
<p class="tx">The topic of regular expressions commands its own book. I’ve demonstrated a couple of examples useful in Batch, but the next time one of your searches starts to get overly complex, look up the regex syntax for your problem in a book or on the internet, and give it a try with the <span class="sans_thesansmonocd_w5regular_">findstr</span> command and the <span class="sans_thesansmonocd_w5regular_">/R</span> option. Even experienced coders sometimes shy away from regex because of the complexity, but the power illustrated in these relatively simple examples is a window into other applications.</p>
<p class="tx">To make things a little more intriguing, Batch supports only a subset of the common regex functionality, so some regular expressions that work elsewhere don’t work in Batch. To state the obvious, rigorous testing is a must, with both positive and negative cases.</p>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="h" id="sec16"><span id="h1-167"/><span class="sans_futura_std_bold_b_">Finding the Record Count of a File</span></h3>
<p class="tni">Hoarding may be a vice, but nothing ever gets truly thrown out in Batch. The <span class="sans_thesansmonocd_w5regular_">copy</span> command is useful for creating an empty file even though the <span class="sans_thesansmonocd_w5regular_">xcopy</span> and <span class="sans_thesansmonocd_w5regular_">robocopy</span> commands have long since superseded it for all <span aria-label=" Page 291. " epub:type="pagebreak" id="pg_291" role="doc-pagebreak"/>copy-related functionality. Likewise, the <span class="sans_thesansmonocd_w5regular_">find</span> command is pretty much useless when compared to the <span class="sans_thesansmonocd_w5regular_">findstr</span> command, so I’ll forgo the discussion of how you would use it to perform a search. It does have one useful feature, however: getting the record count of a file. Consider the following:</p>
<pre class="pre"><code class="calibre11">find "" /V /C C:\Batch\12Movies.txt</code></pre>
<p class="tx">This command performs a search for the null string between the double quotes, using <i class="calibre6">12Movies.txt</i> as its input. The <span class="sans_thesansmonocd_w5regular_">/V</span> option negates the search logic just as it does with the <span class="sans_thesansmonocd_w5regular_">findstr</span> command. It returns all records not containing the null string, which in effect returns every record in the file. The <span class="sans_thesansmonocd_w5regular_">/C</span> option gives the <i class="calibre6">count</i> of records returned, which is the number of records in the file since every record is returned, but what it writes to stdout is a bit more verbose than what we need:</p>
<pre class="pre"><code class="calibre11">---------- C:\BATCH\12MOVIES.TXT: 12</code></pre>
<p class="tx">Conveniently, and also oddly, the <span class="sans_thesansmonocd_w5regular_">find</span> command behaves differently when we pipe the input file into it via the <span class="sans_thesansmonocd_w5regular_">type</span> command:</p>
<pre class="pre"><code class="calibre11">type C:\Batch\12Movies.txt | find "" /V /C</code></pre>
<p class="tni">This command succinctly writes the count, <span class="sans_thesansmonocd_w5regular_">12</span> in this instance, to stdout.</p>
<p class="tx">To capture that value in a variable, we can execute the two piped commands as input to a <span class="sans_thesansmonocd_w5regular_">for /F</span> command, but we must escape the pipe before the <span class="sans_thesansmonocd_w5regular_">find</span> command:</p>
<pre class="pre"><code class="calibre11">for /F usebackq %%c in (`type C:\Batch\12Movies.txt ^| find "" /V /C`) do (
   set recCount=%%c
)
</code></pre>
<p class="tni">(Notice the <span class="sans_thesansmonocd_w5regular_">usebackq</span> keyword and the back quotes encasing the input component of the <span class="sans_thesansmonocd_w5regular_">for /F</span> command, a combination that clearly shows command input.)</p>
<p class="tx">This might seem like an awfully long walk to get a record count. Yes, with the use of escaping we are piping the output of one command (<span class="sans_thesansmonocd_w5regular_">type</span>) into a second command (<span class="sans_thesansmonocd_w5regular_">find</span>) and using its output as input to a third command (<span class="sans_thesansmonocd_w5regular_">for</span>) that has a code block containing a fourth command (<span class="sans_thesansmonocd_w5regular_">set</span>) that actually sets the variable. Phew. But it works and is elegant in its own special way.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="h" id="sec17"><span id="h1-168"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, I discussed many facets of Batch text searches. You learned how to perform searches for many different types of strings, how to search each record of a file, and how to search for one string inside another string.</p>
<p class="tx">I also compared and contrasted two different techniques for performing text searches. The <span class="sans_thesansmonocd_w5regular_">findstr</span> method is extremely powerful and flexible, <span aria-label=" Page 292. " epub:type="pagebreak" id="pg_292" role="doc-pagebreak"/>and the text replacement method is easy, efficient, and lightning fast. You now know when to use each. I introduced regular expressions and demonstrated how immensely useful they are in complex searches. You even learned how to determine how many records are in a file.</p>
<p class="tx">In the next chapter, I’ll introduce another fascinating and useful topic—code that writes code, specifically bat files that create other bat files.</p>
</section>
</section>
</div></body></html>