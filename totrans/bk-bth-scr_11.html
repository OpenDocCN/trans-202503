<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch10" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch10">
<span class="cn"><span aria-label=" Page 103. " epub:type="pagebreak" id="pg_103" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">10</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">CALLING ROUTINES AND BAT FILES</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">In the previous chapter, I introduced labels and nonsequential execution, both of which also play a major part in this chapter. I’ll soon introduce a new twist on an already discussed command, allowing you to create and call a routine defined by a label. Instead of simply handing control over to the code just after the label, control is returned to the place from where it was called after the routine executes. As you write more complex and interesting bat files, you’ll want a full understanding of routines.</p>
<p class="tx">In <span class="xref"><a href="chapter8.xhtml" class="calibre3">Chapter 8</a></span>, I introduced the concept of calling executables compiled in other languages. I’ll expand on that discussion here, describing different techniques for one bat file calling another bat file. You’ll obviously learn about the most typical type of call, one that returns control to the calling <span aria-label=" Page 104. " epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/>bat file. But you’ll also learn techniques for relinquishing control to the called bat file and how to spawn a second parallel Batch process. In addition, you’ll explore different ways to exit from a routine or bat file gracefully, with or without a return code.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-70"/><span class="sans_futura_std_bold_b_">The call Command, Revisited</span></h3>
<p class="tni">Before you can create callable internal routines, you must understand the similarities and differences between two commands that work with labels. One is the <span class="sans_thesansmonocd_w5regular_">call</span> command first introduced in <span class="xref"><a href="chapter8.xhtml" class="calibre3">Chapter 8</a></span>, where we used it to call programs compiled in other languages. The other is the <span class="sans_thesansmonocd_w5regular_">goto</span> command, introduced in <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span> for altering the execution flow of a bat file.</p>
<p class="tx">To compare and contrast the two commands, recall this code from <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span>:</p>
<pre class="pre"><code class="calibre11"> &gt; con echo Before GOTO
 goto :MyLabel
 &gt; con echo After GOTO
:MyLabel
 &gt; con echo After LABEL
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">goto</span> command skipped the middle <span class="sans_thesansmonocd_w5regular_">echo</span> command, resulting in this output:</p>
<pre class="pre"><code class="calibre11">Before GOTO
After LABEL
</code></pre>
<p class="tx">To demonstrate the contrast, <a href="#Lis10-1" class="calibre3">Listing 10-1</a> changes every instance of <span class="sans_thesansmonocd_w5regular_">goto</span> in that code to <span class="sans_thesansmonocd_w5regular_">call</span>, including both the <span class="sans_thesansmonocd_w5regular_">goto</span> command and the text in the <span class="sans_thesansmonocd_w5regular_">echo</span> commands, while leaving everything else identical in this very concise bat file.</p>
<span id="Lis10-1"/>
<pre class="pre"><code class="calibre11"> &gt; con echo Before CALL
 call :MyLabel
 &gt; con echo After CALL
:MyLabel
 &gt; con echo After LABEL
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 10-1: A short bat file demonstrating the call command</span></p>
<p class="tx">Execute the bat file from <a href="#Lis10-1" class="calibre3">Listing 10-1</a>, and you’ll get the four lines shown in <a href="#Lis10-2" class="calibre3">Listing 10-2</a> written to the console, not the three some may have expected.</p>
<span id="Lis10-2"/>
<pre class="pre"><code class="calibre11">Before CALL
After LABEL
After CALL
After LABEL
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 10-2: The results written to the console when executing <a href="#Lis10-1" class="calibre3">Listing 10-1</a></span></p>
<p class="tx"><span aria-label=" Page 105. " epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/>The display of <span class="sans_thesansmonocd_w5regular_">Before CALL</span> obviously executes right off the bat (pun intended). The <span class="sans_thesansmonocd_w5regular_">call</span> command temporarily hands control to the code just after the label, resulting in <span class="sans_thesansmonocd_w5regular_">After LABEL</span> being displayed. When this was a <span class="sans_thesansmonocd_w5regular_">goto</span> command, that was it; the bat file ended after that display. But with the <span class="sans_thesansmonocd_w5regular_">call</span> command, after everything between <span class="sans_thesansmonocd_w5regular_">:MyLabel</span> and the end of the bat file executes, control returns to the command immediately after the <span class="sans_thesansmonocd_w5regular_">call</span> command. Hence, <span class="sans_thesansmonocd_w5regular_">After CALL</span> is displayed.</p>
<p class="tx">Some might expect the execution to be completed at this point, but the interpreter next encounters <span class="sans_thesansmonocd_w5regular_">:MyLabel</span> again. We aren’t calling it or going to it; instead, it’s just the next line of code. Notice that I didn’t call it a command or even a statement. It’s just a line of code, a placeholder, and in this context, little more than a very subtle speed bump on the path to the next command. The interpreter moves on to the last line in the bat file, and the text <span class="sans_thesansmonocd_w5regular_">After LABEL</span> is displayed a second time. The interpreter finds no other command to interpret, and the bat file is done.</p>
<p class="tx">While the <span class="sans_thesansmonocd_w5regular_">goto</span> command relinquishes control, the <span class="sans_thesansmonocd_w5regular_">call</span> command remembers from where it came and returns to that spot when its business is done. We now have the makings of a callable internal routine, and we’ll be calling that routine with the <span class="sans_thesansmonocd_w5regular_">call</span> command.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h" id="sec2"><span id="h1-71"/><span class="sans_futura_std_bold_b_">Calling Internal Routines</span></h3>
<p class="tni">As your Batch code gets more interesting, you’ll want to execute a bit of code multiple times from various locations in a bat file. For instance, you might want to call an executable more than once, or you might want to periodically check a directory for some files in need of copying. When we get to interactive Batch, you might want to ask the user a question and get a response several times.</p>
<p class="tx">Faced with a need for multiple invocations of a section of code, a novice coder might resort to cutting and pasting—a loathsome and odious option in my exceedingly judgmental (but accurate) opinion. A far better solution is to create an internal routine and call it from those multiple locations. You can even place some code that’s called only once into a routine just to better organize your bat file. Sometimes it’s perfectly fine to run right through a label, but more times than not, you’ll want to create a routine that can be invoked only by calling it.</p>
<p class="tx">For the following exercise, I’ll take <a href="#Lis10-1" class="calibre3">Listing 10-1</a> and reconfigure it so that the label defines a callable routine. That is, the execution flow will call the routine, return from it, and exit the bat file before falling through to that routine again. To this end, I’ll need a way to terminate both the routine and bat file. The final display of <span class="sans_thesansmonocd_w5regular_">After LABEL</span> that appears in <a href="#Lis10-2" class="calibre3">Listing 10-2</a> will be no more. Instead, we’ll expect these three lines of output:</p>
<pre class="pre"><code class="calibre11">Before CALL
After LABEL
After CALL
</code></pre>
<p class="tx"><span aria-label=" Page 106. " epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/>The following code, which looks quite a bit different, does exactly that:</p>
<pre class="pre"><code class="calibre11"> &gt; con echo Before CALL
<span aria-label="annotation1" class="codeannotationhang1">❶</span> call :MyLabel
 &gt; con echo After CALL
<span aria-label="annotation2" class="codeannotationhang1">❷</span> goto :eof &amp; rem End of TestCall.bat
   
<span aria-label="annotation3" class="codeannotationhang">❸</span> :MyLabel
 &gt; con echo After LABEL
<span aria-label="annotation4" class="codeannotationhang1">❹</span> goto :eof &amp; rem End of :MyLabel

<span aria-label="annotation5" class="codeannotationhang">❺</span> :AnotherLabel
 &gt; con echo This is Never Executed
 <span aria-label="annotation6" class="codeannotationhang">❻</span> goto :eof &amp; rem End of :AnotherLabel
</code></pre>
<p class="tni">Before stepping through the code, notice the three <span class="sans_thesansmonocd_w5regular_">goto :eof</span> commands. As you might expect, the first one <span aria-label="annotation2" class="codeannotation">❷</span> jumps to the <i class="calibre6">end of file</i>, ceasing the bat file. The other two <span aria-label="annotation4" class="codeannotation">❹</span> <span aria-label="annotation6" class="codeannotation">❻</span> are something quite different—something new.</p>
<p class="tx">After the initial <span class="sans_thesansmonocd_w5regular_">echo</span> command, the <span class="sans_thesansmonocd_w5regular_">call</span> command <span aria-label="annotation1" class="codeannotation">❶</span> invokes the routine that <span class="sans_thesansmonocd_w5regular_">:MyLabel</span> <span aria-label="annotation3" class="codeannotation">❸</span> defines, which contains just two commands. The first is the familiar <span class="sans_thesansmonocd_w5regular_">echo</span> of <span class="sans_thesansmonocd_w5regular_">After LABEL</span> to the console, and the second is a <span class="sans_thesansmonocd_w5regular_">goto :eof</span> command <span aria-label="annotation4" class="codeannotation">❹</span>. Because this command is being executed after a label is called, it ends not the file but the routine, and control returns to the command just after the <span class="sans_thesansmonocd_w5regular_">call</span> command <span aria-label="annotation1" class="codeannotation">❶</span>, writing <span class="sans_thesansmonocd_w5regular_">After CALL</span> to the console. Finally, the main <span class="sans_thesansmonocd_w5regular_">goto :eof</span> command <span aria-label="annotation2" class="codeannotation">❷</span> exits the bat file, because the interpreter knows that it isn’t in a routine.</p>
<p class="tx">When inside the <span class="sans_thesansmonocd_w5regular_">:MyLabel</span> <span aria-label="annotation3" class="codeannotation">❸</span> routine, going to <span class="sans_thesansmonocd_w5regular_">:eof</span> (or <i class="calibre6">end of file</i>) is a misnomer; it’s really more of an <i class="calibre6">end of routine</i>, but let’s not quibble over semantics. If you remove this <span class="sans_thesansmonocd_w5regular_">goto :eof</span> command <span aria-label="annotation4" class="codeannotation">❹</span>, control would’ve continued through to the code under <span class="sans_thesansmonocd_w5regular_">:AnotherLabel</span> <span aria-label="annotation5" class="codeannotation">❺</span> before returning to the mainline logic. But with this command <span aria-label="annotation4" class="codeannotation">❹</span>, the code under <span class="sans_thesansmonocd_w5regular_">:AnotherLabel</span> never executes.</p>
<p class="tx">Since the <span class="sans_thesansmonocd_w5regular_">goto :eof</span> command has two distinct uses, I usually follow such commands with a remark defining exactly what it’s terminating, either the name of the routine or the bat file itself. I’m simply placing the <span class="sans_thesansmonocd_w5regular_">rem</span> command after an ampersand, which separates the two commands on a single line of code. Programmatically, it’s not necessary, but this practice very much enhances the code’s readability, especially when the routines become longer and more complex than the previous examples.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="h" id="sec3"><span id="h1-72"/><span class="sans_futura_std_bold_b_">Calling Bat Files</span></h3>
<p class="tni">Short or repetitive bits of code are great candidates for internal routines; you can add one or more routines to the end of a bat file to create a well-organized module of which you can be proud. But sometimes those short bits of code aren’t so short, or they are so useful that you would like to make them available to other bat files written by you and maybe even others. Instead of a routine, this scenario calls for one bat file calling another bat <span aria-label=" Page 107. " epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>file. For instance, you might create a single bat file to handle logging and call it from multiple other bat files.</p>
<p class="tx">Executing one bat file from another works a bit differently than executing an internal routine. But first, let’s return to how a compiled program is executed from <span class="xref"><a href="chapter8.xhtml" class="calibre3">Chapter 8</a></span>. When the interpreter comes across a line of code that’s simply the name of an executable, it invokes the executable. Hence, this “command” executes the program:</p>
<pre class="pre"><code class="calibre11">C:\Executables\CompiledProg.exe</code></pre>
<p class="tx">After the program completes its task, control returns to the bat file. You might expect the calling of a bat file to work the same way, but alas, it does not. However, the following line of code indeed executes the called bat file, but with an enormous batveat:</p>
<pre class="pre"><code class="calibre11">C:\Batch\CalledBat.bat</code></pre>
<p class="tx">That batveat is simple: control never returns to the calling bat file. The entire process ends when the called bat file ends. The vast majority of the time you’ll want control returned; otherwise, there wouldn’t be much point in coding anything after the invocation of the called bat file. To see control returned, you can insert the <span class="sans_thesansmonocd_w5regular_">call</span> command just before the called bat file:</p>
<pre class="pre"><code class="calibre11">call C:\Batch\CalledBat.bat</code></pre>
<p class="tx">To sum up, whether calling bat files or compiled executables of another language, you can use the <span class="sans_thesansmonocd_w5regular_">call</span> command or omit it, but there’s a difference. When calling an executable, both techniques are virtually identical. When calling a fellow bat file, the <span class="sans_thesansmonocd_w5regular_">call</span> command ensures that control is returned to the caller. Without the command, control never returns.</p>
<p class="tx">Since I’ve never found a use for a non-returning bat file invocation, my preference always is to omit the <span class="sans_thesansmonocd_w5regular_">call</span> command for executables and use it for bat files. One advantage is that at a glance, it’s obvious what type of file is being called.</p>
<p class="tx">Early in my career, I learned about the need for the <span class="sans_thesansmonocd_w5regular_">call</span> command vis-<span class="copyright_accent">à</span>-vis bat files the hard way when I couldn’t figure out why my bat file just stopped executing. There was no hang or abort message; it just stopped. Complicating matters, my troubleshooting was understandably focused on the called bat file. It took quite a while before I noticed the missing <span class="sans_thesansmonocd_w5regular_">call</span> command and, more important, understood its significance. But that isn’t the only idiosyncrasy concerning the <span class="sans_thesansmonocd_w5regular_">call</span> command.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="h" id="sec4"><span id="h1-73"/><span class="sans_futura_std_bold_b_">Notes on Calling a Label</span></h3>
<p class="tni">In the previous chapter, I mentioned that it’s possible to leave the colon off the label name in the argument of the <span class="sans_thesansmonocd_w5regular_">goto</span> command, although including it is highly encouraged. With the <span class="sans_thesansmonocd_w5regular_">call</span> command, the colon is always required when calling a label defining an internal routine.</p>
<p class="tx"><span aria-label=" Page 108. " epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>This apparent incongruity might not make sense until you consider that the <span class="sans_thesansmonocd_w5regular_">goto</span> command is concerned only with going to labels inside its bat file, while the <span class="sans_thesansmonocd_w5regular_">call</span> command calls entities inside and outside of its bat file. The upshot is that something very unexpected happens when an attempt to call <span class="sans_thesansmonocd_w5regular_">:MyLabel</span> is invoked without the colon:</p>
<pre class="pre"><code class="calibre11">call MyLabel</code></pre>
<p class="tx">A colon would’ve told the interpreter to call an internal routine, but instead the interpreter tries to call an external file. First it looks for an executable, such as <i class="calibre6">MyLabel.com</i> or <i class="calibre6">MyLabel.exe</i>, in the current directory. Then it looks for <i class="calibre6">MyLabel.bat</i> and a few other types of executables with this filename, also in the current directory. Then it goes through all the directories in the <span class="sans_thesansmonocd_w5regular_">path</span> variable desperately looking for anything named <span class="sans_thesansmonocd_w5regular_">MyLabel</span> that it can execute. If no such file is found, the interpreter won’t look for a label of that name, even if <span class="sans_thesansmonocd_w5regular_">:MyLabel</span> is a valid label in the bat file; instead, it generates an error.</p>
<p class="tx">When navigating to a label with either the <span class="sans_thesansmonocd_w5regular_">goto</span> or <span class="sans_thesansmonocd_w5regular_">call</span> command, always use the colon, for consistency’s sake if nothing else.</p>
<blockquote class="calibre8">
<p class="warning"><span class="sans_dogma_ot_bold_b_1">NOTE</span></p>
</blockquote>
<p class="warning-txt"><i class="calibre6">In <a href="chapter9.xhtml" class="calibre3">Chapter 9</a>, I mentioned that the goto command aborts a process when the label isn’t found. The call command is a little more forgiving. They both write out an error message when its argument is an invalid label, but the call command also sets errorlevel to 1. If you choose not to interrogate the return code, the process continues on cavalierly as if nothing is amiss. (See <a href="chapter28.xhtml" class="calibre3">Chapter 28</a> for more details on how to handle a failed call command.)</i></p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="h" id="sec5"><span id="h1-74"/><span class="sans_futura_std_bold_b_">Launching Bat Files</span></h3>
<p class="tni">Sometimes you might want to launch or spawn a bat file as a new process. That is, you may wish to kick off another bat file but don’t want the interpreter to wait around for it to finish up before continuing. For instance, you can execute multiple processes in parallel to speed up overall processing time. You can spin off a noncritical but time-consuming task, perhaps a logging process, to execute on its own time. In <span class="xref"><a href="chapter26.xhtml" class="calibre3">Chapter 26</a></span>, I’ll discuss how to automatically kill and restart a process that’s hung. To make this happen, I’ll spawn the process susceptible to hanging as an independent bat file and monitor it from the main bat file.</p>
<p class="tx">To launch or spawn a bat file, simply use the <span class="sans_thesansmonocd_w5regular_">start</span> command in lieu of the <span class="sans_thesansmonocd_w5regular_">call</span> command:</p>
<pre class="pre"><code class="calibre11">start C:\Batch\LaunchedBat.bat</code></pre>
<p class="tx">This command creates a second command or DOS window where the file <i class="calibre6">LaunchedBat.bat</i> executes simultaneously with the bat file that started it.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="h" id="sec6"><span id="h1-75"/><span aria-label=" Page 109. " epub:type="pagebreak" id="pg_109" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">The exit Command</span></h3>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">exit</span> command, as you might imagine, exits routines, bat files, or entire executions, and it can even set a return code. It overlaps in functionality with the <span class="sans_thesansmonocd_w5regular_">goto :eof</span> command, but I’ll soon show a significant distinction.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">exit</span> command with no arguments abruptly ends the entire process. Sadly, the second <span class="sans_thesansmonocd_w5regular_">echo</span> command won’t be executed:</p>
<pre class="pre"><code class="calibre11">&gt; con echo The Meaning of Life is...
exit
&gt; con echo ... %meaningOfLife%
</code></pre>
<p class="tx">The first <span class="sans_thesansmonocd_w5regular_">echo</span> command writes its message to the console, but the <span class="sans_thesansmonocd_w5regular_">exit</span> command closes the window before you can read it. This happens regardless of where the <span class="sans_thesansmonocd_w5regular_">exit</span> command is invoked—in the high-level bat file, in a called bat file, or even in a routine in either type of bat file. This variant of the command is analogous to a sledgehammer.</p>
<p class="tx">However, the <span class="sans_thesansmonocd_w5regular_">/B</span> option turns the <span class="sans_thesansmonocd_w5regular_">exit</span> command into more of a jewelry mallet. The documentation is unclear as to what <span class="sans_thesansmonocd_w5regular_">B</span> represents, but for me it stands for <i class="calibre6">break</i> in that the following command breaks out of just the code being invoked, whether it’s a called bat file or a routine inside a bat file:</p>
<pre class="pre"><code class="calibre11">exit /B</code></pre>
<p class="tni">This command exits the entire process only if invoked in the main logic of the high-level bat file. It doesn’t change <span class="sans_thesansmonocd_w5regular_">errorlevel</span> and is logically equivalent to <span class="sans_thesansmonocd_w5regular_">goto :eof</span>. Both commands are valid, and the usage usually comes down to personal preference. Mine is the <span class="sans_thesansmonocd_w5regular_">goto :eof</span> command, but only in those instances when I don’t need the return code.</p>
<p class="tx">At the beginning of <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span>, I referenced the rudimentary abort logic reproduced in <a href="#Lis10-3" class="calibre3">Listing 10-3</a> but left its explanation for later, which is now.</p>
<span id="Lis10-3"/>
<pre class="pre"><code class="calibre11">:Abort
 echo The Process is aborting
 exit /B 1
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 10-3: An abort routine labeled as :Abort</span></p>
<p class="tx">This <span class="sans_thesansmonocd_w5regular_">exit</span> command behaves just like <span class="sans_thesansmonocd_w5regular_">exit /B</span> with one exception. When control is returned to where the code was called, the command’s numerical argument following the option becomes the new value contained in <span class="sans_thesansmonocd_w5regular_">errorlevel</span>. In short, the command breaks out of a bat file or routine and returns an exit or return code. In the prior example, the return code is <span class="sans_thesansmonocd_w5regular_">1</span>. But if no errors are detected, the main logic of a bat file might end by setting the return code to <span class="sans_thesansmonocd_w5regular_">0</span>:</p>
<pre class="pre"><code class="calibre11">exit /B 0</code></pre>
<p class="tx"><span aria-label=" Page 110. " epub:type="pagebreak" id="pg_110" role="doc-pagebreak"/>If a fatal error is detected, a <span class="sans_thesansmonocd_w5regular_">goto :Abort</span> command from the mainline logic will direct the interpreter to the abort logic shown in <a href="#Lis10-3" class="calibre3">Listing 10-3</a>. The <span class="sans_thesansmonocd_w5regular_">goto</span> command must be used because a <span class="sans_thesansmonocd_w5regular_">call</span> command would treat the abort logic like a called routine; the <span class="sans_thesansmonocd_w5regular_">errorlevel</span> would be set, but control would be returned to the spot of the fatal error. But when navigating to the label with the <span class="sans_thesansmonocd_w5regular_">goto</span> command, a routine isn’t invoked; it’s still considered to be in the mainline logic, and the <span class="sans_thesansmonocd_w5regular_">exit</span> command ends the bat file instead of a routine.</p>
<p class="tx">To make this more flexible, you can create a variable for the exit code, setting it to different values for different failures:</p>
<pre class="pre"><code class="calibre11">:Abort
 echo The Process is Aborting
 exit /B %exitCode%
</code></pre>
<p class="tni">Then this logic can be accessed via multiple <span class="sans_thesansmonocd_w5regular_">goto</span> commands in the bat file.</p>
<p class="tx">(A real-world abort routine will be far more interesting than this simple <span class="sans_thesansmonocd_w5regular_">echo</span> command. The error message could be multiple lines and have variable content, all written to a logfile as well as the console, but I’ve simplified it here to keep the focus on the <span class="sans_thesansmonocd_w5regular_">exit</span> command.)</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="h" id="sec7"><span id="h1-76"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, I’ve detailed the different methods of calling internal routines and other bat files. You’ve learned how to return from those calls with or without a return code, or how to simply end the entire process abruptly from anywhere. You also learned how to launch or spawn another bat file, which is entirely independent of the first bat file. Above all else, you now understand the significant and subtle differences between the <span class="sans_thesansmonocd_w5regular_">goto</span> and <span class="sans_thesansmonocd_w5regular_">call</span> commands. In a nutshell, the <span class="sans_thesansmonocd_w5regular_">call</span> returns control and can reach outside of its bat file, while the <span class="sans_thesansmonocd_w5regular_">goto</span> does neither.</p>
<p class="tx">One large piece remains in this puzzle. A calling bat file can pass multiple arguments to a called bat file, and that called bat file can even set and pass back parameters in return. There’s more to this than one might expect, and I’ll detail all of the nuances in the very next chapter.</p>
</section>
</section>
</div></body></html>