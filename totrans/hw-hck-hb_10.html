<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="293" id="Page_293"/>10</span><br/>
<span class="ChapterTitle">Splitting the Difference: Differential Power Analysis</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Using power measurements to learn about program flow has clear security implications, but what if we can go further than just learning about the program flow? It’s easy to imagine an algorithm where the code has the same program flow regardless of data being processed, but with a powerful technique called <em>differential power analysis (DPA)</em>, we can learn about the data being processed by a device, even if the program flow is exactly the same.</p>
<p>In the previous chapter, you learned that simple power analysis uses a device’s power signature to broadly determine the operation it’s performing. Those operations could be the loops in a PIN verification or the modular operations in an RSA calculation. In SPA, we can treat each trace by itself. For instance, in an SPA attack on RSA, we may use the order of the modular operations to retrieve a key. In DPA, we analyze the <em>differences</em> <span epub:type="pagebreak" title="294" id="Page_294"/>between sets of traces. We use statistics to analyze small variations in our traces, which may allow us to determine what data the device is processing all the way down to individual bits.</p>
<p>Since individual bits affect only a handful of transistors, you can imagine that the effect on the power consumption is tiny. In fact, you generally can’t measure a single bit in a power trace (unless it causes large operational differences, such as in the textbook implementation of RSA). What we can do, though, is capture many thousands, millions, billions of power traces and use the power of statistics (pun intended) to detect a small bias in current caused by a bit. The goal of a DPA attack is to use power measurements to determine some secret and constant state—typically a cryptographic key—of an algorithm that’s processing data on the target device.</p>
<p>This incredibly powerful technique was first published in 1998 by Paul Kocher, Joshua Jaffe, and Benjamin Jun in the aptly named paper “Differential Power Analysis.” DPA is a specific side-channel power analysis algorithm, but the term is used generically to describe all related algorithms in the field. We’ll use it as a generic term here as well, unless otherwise specified.</p>
<p>Before you can perform a DPA attack, you need to be able to communicate with the target and cause it to perform the desired cryptographic operation. You’ll collect measurements on the target and record its power consumption. You’ll then process the measurements and perform the attack with the hope of recovering the encryption key. Although this attack sounds similar to the SPA attack described in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, the processing step differs substantially.</p>
<p>But before we delve into what processing is implemented in a DPA attack, you’ll need to understand what specific effect we are exploiting. We’ll start by looking at a humble microcontroller; these programmable digital devices are almost guaranteed to be in any hackable product.</p>
<h2 id="h1-278748c10-0001">Inside the Microcontroller</h2>
<p class="BodyFirst">If you were to look deep inside your microcontroller, you would see all the conducting lines bringing signals from one side of the chip to the other, as shown in <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a>. Various data lines flow from one section of the chip to another. An 8-bit microcontroller typically has one 8-bit-wide main <em>data bus</em>.</p>
<p>These lines transport data, and some of that data will be our target. All these lines eventually run into one of the building blocks of digital circuits, namely <em>transistors</em>. These are <em>field effect transistors (FETs)</em>, but all we care about is that they are basically a switch; they have one input that turns the output on or off. To toggle the FETs at the end of the data bus lines, we must move that data bus line high or low. The input to the FET along with all the lines in between can be thought of as a very small capacitor, and moving that line high or low really means changing the voltage across that capacitor, which means data values directly affect charges on internal capacitances.</p>
<span epub:type="pagebreak" title="295" id="Page_295"/><figure>
<img src="image_fi/278748c10/f10001.png" alt="f10001"/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: Data lines in a chip</p></figcaption>
</figure>
<h3 id="h2-278748c10-0001">Changing the Voltage on a Capacitor</h3>
<p class="BodyFirst">All kinds of capacitances in and around the microcontroller affect the power consumption. For the sake of the following discussion, we’ll refer to all these capacitances as a single capacitor. If you were paying attention in high-school physics, you may remember that to increase the voltage across a capacitor, you need to apply a <em>charge</em>, which has to come from somewhere—most usually through power lines. A digital integrated circuit (IC) will have both VCC (positive) and GND (ground) power lines. If you were to monitor the power consumption, you would see current spikes in the VCC line when switching from low to high. This comes about from the fundamental equations around changing the voltage on a capacitor, which can be stated as “the current through a capacitor is related to capacitance <em>C</em> and the rate of change of voltage,” as shown here:</p>
<figure class="graphic">
<img src="image_fi/278748c10/e10001.png" alt="e10001"/></figure>

<p class="BodyContinued">If we have a changing voltage on the capacitor (such as what happens when switching from a low to high state), we have a current flowing in the circuit that capacitor is part of. If the voltage is changing on a low-to-high <span epub:type="pagebreak" title="296" id="Page_296"/>transition, we should see a current flow of one direction. If the voltage changes on a high-to-low transition, we should see this current flow reversed. Observing the magnitude and direction of the current flow allows us to infer something about the voltage changes over the “capacitor,” and thus over the entire circuit (including the transitions occurring on internal bus states of the microcontroller).</p>
<p>To illustrate this, let’s assume we have a microcontroller that allows us to monitor the current consumption and the state of the internal data bus. If we change two data lines while monitoring the current going into the device, we expect the results of this measurement to look something like <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a>. When data on the bus changes, the data lines all change state simultaneously relative to a system clock at well-defined points in time. At these moments we see current spikes resulting from the toggling data lines. Toggling data lines means charging and discharging a capacitor, which requires a current flow.</p>
<figure>
<img src="image_fi/278748c10/f10002.png" alt="f10002"/>
<figcaption><p><a id="figure10-2">Figure 10-2</a>: Monitoring current spikes when toggling data lines, showing current flowing in for both 0→1 and 1→0 transitions</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="297" id="Page_297"/>Most real-life microcontroller buses go into a <em>pre-charge</em> state, which is halfway between a logic one and a logic zero. A logical state switch takes time, and the time depends on the voltage differential to put on the bus (that is, the voltage difference between the one state and zero state). Via pre-charging, this voltage differential is constant and only half the distance of a full zero-to-one switch, no matter whether there is a zero or a one on the bus. This results in bus operations taking less time to reach the final state and the whole operation being more dependable.</p>
<h3 id="h2-278748c10-0002">From Power to Data and Back</h3>
<p class="BodyFirst">Most measurements we’ll be discussing in this book aim to capture the current of the device under test. The power is related to current with <em>P</em> = <em>I</em> × <em>V</em>; see <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> for details. If the device has a constant operating voltage, the power and current have a linear relationship. For the work that follows, we don’t need specific units on these measurements, and a linear (or even nonlinear) scaling factor makes little difference in application of the results.</p>
<p>For this reason, the terms <em>current</em> and <em>power</em> are used interchangeably in the following discussion and for the remainder of this book. The common nomenclature for these attacks is one of <em>power analysis</em>, so you’ll see reference to attackers measuring the power of the device or having power traces. In most cases that’s not accurate because the current of the device in the circuit is being measured with tools such as current probes. (To confuse you even further, those currents are measured by an oscilloscope in volts. If you are especially pedantic about the difference between power and current, be warned that you may find existing in the field of power analysis to be entirely impossible.)</p>
<p>As attackers, we can use the aforementioned pre-charge state to directly determine the number of ones in the number being manipulated. This number is referred to as the <em>Hamming weight (HW)</em>. The Hamming weight of 0xA4 is 3 because 0xA4 is 10010100 in binary and in it are three ones. With a simple pre-charged 2-bit bus, our power consumption trace would look like <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a>.</p>
<p>As a result of pre-charging, the power spike depends only on the number of ones in the current value being sent over the bus. Note that we’re considering only the VCC rail current consumption, which is why there are no negative spikes when lines change to a low state. This behavior more closely matches what you would see in real systems, since you are observing power from only one rail.</p>
<span epub:type="pagebreak" title="298" id="Page_298"/><figure>
<img src="image_fi/278748c10/f10003.png" alt="f10003"/>
<figcaption><p><a id="figure10-3">Figure 10-3</a>: Hamming weights on a 2-bit data line</p></figcaption>
</figure>
<p>In real life, microcontrollers do typically leak the Hamming weight of processed data. We can confirm this by averaging the power consumption at a moment in time when we know what data is being processed on the bus over many measurements. <a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a> shows an example for an STM32F303 microcontroller.</p>
<figure>
<img src="image_fi/278748c10/f10004.png" alt="f10004"/>
<figcaption><p><a id="figure10-4">Figure 10-4</a>: Increased power consumption of an STM32F303 microcontroller leads to a decreased voltage measurement.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="299" id="Page_299"/>You might be surprised by just how perfectly linear this fit is, but our real-life measurements on microcontrollers often actually do result in matching this model. We measure the voltage drop over a series resistor in the VCC line, so an increased power consumption (increased Hamming weight) results in a larger drop in voltage.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The word <em>Hamming</em> refers to Richard Hamming, a sensible man who lived by maxims like “If the prediction that an airplane can stay up depends on the difference between Riemann and Lebesgue Integration, I don’t want to fly in it.” He also developed the idea of the Hamming distance in a paper from 1950 titled “Error Detecting and Error Correcting Codes.” The paper’s core purpose was to introduce the Hamming code, effectively creating the idea of error-correcting codes. The ideas from this paper are used in everything from hard-drive disks to high-speed wireless communications.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-278748c10-0002">Sexy XORy Example</h2>
<p class="BodyFirst">Now that we can use averaged power consumption to determine the sum of the number of bits that are set to one in a digital device, let’s see how we could crack a simple device. Consider a basic circuit that XORs each byte of input with some unknown but constant 8-bit secret key. It then shoots that data through a lookup table with known values that replace every byte with another value, just like a substitution cipher, where the original input byte is replaced by a corresponding output byte in a lookup table, ending up with an “encrypted” result.</p>
<p>We don’t have access to the output on this device; all we can do is send it data that it XORs and sends through the lookup table. We <em>can</em>, however, measure the power of this device, as shown in <a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>, by inserting a shunt resistor in the VCC line of the device under test.</p>
<figure>
<img src="image_fi/278748c10/f10005.png" alt="f10005"/>
<figcaption><p><a id="figure10-5">Figure 10-5</a>: This simple device will be cracked using a DPA attack.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="300" id="Page_300"/>Now we send a bunch of random 8-bit input data bytes to the device and record each byte along with the power trace. We end up with a list of data sent to the device, along with the associated power trace measured during that operation, as shown in <a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a>.</p>
<figure>
<img src="image_fi/278748c10/f10006.png" alt="f10006"/>
<figcaption><p><a id="figure10-6">Figure 10-6</a>: Input data vs. associated power trace</p></figcaption>
</figure>
<p>This is all we need to start a DPA attack, where we’ll attempt to recover the secret key.</p>
<h2 id="h1-278748c10-0003">Differential Power Analysis Attack</h2>
<p class="BodyFirst">For the DPA attack on this XOR example from <a href="#figure10-5">Figure 10-5</a>, we target a single bit of the secret key at a time. We’ll describe how to break the least significant bit (LSB), but you can extend that to all 8 bits with a touch of creativity.</p>
<p>Fundamental to these attacks is <em>key enumeration</em>, which is a fancy way of saying we take informed guesses at the key. We try every possible key value, predict what the power consumption would be if the device used that key value, and match our predictions against the actual power traces. The best match is our <em>key candidate</em>.</p>
<p>You are quite right at this point to think, “Why do I need power analysis instead of simply brute-forcing an 8-bit key?” For a brute-force attack, you need to input a key and get some feedback from the system on whether the key is correct. The problem here is that we assume the output is not available, so you could never test whether the guessed key was correct.</p>
<p>With DPA, we are going to be getting some “hints” on whether a guessed key is correct. We don’t actually learn whether the key decrypts the data. The best test of a guessed key would be to attempt to decrypt some data and <span epub:type="pagebreak" title="301" id="Page_301"/>see whether it results in valid output; if it does, we fundamentally know the key is correct. With a DPA attack, we technically just gain confidence in a <em>key hypothesis</em> or<em> key guess</em>. If this confidence is very high, we can deduce that the actual key is equal to our key hypothesis without needing to perform a test decryption. More crucially, we’ll later extend this example to larger keys that you can’t brute-force. For example, applying DPA to a 128-bit key is 128 times more work than applying it to a single bit, as we can perform attacks on key bits independently of the other key bits. Compare this to brute-forcing, where guessing a single-bit key requires at maximum two tries, but guessing all 128 bits requires at maximum 2<sup>128</sup> tries. That’s a big number. It’s about the number of ants in the universe if each star in the universe had a billion queen ants, and each queen ant had a colony of a billion. This means with DPA, it’s feasible to break a 128-bit key, whereas with brute-forcing, it is not.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You may have heard of quantum computing and its ability to break cryptographic algorithms. The worst affected are RSA- and ECC-based systems, which are “trivially” broken using <em>quantum attacks</em>. However, even if we consider quantum computers, symmetric algorithms such as AES remain mostly secure. Currently, the best known quantum attacks for symmetric algorithms only halve the effective number of bits of the algorithm. This means breaking AES-128’s 128-bit key is as hard on a quantum computer as breaking a 64-bit key is on a classical computer, and AES-256 under quantum attacks is as strong as brute-forcing 128 bits. Brute-forcing a 64-bit key is barely plausible for a nation-state, and brute-forcing a 128-bit key is effectively impossible. But by comparison, a DPA attack on AES-256 is only about twice as hard as a DPA attack on AES-128.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-278748c10-0003">Predicting Power Consumption Using a Leakage Assumption</h3>
<p class="BodyFirst">To predict the device’s power consumption, we’ll use a <em>leakage assumption</em> in combination with our knowledge of the system. We assume that the system leaks the Hamming weight of all values processed, but we have a problem. We are able to measure only the total power consumption, and thus the total Hamming weight of all the data that is being processed, instead of the Hamming weight of only the secret value in which we are interested. Further, even if we can isolate the secret value, many different 8-bit values will have the same Hamming weight. Since this chapter has many more pages, you have guessed correctly that a solution to this difficulty exists.</p>
<p>Say we have an array of power traces called <code>t[]</code> and an array called <code>p[]</code> of associated input data. For example, the top entry from <a href="#figure10-6">Figure 10-6</a> would have <code>p[0] = 0xAC</code>. The power trace <code>t[0]</code> is an array of sample values, shown as the top trace. We can apply the DPA algorithm to generate a list of differences for each key guess. The simple function presented in <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a> simulates the power consumption of a simple target device and guesses a single bit by means of a DPA attack.</p>
<pre><code><span epub:type="pagebreak" title="302" id="Page_302"/>diffarray = []
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> each key guess i of the secret key in range {0x00, 0x01, ..., 0xFE, 0xFF}:
    zerosarray = new array
    onesarray = new array
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for each trace d in range {0,1, ..., D-1}:
        <span class="CodeAnnotationHang" aria-label="annotation3">3</span> calculate hypothetical output h = lookup_table[i XOR p[d]]

        <span class="CodeAnnotationHang" aria-label="annotation4">4</span> if the LSB of h == 0:
            <span class="CodeAnnotationHang" aria-label="annotation5">5</span> Append t[d] to zerosarray[]
        else:
            <span class="CodeAnnotationHang" aria-label="annotation6">6</span> Append t[d] to onesarray[]

    <span class="CodeAnnotationHang" aria-label="annotation7">7</span> difference = mean(onesarray) – mean(zerosarray)
    append difference to diffarray[]</code></pre>
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: Simulated power consumption and guess of a single bit using a DPA attack</p>
<p>We first enumerate over all possibilities for the byte being guessed <span class="CodeAnnotation" aria-label="annotation1">1</span>. For each possible guess of the key byte, we loop over all recorded power traces <span class="CodeAnnotation" aria-label="annotation2">2</span>. Using the input data associated with the trace <code>p[d]</code> and guess <code>i</code> of the secret key, we can generate a <em>hypothetical</em> output <code>h</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> that’s only equal to what the microcontroller would have computed if we had guessed the key correctly.</p>
<p>Finally, we look at the target bit (the LSB) in the hypothetical output <span class="CodeAnnotation" aria-label="annotation4">4</span>. Based on the key guess, we add each recorded power trace <code>t[d]</code> into one of two groups: ones where we <em>think</em> the LSB was a one <span class="CodeAnnotation" aria-label="annotation5">5</span>, and ones where we <em>think</em> the LSB was a zero <span class="CodeAnnotation" aria-label="annotation6">6</span>.</p>
<p>Now consider the nature of this guess. If the guess is <em>incorrect</em>, what we think went into the lookup table isn’t what actually went in there on the device, and, consequently, what we think came out of the lookup table also isn’t what actually came out. Grouping by the incorrect LSB means that we basically split all power traces randomly into two groups. In that case, you would expect the mean power consumption of each group to be about the same. Thus, if you subtract the means from each other, you should get nothing but perhaps some noise. <a href="#figure10-7" id="figureanchor10-7">Figure 10-7</a> shows some examples of the two groups and the resulting subtraction.</p>
<p>If our guess is <em>correct</em>, what we think is computed is in reality the same as the data that was computed on the device. Therefore, we’ve moved all power traces where the LSB is actually set to 1 into one group and all traces where the LSB is actually set to 0 into the other group. If those ones and zeros consume a slightly different amount of power, that difference should become evident if we average large enough groups of traces. We would expect to see a small difference between the one and zero groups when this bit is manipulated, as shown in <a href="#figure10-8" id="figureanchor10-8">Figure 10-8</a>.</p>
<span epub:type="pagebreak" title="303" id="Page_303"/><figure>
<img src="image_fi/278748c10/f10007.png" alt="f10007"/>
<figcaption><p><a id="figure10-7">Figure 10-7</a>: Averaging many traces into ones and zeros for an incorrect guess (0xAB) with no specific peak visible</p></figcaption>
</figure>
<span epub:type="pagebreak" title="304" id="Page_304"/><figure>
<img src="image_fi/278748c10/f10008.png" alt="f10008"/>
<figcaption><p><a id="figure10-8">Figure 10-8</a>: Averaging many traces into ones and zeros for a correct guess (0x97) where a peak is clearly visible</p></figcaption>
</figure>
<p>This difference (<span class="CodeAnnotation" aria-label="annotation7">7</span> in <a href="#listing10-1">Listing 10-1</a>) gives us the <em>differential</em> part of differential power analysis. The power of this analysis is that separating the traces from the table shown in <a href="#figure10-6">Figure 10-6</a> into two groups allows us to average many traces to reduce noise, while not averaging out the contribution of the bit of interest. We can see the final blip at sample 35 in <a href="#figure10-8">Figure 10-8</a>, which demonstrates that we can see the small contribution of our LSB. Taking the difference between these two averaged groups will be called taking the <em>difference of means (DoM)</em>.</p>
<p><span epub:type="pagebreak" title="305" id="Page_305"/>But wouldn’t such a tiny blip of power consumption be lost in the noise of so many other lines being switched in real-life chips? Well, all of that other noise is effectively uniformly distributed over the two groups. The only difference that remains statistically significant between the groups is the LSB, the single bit that we’ve chosen to split our groups on. When we average a sufficient number of such traces, the contributions of any other flipping bits cancel out.</p>
<h3 id="h2-278748c10-0004">A DPA Attack in Python</h3>
<p class="BodyFirst">As proof of concept, the companion Jupyter notebook for this chapter (<a href="https://nostarch.com/hardwarehacking/" class="LinkURL">https://nostarch.com/hardwarehacking/</a>) implements a DPA attack on our example in Python. The <code>measure_power()</code> function, partially shown in <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a>, performs an XOR of the input data using a secret byte and passes it through a lookup table.</p>
<pre><code>def measure_power(din):
    #secret byte
    skey = 0b10010111 # 0x97

    #Calculate result
    res = lookup[din ^ skey]</code></pre>
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: Lookup table that XORs the input with some secret key</p>
<p>In the following examples, the lookup table is randomly generated (that is, the <code>lookup</code> array from <a href="#listing10-2">Listing 10-2</a>). The lookup table should at least be a bijection, and if we were implementing a real encryption algorithm, there would be more considerations. However, for the purpose of this demonstration, a randomly permuted sequence will work as well. Using such a lookup table will demonstrate that there is no fundamental “problem” with AES or another algorithm that makes the attack possible.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The function and variables names mentioned in this text refer to Python code as part of the companion Jupyter notebook. You should be able to follow along without it, but you’ll be able to run the example interactively with the notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Rather than simply performing the “encryption function,” we’ll simulate the power consumption of a piece of hardware running this function, which will make it easier to follow on a computer. You’ll see later how to perform the measurements on a real piece of hardware.</p>
<h4 id="h3-278748c10-0001">Simulating a Single Power Measurement</h4>
<p class="BodyFirst">To simulate a single power measurement, we’ll generate an array with random background noise to reflect the reality of noisy measurements and systems in the <code>measure_power()</code> function. We’ll then insert a power spike based on the number of ones in the intermediate value. This simulates the power consumption measurements of the system shown in <a href="#figure10-5">Figure 10-5</a>.</p>
<h4 id="h3-278748c10-0002"><span epub:type="pagebreak" title="306" id="Page_306"/>The Batch Measurement</h4>
<p class="BodyFirst">Next, we perform the batch measurement. The <code>gen_traces()</code> function calls the <code>measure_power()</code> function with a number of random inputs while recording the resulting power trace. You can specify how many measurements to perform. (We’ll look at the effect of this on the attack success rate later.)</p>
<p><a href="#figure10-9" id="figureanchor10-9">Figure 10-9</a> shows a single trace we “measured,” as plotted from Python.</p>
<figure>
<img src="image_fi/278748c10/f10009.png" alt="f10009"/>
<figcaption><p><a id="figure10-9">Figure 10-9</a>: Example of a single trace generated (input = 0xAC)</p></figcaption>
</figure>
<h4 id="h3-278748c10-0003">Enumerating the Possibilities and Splitting the Traces</h4>
<p class="BodyFirst">At this point, we have the measurement and input data arrays mentioned earlier in the “Predicting Power Consumption Using a Leakage Assumption” section. All we need to do now is to enumerate the key guesses and split the recorded power traces into two groups based on the hypothetical intermediate value.</p>
<p>In the <code>dom()</code> function, we guess the intermediate value with <code>lookup[guess ^ p]</code> and then check the value to see whether a specific bit is set with the <code>(XX &gt;&gt; bitnum) &amp; 1</code> expression. Based on the value of that bit, the traces are partitioned into two groups. In our example, before we were using the LSB, this would correspond to <code>bitnum</code> being set to 0.</p>
<h4 id="h3-278748c10-0004">The Difference Array</h4>
<p class="BodyFirst">Finally, we subtract the mean of each group to get the difference array. What does this difference look like? If the split was done correctly, we’d expect a large spike at some point. Look back at the difference of means in Figures 10-7 and 10-8. You should see the obvious positive spike when the separation of traces is done correctly, and thus we know our key guess is correct.</p>
<p><span epub:type="pagebreak" title="307" id="Page_307"/>The graph in <a href="#figure10-8">Figure 10-8</a> is the result of a correct guess, where we have partitioned the traces based on the assumption that the secret key byte was 0x97. The graph in <a href="#figure10-7">Figure 10-7</a> shows an incorrect key guess, where we have partitioned the traces based on the assumption that the secret key byte is 0xAB.</p>
<p>As we separate the traces, even in very high noise environments, eventually everything that is not the DPA signal will average away, as you can see by comparing the left and right differences of means in <a href="#figure10-10" id="figureanchor10-10">Figure 10-10</a>.</p>
<figure>
<img src="image_fi/278748c10/f10010.png" alt="f10010"/>
<figcaption><p><a id="figure10-10">Figure 10-10</a>: Difference of means on 1,000 (left) vs. 100,000 (right) traces to reduce noise</p></figcaption>
</figure>
<p><a href="#figure10-10">Figure 10-10</a> shows 100,000 traces used on the right as opposed to 1,000 traces on the left. The result is that the random noise is further suppressed, and the signal becomes even more pronounced.</p>
<h4 id="h3-278748c10-0005">A Complete Attack</h4>
<p class="BodyFirst">Next, we determine the most likely value of the encryption key from each bit by calculating the difference of means for each guess for a particular bit. From all those differences, we find the strongest peak, which indicates what the best guess at the key is for that bit. Running the code produces this output:</p>
<pre><code>Best guess from bit 0: 0x97
Best guess from bit 1: 0x97
Best guess from bit 2: 0x97
Best guess from bit 3: 0x97
Best guess from bit 4: 0x97
Best guess from bit 5: 0x97
Best guess from bit 6: 0x97
Best guess from bit 7: 0x97</code></pre>
<p><span epub:type="pagebreak" title="308" id="Page_308"/>We’ve determined the correct value of the encryption key for each bit. While DPA deals with single bits at a time, the use of that funny lookup table in our sample encryption function meant we were able to break the entire eight bits of the encryption key by guessing only a single bit. This method worked because a single bit of the output of the lookup table may be related to all bits of the input to the table. This input is the 8-bit unknown key combined with the 8-bit known algorithm input data.</p>
<p>Using the lookup table ensures that if our guess of the key value is wrong, the partitioning of traces into one and zero categories would basically be random. Specifically, the lookup table is most likely nonlinear because we randomized it.</p>
<p>Had we been attacking just a simple input XOR key without the lookup table, each key bit would be related only to one bit of the intermediate state, which means we would have been able to determine only one bit of the key per bit of intermediate state.</p>
<h2 id="h1-278748c10-0004">Know Thy Enemy: An Advanced Encryption Standard Crash Course</h2>
<p class="BodyFirst">Breaking our made-up algorithm that works on a single byte isn’t too exciting, so now we’re going to apply DPA to the advanced encryption standard (AES). AES always operates in 16-byte blocks, which means that you must encrypt 16 bytes at a time. AES has three possibilities for key length: 128-bit (16 bytes), 192-bit (24 bytes), or 256-bit (32 bytes). Longer keys typically mean stronger encryption, as any sort of brute-force attack takes exponentially longer to crack for longer keys.</p>
<p>We primarily deal with AES-128 here (although you also can easily apply side-channel attacks to AES-192 or AES-256) using <em>Electronic Code Book (ECB)</em> mode. In ECB mode, a block of 16 bytes of unencrypted <em>plaintext</em> run through AES-128-ECB with the same secret key always maps to the same encrypted <em>ciphertext</em>. Most real-world encryption does not directly use ECB mode but instead uses various <em>modes of operation</em>, such as <em>cipher block chaining (CBC)</em> and <em>Galois Counter Mode (GCM)</em>. A straightforward DPA on AES would apply directly to AES in ECB mode. And once you know how to deal with AES in ECB mode, you can also extend it to attacks on AES CBC and AES GCM.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	AES was specified by the US National Institute of Standards and Technology in 2001. You’ll see references to AES as the <em>Rijndael cipher</em> because the standard was actually the result of a competition, and Rijndael was one of the entries. Rijndael was created by the Belgian cryptographers Joan Daemen and Vincent Rijmen, so next time you are enjoying a Belgian beer, be sure to dedicate a toast to them. For more detail on the AES-128 algorithm, see <em>Serious Cryptography</em> (No Starch Press, 2018), by Jean-Philippe Aumasson, or <em>Understanding Cryptography</em> (Springer, 2010), by Christof Paar and Jan Pelzl, and its companion website.<sup>.</sup></p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><a href="#figure10-11" id="figureanchor10-11">Figure 10-11</a> shows the general structure of the start of AES-128. (We’ll limit our discussion to the beginning rounds of the algorithm, as our attacks take place within that section.)</p>
<span epub:type="pagebreak" title="309" id="Page_309"/><figure>
<img src="image_fi/278748c10/f10011.png" alt="f10011"/>
<figcaption><p><a id="figure10-11">Figure 10-11</a>: The complete first round and start of the second of the AES algorithm</p></figcaption>
</figure>
<p>In <a href="#figure10-11">Figure 10-11</a>, the 16-byte secret key is given as R<sub>0</sub>K<sub><em>k</em></sub> <span class="CodeAnnotation" aria-label="annotation1">1</span>, where <em>k</em> is the key byte number. The first subscript indicates to which round this key applies; AES uses a different 16-byte round key for each round. The input plaintext is entered <span class="CodeAnnotation" aria-label="annotation2">2</span>, again with a subscript indicating the byte number. Each byte of the round key is XOR’d with each byte of the plaintext <span class="CodeAnnotation" aria-label="annotation3">3</span> in an operation referred to as <code>AddRoundKey</code>. Note that for AES-128, the first round key is the same as the AES key; all other round keys are derived from the AES key through the key-scheduling algorithm. For DPA on AES-128, we need to extract only one round key from which we can derive the AES key.</p>
<p>Once the round key and plaintext have been XOR’d together in the <code>AddRoundKey</code> operation, each byte is passed through a <em>substitution-box</em> <em>(S-box)</em> <span class="CodeAnnotation" aria-label="annotation4">4</span>, in an operation referred to as <code>SubBytes</code>. The S-box is an 8-bit lookup table with a one-to-one mapping (that is, every input maps to a unique output). This also means it is invertible; given the output of the S-box, you can determine the input. The S-box is designed to have a number of preferred properties that can discourage linear and differential cryptanalysis. (The exact definition of these lookup tables is irrelevant; we just want to note the S-box is more than just any old lookup table.)</p>
<p>The next two layers further distribute the input across multiple output bits. The first layer is a function called <code>ShiftRows</code>, which shuffles the bytes <span class="CodeAnnotation" aria-label="annotation5">5</span>. Next, the <code>MixColumns</code> operation <span class="CodeAnnotation" aria-label="annotation6">6</span> combines 4 bytes of input to create 4 bytes of output, which implies that if a single byte changes at the input to <code>MixColumns</code>, all 4 bytes of output will be affected.</p>
<p><span epub:type="pagebreak" title="310" id="Page_310"/>The output of <code>MixColumns</code> becomes the input to the next round <span class="CodeAnnotation" aria-label="annotation7">7</span>. This round has a round key <span class="CodeAnnotation" aria-label="annotation8">8</span>, which will be XOR’d with the input round text <span class="CodeAnnotation" aria-label="annotation7">7</span> yet again using the <code>AddRoundKey</code> operation. The previous operations (<code>SubBytes</code>, <code>ShiftRows</code>, and <code>MixColumns</code>) then repeat. The consequence is that if we flip a single bit at the start of the AES, by the end of the 10 rounds, we should (on average) see half the output bits flip.</p>
<p>All rounds but the last will have exactly the same operations; only the data going into the round and the round key will differ. The last round will have another <code>AddRoundKey</code> instead of a <code>MixColumns</code> operation. However, we’ll need to attack only the first round with DPA to extract a full key, so we’re not too concerned about that last round!</p>
<h3 id="h2-278748c10-0005">Attacking AES-128 Using DPA</h3>
<p class="BodyFirst">To break an AES-128 implementation with DPA, we first need to simulate an AES-128 implementation. The XOR example we’ve been using is basically the first two steps of AES: a key addition (XOR) and an S-box lookup.</p>
<p>To build a real DPA attack on AES, we will modify the sample code from the companion Jupyter notebook (if you haven’t done so already, now is a good time to get it working). We simply need to change our randomized lookup table to be the proper AES S-box. In this case, we’re attacking the <em>output</em> of the S-box. The nonlinear effect of the S-box will make it easier to extract the complete encryption key.</p>
<p>If you run the sample code, it should produce the output in <a href="#figure10-12" id="figureanchor10-12">Figure 10-12</a>, which shows a trace for each of the three values of the <code>guess</code> variable: 0x96, 0x97, and 0x98. These are the difference traces for three out of 256 values of the <code>guess</code> variable. When the <code>guess</code> variable matches the correct value of the key byte, you can see a large spike.</p>
<figure>
<img src="image_fi/278748c10/f10012.png" alt="f10012"/>
<figcaption><p><a id="figure10-12">Figure 10-12</a>: Output from a DPA attack on a single byte of the AES-128 encryption algorithm with key 0x97</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="311" id="Page_311"/>Although we are attacking only a single byte of the AES-128 encryption, we can repeat the attack for each byte of input to determine the entire 16-byte key. Remember how we fared guessing only over 8 bits? We didn’t make any special assumptions on which of the 8 bits of the key we broke. Therefore, we can do the same attack on any of the key bytes.</p>
<p>We now claim we can break all AES key bytes by attacking 16 times and only guessing 8 bits for each attack! This is computationally entirely feasible, whereas doing a brute-force attack of 2<sup>128</sup> is out of the question. The fundamental strength of DPA is that instead of brute-forcing the entire keyspace, we separate the cryptographic algorithm into subkeys and then brute-force those subkeys using additional information from power traces to validate subkey guesses. In this way, we have transformed the breaking of AES-128 implementations from the impossible to an achievable reality.</p>
<h2 id="h1-278748c10-0005">Correlation Power Analysis Attack</h2>
<p class="BodyFirst">The DPA attack assumes that for a particular device, you’ll get a difference in power consumption when a bit is a 1 or a 0. As we explained, we can use any one of the 8 bits extracted from the lookup table to predict the key. This redundancy is something we can actually use to strengthen our attack. A straightforward way would be to use each bit as a separate “vote” into what subkey is the likely candidate, but we can be smarter. We can use a more advanced attack called a <em>correlation power analysis (CPA</em><em>)</em>, which will simultaneously model any number of bits and can, therefore, yield a stronger attack. In DPA/CPA terms, this means we need fewer traces to recover the key. CPA was introduced by Eric Brier, Christophe Clavier, and Francis Olivier in the CHES 2004 paper “Correlation Power Analysis with a Leakage Model.” We’ll present the mathematical notation along with the Python implementation so you can match the theory to real-world code. Until you actually implement the attack, the details will escape you (trust us), so grab a pen and paper and let’s dig in.</p>
<p>In DPA, we’re basically saying, “if some intermediate bit varies, the power consumption varies with it.” Although that’s true, it doesn’t capture the full extent of the relationship between data and power consumption. Refer to <a href="#figure10-4">Figure 10-4</a>. The higher the Hamming weight of a word (that is, the more bits set), the higher the power consumption. It’s close to a perfect linear relationship. This relation seems to hold for any type of CMOS, so it applies quite nicely to microcontrollers. Now, how do we exploit this linearity?</p>
<p>The basic idea in DPA is to make key guesses and predict what one bit in an intermediate value would be. In CPA, we make the same key guesses but predict the entire word of an intermediate value. In our AES example, we predict the 8-bit output of the S-box:</p>
<pre><code>sbox[guess ^ input_data[d]]</code></pre>
<p><span epub:type="pagebreak" title="312" id="Page_312"/>Now, here comes the magic: after prediction, we calculate the Hamming weight of this predicted value. We know it’s very nearly linearly related to the actual power consumption. So, if our guess is correct, we should be able to find a linear relationship between the Hamming weight of the S-box outputs and the actual measured power consumption of a device. If our guess is incorrect, we won’t see a linear relationship because the Hamming weight we calculated for the predicted value was actually the Hamming weight for some other as-yet-unknown value, not for the value we predicted. What will be very useful to us is to find the <code>guess</code> that gives this linear relationship. How to exploit this linear relationship will become apparent as we turn our attention to a certain Mr. Pearson.</p>
<h3 id="h2-278748c10-0006">Correlation Coefficient</h3>
<p class="BodyFirst">The <em>sample Pearson’s correlation coefficient</em> <em>r</em> does what we are looking for. It measures the linear relationship between samples of two random variables—in our case, the measured power traces and the Hamming weight of the S-box output for a certain key <code>guess</code>. By definition, the Pearson correlation coefficient is +1 if these are perfectly linearly related; that is, the greater the power consumption, the higher the Hamming weight. If the correlation coefficient is –1, they are perfectly negatively correlated; that is, a higher Hamming weight correlates to a lesser power consumption.</p>
<p>A negative correlation can happen in practice for various reasons, so we are typically interested in the absolute value of the correlation coefficient. If the correlation is 0, there is no linear relation whatsoever, and for our practical purposes, it means that for a certain key <code>guess</code>, the measured traces don’t correspond significantly at all to the Hamming weight of the S-box. By this observation, we can test how good a guess is and compare different guesses simply by looking at the absolute value of the Pearson correlation. The guess with the highest absolute correlation wins and is therefore likely the actual key!</p>
<h4 id="h3-278748c10-0006">First Some Nomenclature</h4>
<p class="BodyFirst">We’re about to introduce a bunch of variables in equations that map to Python expressions in the notebook. For your convenience, we give the mapping in <a href="#table10-1" id="tableanchor10-1">Table 10-1</a>.</p>
<p>Converting from equation to Python is an important part of the following process, along with many of the attacks you’ll read about in the future. Creating simple mapping tables like <a href="#table10-1">Table 10-1</a> can make your life a lot easier. If you have the companion code up and running, keep this page open to convert between equation and code quickly.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-1">Table 10-1</a>: Mapping Correlation Equation Variables to Notebook </p></figcaption>
<table id="table-278748c10-0001" border="1">
<thead>
<tr>
<td><b>Equation variable</b></td>
<td><b>Notebook</b></td>
<td><b>Meaning</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><em>d</em></td>
<td><code>tnum</code></td>
<td>Trace index [<em>0..D</em> – <em>1</em>]</td>
</tr>
<tr>
<td><em>D</em></td>
<td><code>number_traces</code></td>
<td>Total number of traces</td>
</tr>
<tr>
<td><em><span epub:type="pagebreak" title="313" id="Page_313"/>i</em></td>
<td><code>guess</code></td>
<td>Guess that a subkey has value <em>i</em><em> </em>[<em>0</em>..<em>I</em> – <em>1</em>]</td>
</tr>
<tr>
<td><em>I</em></td>
<td><code>256</code></td>
<td>Total number of possible subkey guesses</td>
</tr>
<tr>
<td><em>j</em></td>
<td>N/A (thanks, NumPy!)</td>
<td>Sample index [<em>0</em>..<em>T</em> – <em>1</em>]</td>
</tr>
<tr>
<td>h<sub><em>d,i</em></sub></td>
<td><code>hyp, intermediate()</code></td>
<td>Hypothetical power consumption for trace <em>d </em>and subkey guess <em>i</em></td>
</tr>
<tr>
<td><em>p</em><sub><em>d</em></sub></td>
<td><code>input_data[d]</code></td>
<td>Plaintext value for trace <em>d</em></td>
</tr>
<tr>
<td><em>r</em><sub><em>i,j</em></sub></td>
<td><code>cpaoutput</code></td>
<td>Correlation coefficient for subkey guess <em>i</em> at sample index <em>j</em></td>
</tr>
<tr>
<td><em>t</em><sub><em>d,j</em></sub></td>
<td><code>traces[d][j]</code></td>
<td>Sample value for trace <em>d</em> at sample index <em>j</em></td>
</tr>
<tr>
<td><em>T</em></td>
<td><code>numpoint</code></td>
<td>The number of samples in each trace</td>
</tr>
</tbody>
</table>
</figure>
<h4 id="h3-278748c10-0007">Calculating the Data to Correlate</h4>
<p class="BodyFirst">To calculate the correlation coefficient, we’ll need a table of actual power measurements from a device (see <a href="#table10-2" id="tableanchor10-2">Table 10-2</a>) and a column of hypothetical power measurements (see <a href="#table10-3" id="tableanchor10-3">Table 10-3</a>). Let’s first look at <a href="#table10-2">Table 10-2</a>, the power measurement, which is generated using the code in the companion notebook.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-2">Table 10-2</a>: Power Measurements of <em>D</em> Traces (Rows), with Plaintext <em>p</em><sub><em>d</em></sub> and <em>T</em> Samples at Various Time Indices <em>j</em> (Columns)</p></figcaption>
<table id="table-278748c10-0002" border="1"><thead>
<tr>
<td/>
<td><b>Plaintext <em>p</em><sub><em>d</em></sub></b></td>
<td><b>Measured <b><i>j</i></b> = 0</b></td>
<td><b>Measured <b><i>j</i></b> = 1</b></td>
<td><b>Measured <b><i>j</i></b> = <em>T</em> – 1</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><b>Trace <em>d</em> = 0</b></td>
<td>0xA1</td>
<td>151.24</td>
<td>153.56</td>
<td>152.11</td>
</tr>
<tr>
<td><b>Trace <em>d</em> = 1</b></td>
<td>0xC5</td>
<td>151.16</td>
<td>150.35</td>
<td>148.54</td>
</tr>
<tr>
<td><b>Trace <em>d</em> = 2</b></td>
<td>0x1B</td>
<td>150.06</td>
<td>149.67</td>
<td>151.28</td>
</tr>
<tr>
<td><b>Trace <em>d</em> = <em>D</em>  – 1</b></td>
<td>0x55</td>
<td>149.09</td>
<td>152.42</td>
<td>151.00</td>
</tr>
</tbody>

</table>
</figure>
<p>The trace number <em>d</em> represents a given encryption operation, plaintext, and corresponding power trace. For the entire operation, we would record <em>T</em> samples of the power trace, each sample being a power measurement at a different point in time during the operation. The total number of samples in each trace depends on the sampling rate of our measurement and how long the operation is. For example, if our AES operation took 10ms (0.01s), and our oscilloscope recorded 100 million samples per second (MS/s), we would have 0.01 × 100,000,000 = 1,000,000 samples (that is, <em>T </em>= 1,000,000). In practical scenarios, <em>T</em> can be almost anything, but often it’s somewhere in the range of 100 to 1,000,000 samples. Our CPA attack will consider each sample independently, so we technically need only a <em>single</em> sample for each trace (but that single sample would need to be at the right time).</p>
<p><span epub:type="pagebreak" title="314" id="Page_314"/>For the hypothetical power measurements, we no longer have a sample (or time) axis. Instead, we consider what the hypothetical power consumption would be for the same trace number (the same <em>d</em> index), given a key guess <em>i</em>. What happened to time then? Earlier, we said that the attack could succeed with a single sample point at the “right time.” The “right time” actually means the time when the device is performing the operation on which we modeled our hypothetical power consumption. This means our hypothetical measurement doesn’t need a time index because we are defining the time as being during the operation of interest. With the physical measurement, we don’t know when that operation occurred, so we need to record a longer power trace that includes that operation (but also includes other stuff our attack will weed out). <a href="#table10-3">Table 10-3</a> shows the hypothetical value table we’re working with in this example.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-3">Table 10-3</a>: Plaintext and Hypothetical Value with <em>d</em> Traces and <em>i</em> Guesses</p></figcaption>
<table id="table-278748c10-0003" border="1">
<thead>
<tr>
<td/>
<td><b>Plaintext <em>p</em><sub><em>d</em></sub></b></td>
<td><b>Guess <b><i>i</i></b> = 0</b></td>
<td><b>Guess <b><i>i</i></b> = 1</b></td>
<td><b>Guess <b><i>i</i></b> = 2</b></td>
<td><b>Guess <b><i>i</i></b> = <em>I</em><em> </em>– 1</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><b>Trace <em>d</em> = 0</b></td>
<td>0xA1</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td><b>Trace <em>d</em> = 1</b></td>
<td>0xC5</td>
<td>4</td>
<td>3</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td><b>Trace <em>d</em> = 2</b></td>
<td>0x1B</td>
<td>6</td>
<td>3</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><b>Trace <em>d</em> = <em>D</em> – 1</b></td>
<td>0x55</td>
<td>6</td>
<td>1</td>
<td>5</td>
<td>4</td>
</tr>
</tbody>

</table>
</figure>
<p>For each key guess, we calculate the Hamming weight of the S-box output and put the results in a table, with one column for each guess, numbered from 0 to 255. Our hypothesis is that if the secret key byte is 0x00, the power measurements will look like column 0; if the secret key byte is 0x01, the power measurements will look like column 1; and if the secret key byte is 0xFF, the power measurements will be as in column 255. We want to see which column (if any) strongly correlates to the physical power measurements.</p>
<p>Earlier, we used tables of measured power traces. Here, we’ll represent those tables by the notation <em>t</em><sub><em>d,j</em></sub> , where <em>j</em> = 0,1, . . ., <em>T – 1</em> is the time index in the trace, and <em>d</em> = 0,1, . . . , <em>D – 1</em> is the trace number. If you are following along with the code example in the Jupyter notebook for this section, we are indexing into a variable called <code>traces[d][j]</code>. As we mentioned before, if the attacker knows exactly where a cryptographic operation occurred, they would need to measure only a single point, such that <em>T</em> = 1. For each trace number <em>d</em>, the attacker also knows the plaintext corresponding to that power trace, defined as <em>p</em><sub><em>d</em></sub>. The variable <em>p</em><sub><em>d</em></sub> is equivalent to <code>input_data[d]</code> in the companion code, and it’s the first column in Tables 10-2 and 10-3.</p>
<h4 id="h3-278748c10-0008"><span epub:type="pagebreak" title="315" id="Page_315"/>Bring in the Functions</h4>
<p class="BodyFirst">We’ll define several functions here: we write the hypothetical power consumption of a device for trace number <em>d</em> and secret key guess <em>i</em> as <em>h</em><sub><em>d,i</em></sub> = <em>l</em>(<em>w</em>(<em>p</em><sub><em>d</em></sub>, <em>i</em>)), where <em>l</em>(<em>x</em>) is the <em>leakage model</em> for a given intermediate value <em>x</em>, and <em>w</em>(<em>p</em><sub><em>d</em></sub>, <em>i</em>) generates this intermediate value <em>x</em> given the input plaintext <em>p</em><sub><em>d</em></sub> and the guess of value <em>i</em> as the secret key. (We’ll dive into leakage models soon.) This function <em>h</em><sub><em>d,i</em></sub> becomes the <em>hypothetical value table</em>, where we are asking what the power measurement should look like for a hypothetical secret key byte. These are the remaining columns in <a href="#table10-3">Table 10-3</a>.</p>
<p>Let’s again assume that the power consumption of a microcontroller depends on the Hamming weight of the output of the S-box, as in the DPA example of AES-128. Now, we can update our function definitions to be more specific for AES-128 (⊕ means XOR):</p>
<p class="equation"><em>l(x) = HammingWeight(x)</em></p>
<p class="equation"><em>w(p,i) = SBox(p ⊕ i)</em></p>
<p>The <code>HammingWeight()</code> function returns the number of ones in an 8-bit value, and the <code>SBox()</code> function returns the value of the AES S-box lookup table. Check the companion notebook for a Python implementation.</p>
<h4 id="h3-278748c10-0009">Calculating the Correlation</h4>
<p class="BodyFirst">Now we’ll use the correlation coefficient <em>r</em> to look for a linear relationship between the hypothetical power consumption <em>l</em>(<em>x</em>) and the measured power consumption <em>t</em><sub><em>d</em></sub>,<sub><em>j</em></sub> . Finally, we can calculate the correlation coefficient for each point 0 ≤ <em>j</em> &lt; <em>T</em> over all traces 0 ≤ <em>d</em> &lt; <em>D</em>, for each possible subkey value 0 ≤ <em>i</em> &lt; <em>I</em>, by plugging these values into the formula for the Pearson correlation coefficient:</p>
<figure class="graphic">
<img src="image_fi/278748c10/e10002.png" alt="e10002"/></figure>

<p>Here’s some detail on the functions just introduced:</p>
<ul>
<li><span class="GraphicInline"><img src="image_fi/278748c10/e10007.png"/></span> <em>x</em>  is the sum of <em>x</em> performed over all <em>D</em> traces.</li>
<li><em>h</em><sub><em>i</em></sub> is the average (mean) hypothetical leakage over all traces <em>D</em> for guess <em>i</em>. If the leakage is the Hamming weight of a byte, the leakage could range from 0 to 8, inclusive. (For a large number of traces, this leakage thus should have a mean of 4 and be independent of <em>i</em>.)</li>
<li><em>t</em><sub><em>j</em></sub> is the average (mean) power measurement over all <em>D</em> traces at point <em>j</em>. </li>
</ul>
<p>If we compute this correlation for <a href="#table10-2">Table 10-2</a> and <a href="#table10-3">Table 10-3</a>, we get <a href="#table10-4" id="tableanchor10-4">Table 10-4</a>. The rows in this table are the <em>correlation traces</em>, and the columns are various points in time.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-4">Table 10-4</a>: The Correlation Trace <em>r</em> for Each Key Guess <em>i</em><span epub:type="pagebreak" title="316" id="Page_316"/></p></figcaption>
<table id="table-278748c10-0004" border="1">
<thead>
<tr>
<td/>
<td><b>Corr <b><i>j</i></b> = 0</b></td>
<td><b>Corr <b><i>j</i></b> = 35</b></td>
<td><b>Corr <b><i>j</i></b> = <em>T</em> – 1</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><b>Guess <b><i>i</i></b> = 0x00</b></td>
<td>0.02</td>
<td>–0.01</td>
<td>0.11</td>
</tr>
<tr>
<td><b>Guess <b><i>i</i></b> = 0x01</b></td>
<td>0.06</td>
<td>–0.01</td>
<td>0.06</td>
</tr>
<tr>
<td><b>Guess <b><i>i</i></b> = 0x97</b></td>
<td>–0.00</td>
<td>0.54</td>
<td>–0.12</td>
</tr>
<tr>
<td><b>Guess <b><i>i</i></b> = 0xFF</b></td>
<td>–0.01</td>
<td>0.18</td>
<td>0.12</td>
</tr>
</tbody>

</table>
</figure>
<p>For the correct time (<em>j</em> = 35) and key guess (<em>i</em> = 0x97), the correlation is significantly higher. Of course, the “full” table would have all sample points (times), with the <em>j</em> index ranging from 0 to <em>T </em>– 1, along with all key guesses from 0 to <em>I</em> – 1. The endpoint of key guesses <em>I</em> – 1 in this example is 0xFF, as our leakage model was based on a single-byte input, which can only take on the values 0x00 to 0xFF. We’ve shown a few examples of some sample points to keep this table looking presentable.</p>
<h3 id="h2-278748c10-0007">Attacking AES-128 Using CPA</h3>
<p class="BodyFirst">Now that we can use CPA to detect leakage, let’s run through an example of attacking a single byte of the AES-128 algorithm as we did in the “Attacking AES-128 Using DPA” section on page <span class="xref" itemid="xref_target_310">310</span>. We’ll use the <code>measure_power()</code> function again, with the goal of attacking this single byte. We’ll extend the previous examples to create an <code>intermediate()</code> function, which represents the value h<sub>d,i</sub> = l(w(p<sub>d</sub>, i)). For a given byte of plaintext input and a guess of the key, this function returns the expected Hamming weight of the intermediate value. The CPA attack will use this when comparing the expected leakage to the actual measured leakage.</p>
<h4 id="h3-278748c10-0010">Summation Loop</h4>
<p class="BodyFirst">Notice in the Pearson correlation coefficient equation that there are effectively three sums over all traces. For this initial implementation, we’ll calculate some of those sums and break them into this format:</p>
<figure class="graphic">
<img src="image_fi/278748c10/e10003.png" alt="e10003"/></figure>

<figure class="graphic">
<img src="image_fi/278748c10/e10004.png" alt="e10004"/></figure>

<figure class="graphic">
<img src="image_fi/278748c10/e10005.png" alt="e10005"/></figure>

<figure class="graphic">
<img src="image_fi/278748c10/e10006.png" alt="e10006"/></figure>

<p><span epub:type="pagebreak" title="317" id="Page_317"/>In Python, we first calculate all means using the current key guess. Then, for each trace, we update all the sum variables. A sum is generated for each sample point presented at the input. Again, the Pearson correlation coefficient result (which is used by the CPA attack) determines where the specific sensitive operation occurred; you don’t need to know ahead of time when the encryption occurred.</p>
<h4 id="h3-278748c10-0011">Correlation Calculation and Analysis</h4>
<p class="BodyFirst">To finish the attack, we generate the correlation trace by combining the sums. We plot the correlation trace for different guess numbers with the expectation that the largest peak occurs with the correct key guess (see <a href="#figure10-13" id="figureanchor10-13">Figure 10-13</a>).</p>
<figure>
<img src="image_fi/278748c10/f10013.png" alt="f10013"/>
<figcaption><p><a id="figure10-13">Figure 10-13</a>: Correlation plot of the correct key guess (0x97) and two incorrect key guesses</p></figcaption>
</figure>
<p>The correlation traces ought to show a strong correlation at the point where the guess matches the secret value in use by the device. The spike in <a href="#figure10-13">Figure 10-13</a> and in correlation graphs in general show a strong <em>positive</em> correlation, but you might end up with a strong <em>negative</em> correlation for the correct key guess if you measure the power consumption in reverse of what the model predicts. This negative correlation might be because you are measuring in the GND path instead of the VCC path, or your probe might be connected in reverse polarity, or your measurement setup may cause inverted readings for some other reason. So, in order to determine the correct key guess, we just look at the absolute value of the correlation peak.</p>
<p>The CPA attack is a way to break cryptographic implementations that are generally too secure for a DPA attack because CPA considers the leakage from all 8 bits (for an 8-bit system). The DPA attack considers only a <span epub:type="pagebreak" title="318" id="Page_318"/>single bit. The principle of a CPA attack is based on the observation that you can linearly relate the Hamming weight of an intermediate variable to a device’s power consumption, and that it employs correlation to exploit this relationship.</p>
<p>Try adjusting the number of traces downward on both the DPA and CPA attacks until they fail to recover the correct key reliably. You’ll probably find that at around 200 traces, the DPA attack will fail to recover the correct key, while the CPA attack will recover the correct key down to about 40 traces. Both simulated systems have the same amount of noise; the CPA attack uses the contribution from multiple bits to achieve much better results.</p>
<h4 id="h3-278748c10-0012">Leakage Models and Sensitive Values</h4>
<p class="BodyFirst">A <em>leakage model</em> describes how data values processed on a device are expressed in a side channel. So far, we’ve used the Hamming weight leakage model, where the power consumption had some linear relationship to the number of bits set in an I/O line. As a sensitive value, we chose an intermediate state shortly after a secret value was mixed with our known input data and after a nonlinear operation.</p>
<p>Hamming weight leakage occurred due to the phenomenon of bus pre-charging. However, not all leakage in the chip is due to pre-charged buses. Another commonly found leakage model is<em> Hamming distance (HD)</em>. The HD model is based on the fact that when a register moves from one state to the next, the power consumption depends solely on the number of bits that change state. Therefore, when using this model, you will care only about the number-of-bits difference between two clock cycles. <a href="#figure10-14" id="figureanchor10-14">Figure 10-14</a> shows an example of the HD for a register.</p>
<figure>
<img src="image_fi/278748c10/f10014.png" alt="f10014"/>
<figcaption><p><a id="figure10-14">Figure 10-14</a>: The Hamming distance of a register over three consecutive clock cycles</p></figcaption>
</figure>
<p>This progression shows that the leakage reflects the changes in the register’s state. If this register was holding the output of an S-box, you’d need to know (or guess) the <em>previous</em> state of this register to break the <em>current</em> state.</p>
<p>Cryptographic implementations in hardware, such as an AES peripheral in a microcontroller where the algorithm isn’t running as a software process, are much more likely to be vulnerable to the HD leakage. Since <span epub:type="pagebreak" title="319" id="Page_319"/>they typically have only a small number of interconnections between registers (compared to the main data bus), they don’t bring data lines to a pre-charge state, which leads us to detect a Hamming distance as opposed to a Hamming weight. When attacking these devices, we need to calculate the hypothetical power consumption of a change, which means we need to determine the previous state of such a sensitive register. It might be that the previous state was simply the last used input byte, or it could have been the output from the last time the encryption operation was run.</p>
<p>Determining the previous value in circuits that are specialized for implementing AES-128 can be expected to present more challenges because that value will now depend on hardware design details (as shown earlier in <a href="#figure10-11">Figure 10-11</a>). Hardware designers have more flexibility than software designers do, and in implementing AES-128, they may choose to use 16 copies of the S-box lookup tables running in parallel or to share a single S-box lookup table between all input bytes by successively performing the lookup, as shown in <a href="#figure10-15" id="figureanchor10-15">Figure 10-15</a>. It may take some sleuthing to identify which approach they chose. </p>
<figure>
<img src="image_fi/278748c10/f10015.png" alt="f10015"/>
<figcaption><p><a id="figure10-15">Figure 10-15</a>: Approaches to implementing AES in hardware</p></figcaption>
</figure>
<p>The choice of implementation will depend on the purpose of the device: a general-purpose microcontroller will likely accept slower throughput when a very small, low-power AES core is being designed, whereas an AES core designed to operate on a hard drive or network controller will trade off whatever power or device size restrictions there may be to accommodate multi-Gbps throughput. You may be able to deduce something about the structure by measuring the number of clock cycles AES takes and then dividing it by the number of rounds. At roughly 1 clock per round, all S-boxes (and other AES operations within the round) run in parallel. At roughly 4 clocks per round, operations such as <code>SubBytes</code> and <code>MixColumns</code> are executed in separate clock cycles. Once you get to 20+ clock per round, <code>SubBytes</code> is likely implemented with a single S-box.</p>
<p>The less you know about a target, the more you need to use trial and error to determine how it implements crypto. If you find that the output of <span epub:type="pagebreak" title="320" id="Page_320"/>a device’s S-box isn’t leaking, try guessing bytes after the <code>MixColumns</code> operation (described earlier in the section “Know Thy Enemy: An Advanced Encryption Standard Crash Course”). If the Hamming weight method shows no correlation, try the Hamming distance approach. Ilya Kizhvatov’s “Side Channel Analysis of AVR XMEGA Crypto Engine” provides a great example of this in practical circuits, showing how to break the XMEGA AES peripheral. You’ll also find a step-by-step tutorial repeating that XMEGA attack as part of the ChipWhisperer project, where you can experiment with these results yourself.</p>
<h4 id="h3-278748c10-0013">DPA on Real (but Still Toy) Hardware</h4>
<p class="BodyFirst"><span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> explained how to perform power measurements for SPA. The acquisition setup in this chapter for DPA is the same, so we’ll build on that here. Don’t attempt to attack a real device until you understand how DPA works and have simulated the Python attack. Take it from the experts: triple-check every step you take. It’s easy for a single bug in your acquisition or analysis to prevent you from seeing any leakage.</p>
<p>We’ll insert AES into a simple software framework, with the firmware performing an encryption operation. You can use any AES library for the encryption, such as the open source avr-crypto-lib. You’ll even find ports of this library to Arduino<sup> </sup>(<a href="https://github.com/DavyLandman/AESLib/" class="LinkURL">https://github.com/DavyLandman/AESLib/</a>, for example).</p>
<p><a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a> shows an example of source code that is capable of receiving data over the serial port and initiating an encryption.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include "aes.h"
#include "hardware.h"

int main(void){
    uint8_t key[16];
    uint8_t ptdata[16];
    uint8_t ctdata[16];
    uint8_t i;
    setup_hardware();
    while(1){
        //Read key
        for(i = 0; i &lt; 16; i++){
            scanf("%02x", key + i);
        }

        //Read plaintext
        for(i = 0; i &lt; 16; i++){
            scanf("%02x", ptdata + i);
        }

        //Do encryption
        trigger_high();
        aes_128(key, ptdata, ctdata);
        trigger_low();
<span epub:type="pagebreak" title="321" id="Page_321"/>
        //Return ciphertext
        for(i = 0; i &lt; 16; i++){
            printf("%02x", ctdata[i]);
        }

    };
    return 0;
}</code></pre>
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: Sample microcontroller firmware in C for performing a simple encryption on a trigger</p>
<p>This example has a very simple serial protocol; you send 16 bytes of the key in ASCII, 16 bytes of plaintext, and the system responds with the encrypted data.</p>
<p>For example, you could open a serial port and send the following text:</p>
<pre><code>2b7e151628aed2a6abf7158809cf4f3c 6bc1bee22e409f96e93d7e117393172a</code></pre>
<p>The AES-128 module would then respond with <code>3ad77bb40d7a3660a89ecaf32466ef97</code>. Test your implementation by researching “AES-128 Test Vectors” on the internet.</p>
<h3 id="h2-278748c10-0008">Communicating with a Target Device</h3>
<p class="BodyFirst">Having defined your own serial protocol to send and receive data, communication with the target should be simple. As with the SPA examples, we’ll send some data to the target and record its power consumption during the AES operation. If you followed along with the companion notebook, it showed how to perform the measurement on a virtual device; simply replace the measurement function with a call to the physical device.</p>
<p>The previous simulated measurement examples performed this attack on a single byte, but you’ll need to send 16 bytes to the real device. You can choose to perform the attack on any arbitrary byte or iterate through each byte.</p>
<p>Again, trigger on the rising edge of the I/O line to determine the exact data points of interest. When targeting the first round of AES, for example, move the <code>trigger_high()</code> code shown in <a href="#listing10-3">Listing 10-3</a> inside the AES function such that the line is high only at around the time of your sensitive operation (such as the output of the S-box lookup).</p>
<h3 id="h2-278748c10-0009">Oscilloscope Capture Speed</h3>
<p class="BodyFirst">As in the SPA attack, you can determine the required sample rate experimentally for any platform or device. In general, the DPA attack will require considerably higher sample rates than SPA, because we’ll be classifying the data into one of many groups based on small variations in the power. In contrast, the SPA attack often matches only large variations in the appearance of the power traces, with the result that SPA can operate in conditions with much larger noise and timing jitter than what DPA can.</p>
<p><span epub:type="pagebreak" title="322" id="Page_322"/>In general, when attacking a software implementation such as AES on a microcontroller, it should be sufficient to sample the device at around 1 to 5 times the clock speed. Attacking hardware implementations requires a higher sample rate, frequently (pun intended) at 5 to 10 times the clock speed. These are, however, vague rules of thumb at best; your choice of sample rate will depend on your device leakage, measurement setup, and quality of oscilloscope. Certain sampling methods, such as the synchronous sampling used in the ChipWhisperer platform, can also relax those requirements so you can even sample at the clock speed itself (1 times the clock speed) and have a successful attack.</p>
<h2 id="h1-278748c10-0006">Summary</h2>
<p class="BodyFirst">This chapter (and the previous two chapters) concentrated on attacking platforms that you control. These are great learning targets, and we encourage you to try a range of algorithms and measurement variants to get a feel for how your choices affect leakage detection. With this ability, you’ll be ready to move on to the next level: attacking black-box systems. To do so effectively, you need a fundamental understanding of how cryptography is implemented on embedded systems and how to use your side-channel analysis toolbox against those systems.</p>
<p>The next chapter will introduce some additional tools for attacks on real systems where you don’t have a convenient trigger signal or know the implementation’s exact details. Your patience will be tested severely. </p>
</section>
</body></html>