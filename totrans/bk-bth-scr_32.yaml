- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 29 ARRAYS AND HASH TABLES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 29 数组和哈希表
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: “Arrays? Batch doesn’t have arrays!” After daring to mention the use of this
    data structure in Batch code, I’ve received an array of incredulous responses.
    Technically, these skeptics have a point. Arrays are not intrinsic to the language,
    and the creators of Batch never anticipated their use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “数组？Batch没有数组！”在敢于在Batch代码中提到使用这种数据结构后，我收到了各种不可置信的回应。从技术角度看，这些怀疑论者确实有一定道理。数组并不是Batch语言的固有部分，Batch的创建者从未预见到它们的使用。
- en: However, over the years, some innovative coders have found ways to build something
    that looks like an array, walks like an array, and even quacks like an array (if
    arrays could quack ... and walk). In this chapter, I’ll explore multiple ways
    of building fixed- and variable-length arrays in Batch. You’ll learn how to iterate
    through an array and access any given element in it, as well as how to initialize
    an array. I’ll also discuss hash tables, detailing their similarities and differences
    with arrays, and then show how to populate them with data and retrieve that data.
    Most important, you’ll learn applications for both of these tools that you can
    use to better organize and house small and large sets of similar data during a
    bat file’s execution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多年来，一些创新的程序员找到了构建类似数组的东西的方法，它看起来像数组，走起来像数组，甚至像数组一样嘎嘎作响（如果数组会嘎嘎作响……并且会走的话）。在本章中，我将探索在Batch中构建固定长度和可变长度数组的多种方法。你将学会如何遍历一个数组并访问其中的任何给定元素，以及如何初始化一个数组。我还会讨论哈希表，详细说明它们与数组的相似性和差异，然后展示如何用数据填充它们并检索数据。最重要的是，你将学到这两种工具的应用，可以在批处理文件执行期间更好地组织和存储小型和大型的相似数据集。
- en: Arrays
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'Regardless of the coding language, an *array* is a data structure that holds
    multiple like variables of the same name, differentiated by an index. You can
    think of *like variables* as items or elements in a list; some commonality must
    tie them together. One array might hold the names of your co-workers. Countries
    of the world might be in another, and a third array might contain members of a
    basketball team. These are all examples of arrays of string variables, but an
    array can contain other data types. Three more arrays might represent statistics
    in each game of the season for that basketball team: points scored (whole numbers),
    point differential (integers), or offensive efficiency (floating-point numbers).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是什么编程语言，*数组*都是一种数据结构，用来存储多个具有相同名称的变量，它们通过索引来区分。你可以将*相似变量*看作是列表中的项或元素；它们之间必须有某种共同性。一种数组可能包含你同事的名字，另一种可能包含世界各国的名称，第三个数组可能包含篮球队的成员。这些都是字符串类型变量的数组示例，但数组也可以包含其他数据类型。再举三个数组可能表示该篮球队赛季每场比赛的统计数据：得分（整数），分差（整数），或进攻效率（浮动小数）。
- en: An array has a unique name, and each element in the array is denoted by a combination
    of the array name and a number or *index*. In most modern languages, the index
    counts up from 0, which is a *zero-offset array*. In contrast, arrays that count
    up from 1 are *one-offset arrays*. I’ll be working solely with the more common
    zero-offset arrays. (If you’re a dyed-in-the-wool COBOL coder, you can build one-offset
    arrays just as easily in Batch, but at the risk of being labeled a dinosaur by
    your younger co-workers.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有一个独特的名称，数组中的每个元素由数组名称和一个数字或*索引*的组合表示。在大多数现代语言中，索引是从0开始的，这种数组被称为*零偏移数组*。相反，从1开始计数的数组被称为*一偏移数组*。我将只使用更常见的零偏移数组。（如果你是个固守传统的COBOL程序员，你也可以在Batch中轻松构建一偏移数组，但你可能会被年轻的同事们标记为“老古董”哦。）
- en: One of the arrays just mentioned might be named coworker and another points.
    The value of points[0] would be the number of points scored in the first game
    of the season, points[1] would correspond to the second game, and so on. Your
    co-workers won’t be as ordered, but coworker[0] would be one person and coworker[1]
    would be another. If you work with 100 people, coworker[99] will be the final
    element of the 100-element array.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上面提到的其中一个数组可能被命名为 coworker，另一个则命名为 points。points[0] 的值将是赛季第一场比赛中得分的数值，points[1]
    则对应第二场比赛，以此类推。你的同事们可能没有这么有序，但 coworker[0] 会是一个人，coworker[1] 会是另一个。如果你和100个人一起工作，那么
    coworker[99] 将是这个100元素数组中的最后一个元素。
- en: 'In many languages, you can define arrays in memory, assigning all of the elements
    of the array to a certain data type. As detailed often since [Chapter 5](chapter5.xhtml),
    Batch simply doesn’t allow you to define variables as certain data types, and
    that doesn’t change with arrays, but you can set the following variables:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，你可以在内存中定义数组，将数组的所有元素分配给特定的数据类型。正如[第5章](chapter5.xhtml)中详细描述的那样，Batch根本不允许你将变量定义为某些数据类型，这一点在数组中也没有变化，但你可以设置以下变量：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any coder would tell you that this certainly looks like the first three elements
    of an array named celtics, and that’s exactly how it behaves. It’s important to
    note that there’s no unifying data structure in memory containing the three elements.
    Instead, the interpreter considers these to be just three different and ordinary
    variables whose names all just happen to start with the text celtics[, followed
    by a number and a trailing].
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序员都会告诉你，这看起来无疑像是名为celtics的数组的前3个元素，而它的表现正是如此。需要注意的是，在内存中没有一个统一的数据结构来包含这三个元素。相反，解释器将它们视为三个不同的普通变量，其名称恰好都以文本celtics[开头，后面跟着一个数字和一个尾随符号。
- en: Because Batch is so accommodating when it comes to which characters are permissible
    in variable names, you can easily embed most characters on the keyboard into the
    variable name itself. Other coders have different conventions on how to name arrays,
    but I use the square brackets, also called hard brackets, around the index. And
    behold, an array is born.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Batch在变量名中允许的字符非常宽松，你可以轻松地将大多数键盘字符嵌入到变量名中。其他程序员可能会有不同的数组命名惯例，但我使用方括号，也叫硬括号，来表示数组索引。于是，一个数组诞生了。
- en: Creating Arrays
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建数组
- en: You can create arrays in many different ways. In the previous section, I created
    the celtics array with three elements. That code snippet defined three elements
    of the array by assigning three hardcoded values to three hardcoded variables.
    But you can build arrays of fixed or variable sizes from multiple different sources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式创建数组。在上一节中，我创建了一个包含三个元素的celtics数组。那段代码通过将三个硬编码值分配给三个硬编码变量来定义数组的三个元素。但你也可以从多个不同的来源构建固定或可变大小的数组。
- en: Fixed-Size Array from User Input
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用户输入的固定大小数组
- en: 'Sticking with the basketball theme, it doesn’t take much code to build an array
    of exactly five elements, the starting five players, with data a user enters from
    the console. A fixed-size array requires a specific number of assignments, which
    begs for an iterative loop made possible with a for /L command ([Chapter 18](chapter18.xhtml)).
    Likewise, user input begs for the set /P command ([Chapter 15](chapter15.xhtml)).
    Here’s the code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 继续篮球主题，构建一个包含正好五个元素的数组——即首发五名球员——并通过用户从控制台输入的数据，这段代码并不复杂。固定大小的数组需要一个特定数量的赋值操作，这就需要通过for
    /L命令创建一个迭代循环（参见[第18章](chapter18.xhtml)）。同样，用户输入也需要使用set /P命令（参见[第15章](chapter15.xhtml)）。以下是代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The trailing &rem is just there to spotlight the space before it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀&rem仅仅是用来突出显示它前面的空格。
- en: 'This loop executes the command requesting user input five times, iterating
    the index, %%i, from 0 to 4. One of the advantages of Batch coding is that variable
    names can contain other variables, something you can’t easily do in many other
    languages. Notice that the variable myTeam[%%i] has three components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环执行命令，要求用户输入五次，每次迭代索引%%i，从0到4。Batch编程的一个优点是，变量名可以包含其他变量，而这是许多其他语言中不容易做到的。注意，变量myTeam[%%i]有三个组成部分：
- en: 'The text string ending in the open square bracket: myTeam['
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以开放方括号结尾的文本字符串：myTeam[
- en: 'The number resolved from %%i: 0 through 4'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%%i解析得到的数字：从0到4'
- en: The single character of text for the close square bracket:]
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '文本中单个字符的关闭方括号: ]'
- en: The first time through the loop, the variable name resolves to myTeam[0] as
    the code assigns it the first value retrieved from the console. Then myTeam[1]
    accepts the second value entered, and so on until myTeam[4] takes on the value
    of the fifth and final entry. I’ll be using the same basic technique in the upcoming
    examples of element assignment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第一次执行中，变量名解析为myTeam[0]，此时代码将从控制台获取的第一个值赋给它。然后myTeam[1]接收第二个输入值，依此类推，直到myTeam[4]接收第五个也是最后一个输入值。在接下来的元素赋值示例中，我将使用相同的基本技巧。
- en: Variable-Size Array from a Parameter List
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从参数列表创建可变大小数组
- en: I defined the previous array to be a set size, but you often don’t know the
    ultimate size of an array. The following routine uses an optionless for command
    ([Chapter 17](chapter17.xhtml)) to process all the parameters passed to it, %*,
    adding each one to the parmArr (parameter array).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了前面的数组为固定大小，但你通常无法预知数组的最终大小。以下例程使用没有选项的`for`命令（[第17章](chapter17.xhtml)）来处理传递给它的所有参数`%*`，将每个参数添加到parmArr（参数数组）中。
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of an iterative loop with a built-in index, this code is executing the
    code block of the for command once for each parameter. As a result, I first define
    or initialize the index, defined as parmArrSize, and then increment it with each
    enumeration of the loop. Since I set it to 0 initially, the first pass of the
    loop assigns the first parameter to parmArr[0]. If there are 20 parameters, the
    for loop assigns 20 elements, up through parmArr[19].
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有使用带有内建索引的迭代循环，而是针对每个参数执行一次`for`命令代码块。因此，我首先定义或初始化索引，将其定义为parmArrSize，然后在每次循环枚举时递增它。由于我最初将其设置为0，循环的第一次执行将第一个参数分配给parmArr[0]。如果有20个参数，`for`循环会分配20个元素，一直到parmArr[19]。
- en: This is a subtle point, but notice that I’m incrementing parmArrSize at the
    end of the loop to the index value of the next parameter, whether or not another
    one exists. The upshot is that if this code assigns elements 0 through 19, the
    ultimate value of parmArrSize is 20, which is the actual size of the array. Many
    languages have a method that returns the size of an array; in Batch the next best
    thing is a variable with that data item.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的要点，但请注意，我在循环结束时递增parmArrSize，设置为下一个参数的索引值，不管是否还有下一个参数。结果是，如果这段代码分配了0到19号元素，最终的parmArrSize值将是20，这也是数组的实际大小。许多编程语言都有返回数组大小的方法；而在Batch中，最接近的做法是使用一个包含该数据项的变量。
- en: This code builds a zero-offset array, but you can build a one-offset array with
    one minor tweak. Swap the two set commands in the code block to assign parmArr[1]
    as the first element, and parmArrSize will still contain the correct array size.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构建了一个零偏移数组，但你可以通过稍作修改来构建一个一偏移数组。只需交换代码块中的两个`set`命令，将parmArr[1]设置为第一个元素，parmArrSize仍然会包含正确的数组大小。
- en: If the call to this routine passes no parameters, parmArrSize remains as 0,
    and this logic adds nothing to the array because the code block of the for command
    doesn’t execute at all. Thus, this code successfully creates an empty array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用此例程时没有传递任何参数，parmArrSize将保持为0，此逻辑不会向数组中添加任何内容，因为`for`命令的代码块根本不会执行。因此，这段代码成功地创建了一个空数组。
- en: Also, I don’t want to give short shrift to the set command after the code block.
    Immediately after building or populating an array, I usually like to document
    its current contents. This command writes all the variables starting with the
    parmArr text and their values to stdout or the trace file. Since all of the elements
    of the array start with this text, they’ll all be displayed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我不想忽视代码块后面的`set`命令。在构建或填充数组后，我通常喜欢记录它的当前内容。此命令会将所有以parmArr开头的变量及其值写入标准输出（stdout）或跟踪文件中。由于数组的所有元素都以该文本开头，它们都会被显示出来。
- en: I highly recommend doing this for all arrays that aren’t too large. You’ll usually
    ignore this data, but when a need to troubleshoot arises, it’ll make the task
    far more pleasant. For diagnostic purposes, it provides a great audit trail of
    how this code loaded the array, and you can easily repeat it elsewhere in the
    code after later manipulating the array in any way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议对所有不是特别大的数组都做这个操作。你通常会忽略这些数据，但当需要进行故障排查时，这样做会让任务变得更加轻松。出于诊断的目的，它提供了一个很好的审计跟踪，记录了这段代码如何加载数组，而且在后续修改数组后，你可以轻松地在代码的其他地方重复这段操作。
- en: 'As a final note on this listing, you may take issue with the variable name
    I’m using for the index. It’s usually best to define indices succinctly, but parmArrSize
    is an awfully verbose, even clunky, name for a reason. Since this variable name
    is the concatenation of the name of the array and the Size text, the set parmArr
    command displays it and its value along with the array contents. If the array
    has even a fairly unique name, it’s unlikely that anything else will meet the
    criterion, resulting in this command cleanly displaying everything you want to
    know about the current state of this array: its elements and its size.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个清单的最后一点，你可能对我为索引使用的变量名有所疑问。通常最好简洁地定义索引，但parmArrSize这个名字的确显得有些冗长，甚至有些笨重。之所以这么命名，是因为这个变量名是数组名与Size文本的连接，set
    parmArr命令会显示它及其值，并且同时显示数组内容。如果数组的名字相对独特，那么不太可能有其他内容满足这个条件，从而使这个命令干净地显示出你想知道的关于该数组的所有信息：它的元素及其大小。
- en: Symbiotic Arrays from a File
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从文件中加载的共生数组
- en: I’ll demonstrate a couple intriguing concepts in this next example that you
    can use together or on their own. One is loading an array from a data file, and
    the other is building symbiotic arrays. Two arrays are *symbiotic* when they are
    the same size and synced up by their indices. For example, two arrays, one of
    co-workers and one of phone numbers, might each contain 10 entries. That doesn’t
    make them symbiotic, but if the phone number at index 0 belongs to the co-worker
    at index 0 of the other array and if the same is true of all 10 sets of elements,
    the arrays are symbiotic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我将演示几个有趣的概念，你可以将它们一起使用，也可以单独使用。一个是从数据文件加载数组，另一个是构建共生数组。当两个数组大小相同且通过它们的索引同步时，它们就是*共生*数组。例如，一个数组包含同事，另一个数组包含电话号码，它们可能各自包含10个条目。这并不意味着它们是共生的，但如果索引0处的电话号码属于另一个数组中索引0处的同事，且所有10组元素都满足这一条件，那么这两个数组就是共生数组。
- en: In [Chapter 15](chapter15.xhtml), I presented an interactive bat file that told
    a joke, a pun, or a riddle. In [Chapter 21](chapter21.xhtml), when discussing
    the random pseudo-environment variable, I expanded on this by imagining dozens
    of jokes, puns, and riddles, all in memory and randomly accessible—ostensibly
    giving the users hours of entertainment. The last piece to this puzzle is reading
    a library (also known as a file) containing dozens of jokes and loading them into
    memory to be accessed randomly. That sounds like an array ... or maybe two arrays.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](chapter15.xhtml)中，我展示了一个交互式的bat文件，它会讲一个笑话、一个双关语或一个谜语。在[第21章](chapter21.xhtml)中，当讨论随机伪环境变量时，我通过想象几十个笑话、双关语和谜语，所有内容都在内存中并可以随机访问——显然给用户提供了数小时的娱乐。这个难题的最后一块拼图是读取一个包含数十个笑话的库（也就是一个文件），并将它们加载到内存中供随机访问。这听起来像是一个数组……或者可能是两个数组。
- en: 'Let’s focus solely on the jokes for now and put the puns and riddles aside,
    knowing that we can do something similar for them later. Mercifully, I’ll include
    only the first three lines of the *BatJokes.txt* file (not to be confused with
    the *BadJokes.txt* file), but just imagine hundreds of lines of material. Each
    record contains a joke followed by its answer, delimited by a pipe:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们暂时只关注笑话，先将双关语和谜语放一边，知道稍后我们可以对它们做类似的处理。幸运的是，我只会包括 *BatJokes.txt* 文件中的前三行（不要与
    *BadJokes.txt* 文件混淆），但请想象成有数百行内容。每条记录包含一个笑话，后面跟着它的答案，通过管道符分隔：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code in [Listing 29-1](#Lis29-1) loads this comedic gold into two arrays,
    the jokes into the joke array and the answers into the answer array.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 29-1](#Lis29-1) 中的代码将这些喜剧金句加载到两个数组中，笑话加载到笑话数组，答案加载到答案数组。'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 29-1: Symbiotic arrays built from a data file'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 29-1：从数据文件构建的共生数组
- en: These are symbiotic arrays in that the joke located at a specific index corresponds
    to the answer of the same index. As the for /F command reads each record, it delimits
    on the pipe to tokenize the text for the joke and its answer. The first two set
    commands assign each string to an element of the appropriate array using the pluralized
    jokes index. I’m using this index for both arrays because they’re symbiotic arrays,
    while incrementing it at the end of the code block.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是共生数组，因为位于特定索引处的笑话对应于相同索引处的答案。当for /F命令读取每条记录时，它会根据管道符分隔来标记笑话和答案的文本。前两个set命令使用复数形式的笑话索引将每个字符串分配给适当数组的元素。我为两个数组都使用这个索引，因为它们是共生数组，并且在代码块的末尾递增它。
- en: 'The set commands outside of the loop write the following to the console verifying
    that both arrays were loaded successfully:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 循环外的set命令会将以下内容写入控制台，验证两个数组都已成功加载：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This also verifies that 3 is the total number of jokes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这也验证了3是笑话的总数。
- en: I’ve built both arrays from a single file, and the contents of answer[1] is
    the punchline for the contents of joke[1]. If the file had a thousand entries,
    both symbiotic arrays would have had a thousand elements, and all of their elements
    would have been synced up. I can set up two more arrays for the riddles, although
    I must use something other than answer for the name of the riddle punchline array.
    Puns don’t have punchlines, so I can load each entire record into a pun array.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从一个文件中构建了这两个数组，answer[1]的内容是joke[1]内容的关键。如果这个文件有一千个条目，那么这两个共生数组将有一千个元素，而且它们的所有元素都会同步。我可以再为谜语设置两个数组，不过我必须使用不同于answer的名称来命名谜语答案数组。双关语没有答案，因此我可以将每一条记录都加载到一个双关语数组中。
- en: We now have almost everything needed to build a truly usable user interface
    of bat jokes, puns, and riddles. We can build libraries of humor, and we can load
    those libraries into memory as arrays. We can get a request from the user for
    a type of humor, and we can randomly determine which of the many jokes, puns,
    or riddles to select. The last piece is the ability to access the arrays—that
    is, to extract a joke and its answer to be displayed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎拥有了构建一个真正可用的用户界面的所有必要内容，包括蝙蝠笑话、双关语和谜语。我们可以构建幽默的库，并将这些库加载到内存中作为数组。我们可以从用户那里接收到一个请求，要求选择某种类型的幽默，并且我们可以随机决定选择哪个笑话、双关语或谜语。最后一步是能够访问这些数组——也就是提取一个笑话及其答案并显示出来。
- en: Accessing Array Elements
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问数组元素
- en: 'In order for this to be a *real* array, we must be able to iterate through
    it, reassign elements, assign elements to other variables, resolve elements, and
    more. To demonstrate how to access array elements, I’ll first assign 14 elements
    of the myChar array:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个成为一个*真正的*数组，我们必须能够遍历它，重新分配元素，将元素分配给其他变量，解析元素等。为了演示如何访问数组元素，我将首先为myChar数组分配14个元素：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I’m assigning each element a single character. Most are straightforward, but
    a few are a bit more interesting. The sixth set command assigns element 5 to a
    single space terminated by a command separator, making it obvious that it isn’t
    being set to null or multiple spaces. Elements 8 and 11 are taking on the value
    of elements defined earlier, so element 8 is a space, and elements 10 and 11 are
    both the letter o.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在为每个元素分配一个单一字符。大多数是直接的，但有几个稍微有点有趣。第六条set命令将元素5分配为空格，并以命令分隔符结束，这样就显而易见它不是被设置为null或多个空格。元素8和元素11则取用了之前定义的元素值，因此元素8是一个空格，元素10和元素11都是字母o。
- en: The two resolutions of elements with a hardcoded index illustrate that both
    delimiters work equally as well. Using percent signs, %myChar[5]% resolves to
    the 6th element, and with exclamation marks, !myChar[10]! resolves to the 11th
    element. The syntax is more limited when the index is a variable, as you’ll soon
    witness.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬编码索引的两种元素解析方式表明，这两种分隔符都同样有效。使用百分号时，%myChar[5]%解析为第6个元素，使用感叹号时，!myChar[10]!解析为第11个元素。当索引是一个变量时，语法更加有限，稍后你会看到。
- en: 'Now we can write a for /L command that will iterate through this array, concatenating
    all the values together into a sentence:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个for /L命令，它将遍历这个数组，将所有值连接成一个句子：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After building the string, the last command writes Batch is Cool. to the console.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完字符串后，最后一条命令会将“Batch is Cool.”写入控制台。
- en: Backing up, the for command iterates %%i from 0 to 13, where !myChar[%%i]! successively
    resolves to each of the 14 elements. The interpreter first resolves the %%i index
    and then the array element. For instance, the first time through the loop, the
    intermediate result is myChar[0]. Since that’s surrounded by exclamation marks,
    the interpreter resolves it to B and assigns it to mySentence. The second time
    through the loop, myChar[1] resolves to a, which the interpreter concatenates
    to the prior result giving us Ba. This repeats another dozen times until we’ve
    constructed the entire sentence.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 回到前面，for命令将%%i从0迭代到13，其中!myChar[%%i]!依次解析为14个元素中的每一个。解释器首先解析%%i索引，然后解析数组元素。例如，第一次通过循环时，中间结果是myChar[0]。由于它被感叹号包围，解释器将其解析为B，并将其赋值给mySentence。第二次通过循环时，myChar[1]解析为a，解释器将其与前一个结果连接起来，得到Ba。这个过程重复了十几次，直到我们构建出完整的句子。
- en: 'This is yet another example of the power of delayed expansion, and with delayed
    expansion, you must use exclamation marks as the outside delimiters; percent signs
    simply won’t work. It’s quite tempting to try %myChar[%%i]%, but if you think
    as the interpreter does, you won’t see an array. You’ll see two discrete variables
    to resolve: myChar[and i]. In this example, a for variable is the index, but delayed
    expansion works the same with a common variable as the index. Consider the following
    where percent signs encase the idx index and exclamation marks encase the outer
    array element for the second level of delayed expansion:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是延迟展开功能的又一个例子，使用延迟展开时，必须使用感叹号作为外部分隔符；百分号是无法工作的。虽然很容易尝试使用%myChar[%%i]%，但是如果你像解释器那样思考，你会发现并没有数组。你会看到两个独立的变量需要解决：myChar[和i]。在这个例子中，for变量是索引，但延迟展开对使用普通变量作为索引时也适用。考虑以下例子，其中百分号包含idx索引，而感叹号包含外部数组元素，适用于第二级延迟展开：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This writes the capital C to the console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将大写字母C写入控制台。
- en: 'Similarly, to extract a joke and its answer from the symbiotic arrays built
    in [Listing 29-1](#Lis29-1), you can enter a random non-negative number less than
    the number of jokes into an index variable such as jokeIdx. Then you can resolve
    the joke with !joke[%jokeIdx%]!. Because these are symbiotic arrays, you can retrieve
    its answer with the same index: !answer[%jokeIdx%]!. You now have all of the tools
    necessary to update the bat file in [Chapter 15](chapter15.xhtml) to randomly
    display one of any number of jokes, puns, and riddles.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要从[Listing 29-1](#Lis29-1)中构建的共生数组中提取笑话及其答案，你可以将一个小于笑话数量的随机非负数输入到一个索引变量中，例如jokeIdx。然后，你可以通过!joke[%jokeIdx%]!来解析笑话。因为这些是共生数组，你可以使用相同的索引来提取答案：!answer[%jokeIdx%]!...你现在拥有了更新[第15章](chapter15.xhtml)中的bat文件所需的所有工具，可以随机显示多个笑话、双关语和谜语中的任意一个。
- en: Initializing an Array
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化数组
- en: Languages with proper arrays usually offer a simple one-line command for creating
    an array or even re-initializing all of the elements of an existing array. There’s
    no instantiation of variables, much less of arrays, in Batch, so once again ingenuity
    is a must.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 支持数组的语言通常提供一个简单的一行命令来创建数组，甚至重新初始化现有数组的所有元素。Batch中没有变量的实例化，更不用说数组了，因此再次需要发挥创造力。
- en: 'Before building the joke array, it makes sense to initialize it just as I have
    often initialized a variable to 0 before entering a loop. It’s true that it’s
    highly unlikely that any active variables start with the joke[text, but there
    are definitely instances when you’ll want to re-initialize and rebuild an array
    already in use. The following wipes out all elements of the joke array:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建笑话数组之前，最好先初始化它，就像我在进入循环之前常常初始化变量为0一样。虽然很不可能任何活动的变量以joke[text开头，但确实有些情况下你会想要重新初始化并重建已在使用的数组。以下命令会清空笑话数组中的所有元素：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The for /F command accepts as input the set command listing every existing element
    of the array and its value. By delimiting on the equal sign and passing only the
    first token—that is, the variable or element name but not its value—we’re setting
    each element to null in the code block. If there aren’t any variables to reset,
    the second set command never executes, and the end result is the same.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: for /F命令接受输入的set命令，列出了数组的每个现有元素及其值。通过在等号上进行分隔，并仅传递第一个标记——即变量或元素名称，而不是其值——我们在代码块中将每个元素设置为null。如果没有变量需要重置，第二个set命令就不会执行，最终结果也是一样的。
- en: In prior examples, I’ve simply assumed that no elements already existed when
    building arrays. To be certain, it’s best to execute a command such as this to
    initialize the array before building and using it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我假设在构建数组时没有任何元素已存在。为了确保准确，最好在构建和使用数组之前执行类似这样的命令来初始化数组。
- en: Implementing Multidimensional Arrays
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现多维数组
- en: 'This technique even extends to building and accessing multidimensional arrays.
    Single-dimensional arrays are largely possible in Batch because you can embed
    square brackets into a variable name. For multiple dimensions, we just need one
    more character: the comma. The following command sets row 1 and column 2 of the
    my2dArray array to a hardcoded value in what unmistakably resembles an element
    assignment of a two-dimensional array regardless of the language:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧甚至可以扩展到构建和访问多维数组。Batch中基本上可以使用一维数组，因为你可以在变量名中嵌入方括号。对于多维数组，我们只需要再加一个字符：逗号。以下命令将my2dArray数组的第1行、第2列设置为硬编码值，明显类似于二维数组元素赋值，无论使用什么语言：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a demonstration, I’ll briefly re-imagine two prior examples as two-dimensional
    arrays:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我将简要地将之前的两个示例重新构想为二维数组：
- en: '**User Input**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户输入**'
- en: 'Returning to the array built with user input, the following nested for /L commands
    build a two-dimensional array of three rows and four columns:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到由用户输入构建的数组，以下嵌套的 for /L 命令构建一个三行四列的二维数组：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The outer for variable, %%r, loops through the three rows, while %%c loops through
    the four columns for each row. This code accepts exactly 12 values before continuing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 外层 for 变量 %%r 遍历三行，而 %%c 则遍历每行的四列。此代码在继续之前会接受恰好 12 个值。
- en: 'If rowIdx is set to 2 and colIdx is set to 3, the following resolves to the
    last data element entered by the user:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 rowIdx 设置为 2，colIdx 设置为 3，那么以下内容将解析为用户输入的最后一个数据元素：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The two indices resolve first with the percent signs, resulting in !my2dArray[2,3]!.
    Then the exclamation marks and delayed expansion finish the job.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个索引首先通过百分号解析，结果为!my2dArray[2,3]!。然后，感叹号和延迟扩展完成了整个过程。
- en: '**File Input**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件输入**'
- en: 'Earlier, we built the two symbiotic arrays, for the joke and answer, from each
    record of an input file. Instead, we can load the data into a single two-dimensional
    array where the second-level index of 0 is the joke and 1 is the answer:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们从每条输入记录构建了两个共生数组，一个用于笑话，一个用于答案。相反，我们可以将数据加载到一个单一的二维数组中，其中第二级索引 0 是笑话，1
    是答案：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can think of this array as having exactly two columns; notice the hardcoded
    index for the second dimension in both assignments: 0 and 1. The set /A command
    increments the jokes index. The number of rows is dictated by the number of records
    in the input file. Finally, the single set command at the end of the listing produces
    the following audit trail given the same three-record input file used earlier:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这个数组看作有两列；注意在两个赋值中第二维的硬编码索引：0和1。set /A 命令会递增笑话的索引。行数由输入文件中的记录数决定。最后，列表结尾的单一
    set 命令在使用相同的三条记录输入文件时生成如下审计追踪：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Arrays of even greater dimensions are only a comma or two away: my4dArray[1,2,3,4].
    I don’t remember ever coding anything quite like this, but single-dimensional
    arrays and even two-dimensional arrays have many applications in Batch.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更大维度的数组仅仅差几条逗号：my4dArray[1,2,3,4]。我不记得曾经编写过类似的代码，但一维数组甚至二维数组在批处理中的应用非常广泛。
- en: Regardless of the dimension, if you need an extremely large array or if you
    plan on accessing it many thousands of times, compiled code is a far more efficient
    solution. But when used wisely, Batch arrays are quite helpful and surprisingly
    easy to manage.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论维度如何，如果你需要一个极其庞大的数组，或者如果你计划访问它成千上万次，编译代码是一个更高效的解决方案。但当合理使用时，批处理数组非常有用，且出乎意料地易于管理。
- en: Hash Tables
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希表
- en: It turns out that Batch does support arrays, or at least we can fashion an array
    out of the rudimentary tools at our disposal. But surely a hash table isn’t possible?
    You’ve probably intuited the answer to this question given the title of the chapter
    and the section that you’re now reading, but before building a hash table, let’s
    define what it is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，批处理确实支持数组，或者至少我们可以利用我们手头的基本工具构建一个数组。但哈希表肯定不可能吧？你可能已经从本章的标题和你现在阅读的这一节中猜到了答案，但在构建哈希表之前，让我们先定义一下它是什么。
- en: 'A *hash table* (sometimes called a *hash map*) is a data structure that stores
    data in pairs: a key and a value. The *value* can be of any data type, even other
    data structures. The *key* is similar to the index of an array, but it doesn’t
    have to be an integer. In fact, in the Batch universe, arrays and hash tables
    behave very much alike; in fact, the best way to compare and contrast them is
    to transform an array into a hash table.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希表*（有时称为*哈希映射*）是一种以键值对存储数据的数据结构。*值*可以是任何数据类型，甚至是其他数据结构。*键*类似于数组的索引，但它不必是整数。事实上，在批处理环境中，数组和哈希表的行为非常相似；实际上，比较和对比它们的最佳方法是将数组转换为哈希表。'
- en: Arrays vs. Hash Tables
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组与哈希表
- en: 'Imagine an array where the index is the date formatted as CCYYMMDD and the
    data is the number of steps a person might take in a day. If this otherwise active
    individual was sedentary on the first pandemic Christmas doing little more than
    opening presents and drinking eggnog in solitude, the steps array might contain
    these three entries:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个数组，其中索引是按 CCYYMMDD 格式排列的日期，数据则是一个人一天可能走的步数。如果这个本来活跃的人在第一次大流行圣诞节期间保持静止，除了孤独地打开礼物和喝蛋酒，步数数组可能包含以下三条记录：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These indices are quite large, even though we’re using only a small number of
    elements. It’s a good thing that we didn’t define this array in memory like we
    would have in many other languages, because its size would have been upward of
    20 million elements. One advantage of a Batch array is that it uses memory only
    for the elements that are defined. Memory has gotten mighty cheap, but there’s
    still no reason to be profligate.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些索引非常大，即使我们只使用了少量元素。幸运的是，我们没有像在许多其他语言中那样在内存中定义这个数组，因为它的大小可能会超过 2000 万个元素。Batch
    数组的一个优点是，它只为已定义的元素使用内存。虽然内存已经变得相当便宜，但仍然没有理由浪费。
- en: 'The minimal usage of memory is a direct result of the array element (for example,
    steps[20201225]) being a simple variable with a name consisting of some text,
    a number, and a couple square brackets. Another advantage of the underlying nature
    of Batch elements is that the index doesn’t have to be a number at all; in fact,
    it needn’t even be a true index. To demonstrate, let’s format the date as MM/DD/CCYY
    for readability:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的最小使用量直接源于数组元素（例如，steps[20201225]）是一个简单的变量，变量名由一些文本、一个数字和几个方括号组成。Batch 元素的另一个优点是，索引根本不需要是数字；实际上，它甚至不需要是真正的索引。为了演示，我们将日期格式化为
    MM/DD/CCYY 以提高可读性：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Because the index is not an integer, this is no longer an array; we’ve transformed
    it into a hash table. Period, just like that. We can’t iterate through it like
    we could an array, but we can look up the number of steps given a formatted date.
    We can no longer retrieve an element for a given index; instead, the lookup involves
    a key between those brackets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于索引不是整数，这不再是一个数组；我们已经将它转变成了哈希表。就这么简单。我们不能像遍历数组那样迭代它，但可以根据格式化后的日期查找步骤数。我们不能再通过给定的索引来检索元素；相反，查找过程涉及方括号之间的键。
- en: 'Taking this a step further, let’s add text for the day of the week and even
    an embedded space to the key:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步讲，我们可以向键中添加星期几的文本，甚至嵌入空格：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Not incidentally, that key is starting to look a lot like what we can resolve
    from the date pseudo-environment variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无意间，这个关键正开始看起来像我们可以从日期伪环境变量中解析出的内容。
- en: 'One small problem with this syntax is that it falsely looks like an array.
    The non-numeric key, in lieu of an index, might make it clear that it isn’t an
    array, but the key will more than likely be a variable, thus obscuring its data
    type. For this reason, a different convention is ideal. Personally, I’ve settled
    on using curly brackets, also called braces:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法有一个小问题，它看起来像是一个数组。非数字键代替了索引，可能会让它看起来不像数组，但这个键很可能是一个变量，从而模糊了它的数据类型。因此，采用另一种约定是理想的。就个人而言，我选择了使用大括号，也叫括号：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is just one convention, and there are others that work just as well. For
    instance, you can prepend hash table variables with ht. What’s important is that
    you make the data structure look like something unique and something other than
    an array. Anyone who reads the code, even quickly, should notice the difference.
    Even if the reader doesn’t know the convention, the uniqueness of the syntax will
    raise curiosity, which in turn cracks open the door to understanding.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是其中一种约定，其他约定也同样有效。例如，你可以在哈希表变量前加上 ht。重要的是，你要使数据结构看起来像是某种独特的、不同于数组的东西。任何阅读代码的人，即使是快速浏览，也应该能注意到区别。即使读者不了解这种约定，语法的独特性也会引起好奇心，从而打开理解的大门。
- en: 'Consider this simple, and at the same time not so simple, set command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的命令，同时又不那么简单的 set 命令：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command is setting one element of the steps hash table, and the key is
    the formatted date of whenever the command executes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令正在设置步骤哈希表的一个元素，键是命令执行时的格式化日期。
- en: If you choose to use my convention, I’ll summarize it as array[index] and hashTable{key},
    but as always, use the convention that makes sense to you and stick with it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用我的约定，我会将其总结为 array[index] 和 hashTable{key}，但像往常一样，使用适合你的约定并坚持下去。
- en: Basic Hash Table Functionality
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本哈希表功能
- en: 'Another example of a basic hash table contains multiple pairs of a person and
    their occupation, where the person’s name is the key, and their job is the value.
    For instance, the Darwin key retrieves the Naturalist value. Lincoln, Poe, and
    Braille are the respective keys for the President, Poet, and Inventor values.
    Here’s the hash table in tabular form:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的哈希表示例包含了多对人员和其职业，其中人员的姓名为键，职业为值。例如，Darwin键检索到“Naturalist”值。Lincoln、Poe
    和 Braille 是总统、诗人和发明家的键。下面是该哈希表的表格形式：
- en: '| Key | Value |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Key | Value |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Lincoln | President |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Lincoln | President |'
- en: '| Darwin | Naturalist |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Darwin | Naturalist |'
- en: '| Poe | Poet |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Poe | Poet |'
- en: '| Braille | Inventor |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| Braille | Inventor |'
- en: Notice the lack of an index and any semblance of order to the elements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意元素缺乏索引以及任何排序的痕迹。
- en: Every key must be a unique value. If there are two people in this hash table
    named Darwin, we’ll need to distinguish them in some way, perhaps by adding first
    and middle names. However, multiple people can hold the job of Poet; that is,
    the value doesn’t have to be unique.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键必须是唯一值。如果这个哈希表中有两个人名为Darwin，我们需要通过某种方式来区分他们，或许可以通过添加名字和中间名来区分。不过，多个不同的人可以拥有相同的职业，比如“诗人”；也就是说，值不必是唯一的。
- en: 'The syntax for building and accessing elements of a hash table in Batch is
    very different from that of many other languages, where after declaring the jobs
    hash table, you can define a single key-value pair via some variant of the *put*
    method. For instance, this is how to do it in Java:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Batch中构建和访问哈希表元素的语法与许多其他语言非常不同，在其他语言中，在声明哈希表之后，你可以通过某种变体的*put*方法定义单个键值对。例如，这是在Java中实现的方式：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There’s no dot notation or built-in methods in Batch, but the following set
    command assigns the same hardcoded pair to the hash table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Batch中没有点符号或内置方法，但以下的set命令将相同的硬编码键值对赋给哈希表：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'More typically, the key and value are both variables. The following code creates
    the same entry:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 更典型的是，键和值都是变量。以下代码创建了相同的条目：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Extracting the value in many languages requires some variant of the *get* method.
    Again, this is from Java:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，提取值需要某种变体的*get*方法。这是来自Java的例子：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The corresponding Batch code retrieves an element much like we did from a Batch
    array, only with curly brackets and a key instead of square brackets and an index.
    Both of these commands work equally as well:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的Batch代码检索元素的方式与我们从Batch数组中获取元素的方式类似，只是使用了大括号和键，而不是方括号和索引。这两个命令的效果一样好：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But the key is more often a variable, which requires the now familiar delayed
    expansion:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但键通常是变量，这就需要现在大家熟悉的延迟展开：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If person is set to Braille, the output is The Job is: Inventor.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '如果person设置为Braille，输出为：The Job is: Inventor。'
- en: 'We now have a simple hash table to which we can add more keys (people) and
    values (occupations) as pairs. We can remove one specific entry if someone is
    laid off and reconsiders their occupation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个简单的哈希表，可以向其中添加更多的键（人名）和值（职业）作为一对一对的条目。如果某人被裁员并重新考虑自己的职业，我们也可以移除其中一条特定的记录：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following assigns a value to a key only if it doesn’t yet exist in the
    hash table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令仅在哈希表中尚未存在该键时，才为其分配一个值：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This for /F command mimics three different methods available in many other
    languages that get the size of a hash table and extract lists of keys and values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个for /F命令模拟了许多其他语言中用于获取哈希表大小以及提取键值对列表的三种不同方法：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Both lists are space-delimited with each element in double quotes. With a little
    more work, we can use these results to determine whether the hash table is empty:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 两个列表都用空格分隔，每个元素都包含在双引号中。稍作处理，我们就可以利用这些结果来判断哈希表是否为空：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code tells us whether a particular key exists in the hash table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码告诉我们某个特定的键是否存在于哈希表中：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The echo command writes the famous refrain to the console if "Poe" is contained
    in listKeys. Poe is encased in double quotes because that’s how we added each
    key to the hash table, and we can similarly search listValues for a specific value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果"listKeys"中包含"Poe"，则echo命令会将著名的副歌输出到控制台。Poe被双引号包围，因为我们就是这样将每个键添加到哈希表中的，我们也可以类似地在listValues中搜索特定的值。
- en: Complex Hash Tables
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复杂的哈希表
- en: A more complex hash table might also be keyed by a person’s name, but instead
    of a simple string as the value, it might have something more resembling an object
    from a more modern language. For example, it might contain a more complete set
    of information on that person such as occupation, state, hobbies, and more. (I’ll
    have much more to say on the topic of objects in [Chapter 32](chapter32.xhtml).)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的哈希表也可能以人名为键，但它的值可能不仅仅是一个简单的字符串，而是更像现代语言中的对象。例如，它可能包含关于该人的更完整的信息，如职业、州、爱好等。（关于对象的话题，我将在[第32章](chapter32.xhtml)中详细讨论。）
- en: 'Once you understand that hash tables and arrays in Batch are built by simply
    stringing together text, partial variable names, resolved variables, indices,
    and brackets, it’s not a huge leap to create a people hash table keyed by a person’s
    name attached to signifiers for job and state, and even an array of hobbies:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了Batch中的哈希表和数组是通过简单地将文本、部分变量名、解析后的变量、索引和括号串联起来构建的，那么要创建一个以人名为键的人员哈希表，并将职位和州作为标识符，甚至是一个爱好数组，就不难了：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Don’t confuse this with dot notation; people{Lincoln.hobbies[1]} is just a variable
    name, either a messy one or an elegant one, depending on your perspective.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将其与点符号表示法混淆；people{Lincoln.hobbies[1]}仅仅是一个变量名，取决于你的视角，它可以是一个杂乱的名称，也可以是一个优雅的名称。
- en: 'After the prior commands execute, the following code extracts the second hobby
    from the array inside the hash table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令执行后，以下代码从哈希表中的数组提取第二个爱好：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Delayed expansion resolves the two variables encased in percent signs first.
    Then the exclamation marks resolve the intermediate result to Cats. (The 16th
    US president shared the White House with Tabby and Dixie.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟扩展首先解析被百分号包围的两个变量。然后，感叹号解析中间结果为 Cats。（美国第16任总统与Tabby和Dixie一起住在白宫。）
- en: The same considerations that I mentioned earlier for arrays apply to hash tables.
    This technique isn’t meant for heavy duty processing, but in many instances, a
    quick and relatively simple solution in the form of a hash table might be hiding
    in plain sight.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到的关于数组的考虑同样适用于哈希表。这个技巧并不是为了进行重型处理，但在许多情况下，哈希表的快速且相对简单的解决方案可能就在眼前。
- en: 'In [Chapter 3](chapter3.xhtml), I introduced the idea of using delayed expansion
    to store and retrieve transmission paths in variables containing city abbreviations,
    such as pathNYC, pathNash, and pathSTL. This is really a thinly disguised hash
    table; consider these three elements: path{NYC}, path{Nash}, and path{STL}. Treat
    the city as a variable and use it to extract the corresponding transmission path
    with !path{%city%}!.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](chapter3.xhtml)中，我介绍了使用延迟扩展将传输路径存储并从包含城市缩写的变量中检索的概念，比如pathNYC、pathNash和pathSTL。这实际上是一个伪装的哈希表；考虑这三个元素：path{NYC}、path{Nash}和path{STL}。将城市视为一个变量，并使用它通过!path{%city%}!来提取相应的传输路径。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: With a little ingenuity, we can make Batch do many things for which it wasn’t
    first designed, like repurposing an old tire and some rope as a swing. In this
    chapter, I illustrated how to load arrays from hardcoded data, user data, parameters,
    and data from a file. You learned the importance of delayed expansion in accessing
    elements of an array and the possibilities opened with multidimensional arrays.
    I then extended this technique to build and access hash tables, explaining the
    similarities and differences between them and arrays, with applications of both.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些巧妙的构思，我们可以让Batch完成许多最初并未设计的任务，就像用旧轮胎和绳子做秋千一样。在本章中，我演示了如何从硬编码数据、用户数据、参数和文件数据加载数组。你学习了延迟扩展在访问数组元素中的重要性以及多维数组所带来的可能性。接着，我扩展了这一技巧，构建并访问哈希表，解释了它们与数组的相似性和差异，并展示了两者的应用。
- en: I hope these examples have demonstrated the flexibility that’s possible in Batch.
    In the next chapter, I’ll switch gears and cover a few disparate yet useful topics
    that are intrinsic to the language.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些例子能够展示Batch中可能实现的灵活性。在下一章，我将切换话题，介绍一些虽然看似不同但对语言本身非常有用的主题。
