- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 29 ARRAYS AND HASH TABLES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: “Arrays? Batch doesn’t have arrays!” After daring to mention the use of this
    data structure in Batch code, I’ve received an array of incredulous responses.
    Technically, these skeptics have a point. Arrays are not intrinsic to the language,
    and the creators of Batch never anticipated their use.
  prefs: []
  type: TYPE_NORMAL
- en: However, over the years, some innovative coders have found ways to build something
    that looks like an array, walks like an array, and even quacks like an array (if
    arrays could quack ... and walk). In this chapter, I’ll explore multiple ways
    of building fixed- and variable-length arrays in Batch. You’ll learn how to iterate
    through an array and access any given element in it, as well as how to initialize
    an array. I’ll also discuss hash tables, detailing their similarities and differences
    with arrays, and then show how to populate them with data and retrieve that data.
    Most important, you’ll learn applications for both of these tools that you can
    use to better organize and house small and large sets of similar data during a
    bat file’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regardless of the coding language, an *array* is a data structure that holds
    multiple like variables of the same name, differentiated by an index. You can
    think of *like variables* as items or elements in a list; some commonality must
    tie them together. One array might hold the names of your co-workers. Countries
    of the world might be in another, and a third array might contain members of a
    basketball team. These are all examples of arrays of string variables, but an
    array can contain other data types. Three more arrays might represent statistics
    in each game of the season for that basketball team: points scored (whole numbers),
    point differential (integers), or offensive efficiency (floating-point numbers).'
  prefs: []
  type: TYPE_NORMAL
- en: An array has a unique name, and each element in the array is denoted by a combination
    of the array name and a number or *index*. In most modern languages, the index
    counts up from 0, which is a *zero-offset array*. In contrast, arrays that count
    up from 1 are *one-offset arrays*. I’ll be working solely with the more common
    zero-offset arrays. (If you’re a dyed-in-the-wool COBOL coder, you can build one-offset
    arrays just as easily in Batch, but at the risk of being labeled a dinosaur by
    your younger co-workers.)
  prefs: []
  type: TYPE_NORMAL
- en: One of the arrays just mentioned might be named coworker and another points.
    The value of points[0] would be the number of points scored in the first game
    of the season, points[1] would correspond to the second game, and so on. Your
    co-workers won’t be as ordered, but coworker[0] would be one person and coworker[1]
    would be another. If you work with 100 people, coworker[99] will be the final
    element of the 100-element array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many languages, you can define arrays in memory, assigning all of the elements
    of the array to a certain data type. As detailed often since [Chapter 5](chapter5.xhtml),
    Batch simply doesn’t allow you to define variables as certain data types, and
    that doesn’t change with arrays, but you can set the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Any coder would tell you that this certainly looks like the first three elements
    of an array named celtics, and that’s exactly how it behaves. It’s important to
    note that there’s no unifying data structure in memory containing the three elements.
    Instead, the interpreter considers these to be just three different and ordinary
    variables whose names all just happen to start with the text celtics[, followed
    by a number and a trailing].
  prefs: []
  type: TYPE_NORMAL
- en: Because Batch is so accommodating when it comes to which characters are permissible
    in variable names, you can easily embed most characters on the keyboard into the
    variable name itself. Other coders have different conventions on how to name arrays,
    but I use the square brackets, also called hard brackets, around the index. And
    behold, an array is born.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can create arrays in many different ways. In the previous section, I created
    the celtics array with three elements. That code snippet defined three elements
    of the array by assigning three hardcoded values to three hardcoded variables.
    But you can build arrays of fixed or variable sizes from multiple different sources.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed-Size Array from User Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sticking with the basketball theme, it doesn’t take much code to build an array
    of exactly five elements, the starting five players, with data a user enters from
    the console. A fixed-size array requires a specific number of assignments, which
    begs for an iterative loop made possible with a for /L command ([Chapter 18](chapter18.xhtml)).
    Likewise, user input begs for the set /P command ([Chapter 15](chapter15.xhtml)).
    Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The trailing &rem is just there to spotlight the space before it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This loop executes the command requesting user input five times, iterating
    the index, %%i, from 0 to 4. One of the advantages of Batch coding is that variable
    names can contain other variables, something you can’t easily do in many other
    languages. Notice that the variable myTeam[%%i] has three components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The text string ending in the open square bracket: myTeam['
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number resolved from %%i: 0 through 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single character of text for the close square bracket:]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first time through the loop, the variable name resolves to myTeam[0] as
    the code assigns it the first value retrieved from the console. Then myTeam[1]
    accepts the second value entered, and so on until myTeam[4] takes on the value
    of the fifth and final entry. I’ll be using the same basic technique in the upcoming
    examples of element assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Variable-Size Array from a Parameter List
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I defined the previous array to be a set size, but you often don’t know the
    ultimate size of an array. The following routine uses an optionless for command
    ([Chapter 17](chapter17.xhtml)) to process all the parameters passed to it, %*,
    adding each one to the parmArr (parameter array).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Instead of an iterative loop with a built-in index, this code is executing the
    code block of the for command once for each parameter. As a result, I first define
    or initialize the index, defined as parmArrSize, and then increment it with each
    enumeration of the loop. Since I set it to 0 initially, the first pass of the
    loop assigns the first parameter to parmArr[0]. If there are 20 parameters, the
    for loop assigns 20 elements, up through parmArr[19].
  prefs: []
  type: TYPE_NORMAL
- en: This is a subtle point, but notice that I’m incrementing parmArrSize at the
    end of the loop to the index value of the next parameter, whether or not another
    one exists. The upshot is that if this code assigns elements 0 through 19, the
    ultimate value of parmArrSize is 20, which is the actual size of the array. Many
    languages have a method that returns the size of an array; in Batch the next best
    thing is a variable with that data item.
  prefs: []
  type: TYPE_NORMAL
- en: This code builds a zero-offset array, but you can build a one-offset array with
    one minor tweak. Swap the two set commands in the code block to assign parmArr[1]
    as the first element, and parmArrSize will still contain the correct array size.
  prefs: []
  type: TYPE_NORMAL
- en: If the call to this routine passes no parameters, parmArrSize remains as 0,
    and this logic adds nothing to the array because the code block of the for command
    doesn’t execute at all. Thus, this code successfully creates an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I don’t want to give short shrift to the set command after the code block.
    Immediately after building or populating an array, I usually like to document
    its current contents. This command writes all the variables starting with the
    parmArr text and their values to stdout or the trace file. Since all of the elements
    of the array start with this text, they’ll all be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend doing this for all arrays that aren’t too large. You’ll usually
    ignore this data, but when a need to troubleshoot arises, it’ll make the task
    far more pleasant. For diagnostic purposes, it provides a great audit trail of
    how this code loaded the array, and you can easily repeat it elsewhere in the
    code after later manipulating the array in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note on this listing, you may take issue with the variable name
    I’m using for the index. It’s usually best to define indices succinctly, but parmArrSize
    is an awfully verbose, even clunky, name for a reason. Since this variable name
    is the concatenation of the name of the array and the Size text, the set parmArr
    command displays it and its value along with the array contents. If the array
    has even a fairly unique name, it’s unlikely that anything else will meet the
    criterion, resulting in this command cleanly displaying everything you want to
    know about the current state of this array: its elements and its size.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbiotic Arrays from a File
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I’ll demonstrate a couple intriguing concepts in this next example that you
    can use together or on their own. One is loading an array from a data file, and
    the other is building symbiotic arrays. Two arrays are *symbiotic* when they are
    the same size and synced up by their indices. For example, two arrays, one of
    co-workers and one of phone numbers, might each contain 10 entries. That doesn’t
    make them symbiotic, but if the phone number at index 0 belongs to the co-worker
    at index 0 of the other array and if the same is true of all 10 sets of elements,
    the arrays are symbiotic.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](chapter15.xhtml), I presented an interactive bat file that told
    a joke, a pun, or a riddle. In [Chapter 21](chapter21.xhtml), when discussing
    the random pseudo-environment variable, I expanded on this by imagining dozens
    of jokes, puns, and riddles, all in memory and randomly accessible—ostensibly
    giving the users hours of entertainment. The last piece to this puzzle is reading
    a library (also known as a file) containing dozens of jokes and loading them into
    memory to be accessed randomly. That sounds like an array ... or maybe two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus solely on the jokes for now and put the puns and riddles aside,
    knowing that we can do something similar for them later. Mercifully, I’ll include
    only the first three lines of the *BatJokes.txt* file (not to be confused with
    the *BadJokes.txt* file), but just imagine hundreds of lines of material. Each
    record contains a joke followed by its answer, delimited by a pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code in [Listing 29-1](#Lis29-1) loads this comedic gold into two arrays,
    the jokes into the joke array and the answers into the answer array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-1: Symbiotic arrays built from a data file'
  prefs: []
  type: TYPE_NORMAL
- en: These are symbiotic arrays in that the joke located at a specific index corresponds
    to the answer of the same index. As the for /F command reads each record, it delimits
    on the pipe to tokenize the text for the joke and its answer. The first two set
    commands assign each string to an element of the appropriate array using the pluralized
    jokes index. I’m using this index for both arrays because they’re symbiotic arrays,
    while incrementing it at the end of the code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The set commands outside of the loop write the following to the console verifying
    that both arrays were loaded successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This also verifies that 3 is the total number of jokes.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve built both arrays from a single file, and the contents of answer[1] is
    the punchline for the contents of joke[1]. If the file had a thousand entries,
    both symbiotic arrays would have had a thousand elements, and all of their elements
    would have been synced up. I can set up two more arrays for the riddles, although
    I must use something other than answer for the name of the riddle punchline array.
    Puns don’t have punchlines, so I can load each entire record into a pun array.
  prefs: []
  type: TYPE_NORMAL
- en: We now have almost everything needed to build a truly usable user interface
    of bat jokes, puns, and riddles. We can build libraries of humor, and we can load
    those libraries into memory as arrays. We can get a request from the user for
    a type of humor, and we can randomly determine which of the many jokes, puns,
    or riddles to select. The last piece is the ability to access the arrays—that
    is, to extract a joke and its answer to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Array Elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order for this to be a *real* array, we must be able to iterate through
    it, reassign elements, assign elements to other variables, resolve elements, and
    more. To demonstrate how to access array elements, I’ll first assign 14 elements
    of the myChar array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I’m assigning each element a single character. Most are straightforward, but
    a few are a bit more interesting. The sixth set command assigns element 5 to a
    single space terminated by a command separator, making it obvious that it isn’t
    being set to null or multiple spaces. Elements 8 and 11 are taking on the value
    of elements defined earlier, so element 8 is a space, and elements 10 and 11 are
    both the letter o.
  prefs: []
  type: TYPE_NORMAL
- en: The two resolutions of elements with a hardcoded index illustrate that both
    delimiters work equally as well. Using percent signs, %myChar[5]% resolves to
    the 6th element, and with exclamation marks, !myChar[10]! resolves to the 11th
    element. The syntax is more limited when the index is a variable, as you’ll soon
    witness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write a for /L command that will iterate through this array, concatenating
    all the values together into a sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After building the string, the last command writes Batch is Cool. to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up, the for command iterates %%i from 0 to 13, where !myChar[%%i]! successively
    resolves to each of the 14 elements. The interpreter first resolves the %%i index
    and then the array element. For instance, the first time through the loop, the
    intermediate result is myChar[0]. Since that’s surrounded by exclamation marks,
    the interpreter resolves it to B and assigns it to mySentence. The second time
    through the loop, myChar[1] resolves to a, which the interpreter concatenates
    to the prior result giving us Ba. This repeats another dozen times until we’ve
    constructed the entire sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is yet another example of the power of delayed expansion, and with delayed
    expansion, you must use exclamation marks as the outside delimiters; percent signs
    simply won’t work. It’s quite tempting to try %myChar[%%i]%, but if you think
    as the interpreter does, you won’t see an array. You’ll see two discrete variables
    to resolve: myChar[and i]. In this example, a for variable is the index, but delayed
    expansion works the same with a common variable as the index. Consider the following
    where percent signs encase the idx index and exclamation marks encase the outer
    array element for the second level of delayed expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This writes the capital C to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to extract a joke and its answer from the symbiotic arrays built
    in [Listing 29-1](#Lis29-1), you can enter a random non-negative number less than
    the number of jokes into an index variable such as jokeIdx. Then you can resolve
    the joke with !joke[%jokeIdx%]!. Because these are symbiotic arrays, you can retrieve
    its answer with the same index: !answer[%jokeIdx%]!. You now have all of the tools
    necessary to update the bat file in [Chapter 15](chapter15.xhtml) to randomly
    display one of any number of jokes, puns, and riddles.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing an Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Languages with proper arrays usually offer a simple one-line command for creating
    an array or even re-initializing all of the elements of an existing array. There’s
    no instantiation of variables, much less of arrays, in Batch, so once again ingenuity
    is a must.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before building the joke array, it makes sense to initialize it just as I have
    often initialized a variable to 0 before entering a loop. It’s true that it’s
    highly unlikely that any active variables start with the joke[text, but there
    are definitely instances when you’ll want to re-initialize and rebuild an array
    already in use. The following wipes out all elements of the joke array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The for /F command accepts as input the set command listing every existing element
    of the array and its value. By delimiting on the equal sign and passing only the
    first token—that is, the variable or element name but not its value—we’re setting
    each element to null in the code block. If there aren’t any variables to reset,
    the second set command never executes, and the end result is the same.
  prefs: []
  type: TYPE_NORMAL
- en: In prior examples, I’ve simply assumed that no elements already existed when
    building arrays. To be certain, it’s best to execute a command such as this to
    initialize the array before building and using it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Multidimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This technique even extends to building and accessing multidimensional arrays.
    Single-dimensional arrays are largely possible in Batch because you can embed
    square brackets into a variable name. For multiple dimensions, we just need one
    more character: the comma. The following command sets row 1 and column 2 of the
    my2dArray array to a hardcoded value in what unmistakably resembles an element
    assignment of a two-dimensional array regardless of the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As a demonstration, I’ll briefly re-imagine two prior examples as two-dimensional
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Input**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the array built with user input, the following nested for /L commands
    build a two-dimensional array of three rows and four columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The outer for variable, %%r, loops through the three rows, while %%c loops through
    the four columns for each row. This code accepts exactly 12 values before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If rowIdx is set to 2 and colIdx is set to 3, the following resolves to the
    last data element entered by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The two indices resolve first with the percent signs, resulting in !my2dArray[2,3]!.
    Then the exclamation marks and delayed expansion finish the job.
  prefs: []
  type: TYPE_NORMAL
- en: '**File Input**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we built the two symbiotic arrays, for the joke and answer, from each
    record of an input file. Instead, we can load the data into a single two-dimensional
    array where the second-level index of 0 is the joke and 1 is the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can think of this array as having exactly two columns; notice the hardcoded
    index for the second dimension in both assignments: 0 and 1. The set /A command
    increments the jokes index. The number of rows is dictated by the number of records
    in the input file. Finally, the single set command at the end of the listing produces
    the following audit trail given the same three-record input file used earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays of even greater dimensions are only a comma or two away: my4dArray[1,2,3,4].
    I don’t remember ever coding anything quite like this, but single-dimensional
    arrays and even two-dimensional arrays have many applications in Batch.'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the dimension, if you need an extremely large array or if you
    plan on accessing it many thousands of times, compiled code is a far more efficient
    solution. But when used wisely, Batch arrays are quite helpful and surprisingly
    easy to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Hash Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It turns out that Batch does support arrays, or at least we can fashion an array
    out of the rudimentary tools at our disposal. But surely a hash table isn’t possible?
    You’ve probably intuited the answer to this question given the title of the chapter
    and the section that you’re now reading, but before building a hash table, let’s
    define what it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *hash table* (sometimes called a *hash map*) is a data structure that stores
    data in pairs: a key and a value. The *value* can be of any data type, even other
    data structures. The *key* is similar to the index of an array, but it doesn’t
    have to be an integer. In fact, in the Batch universe, arrays and hash tables
    behave very much alike; in fact, the best way to compare and contrast them is
    to transform an array into a hash table.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays vs. Hash Tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine an array where the index is the date formatted as CCYYMMDD and the
    data is the number of steps a person might take in a day. If this otherwise active
    individual was sedentary on the first pandemic Christmas doing little more than
    opening presents and drinking eggnog in solitude, the steps array might contain
    these three entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These indices are quite large, even though we’re using only a small number of
    elements. It’s a good thing that we didn’t define this array in memory like we
    would have in many other languages, because its size would have been upward of
    20 million elements. One advantage of a Batch array is that it uses memory only
    for the elements that are defined. Memory has gotten mighty cheap, but there’s
    still no reason to be profligate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimal usage of memory is a direct result of the array element (for example,
    steps[20201225]) being a simple variable with a name consisting of some text,
    a number, and a couple square brackets. Another advantage of the underlying nature
    of Batch elements is that the index doesn’t have to be a number at all; in fact,
    it needn’t even be a true index. To demonstrate, let’s format the date as MM/DD/CCYY
    for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Because the index is not an integer, this is no longer an array; we’ve transformed
    it into a hash table. Period, just like that. We can’t iterate through it like
    we could an array, but we can look up the number of steps given a formatted date.
    We can no longer retrieve an element for a given index; instead, the lookup involves
    a key between those brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking this a step further, let’s add text for the day of the week and even
    an embedded space to the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Not incidentally, that key is starting to look a lot like what we can resolve
    from the date pseudo-environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'One small problem with this syntax is that it falsely looks like an array.
    The non-numeric key, in lieu of an index, might make it clear that it isn’t an
    array, but the key will more than likely be a variable, thus obscuring its data
    type. For this reason, a different convention is ideal. Personally, I’ve settled
    on using curly brackets, also called braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is just one convention, and there are others that work just as well. For
    instance, you can prepend hash table variables with ht. What’s important is that
    you make the data structure look like something unique and something other than
    an array. Anyone who reads the code, even quickly, should notice the difference.
    Even if the reader doesn’t know the convention, the uniqueness of the syntax will
    raise curiosity, which in turn cracks open the door to understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this simple, and at the same time not so simple, set command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command is setting one element of the steps hash table, and the key is
    the formatted date of whenever the command executes.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to use my convention, I’ll summarize it as array[index] and hashTable{key},
    but as always, use the convention that makes sense to you and stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Hash Table Functionality
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another example of a basic hash table contains multiple pairs of a person and
    their occupation, where the person’s name is the key, and their job is the value.
    For instance, the Darwin key retrieves the Naturalist value. Lincoln, Poe, and
    Braille are the respective keys for the President, Poet, and Inventor values.
    Here’s the hash table in tabular form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Lincoln | President |'
  prefs: []
  type: TYPE_TB
- en: '| Darwin | Naturalist |'
  prefs: []
  type: TYPE_TB
- en: '| Poe | Poet |'
  prefs: []
  type: TYPE_TB
- en: '| Braille | Inventor |'
  prefs: []
  type: TYPE_TB
- en: Notice the lack of an index and any semblance of order to the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Every key must be a unique value. If there are two people in this hash table
    named Darwin, we’ll need to distinguish them in some way, perhaps by adding first
    and middle names. However, multiple people can hold the job of Poet; that is,
    the value doesn’t have to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for building and accessing elements of a hash table in Batch is
    very different from that of many other languages, where after declaring the jobs
    hash table, you can define a single key-value pair via some variant of the *put*
    method. For instance, this is how to do it in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no dot notation or built-in methods in Batch, but the following set
    command assigns the same hardcoded pair to the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'More typically, the key and value are both variables. The following code creates
    the same entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting the value in many languages requires some variant of the *get* method.
    Again, this is from Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding Batch code retrieves an element much like we did from a Batch
    array, only with curly brackets and a key instead of square brackets and an index.
    Both of these commands work equally as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But the key is more often a variable, which requires the now familiar delayed
    expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If person is set to Braille, the output is The Job is: Inventor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a simple hash table to which we can add more keys (people) and
    values (occupations) as pairs. We can remove one specific entry if someone is
    laid off and reconsiders their occupation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following assigns a value to a key only if it doesn’t yet exist in the
    hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This for /F command mimics three different methods available in many other
    languages that get the size of a hash table and extract lists of keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Both lists are space-delimited with each element in double quotes. With a little
    more work, we can use these results to determine whether the hash table is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code tells us whether a particular key exists in the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The echo command writes the famous refrain to the console if "Poe" is contained
    in listKeys. Poe is encased in double quotes because that’s how we added each
    key to the hash table, and we can similarly search listValues for a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: Complex Hash Tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more complex hash table might also be keyed by a person’s name, but instead
    of a simple string as the value, it might have something more resembling an object
    from a more modern language. For example, it might contain a more complete set
    of information on that person such as occupation, state, hobbies, and more. (I’ll
    have much more to say on the topic of objects in [Chapter 32](chapter32.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you understand that hash tables and arrays in Batch are built by simply
    stringing together text, partial variable names, resolved variables, indices,
    and brackets, it’s not a huge leap to create a people hash table keyed by a person’s
    name attached to signifiers for job and state, and even an array of hobbies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Don’t confuse this with dot notation; people{Lincoln.hobbies[1]} is just a variable
    name, either a messy one or an elegant one, depending on your perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the prior commands execute, the following code extracts the second hobby
    from the array inside the hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Delayed expansion resolves the two variables encased in percent signs first.
    Then the exclamation marks resolve the intermediate result to Cats. (The 16th
    US president shared the White House with Tabby and Dixie.)
  prefs: []
  type: TYPE_NORMAL
- en: The same considerations that I mentioned earlier for arrays apply to hash tables.
    This technique isn’t meant for heavy duty processing, but in many instances, a
    quick and relatively simple solution in the form of a hash table might be hiding
    in plain sight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](chapter3.xhtml), I introduced the idea of using delayed expansion
    to store and retrieve transmission paths in variables containing city abbreviations,
    such as pathNYC, pathNash, and pathSTL. This is really a thinly disguised hash
    table; consider these three elements: path{NYC}, path{Nash}, and path{STL}. Treat
    the city as a variable and use it to extract the corresponding transmission path
    with !path{%city%}!.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a little ingenuity, we can make Batch do many things for which it wasn’t
    first designed, like repurposing an old tire and some rope as a swing. In this
    chapter, I illustrated how to load arrays from hardcoded data, user data, parameters,
    and data from a file. You learned the importance of delayed expansion in accessing
    elements of an array and the possibilities opened with multidimensional arrays.
    I then extended this technique to build and access hash tables, explaining the
    similarities and differences between them and arrays, with applications of both.
  prefs: []
  type: TYPE_NORMAL
- en: I hope these examples have demonstrated the flexibility that’s possible in Batch.
    In the next chapter, I’ll switch gears and cover a few disparate yet useful topics
    that are intrinsic to the language.
  prefs: []
  type: TYPE_NORMAL
