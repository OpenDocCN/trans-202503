["```\n// Add three constants to show some machine code.\n        .arch armv8-a\n// Stack frame\n        .equ    z, 28\n        .equ    FRAME, 32\n// Constant data\n        .section  .rodata\nformat:\n        .string \"%i + %i + 456 = %i\\n\"\n// Code\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp       fp, lr, [sp, FRAME]!  // Create stack frame\n        mov       fp, sp\n\n        mov       w19, 123              // 1st constant\n        mov       w20, -123             // 2nd constant\n        add       w21, w19, w20         // Add them\n        add       w22, w21, 456         // Another constant\n        str       w22, [sp, z]          // Store sum\n\n        ldr       w3, [sp, z]           // Get sum\n     ➊ mov       w2, w20               // Get 2nd constant\n     ➋ orr       w2, wzr, w20          // Alias\n        mov       w1, w19               // Get 1st constant\n        adr       x0, format            // Assume on same page bl        printf\n\n        mov       w0, wzr               // Return 0\n        ldp       fp, lr, [sp], FRAME   // Delete stack frame\n        ret\n```", "```\n$ as --gstabs -al -o add_consts.o add_consts.s > add_consts.lst\n```", "```\nAARCH64 GAS  add_consts.s     page 1\n\n    1               // Add three constants to show some machine code.\n    2                       .arch armv8-a\n    3               // Stack frame\n    4                       .equ    z, 28\n    5                       .equ    FRAME, 32\n    6               // Constant data\n    7                       .section  .rodata\n    8               format:\n    9 0000 2569202B         .string \"%i + %i + 456 = %i\\n\"\n    9      20256920\n    9      2B203435\n    9      36203D20\n    9      25690A00\n   10               // Code\n   11                       .text\n   12                       .align 2\n   13                       .global main\n   14                       .type main, %function\n   15               main:\n➊ 16 0000 FD7B82A9           stp     fp, lr, [sp, FRAME]!  // Create stack frame\n   17 0004 FD030091           mov     fp, sp\n   18\n   19 0008 730F8052           mov     w19, 123              // 1st constant\n   20 000c 540F8012           mov     w20, -123             // 2nd constant\n   21 0010 7502140B           add     w21, w19, w20         // Add them 22 0014 B6220711           add     w22, w21, 456         // Another constant\n   23 0018 F61F00B9           str     w22, [sp, z]          // Store sum\n   24\n   25 001c E31F40B9           ldr     w3, [sp, z]           // Get sum\n➋ 26 0020 E203142A           mov     w2, w20               // Get 2nd constant\n➌ 27 0024 E203142A           orr     w2, wzr, w20          // Alias instruction\n   28 0028 E103132A           mov     w1, w19               // Get 1st constant\n   29 002c 00000010           adr     x0, format            // Assume on same page\n   30 0030 00000094           bl      printf\n   31\n   32 0034 E0031F2A           mov     w0, wzr               // Return 0\n   33 0038 FD7BC2A8           ldp     fp, lr, [sp], FRAME   // Delete stack frame\n   34 003c C0035FD6           ret\n```", "```\nBreakpoint 1, main () at add_consts.s:24\n24              str     w22, [sp, z]          // Store sum\n(gdb) i r w19 w20 w21 w22\nw19            0x7b                123\nw20            0xffffff85          4294967173\nw21            0x0                 0\nw22            0x1c8               456\n```", "```\n   $ objdump -D add_consts\n   --snip--\n   0000000000000774 <main>:\n   774:   a9827bfd        stp     x29, x30, [sp, #32]!\n   778:   910003fd        mov     x29, sp\n   77c:   52800f73        mov     w19, #0x7b                      // #123\n   780:   12800f54        mov     w20, #0xffffff85                // #-123\n   784:   0b140275        add     w21, w19, w20\n   788:   110722b6        add     w22, w21, #0x1c8\n   78c:   b9001ff6        str     w22, [sp, #28]\n   790:   b9401fe3        ldr     w3, [sp, #28]\n   794:   2a1403e2        mov     w2, w20\n   798:   2a1403e2        mov     w2, w20\n   79c:   2a1303e1        mov     w1, w19\n➊ 7a0:   100005c0        adr     x0, 858 <format>\n   7a4:   97ffffab        bl      650 <printf@plt>\n   7a8:   2a1f03e0        mov     w0, wzr\n   7ac:   a8c27bfd        ldp     x29, x30, [sp], #32\n   7b0:   d65f03c0        ret\n   7b4:   d503201f        nop\n   7b8:   d503201f        nop\n   7bc:   d503201f        nop\n   --snip--\n   0000000000000858 <format>:\n   858:   2b206925        adds    w5, w9, w0, uxtx #2\n   85c:   20692520        .inst   0x20692520 ; undefined\n   860:   3534202b        cbnz    w11, 68c64 <__bss_end__+0x57c24> 864:   203d2036        .inst   0x203d2036 ; undefined\n   868:   000a6925        .inst   0x000a6925 ; undefined\n   --snip--\n```", "```\n--snip--\n33 0024 3F00006B                cmp     w1, w0                // Above or below middle?\n34 0028 88000054                b.hi    tails                 // Above -> tails\n35 002c 00000010                adr     x0, heads_msg         // Below -> heads message\n36 0030 00000094                bl      puts                  // Print message\n37 0034 03000014                b       continue              // Skip else part\n38               tails: 39 0038 00000010                adr     x0, tails_msg         // Tails message page address\n--snip--\n```", "```\nLet location_counter = 0\ndo\n    Read a line of source code\n    if (.equ directive)\n        local_symbol_table.symbol = symbol\n        local_symbol_table.value = expression value\n    else if (line has a label)\n        local_symbol_table.symbol = label\n        local_symbol_table.value = location_counter\n    Determine number_of_bytes required by line when assembled\n    location_counter = location_counter + number_of_bytes\nwhile (more lines of source code)\n```", "```\nLet location_counter = 0\ndo\n    Read a line of source code\n    Find machine code from opcode table\n    if (symbol is used in instruction)\n        if (symbol found in local_symbol_table)\n            Get value of symbol\n        else\n            Let value = 0\n            Write symbol and location_counter to object file\n        Add symbol value to instruction\n    Write assembled instruction to object file\n    Determine number_of_bytes used by the assembled instruction\n    location_counter = location_counter + number_of_bytes\nwhile (more lines of source code)\n```", "```\nbl     printf\n```", "```\n7a4:   97ffffab      bl     650 <printf@plt>\n```"]