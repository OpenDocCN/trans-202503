<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch02">
  <div id="header0201" class="chapter">
   <h1 class="cn">
    <span class="page" id="p28">
    </span>
    <span class="page" id="p29">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch02">
     2
    </a>
   </h1>
   <h1 class="ctfm">
    First Steps
   </h1>
  </div>
  <div class="figure" id="ct02">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   Now that you’ve installed the requisite software and are prepared to enter the world of AVR microcontrollers, this chapter will ease you into your first AVR projects with some basic circuits and code.
  </p>
  <p class="calibre8">
   In this chapter, you’ll learn how to:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Test your setup for making AVR-based projects.
   </li>
   <li class="bl">
    • Read basic circuit schematics.
   </li>
   <li class="bll">
    • Control LEDs with the digital output pins on both AVR microcontrollers, the ATtiny85 and the ATmega328P-PU.
   </li>
  </ul>
  <p class="calibre8">
   I’ll also show you how to start coding with
   <code class="calibre23">
    #define
   </code>
   macros and
   <code class="calibre23">
    for
   </code>
   loops, and how to use bitwise arithmetic and bit shifting to generate outputs efficiently.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah0401">
    <span class="page" id="p30">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0401">
     Testing the Hardware and Toolchain
    </a>
   </h2>
   <p class="paft">
    At this point, it’s wise to check that the USBasp programmer and the previously installed toolchain are working as expected. We’ll do this in three stages: by building a simple circuit, testing the USBasp, and uploading code to the microcontroller.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0401">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0401">
      Build the Circuit
     </a>
    </h3>
    <p class="paft">
     In this section you’ll build a simple device that flashes an LED on and off, which is a fun and simple way to test your hardware and toolchain. To get started, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATtiny85–20PU microcontroller
     </li>
     <li class="bl">
      • One 5 mm red LED
     </li>
     <li class="bl">
      • One 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistor
     </li>
     <li class="bll">
      • Seven jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Now let’s focus on the practical steps of putting the circuit together to make sure your toolchain works correctly and will hold up when we dig into meatier projects. To connect the components of your test circuit, first place the solderless breadboard on a flat surface, as shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02001">
      Figure 2-1
     </a>
     .
    </p>
    <div class="figure" id="f02001">
     <p class="fig">
      <img alt="Photo of a 400-hole solderless breadboard" height="1200" src="images/nsp-boxall502581-f02001.jpg" width="945" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-1:
       </span>
       A solderless breadboard
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p31">
     </span>
     Insert your ATtiny85 into the breadboard so that it sits across the vertical gap in the board’s top four rows, as shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02002">
      Figure 2-2
     </a>
     , making sure you insert the microcontroller’s pin 1—indicated by the small circle beside the leg, as described in
     <a class="url" href="nsp-boxall502581-0011.xhtml#ch01">
      Chapter 1
     </a>
     —into column e, row 1 of the breadboard. The pins are numbered in a counterclockwise direction from 1, so pin 4 is at the bottom left in this figure, and pin 8 is at the top right.
    </p>
    <div class="figure" id="f02002">
     <p class="fig">
      <img alt="Photo of an ATtiny85 microcontroller positioned at the top of a solderless breadboard" height="346" src="images/nsp-boxall502581-f02002.jpg" width="1006" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-2:
       </span>
       The AVR in the breadboard
      </p>
     </div>
    </div>
    <p class="calibre8">
     Now take the 560
     <span lang="el" xml:lang="el">
      Ω
     </span>
     resistor and insert one leg in the same row as pin 2 of the ATtiny85 and the other leg a few rows farther along. In
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02003">
      Figure 2-3
     </a>
     , I’ve inserted the second leg into row 8.
    </p>
    <div class="figure" id="f02003">
     <p class="fig">
      <img alt="Adding the first resistor to the solderless breadboard from pin 2 of the microcontroller" height="515" src="images/nsp-boxall502581-f02003.jpg" width="1001" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-3:
       </span>
       The resistor in the breadboard
      </p>
     </div>
    </div>
    <p class="calibre8">
     Next, take a look at your LED. Note that one leg is longer than the other, as shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02004">
      Figure 2-4
     </a>
     .
    </p>
    <div class="figure" id="f02004">
     <p class="fig">
      <img alt="Photo of a red LED" height="367" src="images/nsp-boxall502581-f02004.jpg" width="1001" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-4:
       </span>
       A typical LED
      </p>
     </div>
    </div>
    <p class="calibre8">
     Insert the LED into the solderless breadboard, with the longer leg in the same row as the lower end of the resistor (row 8 in our example) and the shorter leg two rows farther along, using
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02005">
      Figure 2-5
     </a>
     as a guide.
    </p>
    <div class="figure" id="f02005">
     <p class="fig">
      <span id="p32">
      </span>
      <img alt="Photo of the red LED inserted into the solderless breadboard, with the anode connected to the other end of the resistor" height="1087" src="images/nsp-boxall502581-f02005.jpg" width="997" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-5:
       </span>
       Your circuit so far
      </p>
     </div>
    </div>
    <p class="calibre8">
     Take a jumper wire and insert one end into the same row as the LED’s shorter leg, then the other end into the same row as pin 4 of the ATtiny85, as demonstrated in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02006">
      Figure 2-6
     </a>
     .
    </p>
    <div class="figure" id="f02006">
     <p class="fig">
      <img alt="Photo of the circuit with a jumper wire between the LED cathode and microcontroller ground pin" height="794" src="images/nsp-boxall502581-f02006.jpg" width="978" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-6:
       </span>
       The wiring begins!
      </p>
     </div>
    </div>
    <p class="calibre8">
     Now that you’ve placed the components, I’ll show you how to get the code from your computer to the microcontroller with the AVR programmer.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0402">
     <span class="page" id="p33">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0402">
      Connect and Run the Programmer
     </a>
    </h3>
    <p class="paft">
     To connect the USBasp programmer to the breadboard, first connect six male to female jumper wires to the six connection pins on the USBasp, shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02007">
      Figure 2-7
     </a>
     .
    </p>
    <div class="figure" id="f02007">
     <p class="fig">
      <img alt="Photo of the connection pins on the USBasp programmer that connect to the circuit" height="1200" src="images/nsp-boxall502581-f02007.jpg" width="847" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-7:
       </span>
       USBasp connection pins
      </p>
     </div>
    </div>
    <p class="calibre8">
     Next, connect each of the USBasp’s six pins to the ATtiny85 using the mapping in
     <a class="url" href="nsp-boxall502581-0012.xhtml#tab0201">
      Table 2-1
     </a>
     . You’ll use these same connections every time you program an ATtiny85 microcontroller. Don’t worry for now about the meaning of the pin labels; I’ll explain them to you as we go along in the book.
    </p>
    <table id="tab0201" class="calibre13">
     <thead class="calibre14">
      <tr class="calibre15">
       <th colspan="2" class="calibre16">
        <p class="th1">
         <span class="calibre4">
          Table 2-1
         </span>
         : USBasp to ATtiny85 Connections
        </p>
       </th>
      </tr>
      <tr class="calibre15">
       <th scope="col" class="calibre16">
        <p class="tch">
         USBasp pin
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         ATtiny85 pin
        </p>
       </th>
      </tr>
     </thead>
     <tbody class="calibre17">
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         RST
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         1
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         GND
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         4
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         VCC
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         8
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         SCK
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         7
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         MISO
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         6
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         MOSI
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         5
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02008">
      Figure 2-8
     </a>
     illustrates the connections between the USBasp and an ATtiny85 described in
     <a class="url" href="nsp-boxall502581-0012.xhtml#tab0201">
      Table 2-1
     </a>
     . I’ve removed the rest of the circuit to show just an example of the connections.
    </p>
    <div class="figure" id="f02008">
     <p class="fig">
      <span id="p34">
      </span>
      <img alt="Photo showing the six connections between the USBasp programmer and the microcontroller on the solderless breadboard" height="633" src="images/nsp-boxall502581-f02008.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-8:
       </span>
       A USBasp connected to an ATtiny85 on a solderless breadboard
      </p>
     </div>
    </div>
    <p class="calibre8">
     Next, check the USBasp is working correctly by connecting your USBasp programmer to your computer. To do this, you’ll use a program that’s part of the installed toolchain called AVRDUDE, which is a utility to upload code to AVR microcontrollers. Open a terminal window and enter the command
     <code class="b">
      avrdude -p t85 -c usbasp -B 4
     </code>
     . This command includes the following options:
    </p>
    <ul class="calibre10">
     <li class="blf">
      •
      <code class="calibre23">
       -p
      </code>
      selects the type of microcontroller being used in the project. You used
      <code class="calibre23">
       t85
      </code>
      just now for the ATtiny85, and later you’ll use
      <code class="calibre23">
       m328p
      </code>
      for the ATmega328P-PU.
     </li>
     <li class="bl">
      •
      <code class="calibre23">
       -c
      </code>
      selects the type of hardware programmer being used. In this case you’ve specified
      <code class="calibre23">
       usbasp
      </code>
      , representing your USBasp programmer.
     </li>
     <li class="bll">
      •
      <code class="calibre23">
       -B
      </code>
      sets the processing speed of the microcontroller in the USBasp programmer. You set this value to
      <code class="calibre23">
       4
      </code>
      to bring the speed down to 187.5 kHz. This is necessary for new microcontrollers, as they are set at the factory with a clock speed of 1 MHz, which is slower than the USBasp’s default speed. I’ll explain more about speeds in
      <a class="url" href="nsp-boxall502581-0022.xhtml#ch12">
       Chapter 12
      </a>
      .
     </li>
    </ul>
    <p class="calibre8">
     The software toolchain should interrogate the programmer and microcontroller, and your terminal should look something like this afterward:
    </p>
    <pre>
     <p class="clf">
      C:\&gt;
      <code class="b">
       avrdude -p t85 -c usbasp -B 4
      </code>
     </p>
     <p class="cl">
      avrdude: set SCK frequency to 187500 Hz
     </p>
     <p class="cl">
      avrdude: AVR device initialized and ready to accept instructions
     </p>
     <p class="cl">
      Reading | ################################################## | 100% 0.03s
     </p>
     <p class="cl">
      avrdude: Device signature = 0x1e930b
     </p>
     <p class="cl">
      avrdude: safemode: Fuses OK
     </p>
     <p class="cl">
      avrdude done.  Thank you.
     </p>
     <p class="cll">
      C:\&gt;
     </p>
    </pre>
    <p class="calibre8">
     By reporting the
     <i class="calibre5">
      device signature
     </i>
     , a unique identifier for the type of AVR microcontroller, the software toolchain has indicated that all is well.
    </p>
    <p class="calibre8">
     <span id="p35">
     </span>
     The AVRDUDE documentation (
     <a class="url-i" href="http://www.nongnu.org/avrdude/user-manual/avrdude_4.html">
      http://www.nongnu.org/avrdude/user-manual/avrdude_4.html
     </a>
     ) describes other options beyond those included in this
     <code class="calibre23">
      avrdude
     </code>
     command, if you’re curious. For now, if you saw the correct output after entering that command, skip ahead to
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     . You’re ready to program your AVR!
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0403">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0403">
      What If It Didn’t Work?
     </a>
    </h3>
    <p class="paft">
     If, after running the command in the previous step, you got an error like the following, then there was a problem with the hardware connection between the programmer and the circuit:
    </p>
    <pre>
     <p class="cl1f">
      C:\&gt;
      <code class="b">
       avrdude -p t85 -c usbasp -B 4
      </code>
     </p>
     <p class="cl1">
      avrdude: set SCK frequency to 187500 Hz
     </p>
     <p class="cl1">
      avrdude: error: programm enable: target doesn’t answer. 1
     </p>
     <p class="cl1">
      avrdude: initialization failed, rc=-1
     </p>
     <p class="cl1">
      Double-check connections and try again, or use -F to override this check
     </p>
     <p class="cl1">
      avrdude done.  Thank you.
     </p>
     <p class="cl1l">
      C:\&gt;
     </p>
    </pre>
    <p class="calibre8">
     Don’t use
     <code class="calibre23">
      -F
     </code>
     to override the check, as the error message suggests. Instead, double-check the wiring between the USBasp and the solderless breadboard to make sure no connections are loose. Then check the circuit itself to confirm the components are connected to one another according to the instructions given in the “Build the Circuit” section. In particular, check that the ATtiny85’s pin 1 is aligned with the top-left corner of the breadboard. Orienting a chip incorrectly is one of the most common circuit errors!
    </p>
    <p class="calibre8">
     If everything looks correct, try running the
     <code class="calibre23">
      avrdude
     </code>
     command again. It should work, but if it doesn’t, walk away for a few moments, then review the process again.
    </p>
    <div class="box">
     <div class="chapter" id="bxheader0201">
      <p class="bxh">
       Using AVR Safely
      </p>
     </div>
     <p class="bxaft">
      As we move on to our
      <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
       first project
      </a>
      , a reminder about safety: as with any hobby or craft, it’s up to you to take care of yourself and those around you. In this book, I discuss working with basic hand tools, battery-powered electrical devices, sharp knives, cutters, and sometimes hot soldering irons.
      <i class="calibre5">
       At no point in your projects should you work directly with AC mains current
      </i>
      . That is, don’t directly wire anything you make to the wall outlets. Leave that to a licensed electrician who is trained for such work. Remember that direct contact with AC current could kill you.
     </p>
    </div>
    <p class="calibre8">
     Once you’ve got your circuit working, keep it together, including the USBasp, as you’ll need all of this for the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      first project
     </a>
     .
    </p>
    <p class="hd" id="pro0">
     <span class="page" id="p36">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro0">
      <span class="ccust1">
       Project 0: Blinking an LED
      </span>
     </a>
    </p>
    <p class="paft">
     Now that you have a working circuit and programmer connection, it’s time to create and upload your first
     <i class="calibre5">
      program
     </i>
     (also known as
     <i class="calibre5">
      code
     </i>
     ), a set of instructions that tells the microcontroller how to accomplish a particular task.
    </p>
    <p class="calibre8">
     Over the course of this book, our programs will increase in length as the projects get more complex. Instead of typing out each piece of code included in the book, please download the ZIP file containing the book’s code from
     <a class="url-i" href="http://www.nostarch.com/avr-workshop">
      http://www.nostarch.com/avr-workshop
     </a>
     . This file includes folders for each project (organized by chapter) that contain the code and anything else required to program the projects.
    </p>
    <p class="pcust">
     <span class="ccust">
      Note
     </span>
     If you’re reading an electronic version of this book, don’t copy and paste the code from the book into your text editor. Use the downloaded code files instead.
    </p>
    <p class="calibre8">
     Projects in this book use the C programming language. Since C is popular across many microcontroller and computer platforms, it should be easy to find help if you need it and to share your work with others.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0404">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0404">
      Uploading Your First AVR Code
     </a>
    </h3>
    <p class="paft">
     Once you’ve downloaded and extracted the book’s code files, use a text editor to open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 0
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 2
     </i>
     folder. This C file contains a small program that should cause your LED to blink on and off once you compile the code and upload it to the microcontroller. However, to get the desired effect, you’ll need to pair the C files for each of your projects with a
     <i class="calibre5">
      Makefile
     </i>
     .
    </p>
    <p class="calibre8">
     A Makefile contains a set of instructions for the toolchain to use when compiling and uploading your code to the microcontroller, including the microcontroller type, the CPU speed the microcontroller requires, and the type of programmer you plan to use. Every time you start a new project of your own, you should create a new folder for that project and place the
     <i class="calibre5">
      main.c
     </i>
     file and Makefile inside that folder. To save you time I’ve already done this for the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     files and for all the other projects in this book.
    </p>
    <p class="calibre8">
     If you’re curious about the contents of the Makefile, open the one for
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     with a text editor and take a look. I’ll introduce any necessary changes to the Makefiles in the download bundle for this book as you progress with the projects.
    </p>
    <p class="calibre8">
     Now that you’re familiar with these file types, it’s time to bring your
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      first project
     </a>
     to life using the circuit you constructed earlier in this chapter. If you closed it earlier, open a terminal window just as you did when testing the toolchain. Next, navigate to the folder containing the two files for
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     , and enter the command
     <code class="b">
      make flash
     </code>
     .
    </p>
    <p class="calibre8">
     After a moment, the toolchain should compile the program file and create the required data file to upload to the microcontroller. The
     <span id="p37">
     </span>
     microcontroller should then start running the program; in this case, your LED should start blinking. During this process, the status should appear in the terminal window, as shown here:
    </p>
    <pre>
     <p class="clf">
      C:\&gt;
      <code class="b">
       make flash
      </code>
     </p>
     <p class="cl">
      avrdude -c USBasp  -p attiny85 -B 4 -U flash:w:main.hex:i
     </p>
     <p class="cl">
      avrdude: set SCK frequency to 187500 Hz
     </p>
     <p class="cl">
      avrdude: AVR device initialized and ready to accept instructions
     </p>
     <p class="cl">
      Reading | ################################################## | 100% 0.02s
     </p>
     <p class="cl">
      avrdude: Device signature = 0x1e930b
     </p>
     <p class="cl">
      avrdude: NOTE: FLASH memory has been specified, an erase cycle will be performed
     </p>
     <p class="cl">
      To disable this feature, specify the -D option.
     </p>
     <p class="cl">
      avrdude: erasing chip
     </p>
     <p class="cl">
      avrdude: set SCK frequency to 187500 Hz
     </p>
     <p class="cl">
      avrdude: reading input file "main.hex"
     </p>
     <p class="cl">
      avrdude: writing flash (108 bytes):
     </p>
     <p class="cl">
      Writing | ################################################## | 100% 0.05s
     </p>
     <p class="cl">
      avrdude: 108 bytes of flash written
     </p>
     <p class="cl">
      avrdude: verifying flash memory against main.hex:
     </p>
     <p class="cl">
      avrdude: load data flash data from input file main.hex:
     </p>
     <p class="cl">
      avrdude: input file main.hex contains 108 bytes
     </p>
     <p class="cl">
      avrdude: reading on-chip flash data:
     </p>
     <p class="cl">
      Reading | ################################################## | 100% 0.06s
     </p>
     <p class="cl">
      avrdude: verifying . . .
     </p>
     <p class="cl">
      avrdude: 108 bytes of flash verified
     </p>
     <p class="cl">
      avrdude: safemode: Fuses OK
     </p>
     <p class="cl">
      avrdude done.  Thank you.
     </p>
     <p class="cll">
      C:\&gt;
     </p>
    </pre>
    <p class="calibre8">
     Let’s take a look at the code to see how this program works:
    </p>
    <pre>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ // Project 0 - Blinking an LED
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ DDRB = 0b00001000; // Set PB3 as output
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     The first line of
     <i class="calibre5">
      main.c
     </i>
     <!--<ccust1>1</ccust1>-->
     ❶ is a
     <i class="calibre5">
      comment
     </i>
     naming the program and describing what it’s intended to accomplish. When writing programs, it’s a good idea to add comments like these explaining how to use the program or highlighting other important details; they may prove useful when you revisit
     <span id="p38">
     </span>
     your code or share it with others. Comments can be any length you like, and you can use them anywhere in your program. To add a comment on a single line, enter two forward slashes and then the comment, like this:
    </p>
    <pre>
     <p class="cls">
      // Project 0 - Blinking an LED
     </p>
    </pre>
    <p class="calibre8">
     The forward slashes tell the compiler in the software toolchain to ignore the rest of the text on the line when compiling the program. In your own projects, you can include comments spanning two or more lines by entering the characters
     <code class="calibre23">
      /*
     </code>
     on a line before the comment text, then ending the comment with the characters
     <code class="calibre23">
      */
     </code>
     , as follows:
    </p>
    <pre>
     <p class="clf">
      /*
     </p>
     <p class="cl">
      Project 0
     </p>
     <p class="cl">
      Blinking an LED
     </p>
     <p class="cl">
      by Mary Smith, created 20/10/2022
     </p>
     <p class="cll">
      */
     </p>
    </pre>
    <p class="calibre8">
     Returning to
     <i class="calibre5">
      main.c
     </i>
     , the
     <code class="calibre23">
      include
     </code>
     statements
     <!--<ccust1>2</ccust1>-->
     ❷ tell the compiler to look inside a library file, like
     <i class="calibre5">
      avr/io.h
     </i>
     , for more information required to compile the program. There are many libraries, each allowing you to use different functions in your code, and you can even create your own if necessary. You’ll learn about that in
     <a class="url" href="nsp-boxall502581-0020.xhtml#ch10">
      Chapter 10
     </a>
     .
    </p>
    <p class="calibre8">
     All the instructions to run the program appear between the curly brackets after
     <code class="calibre23">
      int main(void)
     </code>
     , where the main section of the program begins
     <!--<ccust1>3</ccust1>-->
     ❸. Within these brackets, the program configures certain
     <i class="calibre5">
      parameters
     </i>
     of the microcontroller—that is, certain settings to make various operations take place. First, the program tells the microcontroller which physical pins will be inputs or outputs
     <!--<ccust1>4</ccust1>-->
     ❹. You hooked your LED up to pin 2, which the AVR knows as PB3, so the code activates that pin as an output. (Don’t worry if this is a little confusing right now; I’ll cover inputs and outputs in detail in the next few chapters.)
    </p>
    <p class="calibre8">
     Finally, the code between the curly brackets after
     <code class="calibre23">
      while(1)
     </code>
     <!--<ccust1>5</ccust1>-->
     ❺ should execute repeatedly, blinking the LED by continuously toggling whether pin 2 outputs a 1 or a 0, until the microcontroller loses power or you reset it. A 1 supplies power to the LED, so that should turn the LED on, while a 0 should turn the LED off.
    </p>
    <p class="calibre8">
     To experiment with the speed of the LED’s blinking, go back to
     <i class="calibre5">
      main.c
     </i>
     and replace
     <code class="calibre23">
      1000
     </code>
     in the two lines that read
     <code class="calibre23">
      _delay_ms(1000);
     </code>
     with any non-negative number you like. Then save the
     <i class="calibre5">
      main.c
     </i>
     file and rerun the
     <code class="b">
      make flash
     </code>
     command. The LED should blink faster or slower, depending on the value you use.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0405">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0405">
      What If It Didn’t Work?
     </a>
    </h3>
    <p class="paft">
     If there is an error in your code, the compiler will indicate which line in the code contains the error, or a line very close to it. For example, here’s what happened when I ran the
     <code class="calibre23">
      make flash
     </code>
     command with a spelling mistake in line 10 of the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     code. The compiler found the error and gave the resulting output:
    </p>
    <pre>
     <p class="clf">
      <span id="p39">
      </span>
      avr-gcc -Wall -Os -Iusbdrv -DF_CPU=1000000 -mmcu=attiny85 -c main.c -o main.o
     </p>
     <p class="cl">
      main.c: In function 'main':
     </p>
     <p class="cl">
      main.c:17: error: 'return' undeclared (first use in this function)
     </p>
     <p class="cl">
      main.c:17: error: (Each undeclared identifier is reported only once
     </p>
     <p class="cl">
      main.c:17: error: for each function it appears in.)
     </p>
     <p class="cl">
      main.c:17: error: expected ';' before numeric constant
     </p>
     <p class="cl">
      make: *** [main.o] Error 1
     </p>
     <p class="cll">
      C:&gt;
     </p>
    </pre>
    <p class="calibre8">
     If this happens to you, open the
     <i class="calibre5">
      main.c
     </i>
     file in your text editor and locate and fix the mistake before trying another upload. To compile your program for this purpose without uploading it, just run the
     <code class="b">
      make
     </code>
     command by itself in the terminal window.
    </p>
    <p class="calibre8">
     Running
     <code class="calibre23">
      make
     </code>
     is a good way to check for errors like typos in the code, but it may not help you catch errors in logic—that is, whether you’ve correctly told the microcontroller what you want it to do. As a general rule, remember that even if your program compiles, it may not behave as you expect if you don’t carefully plan your instructions to the microcontroller before you write the code.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0402">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0402">
     Controlling Digital Outputs
    </a>
   </h2>
   <p class="paft">
    Now that you’ve seen the electronic components you’ll use in this book, let’s talk a bit more about the digital output pins on the ATtiny85 and the ATmega328P-PU.
   </p>
   <p class="calibre8">
    To recap, a digital output pin is a source of electrical current that you can control; it can be either on or off. On the ATtiny85 up to six pins can operate as outputs, and on the ATmega328P-PU up to eight pins can operate as outputs. I say “up to” because some pins can have more than one function, depending on how you set them up. I’ll explain how to select pin functions later in this chapter.
   </p>
   <p class="calibre8">
    Each output pin offers a maximum amount of current. On the ATtiny85, that maximum is 40 mA. However, the total maximum current you can run through the IC is 200 mA. Drawing too much current can cause problems, so to avoid any issues, assume you can have a maximum of 20 mA per output pin on the ATtiny85 and the ATmega328P-PU. Keep these ratings in the back of your mind when creating your own projects; all the projects in this book are designed to avoid this problem.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0406">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0406">
      Hardware Registers
     </a>
    </h3>
    <p class="paft">
     The key to understanding digital outputs is to learn about the
     <i class="calibre5">
      hardware registers
     </i>
     . Our AVR microcontrollers all have multiple registers that store information related to all the possible settings for the microcontroller’s operations. The numerical values placed inside these registers control digital outputs.
    </p>
    <p class="calibre8">
     The first AVR register to consider is called the
     <i class="calibre5">
      DDR
     </i>
     , for
     <i class="calibre5">
      data-direction register
     </i>
     . This is used to tell the microcontroller which pins are outputs and which are inputs. Some microcontrollers, such as the ATtiny85, will have
     <span id="p40">
     </span>
     only one DDR register, and some, like the ATmega328P-PU, will have more. The second register to consider is called
     <i class="calibre5">
      PORT
     </i>
     . You’ll use this to set which pins are on or off.
    </p>
    <p class="calibre8">
     Each register is 8 bits in size, where a bit can be either a 0 or a 1, just like a binary number. Each bit relates to a physical pin on the microcontroller. In the DDR
     <i class="calibre5">
      x
     </i>
     registers, 1s indicate that a pin is an output and 0s indicate that a pin is an input. In the PORT
     <i class="calibre5">
      x
     </i>
     registers, 1s indicate that a pin is on and 0s indicate that a pin is off.
    </p>
    <p class="calibre8">
     You can find out how many pins and registers are available by looking at the data sheet for your microcontroller (you can download the ATtiny85’s data sheet from the Microchip website at
     <a class="url-i" href="https://www.microchip.com/wwwproducts/en/ATtiny85">
      https://www.microchip.com/wwwproducts/en/ATtiny85
     </a>
     ). For example, the diagram in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02009">
      Figure 2-9
     </a>
     shows that there is one PORT register on the ATtiny85: the PORTB register, which spans pins 5, 6, 7, 3, 2, and 1.
    </p>
    <div class="figure" id="f02009">
     <p class="fig">
      <img alt="Diagram of the ATtiny85 microcontroller’s pins and their functions" height="201" src="images/nsp-boxall502581-f02009.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-9:
       </span>
       Pinouts and PORT registers for the ATtiny85
      </p>
     </div>
    </div>
    <p class="calibre8">
     PORT register names are usually abbreviated on diagrams and data sheets; in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02009">
      Figure 2-9
     </a>
     , the PORTB register is referred to as PB, with each pin labeled as PB
     <i class="calibre5">
      x
     </i>
     , where
     <i class="calibre5">
      x
     </i>
     is the number of the pin. You’ll refer to this register as
     <code class="calibre23">
      PORTB
     </code>
     in your code. The matching DDR register is called DDRB, as it controls the data direction for PORTB. Please note that you can only use pins PB0 through PB4, as PB5 has other functions, which we’ll examine later.
    </p>
    <p class="calibre8">
     To set some of the pins in the DDRB register to outputs, just set the respective bits to 1s. As an example, let’s revisit the code from
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     :
    </p>
    <pre>
     <p class="clf">
      // Project 0 - Blinking an LED
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ DDRB = 0b00001000;
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p41">
     </span>
     This code sets the physical pin 2 to an output
     <!--<ccust1>1</ccust1>-->
     ❶. To set all the PORTB pins to outputs, you could use:
    </p>
    <pre>
     <p class="cls">
      DDRB = 0b11111111;
     </p>
    </pre>
    <p class="calibre8">
     Let’s examine how this works. The physical pins of the DDRB register of your ATtiny85 are 1, 3, 2, 7, 6, and 5. Each pin corresponds to a single bit in the register; from left to right, those pins are bits 5, 3, 4, 2, 1, and 0, respectively. So, for example, to set physical pin 6 (PB1) as an output and the rest as inputs you would use:
    </p>
    <pre>
     <p class="clf">
      // Bits: 76543210
     </p>
     <p class="cl">
      // Pins: 44132765
     </p>
     <p class="cll">
      DDRB = 0b00000010;
     </p>
    </pre>
    <p class="calibre8">
     And, as we saw in the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     code, to set physical pin 2 (PB3) as an output and the rest as inputs you would use:
    </p>
    <pre>
     <p class="clf">
      // Bits: 76543210
     </p>
     <p class="cl">
      // Pins: 44132765
     </p>
     <p class="cll">
      DDRB = 0b00001000;
     </p>
    </pre>
    <p class="calibre8">
     We call the bit on the right-hand side of the register the
     <i class="calibre5">
      first bit
     </i>
     or
     <i class="calibre5">
      least significant bit (LSB)
     </i>
     and the bit on the left-hand side the
     <i class="calibre5">
      last bit
     </i>
     or
     <i class="calibre5">
      most significant bit (MSB)
     </i>
     . This may seem backward at first, but bits are the equivalent of binary numbers, whose contents are referenced using the same method.
    </p>
    <p class="calibre8">
     Because the ATtiny85 has only six outputs, you can leave the last two bits (6 and 7) as 0s or 1s in the DDRB statement. Once you’ve set a pin to an output, use the
     <code class="calibre23">
      PORT
     </code>
     <code class="i1">
      x
     </code>
     function to switch the output on or off. To turn all the outputs on, use:
    </p>
    <pre>
     <p class="cls">
      PORTB = 0b11111111;
     </p>
    </pre>
    <p class="calibre8">
     To turn them all off, use:
    </p>
    <pre>
     <p class="cls">
      PORTB = 0b00000000;
     </p>
    </pre>
    <p class="calibre8">
     Or to turn, say, pins 3 (PB4) and 5 (PB0) on and the rest off, use:
    </p>
    <pre>
     <p class="clf">
      // Bits:   76543210
     </p>
     <p class="cl">
      // Pins:   44132765
     </p>
     <p class="cll">
      PORTB = 0b00010001;
     </p>
    </pre>
    <p class="calibre8">
     To experiment with these functions, in the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro1">
      next project
     </a>
     you’ll build a new circuit like the one in
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     , but this time with four LEDs.
    </p>
    <p class="hd" id="pro1">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro1">
      <span class="ccust1">
       Project 1: Experimenting with ATtiny85 Digital Outputs
      </span>
     </a>
    </p>
    <p class="paft">
     To practice and increase your understanding of using the ATtiny85’s DDRB and PORTB registers, in this project you’ll control four output devices
     <span id="p42">
     </span>
     (LEDs). Although blinking LEDs may seem a somewhat trivial example, the ability to control digital outputs is the foundation for controlling a wide range of objects.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0407">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0407">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You will need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATtiny85–20PU microcontroller
     </li>
     <li class="bl">
      • Four LEDs
     </li>
     <li class="bl">
      • Four 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     The circuit for this project is similar to the one in
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
      Project 0
     </a>
     , but with three more LEDs. Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02010">
      Figure 2-10
     </a>
     .
    </p>
    <div class="figure" id="f02010">
     <p class="fig">
      <img alt="Diagram of the physical circuit layout for Project 1" height="784" src="images/nsp-boxall502581-f02010.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-10:
       </span>
       A physical layout diagram of the main circuit for
       <a class="url" href="nsp-boxall502581-0012.xhtml#pro1">
        Project 1
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Once you’ve assembled your circuit, connect the USBasp programmer. Repeat the connections as shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#tab0201">
      Table 2-1
     </a>
     .
    </p>
    <p class="pcust">
     <span class="ccust">
      Note
     </span>
     If you’d like to try creating diagrams like the one in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02010">
      Figure 2-10
     </a>
     , use Autodesk Tinkercad, available at
     <a class="url-i1" href="https://www.tinkercad.com/">
      https://www.tinkercad.com/
     </a>
     .
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0408">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0408">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the folder containing the two files for
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro1">
      Project 1
     </a>
     , and enter the command
     <code class="b">
      make flash
     </code>
     . After a moment, the toolchain should compile the program file and create the required data file to
     <span id="p43">
     </span>
     upload to the microcontroller. Then the microcontroller should run the program that turns the digital outputs on and off, causing all four of the LEDs to blink.
    </p>
    <p class="calibre8">
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 1
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 2
     </i>
     folder:
    </p>
    <pre>
     <p class="clf">
      // Project 1 - Experimenting with ATtiny85 Digital Outputs
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ DDRB = 0b11111111; // Set pins as outputs
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ _delay_ms(250);
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ PORTB = 0b00011111;
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ PORTB = 0b00000000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     First we use
     <code class="calibre23">
      DDRB
     </code>
     to set all the pins to outputs
     <!--<ccust1>1</ccust1>-->
     ❶. The
     <code class="calibre23">
      _delay_ms()
     </code>
     function
     <!--<ccust1>2</ccust1>-->
     ❷ tells the microcontroller to stop everything for a set period of time. To use a delay, just enter the number of milliseconds you want the program to pause inside the parentheses:
     <code class="calibre23">
      _delay_ms(250)
     </code>
     sets the delay to 250 milliseconds. Next, we turn on the digital outputs so current will flow from the pins, through the resistors and LEDs, and then to GND, completing the electrical circuit
     <!--<ccust1>3</ccust1>-->
     ❸. After another delay we turn off the digital outputs, causing the LEDs to turn off
     <!--<ccust1>4</ccust1>-->
     ❹.
    </p>
    <p class="calibre8">
     By now you should understand how to set the pins on the ATtiny85 to outputs, turn them on and off, and create a delay. Experiment with the delay and pins by changing which LEDs turn on and off, the length of the delay, and so on.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0403">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0403">
     Using Schematic Diagrams
    </a>
   </h2>
   <p class="paft">
    <a class="url" href="nsp-boxall502581-0012.xhtml#pro0">
     Projects 0
    </a>
    and
    <a class="url" href="nsp-boxall502581-0012.xhtml#pro1">
     1
    </a>
    showed you how to build circuits using a picture and a physical layout diagram, respectively. Physical layout diagrams like the one in
    <a class="url" href="nsp-boxall502581-0012.xhtml#f02010">
     Figure 2-10
    </a>
    may seem like the easiest way to diagram a circuit, but as you add more components, direct representations make physical diagrams a real mess. Because your circuits are about to get more complicated, from now on I’ll use
    <i class="calibre5">
     schematic diagrams
    </i>
    (also known as
    <i class="calibre5">
     circuit diagrams
    </i>
    ) to illustrate them, like the one shown in
    <a class="url" href="nsp-boxall502581-0012.xhtml#f02011">
     Figure 2-11
    </a>
    .
   </p>
   <div class="figure" id="f02011">
    <p class="fig">
     <span id="p44">
     </span>
     <img alt="Example of a simple microcontroller circuit schematic" height="696" src="images/nsp-boxall502581-f02011.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 2-11:
      </span>
      An example schematic diagram
     </p>
    </div>
   </div>
   <p class="calibre8">
    Schematics are road maps that show where electrical current flows through various components, with the lines between components indicating those paths. Instead of showing components and wires, a schematic uses symbols and lines.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0409">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0409">
      Components in Schematics
     </a>
    </h3>
    <p class="paft">
     Once you know what the symbols mean, reading a schematic is easy. To begin, let’s examine the symbols for the components you’ve already used.
    </p>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02012">
      Figure 2-12
     </a>
     shows the ATtiny85 microcontroller symbol. The pin numbers are labeled clearly; don’t forget that pin 1 is at the top left on the physical chip. Other microcontrollers and ICs use similar symbols, but their size depends on the number of pins.
    </p>
    <div class="figure" id="f02012">
     <p class="fig">
      <img alt="Schematic symbol for the ATtiny85–20PU microcontroller" height="849" src="images/nsp-boxall502581-f02012.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 2-12:
       </span>
       The ATtiny85 microcontroller symbol
      </p>
     </div>
    </div>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02013">
      Figure 2-13
     </a>
     shows the resistor symbol. It’s good practice to display the resistor value and part designator along with the resistor symbol (220
     <span lang="el" xml:lang="el">
      Ω
     </span>
     and R1, in this case). This makes life a lot easier for everyone trying to make sense of the schematic, including you!
    </p>
    <div class="figure" id="f02013">
     <p class="fig">
      <span id="p45">
      </span>
      <img alt="Schematic symbol for a common resistor" src="images/nsp-boxall502581-f02013.jpg" class="calibre24"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 2-13:
       </span>
       The resistor symbol
      </p>
     </div>
    </div>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02014">
      Figure 2-14
     </a>
     shows the LED symbol. All members of the diode family share a common symbol, the triangle and vertical line, but LED symbols show two parallel arrows pointing away from the triangle to indicate that light is being emitted.
    </p>
    <div class="figure" id="f02014">
     <p class="fig">
      <img alt="Schematic symbol for a common LED" src="images/nsp-boxall502581-f02014.jpg" class="calibre25"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span>
       </span>
       <span class="calibre4">
        Figure 2-14:
       </span>
       The LED symbol
      </p>
     </div>
    </div>
    <p class="calibre8">
     Now that you have an understanding of the various component schematic symbols, I’ll show you how the wired connections between the components are shown in circuit schematics.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0410">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0410">
      Wires in Schematics
     </a>
    </h3>
    <p class="paft">
     When wires cross or connect in schematics, they are drawn in the following ways:
    </p>
    <div class="list">
     <p class="ulh">
      Crossing but not connected wires
     </p>
     <ul class="calibre10">
      <li class="ul">
       When two wires cross but are not connected, the crossing can be represented in one of two ways, as shown in
       <a class="url" href="nsp-boxall502581-0012.xhtml#f02015">
        Figure 2-15
       </a>
       . Either way is correct; it’s just a matter of preference.
       <div class="figure" id="f02015">
        <p class="fig">
         <img alt="Two ways of representing non-connecting wires in circuit schematics" height="497" src="images/nsp-boxall502581-f02015.jpg" width="1200" class="calibre11"/>
        </p>
        <div class="chapter">
         <p class="figh">
          <span class="calibre4">
           Figure 2-15:
          </span>
          Non-connecting crossed wires
         </p>
        </div>
       </div>
      </li>
      <li class="ulh1">
       Connected wires
      </li>
      <li class="ul">
       When wires are physically connected, a
       <i class="calibre5">
        junction dot
       </i>
       is drawn at the point of connection, as shown in
       <a class="url" href="nsp-boxall502581-0012.xhtml#f02016">
        Figure 2-16
       </a>
       .
       <div class="figure" id="f02016">
        <p class="fig">
         <span id="p46">
         </span>
         <img alt="Representation of connected wires in a circuit schematic" height="674" src="images/nsp-boxall502581-f02016.jpg" width="1200" class="calibre11"/>
        </p>
        <div class="chapter">
         <p class="figh">
          <span class="calibre4">
           Figure 2-16:
          </span>
          Two wires that are connected
         </p>
        </div>
       </div>
      </li>
      <li class="ulh1">
       Wire connected to ground
      </li>
      <li class="ul">
       The symbol shown in
       <a class="url" href="nsp-boxall502581-0012.xhtml#f02017">
        Figure 2-17
       </a>
       indicates when a wire is connected to ground (GND).
       <div class="figure" id="f02017">
        <p class="fig">
         <img alt="Schematic symbol for circuit ground" src="images/nsp-boxall502581-f02017.jpg" class="calibre26"/>
        </p>
        <div class="chapter">
         <p class="figh">
          <span>
          </span>
          <span class="calibre4">
           Figure 2-17:
          </span>
          The GND symbol
         </p>
        </div>
       </div>
       <p class="pcust1">
        The GND symbol at the end of a line in a schematic tells you that the wire is physically connected to the microcontroller’s GND pin. For your circuits, this is also known as the
        <i class="calibre5">
         negative
        </i>
        .
       </p>
      </li>
     </ul>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0411">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0411">
      Dissecting a Schematic
     </a>
    </h3>
    <p class="paft">
     Now that you know the symbols for the parts you’ve used so far, let’s dissect the schematic you’d draw for
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro1">
      Project 1
     </a>
     . Compare the schematic shown in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02018">
      Figure 2-18
     </a>
     with physical image of the circuit in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02010">
      Figure 2-10
     </a>
     .
    </p>
    <div class="figure" id="f02018">
     <p class="fig">
      <img alt="Schematic diagram for Project 1" height="696" src="images/nsp-boxall502581-f02018.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-18:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0012.xhtml#pro1">
        Project 1
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     The arrow with +5V written above it represents the 5 V power supply on the breadboard, and the ATtiny85 is labeled with its chip name. LEDs 1 through 4 are connected to the ATtiny85 at the same pins you saw in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02010">
      Figure 2-10
     </a>
     , and just like in the original circuit, all four resistors attached to the LEDs go to GND, pin 4 on the microcontroller. Note the dots at the junctions of R1, R2, R3, and R4, which indicate that those resistors are all connected to the same place (GND). The Xs on pins 1 and 3 in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02018">
      Figure 2-18
     </a>
     signal that those pins are not connected to anything.
    </p>
    <p class="calibre8">
     <span id="p47">
     </span>
     In this schematic, you can trace the flow of current from the power supply through the circuit to ground. Current is sourced from the 5 V power supply and enters the microcontroller. Our code then allows the current to flow from digital output pins when required. This current goes through an LED (which causes the LED to glow) and the resistor (which regulates the current) before reaching ground and completing the circuit.
    </p>
    <p class="pcust">
     <span class="ccust">
      Note
     </span>
     If you’d like to create your own computer-drawn schematics, try the open source KiCad package, available for free or with a donation from
     <a class="url-i1" href="https://www.kicad.org/">
      https://www.kicad.org/
     </a>
     .
    </p>
    <p class="calibre8">
     Along with using the ATmega328P-PU for the first time, the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro2">
      following project
     </a>
     will also put your new knowledge of reading circuit schematics to use.
    </p>
    <p class="hd" id="pro2">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro2">
      <span class="ccust1">
       Project 2: Experimenting with ATmega328P-PU Digital Outputs
      </span>
     </a>
    </p>
    <p class="paft">
     You can tell at a glance that the ATmega328P-PU has more digital outputs than the ATtiny85. The pinout diagram from the data sheet in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02019">
      Figure 2-19
     </a>
     gives the details.
    </p>
    <div class="figure" id="f02019">
     <p class="fig">
      <img alt="Diagram of the ATmega328P-PU’s pins and their functions" height="805" src="images/nsp-boxall502581-f02019.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-19:
       </span>
       The ATmega328P-PU pinout and port register diagram
      </p>
     </div>
    </div>
    <p class="calibre8">
     There are two registers you can use for digital outputs: PORTB (PB) and PORTD (PD). For this and the following few projects, you’ll use the PORTB register. In this project, you’ll put the ATmega328P-PU’s digital outputs to work using more LEDs.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0412">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0412">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     You will need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      <span id="p48">
      </span>
      • Eight LEDs
     </li>
     <li class="bl">
      • Eight 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     I’ve provided both a physical layout diagram and the schematic for the required circuit, which you can use to assemble your circuit. The diagram in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02020">
      Figure 2-20
     </a>
     indicates the physical connections you see with your own eyes, and the schematic in
     <a class="url" href="nsp-boxall502581-0012.xhtml#f02021">
      Figure 2-21
     </a>
     indicates the same electrical connections between the various components in a more compact and easier-to-follow form.
    </p>
    <div class="figure" id="f02020">
     <p class="fig">
      <img alt="Diagram of the physical circuit layout for Project 2" height="445" src="images/nsp-boxall502581-f02020.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-20:
       </span>
       Diagram for
       <a class="url" href="nsp-boxall502581-0012.xhtml#pro2">
        Project 2
       </a>
      </p>
     </div>
    </div>
    <div class="figure" id="f02021">
     <p class="fig">
      <img alt="Schematic diagram for Project 2" height="1200" src="images/nsp-boxall502581-f02021.jpg" width="1147" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 2-21:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0012.xhtml#pro2">
        Project 2
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p49">
     </span>
     Connect your USBasp programmer to the circuit, then connect jumper wires between the programmer and the microcontroller using the information in
     <a class="url" href="nsp-boxall502581-0012.xhtml#tab0202">
      Table 2-2
     </a>
     . Take note of the connections, as they will be the same every time you program an ATmega328P-PU microcontroller.
    </p>
    <table id="tab0202" class="calibre13">
     <thead class="calibre14">
      <tr class="calibre15">
       <th colspan="2" class="calibre16">
        <p class="th1">
         <span class="calibre4">
          Table 2-2
         </span>
         : USBasp to ATmega328P-PU Connections
        </p>
       </th>
      </tr>
      <tr class="calibre15">
       <th scope="col" class="calibre16">
        <p class="tch">
         USBasp pin
        </p>
       </th>
       <th scope="col" class="calibre16">
        <p class="tch">
         ATmega328P-PU pin
        </p>
       </th>
      </tr>
     </thead>
     <tbody class="calibre17">
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         RST
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         1
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         GND
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         8
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         VCC
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         7
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         SCK
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         19
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         MISO
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         18
        </p>
       </td>
      </tr>
      <tr class="calibre15">
       <td class="calibre18">
        <p class="td">
         MOSI
        </p>
       </td>
       <td class="calibre18">
        <p class="td">
         17
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p class="calibre8">
     Before uploading code to the microcontroller, test that the programmer is communicating with the ATmega328P-PU. Connect your USBasp programmer to your computer and open a terminal window. Enter the command
     <code class="b">
      avrdude -p m328p -c usbasp -B 4
     </code>
     and press
     <span class="ac">
      enter
     </span>
     . The software toolchain should interrogate the programmer and microcontroller, and you should see the following output in your terminal:
    </p>
    <pre>
     <p class="clf">
      C:\&gt;
      <code class="b">
       avrdude -p m328p -c usbasp -B 4
      </code>
     </p>
     <p class="cl">
      avrdude: set SCK frequency to 187500 Hz
     </p>
     <p class="cl">
      avrdude: AVR device initialized and ready to accept instructions
     </p>
     <p class="cl">
      Reading | ################################################## | 100% 0.03s
     </p>
     <p class="cl">
      avrdude: Device signature = 0x1e950f
     </p>
     <p class="cl">
      avrdude: safemode: Fuses OK
     </p>
     <p class="cl">
      avrdude done.  Thank you.
     </p>
     <p class="cll">
      C:\&gt;
     </p>
    </pre>
    <p class="calibre8">
     The only difference between this
     <code class="calibre23">
      avrdude
     </code>
     command and the command used earlier to test your setup with the ATtiny85 is that we changed the microcontroller parameter
     <code class="calibre23">
      -p
     </code>
     to
     <code class="calibre23">
      m328p
     </code>
     . If you saw the correct output after entering this command, you can move forward; otherwise, review the “What If It Didn’t Work?” section on
     <a class="url" href="nsp-boxall502581-0012.xhtml#p35">
      page 35
     </a>
     .
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0413">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0413">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the folder containing the two files for
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro2">
      Project 2
     </a>
     , and enter the command
     <code class="b">
      make flash
     </code>
     . After a moment, the toolchain should compile the program file and create the required data file to upload to the microcontroller. Then the microcontroller should run the program, causing all eight of the LEDs to blink together.
    </p>
    <p class="calibre8">
     To see how this works, open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 2
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 2
     </i>
     folder.
    </p>
    <pre>
     <p class="clf">
      <span id="p50">
      </span>
      // Project 2 - Experimenting with ATmega328P-PU Digital Outputs
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b11111111; // Set PORTB register as outputs
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ PORTB = 0b11111111;
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ PORTB = 0b00000000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     The code in this project is identical to that of
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro1">
      Project 1
     </a>
     . However, because the ATmega328P-PU has a full PORTB register (that is, eight outputs), you can control all of them with the
     <code class="calibre23">
      PORTB
     </code>
     function. For some practice, change the
     <code class="calibre23">
      PORTB
     </code>
     lines to experiment with blinking LEDs. Try turning half of them on and half of them off by changing the line at
     <!--<ccust1>1</ccust1>-->
     ❶ to:
    </p>
    <pre>
     <p class="cls">
      PORTB = 0b11110000;
     </p>
    </pre>
    <p class="pcon">
     and the line at
     <!--<ccust1>2</ccust1>-->
     ❷ to:
    </p>
    <pre>
     <p class="cls">
      PORTB = 0b00001111;
     </p>
    </pre>
    <p class="calibre8">
     You can also increase the effects by adding more
     <code class="calibre23">
      PORTB
     </code>
     lines with different on/off states. Go crazy! Keep this circuit together when you’re done experimenting, since you’ll use it for the rest of this chapter.
    </p>
    <p class="calibre8">
     You’ll soon see how each bit of the PORTB register relates to a digital output on the microcontroller. However, there’s a better way to control the outputs to create complicated patterns. In the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro3">
      next project
     </a>
     , you’ll use the same circuit to control outputs more efficiently with variables, functions, bit shifting, and bitwise arithmetic.
    </p>
    <p class="hd" id="pro3">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro3">
      <span class="ccust1">
       Project 3: Bit-Shifting Digital Outputs
      </span>
     </a>
    </p>
    <p class="paft">
     In this project, you’ll learn more efficient ways to control the digital outputs. These techniques will give you more control over the outputs without excessive code, so that you don’t waste program memory in the microcontroller.
    </p>
    <p class="calibre8">
     This project uses the same hardware as
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro2">
      Project 2
     </a>
     , so you should have that set up already. Open a terminal window, navigate to the folder containing the two files for
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro3">
      Project 3
     </a>
     , and enter the command
     <code class="b">
      make flash
     </code>
     . Once
     <span id="p51">
     </span>
     again, the toolchain should process the code, and in a moment the LEDs should start blinking on and off in a repeating pattern from left to right, then from right to left, and so on.
    </p>
    <p class="calibre8">
     Now open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 3
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 2
     </i>
     folder for a closer look at how this works:
    </p>
    <pre>
     <p class="clf">
      // Project 3 - Bit-Shifting Digital Outputs
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ #define TIME 100 // Delay in milliseconds
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ uint8_t i;         // 8-bit integer variable "i"
     </p>
     <p class="cl">
      DDRB = 0b11111111; // Set PORTB register as outputs
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ for (i = 0; i &lt; 8; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ _delay_ms(TIME);
     </p>
     <p class="cl">
      PORTB = 0b00000001 &lt;&lt; i;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      <!--<ccust1>5</ccust1>-->
      ❺ for (i = 1; i &lt; 7; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      _delay_ms(TIME);
     </p>
     <p class="cl">
      PORTB = 0b10000000 &gt;&gt; i;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     This code introduces some new concepts. First, the
     <code class="calibre23">
      #define
     </code>
     macro lets you assign values to words, which are called
     <i class="calibre5">
      constant values
     </i>
     or just
     <i class="calibre5">
      constants
     </i>
     for short. Constants make it possible to reference values later in your code and make your code easier to read. For example,
     <code class="calibre23">
      #define TIME 100
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶ tells the compiler to replace the word
     <code class="calibre23">
      TIME
     </code>
     with the value 100 anywhere you use
     <code class="calibre23">
      TIME
     </code>
     in your code, as in the
     <code class="calibre23">
      __delay_ms_
     </code>
     lines
     <!--<ccust1>4</ccust1>-->
     ❹. To change the blink delay you only need to change the value in the original
     <code class="calibre23">
      #define
     </code>
     macro, and the compiler takes care of the rest. Whenever you use
     <code class="calibre23">
      #define
     </code>
     , you must place it before the main
     <code class="calibre23">
      int main(void)
     </code>
     loop in the code.
    </p>
    <p class="calibre8">
     Inside the main loop we define a
     <i class="calibre5">
      variable
     </i>
     , which that represents data. A variable’s value can change while the code is being executed, whereas the value of a constant defined by the
     <code class="calibre23">
      #define
     </code>
     macro cannot. You can think of a variable as a part of the microcontroller’s memory that stores a number you can change as needed during program execution. The first type of variable you’ll use in this book is an
     <i class="calibre5">
      integer
     </i>
     . In programming terms, this type can hold a whole number; that is, a number that can be positive, negative, or zero, without a fractional or decimal part.
    </p>
    <p class="calibre8">
     <span id="p52">
     </span>
     To define a variable, first enter the type and then the label. The line
     <code class="calibre23">
      uint8_t i;
     </code>
     <!--<ccust1>2</ccust1>-->
     ❷ defines a variable called
     <code class="calibre23">
      i
     </code>
     of type
     <code class="calibre23">
      uint8_t
     </code>
     . This type of variable can store a whole number between 0 and 255 (the
     <code class="calibre23">
      u
     </code>
     stands for
     <i class="calibre5">
      unsigned
     </i>
     ; an unsigned integer cannot store negative numbers). The letter
     <code class="calibre23">
      i
     </code>
     now represents an integer whose value you can change.
    </p>
    <p class="calibre8">
     There are six types of integer variables you can make use of:
    </p>
    <ul class="calibre10">
     <li class="blf">
      •
      <code class="calibre23">
       uint8_t
      </code>
      is an 8-bit unsigned integer (0 to 255).
     </li>
     <li class="bl">
      •
      <code class="calibre23">
       int8_t
      </code>
      is an 8-bit signed integer (–128 to 127).
     </li>
     <li class="bl">
      •
      <code class="calibre23">
       uint16_t
      </code>
      is a 16-bit unsigned integer (0 to 65,535).
     </li>
     <li class="bl">
      •
      <code class="calibre23">
       int16_t
      </code>
      is a 16-bit signed integer (–32,768 to 32,767).
     </li>
     <li class="bl">
      •
      <code class="calibre23">
       uint32_t
      </code>
      is a 32-bit unsigned integer (0 to 4,294,967,295).
     </li>
     <li class="bll">
      •
      <code class="calibre23">
       int32_t
      </code>
      is a 32-bit signed integer (–2,147,483,648 to 2,147,483,647).
     </li>
    </ul>
    <p class="calibre8">
     At first glance, you may think that the smaller integer types are redundant and that you should just use
     <code class="calibre23">
      int32_t
     </code>
     for all your integer needs. However, the larger the integer type, the more time it takes your microcontroller to process those numbers. To maximize efficiency, bear in mind the needs of your project when selecting an integer type, and use the smallest type that will accommodate the largest possible value.
    </p>
    <p class="calibre8">
     This code also introduces
     <code class="i1">
      for
     </code>
     <i class="calibre5">
      loops
     </i>
     , which allow you to repeat a section of code without retyping it. Retyping is inefficient and wastes memory;
     <code class="calibre23">
      for
     </code>
     loops simply let you set how many times the code inside the loop will repeat. There are two
     <code class="calibre23">
      for
     </code>
     loops in the
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro3">
      Project 3
     </a>
     code. Let’s look at the first one
     <!--<ccust1>3</ccust1>-->
     ❸:
    </p>
    <pre>
     <p class="clf">
      for (i = 0; i &lt; 8; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      _delay_ms(TIME);
     </p>
     <p class="cl">
      PORTB = 0b00000001 &lt;&lt; i;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     A
     <code class="calibre23">
      for
     </code>
     loop repeats the code between the curly brackets as long as a certain condition is true. In this case, this loop will repeat until the value of the variable
     <code class="calibre23">
      i
     </code>
     is 8. In the first section of the loop, we set the initial value of
     <code class="calibre23">
      i
     </code>
     to 0 using
     <code class="calibre23">
      i = 0
     </code>
     . The second section of the loop checks to see if the condition is true: in this case, if
     <code class="calibre23">
      i &lt; 8
     </code>
     . The third section of the loop keeps track of how many times the code loops;
     <code class="calibre23">
      i++
     </code>
     means “add one to the value of
     <code class="calibre23">
      i
     </code>
     after each loop.” Every time the code between the curly brackets is executed, the value of
     <code class="calibre23">
      i
     </code>
     increases by one and the code checks to see if
     <code class="calibre23">
      i
     </code>
     is less than 8. When
     <code class="calibre23">
      i
     </code>
     equals 8, the looping stops and the microcontroller moves on to the code after the
     <code class="calibre23">
      for
     </code>
     loop.
    </p>
    <p class="calibre8">
     The final concept this project introduces is
     <i class="calibre5">
      bit shifting
     </i>
     , a technique that moves the bits in a binary number to the left or right. This helps you to efficiently use binary numbers in your
     <code class="calibre23">
      PORT
     </code>
     <code class="i1">
      x
     </code>
     functions to turn the output pins on and off. The
     <code class="calibre23">
      for
     </code>
     loop at
     <!--<ccust1>3</ccust1>-->
     ❸ shifts the first bit one to the left every time the loop completes. This is faster than using the equivalent eight
     <code class="calibre23">
      PORTB
     </code>
     functions:
    </p>
    <pre>
     <p class="clf">
      <span id="p53">
      </span>
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      PORTB = 0b00000010;
     </p>
     <p class="cl">
      PORTB = 0b00000100;
     </p>
     <p class="cl">
      PORTB = 0b00001000;
     </p>
     <p class="cl">
      PORTB = 0b00010000;
     </p>
     <p class="cl">
      PORTB = 0b00100000;
     </p>
     <p class="cl">
      PORTB = 0b01000000;
     </p>
     <p class="cll">
      PORTB = 0b10000000;
     </p>
    </pre>
    <p class="calibre8">
     Instead of wasting code on such functions, you can shift the first bit to the left with
     <code class="calibre23">
      &lt;&lt;
     </code>
     or to the right with
     <code class="calibre23">
      &gt;&gt;
     </code>
     , followed by the number of bits to move. For example, to turn the first three outputs in PORTB on and off in sequence, you could enter:
    </p>
    <pre>
     <p class="clf">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      PORTB = 0b00000001 &lt;&lt; 1; // equivalent to 0b00000010
     </p>
     <p class="cll">
      PORTB = 0b00000001 &lt;&lt; 2; // equivalent to 0b00000100
     </p>
    </pre>
    <p class="calibre8">
     The
     <code class="calibre23">
      for
     </code>
     loop at
     <!--<ccust1>3</ccust1>-->
     ❸ demonstrates shifting bits to the left with
     <code class="calibre23">
      &lt;&lt; i
     </code>
     . Here,
     <code class="calibre23">
      i
     </code>
     starts with a value of 0 in the first loop, meaning the first output is on. When the code loops again,
     <code class="calibre23">
      i
     </code>
     has a value of 1, meaning the second output is on, and so forth. In the same manner, the
     <code class="calibre23">
      for
     </code>
     loop at
     <!--<ccust1>5</ccust1>-->
     ❺ turns on the LEDs from left to right with
     <code class="calibre23">
      &gt;&gt;
     </code>
     .
    </p>
    <p class="calibre8">
     You can manipulate outputs even more effectively with some deeper manipulation of the PORT
     <i class="calibre5">
      x
     </i>
     register using
     <i class="calibre5">
      bitwise arithmetic
     </i>
     . This is a way of manipulating numbers in the form of their individual bits that is directly supported by the microcontroller. Don’t let past experiences in math class scare you; it’s quite simple. The four operators you can use with numbers or variables to change the bits in a register are NOT, AND, OR, and XOR. You’ll see how they work in
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro4">
      Projects 4
     </a>
     through
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro7">
      7
     </a>
     .
    </p>
    <p class="hd" id="pro4">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro4">
      <span class="ccust1">
       Project 4: Experimenting with NOT
      </span>
     </a>
    </p>
    <p class="paft">
     The NOT (
     <code class="calibre23">
      ~
     </code>
     ) operator inverts all the bits in a number or register. If you place a tilde (
     <code class="calibre23">
      ~
     </code>
     ) in front of a number, it will be interpreted as the binary opposite. For example:
    </p>
    <pre>
     <p class="cls">
      ~0b00001111 = 0b11110000
     </p>
    </pre>
    <p class="calibre8">
     Try this yourself by replacing the main loop from
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro2">
      Project 2
     </a>
     with the following:
    </p>
    <pre>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00001111;    // PORTB pins 3, 2, 1, and 0 turned on
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cl">
      PORTB = ~0b00001111;   // PORTB pins 7, 6, 5, and 4 turned on
     </p>
     <p class="cl">
      _delay_ms(250);
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     <span id="p54">
     </span>
     After the
     <code class="calibre23">
      ~
     </code>
     line, all the pins on PORTB should be turned on. NOT (and all the other bitwise operators) is a useful tool to keep in your arsenal when planning out projects.
    </p>
    <p class="hd" id="pro5">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro5">
      <span class="ccust1">
       Project 5: Experimenting with AND
      </span>
     </a>
    </p>
    <p class="paft">
     The AND (
     <code class="calibre23">
      &amp;
     </code>
     ) operator compares two binary numbers and returns a new binary number. If both numbers have 1s at the same position, the new number will have a 1 at that position, and the other bits will be 0s. For example:
    </p>
    <pre>
     <p class="clf">
      0b00100010 &amp;
     </p>
     <p class="cl">
      0b10101011
     </p>
     <p class="cll">
      = 0b00100010
     </p>
    </pre>
    <p class="calibre8">
     AND is useful when you only want to turn outputs on depending on a certain value.
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro5">
      Project 5
     </a>
     demonstrates this by displaying binary numbers from 0 to 255. Use the same circuit from
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro3">
      Project 3
     </a>
     , and open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 5
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 2
     </i>
     folder:
    </p>
    <pre>
     <p class="clf">
      // Project 5 - AND &amp; Demonstration
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      #define TIME 5              // Delay in milliseconds
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;                // 8-bit integer variable "i"
     </p>
     <p class="cl">
      DDRB = 0b11111111;        // Set PORTB register as outputs
     </p>
     <p class="cl">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      for (i = 0; i &lt; 256; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      _delay_ms(TIME);
     </p>
     <p class="cl">
      PORTB = 0b11111111 &amp; i; // Displays value of i in binary using LEDs
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     In this code, the
     <code class="calibre23">
      for
     </code>
     loop counts from 0 to 255. Every time the code loops, it performs an AND on
     <code class="calibre23">
      0b11111111
     </code>
     and the variable
     <code class="calibre23">
      i
     </code>
     and sets
     <code class="calibre23">
      PORTB
     </code>
     to the result of the operation. For example, let’s say
     <code class="calibre23">
      i
     </code>
     has a value of 9, which is
     <code class="calibre23">
      0b00001001
     </code>
     . The result of
     <code class="calibre23">
      0b00001001 &amp; 0b11111111
     </code>
     will be
     <code class="calibre23">
      0b00001001
     </code>
     because the bits in the ones and eights columns match. Thus, the
     <code class="calibre23">
      PORTB
     </code>
     setting will be
     <code class="calibre23">
      0b00001001
     </code>
     and all the LEDs for 1 and 4 will turn on.
    </p>
    <p class="hd" id="pro6">
     <span class="page" id="p55">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro6">
      <span class="ccust1">
       Project 6: Experimenting with OR
      </span>
     </a>
    </p>
    <p class="paft">
     The OR (
     <code class="calibre23">
      |
     </code>
     ) operator compares two binary numbers and returns another binary number with 1s in any position where either operand had a bit set to 1. For example:
    </p>
    <pre>
     <p class="clf">
      0b00100110 |
     </p>
     <p class="cl">
      0b10101011
     </p>
     <p class="cll">
      = 0b10101111
     </p>
    </pre>
    <p class="calibre8">
     This operator is useful when you want to turn outputs on when bits in either of two numbers have a certain value. To try it out, use the same circuit from
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro3">
      Project 3
     </a>
     and open the
     <i class="calibre5">
      main.c
     </i>
     file in the
     <i class="calibre5">
      Project 6
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 2
     </i>
     folder:
    </p>
    <pre>
     <p class="clf">
      // Project 6 - Experimenting with OR
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      #define TIME 50      // Delay in milliseconds
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;         // 8-bit integer variable "i"
     </p>
     <p class="cl">
      DDRB = 0b11111111; // Set PORTB register as outputs
     </p>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      for (i = 0; i &lt; 255; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      _delay_ms(TIME);
     </p>
     <p class="cl">
      PORTB = 0b00001111 | i;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     The main loop counts from 0 to 255, as in the previous example. Every time the code loops, it performs an OR on
     <code class="calibre23">
      0b00001111
     </code>
     and the variable
     <code class="calibre23">
      i
     </code>
     and sets
     <code class="calibre23">
      PORTB
     </code>
     to the result of the operation. If
     <code class="calibre23">
      i
     </code>
     has a value of, for example, 0, which is
     <code class="calibre23">
      0b00000000
     </code>
     , the result of
     <code class="calibre23">
      0b00001111 | 0b00000000
     </code>
     will be
     <code class="calibre23">
      0b00001111
     </code>
     . Thus, the
     <code class="calibre23">
      PORTB
     </code>
     setting will be
     <code class="calibre23">
      0b0001111
     </code>
     , and the four LEDs on the right side will stay on.
    </p>
    <p class="calibre8">
     As the value of
     <code class="calibre23">
      i
     </code>
     increases, the number of bits in
     <code class="calibre23">
      i
     </code>
     increases and more LEDs will turn on. For example, when
     <code class="calibre23">
      i
     </code>
     has a value of 128, or
     <code class="calibre23">
      0b10000000
     </code>
     , the resulting
     <code class="calibre23">
      PORTB
     </code>
     is
     <code class="calibre23">
      0b10001111
     </code>
     . Load this code onto your AVR to see it in action, then experiment with the code and create your own OR situations to practice.
    </p>
    <p class="hd" id="pro7">
     <span class="page" id="p56">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro7">
      <span class="ccust1">
       Project 7: Experimenting with XOR
      </span>
     </a>
    </p>
    <p class="paft">
     The final operator, XOR (
     <code class="calibre23">
      ^
     </code>
     ), compares the same bits in two numbers and returns a new binary number. Anywhere the two numbers had opposite bits in the same position, the new number will have a 1; anywhere the two numbers had identical bits, the new number will have a 0. For example:
    </p>
    <pre>
     <p class="clf">
      0b00100110 ^
     </p>
     <p class="cl">
      0b10101011
     </p>
     <p class="cll">
      = 0b10001101
     </p>
    </pre>
    <p class="calibre8">
     XOR operators are useful when you want to turn outputs on when bits in two numbers have different values. To see how this works, use the same circuit from
     <a class="url" href="nsp-boxall502581-0012.xhtml#pro3">
      Project 3
     </a>
     and open the
     <i class="calibre5">
      main.c
     </i>
     file located in the
     <i class="calibre5">
      Project 7
     </i>
     subfolder of the
     <i class="calibre5">
      Chapter 2
     </i>
     folder:
    </p>
    <pre>
     <p class="clf">
      // Project 7 - Experimenting with XOR
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #define TIME 250     // Delay in milliseconds
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      uint8_t i;         // 8-bit integer variable "i"
     </p>
     <p class="cl">
      DDRB = 0b11111111; // Set PORTB register as outputs
     </p>
     <p class="clf">
      for(;;)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      for (i = 0; i &lt; 255; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      _delay_ms(TIME);
     </p>
     <p class="cl">
      PORTB = 0b11111111 ^ i;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </pre>
    <p class="calibre8">
     Once again, the code’s main loop counts from 0 to 255. Every time the code loops, it performs an XOR on
     <code class="calibre23">
      0b11111111
     </code>
     and the variable
     <code class="calibre23">
      i
     </code>
     and sets
     <code class="calibre23">
      PORTB
     </code>
     to the result of the operation. For example, if
     <code class="calibre23">
      i
     </code>
     has a value of 15, or
     <code class="calibre23">
      0b00001111
     </code>
     , the result of
     <code class="calibre23">
      0b11111111 ^ 0b00001111
     </code>
     is
     <code class="calibre23">
      0b11110000
     </code>
     .
    </p>
    <p class="calibre8">
     When you run this code on your AVR, it should demonstrate counting in binary from 0 to 255. However, in this case the LEDs are lit in an inverse fashion—that is, numbers are shown with LEDs that are off, not on.
    </p>
    <p class="calibre8">
     As this chapter concludes, I encourage you to experiment with the code samples. Enjoy creating patterns, learning about bitwise arithmetic, and bit shifting using your newfound knowledge. In the
     <a class="url" href="nsp-boxall502581-0013.xhtml#ch03">
      next chapter
     </a>
     , you’ll learn to use the inputs of your microcontrollers to create interactive devices.
    </p>
   </div>
  </div>
 </div>
</div></body></html>