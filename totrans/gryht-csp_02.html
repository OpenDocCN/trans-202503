<html><head></head><body>
<p id="filepos243384" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">3</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">FUZZING SOAP ENDPOINTS</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">As a penetration tester, you may run into applications or servers that offer programmatic API access via SOAP endpoints. SOAP, or Simple Object Access Protocol, is a common enterprise technology that enables language-agnostic access to programming APIs. Generally speaking, SOAP is used over the HTTP protocol, and it uses XML to organize the data sent to and from the SOAP server. The Web Service Description Language (WSDL) describes the methods and functionality exposed through SOAP endpoints. By default, SOAP endpoints expose WSDL XML documents that clients can easily parse so that they can interface with the SOAP endpoints, and C# has several classes that make this possible.</p><p class="calibre_6"> This chapter builds on your knowledge of how to programmatically craft HTTP requests to detect XSS and SQL injection vulnerabilities, except that it focuses on SOAP XML instead. This chapter also shows you how to write a small fuzzer to download and parse the WSDL file exposed by a SOAP endpoint and then use the information in the WSDL file to generate HTTP requests for the SOAP service. Ultimately, you’ll be able to systematically and automatically look for possible SQL injection vulnerabilities in SOAP methods.</p><p id="filepos244969" class="calibre_10"><span class="calibre3"><span class="bold">Setting Up the Vulnerable Endpoint</span></span></p><p class="calibre_11">For this chapter, you’ll use a vulnerable endpoint in a preconfigured virtual appliance called <span class="italic">CsharpVulnSoap</span> (which should have a file extension of <span class="italic">.ova</span>) available on the VulnHub website (<a href="http://www.vulnhub.com/"><span class="italic">http://www.vulnhub.com/</span></a>). After downloading the appliance, you can import it into VirtualBox or VMware on most operating systems by double-clicking the file. Once the appliance is installed, log in with a password of <span class="italic">password</span> or use a Guest session to open a terminal. From there, enter <span class="calibre4"><span class="bold">ifconfig</span></span> to find the virtual appliance’s IP address. By default, this appliance will be listening on a host-only interface, unlike in previous chapters where we bridged the network interfaces.</p><p class="calibre_6">After bringing the endpoint up in a web browser, as shown in <a href="#filepos246543">Figure 3-1</a>, you can use the menu items on the left side of the screen (AddUser, ListUsers, GetUser, and DeleteUser) to see what the functions exposed by the SOAP endpoint return when used. Navigating to <span class="italic">http://&lt;ip&gt;/Vulnerable.asmx?WSDL</span> should present you with the WSDL document describing the available functions in a parseable XML file. Let’s dig into the structure of this document.</p><p class="calibre_22"><img src="images/00030.jpg" class="calibre_31"/></p><p id="filepos246543" class="calibre_15"><span class="calibre4"><span class="italic">Figure 3-1: The vulnerable endpoint as seen from Firefox</span></span></p><p id="filepos246673" class="calibre_10"><span class="calibre3"><span class="bold"> Parsing the WSDL</span></span></p><p class="calibre_11">WSDL XML documents are a bit complicated. Even a simple WSDL document like the one we’ll parse is not trivial. However, because C# has excellent classes for parsing and consuming XML files, getting the WSDL parsed correctly and into a state that lets us interact with the SOAP services in an object-oriented fashion is pretty bearable.</p><p class="calibre_6">A WSDL document is essentially a bunch of XML elements that relate to one another in a logical way, from the bottom of the document to the top. At the bottom of the document, you interact with the <span class="italic">service</span> to make a request to the endpoint. From the service, you have the notion of <span class="italic">ports</span>. These ports point to a <span class="italic">binding</span>, which in turn points to a <span class="italic">port type</span>. The port type contains the <span class="italic">operations</span> (or <span class="italic">methods</span>) available on that endpoint. The operations contain an <span class="italic">input</span> and an <span class="italic">output</span>, which both point to a <span class="italic">message</span>. The message points to a <span class="italic">type</span>, and the type contains the parameters required to call the method. <a href="#filepos248062">Figure 3-2</a> explains this concept visually.</p><p class="calibre_22"><img src="images/00011.jpg" class="calibre_32"/></p><p id="filepos248062" class="calibre_15"><span class="calibre4"><span class="italic">Figure 3-2: The basic logical layout of a WSDL document</span></span></p><p class="calibre_6">Our WSDL class constructor will work in reverse order. First, we’ll create the constructor, and then we’ll create a class to handle parsing each part of the WSDL document, from types to services.</p><p id="filepos248438" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a Class for the WSDL Document</span></span></span></p><p class="calibre_11">When you’re parsing WSDL programmatically, it’s easiest to start at the top of the document with the SOAP types and work your way down the document. Let’s create a class called <span class="calibre4">WSDL</span> that encompasses the WSDL document. The constructor is relatively simple, as shown in <a href="#filepos249737">Listing 3-1</a>.</p><blockquote class="calibre_14"><span class="calibre4">public WSDL (XmlDocument doc)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> XmlNamespaceManager nsManager = new ➊XmlNamespaceManager(doc.NameTable);</span><br class="calibre5"/><span class="calibre4"> nsManager.➋AddNamespace("wsdl", doc.DocumentElement.NamespaceURI);</span><br class="calibre5"/><span class="calibre4"> nsManager.AddNamespace("xs", "http://www.w3.org/2001/XMLSchema");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ParseTypes(doc, nsManager);</span><br class="calibre5"/><span class="calibre4"> ParseMessages(doc, nsManager);</span><br class="calibre5"/><span class="calibre4"> ParsePortTypes(doc, nsManager);</span><br class="calibre5"/><span class="calibre4"> ParseBindings(doc, nsManager);</span><br class="calibre5"/><span class="calibre4"> ParseServices(doc, nsManager);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos249737" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-1: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">WSDL</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class constructor</span></span></p><p class="calibre_6">The constructor of our <span class="calibre4">WSDL</span> class calls just a handful of methods (which we’ll write next), and it expects the retrieved XML document that contains all the definitions of the web service as a parameter. The first thing we need to do is define the XML namespaces we’ll be referencing while using XPath queries (which are covered in <a href="#filepos253495">Listing 3-3</a> and later listings) when we implement the parsing methods. To do this, we create a new <span class="calibre4">XmlNamespaceManager</span> ➊ and use the <span class="calibre4">AddNamespace()</span> method ➋ to add two namespaces, <span class="calibre4">wsdl</span> and <span class="calibre4">xs</span>. Then we call the methods that will parse the elements of the WSDL document, starting with types and working our way down to services. Each method takes two arguments: the WSDL document and the namespace manager.</p><p class="calibre_6">We also need access to a few properties of the <span class="calibre4">WSDL</span> class that correspond to the methods called in the constructor. Add the properties shown in <a href="#filepos251619">Listing 3-2</a> to the WSDL class.</p><blockquote class="calibre_14"><span class="calibre4">public List&lt;SoapType&gt; Types { get; set; }</span><br class="calibre5"/><span class="calibre4">public List&lt;SoapMessage&gt; Messages { get; set; }</span><br class="calibre5"/><span class="calibre4">public List&lt;SoapPortType&gt; PortTypes { get; set; }</span><br class="calibre5"/><span class="calibre4">public List&lt;SoapBinding&gt; Bindings { get; set; }</span><br class="calibre5"/><span class="calibre4">public List&lt;SoapService&gt; Services { get; set; }</span></blockquote><p id="filepos251619" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-2: Public properties of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">WSDL</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">These properties of the <span class="calibre4">WSDL</span> class are consumed by the fuzzer (which is why they are public) and by the methods called in the constructor. The properties are lists of the SOAP classes we’ll implement in this chapter.</p><p id="filepos252131" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Writing the Initial Parsing Methods</span></span></span></p><p class="calibre_11">First, we’ll write the methods that are called in <a href="#filepos249737">Listing 3-1</a>. Once we have those methods implemented, we’ll move on to create the classes each method relies on. This is going to be a bit of work, but we’ll get through it together!</p><p class="calibre_6">We’ll start by implementing the first method called in <a href="#filepos249737">Listing 3-1</a>, <span class="calibre4">ParseTypes()</span>. All the methods called from the constructor are relatively simple and will look similar to <a href="#filepos253495">Listing 3-3</a>.</p><blockquote class="calibre_14"><span class="calibre4">private void ParseTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> this.Types = new List&lt;SoapType&gt;();</span><br class="calibre5"/><span class="calibre4"> string xpath = ➊"/wsdl:definitions/wsdl:types/xs:schema/xs:element";</span><br class="calibre5"/><span class="calibre4"> XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode type in nodes)</span><br class="calibre5"/><span class="calibre4"> this.Types.Add(new SoapType(type));</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos253495" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-3: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ParseTypes()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method called in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">WSDL</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class constructor</span></span></p><p class="calibre_6"> Because these methods are only called internally in the <span class="calibre4">WSDL</span> constructor, we use the <span class="calibre4">private</span> keyword so that only the <span class="calibre4">WSDL</span> class can access them. The <span class="calibre4">ParseTypes()</span> method accepts a WSDL document and the namespace manager (used to resolve namespaces in the WSDL document) as arguments. Next, we instantiate a new <span class="calibre4">List</span> object and assign it to the <span class="calibre4">Types</span> property. We then iterate over the XML elements in the WSDL using the XPath facilities available to XML documents in C#. XPath lets a programmer traverse and consume an XML document based on node paths within the document. In this example, we use an XPath query ➊ to enumerate all the SOAP <span class="calibre4">type</span> nodes from the document using the <span class="calibre4">SelectNodes()</span> method. Then we iterate over those SOAP types and pass each node to the <span class="calibre4">SoapType</span> class constructor, which is one of the classes we’ll implement after entering the initial parsing methods. Finally, we add the newly instantiated <span class="calibre4">SoapType</span> objects to the <span class="calibre4">SoapType</span> list property of the <span class="calibre4">WSDL</span> class.</p><p class="calibre_6">Easy enough, right? We’ll employ this pattern of using an XPath query to iterate over specific nodes a few more times to consume a few other types of nodes we need from the WSDL document. XPath is quite powerful and is great for working with the C# language in general.</p><p class="calibre_6">Now we’ll implement the next method called in the <span class="calibre4">WSDL</span> constructor to parse the WSDL document, <span class="calibre4">ParseMessages()</span>, as detailed in <a href="#filepos256350">Listing 3-4</a>.</p><blockquote class="calibre_14"><span class="calibre4">private void ParseMessages(XmlDocument wsdl, XmlNamespaceManager nsManager)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> this.Messages = new List&lt;SoapMessage&gt;();</span><br class="calibre5"/><span class="calibre4"> string xpath = ➊"/wsdl:definitions/wsdl:message";</span><br class="calibre5"/><span class="calibre4"> XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode node in nodes)</span><br class="calibre5"/><span class="calibre4"> this.Messages.Add(new SoapMessage(node));</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos256350" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-4: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ParseMessages()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method called in the WSDL class constructor</span></span></p><p class="calibre_6">First, we need to instantiate and assign a new <span class="calibre4">List</span> to hold the <span class="calibre4">SoapMessage</span> objects. (<span class="calibre4">SoapMessage</span> is a class we’ll implement in “<a href="#filepos270075">Creating the SoapMessage Class to Define Sent Data</a>” on <a href="#filepos243384">page 60</a>.) Using an XPath query ➊ to select the message nodes from the WSDL document, we iterate over the nodes returned by the <span class="calibre4">SelectNodes()</span> method and pass them to the <span class="calibre4">SoapMessage</span> constructor. These newly instantiated objects are added to the <span class="calibre4">Messages</span> property of the <span class="calibre4">WSDL</span> class for later consumption.</p><p class="calibre_6">The next few methods called from the <span class="calibre4">WSDL</span> class are similar to the previous two. By now, they should seem relatively straightforward to you, given how the previous two methods have worked. These methods are all detailed in <a href="#filepos259460">Listing 3-5</a>.</p><blockquote class="calibre_14"><span class="calibre4">private void ParsePortTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> this.PortTypes = new List&lt;SoapPortType&gt;();</span><br class="calibre5"/><span class="calibre4"> string xpath = "/wsdl:definitions/wsdl:portType";</span><br class="calibre5"/><span class="calibre4"> XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode node in nodes)</span><br class="calibre5"/><span class="calibre4"> this.PortTypes.Add(new SoapPortType(node));</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">private void ParseBindings(XmlDocument wsdl, XmlNamespaceManager nsManager)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> this.Bindings = new List&lt;SoapBinding&gt;();</span><br class="calibre5"/><span class="calibre4"> string xpath = "/wsdl:definitions/wsdl:binding";</span><br class="calibre5"/><span class="calibre4"> XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode node in nodes)</span><br class="calibre5"/><span class="calibre4"> this.Bindings.Add(new SoapBinding(node));</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">private void ParseServices(XmlDocument wsdl, XmlNamespaceManager nsManager)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> this.Services = new List&lt;SoapService&gt;();</span><br class="calibre5"/><span class="calibre4"> string xpath = "/wsdl:definitions/wsdl:service";</span><br class="calibre5"/><span class="calibre4"> XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode node in nodes)</span><br class="calibre5"/><span class="calibre4"> this.Services.Add(new SoapService(node));</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos259460" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-5: The rest of the initial parsing methods in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">WSDL</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">To fill the <span class="calibre4">PortTypes</span>, <span class="calibre4">Bindings</span>, and <span class="calibre4">Services</span> properties, we use XPath queries to find and iterate over the relevant nodes; then we instantiate specific SOAP classes, which we’ll implement next, and add them to the lists so that we can access them later when we need to build the WSDL fuzzer logic.</p><p class="calibre_6">That’s it for the <span class="calibre4">WSDL</span> class. A constructor, a handful of properties to store data relevant to the <span class="calibre4">WSDL</span> class, and some methods to parse out a WSDL document are all that you need to get started. Now we need to implement the supporting classes. Within the parsing methods, we used some classes that haven’t yet been implemented (<span class="calibre4">SoapType</span>, <span class="calibre4">SoapMessage</span>, <span class="calibre4">SoapPortType</span>, <span class="calibre4">SoapBinding</span>, and <span class="calibre4">SoapService</span>). We’ll start with the <span class="calibre4">SoapType</span> class.</p><p id="filepos260782" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Writing a Class for the SOAP Type and Parameters</span></span></span></p><p class="calibre_11">To complete the <span class="calibre4">ParseTypes()</span> method, we need to implement the <span class="calibre4">SoapType</span> class. The <span class="calibre4">SoapType</span> class is a relatively simple one. All it needs is a constructor and a couple of properties, as shown in <a href="#filepos262263">Listing 3-6</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapType</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapType(XmlNode type)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = type.➊Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> this.Parameters = new List&lt;SoapTypeParameter&gt;();</span><br class="calibre5"/><span class="calibre4"> if (type.➋HasChildNodes &amp;&amp; type.FirstChild.HasChildNodes)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (XmlNode node in type.➌FirstChild.FirstChild.➍ChildNodes)</span><br class="calibre5"/><span class="calibre4"> this.Parameters.Add(new SoapTypeParameter(node));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">
</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public List&lt;SoapTypeParameter&gt; Parameters { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos262263" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-6: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapType</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class used in the WSDL fuzzer</span></span></p><p class="calibre_6">The logic in the <span class="calibre4">SoapType</span> constructor is similar to that in the previous parsing methods (in <a href="#filepos256350">Listings 3-4</a> and <a href="#filepos259460">3-5</a>), except we’re not using XPath to enumerate the nodes we’re iterating over. We could have, but I wanted to show you another way of iterating over XML nodes. Usually, when you’re parsing XML, XPath is the way to go, but XPath can be computationally expensive. In this case, we’ll write an <span class="calibre4">if</span> statement to check whether we have to iterate over the child nodes. Iterating over the child nodes using a <span class="calibre4">foreach</span> loop to find the relevant XML element involves slightly less code than using XPath in this particular instance.</p><p class="calibre_6">The <span class="calibre4">SoapType</span> class has two properties: a <span class="calibre4">Name</span> property, which is a string, and a list of parameters (the <span class="calibre4">SoapTypeParameter</span> class, which we’ll implement shortly). Both of these properties are used in the <span class="calibre4">SoapType</span> constructor and are public so that they can be consumed outside the class later on.</p><p class="calibre_6">We use the <span class="calibre4">Attributes</span> property ➊ on the node passed into the constructor arguments to retrieve the node’s <span class="calibre4">name</span> attribute. The value of the <span class="calibre4">name</span> attribute is assigned to the <span class="calibre4">Name</span> property of the <span class="calibre4">SoapType</span> class. We also instantiate the <span class="calibre4">SoapTypeParameter</span> list and assign the new object to the <span class="calibre4">Parameters</span> property. Once this is done, we use an <span class="calibre4">if</span> statement to determine whether we need to iterate over child nodes in the first place, since we’re not using XPath to iterate over any child nodes. Using the <span class="calibre4">HasChildNodes</span> property ➋, which returns a Boolean value, we can determine whether we have to iterate over the child nodes. If the node has child nodes, and if the first child of that node also has child nodes, we’ll iterate over them.</p><p class="calibre_6">Every <span class="calibre4">XmlNode</span> class has a <span class="calibre4">FirstChild</span> property and a <span class="calibre4">ChildNodes</span> property ➍ that returns an enumerable list of the child nodes available. In the <span class="calibre4">foreach</span> loop, we use a chain of <span class="calibre4">FirstChild</span> properties ➌ to iterate over the child nodes of the first child of the first child of the node passed in.</p><p class="calibre_6">An example of an XML node that would be passed to the <span class="calibre4">SoapType</span> constructor is shown in <a href="#filepos266373">Listing 3-7</a>.</p><p class="calibre_6">After iterating over the relevant child nodes in the <span class="calibre4">SoapType</span> node that’s passed in, we instantiate a new <span class="calibre4">SoapTypeParameter</span> class by passing the current child node into the <span class="calibre4">SoapTypeParameter</span> constructor. The new object is stored in the <span class="calibre4">Parameters</span> list for access later on.</p><blockquote class="calibre_14"><span class="calibre4">&lt;xs:element name="AddUser"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;xs:complexType&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;xs:sequence&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;xs:element minOccurs="0" maxOccurs="1" name="password" type="xs:string"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/xs:sequence&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/xs:complexType&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/xs:element&gt; </span><a id="filepos266373"/><span class="calibre4"><span class="italic">Listing 3-7: Sample</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">SoapType</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">XML</span></span></blockquote><p class="calibre_6"> Now let’s create the <span class="calibre4">SoapTypeParameter</span> class. The <span class="calibre4">SoapTypeParameter</span> class is also relatively simple. In fact, no iteration over child nodes is required, just basic information gathering, as <a href="#filepos268034">Listing 3-8</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapTypeParameter</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapTypeParameter(XmlNode node)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➊if (node.Attributes["maxOccurs"].Value == "unbounded")</span><br class="calibre5"/><span class="calibre4"> this.MaximumOccurrence = int.MaxValue;</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> this.MaximumOccurrence = int.Parse(node.Attributes["maxOccurs"].Value);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.MinimumOccurrence = int.Parse(node.Attributes["minOccurs"].Value);</span><br class="calibre5"/><span class="calibre4"> this.Name = node.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> this.Type = node.Attributes["type"].Value;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public int MinimumOccurrence { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int MaximumOccurrence { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Type { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos268034" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-8: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapTypeParameter</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">An example of an XML node passed to the <span class="calibre4">SoapTypeParameter</span> constructor is shown in <a href="#filepos268593">Listing 3-9</a>.</p><blockquote class="calibre_14"><span class="calibre4">&lt;xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/&gt; </span><a id="filepos268593"/><span class="calibre4"><span class="italic">Listing 3-9: Sample XML node passed to the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">SoapTypeParameter</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">constructor</span></span></blockquote><p class="calibre_6">Given an XML node like this, we can expect a few things to happen in our method. First, this is a very basic WSDL parameter that defines a parameter named <span class="calibre4">username</span> that is of type <span class="calibre4">string</span>. It can occur at a minimum zero times and at most once. Look closely at the code in <a href="#filepos268034">Listing 3-8</a>, and you’ll notice that there’s an <span class="calibre4">if</span> statement ➊ that checks the value of <span class="calibre4">maxOccurs</span>. Unlike <span class="calibre4">minOccurs</span>, <span class="calibre4">maxOccurs</span> can be either an integer or the string value <span class="calibre4">unbounded</span>, so we have to check the <span class="calibre4">maxOccurs</span> value before passing it to the <span class="calibre4">int.Parse()</span> method to see what the value is.</p><p class="calibre_6">Within our <span class="calibre4">SoapTypeParameter</span> constructor, we first assign the <span class="calibre4">MaximumOccurrence</span> property based on the node’s <span class="calibre4">maxOccurs</span> attribute. We then assign the <span class="calibre4">MinimumOccurrence</span>, <span class="calibre4">Name</span>, and <span class="calibre4">Type</span> properties based on the corresponding node attributes.</p><p id="filepos270075" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating the SoapMessage Class to Define Sent Data</span></span></span></p><p class="calibre_11">A SOAP message defines a set of data that the web service either expects or responds with for a given operation. It references the SOAP types and parameters previously parsed to present data to or consume data from the client application and is made up of <span class="italic">parts</span>, which is the technical term. An example of a SOAP 1.1 message XML element is provided in <a href="#filepos270966">Listing 3-10</a>.</p><blockquote class="calibre_14"><span class="calibre4"> &lt;message name="AddUserHttpGetIn"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;part name="username" type="s:string"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;part name="password" type="s:string"/&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/message&gt; </span><a id="filepos270966"/><span class="calibre4"><span class="italic">Listing 3-10: Sample SOAP message XML element</span></span></blockquote><p class="calibre_6">Our <span class="calibre4">SoapMessage</span> class, which consumes an XML element like the one in <a href="#filepos270966">Listing 3-10</a>, is detailed in <a href="#filepos272170">Listing 3-11</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapMessage</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapMessage(XmlNode node)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊node.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> this.Parts = new List&lt;SoapMessagePart&gt;();</span><br class="calibre5"/><span class="calibre4"> if (node.HasChildNodes)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode part in node.ChildNodes)</span><br class="calibre5"/><span class="calibre4"> this.Parts.Add(new SoapMessagePart(part));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public List&lt;SoapMessagePart&gt; Parts { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos272170" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-11: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapMessage</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">First, we assign the name of the message to the <span class="calibre4">Name</span> property ➊ of the <span class="calibre4">SoapMessage</span> class. We then instantiate a new <span class="calibre4">List</span> of parts called <span class="calibre4">SoapMessagePart</span> and iterate over each <span class="calibre4">&lt;part&gt;</span> element, passing the element to the <span class="calibre4">SoapMessagePart</span> constructor and saving the new <span class="calibre4">SoapMessagePart</span> for later use by adding it to the <span class="calibre4">Parts</span> list.</p><p id="filepos272939" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Implementing a Class for Message Parts</span></span></span></p><p class="calibre_11">Like the previous SOAP classes we have implemented, the <span class="calibre4">SoapMessagePart</span> class is a simple class, as <a href="#filepos274368">Listing 3-12</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapMessagePart</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapMessagePart(XmlNode part)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊part.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> if (➋part.Attributes["element"] != null)</span><br class="calibre5"/><span class="calibre4"> this.Element = part.Attributes["element"].Value;</span><br class="calibre5"/><span class="calibre4"> else if ( part.Attributes["type"].Value != null)</span><br class="calibre5"/><span class="calibre4"> this.Type = part.Attributes["type"].Value;</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> throw new ArgumentException("Neither element nor type is set.", "part");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Element { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Type { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p class="calibre_15"><span class="calibre4">
</span><a id="filepos274368"/><span class="calibre4"><span class="italic">Listing 3-12: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapMessagePart</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">SoapMessagePart</span> class constructor takes a single argument, <span class="calibre4">XmlNode</span>, that contains the name and the type or element of the part within the <span class="calibre4">SoapMessage</span>. The <span class="calibre4">SoapMessagePart</span> class defines three public properties: the part’s <span class="calibre4">Name</span>, <span class="calibre4">Type</span>, and <span class="calibre4">Element</span>, all of which are strings. First, we store the name of the part in the <span class="calibre4">Name</span> property ➊. Then, if we have an attribute called <span class="calibre4">element</span> ➋, we assign the value of the <span class="calibre4">element</span> attribute to the <span class="calibre4">Element</span> property. If the <span class="calibre4">element</span> attribute doesn’t exist, the <span class="calibre4">type</span> attribute must exist, so we assign the value of the <span class="calibre4">type</span> attribute to the <span class="calibre4">Type</span> property. Only two of these properties will be set for any given SOAP part—a SOAP part always has a <span class="calibre4">Name</span> and either a <span class="calibre4">Type</span> or <span class="calibre4">Element</span>. The <span class="calibre4">Type</span> or <span class="calibre4">Element</span> will be set depending on whether the part is a simple type (such as a string or integer) or a complex type encompassed by another XML element within the WSDL. We have to create a class for each kind of parameter, and we’ll start by implementing the <span class="calibre4">Type</span> class.</p><p id="filepos276069" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Defining Port Operations with the SoapPortType Class</span></span></span></p><p class="calibre_11">With the <span class="calibre4">SoapMessage</span> and <span class="calibre4">SoapMessagePart</span> classes defined to complete the <span class="calibre4">ParseMessages()</span> method from <a href="#filepos256350">Listing 3-4</a>, we move on to create the <span class="calibre4">SoapPortType</span> class, which will complete the <span class="calibre4">ParsePortTypes()</span> method. The SOAP port type defines the operations available on a given port (not to be confused with a network port), and parsing it is detailed in <a href="#filepos277536">Listing 3-13</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapPortType</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapPortType(XmlNode node)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊node.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> this.Operations = new List&lt;SoapOperation&gt;();</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode op in node.ChildNodes)</span><br class="calibre5"/><span class="calibre4"> this.Operations.Add(new SoapOperation(op));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public List&lt;SoapOperation&gt; Operations { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos277536" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-13: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapPortType</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class used in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ParsePortTypes()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The pattern of how these SOAP classes work continues: the <span class="calibre4">SoapPortType</span> class in <a href="#filepos277536">Listing 3-13</a> defines a small constructor that accepts an <span class="calibre4">XmlNode</span> from the WSDL document. It requires two public properties: a <span class="calibre4">SoapOperation</span> list and a <span class="calibre4">Name</span> string. Within the <span class="calibre4">SoapPortType</span> constructor, we first assign the <span class="calibre4">Name</span> property ➊ to the XML <span class="calibre4">name</span> attribute. We then create a new <span class="calibre4">SoapOperation</span> list and iterate over each of the child nodes in the <span class="calibre4">portType</span> element. As we iterate, we pass the child node to the <span class="calibre4">SoapOperation</span> constructor (which we build in the next section) and store the resulting <span class="calibre4">SoapOperation</span> in our list. An example of an XML node from the WSDL document that would be passed to the <span class="calibre4">SoapPortType</span> class constructor is shown in <a href="#filepos280223">Listing 3-14</a>.</p><blockquote class="calibre_14"><span class="calibre4">&lt;portType name="VulnerableServiceSoap"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;operation name="AddUser"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;input message="s0:AddUserSoapIn"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;output message="s0:AddUserSoapOut"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/operation&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;operation name="ListUsers"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;input message="s0:ListUsersSoapIn"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;output message="s0:ListUsersSoapOut"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/operation&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;operation name="GetUser"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;input message="s0:GetUserSoapIn"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;output message="s0:GetUserSoapOut"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/operation&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;operation name="DeleteUser"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;input message="s0:DeleteUserSoapIn"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;output message="s0:DeleteUserSoapOut"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/operation&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/portType&gt; </span><a id="filepos280223"/><span class="calibre4"><span class="italic">Listing 3-14: Sample</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">portType</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">XML node passed to the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">SoapPortType</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class constructor</span></span></blockquote><p class="calibre_6">As you can see, the <span class="calibre4">portType</span> element contains the operations we’ll be able to perform, such as listing, creating, and deleting users. Each of the operations maps to a given message, which we parsed in <a href="#filepos272170">Listing 3-11</a>.</p><p id="filepos280871" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Implementing a Class for Port Operations</span></span></span></p><p class="calibre_11">In order to use the operations from the <span class="calibre4">SoapPortType</span> class constructor, we need to create the <span class="calibre4">SoapOperation</span> class, as shown in <a href="#filepos282268">Listing 3-15</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapOperation</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapOperation(XmlNode op)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊op.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode message in op.ChildNodes)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (message.Name.EndsWith("input"))</span><br class="calibre5"/><span class="calibre4"> this.Input = message.Attributes["message"].Value;</span><br class="calibre5"/><span class="calibre4"> else if (message.Name.EndsWith("output"))</span><br class="calibre5"/><span class="calibre4"> this.Output = message.Attributes["message"].Value;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Input { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Output { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos282268" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-15: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapOperation</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6"> The <span class="calibre4">SoapOperation</span> constructor accepts an <span class="calibre4">XmlNode</span> as the single argument. The first thing we do is assign a property of the <span class="calibre4">SoapOperation</span> class called <span class="calibre4">Name</span> ➊ to the <span class="calibre4">name</span> attribute of the operation XML element passed to the constructor. We then iterate over each of the child nodes, checking whether the name of the element ends with either <span class="calibre4">"input"</span> or <span class="calibre4">"output"</span>. If the name of the child node ends with <span class="calibre4">"input"</span>, we assign the <span class="calibre4">Input</span> property to the name of the input element. Otherwise, we assign the <span class="calibre4">Output</span> property to the name of the output element. Now that the <span class="calibre4">SoapOperation</span> class has been implemented, we can move on to the classes we need to finish up the <span class="calibre4">ParseBindings()</span> method.</p><p id="filepos283477" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Defining Protocols Used in SOAP Bindings</span></span></span></p><p class="calibre_11">The two general types of bindings are HTTP and SOAP. It seems redundant, but the HTTP bindings transport data over the general HTTP protocol, using an HTTP query string or POST parameters. SOAP bindings use either the SOAP 1.0 or SOAP 1.1 protocol over simple TCP sockets or named pipes, which encompass the data flowing to and from the server in XML. The <span class="calibre4">SoapBinding</span> class lets you decide how to communicate with a given SOAP port depending on the binding.</p><p class="calibre_6">A sample binding node from the WSDL is shown in <a href="#filepos285096">Listing 3-16</a>.</p><blockquote class="calibre_14"><span class="calibre4">&lt;binding name="VulnerableServiceSoap" type="s0:VulnerableServiceSoap"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;operation name="AddUser"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;soap:operation soapAction="http://tempuri.org/AddUser" style="document"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;input&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;soap:body use="literal"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/input&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;output&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;soap:body use="literal"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/output&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/operation&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/binding&gt; </span><a id="filepos285096"/><span class="calibre4"><span class="italic">Listing 3-16: Sample binding XML node from the WSDL</span></span></blockquote><p class="calibre_6">In order to parse this XML node, our class needs to pull some key information out of the binding node, as shown in <a href="#filepos286958">Listing 3-17</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapBinding</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapBinding(XmlNode node)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊node.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> this.Type = ➋node.Attributes["type"].Value;</span><br class="calibre5"/><span class="calibre4"> this.IsHTTP = false;</span><br class="calibre5"/><span class="calibre4"> this.Operations = new List&lt;SoapBindingOperation&gt;();</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode op in node.ChildNodes)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (➌op.Name.EndsWith("operation"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Operations.Add(new SoapBindingOperation(op));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> else if (op.Name == "http:binding")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Verb = op.Attributes["verb"].Value;</span><br class="calibre5"/><span class="calibre4"> this.IsHTTP = true;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public List&lt;SoapBindingOperation&gt; Operations { get; set; }</span><br class="calibre5"/><span class="calibre4"> public bool IsHTTP { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Verb { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Type { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos286958" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-17: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapBinding</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">After accepting an <span class="calibre4">XmlNode</span> as the argument to the <span class="calibre4">SoapBinding</span> constructor, we first assign the values of the <span class="calibre4">name</span> and <span class="calibre4">type</span> attributes of the node to the <span class="calibre4">Name</span> ➊ and <span class="calibre4">Type</span> ➋ properties of the <span class="calibre4">SoapBinding</span> class. By default, we set the <span class="calibre4">IsHTTP</span> Boolean property to <span class="calibre4">false</span>. The <span class="calibre4">IsHTTP</span> property helps us determine how to send the data we want to fuzz, using either HTTP parameters or SOAP XML.</p><p class="calibre_6">As we iterate over the child nodes, we test whether each child node’s name ends with <span class="calibre4">"operation"</span> ➌, and, if so, we add the operation to the <span class="calibre4">SoapBindingOperation</span> list. If the child node’s name does not end with <span class="calibre4">"operation"</span>, the node should be an HTTP binding. We ensure this is the case with an <span class="calibre4">else if</span> statement, and we set the HTTP <span class="calibre4">Verb</span> property to the value of the <span class="calibre4">verb</span> attribute of the child node. We also set <span class="calibre4">IsHTTP</span> to <span class="calibre4">true</span>. The <span class="calibre4">Verb</span> property should contain either GET or POST, which tells us whether the data sent to the SOAP endpoint will be in query string (GET) parameters or POST parameters.</p><p class="calibre_6">Next, we’ll implement the <span class="calibre4">SoapBindingOperation</span> class.</p><p id="filepos288801" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Compiling a List of Operation Child Nodes</span></span></span></p><p class="calibre_11">The <span class="calibre4">SoapBindingOperation</span> class is a small class consumed in the <span class="calibre4">SoapBinding</span> class constructor. It defines a few string properties that will be assigned values based on the operation node passed to the constructor, as shown in <a href="#filepos290356">Listing 3-18</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapBindingOperation</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapBindingOperation(XmlNode op)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊op.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode node in op.ChildNodes)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (➋node.Name == "http:operation")</span><br class="calibre5"/><span class="calibre4"> this.Location = node.Attributes["location"].Value;</span><br class="calibre5"/><span class="calibre4"> else if (node.Name == "soap:operation" || node.Name == "soap12:operation")</span><br class="calibre5"/><span class="calibre4"> this.SoapAction = node.Attributes["soapAction"].Value;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Location { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string SoapAction { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos290356" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-18: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapBindingOperation</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Using the <span class="calibre4">XmlNode</span> that’s passed to the constructor, we first assign the <span class="calibre4">Name</span> property ➊ to the value of the <span class="calibre4">name</span> attribute on the XML node. The operation node contains a few child nodes, but we only really care about three specific nodes: <span class="calibre4">http:operation</span>, <span class="calibre4">soap:operation</span>, and <span class="calibre4">soap12:operation</span>. As we iterate over the child nodes to find a node we care about, we check whether the operation is an HTTP operation or a SOAP operation. If it is an HTTP operation ➋, we store the location of the endpoint for the operation, which is a relative URI such as <span class="calibre4">/AddUser</span>. If it’s a SOAP operation, we store the <span class="calibre4">SoapAction</span>, which is used in a specific HTTP header when making SOAP calls against the SOAP endpoint. When we write the fuzzing logic, this information will be used to send the data to the correct endpoint.</p><p id="filepos291613" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Finding the SOAP Services on Ports</span></span></span></p><p class="calibre_11">Before we can begin fuzzing, we need to finish parsing the WSDL. We’ll implement two more small classes that encompass the SOAP services available and the SOAP ports on those services. We must implement the <span class="calibre4">SoapService</span> class first, as shown in <a href="#filepos292818">Listing 3-19</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapService</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapService(XmlNode node)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊node.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> this.Ports = new List&lt;SoapPort&gt;();</span><br class="calibre5"/><span class="calibre4"> foreach (XmlNode port in node.ChildNodes)</span><br class="calibre5"/><span class="calibre4"> this.Ports.Add(new SoapPort(port));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public List&lt;SoapPort&gt; Ports { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos292818" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-19: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapService</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">SoapService</span> class takes an XML node as the only argument to the constructor. We first assign the name of the service to the <span class="calibre4">Name</span> property of the class ➊ and then create a new list of ports, called <span class="calibre4">SoapPort</span>. As we iterate over the child nodes in the service node, we use each child node to create a new <span class="calibre4">SoapPort</span> and add the new object to the <span class="calibre4">SoapPort</span> list for later reference.</p><p class="calibre_6"> A sample service XML node with four child port nodes from a WSDL document is shown in <a href="#filepos294942">Listing 3-20</a>.</p><blockquote class="calibre_14"><span class="calibre4">&lt;service name="VulnerableService"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;port name="VulnerableServiceSoap" binding="s0:VulnerableServiceSoap"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;soap:address location="http://127.0.0.1:8080/Vulnerable.asmx"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/port&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;port name="VulnerableServiceSoap12" binding="s0:VulnerableServiceSoap12"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;soap12:address location="http://127.0.0.1:8080/Vulnerable.asmx"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/port&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;port name="VulnerableServiceHttpGet" binding="s0:VulnerableServiceHttpGet"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/port&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;port name="VulnerableServiceHttpPost" binding="s0:VulnerableServiceHttpPost"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/port&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/service&gt; </span><a id="filepos294942"/><span class="calibre4"><span class="italic">Listing 3-20: A sample service node from a WSDL document</span></span></blockquote><p class="calibre_6">The last thing to do is implement the <span class="calibre4">SoapPort</span> class to complete the <span class="calibre4">ParseServices()</span> method and then finish parsing the WSDL for fuzzing. The <span class="calibre4">SoapPort</span> class is shown in <a href="#filepos296261">Listing 3-21</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class SoapPort</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public SoapPort(XmlNode port)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Name = ➊port.Attributes["name"].Value;</span><br class="calibre5"/><span class="calibre4"> this.Binding = port.Attributes["binding"].Value;</span><br class="calibre5"/><span class="calibre4"> this.ElementType = port.➋FirstChild.Name;</span><br class="calibre5"/><span class="calibre4"> this.Location = port.FirstChild.Attributes["location"].Value;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Name { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Binding { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string ElementType { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Location { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos296261" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-21: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapPort</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">To finish parsing the WSDL document, we grab a few attributes from the port node passed to the <span class="calibre4">SoapPort</span> constructor. We first store the name of the port in the <span class="calibre4">Name</span> property ➊ and the binding in the <span class="calibre4">Binding</span> property. Then, referencing the port node’s only child node with the <span class="calibre4">FirstChild</span> property ➋, we store the name and location data of the child node in the <span class="calibre4">ElementType</span> and <span class="calibre4">Location</span> properties, respectively.</p><p class="calibre_6">Finally, we have broken apart the WSDL document into manageable pieces that will allow us to easily write a fuzzer to find potential SQL injections. With the various parts of the WSDL described as classes, we can programmatically drive automatic vulnerability detection and reporting.</p><p id="filepos297397" class="calibre_10"><span class="calibre3"><span class="bold"> Automatically Fuzzing the SOAP Endpoint for SQL Injection Vulnerabilities</span></span></p><p class="calibre_11">Now that the building blocks for the WSDL fuzzer have been built, we can start doing some real fun tool development. Using the <span class="calibre4">WSDL</span> class, we can interact with the data in the WSDL in an object-oriented manner, which makes fuzzing the SOAP endpoint much easier. We start by writing a new <span class="calibre4">Main()</span> method that accepts a single argument (the URL to the SOAP endpoint), which can be created in its own file inside of its own <span class="calibre4">Fuzzer</span> class, as shown in <a href="#filepos299332">Listing 3-22</a>.</p><blockquote class="calibre_14"><span class="calibre4">private static ➊WSDL _wsdl = null;</span><br class="calibre5"/><span class="calibre4">private static ➋string _endpoint = null;</span><br class="calibre5"/><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> _endpoint = ➌args[0];</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fetching the WSDL for service: " + _endpoint);</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest)WebRequest.Create(_endpoint + "?WSDL");</span><br class="calibre5"/><span class="calibre4"> XmlDocument wsdlDoc = new XmlDocument();</span><br class="calibre5"/><span class="calibre4"> using (WebResponse resp = req.GetResponse())</span><br class="calibre5"/><span class="calibre4"> using (Stream respStream = resp.GetResponseStream())</span><br class="calibre5"/><span class="calibre4"> wsdlDoc.➍Load(respStream);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> _wsdl = new WSDL(wsdlDoc);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fetched and loaded the web service description.");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (SoapService service in _wsdl.Services)</span><br class="calibre5"/><span class="calibre4"> FuzzService(service);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos299332" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-22: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method of the SOAP endpoint fuzzer</span></span></p><p class="calibre_6">We first declare a couple of static variables at the class level before the <span class="calibre4">Main()</span> method. These variables will be used throughout methods we write. The first variable is the <span class="calibre4">WSDL</span> class ➊, and the second stores the URL to the SOAP endpoint ➋.</p><p class="calibre_6">Within the <span class="calibre4">Main()</span> method, we assign the <span class="calibre4">_endpoint</span> variable to the value of the first argument passed to the fuzzer ➌. Then we print a friendly message alerting the user that we are going to fetch the WSDL for the SOAP service.</p><p class="calibre_6">After storing the URL to the endpoint, we create a new <span class="calibre4">HttpWebRequest</span> to retrieve the WSDL from the SOAP service by appending <span class="calibre4">?WSDL</span> to the end of the endpoint URL. We also create a temporary <span class="calibre4">XmlDocument</span> to store the WSDL and to pass to the WSDL class constructor. Passing the HTTP response stream to the <span class="calibre4">XmlDocument Load()</span> method ➍, we load the XML returned by the HTTP request into the XML document. We then pass the resulting XML document to the WSDL class constructor to create a new WSDL object. Now we can iterate over each of the SOAP endpoint services and fuzz the service. A <span class="calibre4">foreach</span> loop iterates over the objects in the WSDL class <span class="calibre4">Services</span> property and passes each service to the <span class="calibre4">FuzzService()</span> method, which we’ll write in the next section.</p><p id="filepos301180" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Fuzzing Individual SOAP Services</span></span></span></p><p class="calibre_11">The <span class="calibre4">FuzzService()</span> method takes a <span class="calibre4">SoapService</span> as an argument and then determines whether we need to fuzz the service using SOAP or HTTP parameters, as shown in <a href="#filepos302490">Listing 3-23</a>.</p><blockquote class="calibre_14"><span class="calibre4">static void FuzzService(SoapService service)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fuzzing service: " + service.Name);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (SoapPort port in service.Ports)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fuzzing " + port.ElementType.Split(':')[0] + " port: " + port.Name);</span><br class="calibre5"/><span class="calibre4"> SoapBinding binding = _wsdl.Bindings.➊Single(b =&gt; b.Name == port.Binding.Split(':')[1]);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (binding.➋IsHTTP)</span><br class="calibre5"/><span class="calibre4"> FuzzHttpPort(binding);</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> FuzzSoapPort(binding);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos302490" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-23: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FuzzService()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method used to determine how to fuzz a given</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">SoapService</span></span></p><p class="calibre_6">After printing the current service we’ll be fuzzing, we iterate over each SOAP port in the <span class="calibre4">Ports</span> service property. Using the Language-Integrated Query (LINQ) <span class="calibre4">Single()</span> method ➊, we select a single <span class="calibre4">SoapBinding</span> that corresponds to the current port. Then we test whether the binding is plain HTTP or XML-based SOAP. If the binding is an HTTP binding ➋, we pass it to the <span class="calibre4">FuzzHttpPort()</span> method to fuzz. Otherwise, we assume the binding is a SOAP binding and pass it to the <span class="calibre4">FuzzSoapPort()</span> method.</p><p class="calibre_6">Now let’s implement the <span class="calibre4">FuzzHttpPort()</span> method. The two types of possible HTTP ports when you’re dealing with SOAP are GET and POST. The <span class="calibre4">FuzzHttpPort()</span> method determines which HTTP verb will be used when sending the HTTP requests during fuzzing, as shown in <a href="#filepos304406">Listing 3-24</a>.</p><blockquote class="calibre_14"><span class="calibre4">static void FuzzHttpPort(SoapBinding binding)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (binding.Verb == "GET")</span><br class="calibre5"/><span class="calibre4"> FuzzHttpGetPort(binding);</span><br class="calibre5"/><span class="calibre4"> else if (binding.Verb == "POST")</span><br class="calibre5"/><span class="calibre4"> FuzzHttpPostPort(binding);</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Don't know verb: " + binding.Verb);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos304406" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-24: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FuzzHttpPort()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">FuzzHttpPort()</span> method is very simple. It tests whether the <span class="calibre4">SoapBinding</span> property <span class="calibre4">Verb</span> equals <span class="calibre4">GET</span> or <span class="calibre4">POST</span> and then passes the binding to the appropriate method—<span class="calibre4">FuzzHttpGetPort()</span> or <span class="calibre4">FuzzHttpPostPort()</span>, respectively. If the <span class="calibre4">Verb</span> property does not equal either <span class="calibre4">GET</span> or <span class="calibre4">POST</span>, an exception is thrown to alert the user that we don’t know how to handle the given HTTP verb.</p><p class="calibre_6"> Now that we’ve created the <span class="calibre4">FuzzHttpPort()</span> method, we’ll implement the <span class="calibre4">FuzzHttpGetPort()</span> method.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Creating the URL to Fuzz</span></span></p><p class="calibre_11">Both of the HTTP fuzzing methods are a bit more complex than the previous methods in the fuzzer. The first half of the <span class="calibre4">FuzzHttpGetPort()</span> method, covered in <a href="#filepos307580">Listing 3-25</a>, builds the initial URL to fuzz.</p><blockquote class="calibre_14"><span class="calibre4">static void FuzzHttpGetPort(SoapBinding binding)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> SoapPortType portType = _wsdl.PortTypes.➊Single(pt =&gt; pt.Name == binding.Type.Split(':')[1]);</span><br class="calibre5"/><span class="calibre4"> foreach (SoapBindingOperation op in binding.Operations)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fuzzing operation: " + op.Name);</span><br class="calibre5"/><span class="calibre4"> string url = ➋_endpoint + op.Location;</span><br class="calibre5"/><span class="calibre4"> SoapOperation po = portType.Operations.Single(p =&gt; p.Name == op.Name);</span><br class="calibre5"/><span class="calibre4"> SoapMessage input = _wsdl.Messages.Single(m =&gt; m.Name == po.Input.Split(':')[1]);</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;string, string&gt; parameters = new Dictionary&lt;string, string&gt;();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (SoapMessagePart part in input.Parts)</span><br class="calibre5"/><span class="calibre4"> parameters.Add(part.Name, part.Type);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> bool ➌first = true;</span><br class="calibre5"/><span class="calibre4"> List&lt;Guid&gt; guidList = new List&lt;Guid&gt;();</span><br class="calibre5"/><span class="calibre4"> foreach (var param in parameters)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (param.Value.EndsWith("string"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Guid guid = Guid.NewGuid();</span><br class="calibre5"/><span class="calibre4"> guidList.Add(guid);</span><br class="calibre5"/><span class="calibre4"> url ➍+= (first ?➎ "?" : "&amp;") + param.Key + "=" + guid.ToString();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> first = false;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos307580" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-25: The first half of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FuzzHttpGetPort()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, where we build the initial URL to fuzz</span></span></p><p class="calibre_6">The first thing we do in the <span class="calibre4">FuzzHttpGetPort()</span> method is use LINQ ➊ to select the port type from our <span class="calibre4">WSDL</span> class that corresponds to the current SOAP binding. We then iterate over the current binding’s <span class="calibre4">Operations</span> property, which contains information regarding each operation we can call and how to call the given operation. As we iterate, we print which operation we are going to fuzz. We then create the URL that we’ll use to make the HTTP request for the given operation by appending the <span class="calibre4">Location</span> property of the current operation to the <span class="calibre4">_endpoint</span> variable we set at the very beginning of the <span class="calibre4">Main()</span> method ➋. We select the current <span class="calibre4">SoapOperation</span> (not to be confused with the <span class="calibre4">SoapBindingOperation</span>!) from the <span class="calibre4">Operations</span> property of the <span class="calibre4">portType</span> using the LINQ method <span class="calibre4">Single()</span>. We also select the <span class="calibre4">SoapMessage</span> used as the input for the current operation using the same LINQ method, which tells us what information the current operation is expecting when called.</p><p class="calibre_6"> Once we have the information we need to set up the GET URL, we create a dictionary to hold the HTTP parameter names and the parameter types we’ll be sending. We iterate over each of the input parts using a <span class="calibre4">foreach</span> loop. As we iterate, we add the name of each parameter and the type, which in this case will always be a string, to the dictionary. After we have all of our parameter names and their respective types stored alongside each other, we can build the initial URL to fuzz.</p><p class="calibre_6">To begin, we define a Boolean called <span class="calibre4">first</span> ➌, which we’ll use to determine whether the parameter that’s appended to the operation’s URL is the first parameter. This is important because the first query string parameter is always separated from the base URL by a question mark (<span class="calibre4">?</span>), and subsequent parameters are separated with an ampersand (<span class="calibre4">&amp;</span>), so we need to be sure of the distinction. Then, we create a <span class="calibre4">Guid</span> list, which will hold unique values that we send along with the parameters so we can reference them in the second half of the <span class="calibre4">FuzzHttpGetPort()</span> method.</p><p class="calibre_6">Next, we iterate over the <span class="calibre4">parameters</span> dictionary using a <span class="calibre4">foreach</span> loop. In this <span class="calibre4">foreach</span> loop, first we test whether the current parameter’s type is a string. If it’s a string, we create a new <span class="calibre4">Guid</span> that will be used as the parameter’s value; then we add the new <span class="calibre4">Guid</span> to the list we created so we can reference it later. We then use the <span class="calibre4">+=</span> operator ➍ to append the parameter and the new value to the current URL. Using a ternary operation ➎, we determine whether we should prefix the parameter with a question mark or ampersand. This is how the HTTP query string parameters must be defined per the HTTP protocol. If the current parameter is the first parameter, it is prepended with a question mark. Otherwise, it is prepended with an ampersand. Finally, we set the parameter to false so that subsequent parameters will be prepended with the correct separating character.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Fuzzing the Created URL</span></span></p><p class="calibre_11">After creating the URL with query string parameters, we can make HTTP requests while systematically replacing parameter values with tainted values that could induce a SQL error from the server, as shown in <a href="#filepos313361">Listing 3-26</a>. This second half of the code completes the <span class="calibre4">FuzzHttpGetPort()</span> method.</p><blockquote class="calibre_14"><span class="calibre4"> Console.WriteLine("Fuzzing full url: " + url);</span><br class="calibre5"/><span class="calibre4"> int k = 0;</span><br class="calibre5"/><span class="calibre4"> foreach(Guid guid in guidList)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string testUrl = url.➊Replace(guid.ToString(), "fd'sa");</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest)WebRequest.Create(testUrl);</span><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new ➋StreamReader(req.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.ReadToEnd();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> ➌catch (WebException ex)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (resp.Contains("syntax error"))</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Possible SQL injection vector in parameter: " + input.➍Parts[k].Name);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> k++;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos313361" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-26: The second half of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FuzzHttpGetPort()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, sending the HTTP requests</span></span></p><p class="calibre_6">Now that we have the full URL that we’ll be fuzzing, we print it for the user to see. We also declare an integer, <span class="calibre4">k</span>, that will be incremented as we iterate over the parameter values in the URL to keep track of potentially vulnerable parameters. Then, using a <span class="calibre4">foreach</span> loop, we iterate over the <span class="calibre4">Guid</span> list we used as the values for our parameters. Within the <span class="calibre4">foreach</span> loop, the first thing we do is replace the current <span class="calibre4">Guid</span> in the URL with the string <span class="calibre4">"fd'sa"</span> using the <span class="calibre4">Replace()</span> method ➊, which should taint any SQL queries using the value without proper sanitization. We then create a new HTTP request with the modified URL and declare an empty string called <span class="calibre4">resp</span> that will hold the HTTP response.</p><p class="calibre_6">Within a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block, we attempt to read the response of the HTTP request from the server using a <span class="calibre4">StreamReader</span> ➋. Reading the response will cause an exception if the server returns a 500 error (which would happen if a SQL exception occurred on the server side). If an exception is thrown, we catch the exception in the <span class="calibre4">catch</span> block ➌ and attempt to read the response from the server again. If the response contains the string <span class="calibre4">syntax error</span>, we print a message alerting the user that the current HTTP parameter could be vulnerable to a SQL injection. In order to tell the user precisely which parameter could be vulnerable, we use the integer <span class="calibre4">k</span> as the index of the <span class="calibre4">Parts</span> list ➍ and retrieve the <span class="calibre4">Name</span> of the current property. When all is said and done, we increment the integer <span class="calibre4">k</span> by 1 and start back at the beginning of the <span class="calibre4">foreach</span> loop with a new value to test.</p><p class="calibre_6">That’s the full method for fuzzing HTTP GET SOAP ports. Next, we need to implement <span class="calibre4">FuzzHttpPostPort()</span> to fuzz POST SOAP ports.</p><p id="filepos315881" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Fuzzing the HTTP POST SOAP Port</span></span></span></p><p class="calibre_11">Fuzzing the HTTP POST SOAP port for a given SOAP service is very similar to fuzzing the GET SOAP port. The only difference is that the data is sent as HTTP POST parameters instead of query-string parameters. When passing the <span class="calibre4">SoapBinding</span> for the HTTP POST port to the <span class="calibre4">FuzzHttpPostPort()</span> method, we need to iterate over each operation and systematically taint values sent to the operations to induce SQL errors from the web server. <a href="#filepos317685">Listing 3-27</a> shows the first half of the <span class="calibre4">FuzzHttpPostPort()</span> method.</p><blockquote class="calibre_14"><span class="calibre4">static void FuzzHttpPostPort(SoapBinding binding)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ➊SoapPortType portType = _wsdl.PortTypes.Single(pt =&gt; pt.Name == binding.Type.Split(':')[1]);</span><br class="calibre5"/><span class="calibre4"> foreach (SoapBindingOperation op in binding.Operations)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Fuzzing operation: " + op.Name);</span><br class="calibre5"/><span class="calibre4"> string url = _endpoint + op.Location;</span><br class="calibre5"/><span class="calibre4"> ➋SoapOperation po = portType.Operations.Single(p =&gt; p.Name == op.Name);</span><br class="calibre5"/><span class="calibre4"> SoapMessage input = _wsdl.Messages.Single(m =&gt; m.Name == po.Input.Split(':')[1]);</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;string, string&gt; parameters = new ➌Dictionary&lt;string, string&gt;();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (SoapMessagePart part in input.Parts)</span><br class="calibre5"/><span class="calibre4"> parameters.Add(part.Name, part.Type); </span><a id="filepos317685"/><span class="calibre4"><span class="italic">Listing 3-27: Determining the operation and parameters to fuzz within the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">FuzzHttpPostPort()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></blockquote><p class="calibre_6">First we select the <span class="calibre4">SoapPortType</span> ➊ that corresponds to the <span class="calibre4">SoapBinding</span> passed to the method. We then iterate over each <span class="calibre4">SoapBindingOperation</span> to determine the current <span class="calibre4">SoapBinding</span> using a <span class="calibre4">foreach</span> loop. As we iterate, we print a message that specifies which operation we are currently fuzzing, and then we build the URL to send the data we are fuzzing to. We also select the corresponding <span class="calibre4">SoapOperation</span> ➋ for the <span class="calibre4">portType</span> variable so that we can find the <span class="calibre4">SoapMessage</span> we need, which contains the HTTP parameters we need to send to the web server. Once we have all the information we need to build and make valid requests to the SOAP service, we build a small dictionary ➌ containing the parameter names and their types to iterate over later.</p><p class="calibre_6">Now we can build the HTTP parameters we’ll send to the SOAP service, as shown in <a href="#filepos319979">Listing 3-28</a>. Continue entering this code into the <span class="calibre4">FuzzHttpPostPort()</span> method.</p><blockquote class="calibre_14"><span class="calibre4"> string postParams = string.Empty;</span><br class="calibre5"/><span class="calibre4"> bool first = true;</span><br class="calibre5"/><span class="calibre4"> List&lt;Guid&gt; guids = new List&lt;Guid&gt;();</span><br class="calibre5"/><span class="calibre4"> foreach (var param in parameters)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (param.Value.➊EndsWith("string"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Guid guid = Guid.NewGuid();</span><br class="calibre5"/><span class="calibre4"> postParams += (first ➋? "" : "&amp;") + param.Key + "=" + guid.ToString();</span><br class="calibre5"/><span class="calibre4"> guids.Add(guid);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> if (first)</span><br class="calibre5"/><span class="calibre4"> first = ➌false;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos319979" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-28: Building the POST parameters to be sent to the POST HTTP SOAP port</span></span></p><p class="calibre_6">We now have all the data we need to build the POST requests. We declare a string to hold the POST parameters, and we declare a Boolean, which will determine whether the parameter will be prefixed with an ampersand, to delineate the POST parameters. We also declare a <span class="calibre4">Guid</span> list so that we can store the values we add to the HTTP parameters for use later in the method.</p><p class="calibre_6">Now we can iterate over each of the HTTP parameters using a <span class="calibre4">foreach</span> loop and build the parameters string that we’ll send in the POST request body. As we iterate, first we check whether the parameter type ends with <span class="calibre4">string</span> ➊. If it does, we create a string for a parameter value. To track which string values we use and to ensure each value is unique, we create a new <span class="calibre4">Guid</span> and use this as the parameter’s value. Using a ternary operation ➋, we determine whether we should prefix the parameter with an ampersand. We then store the <span class="calibre4">Guid</span> in the <span class="calibre4">Guid</span> list. Once we have appended the parameter and value to the POST parameters string, we check the Boolean value and, if it is true, set it to false ➌ so that later POST parameters will be delineated with an ampersand.</p><p class="calibre_6">Next, we need to send the POST parameters to the server and then read the response and check for any errors, as <a href="#filepos323372">Listing 3-29</a> shows.</p><blockquote class="calibre_14"><span class="calibre4"> int k = 0;</span><br class="calibre5"/><span class="calibre4"> foreach (Guid guid in guids)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string testParams = postParams.➊Replace(guid.ToString(), "fd'sa");</span><br class="calibre5"/><span class="calibre4"> byte[] data = System.Text.Encoding.ASCII.GetBytes(testParams);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = ➋(HttpWebRequest) WebRequest.Create(url);</span><br class="calibre5"/><span class="calibre4"> req.Method = "POST";</span><br class="calibre5"/><span class="calibre4"> req.ContentType = "application/x-www-form-urlencoded";</span><br class="calibre5"/><span class="calibre4"> req.ContentLength = data.Length;</span><br class="calibre5"/><span class="calibre4"> req.GetRequestStream().➌Write(data, 0, data.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.➍ReadToEnd();</span><br class="calibre5"/><span class="calibre4"> } catch (WebException ex)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (resp.➎Contains("syntax error"))</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Possible SQL injection vector in parameter: " + input.Parts[k].Name);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> k++;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos323372" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-29: Sending the POST parameters to the SOAP service and checking for server errors</span></span></p><p class="calibre_6">To start off, we declare an integer named <span class="calibre4">k</span>, which will be incremented and used throughout the fuzzing to keep track of potentially vulnerable parameters, and we assign <span class="calibre4">k</span> a value of 0. Then we iterate over the <span class="calibre4">Guid</span> list using a <span class="calibre4">foreach</span> loop. As we iterate, the first thing we do is create a new POST parameter string by replacing the current <span class="calibre4">Guid</span> with a tainted value using the <span class="calibre4">Replace()</span> method ➊. Because each <span class="calibre4">Guid</span> is unique, when we replace the <span class="calibre4">Guid</span>, it will only change a single parameter’s value. This lets us determine exactly which parameter has a potential vulnerability. Next, we send the POST request and read the response.</p><p class="calibre_6"> Once we have the new POST parameter string to send to the SOAP service, we convert the string to an array of bytes using the <span class="calibre4">GetBytes()</span> method that will be written to the HTTP stream. We then build the <span class="calibre4">HttpWebRequest</span> ➋ to send the bytes to the server and set the <span class="calibre4">HttpWebRequest</span>’s <span class="calibre4">Method</span> property to <span class="calibre4">"POST"</span>, the <span class="calibre4">ContentType</span> property to <span class="calibre4">application/x-www-form-urlencoded</span>, and the <span class="calibre4">ContentLength</span> property to the size of the byte array. Once this is built, we write the byte array to the request stream by passing the byte array, the index of the array to begin writing from (0), and the number of bytes to write to the <span class="calibre4">Write()</span> method ➌.</p><p class="calibre_6">After the POST parameters have been written to the request stream, we need to read the response from the server. After declaring an empty string to hold the HTTP response, we use a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block to catch any exceptions thrown while reading from the HTTP response stream. Creating a <span class="calibre4">StreamReader</span> in the context of a <span class="calibre4">using</span> statement, we attempt to read the entire response with the <span class="calibre4">ReadToEnd()</span> method ➍ and assign the response to an empty string. If the server responds with an HTTP code of 50x (which means an error occurred on the server side), we catch the exception, attempt to read the response again, and reassign the response string to the empty string to update it. If the response contains the phrase <span class="calibre4">syntax error</span> ➎, we print a message alerting the user that the current HTTP parameter could be vulnerable to a SQL injection. To determine which parameter was vulnerable, we use the integer <span class="calibre4">k</span> as the index of the parameter list to get the current parameter’s <span class="calibre4">Name</span>. Finally, we increment the <span class="calibre4">k</span> integer by 1 so that the next parameter will be referenced in the next iteration, and then we start the process over again for the next POST parameter.</p><p class="calibre_6">That completes the <span class="calibre4">FuzzHttpGetPort()</span> and <span class="calibre4">FuzzHttpPostPort()</span> methods. Next, we’ll write the <span class="calibre4">FuzzSoapPort()</span> method to fuzz the SOAP XML port.</p><p id="filepos326942" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Fuzzing the SOAP XML Port</span></span></span></p><p class="calibre_11">In order to fuzz the SOAP XML port, we need to dynamically build XML to send to the server, which is slightly more difficult than building HTTP parameters to send in a GET or POST request. Starting off, though, the <span class="calibre4">FuzzSoapPort()</span> method is similar to <span class="calibre4">FuzzHttpGetPort()</span> and <span class="calibre4">FuzzHttpPostPort()</span>, as shown in <a href="#filepos328219">Listing 3-30</a>.</p><blockquote class="calibre_14"><span class="calibre4">static void FuzzSoapPort(SoapBinding binding)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> SoapPortType portType = _wsdl.PortTypes.Single(pt =&gt; pt.Name == binding.Type.Split(':')[1]);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (SoapBindingOperation op in binding.Operations)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.➊WriteLine("Fuzzing operation: " + op.Name);</span><br class="calibre5"/><span class="calibre4"> SoapOperation po = portType.Operations.Single(p =&gt; p.Name == op.Name);</span><br class="calibre5"/><span class="calibre4"> SoapMessage input = _wsdl.Messages.Single(m =&gt; m.Name == po.Input.Split(':')[1]); </span><a id="filepos328219"/><span class="calibre4"><span class="italic">Listing 3-30: Gathering initial information to build dynamic SOAP XML</span></span></blockquote><p class="calibre_6">As with the GET and POST fuzzing methods, we need to collect some information about what we are going to fuzz before we can do anything. We first grab the corresponding <span class="calibre4">SoapPortType</span> from the <span class="calibre4">_wsdl.PortTypes</span> property using LINQ; then we iterate over each operation with a <span class="calibre4">foreach</span> loop. As we iterate, we print the current operation we are fuzzing to the console ➊. In order to send the correct XML to the server, we need to select the <span class="calibre4">SoapOperation</span> and <span class="calibre4">SoapMessage</span> classes that correspond to the <span class="calibre4">SoapBinding</span> class passed to the method. Using the <span class="calibre4">SoapOperation</span> and <span class="calibre4">SoapMessage</span>, we can dynamically build the XML required. To do this, we use <span class="italic">LINQ to XML</span>, which is a set of built-in classes in the <span class="calibre4">System.Xml.Linq</span> namespace that lets you create simple, dynamic XML, as shown in <a href="#filepos330717">Listing 3-31</a>.</p><blockquote class="calibre_14"><span class="calibre4">XNamespace soapNS = "http://schemas.xmlsoap.org/soap/envelope/";</span><br class="calibre5"/><span class="calibre4">XNamespace xmlNS = op.➊SoapAction.Replace(op.Name, string.Empty);</span><br class="calibre5"/><span class="calibre4">XElement soapBody = new XElement(soapNS + "Body");</span><br class="calibre5"/><span class="calibre4">XElement soapOperation = new ➋XElement(xmlNS + op.Name);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">soapBody.Add(soapOperation);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">List&lt;Guid&gt; paramList = new List&lt;Guid&gt;();</span><br class="calibre5"/><span class="calibre4">SoapType type = _wsdl.Types.➌Single(t =&gt; t.Name == input.Parts[0].Element.Split(':')[1]);</span><br class="calibre5"/><span class="calibre4">foreach (SoapTypeParameter param in type.Parameters)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> XElement soapParam = new ➍XElement(xmlNS + param.Name);</span><br class="calibre5"/><span class="calibre4"> if (param.Type.EndsWith("string"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Guid guid = Guid.NewGuid();</span><br class="calibre5"/><span class="calibre4"> paramList.Add(guid);</span><br class="calibre5"/><span class="calibre4"> soapParam.➎SetValue(guid.ToString());</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> soapOperation.Add(soapParam);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos330717" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-31: Building the dynamic SOAP XML using LINQ to XML in the SOAP fuzzer</span></span></p><p class="calibre_6">We first create two <span class="calibre4">XNameSpace</span> instances to use when building the XML. The first <span class="calibre4">XNameSpace</span> is the default SOAP namespace, but the second <span class="calibre4">XNameSpace</span> will change based on the current operation’s <span class="calibre4">SoapAction</span> property ➊. After the namespaces are defined, we create two new XML elements using the <span class="calibre4">XElement</span> class. The first <span class="calibre4">XElement</span> (which will be called <span class="calibre4">&lt;Body&gt;</span>) is a standard XML element used in SOAP and will encapsulate the data for the current SOAP operation. The second <span class="calibre4">XElement</span> will be named after the current operation ➋. The <span class="calibre4">XElement</span> instances use the default SOAP namespace and the SOAP operation namespace, respectively. We then add the second <span class="calibre4">XElement</span> to the first using the <span class="calibre4">XElement Add()</span> method so that the SOAP <span class="calibre4">&lt;Body&gt;</span> XML element will contain the SOAP operation element.</p><p class="calibre_6">After creating the outer XML elements, we create a <span class="calibre4">Guid</span> list to store the values we generate, and we also select the current <span class="calibre4">SoapType</span> with LINQ ➌ so that we can iterate over the parameters required for the SOAP call. As we iterate, we first create a new <span class="calibre4">XElement</span> for the current parameter ➍. If the parameter type is a string, we assign the <span class="calibre4">XElement</span> a <span class="calibre4">Guid</span> for a value using <span class="calibre4">SetValue()</span> ➎ and store the <span class="calibre4">Guid</span> in the <span class="calibre4">Guid</span> list we created for reference later. We then add the <span class="calibre4">XElement</span> to the SOAP operation element and move on to the next parameter.</p><p class="calibre_6">Once we have completed adding the parameters to the SOAP operation XML node, we need to put the whole XML document together, as shown in <a href="#filepos333407">Listing 3-32</a>.</p><blockquote class="calibre_14"><span class="calibre4">XDocument soapDoc = new XDocument(new XDeclaration("1.0", "ascii", "true"),</span><br class="calibre5"/><span class="calibre4"> new ➊XElement(soapNS + "Envelope",</span><br class="calibre5"/><span class="calibre4"> new XAttribute(XNamespace.Xmlns + "soap", soapNS),</span><br class="calibre5"/><span class="calibre4"> new XAttribute("xmlns", xmlNS),</span><br class="calibre5"/><span class="calibre4"> ➋soapBody)); </span><a id="filepos333407"/><span class="calibre4"><span class="italic">Listing 3-32: Putting the whole SOAP XML document together</span></span></blockquote><p class="calibre_6">We need to create an <span class="calibre4">XDocument</span> with one more <span class="calibre4">XElement</span> called the SOAP <span class="calibre4">Envelope</span> ➊. We create a new <span class="calibre4">XDocument</span> by passing a new <span class="calibre4">XElement</span> to the <span class="calibre4">XDocument</span> constructor. The <span class="calibre4">XElement</span>, in turn, is created with a couple of attributes defining the node’s XML namespaces, as well as with the SOAP body we built with the parameters ➋.</p><p class="calibre_6">Now that the XML is built, we can send the XML to the web server and attempt to induce SQL errors, as <a href="#filepos335195">Listing 3-33</a> shows. Continue to add this code to the <span class="calibre4">FuzzSoapPort()</span> method.</p><blockquote class="calibre_14"><span class="calibre4">int k = 0;</span><br class="calibre5"/><span class="calibre4">foreach (Guid parm in paramList)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> string testSoap = soapDoc.ToString().➊Replace(parm.ToString(), "fd'sa");</span><br class="calibre5"/><span class="calibre4"> byte[] data = System.Text.Encoding.ASCII.GetBytes(testSoap);</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest) WebRequest.Create(_endpoint);</span><br class="calibre5"/><span class="calibre4"> req.Headers["SOAPAction"] = ➋op.SoapAction;</span><br class="calibre5"/><span class="calibre4"> req.Method = "POST";</span><br class="calibre5"/><span class="calibre4"> req.ContentType = "text/xml";</span><br class="calibre5"/><span class="calibre4"> req.ContentLength = data.Length;</span><br class="calibre5"/><span class="calibre4"> using (Stream stream = req.GetRequestStream())</span><br class="calibre5"/><span class="calibre4"> stream.➌Write(data, 0, data.Length); </span><a id="filepos335195"/><span class="calibre4"><span class="italic">Listing 3-33: Creating the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">HttpWebRequest</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">to send the SOAP XML to the SOAP endpoint</span></span></blockquote><p class="calibre_6">As with the fuzzers covered previously in the chapter, we iterate over each <span class="calibre4">Guid</span> in the list of values that we created while building the XML for the SOAP operation. As we iterate, we replace the current <span class="calibre4">Guid</span> in the SOAP XML body with a value that should induce a SQL error if that value is being used in a SQL query unsafely ➊. After we replace the <span class="calibre4">Guid</span> with the tainted value, we convert the resulting string into a byte array using the <span class="calibre4">GetBytes()</span> method, which we’ll write to the HTTP stream as POST data.</p><p class="calibre_6">We then build the <span class="calibre4">HttpWebRequest</span> that we’ll use to make the HTTP request and read the result. One special piece to note is the <span class="calibre4">SOAPAction</span> header ➋. This <span class="calibre4">SOAPAction</span> HTTP header will be used by the SOAP endpoint to determine which action is performed with the data, such as listing or deleting users. We also set the HTTP method to <span class="calibre4">POST</span>, the content type to <span class="calibre4">text/xml</span>, and the content length to the length of the byte array we created. Finally, we write the data to the HTTP stream ➌. Now we need to read the response from the server and determine whether the data we sent induced any SQL errors, as <a href="#filepos337934">Listing 3-34</a> shows.</p><blockquote class="calibre_14"><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.➊ReadToEnd();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch (WebException ex)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (resp.➋Contains("syntax error"))</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Possible SQL injection vector in parameter: ");</span><br class="calibre5"/><span class="calibre4"> Console.Write(type.Parameters[k].Name);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> k++;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos337934" class="calibre_15"><span class="calibre4"><span class="italic">Listing 3-34: Reading the HTTP stream in the SOAP fuzzer and looking for errors</span></span></p><p class="calibre_6"><a href="#filepos337934">Listing 3-34</a> uses almost the same code as the fuzzers in Listings <a href="#filepos313361">3-26</a> and <a href="#filepos323372">3-29</a> to check for a SQL error, but in this case we’re handling the detected error differently. First, we declare a string to hold the HTTP response and begin a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block. Then, within the context of a <span class="calibre4">using</span> statement, we use a <span class="calibre4">StreamReader</span> to attempt to read the contents of the HTTP response and store the response in a string ➊. If an exception is thrown because the HTTP server returned a 50x error, we catch the exception and try to read the response again. If an exception is thrown and the response data contains the phrase <span class="calibre4">syntax error</span> ➋, we print a message to alert the user about a possible SQL injection and the potentially vulnerable parameter name. Finally, we increment <span class="calibre4">k</span> and go on to the next parameter.</p><p id="filepos339149" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Running the Fuzzer</span></span></span></p><p class="calibre_11">We can now run the fuzzer against the vulnerable SOAP service appliance <span class="italic">CsharpVulnSoap</span>. The fuzzer takes a single argument: the URL to the vulnerable SOAP endpoint. In this case, we’ll use <a href="http://192.168.1.15/Vulnerable.asmx"><span class="italic">http://192.168.1.15/Vulnerable.asmx</span></a>. Passing the URL as the first argument and running the fuzzer should yield similar output to <a href="#filepos341828">Listing 3-35</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">mono ch3_soap_fuzzer.exe http://192.168.1.15/Vulnerable.asmx</span></span><br class="calibre5"/><span class="calibre4">Fetching the WSDL for service: http://192.168.1.15/Vulnerable.asmx</span><br class="calibre5"/><span class="calibre4">Fetched and loaded the web service description.</span><br class="calibre5"/><span class="calibre4"> Fuzzing service: VulnerableService</span><br class="calibre5"/><span class="calibre4">Fuzzing soap port: ➊VulnerableServiceSoap</span><br class="calibre5"/><span class="calibre4">Fuzzing operation: AddUser</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: username</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: password</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span><br class="calibre5"/><span class="calibre4">Fuzzing http port: ➋VulnerableServiceHttpGet</span><br class="calibre5"/><span class="calibre4">Fuzzing operation: AddUser</span><br class="calibre5"/><span class="calibre4">Fuzzing full url: http://192.168.1.15/Vulnerable.asmx/AddUser?username=a7ee0684-</span><br class="calibre5"/><span class="calibre4">fd54-41b4-b644-20b3dd8be97a&amp;password=85303f3d-1a68-4469-bc69-478504166314</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: username</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: password</span><br class="calibre5"/><span class="calibre4">Fuzzing operation: ListUsers</span><br class="calibre5"/><span class="calibre4">Fuzzing full url: http://192.168.1.15/Vulnerable.asmx/ListUsers</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span><br class="calibre5"/><span class="calibre4">Fuzzing http port: ➌VulnerableServiceHttpPost</span><br class="calibre5"/><span class="calibre4">Fuzzing operation: AddUser</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: username</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: password</span><br class="calibre5"/><span class="calibre4">Fuzzing operation: ListUsers</span><br class="calibre5"/><span class="calibre4">Fuzzing operation: GetUser</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: username</span><br class="calibre5"/><span class="calibre4">Fuzzing operation: DeleteUser</span><br class="calibre5"/><span class="calibre4">Possible SQL injection vector in parameter: username </span><a id="filepos341828"/><span class="calibre4"><span class="italic">Listing 3-35: Partial output from the SOAP fuzzer running against the</span></span><span class="calibre4"> CsharpVulnSoap </span><span class="calibre4"><span class="italic">application</span></span></blockquote><p class="calibre_6">From the output, we can see the various stages of the fuzzing. Starting with the <span class="calibre4">VulnerableServiceSoap</span> port ➊, we find that the <span class="calibre4">AddUser</span> operation might be vulnerable to SQL injection in the <span class="calibre4">username</span> and <span class="calibre4">password</span> fields passed to the operation. Next is the <span class="calibre4">VulnerableServiceHttpGet</span> port ➋. We fuzz the same <span class="calibre4">AddUser</span> operation and print the URL we built, which we can paste into a web browser to see what the response of a successful call is. Again, the <span class="calibre4">username</span> and <span class="calibre4">password</span> parameters were found to be potentially vulnerable to SQL injection. Finally, we fuzz the <span class="calibre4">VulnerableServiceHttpPost</span> SOAP port ➌, first fuzzing the <span class="calibre4">AddUser</span> operation, which reports the same as the previous ports. The <span class="calibre4">ListUsers</span> operation reports no potential SQL injections, which makes sense because it has no parameters to begin with. Both the <span class="calibre4">GetUser</span> and <span class="calibre4">DeleteUser</span> operations are potentially vulnerable to SQL injection in the <span class="calibre4">username</span> parameter.</p><p id="filepos343307" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">In this chapter, you were introduced to the XML classes available from the core libraries. We used the XML classes to implement a full SOAP service SQL injection fuzzer, and we covered a few of the methods of interacting with a SOAP service.</p><p class="calibre_6">The first and most simple method was via HTTP GET requests, where we built URLs with dynamic query string parameters based on the how the WSDL document described the SOAP service. Once this was implemented, we built a method to fuzz POST requests to the SOAP service. Finally, we wrote the method to fuzz the SOAP XML using the LINQ to XML libraries in C# to dynamically create the XML used to fuzz the server.</p><p class="calibre_6">The powerful XML classes in C# make consuming and dealing with XML a breeze. With so many enterprise technologies reliant on XML for cross-platform communication, serialization, or storage, understanding how to efficiently read and create XML documents on the fly can be incredibly useful, especially for a security engineer or pentester.</p><div class="mbp_pagebreak" id="calibre_pb_8"/>
</body></html>