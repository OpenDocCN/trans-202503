- en: '**0**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**A SHELL SCRIPTS CRASH COURSE**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bash (and shell scripting in general) has been around for a long time, and every
    day new people are introduced to the power of shell scripting and system automation
    with bash. And with Microsoft’s release of an interactive bash shell and Unix
    subsystem within Windows 10, there’s never been a better time to learn how simple
    and effective shell scripts can be.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is a Shell Script, Anyway?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ever since the early days of computers, shell scripts have been helping systems
    administrators and programmers perform tedious jobs that otherwise took time and
    elbow grease. So what is a shell script, and why should you care? Shell scripts
    are text files that run a set of commands, in the order they are written in the
    script, for a particular shell (in our case, bash). The *shell* is your command
    line interface to the library of commands available on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripts are essentially bite-sized programs built using the commands available
    in your shell environment to automate specific tasks— generally those tasks that
    no one enjoys doing by hand, like web scraping, tracking disk usage, downloading
    weather data, renaming files, and much more. You can even use shell scripts to
    make basic games! These scripts can include simple logic, like the `if` statements
    you may have seen in other languages, but they can also be even simpler, as you’ll
    soon see.
  prefs: []
  type: TYPE_NORMAL
- en: Many flavors of command line shells, such as tcsh, zsh, and the ever-popular
    bash, are available for OS X, BSD, and Linux operating systems. This book will
    focus on the mainstay of the Unix environment, bash. Each shell has its own features
    and capabilities, but the shell that most people first become familiar with on
    Unix is usually bash. On OS X, the Terminal app will open a window with a bash
    shell (see [Figure 0-1](ch00.xhtml#ch0fig1)). On Linux, the command shell program
    can vary widely, but common command line consoles are *gnome-terminal* for GNOME
    or *konsole* for KDE. These applications can have their configurations changed
    so that they use different types of command line shells, but they all use bash
    by default. Essentially, if you are on any kind of Unix-like operating system,
    opening the terminal application should present you with a bash shell by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 0-1: The Terminal app on OS X, showing a version of bash*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In August 2016, Microsoft released bash for the Windows 10 Anniversary release,
    so if you’re working in Windows you can still run a bash shell. [Appendix A](app01.xhtml#app01)
    gives instructions on how to install bash for Windows 10, but this book assumes
    you are running on a Unix-like operating system such as OS X or Linux. Feel free
    to test these scripts on Windows 10, but we make no guarantees and have not tested
    them on Windows ourselves! The beauty of bash, though, is portability, and many
    scripts in this book should “just work.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the terminal to interact with your system may seem like a daunting task.
    Over time, though, it becomes more natural to just open a terminal to make a quick
    system change than to move your mouse around in menu after menu, trying to find
    the options you want to change.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running Commands**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bash’s core ability is to run commands on your system. Let’s try a quick “Hello
    World” example. In a bash shell, the `echo` command displays text to the screen,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Enter this on the bash command line and you’ll see the words `Hello World` displayed
    onscreen. This line of code runs the `echo` command that’s stored in your standard
    bash library. The directories that bash will search for these standard commands
    are stored in an environment variable called `PATH`. You can use `echo` with the
    `PATH` variable to see its contents, as [Listing 0-1](ch00.xhtml#ch0ex1) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0003-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Listing 0-1: Printing the current* `*PATH*` *environment variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In listings that show both input commands and output, the input commands will
    be shown in bold and will start with a* `*$*` *to differentiate them from output.*'
  prefs: []
  type: TYPE_NORMAL
- en: The directories in this output are separated from one another by a colon. These
    are all the directories that bash will check when you ask it to run a program
    or command. If your command is not stored in any of these directories, bash cannot
    run it. Also, note that bash will check these directories *in the order they appear
    in the* `*PATH*`. This order is important because it may make a difference if
    you have two commands of the same name in two directories in your `PATH`. If you’re
    having trouble finding a particular command, you can use the `which` command with
    the name of that command to see its `PATH` in the shell, as in [Listing 0-2](ch00.xhtml#ch0ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 0-2: Using* `*which*` *to find a command in* `*PATH*`'
  prefs: []
  type: TYPE_NORMAL
- en: Now armed with this information, you could move or copy the file in question
    to one of the directories listed by the `echo $PATH` command, as in [Listing 0-1](ch00.xhtml#ch0ex1),
    and then the command will run. We use `which` throughout the book to determine
    the full path to commands. It’s a useful tool for debugging a broken or weird
    `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring Your Login Script**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Throughout the book, we will be writing scripts that we will then use in other
    scripts, so being able to easily call your new scripts is important. You can configure
    your `PATH` variable so that your custom scripts are automatically callable, just
    like any other command, when you start a new command shell. When you open a command
    shell, the first thing it does is read a login script in your home directory (*/Users/<username>*
    or */home/<username>* in OS X or Linux, respectively) and execute any custom commands
    it finds there. The login script will be *.login*, *.profile*, *.bashrc*, or *.bash_profile*,
    depending on your system. To find out which of these files is the login script,
    add a line like the following to each file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tweak the last word to match the name of the file and then log in. The line
    should be printed at the top of the terminal window, reporting which script was
    run at login. If you open a terminal and see `this is .profile`, you know the
    *.profile* file is being loaded for your shell environment; if you see `this is
    .bashrc`, you know it’s the *.bashrc* file; and so on. And now you know! This
    behavior can change, though, depending on your shell.
  prefs: []
  type: TYPE_NORMAL
- en: You can alter the login script so it configures your `PATH` variable with other
    directories. You can also set up all kinds of bash settings, from changing how
    the bash prompt looks to setting a custom `PATH` to any number of other customizations.
    For instance, let’s use the `cat` command to take a look at a customized *.bashrc*
    login script. The `cat` command takes a filename as an argument and prints the
    contents of the file to the console screen, as shown in [Listing 0-3](ch00.xhtml#ch0ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 0-3: This customized* .bashrc *file updates* `*PATH*` *to include
    RVM.*'
  prefs: []
  type: TYPE_NORMAL
- en: This code displays the contents of the *.bashrc* file, showing that a new value
    has been assigned to `PATH` that allows the local RVM (Ruby version manager) installation
    to manage any installed Ruby versions. Because the *.bashrc* file sets the customized
    `PATH` every time a new command shell is opened, the RVM installation will be
    available by default on this system.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement a similar customization to make your shell scripts available
    by default. First, you’ll create a development folder in your home directory to
    save all your shell scripts in. Then you can add this directory to `PATH` in your
    login file to reference your new scripts more easily.
  prefs: []
  type: TYPE_NORMAL
- en: To identify your home directory, use the command `echo $HOME` to print the directory
    path in your terminal. Navigate to that directory and create your development
    folder (we recommend naming it *scripts*). Then, to add your development directory
    to your login script, open the login script file in your text editor and add the
    following line to the top of the file, replacing `*/path/to/scripts/*` with the
    directory of your development folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, any of the scripts you save in the development folder can
    then be called as a command in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running Shell Scripts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve used a few commands now, such as `echo`, `which`, and `cat`. But we’ve
    only used them individually, not all together in a shell script. Let’s write a
    shell script that runs them all consecutively, as shown in [Listing 0-4](ch00.xhtml#ch0ex4).
    This script will print *Hello World* followed by the file path of the `neqn` shell
    script, a shell script that should be in your bash files by default. Then it will
    use this path to print the contents of `neqn` to the screen. (The contents of
    `neqn` aren’t important at the moment; this is just being used as an example script.)
    This is a good example of using a shell script to perform a series of commands
    in order, in this case to see the full system path of a file and quickly check
    the contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 0-4: The contents of our first shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite text editor (Vim or gedit on Linux and TextEdit on OS X are
    popular editors) and enter [Listing 0-4](ch00.xhtml#ch0ex4). Then save the shell
    script to your development directory and name it *intro*. Shell scripts don’t
    need a special file extension, so leave the extension blank (or you can add the
    extension *.sh* if you prefer, but this isn’t required). The first line of the
    shell script uses the `echo` command to simply print the text `Hello World`. The
    second line is a bit more complicated; it uses `which` to find the location of
    the bash file *neqn* and then uses the `echo` command to print the location to
    the screen. To run two commands like this, where one command is provided as an
    argument to another, bash uses a *subshell* to run the second command and store
    the output for use by the first command. In our example, the sub-shell runs the
    `which` command, which will return the full path to the `neqn` script. This path
    is then used as the argument for `echo`, which means `echo` prints the path to
    *neqn* to the screen. Finally, the same subshell trick passes the file path of
    *neqn* to the `cat` command, which prints the contents of the `neqn` shell script
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file is saved, we can run the shell script from the terminal. [Listing
    0-5](ch00.xhtml#ch0ex5) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 0-5: Running our first shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the shell script by using the `sh` command with the `intro` script passed
    as an argument. The `sh` command will step through each line in the file and execute
    it as if it were a bash command passed in the terminal. You can see here that
    `Hello World` ➊ is printed to the screen and then the path to *neqn* is printed
    ➋. Finally, the contents of the *neqn* file are printed ➌; this is the source
    code for the short `neqn` shell script on your hard drive (on OS X at least—the
    Linux version may look slightly different).
  prefs: []
  type: TYPE_NORMAL
- en: '**Making Shell Scripts More Intuitive**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You don’t need to use the `sh` command to run your scripts. If you add one
    more line to the `intro` shell script and then modify the script’s filesystem
    permissions, you will be able to call the shell script directly, without `sh`,
    as you do other bash commands. In your text editor, update your `intro` script
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added a single line at the very top of the file referencing the filesystem
    path */bin/bash* ➊. This line is called the *shebang*. The shebang allows you
    to define which program will be run to interpret the script. Here we set the file
    as a bash file. You may have seen other shebangs, like those for the Perl language
    (`#!/usr/bin/perl`) or for Ruby (`#!/usr/bin/env ruby`).
  prefs: []
  type: TYPE_NORMAL
- en: With this new line added at the top, you’ll still need to set a file permission
    so you can execute the shell script as if it were a program. Do this in the bash
    terminal, as shown in [Listing 0-6](ch00.xhtml#ch0ex6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 0-6: Changing the file permissions of the* `*intro*` *script to allow
    execution*'
  prefs: []
  type: TYPE_NORMAL
- en: We use `chmod` ➊, the change mode command, and pass it the `+x` argument, which
    makes a file executable. We pass this the filename of the file to change. After
    setting the file permissions to allow the shell script to run as a program, we
    can run the shell script as shown at ➋, without needing to invoke bash directly.
    This is good shell-scripting practice and will prove useful as you hone your skills.
    Most of the scripts we write in this book will need to have the same executable
    permissions we set for the `intro` script.
  prefs: []
  type: TYPE_NORMAL
- en: This was just a simple example to show you how to run shell scripts and how
    to use shell scripts to run other shell scripts. Many of the shell scripts in
    the book will use this method, and you’ll see shebangs a lot in your future shell-scripting
    endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Shell Scripts?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may be wondering why you’d use bash shell scripts instead of a fancy new
    language like Ruby or Go. These languages try to provide portability across many
    types of systems, but they generally aren’t installed by default. The reason is
    simple: every Unix machine has a basic shell, and the vast majority of shells
    use bash. As mentioned at the beginning of this chapter, Microsoft recently shipped
    Windows 10 with the same bash shell that the major Linux distributions and OS
    X have. This means your shell scripts can be more portable than ever, with little
    work on your part. You can also more concisely and easily accomplish maintenance
    and system tasks with shell scripts than you can with other languages. Bash is
    still wanting in some ways, but you’ll learn how to smooth over some of these
    shortcomings in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 0-7](ch00.xhtml#ch0ex7) shows an example of a handy little shell script
    (really, just a bash one-liner!) that’s totally portable. The script finds how
    many pages are in a folder of OpenOffice documents—especially useful for writers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 0-7: A bash script for determining how many pages are in a folder
    of OpenOffice documents*'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into the details of how this works—we’re just getting started, after
    all! But at a high level, it extracts the page count information for each document,
    strings the page counts together with addition operators, and pipes the arithmetic
    to a command line calculator that generates the sum. All that, in basically a
    single line. You’ll find more cool shell scripts like this one throughout the
    book, and, after you’ve gotten some practice, this script should make perfect
    sense and seem very simple!
  prefs: []
  type: TYPE_NORMAL
- en: '**Let’s Get Cracking**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should have a general idea of what shell scripting is now, if you didn’t
    have one already. Creating bite-sized scripts to accomplish specific tasks is
    at the heart of Unix philosophy. Understanding how to make your own scripts and
    expand your own Unix systems to better fit your needs will make you a power user.
    This chapter is just a taste of what is to come in the book: some really wicked
    cool shell scripts!'
  prefs: []
  type: TYPE_NORMAL
