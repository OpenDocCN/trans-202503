<html><head></head><body>
<h2 class="h2" id="ch08"><a id="page_161"/><strong><span class="big">8</span></strong><br/><strong>Concurrency</strong></h2>
<div class="image1"><img alt="image" src="graphics/common-01.jpg"/></div>
<p class="noindent">Usually we can tell when software is doing something interesting, even if we don’t know how it’s done. We know that computers make graphics, encrypt our transmissions, and stream our videos. What we miss, though, is that these tasks often involve multiple programs, multiple processors, or even multiple computers connected via a network, accessing the same data at the same time.</p>
<p class="indent">This overlapping access of data, known as <em>concurrency</em>, is a vital part of modern technology. High-performance tasks like graphics and shared resources like websites wouldn’t be possible without it. But concurrency causes big problems when it’s not carefully managed. In this chapter, we’ll see how results can become scrambled when multiple processors access the same data. Then we’ll look at the clever software (and hardware) techniques that keep processors from getting in each other’s way.</p>
<h3 class="h3" id="ch08lev1sec01"><a id="page_162"/><strong>Why Concurrency Is Needed</strong></h3>
<p class="noindent">Situations that require concurrency fall into three basic categories: performance, multiuser environments, and multitasking.</p>
<h4 class="h4" id="ch08lev2sec01"><strong><em>Performance</em></strong></h4>
<p class="noindent">Concurrency is needed when there’s more work to do than a single processor can handle. Until recently, the number of instructions a processor could execute in a second was steadily increasing, but now the pace of improvement has slowed. In order to execute more instructions in the same amount of time, a processor has to run faster. The faster it runs, the more power courses through it and the hotter it gets, which can eventually damage the components.</p>
<p class="indent">To mitigate that problem, the size of the components in the processor keeps getting smaller so that they draw less current and remain relatively cool. But it’s getting difficult to make processor components any smaller, which in turn makes it difficult to make them run any faster. When a single processor can’t get the job done, the only solution is to use multiple processing cores. We saw this with video game graphics in <a href="ch05.html#ch05">Chapter 5</a>, but it’s not just high-end game graphics that need multiple processors. Even today’s basic graphics tasks may require multiple processor cores.</p>
<h4 class="h4" id="ch08lev2sec02"><strong><em>Multiuser Environments</em></strong></h4>
<p class="noindent">Concurrency also allows networked computer systems to work together. Suppose you are playing an online game such as <em>World of Warcraft</em>. The game tracks each player’s actions as well as those of the computer-controlled monsters. The game’s servers tally every spell and axe swing, and calculate the damage done, the monsters slain, and the loot dropped.</p>
<p class="indent">Concurrency is required here because the processor in every player’s computer must share the data of nearby players and computer-controlled creatures.</p>
<h4 class="h4" id="ch08lev2sec03"><strong><em>Multitasking</em></strong></h4>
<p class="noindent">Concurrency can occur even in situations where only one processor is involved. Modern computers <em>multitask</em>, which means they are constantly switching between different programs, even when we think we’re doing only one thing on the computer at a time. For example, multitasking is what allows your email client to receive a new message while you surf the Web. In these cases, whether or not the computer has multiple processor cores, it’s definitely running multiple <em>processes</em>—different programs with overlapping executions.</p>
<p class="indent">Printing is another typical example. When you print a recipe from a website, the software that manages the printer, known as the driver, collects the print data in an orderly queue and then passes it on to the printer as needed. This is called <em>print spooling</em>. Without print spooling, the browser <a id="page_163"/>could send the data only as fast as the printer processed it, which means that you would have to wait for the print job to finish before you could do anything else with the browser.</p>
<p class="indent">Print spooling can’t work without concurrency. You can think of a print spool as one of those carousels that sit in the window between the front counter and the kitchen in a short-order restaurant, like the one shown in <a href="ch08.html#ch8fig1">Figure 8-1</a>. Someone in the front puts new orders on the carousel, and someone in the back takes down the orders as they are fulfilled. The shared data storage of the carousel allows the order takers and the cooks to work independently.</p>
<div class="image"><img alt="image" src="graphics/f08-01.jpg"/></div>
<p class="figuret"><a id="ch8fig1"/><em>Figure 8-1: An order-ticket carousel</em></p>
<p class="indent">This arrangement is known as a <em>shared buffer</em> and is frequently used behind the scenes in software. For example, suppose you are typing an email, but your computer momentarily slows down so that nothing you typed appears on screen. Then the system catches up, and everything you typed is now in the email. That happens because the keyboard doesn’t communicate directly with the email program, but uses the operating system as an intermediary. The operating system queues the keystrokes in a shared buffer so the email program can access them when ready.</p>
<p class="indent">Multitasking also allows programs to sit in the background and interrupt you when something significant happens. When a new email alert appears in the corner of your desktop’s screen while you are working in a word processor, or your phone signals a newly received text message while you’re playing a game, that’s multitasking at work.</p>
<p class="indent">Beyond the performance benefits of multiple processors and distributed processing, the importance of multitasking means some form of concurrency is required to provide the basic computing functionality we rely on daily.</p>
<h3 class="h3" id="ch08lev1sec02"><strong>How Concurrency Can Fail</strong></h3>
<p class="noindent">Although concurrency is a vital part of everyday computing, it creates enormous headaches for software and can produce serious problems if proper safeguards aren’t in place to prevent them.</p>
<p class="indent">The underlying issue is how data is copied when it’s used in calculations. Essentially, all a computer processor does is retrieve numbers from storage and either perform math with them or compare them. To do these tasks, though, it must copy the numbers from wherever they are stored to locations inside the processor. Stored data isn’t changed directly. Instead, the computer fetches the value from main memory, or a hard drive, or <a id="page_164"/>across a network, and delivers it to the innermost part of the processor. The processor performs the math on this internal copy, and then sends the updated value back to storage to replace the original data.</p>
<p class="indent">Suppose you’re playing a first-person shooter game. You have 300 bullets in reserve when you run over an ammo clip, picking up 20 more bullets. <a href="ch08.html#ch8fig2">Figure 8-2</a> shows the steps involved. To update your bullet count, the processor first retrieves your current bullet count and the number of bullets in the clip from their places in storage, shown in step 1. These values are fed into the inputs of an “adder” circuit in the processor, as shown in step 2, which performs the actual math. Then the result is sent back to main memory, replacing the old value in the bullet count storage location, as shown in step 3.</p>
<div class="image"><img alt="image" src="graphics/f08-02.jpg"/></div>
<p class="figuret"><a id="ch8fig2"/><em>Figure 8-2: Three steps to update a number from 300 to 320</em></p>
<p class="indent">This update sequence causes problems when multiple processes attempt to make alterations to the same storage location. Take, for example, a <em>massively multiplayer online game (MMO)</em>. Trina Orcslayer and Skylar Rockguardian are two players. They are both officers of the same “guild,” and this game allows guilds to hold shared bank accounts across multiple game servers. On Friday morning, the balance of the guild account is exactly 10,000 gold, and Skylar and Trina each have 500 gold in their personal accounts. Sometime that day, Skylar withdraws 300 gold <a id="page_165"/>from the guild account while Trina deposits 200 gold into it. If these are the only transactions that happen, the final balance should be 9,900 in the guild account (10,000 – 300 + 200), 800 in Skylar’s account (500 + 300), and 300 in Trina’s account (500 – 200).</p>
<p class="indentb">And that’s what will happen if the transactions are kept separate. Suppose Skylar makes the withdrawal in the morning, and Trina makes her deposit that afternoon. We won’t get into programming here, but let’s consider the steps that the game software will take to carry out these transactions. Let’s start with Skylar’s withdrawal:</p>
<p class="order1">1.   Retrieve the balance of the guild account. Call this <strong>Skylar’s copy</strong>.</p>
<p class="order1">2.   Subtract 300 gold from <strong>Skylar’s copy</strong>.</p>
<p class="order1">3.   Add 300 gold to Skylar’s personal stash.</p>
<p class="order1">4.   Update the guild bank balance to <strong>Skylar’s copy</strong>.</p>
<p class="indenttb">Now suppose Trina makes the deposit in the afternoon. The steps of her transaction are:</p>
<p class="order1">1.   Retrieve the balance of the guild account. Call this <strong>Trina’s copy</strong>.</p>
<p class="order1">2.   Subtract 200 gold from Trina’s personal stash.</p>
<p class="order1">3.   Add 200 gold to <strong>Trina’s copy</strong>.</p>
<p class="order1">4.   Update the guild bank balance to <strong>Trina’s copy</strong>.</p>
<p class="indentt">In this example everything works fine. But what happens if Skylar and Trina perform their transactions at the same time? In that case, the final balance of the guild account could be incorrect. This happens if the original guild balance of 10,000 gold is retrieved for calculation by both processes before either of them completes the transaction.</p>
<p class="indent">Take a look at the details shown in <a href="ch08.html#ch8tab1">Table 8-1</a>. When Trina and Skylar initiate transactions at the same time, the same 10,000 balance is retrieved into their separate copies of the balance. Trina’s copy is increased to 10,200, while Skylar’s copy is decreased to 9,700. Then both of the updated figures overwrite the guild account balance. In the example shown in the table, Skylar’s updated number arrives last, which means 9,700 is the new account balance and 200 gold has simply vanished.</p>
<p class="indent">It could have worked out the other way—Trina’s copy could have arrived after Skylar’s, increasing the guild’s gold balance, but of course neither result is correct. The only correct final balance is 9,900 gold, the balance that corresponds to the two transactions occurring separately.</p>
<p class="indent">Situations similar to this example are possible whenever two or more processes use the same data simultaneously. The general term for this situation is a <em>race condition</em>, since all the processes involved are racing to complete their task first. In this case the process that finishes last “wins,” because it determines the final value of the data.</p>
<p class="indent">While this example features two different processors, Trina’s and Skyler’s, it’s important to note that race conditions can happen even with a single <a id="page_166"/>processor. Because multitasking involves switching the processor to a different program many times a second, multiple processes operating on the same data could interleave, creating a race condition.</p>
<p class="tablet"><a id="ch8tab1"/><strong>Table 8-1:</strong> The Danger of Overlapping Bank Transactions</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Step</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Description</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Skylar’s copy</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Trina’s copy</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Guild balance</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table_co" valign="top"><p class="table">Trina 1</p></td>
<td class="table_co" valign="top"><p class="table">Retrieve the guild balance from the bank.</p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
<td class="table_co" valign="top"><p class="table">10,000</p></td>
<td class="table_co" valign="top"><p class="table">10,000</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Skylar 1</p></td>
<td class="table" valign="top"><p class="table">Retrieve the guild balance from the bank.</p></td>
<td class="table" valign="top"><p class="table">10,000</p></td>
<td class="table" valign="top"><p class="table"> </p></td>
<td class="table" valign="top"><p class="table">10,000</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">Trina 2</p></td>
<td class="table_co" valign="top"><p class="table">Subtract 200 gold from Trina’s stash.</p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
<td class="table_co" valign="top"><p class="table">10,000</p></td>
<td class="table_co" valign="top"><p class="table">10,000</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Trina 3</p></td>
<td class="table" valign="top"><p class="table">Add 200 gold to Trina’s copy of the guild balance.</p></td>
<td class="table" valign="top"><p class="table"> </p></td>
<td class="table" valign="top"><p class="table">10,200</p></td>
<td class="table" valign="top"><p class="table">10,000</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">Skylar 2</p></td>
<td class="table_co" valign="top"><p class="table">Subtract 300 gold from Skylar’s copy of the guild balance.</p></td>
<td class="table_co" valign="top"><p class="table">9,700</p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
<td class="table_co" valign="top"><p class="table">10,000</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Skylar 3</p></td>
<td class="table" valign="top"><p class="table">Add 300 gold to Skylar’s stash.</p></td>
<td class="table" valign="top"><p class="table">9,700</p></td>
<td class="table" valign="top"><p class="table"> </p></td>
<td class="table" valign="top"><p class="table">10,000</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">Trina 4</p></td>
<td class="table_co" valign="top"><p class="table">Send Trina’s copy of the guild balance to the bank.</p></td>
<td class="table_co" valign="top"><p class="table"> </p></td>
<td class="table_co" valign="top"><p class="table">10,200</p></td>
<td class="table_co" valign="top"><p class="table">10,200</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Skylar 4</p></td>
<td class="table" valign="top"><p class="table">Send Skylar’s copy of the guild balance to the bank.</p></td>
<td class="table" valign="top"><p class="table">9,700</p></td>
<td class="table" valign="top"><p class="table"> </p></td>
<td class="table" valign="top"><p class="table">9,700</p></td>
</tr>
</tbody>
</table>
<h3 class="h3" id="ch08lev1sec03"><strong>Making Concurrency Safe</strong></h3>
<p class="noindent">In order to make concurrency useful, then, we need to prevent race conditions. This requires enforcing rules on how processes can access data. The tighter the restrictions, the easier it is to prevent problems from occurring, but these restrictions can have an adverse effect on performance.</p>
<h4 class="h4" id="ch08lev2sec04"><strong><em>Read-Only Data</em></strong></h4>
<p class="noindent">One possible restriction is to allow processes to retrieve data simultaneously, but prohibit them from changing it; this is known as <em>read-only</em> data. This eliminates the possibility of a race condition but at an enormous cost. Most applications that require shared data access simply can’t work without the ability to change the data. So this method is rarely considered. However, as we’ll see later, distinguishing which processes want to change data from those that merely want to read data can improve the performance of concurrency.</p>
<h4 class="h4" id="ch08lev2sec05"><strong><em>Transaction-Based Processing</em></strong></h4>
<p class="noindentb">Another straightforward, comprehensive solution eliminates simultaneous data access entirely. The race condition occurs in the example because Skylar’s and Trina’s transactions overlap. What if we prevent overlapping <a id="page_167"/>transactions? To enforce this rule, once any bank transaction begins, we wait for it to signal its completion before any other transaction may start. For example, the steps in Skylar’s process now might look like this:</p>
<p class="order1">1.   Signal <strong>Start Transaction</strong> to the bank server.</p>
<p class="order1">2.   Retrieve the balance of the guild account. Call this <strong>Skylar’s copy</strong>.</p>
<p class="order1">3.   Subtract 300 gold from <strong>Skylar’s copy</strong>.</p>
<p class="order1">4.   Add 300 gold to Skylar’s personal stash.</p>
<p class="order1">5.   Update the guild bank balance to <strong>Skylar’s copy</strong>.</p>
<p class="order1">6.   Signal <strong>End Transaction</strong> to the bank server.</p>
<p class="indenttb">The steps in Trina’s process would be likewise bracketed:</p>
<p class="order1">1.   Signal <strong>Start Transaction</strong> to the bank server.</p>
<p class="order1">2.   Retrieve the balance of the guild account. Call this <strong>Trina’s copy</strong>.</p>
<p class="order1">3.   Subtract 200 gold from Trina’s personal stash.</p>
<p class="order1">4.   Add 200 gold to <strong>Trina’s copy</strong>.</p>
<p class="order1">5.   Update the guild bank balance to <strong>Trina’s copy</strong>.</p>
<p class="order1">6.   Signal <strong>End Transaction</strong> to the bank server.</p>
<p class="indentt">The bank server process enforces the transaction rules. When no transaction is under way, a signal to start a new transaction is immediately accepted. So if Trina’s transaction began during an idle period, it would continue. If, however, the <em>start transaction</em> signal from Skylar’s process arrived while Trina’s transaction was being processed, Skylar’s transaction would have to wait until Trina’s transaction finished. And if other transactions arrived during this time, the bank server would put them in a queue, to process them in the order in which they arrived.</p>
<p class="indent">This rule transforms the guild bank into the equivalent of a lobby with a single teller. If a customer arrives and the teller is available, the customer gets immediate service; otherwise, the customer must wait until the teller is free. This prevents race conditions but robs the system of the performance benefit of having multiple processors. Just as having one teller in a busy bank means a long wait for each customer, allowing only one transaction through the bank server at a time means a relatively long wait for each transaction.</p>
<p class="indent">The rule is much too strict. At any given time, the bank may be handling a large number of transactions, and few (if any) of them involve the same accounts. This rule prevents race conditions by preventing all overlapping transactions, even when the overlap is harmless.</p>
<h4 class="h4" id="ch08lev2sec06"><strong><em>Semaphores</em></strong></h4>
<p class="noindent">Another idea takes advantage of the fact that most of the transactions are not interacting with the same data. If the transaction rule is like a bank with a single teller, a better rule would be like a bank where every account <a id="page_168"/>has its own personal teller. Two or more customers attempting to access the same account at the same time will form a queue, but customers accessing different accounts won’t slow each other down at all.</p>
<p class="indent">The secret ingredient behind this technique is a special type of data called a <em>semaphore</em>. In nautical language, semaphores are flags that ships hoist to signal other ships; in software, semaphores are the numerical equivalent of flags, signaling whether or not logically connected data is in use. The simplest type of semaphore has just two possible values, 0 or 1, and is called a <em>binary semaphore</em>.</p>
<h5 class="h5" id="ch08lev3sec01"><strong>How Semaphores Prevent Race Conditions</strong></h5>
<p class="noindent">Returning to our guild bank account, we can avoid the race condition by creating semaphores on the bank server for each of the account balances. Each semaphore begins with a value of 1.</p>
<p class="indent">Before requesting an account balance, a process must first <em>acquire</em> the semaphore associated with that account. This acquire operation will check the value of the semaphore. If the semaphore is 1, it means no other process is using the associated balance; in this case, the semaphore changes to 0, and the process will be allowed to continue.</p>
<p class="indent">If the semaphore is already 0, though, it means another process is currently accessing the associated balance. In this case, the software will have to wait.</p>
<p class="indent">When a process completes its transaction, it <em>releases</em> the semaphore, which immediately sets its value back to 1. This allows one of the processes waiting for the semaphore to continue.</p>
<p class="indentb">Using semaphores, Skylar’s process would look like this:</p>
<p class="order1">1.   <strong>Acquire</strong> the semaphore for the guild account.</p>
<p class="order1">2.   Retrieve the balance of the guild account. Call this <strong>Skylar’s copy</strong>.</p>
<p class="order1">3.   Subtract 300 gold from <strong>Skylar’s copy</strong>.</p>
<p class="order1">4.   Add 300 gold to Skylar’s personal stash.</p>
<p class="order1">5.   Update the guild bank balance to <strong>Skylar’s copy</strong>.</p>
<p class="order1">6.   <strong>Release</strong> the semaphore for the guild account.</p>
<p class="indenttb">And Trina’s:</p>
<p class="order1">1.   <strong>Acquire</strong> the semaphore for the guild account.</p>
<p class="order1">2.   Retrieve the balance of the guild account. Call this <strong>Trina’s copy</strong>.</p>
<p class="order1">3.   Subtract 200 gold from Trina’s personal stash.</p>
<p class="order1">4.   Add 200 gold to <strong>Trina’s copy</strong>.</p>
<p class="order1">5.   Update the guild bank balance to <strong>Trina’s copy</strong>.</p>
<p class="order1">6.   <strong>Release</strong> the semaphore for the guild account.</p>
<p class="indentt">In this way, Skylar and Trina are prevented from accessing the guild balance at the same time, preventing the race condition. Additionally, neither transaction will affect any other transaction that doesn’t deal with this particular account.</p>
<h5 class="h5" id="ch08lev3sec02"><a id="page_169"/><strong>How Semaphores Are Made</strong></h5>
<p class="noindentb">Now let’s look at how semaphores are actually made. If semaphores aren’t implemented with care, they can produce the very race conditions they are intended to prevent. Although the acquire operation is just one step for Skylar’s and Trina’s processes, in reality, it takes several steps itself:</p>
<p class="order1">1.   Retrieve the value of the semaphore.</p>
<p class="order1">2.   If the value is 0, go back to step 1 and try again.</p>
<p class="order1">3.   Set the semaphore to 0.</p>
<p class="indentt">Now consider what happens if both Skylar’s and Trina’s processes attempt to acquire the guild account semaphore at the same time. If the semaphore had a value of 1, both processes could retrieve this initial value (in step 1) before either had a chance to check the value and set it to 0. In this case, both processes would think that they were the only process that had acquired the semaphore, and were therefore free to do whatever they wanted with the accompanying bank balance. We’re right back where we started.</p>
<p class="indent">To make a semaphore, then, software needs some help from hardware. The processor on the bank server must be able to implement the acquire and release operations in such a way that nothing can interrupt them. This is known as making the operations <em>atomic</em>, which in this sense means indivisible.</p>
<p class="indentb">Modern processors implement a hardware operation known as <em>test-andset</em>. This sets a byte in main memory to a particular value, while retrieving the previous value for inspection. Test-and-set makes semaphores possible. In the list of semaphore steps, the problem is the potential interruption between steps 1 and 3. If two different processes execute the first step before either reaches the third step, both will be able to alter the data that the semaphore is supposed to protect. Using the atomic test-and-set operation, though, a semaphore acquire operation can be implemented like this:</p>
<p class="order1">1.   Using test-and-set, set the semaphore to 0 and retrieve the old value.</p>
<p class="order1">2.   If the old value was 0, go back to step 1 and try again.</p>
<p class="indentt">Now the race condition cannot happen. If two processes attempt to acquire the same semaphore at the same time, they will each execute the test-and-set in step 1. Both operations will set the semaphore value to 0, but only the semaphore that tests-and-sets first will retrieve a 1. The other process will retrieve a 0. One process will immediately continue, while the other will have to wait.</p>
<h3 class="h3" id="ch08lev1sec04"><strong>The Problem of Indefinite Waits</strong></h3>
<p class="noindent">A process acquiring a semaphore using this two-step plan—continuously checking the semaphore’s value until it changes back to 1—is said to be in a <em>spin lock</em>. This is the simplest way to wait for a semaphore to become <a id="page_170"/>available, but it has two major problems. First, it wastes processor time. A process in a spin lock is continuously executing code, but the code isn’t doing anything useful. Secondly, spin locks can be unfair. In some cases, some processes cannot check the semaphore as fast as others. Perhaps the process is executing on a slower processor, or perhaps the process is communicating with a server across a slower network. Regardless of the reason, if a semaphore’s resource is so popular that multiple processes are always waiting, a slower-checking process might never be able to snag the semaphore. This is known as <em>starvation</em>; picture the least-assertive person at a busy restaurant with only one waiter, and you’ll get the idea.</p>
<h4 class="h4" id="ch08lev2sec07"><strong><em>Orderly Queues</em></strong></h4>
<p class="noindent">Avoiding starvation requires a more organized approach to waiting. Banks organize the wait in their lobbies with cordons, forming groups of waiting customers into orderly queues. Semaphores can be designed to do the same thing. Rather than waste time continually checking the value of the semaphore, many acquire operations written so that when they do not succeed immediately, they put their process to sleep, so to speak. Putting a computer or phone to sleep means suspending all running applications in a way that allows the applications to be restored quickly. In the same way, if a process cannot immediately acquire a semaphore, it will be suspended and flushed out of the processor, but its internal data will remain in storage.</p>
<p class="indent">To accomplish this, the computer’s operating system assigns each process a unique identification number. When an acquire operation has to wait, the process identifier is placed at the end of that semaphore’s wait list. When the process currently holding that semaphore releases it, the first process on the list is awakened. In this way, processes acquire the semaphore in the same order they request it. A process may have to wait to acquire a popular semaphore, but will eventually get to the top of the list— it won’t starve.</p>
<h4 class="h4" id="ch08lev2sec08"><strong><em>Starvation from Circular Waits</em></strong></h4>
<p class="noindent">Although semaphores prevent race conditions when implemented and used correctly, they can cause starvation when processes need to access multiple pieces of data that are protected by semaphores.</p>
<p class="indent">Suppose Skylar and Trina’s guild opens a second account that is accessible to lower-ranked guild officers, so now the guild has a main account and a secondary account. The banking system has implemented semaphores for each individual account, eliminating the chance of a race condition on any guild transactions.</p>
<p class="indentb">But on a particular day, Skylar and Trina are each transferring 200 gold from one account to the other in opposite directions. Both transactions involve debiting one account and crediting the other. Skylar’s transaction would have these steps:</p>
<p class="order1">1.   <strong>Acquire</strong> the semaphore of the main account balance.</p>
<p class="order1">2.   Retrieve the balance of the main account.</p>
<p class="order1"><a id="page_171"/>3.   <strong>Acquire</strong> the semaphore of the secondary account balance.</p>
<p class="order1">4.   Retrieve the balance of the secondary account.</p>
<p class="order1">5.   Add 200 gold to the secondary account balance.</p>
<p class="order1">6.   Subtract 200 gold from the main account balance.</p>
<p class="order1">7.   Update the secondary account balance.</p>
<p class="order1">8.   Update the main account balance.</p>
<p class="order1">9.   <strong>Release</strong> the semaphore of the secondary account.</p>
<p class="order1">10. <strong>Release</strong> the semaphore of the main account.</p>
<p class="indenttb">Trina’s transaction would run like this:</p>
<p class="order1">1.   <strong>Acquire</strong> the semaphore of the secondary account balance.</p>
<p class="order1">2.   Retrieve the balance of the secondary account.</p>
<p class="order1">3.   <strong>Acquire</strong> the semaphore of the main account balance.</p>
<p class="order1">4.   Retrieve the balance of the main account balance.</p>
<p class="order1">5.   Add 200 gold to the main account balance.</p>
<p class="order1">6.   Subtract 200 gold from the secondary account balance.</p>
<p class="order1">7.   Update the main account balance.</p>
<p class="order1">8.   Update the secondary account balance.</p>
<p class="order1">9.   <strong>Release</strong> the semaphore of the main account.</p>
<p class="order1">10. <strong>Release</strong> the semaphore of the secondary account.</p>
<p class="indentt">Because all shared value access is properly bracketed by the acquisition and release of associated semaphores, no race conditions can occur from the overlapping execution of these transactions. However, suppose both transactions begin around the same time and the first few steps interleave as shown in <a href="ch08.html#ch8tab2">Table 8-2</a>.</p>
<p class="tablet"><a id="ch8tab2"/><strong>Table 8-2:</strong> Multiple Semaphores Leading to Indefinite Waiting</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Step</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Description</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Main account semaphore</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Secondary account semaphore</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table_co" valign="top"><p class="table"> </p></td>
<td class="table_co" valign="top"><p class="table">Initial state.</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Skylar 1</p></td>
<td class="table" valign="top"><p class="table">Acquire the semaphore of the main account balance.</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
<td class="table" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">Skylar 2</p></td>
<td class="table_co" valign="top"><p class="table">Retrieve the balance of the main account.</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
<td class="table_co" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Trina 1</p></td>
<td class="table" valign="top"><p class="table">Acquire the semaphore of the secondary account balance.</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">Trina 2</p></td>
<td class="table_co" valign="top"><p class="table">Retrieve the balance of the secondary account.</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Skylar 3</p></td>
<td class="table" valign="top"><p class="table">Acquire the semaphore of the secondary account balance.</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
<td class="table" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td class="table_co" valign="top"><p class="table">Trina 3</p></td>
<td class="table_co" valign="top"><p class="table">Acquire the semaphore of the main account balance.</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
<td class="table_co" valign="top"><p class="table">0</p></td>
</tr>
</tbody>
</table>
<p class="indent"><a id="page_172"/>I’ve shown only these steps because these are the only steps that would occur. Both Skylar’s and Trina’s processes would halt at step 3, because both are trying to acquire semaphores that aren’t available. What’s worse is that they can never become available, because each is being held by the other process. This is like waiting for traffic to clear so you can turn left on a two-lane road, but someone going the other way wants to turn left behind you, as shown in <a href="ch08.html#ch8fig3">Figure 8-3</a>.</p>
<div class="image"><img alt="image" src="graphics/f08-03.jpg"/></div>
<p class="figuret"><a id="ch8fig3"/><em>Figure 8-3: If both white cars are waiting to turn left, traffic is stopped.</em></p>
<p class="indent">Because neither process in this example can continue until the other process completes, this situation is known as a <em>circular wait</em>. In this case, the circular wait involves only two processes, but circular waits sometimes involve many processes, and is therefore difficult to detect or foresee. A circular wait is one form of <em>deadlock</em>, which describes a situation in which a process cannot be expected to continue. Circular waits are one way that concurrency can cause deadlocks, and unless precautions are taken, a circular wait can occur whenever processes hold multiple semaphores at once. Fortunately, such precautions can be easy to implement.</p>
<p class="indent">One solution is a rule by which semaphores must be acquired in some specified order. In our example, the game’s bank management system can internally assign each account a number, and require processes to acquire account semaphores in numerical order. Or, put more broadly, a process can acquire an account’s semaphore only when it does not currently hold a semaphore for an account with a higher number. This rule prevents the circular wait in the previous example. Let’s suppose the main account is 39785 and the secondary account is 87685. Because the main account number is lower, both Skylar’s and Trina’s processes would attempt to acquire its semaphore first. If both processes tried at the same time, only one process would succeed. That process would then acquire the semaphore for the secondary account and complete the transaction, at which point both account semaphores would be released, allowing the other process to continue through completion.</p>
<h3 class="h3" id="ch08lev1sec05"><strong>Performance Issues of Semaphores</strong></h3>
<p class="noindent">With the proper rules in place, semaphores enable concurrency without fear of race conditions, deadlock, or starvation. However, in situations where we are trying to boost performance by having multiple processors work together on the same job, enforcing these semaphore rules can limit the performance benefit we hoped to create. Instead of lots of processors <a id="page_173"/>working together, we are left instead with lots of processors waiting in line for an opportunity to work. Concurrent software can mitigate these performance issues by creating additional rules.</p>
<p class="indent">Sometimes a process needs access to a piece of data but doesn’t need to change it. In our running guild bank example, suppose Skylar and Trina are both inspecting the main guild account at the same time—that is, neither player is depositing or withdrawing, but is merely checking the balance. In this case, no danger arises from the simultaneous access of the account. Even though the processes would have potentially overlapping retrieval operations, as long as neither one of them updated the balance, everything would be fine.</p>
<p class="indentb">Allowing simultaneous access during “read-only” situations greatly improves multiprocessor performance, and requires only a modification of the semaphore concept. Instead of having one semaphore for each piece of data to be shared, we’ll have two: a <em>read</em> semaphore and a <em>write</em> semaphore, subject to the following rules:</p>
<p class="bull">• Acquiring the associated <em>write</em> semaphore allows data to be retrieved or updated, just like how the semaphores worked in previous examples.</p>
<p class="bull">• Acquiring the associated <em>read</em> semaphore allows data to be retrieved, but not updated.</p>
<p class="bull">• A <em>write</em> semaphore can be acquired only when no process holds a semaphore (of either type) for that data.</p>
<p class="bull">• A <em>read</em> semaphore can be acquired only when no process holds a <em>write</em> semaphore for that data.</p>
<p class="indentt">Following these rules means that at any given time, either one process will have acquired the write semaphore for a piece of data or one or more processes will have acquired read semaphores for that data. At first, this appears to be what we want. So long as processes are merely looking at, but not changing data, they can share access. Once a process needs to change the data, all other processes are locked out until the updating process completes its work.</p>
<p class="indent">Unfortunately, these rules potentially reintroduce the starvation problem. As long as read-only processes keep arriving, a process that needs a write semaphore might wait indefinitely. To prevent this from happening, we can modify the last rule as follows: “a read semaphore can be acquired only when no process is holding or waiting for a write semaphore.” In other words, once a process attempts to acquire a write semaphore, all processes arriving later must wait behind it.</p>
<p class="indent">Another potential concern for performance is known as <em>granularity</em>, which in this context refers to whether we lock up individual pieces or collections of data. For example, the bank system could use semaphores to protect individual data elements, such as the balance of the main guild account, or it could apply a single read/write pair for all data related to a particular guild’s finances, such as the balances of all guild accounts, the list of guild officers who are allowed to access that account, and so on.</p>
<p class="indent"><a id="page_174"/>Protecting data as a group can cause more waiting, because a process that may need only one or two numbers in a data group will have to lock up all the data in the group, potentially blocking another process that needs other, nonoverlapping data from the group. Very fine granularity can also hinder performance. Acquiring and releasing semaphores takes time, and with lots of semaphores, it’s possible for processes to spend most of their time dealing with them. Developers must therefore carefully determine the best granularity for a particular application.</p>
<h3 class="h3" id="ch08lev1sec06"><strong>What’s Next for Concurrency</strong></h3>
<p class="noindent">For several reasons, we can expect concurrency to be an even greater concern for the future.</p>
<p class="indent">These days, multiple processing cores can be found even in our simplest computing devices. The push for more processing power will continue, and until the arrival of a new processing paradigm like quantum computing, more processing power will mean more processor cores.</p>
<p class="indent">Multitasking is now the norm. We expect our computing devices to run multiple applications at the same time, and to interrupt our foreground tasks when something interesting happens in the background.</p>
<p class="indent">Data and devices are becoming more connected than ever. Data and processing are increasingly being moved from client devices onto servers or clouds of interconnected servers. In computer gaming, socialization is the new paradigm, and in some games, even single-player game modes require an Internet connection.</p>
<p class="indent">In short, properly handling concurrency is becoming essential in everyday computing. What looks like a single computer running a single-user application may contain a multiprocessor that provides a multitasking environment with shared cloud storage for data. The vital power of concurrency is thus often invisible. As the trend toward even greater concurrency continues, we may take for granted the way in which so many processes work together without running into one another. But future improvements in computing depend upon further advancements in concurrency control. We don’t know yet whether current methods of preventing deadlock, starvation, and race conditions will be sufficient as concurrency increases. If current methods are inadequate for solving future challenges, they will become the bottleneck until better methods are developed.</p>
</body></html>