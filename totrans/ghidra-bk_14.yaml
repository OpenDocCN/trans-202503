- en: '## **11'
  prefs: []
  type: TYPE_NORMAL
- en: COLLABORATIVE SRE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, you should be comfortable navigating the Ghidra project environment
    and the many available tools and windows. You know how to create a project, import
    files, navigate, and manipulate the disassembly. You understand Ghidra data types,
    data structures, and cross-references. But do you understand scale? A 200MB binary
    is likely to generate a disassembly that is millions of lines long and consists
    of hundreds of thousands of functions. Even with the largest, portrait-oriented
    monitor you can find, you’ll be able to view only a few hundred lines of that
    disassembly at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to take on such a monumental task is to assign a team of people to
    it, but that introduces an additional problem: how will you synchronize everyone’s
    efforts so that people aren’t walking all over one another with their changes?
    It’s time to extend our discussion of using Ghidra to cover a collaborative team
    working together on a shared project. Ghidra’s support for collaborative reverse
    engineering alone makes it unique among software analysis tools. In this chapter,
    we introduce Ghidra’s collaboration server, which is included with the standard
    Ghidra distribution. We discuss its installation, configuration, and use to help
    you get more eyes focused on your most challenging RE problems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Teamwork**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SRE is a complex process, and few individuals are experts in all of its intricacies.
    The ability to have analysts with different skill sets simultaneously analyzing
    a single binary can drastically reduce the amount of time needed to obtain the
    desired results. A rock star in navigating control flows through a complex program
    may dread having to analyze and document the associated data structures. An expert
    in malware analysis may be ill-suited for vulnerability discovery work, and anyone
    who is pressed for time is less likely to use that time inserting the inevitable
    plethora of comments that will certainly be useful down the road, but may in the
    short run keep them from analyzing additional code. Five colleagues may want to
    individually analyze the same binary but recognize that there are certain steps
    in the process that they will all need to do. An individual may need to pass off
    an assignment to a colleague for expert input or while on vacation. Sometimes,
    it is just helpful to have multiple sets of eyes looking at the same thing for
    sanity checks. Regardless of the motivation, the shared project capability within
    Ghidra supports collaborative SRE in many forms.
  prefs: []
  type: TYPE_NORMAL
- en: '### **Ghidra Server Setup**'
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration in Ghidra is facilitated by a shared Ghidra Server instance. If
    you are the system administrator responsible for setting up the Ghidra Server,
    you have a lot of choices to make, like whether to deploy it on a bare-metal server
    or in a virtual environment for ease of migration and repeatable installation.
    The deployment we use in this chapter to demonstrate Ghidra’s collaborative features
    is suitable for development and experimentation only. If you are configuring a
    Ghidra Server for production use, you should carefully read the Ghidra Server
    documentation and determine an appropriate configuration for your environment
    and specific use case. (An entire book could be written to describe Ghidra Server
    setup and all the installation options and associated approaches, but that isn’t
    this book.)
  prefs: []
  type: TYPE_NORMAL
- en: Although Ghidra Server can be configured on all platforms that support Ghidra,
    we will describe running a Ghidra Server instance in a Linux environment and assume
    some familiarity with the Linux command line and system administration. We will
    make a few minor modifications to the Ghidra Server configuration file (specified
    in *server/server.conf*) to facilitate the concepts that we want to demonstrate
    in this chapter so that we are not overly reliant on use of the Linux command
    line interface after we complete the initial installation, configuration, administration,
    and access control. Modifications include changing the default Ghidra repository
    directory to one of our own choosing, as recommended in the Ghidra Server documentation,
    and tuning user management and access control settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**GHIDRA SERVER SPECIALS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Ghidra Server is happy to offer you the following installation options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platforms** Bare metal, virtual machine, containers, and more!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating systems** Multiple flavors of Windows, Linux, and macOS. Something
    to suit every taste.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication methods** Choose how friends and colleagues are able to access
    your offerings—from “open to the general public” to “PKI only” and everything
    in between.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparation** You can install from a container, a script, *.bat* files, or
    detailed instructions, or you can make your own recipe by banging away at the
    console until something exciting happens.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see what you like, don’t worry, as this is just a subset of what
    is available. Ghidra Server options can meet the needs of even the most discriminating
    guests to provide them with the Ghidra installation of their dreams. Thank you
    for visiting your Ghidra Server. For more information, see the extended server
    menu, *server/svrREADME.html*, available in a Ghidra directory near you.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps walk you through a scripting process to create an environment
    and initial set of Ghidra users on an Ubuntu host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define some environment variables used throughout the script including the
    Ghidra version you are installing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the two packages (*unzip* and *OpenJDK*), which are needed to complete
    the installation and run the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a nonprivileged user to run the server and create a directory for hosting
    shared Ghidra repositories outside the directory in which Ghidra Server will be
    installed. Keeping the server executables and your repositories in separate directories
    is recommended in the server configuration guide and facilitates future server
    updates. The Ghidra Server administration tool (svrAdmin) will use the home directory
    of the server admin user. [PRE2]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download Ghidra, unzip it, and move it to the server root directory. Make sure
    that you grab the latest public release when you are downloading Ghidra (the release
    date is in the *.zip* filename):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a backup of the original server configuration file and change the location
    in which the repositories will be saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `-u` parameter to your Ghidra Server launch parameters, so users can
    specify a username when connecting, instead of being forced to use their local
    username. This option allows us to log in as several different users from a single
    machine for demonstration purposes, and allows us to log in to the same account
    from several machines. (Some versions of Ghidra expect the repository path to
    be the last command line parameter, so we changed `parameter.2` to `parameter.3`
    and then added the new `parameter.2=-u` before that updated line.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the ownership of the Ghidra Server process and the Ghidra Server directory
    to the *ghidrasvr* user. (Because this was just a demonstration server, we left
    all other parameters unchanged. You are strongly advised to read *server/svrREADME.html*
    to determine the configurations appropriate for a production deployment.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, install the Ghidra Server as a service and add users authorized to
    connect to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While a more detailed discussion of access control comes later in the chapter,
    it is important to mention here since the users need to exist in the authentication
    system that your Ghidra Server instance uses. This happens on the Ghidra Server
    itself. By default, each user must log in from a Ghidra client within 24 hours
    by using the default password *changeme* (which must be changed during the initial
    login). If a user does not activate their account within 24 hours, the account
    is locked and must be reset. Ghidra provides the Ghidra Server System Administrator
    with several options for authentication, ranging from simple passwords to public
    key infrastructure(PKI). We chose to use a local Ghidra password (which is the
    default).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to install your own Ghidra Server or just need a more in-depth description
    of the various installation options, see *server/svrREADME.html* in your Ghidra
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE PROJECT REPOSITORY**'
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of working together as a team is that multiple people can work
    on the same binary at the same time. One disadvantage of working together as a
    team is that multiple people can work on the same binary at the same time. Whenever
    multiple users are interacting with the same content, there is a potential to
    introduce race conditions. In a *race condition*, the order in which the operations
    (such as saving an updated file) are performed can affect the final outcome. Ghidra
    has a project repository and versioning system to control which changes are committed,
    when, and by whom.
  prefs: []
  type: TYPE_NORMAL
- en: The Ghidra repository checks files in and out, tracks version history, and lets
    you see what is currently checked out. When you check out a file, you get a copy
    of the file. When you have finished working with the file and check the file back
    in, a new version of the file is created and becomes part of the file’s legacy,
    and if someone else has also checked in a new version of the file, the repository
    helps resolve any conflicts. We demonstrate interactions with the repository later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared Projects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, we have created and worked with only standalone Ghidra projects,
    suitable for use by a single analyst working on a single computer. Now that you
    have configured and given yourself access to a Ghidra Server, let’s walk through
    the process of creating a shared project. A shared project can be made accessible
    to any users who are authorized to connect to your Ghidra Server and facilitates
    collaborative, concurrent access to the project.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Creating a Shared Project***'
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new project (File ▸ New Project) and select Shared Project,
    you must specify the server information associated with your Ghidra Server, as
    shown on the left in [Figure 11-1](ch11.xhtml#fig11_1). The default port number
    (13100) is provided, but you must supply the server’s hostname or IP address,
    and may need to authenticate yourself, depending on the configuration of your
    Ghidra Server.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Logging in to a Ghidra Server repository*'
  prefs: []
  type: TYPE_NORMAL
- en: On the right side of the figure, we log in as one of the users created by our
    installation script (*user1*). If this is the first time logging in as this user,
    you will need to change the password from *changeme*, as discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, select an existing repository or create a new one by entering a new repository
    name, as shown in [Figure 11-2](ch11.xhtml#fig11_2). For this example, we will
    create a new repository named *CH11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The New Project dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking **Next** creates a new repository and a new project and takes you to
    the now-familiar Project window ([Figure 11-3](ch11.xhtml#fig11_3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Project window for shared project showing Table View*'
  prefs: []
  type: TYPE_NORMAL
- en: We have imported some files ➊ and are displaying them using a table instead
    of the default tree structure for project files. The *Table View*, which is one
    of the tabbed layout choices ➋, provides much more information about each of the
    project’s files. The Project window shows the name of the project repository (*CH11*),
    your role on the project (Administrator), and an icon to the right to provide
    information about your connection to the server ➌. In this case, hovering over
    the icon ➍ displays the message “Connected as user1 to 172.16.4.35.” If you were
    not connected, the icon would be a broken link rather than the connected link
    shown in the image.
  prefs: []
  type: TYPE_NORMAL
- en: '***Project Management***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once a project has been created and has an administrator, authorized users can
    log in to the server and work with the project. A successful login takes you to
    the Ghidra Project window, where you will have access to your authorized projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHO’S THE BOSS AROUND HERE?**'
  prefs: []
  type: TYPE_NORMAL
- en: The server administrator is responsible for creating Ghidra Server accounts
    and configuring an authentication protocol for connections to the server. Server
    administration is an inherently command line–oriented activity, and there is no
    requirement for the server administrator to be a Ghidra user themselves. On the
    client side, any authorized user may create repositories on the Ghidra Server,
    automatically becoming the administrator of each repository they create. This
    gives them complete control of the repository, including who can access it and
    the type of access each user can have. After creation, administrators may grant
    access to additional authorized users via Ghidra’s Project window.
  prefs: []
  type: TYPE_NORMAL
- en: '**I DON’T WANT TO SHARE**'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Ghidra Server installation for nonshared projects has advantages as
    well. Your initial introduction to Ghidra focused on installing Ghidra on a single
    computer and using that computer to access your projects and files (which were
    all stored on that computer). This means all analysis work depends on that computer.
    Ghidra Server facilitates multipoint access to your files from a wide variety
    of devices. You can require authentication before your files are accessed, and
    you can convert your projects from nonshared to shared if desired. One limitation
    is that you need to be connected to the Ghidra Server to check out or check in
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '### **Project Window Menus**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created and connected to a Ghidra Server, the options available
    in the Project window become more meaningful, as some of the previously unavailable
    options now have a new context. Here, as well as in [Chapter 12](ch12.xhtml#ch12),
    we discuss the individual menu components and how they can be used to improve
    your analysis process.
  prefs: []
  type: TYPE_NORMAL
- en: '***File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The File menu is shown in [Figure 11-4](ch11.xhtml#fig11_4). The first five
    options in the File menu are pretty standard file-type operations, and their behavior
    is what you would expect from menu-driven applications. We’ll discuss the notable
    options, marked with numerals, in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: File menu*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting Projects**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Deleting a project ➊ is a permanent action in Ghidra that cannot be undone.
    Fortunately, it takes effort and requires confirmation. First, you cannot delete
    your active project. This minimizes the danger of an accidental deletion. To delete
    a project, you must complete the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose **File** ▸ **Delete Project** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to (or enter the name of) the project to be deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that you want to delete the project in the resulting confirmation window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting a project deletes all of its associated files. For that reason, it
    may be wise to first archive the project via the Archive Current Project option
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**Archiving Projects**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Archiving a project allows you to save a snapshot of the project, its associated
    files, and associated tool configurations. Reasons for archiving a pro­ject include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You are going to delete the project but want to preserve a copy “just in case.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to package a project for migration to another server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want a version you can easily transfer between Ghidra versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to create a backup of a project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to archive a project:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the CodeBrowser window and all associated tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **File** ▸ **Archive Current Project** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a location and name for the archive file on your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you choose the name of an existing file, you will have the opportunity to
    change the name or overwrite the existing file. Archived files can easily be restored
    through the Restore Project option.
  prefs: []
  type: TYPE_NORMAL
- en: '**Batch Import**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Batch Import option (at ➌ in [Figure 11-4](ch11.xhtml#fig11_4)) allows you
    to import a collection of files into a project in a single operation. When you
    choose File ▸ Batch Import, Ghidra presents a file browser window similar to the
    one shown in [Figure 11-5](ch11.xhtml#fig11_5). This window allows you to navigate
    to the directory containing the files you wish to import.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: Batch file import selection window with files selected*'
  prefs: []
  type: TYPE_NORMAL
- en: You can select a file (or files) from a single directory, or an entire directory,
    to add to the batch import list. After you highlight the files and click the Select
    files button, you are taken to the Batch Import window, which shows you the files
    you have already selected for import. In [Figure 11-6](ch11.xhtml#fig11_6), the
    files from the directory *BinBatchImport1* were loaded as individual files, and
    the directory *BinBatchImport2* was added as a directory with five files, as shown
    to the right of the directory name. You can add/remove files to refine your import
    list and control several options, including the depth of recursion to search for
    files in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the appropriate depth limit in the Batch Import window, or simply
    to explore the filesystem, use the Open File System menu option (at ➍ in [Figure
    11-4](ch11.xhtml#fig11_4)). This option opens the selected file system container
    (*.zip* file, *.tar* file, directory, and so on) in a separate window. (It is
    best to determine the depth beforehand because you would need a second Ghidra
    instance open to operate both windows simultaneously. Each window blocks access
    to the other in a single instance.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: Batch file import confirmation dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Edit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Edit menu is shown in [Figure 11-7](ch11.xhtml#fig11_7). The Tool Options
    and Plugin Path options are be discussed in [Chapter 12](ch12.xhtml#ch12), but
    the PKI options are related to the Ghidra Server setup and merit discussion in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Edit menu*'
  prefs: []
  type: TYPE_NORMAL
- en: '##### **PKI Certificates**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned at the start of this chapter, when you set up a Ghidra Server,
    you can choose from several authentication methods. We set up a simple server
    that uses a username and password for authentication. PKI certificates are more
    complex. While PKI implementations can vary, the following example represents
    a reasonable PKI client authentication process for Ghidra Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '*User1* wants to be authenticated so she can work on her Ghidra Server project.
    She has a client certificate that includes her username and a public cryptographic
    key. She also has a private cryptographic key corresponding to the public key
    contained in the certificate, which she keeps safely hidden away for important
    occasions such as this. Her certificate was cryptographically signed by a certificate
    authority (CA) that is trusted by the Ghidra Server.'
  prefs: []
  type: TYPE_NORMAL
- en: '*User1* presents the server with her certificate, from which the server can
    extract the public key and username. The server runs checks to confirm the certificate
    is valid (for example, is not on a Certificate Revocation List, is within a valid
    date range, and has a valid signature from a trusted CA, and possibly others).
    If all checks pass, the server confirms a valid certificate and binds *User1*’s
    identity to a public key. Now *User1* needs to prove she has the corresponding
    private key so the Ghidra Server can verify it against the extracted public key.
    As long as the private key is truly held by only *User1*, the Ghidra Server correctly
    validates her certificate, and the server verifies that *User1* actually possesses
    the private key, so *User1* is considered to be authenticated.'
  prefs: []
  type: TYPE_NORMAL
- en: The process for managing PKI certificate authorities is described in the Ghidra
    Server readme file (*server/svrREADME.html*). The Set PKI Certificate and Clear
    PKI Certificate menu options enable a user to associate (or disassociate) themselves
    with a key file (**.pfx*, **.pks*, **.p12*). When setting a PKI certificate, the
    user will be provided a file navigation window to identify the appropriate keystore.
    The certificate can be cleared at any time with the Clear PKI Certificate option.
    Should you choose to enable PKI authentication, Java’s `keytool` utility may be
    used to manage keys, certificates, and Java keystores.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Project***'
  prefs: []
  type: TYPE_NORMAL
- en: The Project menu, shown in [Figure 11-8](ch11.xhtml#fig11_8), provides facilities
    for managing project-level activities, including viewing and copying from other
    projects, changing your password, and managing user access to projects that you
    administer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: Project menu*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing Projects and Repositories**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first four options ➊ are related to viewing projects and repositories.
    The first two, View Project and View Repository, open read-only versions of a
    project (local) or repository (remote server) in a new window adjacent to the
    Active Project window. In [Figure 11-9](ch11.xhtml#fig11_9), the local project
    *ExtraFiles* has been opened beside the active project. You can explore the read-only
    project or drag any file or directory from the Read-Only Project Data window to
    the Active Project window. In [Figure 11-9](ch11.xhtml#fig11_9), the three selected
    files (with the extension *NEW*) have been copied from the Project Data window
    to the active project: *CH11*.'
  prefs: []
  type: TYPE_NORMAL
- en: The next option, View Recent, provides a list of recent projects that can speed
    up the process of locating a project or repository. Close View closes the read-only
    view (although in some versions of Ghidra, this option appears to be inactive).
    A simpler reliable alternative is to click the X at the bottom of the project
    tab you wish to close, as seen in the bottom right of [Figure 11-9](ch11.xhtml#fig11_9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-9: Using Project window to view another project*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing Passwords and Project Access**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Change Password option (at ➋ in [Figure 11-8](ch11.xhtml#fig11_8)) is available
    only to users on shared projects, provided that the Ghidra Server is configured
    with an authentication method that allows a password change. This is a two-step
    process with an initial confirmation dialog, as shown in [Figure 11-10](ch11.xhtml#fig11_10),
    followed by the same password change option dialog used for the initial mandatory
    password change.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-10: Password change initial confirmation dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: While users can each control their own passwords, shared projects also offer
    the capability to control who can access a project and what permissions are granted
    to each user. As mentioned earlier in the chapter, the Ghidra Server system administrator
    has some control over access. Specifically, an administrator can assign an administrator
    to a repository and create and delete user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, if you are an administrator, you can also control access
    through the Edit Project Access List option (at ➌ in [Figure 11-8](ch11.xhtml#fig11_8))
    from the Project menu. When it is selected, you will see the dialog shown in [Figure
    11-11](ch11.xhtml#fig11_11), which allows you to add and remove users from the
    project and to control their associated permissions. Each user can be placed in
    exactly one privilege class, from least privileged (Read Only to the left) to
    most privileged (Admin on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-11: Access control window*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing Project Information**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final menu option is View Project Info (at ➍ in [Figure 11-8](ch11.xhtml#fig11_8)).
    The options available in the resulting dialog depend on the whether the project
    is hosted on a Ghidra Server. Examples of nonserver-based (left) and server-based
    (right) project information dialogs are shown in [Figure 11-12](ch11.xhtml#fig11_12).
    While the information displayed is pretty straightforward, buttons at the bottom
    of each window allow you to convert a nonshared project to a shared project (with
    the Convert to Shared button) or change project information.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the Convert to Shared button opens a dialog that asks you to specify
    the server information and enter the user ID and password for the project administrator.
    The subsequent steps allow you to specify a repository, add users, set their permissions,
    and confirm that you want to convert the project. Note that this operation cannot
    be undone and removes all existing local version history.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: Project information windows for nonshared and shared projects*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Repository**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you may be wondering how projects can be shared while maintaining
    project integrity. This section covers the process that Ghidra uses to ensure
    that everyone’s work is retained in a shared project that a team can work on concurrently.
    Before we delve too deeply into the process, let’s investigate the file types
    associated with a shared Ghidra project. We start with discussing the relationship
    between a project and a repository.
  prefs: []
  type: TYPE_NORMAL
- en: A repository is the key facilitator of the versioning process. When you create
    a new nonshared project, a project file (*.gpr* file) and a repository directory,
    with a *.rep* extension, are created to facilitate version control. Additional
    files are created to control locks, versioning, and so on, but understanding the
    purpose of each file is not critical to successful Ghidra usage. For nonshared
    projects, all files reside on your computer within the directories that you specify
    at project creation time (refer to [Chapter 4](ch04.xhtml#ch04)).
  prefs: []
  type: TYPE_NORMAL
- en: When you create a shared project, you have the option of creating a new repository
    or selecting from existing repositories, as discussed earlier in the chapter (refer
    to [Figure 11-2](ch11.xhtml#fig11_2)). If you create a new project and a new repository
    at the same time, a one-to-one relationship exists between the project and its
    repository, and you become the project administrator. If you choose an existing
    repository, you are creating a new project for which you are not the project administrator
    (unless you owned the repository). In either case, the *.gpr* file and the *.rep*
    directory share the same base name. If the repository is named RepoExample, the
    project file will be named *RepoExample.gpr* and the repository folder will be
    named *RepoExample.rep*. (Despite having an extension, the repository is a directory
    rather than a file.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum it up: if you create the repository, you are the project administrator
    and can choose who else can access your repository. If you use an existing repository,
    you are a user with the rights and privileges that have been assigned to you by
    the project administrator. So what happens when multiple users want to make changes
    to the same project? That’s where version control comes into play.'
  prefs: []
  type: TYPE_NORMAL
- en: '**VERSION CONTROL VS. VERSION TRACKING**'
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra includes two very different versioning systems. In this chapter, we are
    discussing version control, and hopefully that concept will become quite clear
    shortly. Ghidra also has a *version tracking* capability. Version tracking is
    used to identify differences (and similarities) between two binaries. In the SRE
    community, this process is generally known as *binary differencing*. The goals
    may include identifying updates in different versions of a binary, identifying
    functions used by a malware family, identifying signatures, and so on. This functionality
    can be important given that the associated source code may not be available to
    allow for source-based diffing. Ghidra version tracking is discussed in more detail
    in [Chapter 23](ch23.xhtml#ch23).
  prefs: []
  type: TYPE_NORMAL
- en: '***Version Control***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Version control* is an important concept in any system where changes can be
    made by multiple users or a recorded history of changes is desirable. Version
    control allows you to manage updates to the system, effectively controlling race
    conditions. The Project window has a version control toolbar ([Figure 11-13](ch11.xhtml#fig11_13)).
    Many of the operations require that the file(s) in question be closed in order
    to complete the action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-13: Ghidra Project window version control toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: The icons are enabled for valid version control operations based on the selected
    file(s). The basic actions that make up the version control workflow are shown
    in [Figure 11-14](ch11.xhtml#fig11_14). (We have included a column that provides
    the rough Git equivalents for all the Git fans.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-14: Ghidra version control toolbar actions*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using the toolbar icons, you can perform the version control
    actions via the right-click context menu.
  prefs: []
  type: TYPE_NORMAL
- en: '**Merging Files**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When a collaborative team member decides to check in changes they have made
    to the project, one of two conditions will be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No conflict** In this case, no new versions of the file have been checked
    in since the user checked out the file. Since no potential conflict exists (no
    committed, conflicting changes that the user is not already aware of), the file
    that is being checked in will become the new version of the file. The old version
    will be retained in an archival fashion and the version number incremented to
    ensure that a continuous chain of versions can be tracked.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Potential conflict** In this case, another user has committed new changes
    while the user had the file checked out. The order in which the files are checked
    in can affect the resulting “current version.” In this case, Ghidra begins a merge
    process. If no conflicts are introduced by the submissions, Ghidra continues with
    its automatic merge process. If conflicts are detected, each must be manually
    resolved by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example of a conflict, assume that *user1* and *user2* both have the same
    file checked out and that *user2* changes the name of `FUN_00123456` to `hash_something`
    and checks in their change. Meanwhile, *user1* analyzes the same function and
    renames it to `compute_hash`. When *user1* finally checks their changes in (after
    *user2*), they will be informed of a naming conflict and will be asked to choose
    the correct name of the function, between `hash``_something` and `compute_hash`,
    before the check-in operation may be completed. Additional information about this
    process can be found in Ghidra Help.
  prefs: []
  type: TYPE_NORMAL
- en: '**VERSION CONTROL COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: When you add or modify a file under version control, you should add a comment
    explaining what you’ve done. Each version control action displays a dialog with
    a comment field and special options. [Figure 11-15](ch11.xhtml#fig11_15) shows
    the Add File to Version Control comment dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig11-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-15: Ghidra’s Add File to Version Control comment dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: The title bar displays the action being performed and is supplemented below
    by the associated icon as well as a description of what you should be entering
    in the Comments text box. If more than one file has been selected, any comments
    will be associated with only the first file unless the Apply to All button is
    clicked. Below the Comments text box are specific options associated with the
    action being performed that the user can select or deselect. See the third column
    of [Figure 11-14](ch11.xhtml#fig11_14) for the special options for each of the
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Example Scenario***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A lot of intricacies, options, and overloaded terminology are associated with
    shared projects. To clarify some of the concepts associated with Ghidra Server
    and shared projects, let’s walk through an example that demonstrates the concepts
    we have been discussing, starting with the concept of a project.
  prefs: []
  type: TYPE_NORMAL
- en: A *project* is the local entity that lives on the client machine (like a local
    Git repo). Shared projects are also associated with a repository on a Ghidra Server
    (like a Git remote), and that repository is where all of the collaborative analysis
    effort results are stored. Files are shared after they have been imported and
    added to version control, and are private before that. Therefore, a user can import
    files into a project, at which point they are private, and then choose to add
    them to version control, at which point they are shared.
  prefs: []
  type: TYPE_NORMAL
- en: '**HELP! MY FILE HAS BEEN HIJACKED!**'
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra has a special term (and associated Project Data Tree icon) for a situation
    that can frequently occur in a shared project environment. If you have a private
    file (imported but not yet added to version control) in your project *and* another
    user adds a file of the same name to the repository, your file will be *hijacked*!
    This is such a frequent occurrence that Ghidra provides a right-click context
    menu option to handle the situation. You will need to close the hijacked file
    and then select the Undo Hijack option from the context menu. This will provide
    you with the option to accept the file in the repository and keep a copy of your
    own file, if desired. Other options for resolving a hijack include renaming the
    file, moving it to another project, and deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, project permissions are really repository permissions. If you create
    a project using an existing repository, you’re really saying, “This project locally
    is backed remotely by that repository on the server” (like a Git clone). Let’s
    walk through a sequence of shared project activities and observe how they affect
    the shared project environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '*user1* creates a new shared project (and associated new repository) called
    *CH11-Example*, adds *user2* and *user3*, and assigns them permissions (see [Figure
    11-16](ch11.xhtml#fig11_16)).![image](Images/fig11-16.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-16: Example scenario, step 1*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user2* creates a new shared project associated with the existing *CH11-Example*
    repository (that is, *user2* clones *CH11-Example*). Note that the project is
    not the same name as *user1*’s project, but the repository (remote) is the same.
    In addition, *user2*’s permissions for the repository are shown at the bottom
    of the window (see [Figure 11-17](ch11.xhtml#fig11_17)).![image](Images/fig11-17.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-17: Example scenario, step 2*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user1* imports a file and adds it to version control, which *user2* can then
    also see (roughly equivalent to `git add`/`commit`/`push`). This is shown in [Figure
    11-18](ch11.xhtml#fig11_18).![image](Images/fig11-18.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-18: Example scenario, step 3*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user1* and *user2* then each import the same file to their projects but don’t
    add them to version control. These are private files (see [Figure 11-19](ch11.xhtml#fig11_19)).![image](Images/fig11-19.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-19: Example scenario, step 4*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user2* adds this second file to version control (which checks it in). As a
    result, the file is no longer private. *user1* now sees this as a hijacked file
    (see [Figure 11-20](ch11.xhtml#fig11_20)).![image](Images/fig11-20.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-20: Example scenario, step 5*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user1* chooses Undo Hijack from the right-click context menu and has the option
    to replace her file with the version in the repository and keep a copy of her
    own file if desired. She chooses to accept the repository version and to keep
    a copy of her own file (which she has moved to another project, and it now has
    the extension *.keep*). Now everything is good again. In this case, *user1* is
    now seeing the state of the second file as it was when *user2* added it to version
    control (see [Figure 11-21](ch11.xhtml#fig11_21)).![image](Images/fig11-21.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-21: Example scenario, step 6*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user1* checks out the second file, analyzes it, and then checks it in. Both
    *user1* and *user2* now see the analyzed version of the file (version 2), as shown
    in [Figure 11-22](ch11.xhtml#fig11_22).![image](Images/fig11-22.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-22: Example scenario, step 7*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user3* creates a project and associates it with the same repository (see [Figure
    11-23](ch11.xhtml#fig11_23)). *user3* can now see all of the files and can make
    changes locally (including adding private files), but has no option to commit
    to the repository, because she was not given write permissions. (The project is
    noted as “Read Only” at the bottom of the window.)![image](Images/fig11-23.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11-23: Example scenario, step 8*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*user2* checks in all of her files before leaving work. This is important because
    she knows that she wants to continue working on her project by using her home
    computer. Because the project does not exist on her home computer, she needs to
    log in to the Ghidra Server and create a new project by using the existing repository.
    This will create the project on her home computer, where she can continue working.
    (Had she not checked in all of her files before leaving work, she would not have
    access to her latest work while at home.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining users go home confident that their collaborative Ghidra Server
    is working as intended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not everyone will require a Ghidra Server or shared projects to facilitate collaborative
    reverse engineering, but many of the associated capabilities can also be applied
    to nonshared projects. The remaining chapters focus on nonshared projects, with
    references to shared projects and Ghidra Server when appropriate. Regardless of
    the configuration of your Ghidra installation, there is a good chance the default
    configurations, tools, and views may not be perfect for your workflow. The next
    chapter focuses on Ghidra configurations, tools, and workspaces and how you can
    make them work better for you.
  prefs: []
  type: TYPE_NORMAL
