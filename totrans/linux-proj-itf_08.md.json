["```\nmtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash\n```", "```\nusers:x:100:\njambit:x:106:claus,felli,frank,harti,markus,martin,mtk,paul\n```", "```\navr:x:1001:100:Anthony Robins:/home/avr:/bin/bash\n```", "```\nusers:x:100:\nstaff:x:101:mtk,avr,martinl\nteach:x:104:avr,rlb,alc\n```", "```\n#include <pwd.h>\n\nstruct passwd *`getpwnam`(const char **name*);\nstruct passwd *`getpwuid`(uid_t *uid*);\n```", "```\nstruct passwd {\n    char *pw_name;      /* Login name (username) */\n    char *pw_passwd;    /* Encrypted password */\n    uid_t pw_uid;       /* User ID */\n    gid_t pw_gid;       /* Group ID */\n    char *pw_gecos;     /* Comment (user information) */\n    char *pw_dir;       /* Initial working (home) directory */\n    char *pw_shell;     /* Login shell */\n};\n```", "```\nstruct passwd *pwd;\n\nerrno = 0;\npwd = getpwnam(name);\nif (pwd == NULL) {\n    if (errno == 0)\n        /* Not found */;\n    else\n        /* Error */;\n }\n```", "```\n#include <grp.h>\nstruct group *`getgrnam`(const char **name*);\nstruct group *`getgrgid`(gid_t *gid*);\n```", "```\nstruct group {\n    char  *gr_name;     /* Group name */\n    char  *gr_passwd;   /* Encrypted password (if not password shadowing) */\n    gid_t  gr_gid;      /* Group ID */\n    char **gr_mem;      /* NULL-terminated array of pointers to names\n                           of members listed in /etc/group */\n};\n```", "```\n`users_groups/ugid_functions.c`\n#include <pwd.h>\n#include <grp.h>\n#include <ctype.h>\n#include \"ugid_functions.h\"     /* Declares functions defined here */\n\nchar *          /* Return name corresponding to 'uid', or NULL on error */\nuserNameFromId(uid_t uid)\n{\n    struct passwd *pwd;\n\n    pwd = getpwuid(uid);\n    return (pwd == NULL) ? NULL : pwd->pw_name;\n}\n\nuid_t           /* Return UID corresponding to 'name', or -1 on error */\nuserIdFromName(const char *name)\n{\n    struct passwd *pwd;\n    uid_t u;\n    char *endptr;\n\n    if (name == NULL || *name == '\\0')  /* On NULL or empty string */\n        return -1;                      /* return an error */\n\n    u = strtol(name, &endptr, 10);      /* As a convenience to caller */\n    if (*endptr == '\\0')                /* allow a numeric string */\n        return u;\n\n    pwd = getpwnam(name);\n    if (pwd == NULL)\n        return -1;\n\n    return pwd->pw_uid;\n}\n\nchar *          /* Return name corresponding to 'gid', or NULL on error */\ngroupNameFromId(gid_t gid)\n{\n    struct group *grp;\n\n    grp = getgrgid(gid);\n    return (grp == NULL) ? NULL : grp->gr_name;\n}\n\ngid_t           /* Return GID corresponding to 'name', or -1 on error */\ngroupIdFromName(const char *name)\n{\n    struct group *grp;\n    gid_t g;\n    char *endptr;\n\n    if (name == NULL || *name == '\\0')  /* On NULL or empty string */\n        return -1;                      /* return an error */\n\n    g = strtol(name, &endptr, 10);      /* As a convenience to caller */\n    if (*endptr == '\\0')                /* allow a numeric string */\n        return g;\n\n    grp = getgrnam(name);\n    if (grp == NULL)\n        return -1;\n\n    return grp->gr_gid;\n}\n     `users_groups/ugid_functions.c`\n```", "```\n#include <pwd.h>\n\nstruct passwd *`getpwent`(void);\n```", "```\nvoid `setpwent`(void);\nvoid `endpwent`(void);\n```", "```\nstruct passwd *pwd;\n\nwhile ((pwd = getpwent()) != NULL)\n    printf(\"%-8s %5ld\\n\", pwd->pw_name, (long) pwd->pw_uid);\n\nendpwent();\n```", "```\n#include <shadow.h>\n\nstruct spwd *`getspnam`(const char **name*);\n```", "```\nstruct spwd *`getspent`(void);\n```", "```\nvoid `setspent`(void);\nvoid `endspent`(void);\n```", "```\nstruct spwd {\n    char *sp_namp;          /* Login name (username) */\n    char *sp_pwdp;          /* Encrypted password */\n\n    /* Remaining fields support \"password aging\", an optional\n       feature that forces users to regularly change their\n       passwords, so that even if an attacker manages to obtain\n       a password, it will eventually cease to be usable. */\n\n    long sp_lstchg;         /* Time of last password change\n                               (days since 1 Jan 1970) */\n    long sp_min;            /* Min. number of days between password changes */\n    long sp_max;            /* Max. number of days before change required */\n    long sp_warn;           /* Number of days beforehand that user is\n                               warned of upcoming password expiration */\n    long sp_inact;          /* Number of days after expiration that account\n                               is considered inactive and locked */\n    long sp_expire;         /* Date when account expires\n                               (days since 1 Jan 1970) */\n    unsigned long sp_flag;  /* Reserved for future use */\n};\n```", "```\n#define _XOPEN_SOURCE\n#include <unistd.h>\n\nchar *`crypt`(const char **key*, const char **salt*);\n```", "```\n#define _BSD_SOURCE\n#include <unistd.h>\nchar *`getpass`(const char **prompt*);\n```", "```\n$ `su`                            *Need privilege to read shadow password file*\n\nPassword:\n# `./check_password`\n\nUsername: `mtk`\n\nPassword:                       *We type in password, which is not echoed*\n\nSuccessfully authenticated: UID=1000\n```", "```\n`users_groups/check_password.c`\n#define _BSD_SOURCE     /* Get getpass() declaration from <unistd.h> */\n#define _XOPEN_SOURCE   /* Get crypt() declaration from <unistd.h> */\n#include <unistd.h>\n#include <limits.h>\n#include <pwd.h>\n#include <shadow.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    char *username, *password, *encrypted, *p;\n    struct passwd *pwd;\n    struct spwd *spwd;\n    Boolean authOk;\n    size_t len;\n    long lnmax;\n\n    lnmax = sysconf(_SC_LOGIN_NAME_MAX);\n    if (lnmax == -1)                    /* If limit is indeterminate */\n        lnmax = 256;                    /* make a guess */\n\n    username = malloc(lnmax);\n    if (username == NULL)\n        errExit(\"malloc\");\n\n    printf(\"Username: \");\n    fflush(stdout);\n    if (fgets(username, lnmax, stdin) == NULL)\n        exit(EXIT_FAILURE);             /* Exit on EOF */\n\n    len = strlen(username);\n    if (username[len - 1] == '\\n')\n        username[len - 1] = '\\0';       /* Remove trailing '\\n' */\n\n    pwd = getpwnam(username);\n    if (pwd == NULL)\n        fatal(\"couldn't get password record\");\n    spwd = getspnam(username);\n    if (spwd == NULL && errno == EACCES)\n        fatal(\"no permission to read shadow password file\");\n\n    if (spwd != NULL)           /* If there is a shadow password record */\n        pwd->pw_passwd = spwd->sp_pwdp;     /* Use the shadow password */\n\n    password = getpass(\"Password: \");\n\n    /* Encrypt password and erase cleartext version immediately */\n\n    encrypted = crypt(password, pwd->pw_passwd);\n    for (p = password; *p != '\\0'; )\n        *p++ = '\\0';\n\n    if (encrypted == NULL)\n        errExit(\"crypt\");\n\n    authOk = strcmp(encrypted, pwd->pw_passwd) == 0;\n    if (!authOk) {\n        printf(\"Incorrect password\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Successfully authenticated: UID=%ld\\n\", (long) pwd->pw_uid);\n\n    /* Now do authenticated work... */\n\n    exit(EXIT_SUCCESS);\n}\n     `users_groups/check_password.c`\n```", "```\n    printf(\"%ld %ld\\n\", (long) (getpwnam(\"avr\")->pw_uid),\n                        (long) (getpwnam(\"tsr\")->pw_uid));\n    ```"]